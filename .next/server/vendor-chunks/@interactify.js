"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@interactify";
exports.ids = ["vendor-chunks/@interactify"];
exports.modules = {

/***/ "(ssr)/./node_modules/@interactify/selection/dist/selecto.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@interactify/selection/dist/selecto.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLASS_NAME: () => (/* binding */ CLASS_NAME),\n/* harmony export */   EVENTS: () => (/* binding */ EVENTS),\n/* harmony export */   METHODS: () => (/* binding */ METHODS),\n/* harmony export */   OPTIONS: () => (/* binding */ OPTIONS),\n/* harmony export */   OPTION_TYPES: () => (/* binding */ OPTION_TYPES),\n/* harmony export */   PROPERTIES: () => (/* binding */ PROPERTIES),\n/* harmony export */   \"default\": () => (/* binding */ Selecto)\n/* harmony export */ });\n/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @scena/event-emitter */ \"(ssr)/./node_modules/@scena/event-emitter/dist/event-emitter.esm.js\");\n/* harmony import */ var gesto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! gesto */ \"(ssr)/./node_modules/gesto/dist/gesto.esm.js\");\n/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! framework-utils */ \"(ssr)/./node_modules/framework-utils/dist/utils.esm.js\");\n/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @daybrush/utils */ \"(ssr)/./node_modules/@daybrush/utils/dist/utils.esm.js\");\n/* harmony import */ var _egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @egjs/children-differ */ \"(ssr)/./node_modules/@egjs/children-differ/dist/children-differ.esm.js\");\n/* harmony import */ var _scena_dragscroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scena/dragscroll */ \"(ssr)/./node_modules/@scena/dragscroll/dist/dragscroll.esm.js\");\n/* harmony import */ var keycon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! keycon */ \"(ssr)/./node_modules/keycon/dist/keycon.esm.js\");\n/* harmony import */ var overlap_area__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! overlap-area */ \"(ssr)/./node_modules/overlap-area/dist/overlap-area.esm.js\");\n/* harmony import */ var css_to_mat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! css-to-mat */ \"(ssr)/./node_modules/css-to-mat/dist/css-to-mat.esm.js\");\n/* harmony import */ var css_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! css-styled */ \"(ssr)/./node_modules/css-styled/dist/styled.esm.js\");\n/*\nCopyright (c) 2020 Daybrush\nname: @interactify/selection\nlicense: MIT\nauthor: \nrepository: git+https://github.com/designcombo/interactiy.git\nversion: 0.0.2\n*/\n\n\n\n\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nfunction getClient(e) {\n    if (\"touches\" in e) {\n        var touch = e.touches[0] || e.changedTouches[0];\n        return {\n            clientX: touch.clientX,\n            clientY: touch.clientY,\n        };\n    }\n    else {\n        return {\n            clientX: e.clientX,\n            clientY: e.clientY,\n        };\n    }\n}\nfunction filterDuplicated(arr) {\n    if (typeof Map === \"undefined\") {\n        return arr.filter(function (value, index) {\n            return arr.indexOf(value) === index;\n        });\n    }\n    var map = new Map();\n    return arr.filter(function (value) {\n        if (map.has(value)) {\n            return false;\n        }\n        map.set(value, true);\n        return true;\n    });\n}\nfunction elementFromPoint(baseNode, clientX, clientY) {\n    var doc = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(baseNode);\n    return (doc.elementFromPoint && doc.elementFromPoint(clientX, clientY)) || null;\n}\nfunction createElement(jsx, prevTarget, container) {\n    var tag = jsx.tag, children = jsx.children, attributes = jsx.attributes, className = jsx.className, style = jsx.style;\n    var el = prevTarget || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(container).createElement(tag);\n    for (var name_1 in attributes) {\n        el.setAttribute(name_1, attributes[name_1]);\n    }\n    var elChildren = el.children;\n    children.forEach(function (child, i) {\n        createElement(child, elChildren[i], el);\n    });\n    if (className) {\n        className.split(/\\s+/g).forEach(function (name) {\n            if (name && !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(el, name)) {\n                (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addClass)(el, name);\n            }\n        });\n    }\n    if (style) {\n        var elStyle = el.style;\n        for (var name_2 in style) {\n            elStyle[name_2] = style[name_2];\n        }\n    }\n    if (!prevTarget && container) {\n        container.appendChild(el);\n    }\n    return el;\n}\nfunction h(tag, attrs) {\n    var children = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        children[_i - 2] = arguments[_i];\n    }\n    var _a = attrs || {}, _b = _a.className, className = _b === void 0 ? \"\" : _b, _c = _a.style, style = _c === void 0 ? {} : _c, attributes = __rest(_a, [\"className\", \"style\"]);\n    return {\n        tag: tag,\n        className: className,\n        style: style,\n        attributes: attributes,\n        children: children,\n    };\n}\nfunction diffValue(prev, cur, func) {\n    if (prev !== cur) {\n        func(prev, cur);\n    }\n}\nfunction getRect(e, ratio, boundArea) {\n    var _a;\n    if (boundArea === void 0) { boundArea = e.data.boundArea; }\n    var _b = e.distX, distX = _b === void 0 ? 0 : _b, _c = e.distY, distY = _c === void 0 ? 0 : _c;\n    var _d = e.data, startX = _d.startX, startY = _d.startY;\n    if (ratio > 0) {\n        var nextHeight = Math.sqrt((distX * distX + distY * distY) / (1 + ratio * ratio));\n        var nextWidth = ratio * nextHeight;\n        distX = (distX >= 0 ? 1 : -1) * nextWidth;\n        distY = (distY >= 0 ? 1 : -1) * nextHeight;\n    }\n    var width = Math.abs(distX);\n    var height = Math.abs(distY);\n    var maxWidth = distX < 0 ? startX - boundArea.left : boundArea.right - startX;\n    var maxHeight = distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;\n    _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.calculateBoundSize)([width, height], [0, 0], [maxWidth, maxHeight], !!ratio), width = _a[0], height = _a[1];\n    distX = (distX >= 0 ? 1 : -1) * width;\n    distY = (distY >= 0 ? 1 : -1) * height;\n    var tx = Math.min(0, distX);\n    var ty = Math.min(0, distY);\n    var left = startX + tx;\n    var top = startY + ty;\n    return {\n        left: left,\n        top: top,\n        right: left + width,\n        bottom: top + height,\n        width: width,\n        height: height,\n    };\n}\nfunction getDefaultElementRect(el) {\n    var rect = el.getBoundingClientRect();\n    var left = rect.left, top = rect.top, width = rect.width, height = rect.height;\n    return {\n        pos1: [left, top],\n        pos2: [left + width, top],\n        pos3: [left, top + height],\n        pos4: [left + width, top + height],\n    };\n}\nfunction passTargets(beforeTargets, afterTargets, continueSelectWithoutDeselect) {\n    var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(beforeTargets, afterTargets), list = _a.list, prevList = _a.prevList, added = _a.added, removed = _a.removed, maintained = _a.maintained;\n    return __spreadArray(__spreadArray(__spreadArray([], added.map(function (index) { return list[index]; }), true), removed.map(function (index) { return prevList[index]; }), true), continueSelectWithoutDeselect ? maintained.map(function (_a) {\n        var nextIndex = _a[1];\n        return list[nextIndex];\n    }) : [], true);\n}\nfunction getLineSize(points) {\n    var size = 0;\n    var length = points.length;\n    for (var i = 1; i < length; ++i) {\n        size = Math.max((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(points[i], points[i - 1]), size);\n    }\n    return size;\n}\n\nvar injector = (0,css_styled__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"\\n:host {\\n    position: fixed;\\n    display: none;\\n    border: 1px solid #4af;\\n    background: rgba(68, 170, 255, 0.5);\\n    pointer-events: none;\\n    will-change: transform;\\n    z-index: 100;\\n}\\n\");\n/**\n * @memberof Selecto\n */\nvar CLASS_NAME = \"selecto-selection \".concat(injector.className);\nvar PROPERTIES = [\n    \"className\",\n    \"boundContainer\",\n    \"selectableTargets\",\n    \"selectByClick\",\n    \"selectFromInside\",\n    \"continueSelect\",\n    \"continueSelectWithoutDeselect\",\n    \"toggleContinueSelect\",\n    \"toggleContinueSelectWithoutDeselect\",\n    \"keyContainer\",\n    \"hitRate\",\n    \"scrollOptions\",\n    \"checkInput\",\n    \"preventDefault\",\n    \"ratio\",\n    \"getElementRect\",\n    \"preventDragFromInside\",\n    \"rootContainer\",\n    \"dragCondition\",\n    \"clickBySelectEnd\",\n    \"checkOverflow\",\n    \"innerScrollOptions\",\n];\n/**\n * @memberof Selecto\n */\nvar OPTIONS = __spreadArray([\n    // ignore target, container,\n    \"dragContainer\",\n    \"cspNonce\",\n    \"preventClickEventOnDrag\",\n    \"preventClickEventOnDragStart\",\n    \"preventRightClick\"\n], PROPERTIES, true);\nvar OPTION_TYPES = {\n    className: String,\n    boundContainer: null,\n    portalContainer: null,\n    container: null,\n    dragContainer: null,\n    selectableTargets: Array,\n    selectByClick: Boolean,\n    selectFromInside: Boolean,\n    continueSelect: Boolean,\n    toggleContinueSelect: Array,\n    toggleContinueSelectWithoutDeselect: Array,\n    keyContainer: null,\n    hitRate: Number,\n    scrollOptions: Object,\n    checkInput: Boolean,\n    preventDefault: Boolean,\n    cspNonce: String,\n    ratio: Number,\n    getElementRect: Function,\n    preventDragFromInside: Boolean,\n    rootContainer: Object,\n    dragCondition: Function,\n    clickBySelectEnd: Boolean,\n    continueSelectWithoutDeselect: Boolean,\n    preventClickEventOnDragStart: Boolean,\n    preventClickEventOnDrag: Boolean,\n    checkOverflow: Boolean,\n    innerScrollOptions: Object,\n};\n/**\n * @memberof Selecto\n */\nvar EVENTS = [\n    \"dragStart\",\n    \"drag\",\n    \"dragEnd\",\n    \"selectStart\",\n    \"select\",\n    \"selectEnd\",\n    \"keydown\",\n    \"keyup\",\n    \"scroll\",\n    \"innerScroll\",\n];\n/**\n * @memberof Selecto\n */\nvar METHODS = [\n    \"clickTarget\",\n    \"getSelectableElements\",\n    \"setSelectedTargets\",\n    \"getElementPoints\",\n    \"getSelectedTargets\",\n    \"findSelectableTargets\",\n    \"triggerDragStart\",\n    \"checkScroll\",\n    \"selectTargetsByPoints\",\n    \"setSelectedTargetsByPoints\",\n];\n\n/**\n * Selecto.js is a component that allows you to select elements in the drag area using the mouse or touch.\n * @sort 1\n * @extends EventEmitter\n */\nvar Selecto$1 = /*#__PURE__*/ (function (_super) {\n    __extends(Selecto, _super);\n    /**\n     *\n     */\n    function Selecto(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this.selectedTargets = [];\n        _this.dragScroll = new _scena_dragscroll__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n        _this._onDragStart = function (e, clickedTarget) {\n            var data = e.data, clientX = e.clientX, clientY = e.clientY, inputEvent = e.inputEvent;\n            var _a = _this.options, selectFromInside = _a.selectFromInside, selectByClick = _a.selectByClick, rootContainer = _a.rootContainer, boundContainer = _a.boundContainer, _b = _a.preventDragFromInside, preventDragFromInside = _b === void 0 ? true : _b, clickBySelectEnd = _a.clickBySelectEnd, dragCondition = _a.dragCondition;\n            if (dragCondition && !dragCondition(e)) {\n                e.stop();\n                return;\n            }\n            data.data = {};\n            var win = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)(_this.container);\n            data.innerWidth = win.innerWidth;\n            data.innerHeight = win.innerHeight;\n            _this.findSelectableTargets(data);\n            data.startSelectedTargets = _this.selectedTargets;\n            data.scaleMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.createMatrix)();\n            data.containerX = 0;\n            data.containerY = 0;\n            var container = _this.container;\n            var boundArea = {\n                left: -Infinity,\n                top: -Infinity,\n                right: Infinity,\n                bottom: Infinity,\n            };\n            if (rootContainer) {\n                var containerRect = _this.container.getBoundingClientRect();\n                data.containerX = containerRect.left;\n                data.containerY = containerRect.top;\n                data.scaleMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.getDistElementMatrix)(_this.container, rootContainer);\n            }\n            if (boundContainer) {\n                var boundInfo = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(boundContainer) && \"element\" in boundContainer\n                    ? __assign({ left: true, top: true, bottom: true, right: true }, boundContainer) : {\n                    element: boundContainer,\n                    left: true,\n                    top: true,\n                    bottom: true,\n                    right: true,\n                };\n                var boundElement = boundInfo.element;\n                var rectElement = void 0;\n                if (boundElement) {\n                    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(boundElement)) {\n                        rectElement = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(container).querySelector(boundElement);\n                    }\n                    else if (boundElement === true) {\n                        rectElement = _this.container;\n                    }\n                    else {\n                        rectElement = boundElement;\n                    }\n                    var rect = rectElement.getBoundingClientRect();\n                    if (boundInfo.left) {\n                        boundArea.left = rect.left;\n                    }\n                    if (boundInfo.top) {\n                        boundArea.top = rect.top;\n                    }\n                    if (boundInfo.right) {\n                        boundArea.right = rect.right;\n                    }\n                    if (boundInfo.bottom) {\n                        boundArea.bottom = rect.bottom;\n                    }\n                }\n            }\n            data.boundArea = boundArea;\n            var hitRect = {\n                left: clientX,\n                top: clientY,\n                right: clientX,\n                bottom: clientY,\n                width: 0,\n                height: 0,\n            };\n            var firstPassedTargets = [];\n            // allow click on select\n            var allowClickBySelectEnd = selectByClick && !clickBySelectEnd;\n            var hasInsideTargets = false;\n            if (!selectFromInside || allowClickBySelectEnd) {\n                var pointTarget = _this._findElement(clickedTarget || inputEvent.target, // elementFromPoint(clientX, clientY),\n                data.selectableTargets);\n                hasInsideTargets = !!pointTarget;\n                if (allowClickBySelectEnd) {\n                    firstPassedTargets = pointTarget ? [pointTarget] : [];\n                }\n            }\n            var isPreventSelect = !selectFromInside && hasInsideTargets;\n            // prevent drag from inside when selectByClick is false\n            if (isPreventSelect && !selectByClick) {\n                e.stop();\n                return false;\n            }\n            var type = inputEvent.type;\n            var isTrusted = type === \"mousedown\" || type === \"touchstart\";\n            /**\n             * When the drag starts (triggers on mousedown or touchstart), the dragStart event is called.\n             * Call the stop () function if you have a specific element or don't want to raise a select\n             * @memberof Selecto\n             * @event dragStart\n             * @param {OnDragStart} - Parameters for the dragStart event\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   selectByClick: true,\n             *   selectFromInside: false,\n             * });\n             *\n             * selecto.on(\"dragStart\", e => {\n             *   if (e.inputEvent.target.tagName === \"SPAN\") {\n             *     e.stop();\n             *   }\n             * }).on(\"select\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            var result = !(e).isClick && isTrusted\n                ? _this.emit(\"dragStart\", __assign(__assign({}, e), { data: data.data }))\n                : true;\n            if (!result) {\n                e.stop();\n                return false;\n            }\n            if (_this.continueSelect) {\n                firstPassedTargets = passTargets(_this.selectedTargets, firstPassedTargets, _this.continueSelectWithoutDeselect);\n                data.startPassedTargets = _this.selectedTargets;\n            }\n            else {\n                data.startPassedTargets = [];\n            }\n            _this._select(firstPassedTargets, hitRect, e, true, isPreventSelect && selectByClick && !clickBySelectEnd && preventDragFromInside);\n            data.startX = clientX;\n            data.startY = clientY;\n            data.selectFlag = false;\n            data.preventDragFromInside = false;\n            if (inputEvent.target) {\n                var offsetPos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(data.scaleMatrix, [\n                    clientX - data.containerX,\n                    clientY - data.containerY,\n                ]);\n                _this.target.style.cssText += \"position: \".concat(rootContainer ? \"absolute\" : \"fixed\", \";\")\n                    + \"left:0px;top:0px;\"\n                    + \"transform: translate(\".concat(offsetPos[0], \"px, \").concat(offsetPos[1], \"px)\");\n            }\n            if (isPreventSelect && selectByClick && !clickBySelectEnd) {\n                inputEvent.preventDefault();\n                // prevent drag from inside when selectByClick is true and force call `selectEnd`\n                if (preventDragFromInside) {\n                    _this._selectEnd(data.startSelectedTargets, data.startPassedTargets, hitRect, e, true);\n                    data.preventDragFromInside = true;\n                }\n            }\n            else {\n                data.selectFlag = true;\n                // why?\n                // if (type === \"touchstart\") {\n                //     inputEvent.preventDefault();\n                // }\n                var _c = _this.options, scrollOptions = _c.scrollOptions, innerScrollOptions = _c.innerScrollOptions;\n                var isInnerScroll = false;\n                if (innerScrollOptions) {\n                    var inputEvent_1 = e.inputEvent;\n                    var target = inputEvent_1.target;\n                    var innerScrollElement = null;\n                    var parentElement = target;\n                    while (parentElement && parentElement !== (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(container).body) {\n                        var overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n                        if (overflow) {\n                            innerScrollElement = parentElement;\n                            break;\n                        }\n                        parentElement = parentElement.parentElement;\n                    }\n                    if (innerScrollElement) {\n                        data.innerScrollOptions = __assign({ container: innerScrollElement, checkScrollEvent: true }, (innerScrollOptions === true ? {} : innerScrollOptions));\n                        _this.dragScroll.dragStart(e, data.innerScrollOptions);\n                        isInnerScroll = true;\n                    }\n                }\n                if (!isInnerScroll && scrollOptions && scrollOptions.container) {\n                    _this.dragScroll.dragStart(e, scrollOptions);\n                }\n                if (isPreventSelect && selectByClick && clickBySelectEnd) {\n                    data.selectFlag = false;\n                    e.preventDrag();\n                }\n            }\n            return true;\n        };\n        _this._onDrag = function (e) {\n            if (e.data.selectFlag) {\n                var scrollOptions = _this.scrollOptions;\n                var innerScrollOptions = e.data.innerScrollOptions;\n                var hasScrollOptions = innerScrollOptions || (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.container);\n                // If it is a scrolling position, pass drag\n                if (hasScrollOptions && !e.isScroll && _this.dragScroll.drag(e, innerScrollOptions || scrollOptions)) {\n                    return;\n                }\n            }\n            _this._checkSelected(e);\n        };\n        _this._onDragEnd = function (e) {\n            var data = e.data, inputEvent = e.inputEvent;\n            var rect = getRect(e, _this.options.ratio);\n            var selectFlag = data.selectFlag;\n            var container = _this.container;\n            /**\n             * When the drag ends (triggers on mouseup or touchend after drag), the dragEnd event is called.\n             * @memberof Selecto\n             * @event dragEnd\n             * @param {OnDragEnd} - Parameters for the dragEnd event\n             */\n            if (inputEvent) {\n                _this.emit(\"dragEnd\", __assign(__assign({ isDouble: !!e.isDouble, isClick: !!e.isClick, isDrag: false, isSelect: selectFlag }, e), { data: data.data, rect: rect }));\n            }\n            _this.target.style.cssText += \"display: none;\";\n            if (selectFlag) {\n                data.selectFlag = false;\n                _this.dragScroll.dragEnd();\n            }\n            else if (_this.selectByClick && _this.clickBySelectEnd) {\n                // only clickBySelectEnd\n                var pointTarget = _this._findElement((inputEvent === null || inputEvent === void 0 ? void 0 : inputEvent.target) || elementFromPoint(container, e.clientX, e.clientY), data.selectableTargets);\n                _this._select(pointTarget ? [pointTarget] : [], rect, e);\n            }\n            if (!data.preventDragFromInside) {\n                _this._selectEnd(data.startSelectedTargets, data.startPassedTargets, rect, e);\n            }\n        };\n        _this._onKeyDown = function (e) {\n            var options = _this.options;\n            var isKeyDown = false;\n            if (!_this._keydownContinueSelect) {\n                var result = _this._sameCombiKey(e, options.toggleContinueSelect);\n                _this._keydownContinueSelect = result;\n                isKeyDown || (isKeyDown = result);\n            }\n            if (!_this._keydownContinueSelectWithoutDeselection) {\n                var result = _this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect);\n                _this._keydownContinueSelectWithoutDeselection = result;\n                isKeyDown || (isKeyDown = result);\n            }\n            if (!isKeyDown) {\n                return;\n            }\n            /**\n             * When you keydown the key you specified in toggleContinueSelect, the keydown event is called.\n             * @memberof Selecto\n             * @event keydown\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   toggleContinueSelect: \"shift\";\n             *   keyContainer: window,\n             * });\n             *\n             * selecto.on(\"keydown\", () => {\n             *   document.querySelector(\".button\").classList.add(\"selected\");\n             * }).on(\"keyup\", () => {\n             *   document.querySelector(\".button\").classList.remove(\"selected\");\n             * }).on(\"select\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            _this.emit(\"keydown\", {\n                keydownContinueSelect: _this._keydownContinueSelect,\n                keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection,\n            });\n        };\n        _this._onKeyUp = function (e) {\n            var options = _this.options;\n            var isKeyUp = false;\n            if (_this._keydownContinueSelect) {\n                var result = _this._sameCombiKey(e, options.toggleContinueSelect, true);\n                _this._keydownContinueSelect = !result;\n                isKeyUp || (isKeyUp = result);\n            }\n            if (_this._keydownContinueSelectWithoutDeselection) {\n                var result = _this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect, true);\n                _this._keydownContinueSelectWithoutDeselection = !result;\n                isKeyUp || (isKeyUp = result);\n            }\n            if (!isKeyUp) {\n                return;\n            }\n            /**\n             * When you keyup the key you specified in toggleContinueSelect, the keyup event is called.\n             * @memberof Selecto\n             * @event keyup\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   toggleContinueSelect: \"shift\";\n             *   keyContainer: window,\n             * });\n             *\n             * selecto.on(\"keydown\", () => {\n             *   document.querySelector(\".button\").classList.add(\"selected\");\n             * }).on(\"keyup\", () => {\n             *   document.querySelector(\".button\").classList.remove(\"selected\");\n             * }).on(\"select\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            _this.emit(\"keyup\", {\n                keydownContinueSelect: _this._keydownContinueSelect,\n                keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection,\n            });\n        };\n        _this._onBlur = function () {\n            if (_this._keydownContinueSelect || _this._keydownContinueSelectWithoutDeselection) {\n                _this._keydownContinueSelect = false;\n                _this._keydownContinueSelectWithoutDeselection = false;\n                _this.emit(\"keyup\", {\n                    keydownContinueSelect: _this._keydownContinueSelect,\n                    keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection,\n                });\n            }\n        };\n        _this._onDocumentSelectStart = function (e) {\n            var doc = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(_this.container);\n            if (!_this.gesto.isFlag()) {\n                return;\n            }\n            var dragContainer = _this.dragContainer;\n            if (dragContainer === (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)(_this.container)) {\n                dragContainer = doc.documentElement;\n            }\n            var containers = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isNode)(dragContainer)\n                ? [dragContainer]\n                : [].slice.call(dragContainer);\n            var target = e.target;\n            containers.some(function (container) {\n                if (container === target || container.contains(target)) {\n                    e.preventDefault();\n                    return true;\n                }\n            });\n        };\n        _this.target = options.portalContainer;\n        var container = options.container;\n        _this.options = __assign({ className: \"\", portalContainer: null, container: null, dragContainer: null, selectableTargets: [], selectByClick: true, selectFromInside: true, clickBySelectEnd: false, hitRate: 100, continueSelect: false, continueSelectWithoutDeselect: false, toggleContinueSelect: null, toggleContinueSelectWithoutDeselect: null, keyContainer: null, scrollOptions: null, checkInput: false, preventDefault: false, boundContainer: false, preventDragFromInside: true, dragCondition: null, rootContainer: null, checkOverflow: false, innerScrollOptions: false, getElementRect: getDefaultElementRect, cspNonce: \"\", ratio: 0 }, options);\n        var portalContainer = _this.options.portalContainer;\n        if (portalContainer) {\n            container = portalContainer.parentElement;\n        }\n        _this.container = container || document.body;\n        _this.initElement();\n        _this.initDragScroll();\n        _this.setKeyController();\n        return _this;\n    }\n    /**\n     * You can set the currently selected targets.\n     * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n     */\n    Selecto.prototype.setSelectedTargets = function (selectedTargets) {\n        var beforeSelected = this.selectedTargets;\n        var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(beforeSelected, selectedTargets), added = _a.added, removed = _a.removed, prevList = _a.prevList, list = _a.list;\n        this.selectedTargets = selectedTargets;\n        return {\n            added: added.map(function (index) { return list[index]; }),\n            removed: removed.map(function (index) { return prevList[index]; }),\n            beforeSelected: beforeSelected,\n            selected: selectedTargets,\n        };\n    };\n    /**\n     * You can set the currently selected targets by points\n     * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n     */\n    Selecto.prototype.setSelectedTargetsByPoints = function (point1, point2) {\n        var left = Math.min(point1[0], point2[0]);\n        var top = Math.min(point1[1], point2[1]);\n        var right = Math.max(point1[0], point2[0]);\n        var bottom = Math.max(point1[1], point2[1]);\n        var rect = {\n            left: left,\n            top: top,\n            right: right,\n            bottom: bottom,\n            width: right - left,\n            height: bottom - top,\n        };\n        var data = { ignoreClick: true };\n        this.findSelectableTargets(data);\n        var selectedElements = this.hitTest(rect, data, true, null);\n        var result = this.setSelectedTargets(selectedElements);\n        return __assign(__assign({}, result), { rect: rect });\n    };\n    /**\n     * Select target by virtual drag from startPoint to endPoint.\n     * The target of inputEvent is null.\n     */\n    Selecto.prototype.selectTargetsByPoints = function (startPoint, endPoint) {\n        var mousedown = new MouseEvent(\"mousedown\", {\n            clientX: startPoint[0],\n            clientY: startPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        var mousemove = new MouseEvent(\"mousemove\", {\n            clientX: endPoint[0],\n            clientY: endPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        var mouseup = new MouseEvent(\"mousemove\", {\n            clientX: endPoint[0],\n            clientY: endPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        var gesto = this.gesto;\n        var result = gesto.onDragStart(mousedown);\n        if (result !== false) {\n            gesto.onDrag(mousemove);\n            gesto.onDragEnd(mouseup);\n        }\n    };\n    /**\n     * You can get the currently selected targets.\n     */\n    Selecto.prototype.getSelectedTargets = function () {\n        return this.selectedTargets;\n    };\n    /**\n     * `OnDragStart` is triggered by an external event.\n     * @param - external event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto();\n     *\n     * window.addEventListener(\"mousedown\", e => {\n     *   selecto.triggerDragStart(e);\n     * });\n     */\n    Selecto.prototype.triggerDragStart = function (e) {\n        this.gesto.triggerDragStart(e);\n        return this;\n    };\n    /**\n     * Destroy elements, properties, and events.\n     */\n    Selecto.prototype.destroy = function () {\n        var _a;\n        this.off();\n        this.keycon && this.keycon.destroy();\n        this.gesto.unset();\n        this.injectResult.destroy();\n        this.dragScroll.dragEnd();\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(document, \"selectstart\", this._onDocumentSelectStart);\n        if (!this.options.portalContainer) {\n            (_a = this.target.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this.target);\n        }\n        this.keycon = null;\n        this.gesto = null;\n        this.injectResult = null;\n        this.target = null;\n        this.container = null;\n        this.options = null;\n    };\n    Selecto.prototype.getElementPoints = function (target) {\n        var getElementRect = this.getElementRect || getDefaultElementRect;\n        var info = getElementRect(target);\n        var points = [info.pos1, info.pos2, info.pos4, info.pos3];\n        if (getElementRect !== getDefaultElementRect) {\n            var rect = target.getBoundingClientRect();\n            return (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.fitPoints)(points, rect);\n        }\n        return points;\n    };\n    /**\n     * Get all elements set in `selectableTargets`.\n     */\n    Selecto.prototype.getSelectableElements = function () {\n        var container = this.container;\n        var selectableElements = [];\n        this.options.selectableTargets.forEach(function (target) {\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target)) {\n                var result = target();\n                if (result) {\n                    selectableElements.push.apply(selectableElements, [].slice.call(result));\n                }\n            }\n            else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isNode)(target)) {\n                selectableElements.push(target);\n            }\n            else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {\n                selectableElements.push(target.value || target.current);\n            }\n            else {\n                var elements = [].slice.call(((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(container)).querySelectorAll(target));\n                selectableElements.push.apply(selectableElements, elements);\n            }\n        });\n        return selectableElements;\n    };\n    /**\n     * If scroll occurs during dragging, you can manually call this method to check the position again.\n     */\n    Selecto.prototype.checkScroll = function () {\n        if (!this.gesto.isFlag()) {\n            return;\n        }\n        var scrollOptions = this.scrollOptions;\n        var innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n        var hasScrollOptions = innerScrollOptions || (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.container);\n        // If it is a scrolling position, pass drag\n        if (hasScrollOptions) {\n            this.dragScroll.checkScroll(__assign({ inputEvent: this.gesto.getCurrentEvent() }, (innerScrollOptions || scrollOptions)));\n        }\n    };\n    /**\n     * Find for selectableTargets again during drag event\n     * You can update selectable targets during an event.\n     */\n    Selecto.prototype.findSelectableTargets = function (data) {\n        var _this = this;\n        if (data === void 0) { data = this.gesto.getEventData(); }\n        var selectableTargets = this.getSelectableElements();\n        var selectablePoints = selectableTargets.map(function (target) { return _this.getElementPoints(target); });\n        data.selectableTargets = selectableTargets;\n        data.selectablePoints = selectablePoints;\n        data.selectableParentMap = null;\n        var options = this.options;\n        var hasIndexesMap = options.checkOverflow || options.innerScrollOptions;\n        var doc = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(this.container);\n        if (hasIndexesMap) {\n            var parentMap_1 = new Map();\n            data.selectableInnerScrollParentMap = parentMap_1;\n            data.selectableInnerScrollPathsList = selectableTargets.map(function (target, index) {\n                var parentElement = target.parentElement;\n                var parents = [];\n                var paths = [];\n                var _loop_1 = function () {\n                    var info = parentMap_1.get(parentElement);\n                    if (!info) {\n                        var overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n                        if (overflow) {\n                            var rect = getDefaultElementRect(parentElement);\n                            info = {\n                                parentElement: parentElement,\n                                indexes: [],\n                                points: [rect.pos1, rect.pos2, rect.pos4, rect.pos3],\n                                paths: __spreadArray([], paths, true),\n                            };\n                            parents.push(parentElement);\n                            parents.forEach(function (prevParentElement) {\n                                parentMap_1.set(prevParentElement, info);\n                            });\n                            parents = [];\n                        }\n                    }\n                    if (info) {\n                        parentElement = info.parentElement;\n                        parentMap_1.get(parentElement).indexes.push(index);\n                        paths.push(parentElement);\n                    }\n                    else {\n                        parents.push(parentElement);\n                    }\n                    parentElement = parentElement.parentElement;\n                };\n                while (parentElement && parentElement !== doc.body) {\n                    _loop_1();\n                }\n                return paths;\n            });\n        }\n        if (!options.checkOverflow) {\n            data.selectableInners = selectableTargets.map(function () { return true; });\n        }\n        this._refreshGroups(data);\n        return selectableTargets;\n    };\n    /**\n     * External click or mouse events can be applied to the selecto.\n     * @params - Extenal click or mouse event\n     * @params - Specify the clicked target directly.\n     */\n    Selecto.prototype.clickTarget = function (e, clickedTarget) {\n        var _a = getClient(e), clientX = _a.clientX, clientY = _a.clientY;\n        var dragEvent = {\n            data: {\n                selectFlag: false,\n            },\n            clientX: clientX,\n            clientY: clientY,\n            inputEvent: e,\n            isClick: true,\n            isTrusted: false,\n            stop: function () {\n                return false;\n            },\n        };\n        if (this._onDragStart(dragEvent, clickedTarget)) {\n            this._onDragEnd(dragEvent);\n        }\n        return this;\n    };\n    Selecto.prototype.setKeyController = function () {\n        var _a = this.options, keyContainer = _a.keyContainer, toggleContinueSelect = _a.toggleContinueSelect, toggleContinueSelectWithoutDeselect = _a.toggleContinueSelectWithoutDeselect;\n        if (this.keycon) {\n            this.keycon.destroy();\n            this.keycon = null;\n        }\n        if (toggleContinueSelect || toggleContinueSelectWithoutDeselect) {\n            this.keycon = new keycon__WEBPACK_IMPORTED_MODULE_6__[\"default\"](keyContainer || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)(this.container));\n            this.keycon\n                .keydown(this._onKeyDown)\n                .keyup(this._onKeyUp)\n                .on(\"blur\", this._onBlur);\n        }\n    };\n    Selecto.prototype.setClassName = function (nextClassName) {\n        this.options.className = nextClassName;\n        this.target.setAttribute(\"class\", \"\".concat(CLASS_NAME, \" \").concat(nextClassName || \"\"));\n    };\n    Selecto.prototype.setKeyEvent = function () {\n        var _a = this.options, toggleContinueSelect = _a.toggleContinueSelect, toggleContinueSelectWithoutDeselect = _a.toggleContinueSelectWithoutDeselect;\n        if ((!toggleContinueSelect && !toggleContinueSelectWithoutDeselect) || this.keycon) {\n            return;\n        }\n        this.setKeyController();\n    };\n    // with getter, setter property\n    Selecto.prototype.setKeyContainer = function (keyContainer) {\n        var _this = this;\n        var options = this.options;\n        diffValue(options.keyContainer, keyContainer, function () {\n            options.keyContainer = keyContainer;\n            _this.setKeyController();\n        });\n    };\n    Selecto.prototype.getContinueSelect = function () {\n        var _a = this.options, continueSelect = _a.continueSelect, toggleContinueSelect = _a.toggleContinueSelect;\n        if (!toggleContinueSelect || !this._keydownContinueSelect) {\n            return continueSelect;\n        }\n        return !continueSelect;\n    };\n    Selecto.prototype.getContinueSelectWithoutDeselect = function () {\n        var _a = this.options, continueSelectWithoutDeselect = _a.continueSelectWithoutDeselect, toggleContinueSelectWithoutDeselect = _a.toggleContinueSelectWithoutDeselect;\n        if (!toggleContinueSelectWithoutDeselect || !this._keydownContinueSelectWithoutDeselection) {\n            return continueSelectWithoutDeselect;\n        }\n        return !continueSelectWithoutDeselect;\n    };\n    Selecto.prototype.setToggleContinueSelect = function (toggleContinueSelect) {\n        var _this = this;\n        var options = this.options;\n        diffValue(options.toggleContinueSelect, toggleContinueSelect, function () {\n            options.toggleContinueSelect = toggleContinueSelect;\n            _this.setKeyEvent();\n        });\n    };\n    Selecto.prototype.setToggleContinueSelectWithoutDeselect = function (toggleContinueSelectWithoutDeselect) {\n        var _this = this;\n        var options = this.options;\n        diffValue(options.toggleContinueSelectWithoutDeselect, toggleContinueSelectWithoutDeselect, function () {\n            options.toggleContinueSelectWithoutDeselect = toggleContinueSelectWithoutDeselect;\n            _this.setKeyEvent();\n        });\n    };\n    Selecto.prototype.setPreventDefault = function (value) {\n        this.gesto.options.preventDefault = value;\n    };\n    Selecto.prototype.setCheckInput = function (value) {\n        this.gesto.options.checkInput = value;\n    };\n    Selecto.prototype.initElement = function () {\n        var _a = this.options, dragContainer = _a.dragContainer, checkInput = _a.checkInput, preventDefault = _a.preventDefault, preventClickEventOnDragStart = _a.preventClickEventOnDragStart, preventClickEventOnDrag = _a.preventClickEventOnDrag, preventClickEventByCondition = _a.preventClickEventByCondition, _b = _a.preventRightClick, preventRightClick = _b === void 0 ? true : _b, className = _a.className;\n        var container = this.container;\n        this.target = createElement((h(\"div\", { className: \"\".concat(CLASS_NAME, \" \").concat(className || \"\") })), this.target, container);\n        var target = this.target;\n        this.dragContainer =\n            typeof dragContainer === \"string\"\n                ? [].slice.call((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(container).querySelectorAll(dragContainer))\n                : dragContainer || this.target.parentNode;\n        this.gesto = new gesto__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this.dragContainer, {\n            checkWindowBlur: true,\n            container: (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)(container),\n            checkInput: checkInput,\n            preventDefault: preventDefault,\n            preventClickEventOnDragStart: preventClickEventOnDragStart,\n            preventClickEventOnDrag: preventClickEventOnDrag,\n            preventClickEventByCondition: preventClickEventByCondition,\n            preventRightClick: preventRightClick,\n        }).on({\n            dragStart: this._onDragStart,\n            drag: this._onDrag,\n            dragEnd: this._onDragEnd,\n        });\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(document, \"selectstart\", this._onDocumentSelectStart);\n        this.injectResult = injector.inject(target, {\n            nonce: this.options.cspNonce,\n        });\n    };\n    Selecto.prototype.hitTest = function (selectRect, data, isDrag, gestoEvent) {\n        var _a = this.options, hitRate = _a.hitRate, selectByClick = _a.selectByClick;\n        var left = selectRect.left, top = selectRect.top, right = selectRect.right, bottom = selectRect.bottom;\n        var innerGroups = data.innerGroups;\n        var innerWidth = data.innerWidth;\n        var innerHeight = data.innerHeight;\n        var clientX = gestoEvent === null || gestoEvent === void 0 ? void 0 : gestoEvent.clientX;\n        var clientY = gestoEvent === null || gestoEvent === void 0 ? void 0 : gestoEvent.clientY;\n        var ignoreClick = data.ignoreClick;\n        var rectPoints = [\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n        ];\n        var isHit = function (points, el) {\n            var hitRateValue = typeof hitRate === \"function\"\n                ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitUnit)(\"\".concat(hitRate(el)))\n                : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitUnit)(\"\".concat(hitRate));\n            var inArea = ignoreClick\n                ? false\n                : (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.isInside)([clientX, clientY], points);\n            if (!isDrag && selectByClick && inArea) {\n                return true;\n            }\n            var overlapPoints = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getOverlapPoints)(rectPoints, points);\n            if (!overlapPoints.length) {\n                return false;\n            }\n            var overlapSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(overlapPoints);\n            // Line\n            var targetSize = 0;\n            if (overlapSize === 0 && (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(points) === 0) {\n                targetSize = getLineSize(points);\n                overlapSize = getLineSize(overlapPoints);\n            }\n            else {\n                targetSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(points);\n            }\n            if (hitRateValue.unit === \"px\") {\n                return overlapSize >= hitRateValue.value;\n            }\n            else {\n                var rate = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.between)(Math.round((overlapSize / targetSize) * 100), 0, 100);\n                return rate >= Math.min(100, hitRateValue.value);\n            }\n        };\n        var selectableTargets = data.selectableTargets;\n        var selectablePoints = data.selectablePoints;\n        var selectableInners = data.selectableInners;\n        if (!innerGroups) {\n            return selectableTargets.filter(function (_, i) {\n                if (!selectableInners[i]) {\n                    return false;\n                }\n                return isHit(selectablePoints[i], selectableTargets[i]);\n            });\n        }\n        var selectedTargets = [];\n        var minX = Math.floor(left / innerWidth);\n        var maxX = Math.floor(right / innerWidth);\n        var minY = Math.floor(top / innerHeight);\n        var maxY = Math.floor(bottom / innerHeight);\n        for (var x = minX; x <= maxX; ++x) {\n            var yGroups = innerGroups[x];\n            if (!yGroups) {\n                continue;\n            }\n            for (var y = minY; y <= maxY; ++y) {\n                var group = yGroups[y];\n                if (!group) {\n                    continue;\n                }\n                group.forEach(function (index) {\n                    var points = selectablePoints[index];\n                    var inner = selectableInners[index];\n                    var target = selectableTargets[index];\n                    if (inner && isHit(points, target)) {\n                        selectedTargets.push(target);\n                    }\n                });\n            }\n        }\n        return filterDuplicated(selectedTargets);\n    };\n    Selecto.prototype.initDragScroll = function () {\n        var _this = this;\n        this.dragScroll\n            .on(\"scrollDrag\", function (_a) {\n            var next = _a.next;\n            next(_this.gesto.getCurrentEvent());\n        })\n            .on(\"scroll\", function (_a) {\n            var container = _a.container, direction = _a.direction;\n            var innerScrollOptions = _this.gesto.getEventData().innerScrollOptions;\n            if (innerScrollOptions) {\n                _this.emit(\"innerScroll\", {\n                    container: container,\n                    direction: direction,\n                });\n            }\n            else {\n                _this.emit(\"scroll\", {\n                    container: container,\n                    direction: direction,\n                });\n            }\n        })\n            .on(\"move\", function (_a) {\n            var offsetX = _a.offsetX, offsetY = _a.offsetY, inputEvent = _a.inputEvent;\n            var gesto = _this.gesto;\n            if (!gesto || !gesto.isFlag()) {\n                return;\n            }\n            var data = _this.gesto.getEventData();\n            var boundArea = data.boundArea;\n            data.startX -= offsetX;\n            data.startY -= offsetY;\n            var innerScrollOptions = _this.gesto.getEventData().innerScrollOptions;\n            var container = innerScrollOptions === null || innerScrollOptions === void 0 ? void 0 : innerScrollOptions.container;\n            var isMoveInnerScroll = false;\n            if (container) {\n                var parentMap_2 = data.selectableInnerScrollParentMap;\n                var parentInfo = parentMap_2.get(container);\n                if (parentInfo) {\n                    parentInfo.paths.forEach(function (scrollContainer) {\n                        var containerInfo = parentMap_2.get(scrollContainer);\n                        containerInfo.points.forEach(function (pos) {\n                            pos[0] -= offsetX;\n                            pos[1] -= offsetY;\n                        });\n                    });\n                    parentInfo.indexes.forEach(function (index) {\n                        data.selectablePoints[index].forEach(function (pos) {\n                            pos[0] -= offsetX;\n                            pos[1] -= offsetY;\n                        });\n                    });\n                    isMoveInnerScroll = true;\n                }\n            }\n            if (!isMoveInnerScroll) {\n                data.selectablePoints.forEach(function (points) {\n                    points.forEach(function (pos) {\n                        pos[0] -= offsetX;\n                        pos[1] -= offsetY;\n                    });\n                });\n            }\n            _this._refreshGroups(data);\n            boundArea.left -= offsetX;\n            boundArea.right -= offsetX;\n            boundArea.top -= offsetY;\n            boundArea.bottom -= offsetY;\n            _this.gesto.scrollBy(offsetX, offsetY, inputEvent.inputEvent);\n            _this._checkSelected(_this.gesto.getCurrentEvent());\n        });\n    };\n    Selecto.prototype._select = function (selectedTargets, rect, e, isStart, isDragStartEnd) {\n        if (isDragStartEnd === void 0) { isDragStartEnd = false; }\n        var inputEvent = e.inputEvent;\n        var data = e.data;\n        var result = this.setSelectedTargets(selectedTargets);\n        var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(data.startSelectedTargets, selectedTargets), added = _a.added, removed = _a.removed, prevList = _a.prevList, list = _a.list;\n        var startResult = {\n            startSelected: prevList,\n            startAdded: added.map(function (i) { return list[i]; }),\n            startRemoved: removed.map(function (i) { return prevList[i]; }),\n        };\n        if (isStart) {\n            /**\n             * When the select(drag) starts, the selectStart event is called.\n             * @memberof Selecto\n             * @event selectStart\n             * @param {Selecto.OnSelect} - Parameters for the selectStart event\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   selectByClick: true,\n             *   selectFromInside: false,\n             * });\n             *\n             * selecto.on(\"selectStart\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * }).on(\"selectEnd\", e => {\n             *   e.afterAdded.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.afterRemoved.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            this.emit(\"selectStart\", __assign(__assign(__assign({}, result), startResult), { rect: rect, inputEvent: inputEvent, data: data.data, isTrusted: e.isTrusted, isDragStartEnd: isDragStartEnd }));\n        }\n        if (result.added.length || result.removed.length) {\n            /**\n             * When the select in real time, the select event is called.\n             * @memberof Selecto\n             * @event select\n             * @param {Selecto.OnSelect} - Parameters for the select event\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   selectByClick: true,\n             *   selectFromInside: false,\n             * });\n             *\n             * selecto.on(\"select\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            this.emit(\"select\", __assign(__assign(__assign({}, result), startResult), { rect: rect, inputEvent: inputEvent, data: data.data, isTrusted: e.isTrusted, isDragStartEnd: isDragStartEnd }));\n        }\n    };\n    Selecto.prototype._selectEnd = function (startSelectedTargets, startPassedTargets, rect, e, isDragStartEnd) {\n        if (isDragStartEnd === void 0) { isDragStartEnd = false; }\n        var inputEvent = e.inputEvent, isDouble = e.isDouble, data = e.data;\n        var type = inputEvent && inputEvent.type;\n        var isDragStart = type === \"mousedown\" || type === \"touchstart\";\n        var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(startSelectedTargets, this.selectedTargets), added = _a.added, removed = _a.removed, prevList = _a.prevList, list = _a.list;\n        var _b = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(startPassedTargets, this.selectedTargets), afterAdded = _b.added, afterRemoved = _b.removed, afterPrevList = _b.prevList, afterList = _b.list;\n        /**\n         * When the select(dragEnd or click) ends, the selectEnd event is called.\n         * @memberof Selecto\n         * @event selectEnd\n         * @param {Selecto.OnSelectEnd} - Parameters for the selectEnd event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"selectStart\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * }).on(\"selectEnd\", e => {\n         *   e.afterAdded.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.afterRemoved.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        this.emit(\"selectEnd\", {\n            startSelected: startSelectedTargets,\n            beforeSelected: startPassedTargets,\n            selected: this.selectedTargets,\n            added: added.map(function (index) { return list[index]; }),\n            removed: removed.map(function (index) { return prevList[index]; }),\n            afterAdded: afterAdded.map(function (index) { return afterList[index]; }),\n            afterRemoved: afterRemoved.map(function (index) { return afterPrevList[index]; }),\n            isDragStart: isDragStart && isDragStartEnd,\n            isDragStartEnd: isDragStart && isDragStartEnd,\n            isClick: !!e.isClick,\n            isDouble: !!isDouble,\n            rect: rect,\n            inputEvent: inputEvent,\n            data: data.data,\n            isTrusted: e.isTrusted,\n        });\n    };\n    Selecto.prototype._checkSelected = function (e, rect) {\n        if (rect === void 0) { rect = getRect(e, this.options.ratio); }\n        var data = e.data;\n        var top = rect.top, left = rect.left, width = rect.width, height = rect.height;\n        var selectFlag = data.selectFlag;\n        var containerX = data.containerX, containerY = data.containerY, scaleMatrix = data.scaleMatrix;\n        var offsetPos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(scaleMatrix, [\n            left - containerX,\n            top - containerY,\n        ]);\n        var offsetSize = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(scaleMatrix, [\n            width,\n            height,\n        ]);\n        var selectedTargets = [];\n        if (selectFlag) {\n            this.target.style.cssText +=\n                \"display: block;\" +\n                    \"left:0px;top:0px;\" +\n                    \"transform: translate(\".concat(offsetPos[0], \"px, \").concat(offsetPos[1], \"px);\") +\n                    \"width:\".concat(offsetSize[0], \"px;height:\").concat(offsetSize[1], \"px;\");\n            var passedTargets = this.hitTest(rect, data, true, e);\n            selectedTargets = passTargets(data.startPassedTargets, passedTargets, this.continueSelect && this.continueSelectWithoutDeselect);\n        }\n        /**\n         * When the drag, the drag event is called.\n         * Call the stop () function if you have a specific element or don't want to raise a select\n         * @memberof Selecto\n         * @event drag\n         * @param {OnDrag} - Parameters for the drag event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"drag\", e => {\n         *   e.stop();\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        var result = this.emit(\"drag\", __assign(__assign({}, e), { data: data.data, isSelect: selectFlag, rect: rect }));\n        if (result === false) {\n            this.target.style.cssText += \"display: none;\";\n            e.stop();\n            return;\n        }\n        if (selectFlag) {\n            this._select(selectedTargets, rect, e);\n        }\n    };\n    Selecto.prototype._sameCombiKey = function (e, keys, isKeyup) {\n        if (!keys) {\n            return false;\n        }\n        var combi = (0,keycon__WEBPACK_IMPORTED_MODULE_6__.getCombi)(e.inputEvent, e.key);\n        var nextKeys = [].concat(keys);\n        var toggleKeys = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(nextKeys[0]) ? nextKeys : [nextKeys];\n        if (isKeyup) {\n            var singleKey_1 = e.key;\n            return toggleKeys.some(function (keys) {\n                return keys.some(function (key) { return key === singleKey_1; });\n            });\n        }\n        return toggleKeys.some(function (keys) {\n            return keys.every(function (key) { return combi.indexOf(key) > -1; });\n        });\n    };\n    Selecto.prototype._findElement = function (clickedTarget, selectableTargets) {\n        var pointTarget = clickedTarget;\n        while (pointTarget) {\n            if (selectableTargets.indexOf(pointTarget) > -1) {\n                break;\n            }\n            pointTarget = pointTarget.parentElement;\n        }\n        return pointTarget;\n    };\n    Selecto.prototype._refreshGroups = function (data) {\n        var _a;\n        var innerWidth = data.innerWidth;\n        var innerHeight = data.innerHeight;\n        var selectablePoints = data.selectablePoints;\n        if (this.options.checkOverflow) {\n            var innerScrollContainer_1 = (_a = this.gesto.getEventData().innerScrollOptions) === null || _a === void 0 ? void 0 : _a.container;\n            var parentMap_3 = data.selectableInnerScrollParentMap;\n            var innerScrollPathsList = data.selectableInnerScrollPathsList;\n            data.selectableInners = innerScrollPathsList.map(function (innerScrollPaths, i) {\n                var isAlwaysTrue = false;\n                return innerScrollPaths.every(function (target) {\n                    if (isAlwaysTrue) {\n                        return true;\n                    }\n                    if (target === innerScrollContainer_1) {\n                        isAlwaysTrue = true;\n                        return true;\n                    }\n                    var rect = parentMap_3.get(target);\n                    if (rect) {\n                        var points1 = selectablePoints[i];\n                        var points2 = rect.points;\n                        var overlapPoints = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getOverlapPoints)(points1, points2);\n                        if (!overlapPoints.length) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            });\n        }\n        if (!innerWidth || !innerHeight) {\n            data.innerGroups = null;\n        }\n        else {\n            var selectablePoints_1 = data.selectablePoints;\n            var groups_1 = {};\n            selectablePoints_1.forEach(function (points, i) {\n                var minX = Infinity;\n                var maxX = -Infinity;\n                var minY = Infinity;\n                var maxY = -Infinity;\n                points.forEach(function (pos) {\n                    var x = Math.floor(pos[0] / innerWidth);\n                    var y = Math.floor(pos[1] / innerHeight);\n                    minX = Math.min(x, minX);\n                    maxX = Math.max(x, maxX);\n                    minY = Math.min(y, minY);\n                    maxY = Math.max(y, maxY);\n                });\n                for (var x = minX; x <= maxX; ++x) {\n                    for (var y = minY; y <= maxY; ++y) {\n                        groups_1[x] = groups_1[x] || {};\n                        groups_1[x][y] = groups_1[x][y] || [];\n                        groups_1[x][y].push(i);\n                    }\n                }\n            });\n            data.innerGroups = groups_1;\n        }\n    };\n    Selecto = __decorate([\n        (0,framework_utils__WEBPACK_IMPORTED_MODULE_8__.Properties)(PROPERTIES, function (prototype, property) {\n            var attributes = {\n                enumerable: true,\n                configurable: true,\n                get: function () {\n                    return this.options[property];\n                },\n            };\n            var getter = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.camelize)(\"get \".concat(property));\n            if (prototype[getter]) {\n                attributes.get = function () {\n                    return this[getter]();\n                };\n            }\n            else {\n                attributes.get = function () {\n                    return this.options[property];\n                };\n            }\n            var setter = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.camelize)(\"set \".concat(property));\n            if (prototype[setter]) {\n                attributes.set = function (value) {\n                    this[setter](value);\n                };\n            }\n            else {\n                attributes.set = function (value) {\n                    this.options[property] = value;\n                };\n            }\n            Object.defineProperty(prototype, property, attributes);\n        })\n    ], Selecto);\n    return Selecto;\n}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_9__[\"default\"]));\n\nvar Selecto = /*#__PURE__*/ (function (_super) {\n    __extends(Selecto, _super);\n    function Selecto() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Selecto;\n}(Selecto$1));\n\n\n//# sourceMappingURL=selecto.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGludGVyYWN0aWZ5L3NlbGVjdGlvbi9kaXN0L3NlbGVjdG8uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUN0QjtBQUNtQjtBQUNtSztBQUNuSztBQUNGO0FBQ007QUFDaUM7QUFDRztBQUNyRDs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw0REFBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEy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QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDREQUFZOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRTZGO0FBQzlGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVtb3Rpb24tY2FwdGlvbnMvLi9ub2RlX21vZHVsZXMvQGludGVyYWN0aWZ5L3NlbGVjdGlvbi9kaXN0L3NlbGVjdG8uZXNtLmpzP2Y1NGEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAoYykgMjAyMCBEYXlicnVzaFxubmFtZTogQGludGVyYWN0aWZ5L3NlbGVjdGlvblxubGljZW5zZTogTUlUXG5hdXRob3I6IFxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9kZXNpZ25jb21iby9pbnRlcmFjdGl5LmdpdFxudmVyc2lvbjogMC4wLjJcbiovXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ0BzY2VuYS9ldmVudC1lbWl0dGVyJztcbmltcG9ydCBHZXN0byBmcm9tICdnZXN0byc7XG5pbXBvcnQgeyBQcm9wZXJ0aWVzIH0gZnJvbSAnZnJhbWV3b3JrLXV0aWxzJztcbmltcG9ydCB7IGdldERvY3VtZW50LCBoYXNDbGFzcywgYWRkQ2xhc3MsIGNhbGN1bGF0ZUJvdW5kU2l6ZSwgZ2V0RGlzdCwgZ2V0V2luZG93LCBpc09iamVjdCwgaXNTdHJpbmcsIGlzTm9kZSwgcmVtb3ZlRXZlbnQsIGlzRnVuY3Rpb24sIGFkZEV2ZW50LCBpc0FycmF5LCBjYW1lbGl6ZSwgc3BsaXRVbml0LCBiZXR3ZWVuIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcbmltcG9ydCB7IGRpZmYgfSBmcm9tICdAZWdqcy9jaGlsZHJlbi1kaWZmZXInO1xuaW1wb3J0IERyYWdTY3JvbGwgZnJvbSAnQHNjZW5hL2RyYWdzY3JvbGwnO1xuaW1wb3J0IEtleUNvbnRyb2xsZXIsIHsgZ2V0Q29tYmkgfSBmcm9tICdrZXljb24nO1xuaW1wb3J0IHsgZml0UG9pbnRzLCBnZXRPdmVybGFwUG9pbnRzLCBpc0luc2lkZSwgZ2V0QXJlYVNpemUgfSBmcm9tICdvdmVybGFwLWFyZWEnO1xuaW1wb3J0IHsgY3JlYXRlTWF0cml4LCBnZXREaXN0RWxlbWVudE1hdHJpeCwgY2FsY3VsYXRlTWF0cml4RGlzdCB9IGZyb20gJ2Nzcy10by1tYXQnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdjc3Mtc3R5bGVkJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5mdW5jdGlvbiBnZXRDbGllbnQoZSkge1xuICAgIGlmIChcInRvdWNoZXNcIiBpbiBlKSB7XG4gICAgICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXSB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbHRlckR1cGxpY2F0ZWQoYXJyKSB7XG4gICAgaWYgKHR5cGVvZiBNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAobWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBtYXAuc2V0KHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBlbGVtZW50RnJvbVBvaW50KGJhc2VOb2RlLCBjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgdmFyIGRvYyA9IGdldERvY3VtZW50KGJhc2VOb2RlKTtcbiAgICByZXR1cm4gKGRvYy5lbGVtZW50RnJvbVBvaW50ICYmIGRvYy5lbGVtZW50RnJvbVBvaW50KGNsaWVudFgsIGNsaWVudFkpKSB8fCBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChqc3gsIHByZXZUYXJnZXQsIGNvbnRhaW5lcikge1xuICAgIHZhciB0YWcgPSBqc3gudGFnLCBjaGlsZHJlbiA9IGpzeC5jaGlsZHJlbiwgYXR0cmlidXRlcyA9IGpzeC5hdHRyaWJ1dGVzLCBjbGFzc05hbWUgPSBqc3guY2xhc3NOYW1lLCBzdHlsZSA9IGpzeC5zdHlsZTtcbiAgICB2YXIgZWwgPSBwcmV2VGFyZ2V0IHx8IGdldERvY3VtZW50KGNvbnRhaW5lcikuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGZvciAodmFyIG5hbWVfMSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lXzEsIGF0dHJpYnV0ZXNbbmFtZV8xXSk7XG4gICAgfVxuICAgIHZhciBlbENoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgICAgY3JlYXRlRWxlbWVudChjaGlsZCwgZWxDaGlsZHJlbltpXSwgZWwpO1xuICAgIH0pO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChuYW1lICYmICFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbCwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgdmFyIGVsU3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIHN0eWxlKSB7XG4gICAgICAgICAgICBlbFN0eWxlW25hbWVfMl0gPSBzdHlsZVtuYW1lXzJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghcHJldlRhcmdldCAmJiBjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gaCh0YWcsIGF0dHJzKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY2hpbGRyZW5bX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBfYSA9IGF0dHJzIHx8IHt9LCBfYiA9IF9hLmNsYXNzTmFtZSwgY2xhc3NOYW1lID0gX2IgPT09IHZvaWQgMCA/IFwiXCIgOiBfYiwgX2MgPSBfYS5zdHlsZSwgc3R5bGUgPSBfYyA9PT0gdm9pZCAwID8ge30gOiBfYywgYXR0cmlidXRlcyA9IF9fcmVzdChfYSwgW1wiY2xhc3NOYW1lXCIsIFwic3R5bGVcIl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZWYWx1ZShwcmV2LCBjdXIsIGZ1bmMpIHtcbiAgICBpZiAocHJldiAhPT0gY3VyKSB7XG4gICAgICAgIGZ1bmMocHJldiwgY3VyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSZWN0KGUsIHJhdGlvLCBib3VuZEFyZWEpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGJvdW5kQXJlYSA9PT0gdm9pZCAwKSB7IGJvdW5kQXJlYSA9IGUuZGF0YS5ib3VuZEFyZWE7IH1cbiAgICB2YXIgX2IgPSBlLmRpc3RYLCBkaXN0WCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsIF9jID0gZS5kaXN0WSwgZGlzdFkgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jO1xuICAgIHZhciBfZCA9IGUuZGF0YSwgc3RhcnRYID0gX2Quc3RhcnRYLCBzdGFydFkgPSBfZC5zdGFydFk7XG4gICAgaWYgKHJhdGlvID4gMCkge1xuICAgICAgICB2YXIgbmV4dEhlaWdodCA9IE1hdGguc3FydCgoZGlzdFggKiBkaXN0WCArIGRpc3RZICogZGlzdFkpIC8gKDEgKyByYXRpbyAqIHJhdGlvKSk7XG4gICAgICAgIHZhciBuZXh0V2lkdGggPSByYXRpbyAqIG5leHRIZWlnaHQ7XG4gICAgICAgIGRpc3RYID0gKGRpc3RYID49IDAgPyAxIDogLTEpICogbmV4dFdpZHRoO1xuICAgICAgICBkaXN0WSA9IChkaXN0WSA+PSAwID8gMSA6IC0xKSAqIG5leHRIZWlnaHQ7XG4gICAgfVxuICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKGRpc3RYKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoZGlzdFkpO1xuICAgIHZhciBtYXhXaWR0aCA9IGRpc3RYIDwgMCA/IHN0YXJ0WCAtIGJvdW5kQXJlYS5sZWZ0IDogYm91bmRBcmVhLnJpZ2h0IC0gc3RhcnRYO1xuICAgIHZhciBtYXhIZWlnaHQgPSBkaXN0WSA8IDAgPyBzdGFydFkgLSBib3VuZEFyZWEudG9wIDogYm91bmRBcmVhLmJvdHRvbSAtIHN0YXJ0WTtcbiAgICBfYSA9IGNhbGN1bGF0ZUJvdW5kU2l6ZShbd2lkdGgsIGhlaWdodF0sIFswLCAwXSwgW21heFdpZHRoLCBtYXhIZWlnaHRdLCAhIXJhdGlvKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgZGlzdFggPSAoZGlzdFggPj0gMCA/IDEgOiAtMSkgKiB3aWR0aDtcbiAgICBkaXN0WSA9IChkaXN0WSA+PSAwID8gMSA6IC0xKSAqIGhlaWdodDtcbiAgICB2YXIgdHggPSBNYXRoLm1pbigwLCBkaXN0WCk7XG4gICAgdmFyIHR5ID0gTWF0aC5taW4oMCwgZGlzdFkpO1xuICAgIHZhciBsZWZ0ID0gc3RhcnRYICsgdHg7XG4gICAgdmFyIHRvcCA9IHN0YXJ0WSArIHR5O1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICByaWdodDogbGVmdCArIHdpZHRoLFxuICAgICAgICBib3R0b206IHRvcCArIGhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEVsZW1lbnRSZWN0KGVsKSB7XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbGVmdCA9IHJlY3QubGVmdCwgdG9wID0gcmVjdC50b3AsIHdpZHRoID0gcmVjdC53aWR0aCwgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zMTogW2xlZnQsIHRvcF0sXG4gICAgICAgIHBvczI6IFtsZWZ0ICsgd2lkdGgsIHRvcF0sXG4gICAgICAgIHBvczM6IFtsZWZ0LCB0b3AgKyBoZWlnaHRdLFxuICAgICAgICBwb3M0OiBbbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHRdLFxuICAgIH07XG59XG5mdW5jdGlvbiBwYXNzVGFyZ2V0cyhiZWZvcmVUYXJnZXRzLCBhZnRlclRhcmdldHMsIGNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0KSB7XG4gICAgdmFyIF9hID0gZGlmZihiZWZvcmVUYXJnZXRzLCBhZnRlclRhcmdldHMpLCBsaXN0ID0gX2EubGlzdCwgcHJldkxpc3QgPSBfYS5wcmV2TGlzdCwgYWRkZWQgPSBfYS5hZGRlZCwgcmVtb3ZlZCA9IF9hLnJlbW92ZWQsIG1haW50YWluZWQgPSBfYS5tYWludGFpbmVkO1xuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gbGlzdFtpbmRleF07IH0pLCB0cnVlKSwgcmVtb3ZlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBwcmV2TGlzdFtpbmRleF07IH0pLCB0cnVlKSwgY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgPyBtYWludGFpbmVkLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IF9hWzFdO1xuICAgICAgICByZXR1cm4gbGlzdFtuZXh0SW5kZXhdO1xuICAgIH0pIDogW10sIHRydWUpO1xufVxuZnVuY3Rpb24gZ2V0TGluZVNpemUocG9pbnRzKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KGdldERpc3QocG9pbnRzW2ldLCBwb2ludHNbaSAtIDFdKSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuXG52YXIgaW5qZWN0b3IgPSBzdHlsZWQoXCJcXG46aG9zdCB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzRhZjtcXG4gICAgYmFja2dyb3VuZDogcmdiYSg2OCwgMTcwLCAyNTUsIDAuNSk7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbiAgICB6LWluZGV4OiAxMDA7XFxufVxcblwiKTtcbi8qKlxuICogQG1lbWJlcm9mIFNlbGVjdG9cbiAqL1xudmFyIENMQVNTX05BTUUgPSBcInNlbGVjdG8tc2VsZWN0aW9uIFwiLmNvbmNhdChpbmplY3Rvci5jbGFzc05hbWUpO1xudmFyIFBST1BFUlRJRVMgPSBbXG4gICAgXCJjbGFzc05hbWVcIixcbiAgICBcImJvdW5kQ29udGFpbmVyXCIsXG4gICAgXCJzZWxlY3RhYmxlVGFyZ2V0c1wiLFxuICAgIFwic2VsZWN0QnlDbGlja1wiLFxuICAgIFwic2VsZWN0RnJvbUluc2lkZVwiLFxuICAgIFwiY29udGludWVTZWxlY3RcIixcbiAgICBcImNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0XCIsXG4gICAgXCJ0b2dnbGVDb250aW51ZVNlbGVjdFwiLFxuICAgIFwidG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3RcIixcbiAgICBcImtleUNvbnRhaW5lclwiLFxuICAgIFwiaGl0UmF0ZVwiLFxuICAgIFwic2Nyb2xsT3B0aW9uc1wiLFxuICAgIFwiY2hlY2tJbnB1dFwiLFxuICAgIFwicHJldmVudERlZmF1bHRcIixcbiAgICBcInJhdGlvXCIsXG4gICAgXCJnZXRFbGVtZW50UmVjdFwiLFxuICAgIFwicHJldmVudERyYWdGcm9tSW5zaWRlXCIsXG4gICAgXCJyb290Q29udGFpbmVyXCIsXG4gICAgXCJkcmFnQ29uZGl0aW9uXCIsXG4gICAgXCJjbGlja0J5U2VsZWN0RW5kXCIsXG4gICAgXCJjaGVja092ZXJmbG93XCIsXG4gICAgXCJpbm5lclNjcm9sbE9wdGlvbnNcIixcbl07XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cbnZhciBPUFRJT05TID0gX19zcHJlYWRBcnJheShbXG4gICAgLy8gaWdub3JlIHRhcmdldCwgY29udGFpbmVyLFxuICAgIFwiZHJhZ0NvbnRhaW5lclwiLFxuICAgIFwiY3NwTm9uY2VcIixcbiAgICBcInByZXZlbnRDbGlja0V2ZW50T25EcmFnXCIsXG4gICAgXCJwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZ1N0YXJ0XCIsXG4gICAgXCJwcmV2ZW50UmlnaHRDbGlja1wiXG5dLCBQUk9QRVJUSUVTLCB0cnVlKTtcbnZhciBPUFRJT05fVFlQRVMgPSB7XG4gICAgY2xhc3NOYW1lOiBTdHJpbmcsXG4gICAgYm91bmRDb250YWluZXI6IG51bGwsXG4gICAgcG9ydGFsQ29udGFpbmVyOiBudWxsLFxuICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICBkcmFnQ29udGFpbmVyOiBudWxsLFxuICAgIHNlbGVjdGFibGVUYXJnZXRzOiBBcnJheSxcbiAgICBzZWxlY3RCeUNsaWNrOiBCb29sZWFuLFxuICAgIHNlbGVjdEZyb21JbnNpZGU6IEJvb2xlYW4sXG4gICAgY29udGludWVTZWxlY3Q6IEJvb2xlYW4sXG4gICAgdG9nZ2xlQ29udGludWVTZWxlY3Q6IEFycmF5LFxuICAgIHRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0OiBBcnJheSxcbiAgICBrZXlDb250YWluZXI6IG51bGwsXG4gICAgaGl0UmF0ZTogTnVtYmVyLFxuICAgIHNjcm9sbE9wdGlvbnM6IE9iamVjdCxcbiAgICBjaGVja0lucHV0OiBCb29sZWFuLFxuICAgIHByZXZlbnREZWZhdWx0OiBCb29sZWFuLFxuICAgIGNzcE5vbmNlOiBTdHJpbmcsXG4gICAgcmF0aW86IE51bWJlcixcbiAgICBnZXRFbGVtZW50UmVjdDogRnVuY3Rpb24sXG4gICAgcHJldmVudERyYWdGcm9tSW5zaWRlOiBCb29sZWFuLFxuICAgIHJvb3RDb250YWluZXI6IE9iamVjdCxcbiAgICBkcmFnQ29uZGl0aW9uOiBGdW5jdGlvbixcbiAgICBjbGlja0J5U2VsZWN0RW5kOiBCb29sZWFuLFxuICAgIGNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0OiBCb29sZWFuLFxuICAgIHByZXZlbnRDbGlja0V2ZW50T25EcmFnU3RhcnQ6IEJvb2xlYW4sXG4gICAgcHJldmVudENsaWNrRXZlbnRPbkRyYWc6IEJvb2xlYW4sXG4gICAgY2hlY2tPdmVyZmxvdzogQm9vbGVhbixcbiAgICBpbm5lclNjcm9sbE9wdGlvbnM6IE9iamVjdCxcbn07XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cbnZhciBFVkVOVFMgPSBbXG4gICAgXCJkcmFnU3RhcnRcIixcbiAgICBcImRyYWdcIixcbiAgICBcImRyYWdFbmRcIixcbiAgICBcInNlbGVjdFN0YXJ0XCIsXG4gICAgXCJzZWxlY3RcIixcbiAgICBcInNlbGVjdEVuZFwiLFxuICAgIFwia2V5ZG93blwiLFxuICAgIFwia2V5dXBcIixcbiAgICBcInNjcm9sbFwiLFxuICAgIFwiaW5uZXJTY3JvbGxcIixcbl07XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cbnZhciBNRVRIT0RTID0gW1xuICAgIFwiY2xpY2tUYXJnZXRcIixcbiAgICBcImdldFNlbGVjdGFibGVFbGVtZW50c1wiLFxuICAgIFwic2V0U2VsZWN0ZWRUYXJnZXRzXCIsXG4gICAgXCJnZXRFbGVtZW50UG9pbnRzXCIsXG4gICAgXCJnZXRTZWxlY3RlZFRhcmdldHNcIixcbiAgICBcImZpbmRTZWxlY3RhYmxlVGFyZ2V0c1wiLFxuICAgIFwidHJpZ2dlckRyYWdTdGFydFwiLFxuICAgIFwiY2hlY2tTY3JvbGxcIixcbiAgICBcInNlbGVjdFRhcmdldHNCeVBvaW50c1wiLFxuICAgIFwic2V0U2VsZWN0ZWRUYXJnZXRzQnlQb2ludHNcIixcbl07XG5cbi8qKlxuICogU2VsZWN0by5qcyBpcyBhIGNvbXBvbmVudCB0aGF0IGFsbG93cyB5b3UgdG8gc2VsZWN0IGVsZW1lbnRzIGluIHRoZSBkcmFnIGFyZWEgdXNpbmcgdGhlIG1vdXNlIG9yIHRvdWNoLlxuICogQHNvcnQgMVxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbnZhciBTZWxlY3RvJDEgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlbGVjdG8sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZWxlY3RvKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2VsZWN0ZWRUYXJnZXRzID0gW107XG4gICAgICAgIF90aGlzLmRyYWdTY3JvbGwgPSBuZXcgRHJhZ1Njcm9sbCgpO1xuICAgICAgICBfdGhpcy5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSwgY2xpY2tlZFRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBlLmRhdGEsIGNsaWVudFggPSBlLmNsaWVudFgsIGNsaWVudFkgPSBlLmNsaWVudFksIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5vcHRpb25zLCBzZWxlY3RGcm9tSW5zaWRlID0gX2Euc2VsZWN0RnJvbUluc2lkZSwgc2VsZWN0QnlDbGljayA9IF9hLnNlbGVjdEJ5Q2xpY2ssIHJvb3RDb250YWluZXIgPSBfYS5yb290Q29udGFpbmVyLCBib3VuZENvbnRhaW5lciA9IF9hLmJvdW5kQ29udGFpbmVyLCBfYiA9IF9hLnByZXZlbnREcmFnRnJvbUluc2lkZSwgcHJldmVudERyYWdGcm9tSW5zaWRlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgY2xpY2tCeVNlbGVjdEVuZCA9IF9hLmNsaWNrQnlTZWxlY3RFbmQsIGRyYWdDb25kaXRpb24gPSBfYS5kcmFnQ29uZGl0aW9uO1xuICAgICAgICAgICAgaWYgKGRyYWdDb25kaXRpb24gJiYgIWRyYWdDb25kaXRpb24oZSkpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmRhdGEgPSB7fTtcbiAgICAgICAgICAgIHZhciB3aW4gPSBnZXRXaW5kb3coX3RoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIGRhdGEuaW5uZXJXaWR0aCA9IHdpbi5pbm5lcldpZHRoO1xuICAgICAgICAgICAgZGF0YS5pbm5lckhlaWdodCA9IHdpbi5pbm5lckhlaWdodDtcbiAgICAgICAgICAgIF90aGlzLmZpbmRTZWxlY3RhYmxlVGFyZ2V0cyhkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuc3RhcnRTZWxlY3RlZFRhcmdldHMgPSBfdGhpcy5zZWxlY3RlZFRhcmdldHM7XG4gICAgICAgICAgICBkYXRhLnNjYWxlTWF0cml4ID0gY3JlYXRlTWF0cml4KCk7XG4gICAgICAgICAgICBkYXRhLmNvbnRhaW5lclggPSAwO1xuICAgICAgICAgICAgZGF0YS5jb250YWluZXJZID0gMDtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5jb250YWluZXI7XG4gICAgICAgICAgICB2YXIgYm91bmRBcmVhID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICB0b3A6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICByaWdodDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgYm90dG9tOiBJbmZpbml0eSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocm9vdENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gX3RoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGRhdGEuY29udGFpbmVyWCA9IGNvbnRhaW5lclJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICBkYXRhLmNvbnRhaW5lclkgPSBjb250YWluZXJSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICBkYXRhLnNjYWxlTWF0cml4ID0gZ2V0RGlzdEVsZW1lbnRNYXRyaXgoX3RoaXMuY29udGFpbmVyLCByb290Q29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib3VuZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZEluZm8gPSBpc09iamVjdChib3VuZENvbnRhaW5lcikgJiYgXCJlbGVtZW50XCIgaW4gYm91bmRDb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgPyBfX2Fzc2lnbih7IGxlZnQ6IHRydWUsIHRvcDogdHJ1ZSwgYm90dG9tOiB0cnVlLCByaWdodDogdHJ1ZSB9LCBib3VuZENvbnRhaW5lcikgOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGJvdW5kQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRFbGVtZW50ID0gYm91bmRJbmZvLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RFbGVtZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGJvdW5kRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RFbGVtZW50ID0gZ2V0RG9jdW1lbnQoY29udGFpbmVyKS5xdWVyeVNlbGVjdG9yKGJvdW5kRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm91bmRFbGVtZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0RWxlbWVudCA9IF90aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RFbGVtZW50ID0gYm91bmRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gcmVjdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib3VuZEluZm8ubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRBcmVhLmxlZnQgPSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdW5kSW5mby50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kQXJlYS50b3AgPSByZWN0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYm91bmRJbmZvLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZEFyZWEucmlnaHQgPSByZWN0LnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChib3VuZEluZm8uYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZEFyZWEuYm90dG9tID0gcmVjdC5ib3R0b207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmJvdW5kQXJlYSA9IGJvdW5kQXJlYTtcbiAgICAgICAgICAgIHZhciBoaXRSZWN0ID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGNsaWVudFgsXG4gICAgICAgICAgICAgICAgdG9wOiBjbGllbnRZLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBjbGllbnRYLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogY2xpZW50WSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGZpcnN0UGFzc2VkVGFyZ2V0cyA9IFtdO1xuICAgICAgICAgICAgLy8gYWxsb3cgY2xpY2sgb24gc2VsZWN0XG4gICAgICAgICAgICB2YXIgYWxsb3dDbGlja0J5U2VsZWN0RW5kID0gc2VsZWN0QnlDbGljayAmJiAhY2xpY2tCeVNlbGVjdEVuZDtcbiAgICAgICAgICAgIHZhciBoYXNJbnNpZGVUYXJnZXRzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdEZyb21JbnNpZGUgfHwgYWxsb3dDbGlja0J5U2VsZWN0RW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50VGFyZ2V0ID0gX3RoaXMuX2ZpbmRFbGVtZW50KGNsaWNrZWRUYXJnZXQgfHwgaW5wdXRFdmVudC50YXJnZXQsIC8vIGVsZW1lbnRGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSksXG4gICAgICAgICAgICAgICAgZGF0YS5zZWxlY3RhYmxlVGFyZ2V0cyk7XG4gICAgICAgICAgICAgICAgaGFzSW5zaWRlVGFyZ2V0cyA9ICEhcG9pbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93Q2xpY2tCeVNlbGVjdEVuZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFBhc3NlZFRhcmdldHMgPSBwb2ludFRhcmdldCA/IFtwb2ludFRhcmdldF0gOiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXNQcmV2ZW50U2VsZWN0ID0gIXNlbGVjdEZyb21JbnNpZGUgJiYgaGFzSW5zaWRlVGFyZ2V0cztcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZHJhZyBmcm9tIGluc2lkZSB3aGVuIHNlbGVjdEJ5Q2xpY2sgaXMgZmFsc2VcbiAgICAgICAgICAgIGlmIChpc1ByZXZlbnRTZWxlY3QgJiYgIXNlbGVjdEJ5Q2xpY2spIHtcbiAgICAgICAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGlucHV0RXZlbnQudHlwZTtcbiAgICAgICAgICAgIHZhciBpc1RydXN0ZWQgPSB0eXBlID09PSBcIm1vdXNlZG93blwiIHx8IHR5cGUgPT09IFwidG91Y2hzdGFydFwiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBkcmFnIHN0YXJ0cyAodHJpZ2dlcnMgb24gbW91c2Vkb3duIG9yIHRvdWNoc3RhcnQpLCB0aGUgZHJhZ1N0YXJ0IGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAqIENhbGwgdGhlIHN0b3AgKCkgZnVuY3Rpb24gaWYgeW91IGhhdmUgYSBzcGVjaWZpYyBlbGVtZW50IG9yIGRvbid0IHdhbnQgdG8gcmFpc2UgYSBzZWxlY3RcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgICAgICAgKiBAZXZlbnQgZHJhZ1N0YXJ0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09uRHJhZ1N0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkcmFnU3RhcnQgZXZlbnRcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICAgICAgICAgKiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgICAqICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgICAgICAgICAqICAgc2VsZWN0RnJvbUluc2lkZTogZmFsc2UsXG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBzZWxlY3RvLm9uKFwiZHJhZ1N0YXJ0XCIsIGUgPT4ge1xuICAgICAgICAgICAgICogICBpZiAoZS5pbnB1dEV2ZW50LnRhcmdldC50YWdOYW1lID09PSBcIlNQQU5cIikge1xuICAgICAgICAgICAgICogICAgIGUuc3RvcCgpO1xuICAgICAgICAgICAgICogICB9XG4gICAgICAgICAgICAgKiB9KS5vbihcInNlbGVjdFwiLCBlID0+IHtcbiAgICAgICAgICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICogICB9KTtcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gIShlKS5pc0NsaWNrICYmIGlzVHJ1c3RlZFxuICAgICAgICAgICAgICAgID8gX3RoaXMuZW1pdChcImRyYWdTdGFydFwiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgZGF0YTogZGF0YS5kYXRhIH0pKVxuICAgICAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRpbnVlU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RQYXNzZWRUYXJnZXRzID0gcGFzc1RhcmdldHMoX3RoaXMuc2VsZWN0ZWRUYXJnZXRzLCBmaXJzdFBhc3NlZFRhcmdldHMsIF90aGlzLmNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0KTtcbiAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0UGFzc2VkVGFyZ2V0cyA9IF90aGlzLnNlbGVjdGVkVGFyZ2V0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhcnRQYXNzZWRUYXJnZXRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fc2VsZWN0KGZpcnN0UGFzc2VkVGFyZ2V0cywgaGl0UmVjdCwgZSwgdHJ1ZSwgaXNQcmV2ZW50U2VsZWN0ICYmIHNlbGVjdEJ5Q2xpY2sgJiYgIWNsaWNrQnlTZWxlY3RFbmQgJiYgcHJldmVudERyYWdGcm9tSW5zaWRlKTtcbiAgICAgICAgICAgIGRhdGEuc3RhcnRYID0gY2xpZW50WDtcbiAgICAgICAgICAgIGRhdGEuc3RhcnRZID0gY2xpZW50WTtcbiAgICAgICAgICAgIGRhdGEuc2VsZWN0RmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YS5wcmV2ZW50RHJhZ0Zyb21JbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpbnB1dEV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRQb3MgPSBjYWxjdWxhdGVNYXRyaXhEaXN0KGRhdGEuc2NhbGVNYXRyaXgsIFtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WCAtIGRhdGEuY29udGFpbmVyWCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WSAtIGRhdGEuY29udGFpbmVyWSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBcInBvc2l0aW9uOiBcIi5jb25jYXQocm9vdENvbnRhaW5lciA/IFwiYWJzb2x1dGVcIiA6IFwiZml4ZWRcIiwgXCI7XCIpXG4gICAgICAgICAgICAgICAgICAgICsgXCJsZWZ0OjBweDt0b3A6MHB4O1wiXG4gICAgICAgICAgICAgICAgICAgICsgXCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZShcIi5jb25jYXQob2Zmc2V0UG9zWzBdLCBcInB4LCBcIikuY29uY2F0KG9mZnNldFBvc1sxXSwgXCJweClcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcmV2ZW50U2VsZWN0ICYmIHNlbGVjdEJ5Q2xpY2sgJiYgIWNsaWNrQnlTZWxlY3RFbmQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBkcmFnIGZyb20gaW5zaWRlIHdoZW4gc2VsZWN0QnlDbGljayBpcyB0cnVlIGFuZCBmb3JjZSBjYWxsIGBzZWxlY3RFbmRgXG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnREcmFnRnJvbUluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VsZWN0RW5kKGRhdGEuc3RhcnRTZWxlY3RlZFRhcmdldHMsIGRhdGEuc3RhcnRQYXNzZWRUYXJnZXRzLCBoaXRSZWN0LCBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wcmV2ZW50RHJhZ0Zyb21JbnNpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEuc2VsZWN0RmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gd2h5P1xuICAgICAgICAgICAgICAgIC8vIGlmICh0eXBlID09PSBcInRvdWNoc3RhcnRcIikge1xuICAgICAgICAgICAgICAgIC8vICAgICBpbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIHZhciBfYyA9IF90aGlzLm9wdGlvbnMsIHNjcm9sbE9wdGlvbnMgPSBfYy5zY3JvbGxPcHRpb25zLCBpbm5lclNjcm9sbE9wdGlvbnMgPSBfYy5pbm5lclNjcm9sbE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5uZXJTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJTY3JvbGxPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dEV2ZW50XzEgPSBlLmlucHV0RXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBpbnB1dEV2ZW50XzEudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJTY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJlbnRFbGVtZW50ICYmIHBhcmVudEVsZW1lbnQgIT09IGdldERvY3VtZW50KGNvbnRhaW5lcikuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93ID0gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnRFbGVtZW50KS5vdmVyZmxvdyAhPT0gXCJ2aXNpYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclNjcm9sbEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXJTY3JvbGxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmlubmVyU2Nyb2xsT3B0aW9ucyA9IF9fYXNzaWduKHsgY29udGFpbmVyOiBpbm5lclNjcm9sbEVsZW1lbnQsIGNoZWNrU2Nyb2xsRXZlbnQ6IHRydWUgfSwgKGlubmVyU2Nyb2xsT3B0aW9ucyA9PT0gdHJ1ZSA/IHt9IDogaW5uZXJTY3JvbGxPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kcmFnU2Nyb2xsLmRyYWdTdGFydChlLCBkYXRhLmlubmVyU2Nyb2xsT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0lubmVyU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzSW5uZXJTY3JvbGwgJiYgc2Nyb2xsT3B0aW9ucyAmJiBzY3JvbGxPcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kcmFnU2Nyb2xsLmRyYWdTdGFydChlLCBzY3JvbGxPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJldmVudFNlbGVjdCAmJiBzZWxlY3RCeUNsaWNrICYmIGNsaWNrQnlTZWxlY3RFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWxlY3RGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERyYWcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX29uRHJhZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5kYXRhLnNlbGVjdEZsYWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsT3B0aW9ucyA9IF90aGlzLnNjcm9sbE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyU2Nyb2xsT3B0aW9ucyA9IGUuZGF0YS5pbm5lclNjcm9sbE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1Njcm9sbE9wdGlvbnMgPSBpbm5lclNjcm9sbE9wdGlvbnMgfHwgKHNjcm9sbE9wdGlvbnMgPT09IG51bGwgfHwgc2Nyb2xsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Nyb2xsT3B0aW9ucy5jb250YWluZXIpO1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGEgc2Nyb2xsaW5nIHBvc2l0aW9uLCBwYXNzIGRyYWdcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2Nyb2xsT3B0aW9ucyAmJiAhZS5pc1Njcm9sbCAmJiBfdGhpcy5kcmFnU2Nyb2xsLmRyYWcoZSwgaW5uZXJTY3JvbGxPcHRpb25zIHx8IHNjcm9sbE9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fY2hlY2tTZWxlY3RlZChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YSwgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZ2V0UmVjdChlLCBfdGhpcy5vcHRpb25zLnJhdGlvKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RGbGFnID0gZGF0YS5zZWxlY3RGbGFnO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgZHJhZyBlbmRzICh0cmlnZ2VycyBvbiBtb3VzZXVwIG9yIHRvdWNoZW5kIGFmdGVyIGRyYWcpLCB0aGUgZHJhZ0VuZCBldmVudCBpcyBjYWxsZWQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICAgICAgICogQGV2ZW50IGRyYWdFbmRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T25EcmFnRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkcmFnRW5kIGV2ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpbnB1dEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRyYWdFbmRcIiwgX19hc3NpZ24oX19hc3NpZ24oeyBpc0RvdWJsZTogISFlLmlzRG91YmxlLCBpc0NsaWNrOiAhIWUuaXNDbGljaywgaXNEcmFnOiBmYWxzZSwgaXNTZWxlY3Q6IHNlbGVjdEZsYWcgfSwgZSksIHsgZGF0YTogZGF0YS5kYXRhLCByZWN0OiByZWN0IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnRhcmdldC5zdHlsZS5jc3NUZXh0ICs9IFwiZGlzcGxheTogbm9uZTtcIjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RGbGFnKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zZWxlY3RGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ1Njcm9sbC5kcmFnRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5zZWxlY3RCeUNsaWNrICYmIF90aGlzLmNsaWNrQnlTZWxlY3RFbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNsaWNrQnlTZWxlY3RFbmRcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRUYXJnZXQgPSBfdGhpcy5fZmluZEVsZW1lbnQoKGlucHV0RXZlbnQgPT09IG51bGwgfHwgaW5wdXRFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRFdmVudC50YXJnZXQpIHx8IGVsZW1lbnRGcm9tUG9pbnQoY29udGFpbmVyLCBlLmNsaWVudFgsIGUuY2xpZW50WSksIGRhdGEuc2VsZWN0YWJsZVRhcmdldHMpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZWxlY3QocG9pbnRUYXJnZXQgPyBbcG9pbnRUYXJnZXRdIDogW10sIHJlY3QsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhLnByZXZlbnREcmFnRnJvbUluc2lkZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZWxlY3RFbmQoZGF0YS5zdGFydFNlbGVjdGVkVGFyZ2V0cywgZGF0YS5zdGFydFBhc3NlZFRhcmdldHMsIHJlY3QsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fb25LZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHZhciBpc0tleURvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5fc2FtZUNvbWJpS2V5KGUsIG9wdGlvbnMudG9nZ2xlQ29udGludWVTZWxlY3QpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3QgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaXNLZXlEb3duIHx8IChpc0tleURvd24gPSByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLl9zYW1lQ29tYmlLZXkoZSwgb3B0aW9ucy50b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdGlvbiA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpc0tleURvd24gfHwgKGlzS2V5RG93biA9IHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzS2V5RG93bikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB5b3Uga2V5ZG93biB0aGUga2V5IHlvdSBzcGVjaWZpZWQgaW4gdG9nZ2xlQ29udGludWVTZWxlY3QsIHRoZSBrZXlkb3duIGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgICAgICAgKiBAZXZlbnQga2V5ZG93blxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKHtcbiAgICAgICAgICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgICogICB0b2dnbGVDb250aW51ZVNlbGVjdDogXCJzaGlmdFwiO1xuICAgICAgICAgICAgICogICBrZXlDb250YWluZXI6IHdpbmRvdyxcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIHNlbGVjdG8ub24oXCJrZXlkb3duXCIsICgpID0+IHtcbiAgICAgICAgICAgICAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5idXR0b25cIikuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICogfSkub24oXCJrZXl1cFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAgICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAqICAgfSk7XG4gICAgICAgICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJrZXlkb3duXCIsIHtcbiAgICAgICAgICAgICAgICBrZXlkb3duQ29udGludWVTZWxlY3Q6IF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3QsXG4gICAgICAgICAgICAgICAga2V5ZG93bkNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0aW9uOiBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9vbktleVVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHZhciBpc0tleVVwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5fc2FtZUNvbWJpS2V5KGUsIG9wdGlvbnMudG9nZ2xlQ29udGludWVTZWxlY3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3QgPSAhcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlzS2V5VXAgfHwgKGlzS2V5VXAgPSByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuX3NhbWVDb21iaUtleShlLCBvcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0aW9uID0gIXJlc3VsdDtcbiAgICAgICAgICAgICAgICBpc0tleVVwIHx8IChpc0tleVVwID0gcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNLZXlVcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB5b3Uga2V5dXAgdGhlIGtleSB5b3Ugc3BlY2lmaWVkIGluIHRvZ2dsZUNvbnRpbnVlU2VsZWN0LCB0aGUga2V5dXAgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgICAgICAgICAqIEBldmVudCBrZXl1cFxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKHtcbiAgICAgICAgICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgICogICB0b2dnbGVDb250aW51ZVNlbGVjdDogXCJzaGlmdFwiO1xuICAgICAgICAgICAgICogICBrZXlDb250YWluZXI6IHdpbmRvdyxcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIHNlbGVjdG8ub24oXCJrZXlkb3duXCIsICgpID0+IHtcbiAgICAgICAgICAgICAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5idXR0b25cIikuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICogfSkub24oXCJrZXl1cFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAgICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAqICAgfSk7XG4gICAgICAgICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJrZXl1cFwiLCB7XG4gICAgICAgICAgICAgICAga2V5ZG93bkNvbnRpbnVlU2VsZWN0OiBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0LFxuICAgICAgICAgICAgICAgIGtleWRvd25Db250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdGlvbjogX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fb25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3QgfHwgX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImtleXVwXCIsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ZG93bkNvbnRpbnVlU2VsZWN0OiBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0LFxuICAgICAgICAgICAgICAgICAgICBrZXlkb3duQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Rpb246IF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9vbkRvY3VtZW50U2VsZWN0U3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IGdldERvY3VtZW50KF90aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmdlc3RvLmlzRmxhZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRyYWdDb250YWluZXIgPSBfdGhpcy5kcmFnQ29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKGRyYWdDb250YWluZXIgPT09IGdldFdpbmRvdyhfdGhpcy5jb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgZHJhZ0NvbnRhaW5lciA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29udGFpbmVycyA9IGlzTm9kZShkcmFnQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgID8gW2RyYWdDb250YWluZXJdXG4gICAgICAgICAgICAgICAgOiBbXS5zbGljZS5jYWxsKGRyYWdDb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgY29udGFpbmVycy5zb21lKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyID09PSB0YXJnZXQgfHwgY29udGFpbmVyLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudGFyZ2V0ID0gb3B0aW9ucy5wb3J0YWxDb250YWluZXI7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IF9fYXNzaWduKHsgY2xhc3NOYW1lOiBcIlwiLCBwb3J0YWxDb250YWluZXI6IG51bGwsIGNvbnRhaW5lcjogbnVsbCwgZHJhZ0NvbnRhaW5lcjogbnVsbCwgc2VsZWN0YWJsZVRhcmdldHM6IFtdLCBzZWxlY3RCeUNsaWNrOiB0cnVlLCBzZWxlY3RGcm9tSW5zaWRlOiB0cnVlLCBjbGlja0J5U2VsZWN0RW5kOiBmYWxzZSwgaGl0UmF0ZTogMTAwLCBjb250aW51ZVNlbGVjdDogZmFsc2UsIGNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0OiBmYWxzZSwgdG9nZ2xlQ29udGludWVTZWxlY3Q6IG51bGwsIHRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0OiBudWxsLCBrZXlDb250YWluZXI6IG51bGwsIHNjcm9sbE9wdGlvbnM6IG51bGwsIGNoZWNrSW5wdXQ6IGZhbHNlLCBwcmV2ZW50RGVmYXVsdDogZmFsc2UsIGJvdW5kQ29udGFpbmVyOiBmYWxzZSwgcHJldmVudERyYWdGcm9tSW5zaWRlOiB0cnVlLCBkcmFnQ29uZGl0aW9uOiBudWxsLCByb290Q29udGFpbmVyOiBudWxsLCBjaGVja092ZXJmbG93OiBmYWxzZSwgaW5uZXJTY3JvbGxPcHRpb25zOiBmYWxzZSwgZ2V0RWxlbWVudFJlY3Q6IGdldERlZmF1bHRFbGVtZW50UmVjdCwgY3NwTm9uY2U6IFwiXCIsIHJhdGlvOiAwIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgcG9ydGFsQ29udGFpbmVyID0gX3RoaXMub3B0aW9ucy5wb3J0YWxDb250YWluZXI7XG4gICAgICAgIGlmIChwb3J0YWxDb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHBvcnRhbENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICBfdGhpcy5pbml0RWxlbWVudCgpO1xuICAgICAgICBfdGhpcy5pbml0RHJhZ1Njcm9sbCgpO1xuICAgICAgICBfdGhpcy5zZXRLZXlDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogWW91IGNhbiBzZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YXJnZXRzLlxuICAgICAqIHNlbGVjdEJ5Q2xpY2ssIGNvbnRpbnVlU2VsZWN0LCBhbmQgY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgYXJlIG5vdCBhcHBsaWVkLlxuICAgICAqL1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLnNldFNlbGVjdGVkVGFyZ2V0cyA9IGZ1bmN0aW9uIChzZWxlY3RlZFRhcmdldHMpIHtcbiAgICAgICAgdmFyIGJlZm9yZVNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZFRhcmdldHM7XG4gICAgICAgIHZhciBfYSA9IGRpZmYoYmVmb3JlU2VsZWN0ZWQsIHNlbGVjdGVkVGFyZ2V0cyksIGFkZGVkID0gX2EuYWRkZWQsIHJlbW92ZWQgPSBfYS5yZW1vdmVkLCBwcmV2TGlzdCA9IF9hLnByZXZMaXN0LCBsaXN0ID0gX2EubGlzdDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFRhcmdldHMgPSBzZWxlY3RlZFRhcmdldHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRlZDogYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gbGlzdFtpbmRleF07IH0pLFxuICAgICAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBwcmV2TGlzdFtpbmRleF07IH0pLFxuICAgICAgICAgICAgYmVmb3JlU2VsZWN0ZWQ6IGJlZm9yZVNlbGVjdGVkLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkVGFyZ2V0cyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gc2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFyZ2V0cyBieSBwb2ludHNcbiAgICAgKiBzZWxlY3RCeUNsaWNrLCBjb250aW51ZVNlbGVjdCwgYW5kIGNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0IGFyZSBub3QgYXBwbGllZC5cbiAgICAgKi9cbiAgICBTZWxlY3RvLnByb3RvdHlwZS5zZXRTZWxlY3RlZFRhcmdldHNCeVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludDEsIHBvaW50Mikge1xuICAgICAgICB2YXIgbGVmdCA9IE1hdGgubWluKHBvaW50MVswXSwgcG9pbnQyWzBdKTtcbiAgICAgICAgdmFyIHRvcCA9IE1hdGgubWluKHBvaW50MVsxXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gTWF0aC5tYXgocG9pbnQxWzBdLCBwb2ludDJbMF0pO1xuICAgICAgICB2YXIgYm90dG9tID0gTWF0aC5tYXgocG9pbnQxWzFdLCBwb2ludDJbMV0pO1xuICAgICAgICB2YXIgcmVjdCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGF0YSA9IHsgaWdub3JlQ2xpY2s6IHRydWUgfTtcbiAgICAgICAgdGhpcy5maW5kU2VsZWN0YWJsZVRhcmdldHMoZGF0YSk7XG4gICAgICAgIHZhciBzZWxlY3RlZEVsZW1lbnRzID0gdGhpcy5oaXRUZXN0KHJlY3QsIGRhdGEsIHRydWUsIG51bGwpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zZXRTZWxlY3RlZFRhcmdldHMoc2VsZWN0ZWRFbGVtZW50cyk7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0KSwgeyByZWN0OiByZWN0IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRhcmdldCBieSB2aXJ0dWFsIGRyYWcgZnJvbSBzdGFydFBvaW50IHRvIGVuZFBvaW50LlxuICAgICAqIFRoZSB0YXJnZXQgb2YgaW5wdXRFdmVudCBpcyBudWxsLlxuICAgICAqL1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLnNlbGVjdFRhcmdldHNCeVBvaW50cyA9IGZ1bmN0aW9uIChzdGFydFBvaW50LCBlbmRQb2ludCkge1xuICAgICAgICB2YXIgbW91c2Vkb3duID0gbmV3IE1vdXNlRXZlbnQoXCJtb3VzZWRvd25cIiwge1xuICAgICAgICAgICAgY2xpZW50WDogc3RhcnRQb2ludFswXSxcbiAgICAgICAgICAgIGNsaWVudFk6IHN0YXJ0UG9pbnRbMV0sXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtb3VzZW1vdmUgPSBuZXcgTW91c2VFdmVudChcIm1vdXNlbW92ZVwiLCB7XG4gICAgICAgICAgICBjbGllbnRYOiBlbmRQb2ludFswXSxcbiAgICAgICAgICAgIGNsaWVudFk6IGVuZFBvaW50WzFdLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbW91c2V1cCA9IG5ldyBNb3VzZUV2ZW50KFwibW91c2Vtb3ZlXCIsIHtcbiAgICAgICAgICAgIGNsaWVudFg6IGVuZFBvaW50WzBdLFxuICAgICAgICAgICAgY2xpZW50WTogZW5kUG9pbnRbMV0sXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBnZXN0byA9IHRoaXMuZ2VzdG87XG4gICAgICAgIHZhciByZXN1bHQgPSBnZXN0by5vbkRyYWdTdGFydChtb3VzZWRvd24pO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZ2VzdG8ub25EcmFnKG1vdXNlbW92ZSk7XG4gICAgICAgICAgICBnZXN0by5vbkRyYWdFbmQobW91c2V1cCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gZ2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFyZ2V0cy5cbiAgICAgKi9cbiAgICBTZWxlY3RvLnByb3RvdHlwZS5nZXRTZWxlY3RlZFRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkVGFyZ2V0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGBPbkRyYWdTdGFydGAgaXMgdHJpZ2dlcmVkIGJ5IGFuIGV4dGVybmFsIGV2ZW50LlxuICAgICAqIEBwYXJhbSAtIGV4dGVybmFsIGV2ZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgICAqXG4gICAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKCk7XG4gICAgICpcbiAgICAgKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcbiAgICAgKiAgIHNlbGVjdG8udHJpZ2dlckRyYWdTdGFydChlKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBTZWxlY3RvLnByb3RvdHlwZS50cmlnZ2VyRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5nZXN0by50cmlnZ2VyRHJhZ1N0YXJ0KGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgZWxlbWVudHMsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuXG4gICAgICovXG4gICAgU2VsZWN0by5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLm9mZigpO1xuICAgICAgICB0aGlzLmtleWNvbiAmJiB0aGlzLmtleWNvbi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZ2VzdG8udW5zZXQoKTtcbiAgICAgICAgdGhpcy5pbmplY3RSZXN1bHQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRyYWdTY3JvbGwuZHJhZ0VuZCgpO1xuICAgICAgICByZW1vdmVFdmVudChkb2N1bWVudCwgXCJzZWxlY3RzdGFydFwiLCB0aGlzLl9vbkRvY3VtZW50U2VsZWN0U3RhcnQpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wb3J0YWxDb250YWluZXIpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudGFyZ2V0LnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZCh0aGlzLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXljb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdlc3RvID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmplY3RSZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgICB9O1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLmdldEVsZW1lbnRQb2ludHMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBnZXRFbGVtZW50UmVjdCA9IHRoaXMuZ2V0RWxlbWVudFJlY3QgfHwgZ2V0RGVmYXVsdEVsZW1lbnRSZWN0O1xuICAgICAgICB2YXIgaW5mbyA9IGdldEVsZW1lbnRSZWN0KHRhcmdldCk7XG4gICAgICAgIHZhciBwb2ludHMgPSBbaW5mby5wb3MxLCBpbmZvLnBvczIsIGluZm8ucG9zNCwgaW5mby5wb3MzXTtcbiAgICAgICAgaWYgKGdldEVsZW1lbnRSZWN0ICE9PSBnZXREZWZhdWx0RWxlbWVudFJlY3QpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpdFBvaW50cyhwb2ludHMsIHJlY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGVsZW1lbnRzIHNldCBpbiBgc2VsZWN0YWJsZVRhcmdldHNgLlxuICAgICAqL1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLmdldFNlbGVjdGFibGVFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICB2YXIgc2VsZWN0YWJsZUVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlRWxlbWVudHMucHVzaC5hcHBseShzZWxlY3RhYmxlRWxlbWVudHMsIFtdLnNsaWNlLmNhbGwocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOb2RlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlRWxlbWVudHMucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGFibGVFbGVtZW50cy5wdXNoKHRhcmdldC52YWx1ZSB8fCB0YXJnZXQuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKChnZXREb2N1bWVudChjb250YWluZXIpKS5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCkpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGFibGVFbGVtZW50cy5wdXNoLmFwcGx5KHNlbGVjdGFibGVFbGVtZW50cywgZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGFibGVFbGVtZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHNjcm9sbCBvY2N1cnMgZHVyaW5nIGRyYWdnaW5nLCB5b3UgY2FuIG1hbnVhbGx5IGNhbGwgdGhpcyBtZXRob2QgdG8gY2hlY2sgdGhlIHBvc2l0aW9uIGFnYWluLlxuICAgICAqL1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLmNoZWNrU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2VzdG8uaXNGbGFnKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsT3B0aW9ucyA9IHRoaXMuc2Nyb2xsT3B0aW9ucztcbiAgICAgICAgdmFyIGlubmVyU2Nyb2xsT3B0aW9ucyA9IHRoaXMuZ2VzdG8uZ2V0RXZlbnREYXRhKCkuaW5uZXJTY3JvbGxPcHRpb25zO1xuICAgICAgICB2YXIgaGFzU2Nyb2xsT3B0aW9ucyA9IGlubmVyU2Nyb2xsT3B0aW9ucyB8fCAoc2Nyb2xsT3B0aW9ucyA9PT0gbnVsbCB8fCBzY3JvbGxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY3JvbGxPcHRpb25zLmNvbnRhaW5lcik7XG4gICAgICAgIC8vIElmIGl0IGlzIGEgc2Nyb2xsaW5nIHBvc2l0aW9uLCBwYXNzIGRyYWdcbiAgICAgICAgaWYgKGhhc1Njcm9sbE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1Njcm9sbC5jaGVja1Njcm9sbChfX2Fzc2lnbih7IGlucHV0RXZlbnQ6IHRoaXMuZ2VzdG8uZ2V0Q3VycmVudEV2ZW50KCkgfSwgKGlubmVyU2Nyb2xsT3B0aW9ucyB8fCBzY3JvbGxPcHRpb25zKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kIGZvciBzZWxlY3RhYmxlVGFyZ2V0cyBhZ2FpbiBkdXJpbmcgZHJhZyBldmVudFxuICAgICAqIFlvdSBjYW4gdXBkYXRlIHNlbGVjdGFibGUgdGFyZ2V0cyBkdXJpbmcgYW4gZXZlbnQuXG4gICAgICovXG4gICAgU2VsZWN0by5wcm90b3R5cGUuZmluZFNlbGVjdGFibGVUYXJnZXRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgeyBkYXRhID0gdGhpcy5nZXN0by5nZXRFdmVudERhdGEoKTsgfVxuICAgICAgICB2YXIgc2VsZWN0YWJsZVRhcmdldHMgPSB0aGlzLmdldFNlbGVjdGFibGVFbGVtZW50cygpO1xuICAgICAgICB2YXIgc2VsZWN0YWJsZVBvaW50cyA9IHNlbGVjdGFibGVUYXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiBfdGhpcy5nZXRFbGVtZW50UG9pbnRzKHRhcmdldCk7IH0pO1xuICAgICAgICBkYXRhLnNlbGVjdGFibGVUYXJnZXRzID0gc2VsZWN0YWJsZVRhcmdldHM7XG4gICAgICAgIGRhdGEuc2VsZWN0YWJsZVBvaW50cyA9IHNlbGVjdGFibGVQb2ludHM7XG4gICAgICAgIGRhdGEuc2VsZWN0YWJsZVBhcmVudE1hcCA9IG51bGw7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgaGFzSW5kZXhlc01hcCA9IG9wdGlvbnMuY2hlY2tPdmVyZmxvdyB8fCBvcHRpb25zLmlubmVyU2Nyb2xsT3B0aW9ucztcbiAgICAgICAgdmFyIGRvYyA9IGdldERvY3VtZW50KHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGhhc0luZGV4ZXNNYXApIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRNYXBfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGRhdGEuc2VsZWN0YWJsZUlubmVyU2Nyb2xsUGFyZW50TWFwID0gcGFyZW50TWFwXzE7XG4gICAgICAgICAgICBkYXRhLnNlbGVjdGFibGVJbm5lclNjcm9sbFBhdGhzTGlzdCA9IHNlbGVjdGFibGVUYXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBwYXJlbnRNYXBfMS5nZXQocGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93ID0gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnRFbGVtZW50KS5vdmVyZmxvdyAhPT0gXCJ2aXNpYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGdldERlZmF1bHRFbGVtZW50UmVjdChwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50OiBwYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBbcmVjdC5wb3MxLCByZWN0LnBvczIsIHJlY3QucG9zNCwgcmVjdC5wb3MzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHM6IF9fc3ByZWFkQXJyYXkoW10sIHBhdGhzLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHByZXZQYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE1hcF8xLnNldChwcmV2UGFyZW50RWxlbWVudCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gaW5mby5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50TWFwXzEuZ2V0KHBhcmVudEVsZW1lbnQpLmluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHBhcmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50RWxlbWVudCAmJiBwYXJlbnRFbGVtZW50ICE9PSBkb2MuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRocztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5jaGVja092ZXJmbG93KSB7XG4gICAgICAgICAgICBkYXRhLnNlbGVjdGFibGVJbm5lcnMgPSBzZWxlY3RhYmxlVGFyZ2V0cy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVmcmVzaEdyb3VwcyhkYXRhKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGFibGVUYXJnZXRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXh0ZXJuYWwgY2xpY2sgb3IgbW91c2UgZXZlbnRzIGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBzZWxlY3RvLlxuICAgICAqIEBwYXJhbXMgLSBFeHRlbmFsIGNsaWNrIG9yIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtcyAtIFNwZWNpZnkgdGhlIGNsaWNrZWQgdGFyZ2V0IGRpcmVjdGx5LlxuICAgICAqL1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLmNsaWNrVGFyZ2V0ID0gZnVuY3Rpb24gKGUsIGNsaWNrZWRUYXJnZXQpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0Q2xpZW50KGUpLCBjbGllbnRYID0gX2EuY2xpZW50WCwgY2xpZW50WSA9IF9hLmNsaWVudFk7XG4gICAgICAgIHZhciBkcmFnRXZlbnQgPSB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgc2VsZWN0RmxhZzogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpZW50WDogY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGNsaWVudFksXG4gICAgICAgICAgICBpbnB1dEV2ZW50OiBlLFxuICAgICAgICAgICAgaXNDbGljazogdHJ1ZSxcbiAgICAgICAgICAgIGlzVHJ1c3RlZDogZmFsc2UsXG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX29uRHJhZ1N0YXJ0KGRyYWdFdmVudCwgY2xpY2tlZFRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRHJhZ0VuZChkcmFnRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VsZWN0by5wcm90b3R5cGUuc2V0S2V5Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBrZXlDb250YWluZXIgPSBfYS5rZXlDb250YWluZXIsIHRvZ2dsZUNvbnRpbnVlU2VsZWN0ID0gX2EudG9nZ2xlQ29udGludWVTZWxlY3QsIHRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0ID0gX2EudG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Q7XG4gICAgICAgIGlmICh0aGlzLmtleWNvbikge1xuICAgICAgICAgICAgdGhpcy5rZXljb24uZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5rZXljb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2dnbGVDb250aW51ZVNlbGVjdCB8fCB0b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5rZXljb24gPSBuZXcgS2V5Q29udHJvbGxlcihrZXlDb250YWluZXIgfHwgZ2V0V2luZG93KHRoaXMuY29udGFpbmVyKSk7XG4gICAgICAgICAgICB0aGlzLmtleWNvblxuICAgICAgICAgICAgICAgIC5rZXlkb3duKHRoaXMuX29uS2V5RG93bilcbiAgICAgICAgICAgICAgICAua2V5dXAodGhpcy5fb25LZXlVcClcbiAgICAgICAgICAgICAgICAub24oXCJibHVyXCIsIHRoaXMuX29uQmx1cik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLnNldENsYXNzTmFtZSA9IGZ1bmN0aW9uIChuZXh0Q2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgPSBuZXh0Q2xhc3NOYW1lO1xuICAgICAgICB0aGlzLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcIlwiLmNvbmNhdChDTEFTU19OQU1FLCBcIiBcIikuY29uY2F0KG5leHRDbGFzc05hbWUgfHwgXCJcIikpO1xuICAgIH07XG4gICAgU2VsZWN0by5wcm90b3R5cGUuc2V0S2V5RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgdG9nZ2xlQ29udGludWVTZWxlY3QgPSBfYS50b2dnbGVDb250aW51ZVNlbGVjdCwgdG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgPSBfYS50b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdDtcbiAgICAgICAgaWYgKCghdG9nZ2xlQ29udGludWVTZWxlY3QgJiYgIXRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0KSB8fCB0aGlzLmtleWNvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0S2V5Q29udHJvbGxlcigpO1xuICAgIH07XG4gICAgLy8gd2l0aCBnZXR0ZXIsIHNldHRlciBwcm9wZXJ0eVxuICAgIFNlbGVjdG8ucHJvdG90eXBlLnNldEtleUNvbnRhaW5lciA9IGZ1bmN0aW9uIChrZXlDb250YWluZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGRpZmZWYWx1ZShvcHRpb25zLmtleUNvbnRhaW5lciwga2V5Q29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zLmtleUNvbnRhaW5lciA9IGtleUNvbnRhaW5lcjtcbiAgICAgICAgICAgIF90aGlzLnNldEtleUNvbnRyb2xsZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWxlY3RvLnByb3RvdHlwZS5nZXRDb250aW51ZVNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBjb250aW51ZVNlbGVjdCA9IF9hLmNvbnRpbnVlU2VsZWN0LCB0b2dnbGVDb250aW51ZVNlbGVjdCA9IF9hLnRvZ2dsZUNvbnRpbnVlU2VsZWN0O1xuICAgICAgICBpZiAoIXRvZ2dsZUNvbnRpbnVlU2VsZWN0IHx8ICF0aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250aW51ZVNlbGVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvbnRpbnVlU2VsZWN0O1xuICAgIH07XG4gICAgU2VsZWN0by5wcm90b3R5cGUuZ2V0Q29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgPSBfYS5jb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCwgdG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgPSBfYS50b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdDtcbiAgICAgICAgaWYgKCF0b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCB8fCAhdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFjb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdDtcbiAgICB9O1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLnNldFRvZ2dsZUNvbnRpbnVlU2VsZWN0ID0gZnVuY3Rpb24gKHRvZ2dsZUNvbnRpbnVlU2VsZWN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBkaWZmVmFsdWUob3B0aW9ucy50b2dnbGVDb250aW51ZVNlbGVjdCwgdG9nZ2xlQ29udGludWVTZWxlY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudG9nZ2xlQ29udGludWVTZWxlY3QgPSB0b2dnbGVDb250aW51ZVNlbGVjdDtcbiAgICAgICAgICAgIF90aGlzLnNldEtleUV2ZW50KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0by5wcm90b3R5cGUuc2V0VG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgPSBmdW5jdGlvbiAodG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGRpZmZWYWx1ZShvcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0LCB0b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucy50b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCA9IHRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0O1xuICAgICAgICAgICAgX3RoaXMuc2V0S2V5RXZlbnQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWxlY3RvLnByb3RvdHlwZS5zZXRQcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdlc3RvLm9wdGlvbnMucHJldmVudERlZmF1bHQgPSB2YWx1ZTtcbiAgICB9O1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLnNldENoZWNrSW5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXN0by5vcHRpb25zLmNoZWNrSW5wdXQgPSB2YWx1ZTtcbiAgICB9O1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLmluaXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIGRyYWdDb250YWluZXIgPSBfYS5kcmFnQ29udGFpbmVyLCBjaGVja0lucHV0ID0gX2EuY2hlY2tJbnB1dCwgcHJldmVudERlZmF1bHQgPSBfYS5wcmV2ZW50RGVmYXVsdCwgcHJldmVudENsaWNrRXZlbnRPbkRyYWdTdGFydCA9IF9hLnByZXZlbnRDbGlja0V2ZW50T25EcmFnU3RhcnQsIHByZXZlbnRDbGlja0V2ZW50T25EcmFnID0gX2EucHJldmVudENsaWNrRXZlbnRPbkRyYWcsIHByZXZlbnRDbGlja0V2ZW50QnlDb25kaXRpb24gPSBfYS5wcmV2ZW50Q2xpY2tFdmVudEJ5Q29uZGl0aW9uLCBfYiA9IF9hLnByZXZlbnRSaWdodENsaWNrLCBwcmV2ZW50UmlnaHRDbGljayA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICB0aGlzLnRhcmdldCA9IGNyZWF0ZUVsZW1lbnQoKGgoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiXCIuY29uY2F0KENMQVNTX05BTUUsIFwiIFwiKS5jb25jYXQoY2xhc3NOYW1lIHx8IFwiXCIpIH0pKSwgdGhpcy50YXJnZXQsIGNvbnRhaW5lcik7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgdGhpcy5kcmFnQ29udGFpbmVyID1cbiAgICAgICAgICAgIHR5cGVvZiBkcmFnQ29udGFpbmVyID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBbXS5zbGljZS5jYWxsKGdldERvY3VtZW50KGNvbnRhaW5lcikucXVlcnlTZWxlY3RvckFsbChkcmFnQ29udGFpbmVyKSlcbiAgICAgICAgICAgICAgICA6IGRyYWdDb250YWluZXIgfHwgdGhpcy50YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgdGhpcy5nZXN0byA9IG5ldyBHZXN0byh0aGlzLmRyYWdDb250YWluZXIsIHtcbiAgICAgICAgICAgIGNoZWNrV2luZG93Qmx1cjogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogZ2V0V2luZG93KGNvbnRhaW5lciksXG4gICAgICAgICAgICBjaGVja0lucHV0OiBjaGVja0lucHV0LFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHByZXZlbnREZWZhdWx0LFxuICAgICAgICAgICAgcHJldmVudENsaWNrRXZlbnRPbkRyYWdTdGFydDogcHJldmVudENsaWNrRXZlbnRPbkRyYWdTdGFydCxcbiAgICAgICAgICAgIHByZXZlbnRDbGlja0V2ZW50T25EcmFnOiBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZyxcbiAgICAgICAgICAgIHByZXZlbnRDbGlja0V2ZW50QnlDb25kaXRpb246IHByZXZlbnRDbGlja0V2ZW50QnlDb25kaXRpb24sXG4gICAgICAgICAgICBwcmV2ZW50UmlnaHRDbGljazogcHJldmVudFJpZ2h0Q2xpY2ssXG4gICAgICAgIH0pLm9uKHtcbiAgICAgICAgICAgIGRyYWdTdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIH0pO1xuICAgICAgICBhZGRFdmVudChkb2N1bWVudCwgXCJzZWxlY3RzdGFydFwiLCB0aGlzLl9vbkRvY3VtZW50U2VsZWN0U3RhcnQpO1xuICAgICAgICB0aGlzLmluamVjdFJlc3VsdCA9IGluamVjdG9yLmluamVjdCh0YXJnZXQsIHtcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm9wdGlvbnMuY3NwTm9uY2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0by5wcm90b3R5cGUuaGl0VGVzdCA9IGZ1bmN0aW9uIChzZWxlY3RSZWN0LCBkYXRhLCBpc0RyYWcsIGdlc3RvRXZlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBoaXRSYXRlID0gX2EuaGl0UmF0ZSwgc2VsZWN0QnlDbGljayA9IF9hLnNlbGVjdEJ5Q2xpY2s7XG4gICAgICAgIHZhciBsZWZ0ID0gc2VsZWN0UmVjdC5sZWZ0LCB0b3AgPSBzZWxlY3RSZWN0LnRvcCwgcmlnaHQgPSBzZWxlY3RSZWN0LnJpZ2h0LCBib3R0b20gPSBzZWxlY3RSZWN0LmJvdHRvbTtcbiAgICAgICAgdmFyIGlubmVyR3JvdXBzID0gZGF0YS5pbm5lckdyb3VwcztcbiAgICAgICAgdmFyIGlubmVyV2lkdGggPSBkYXRhLmlubmVyV2lkdGg7XG4gICAgICAgIHZhciBpbm5lckhlaWdodCA9IGRhdGEuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHZhciBjbGllbnRYID0gZ2VzdG9FdmVudCA9PT0gbnVsbCB8fCBnZXN0b0V2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXN0b0V2ZW50LmNsaWVudFg7XG4gICAgICAgIHZhciBjbGllbnRZID0gZ2VzdG9FdmVudCA9PT0gbnVsbCB8fCBnZXN0b0V2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXN0b0V2ZW50LmNsaWVudFk7XG4gICAgICAgIHZhciBpZ25vcmVDbGljayA9IGRhdGEuaWdub3JlQ2xpY2s7XG4gICAgICAgIHZhciByZWN0UG9pbnRzID0gW1xuICAgICAgICAgICAgW2xlZnQsIHRvcF0sXG4gICAgICAgICAgICBbcmlnaHQsIHRvcF0sXG4gICAgICAgICAgICBbcmlnaHQsIGJvdHRvbV0sXG4gICAgICAgICAgICBbbGVmdCwgYm90dG9tXSxcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGlzSGl0ID0gZnVuY3Rpb24gKHBvaW50cywgZWwpIHtcbiAgICAgICAgICAgIHZhciBoaXRSYXRlVmFsdWUgPSB0eXBlb2YgaGl0UmF0ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgPyBzcGxpdFVuaXQoXCJcIi5jb25jYXQoaGl0UmF0ZShlbCkpKVxuICAgICAgICAgICAgICAgIDogc3BsaXRVbml0KFwiXCIuY29uY2F0KGhpdFJhdGUpKTtcbiAgICAgICAgICAgIHZhciBpbkFyZWEgPSBpZ25vcmVDbGlja1xuICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IGlzSW5zaWRlKFtjbGllbnRYLCBjbGllbnRZXSwgcG9pbnRzKTtcbiAgICAgICAgICAgIGlmICghaXNEcmFnICYmIHNlbGVjdEJ5Q2xpY2sgJiYgaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcFBvaW50cyA9IGdldE92ZXJsYXBQb2ludHMocmVjdFBvaW50cywgcG9pbnRzKTtcbiAgICAgICAgICAgIGlmICghb3ZlcmxhcFBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcFNpemUgPSBnZXRBcmVhU2l6ZShvdmVybGFwUG9pbnRzKTtcbiAgICAgICAgICAgIC8vIExpbmVcbiAgICAgICAgICAgIHZhciB0YXJnZXRTaXplID0gMDtcbiAgICAgICAgICAgIGlmIChvdmVybGFwU2l6ZSA9PT0gMCAmJiBnZXRBcmVhU2l6ZShwb2ludHMpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2l6ZSA9IGdldExpbmVTaXplKHBvaW50cyk7XG4gICAgICAgICAgICAgICAgb3ZlcmxhcFNpemUgPSBnZXRMaW5lU2l6ZShvdmVybGFwUG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFNpemUgPSBnZXRBcmVhU2l6ZShwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhpdFJhdGVWYWx1ZS51bml0ID09PSBcInB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmxhcFNpemUgPj0gaGl0UmF0ZVZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGUgPSBiZXR3ZWVuKE1hdGgucm91bmQoKG92ZXJsYXBTaXplIC8gdGFyZ2V0U2l6ZSkgKiAxMDApLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIHJldHVybiByYXRlID49IE1hdGgubWluKDEwMCwgaGl0UmF0ZVZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNlbGVjdGFibGVUYXJnZXRzID0gZGF0YS5zZWxlY3RhYmxlVGFyZ2V0cztcbiAgICAgICAgdmFyIHNlbGVjdGFibGVQb2ludHMgPSBkYXRhLnNlbGVjdGFibGVQb2ludHM7XG4gICAgICAgIHZhciBzZWxlY3RhYmxlSW5uZXJzID0gZGF0YS5zZWxlY3RhYmxlSW5uZXJzO1xuICAgICAgICBpZiAoIWlubmVyR3JvdXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0YWJsZVRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RhYmxlSW5uZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzSGl0KHNlbGVjdGFibGVQb2ludHNbaV0sIHNlbGVjdGFibGVUYXJnZXRzW2ldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3RlZFRhcmdldHMgPSBbXTtcbiAgICAgICAgdmFyIG1pblggPSBNYXRoLmZsb29yKGxlZnQgLyBpbm5lcldpZHRoKTtcbiAgICAgICAgdmFyIG1heFggPSBNYXRoLmZsb29yKHJpZ2h0IC8gaW5uZXJXaWR0aCk7XG4gICAgICAgIHZhciBtaW5ZID0gTWF0aC5mbG9vcih0b3AgLyBpbm5lckhlaWdodCk7XG4gICAgICAgIHZhciBtYXhZID0gTWF0aC5mbG9vcihib3R0b20gLyBpbm5lckhlaWdodCk7XG4gICAgICAgIGZvciAodmFyIHggPSBtaW5YOyB4IDw9IG1heFg7ICsreCkge1xuICAgICAgICAgICAgdmFyIHlHcm91cHMgPSBpbm5lckdyb3Vwc1t4XTtcbiAgICAgICAgICAgIGlmICgheUdyb3Vwcykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IG1pblk7IHkgPD0gbWF4WTsgKyt5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0geUdyb3Vwc1t5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBncm91cC5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gc2VsZWN0YWJsZVBvaW50c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbm5lciA9IHNlbGVjdGFibGVJbm5lcnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gc2VsZWN0YWJsZVRhcmdldHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIgJiYgaXNIaXQocG9pbnRzLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlckR1cGxpY2F0ZWQoc2VsZWN0ZWRUYXJnZXRzKTtcbiAgICB9O1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLmluaXREcmFnU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRyYWdTY3JvbGxcbiAgICAgICAgICAgIC5vbihcInNjcm9sbERyYWdcIiwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IF9hLm5leHQ7XG4gICAgICAgICAgICBuZXh0KF90aGlzLmdlc3RvLmdldEN1cnJlbnRFdmVudCgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcInNjcm9sbFwiLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfYS5jb250YWluZXIsIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbjtcbiAgICAgICAgICAgIHZhciBpbm5lclNjcm9sbE9wdGlvbnMgPSBfdGhpcy5nZXN0by5nZXRFdmVudERhdGEoKS5pbm5lclNjcm9sbE9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoaW5uZXJTY3JvbGxPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImlubmVyU2Nyb2xsXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInNjcm9sbFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdmVcIiwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IF9hLm9mZnNldFgsIG9mZnNldFkgPSBfYS5vZmZzZXRZLCBpbnB1dEV2ZW50ID0gX2EuaW5wdXRFdmVudDtcbiAgICAgICAgICAgIHZhciBnZXN0byA9IF90aGlzLmdlc3RvO1xuICAgICAgICAgICAgaWYgKCFnZXN0byB8fCAhZ2VzdG8uaXNGbGFnKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IF90aGlzLmdlc3RvLmdldEV2ZW50RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGJvdW5kQXJlYSA9IGRhdGEuYm91bmRBcmVhO1xuICAgICAgICAgICAgZGF0YS5zdGFydFggLT0gb2Zmc2V0WDtcbiAgICAgICAgICAgIGRhdGEuc3RhcnRZIC09IG9mZnNldFk7XG4gICAgICAgICAgICB2YXIgaW5uZXJTY3JvbGxPcHRpb25zID0gX3RoaXMuZ2VzdG8uZ2V0RXZlbnREYXRhKCkuaW5uZXJTY3JvbGxPcHRpb25zO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGlubmVyU2Nyb2xsT3B0aW9ucyA9PT0gbnVsbCB8fCBpbm5lclNjcm9sbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlubmVyU2Nyb2xsT3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgICAgICB2YXIgaXNNb3ZlSW5uZXJTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50TWFwXzIgPSBkYXRhLnNlbGVjdGFibGVJbm5lclNjcm9sbFBhcmVudE1hcDtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5mbyA9IHBhcmVudE1hcF8yLmdldChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEluZm8ucGF0aHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBhcmVudE1hcF8yLmdldChzY3JvbGxDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVySW5mby5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzBdIC09IG9mZnNldFg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzFdIC09IG9mZnNldFk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEluZm8uaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWxlY3RhYmxlUG9pbnRzW2luZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMF0gLT0gb2Zmc2V0WDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMV0gLT0gb2Zmc2V0WTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaXNNb3ZlSW5uZXJTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNNb3ZlSW5uZXJTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnNlbGVjdGFibGVQb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc1swXSAtPSBvZmZzZXRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzFdIC09IG9mZnNldFk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX3JlZnJlc2hHcm91cHMoZGF0YSk7XG4gICAgICAgICAgICBib3VuZEFyZWEubGVmdCAtPSBvZmZzZXRYO1xuICAgICAgICAgICAgYm91bmRBcmVhLnJpZ2h0IC09IG9mZnNldFg7XG4gICAgICAgICAgICBib3VuZEFyZWEudG9wIC09IG9mZnNldFk7XG4gICAgICAgICAgICBib3VuZEFyZWEuYm90dG9tIC09IG9mZnNldFk7XG4gICAgICAgICAgICBfdGhpcy5nZXN0by5zY3JvbGxCeShvZmZzZXRYLCBvZmZzZXRZLCBpbnB1dEV2ZW50LmlucHV0RXZlbnQpO1xuICAgICAgICAgICAgX3RoaXMuX2NoZWNrU2VsZWN0ZWQoX3RoaXMuZ2VzdG8uZ2V0Q3VycmVudEV2ZW50KCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLl9zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0ZWRUYXJnZXRzLCByZWN0LCBlLCBpc1N0YXJ0LCBpc0RyYWdTdGFydEVuZCkge1xuICAgICAgICBpZiAoaXNEcmFnU3RhcnRFbmQgPT09IHZvaWQgMCkgeyBpc0RyYWdTdGFydEVuZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50O1xuICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2V0U2VsZWN0ZWRUYXJnZXRzKHNlbGVjdGVkVGFyZ2V0cyk7XG4gICAgICAgIHZhciBfYSA9IGRpZmYoZGF0YS5zdGFydFNlbGVjdGVkVGFyZ2V0cywgc2VsZWN0ZWRUYXJnZXRzKSwgYWRkZWQgPSBfYS5hZGRlZCwgcmVtb3ZlZCA9IF9hLnJlbW92ZWQsIHByZXZMaXN0ID0gX2EucHJldkxpc3QsIGxpc3QgPSBfYS5saXN0O1xuICAgICAgICB2YXIgc3RhcnRSZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGFydFNlbGVjdGVkOiBwcmV2TGlzdCxcbiAgICAgICAgICAgIHN0YXJ0QWRkZWQ6IGFkZGVkLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gbGlzdFtpXTsgfSksXG4gICAgICAgICAgICBzdGFydFJlbW92ZWQ6IHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBwcmV2TGlzdFtpXTsgfSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gdGhlIHNlbGVjdChkcmFnKSBzdGFydHMsIHRoZSBzZWxlY3RTdGFydCBldmVudCBpcyBjYWxsZWQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICAgICAgICogQGV2ZW50IHNlbGVjdFN0YXJ0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1NlbGVjdG8uT25TZWxlY3R9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHNlbGVjdFN0YXJ0IGV2ZW50XG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAgICAgICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICAgKiAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgICAgICAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogc2VsZWN0by5vbihcInNlbGVjdFN0YXJ0XCIsIGUgPT4ge1xuICAgICAgICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAqICAgfSk7XG4gICAgICAgICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgICAgICogfSkub24oXCJzZWxlY3RFbmRcIiwgZSA9PiB7XG4gICAgICAgICAgICAgKiAgIGUuYWZ0ZXJBZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgICAgICogICBlLmFmdGVyUmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW1pdChcInNlbGVjdFN0YXJ0XCIsIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCBzdGFydFJlc3VsdCksIHsgcmVjdDogcmVjdCwgaW5wdXRFdmVudDogaW5wdXRFdmVudCwgZGF0YTogZGF0YS5kYXRhLCBpc1RydXN0ZWQ6IGUuaXNUcnVzdGVkLCBpc0RyYWdTdGFydEVuZDogaXNEcmFnU3RhcnRFbmQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuYWRkZWQubGVuZ3RoIHx8IHJlc3VsdC5yZW1vdmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBzZWxlY3QgaW4gcmVhbCB0aW1lLCB0aGUgc2VsZWN0IGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgICAgICAgKiBAZXZlbnQgc2VsZWN0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1NlbGVjdG8uT25TZWxlY3R9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHNlbGVjdCBldmVudFxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKHtcbiAgICAgICAgICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgICogICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgICAgICAgICAgICogICBzZWxlY3RGcm9tSW5zaWRlOiBmYWxzZSxcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIHNlbGVjdG8ub24oXCJzZWxlY3RcIiwgZSA9PiB7XG4gICAgICAgICAgICAgKiAgIGUuYWRkZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICogICB9KTtcbiAgICAgICAgICAgICAqICAgZS5yZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAqICAgfSk7XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwic2VsZWN0XCIsIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCBzdGFydFJlc3VsdCksIHsgcmVjdDogcmVjdCwgaW5wdXRFdmVudDogaW5wdXRFdmVudCwgZGF0YTogZGF0YS5kYXRhLCBpc1RydXN0ZWQ6IGUuaXNUcnVzdGVkLCBpc0RyYWdTdGFydEVuZDogaXNEcmFnU3RhcnRFbmQgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3RvLnByb3RvdHlwZS5fc2VsZWN0RW5kID0gZnVuY3Rpb24gKHN0YXJ0U2VsZWN0ZWRUYXJnZXRzLCBzdGFydFBhc3NlZFRhcmdldHMsIHJlY3QsIGUsIGlzRHJhZ1N0YXJ0RW5kKSB7XG4gICAgICAgIGlmIChpc0RyYWdTdGFydEVuZCA9PT0gdm9pZCAwKSB7IGlzRHJhZ1N0YXJ0RW5kID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsIGlzRG91YmxlID0gZS5pc0RvdWJsZSwgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgdmFyIHR5cGUgPSBpbnB1dEV2ZW50ICYmIGlucHV0RXZlbnQudHlwZTtcbiAgICAgICAgdmFyIGlzRHJhZ1N0YXJ0ID0gdHlwZSA9PT0gXCJtb3VzZWRvd25cIiB8fCB0eXBlID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAgICAgdmFyIF9hID0gZGlmZihzdGFydFNlbGVjdGVkVGFyZ2V0cywgdGhpcy5zZWxlY3RlZFRhcmdldHMpLCBhZGRlZCA9IF9hLmFkZGVkLCByZW1vdmVkID0gX2EucmVtb3ZlZCwgcHJldkxpc3QgPSBfYS5wcmV2TGlzdCwgbGlzdCA9IF9hLmxpc3Q7XG4gICAgICAgIHZhciBfYiA9IGRpZmYoc3RhcnRQYXNzZWRUYXJnZXRzLCB0aGlzLnNlbGVjdGVkVGFyZ2V0cyksIGFmdGVyQWRkZWQgPSBfYi5hZGRlZCwgYWZ0ZXJSZW1vdmVkID0gX2IucmVtb3ZlZCwgYWZ0ZXJQcmV2TGlzdCA9IF9iLnByZXZMaXN0LCBhZnRlckxpc3QgPSBfYi5saXN0O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0aGUgc2VsZWN0KGRyYWdFbmQgb3IgY2xpY2spIGVuZHMsIHRoZSBzZWxlY3RFbmQgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICAgKiBAZXZlbnQgc2VsZWN0RW5kXG4gICAgICAgICAqIEBwYXJhbSB7U2VsZWN0by5PblNlbGVjdEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgc2VsZWN0RW5kIGV2ZW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgKiAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgICAgICAqICAgc2VsZWN0RnJvbUluc2lkZTogZmFsc2UsXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBzZWxlY3RvLm9uKFwic2VsZWN0U3RhcnRcIiwgZSA9PiB7XG4gICAgICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAqICAgfSk7XG4gICAgICAgICAqIH0pLm9uKFwic2VsZWN0RW5kXCIsIGUgPT4ge1xuICAgICAgICAgKiAgIGUuYWZ0ZXJBZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICogICBlLmFmdGVyUmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoXCJzZWxlY3RFbmRcIiwge1xuICAgICAgICAgICAgc3RhcnRTZWxlY3RlZDogc3RhcnRTZWxlY3RlZFRhcmdldHMsXG4gICAgICAgICAgICBiZWZvcmVTZWxlY3RlZDogc3RhcnRQYXNzZWRUYXJnZXRzLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWRUYXJnZXRzLFxuICAgICAgICAgICAgYWRkZWQ6IGFkZGVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGxpc3RbaW5kZXhdOyB9KSxcbiAgICAgICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gcHJldkxpc3RbaW5kZXhdOyB9KSxcbiAgICAgICAgICAgIGFmdGVyQWRkZWQ6IGFmdGVyQWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gYWZ0ZXJMaXN0W2luZGV4XTsgfSksXG4gICAgICAgICAgICBhZnRlclJlbW92ZWQ6IGFmdGVyUmVtb3ZlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBhZnRlclByZXZMaXN0W2luZGV4XTsgfSksXG4gICAgICAgICAgICBpc0RyYWdTdGFydDogaXNEcmFnU3RhcnQgJiYgaXNEcmFnU3RhcnRFbmQsXG4gICAgICAgICAgICBpc0RyYWdTdGFydEVuZDogaXNEcmFnU3RhcnQgJiYgaXNEcmFnU3RhcnRFbmQsXG4gICAgICAgICAgICBpc0NsaWNrOiAhIWUuaXNDbGljayxcbiAgICAgICAgICAgIGlzRG91YmxlOiAhIWlzRG91YmxlLFxuICAgICAgICAgICAgcmVjdDogcmVjdCxcbiAgICAgICAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLmRhdGEsXG4gICAgICAgICAgICBpc1RydXN0ZWQ6IGUuaXNUcnVzdGVkLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlbGVjdG8ucHJvdG90eXBlLl9jaGVja1NlbGVjdGVkID0gZnVuY3Rpb24gKGUsIHJlY3QpIHtcbiAgICAgICAgaWYgKHJlY3QgPT09IHZvaWQgMCkgeyByZWN0ID0gZ2V0UmVjdChlLCB0aGlzLm9wdGlvbnMucmF0aW8pOyB9XG4gICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICB2YXIgdG9wID0gcmVjdC50b3AsIGxlZnQgPSByZWN0LmxlZnQsIHdpZHRoID0gcmVjdC53aWR0aCwgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciBzZWxlY3RGbGFnID0gZGF0YS5zZWxlY3RGbGFnO1xuICAgICAgICB2YXIgY29udGFpbmVyWCA9IGRhdGEuY29udGFpbmVyWCwgY29udGFpbmVyWSA9IGRhdGEuY29udGFpbmVyWSwgc2NhbGVNYXRyaXggPSBkYXRhLnNjYWxlTWF0cml4O1xuICAgICAgICB2YXIgb2Zmc2V0UG9zID0gY2FsY3VsYXRlTWF0cml4RGlzdChzY2FsZU1hdHJpeCwgW1xuICAgICAgICAgICAgbGVmdCAtIGNvbnRhaW5lclgsXG4gICAgICAgICAgICB0b3AgLSBjb250YWluZXJZLFxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIG9mZnNldFNpemUgPSBjYWxjdWxhdGVNYXRyaXhEaXN0KHNjYWxlTWF0cml4LCBbXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciBzZWxlY3RlZFRhcmdldHMgPSBbXTtcbiAgICAgICAgaWYgKHNlbGVjdEZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnN0eWxlLmNzc1RleHQgKz1cbiAgICAgICAgICAgICAgICBcImRpc3BsYXk6IGJsb2NrO1wiICtcbiAgICAgICAgICAgICAgICAgICAgXCJsZWZ0OjBweDt0b3A6MHB4O1wiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZShcIi5jb25jYXQob2Zmc2V0UG9zWzBdLCBcInB4LCBcIikuY29uY2F0KG9mZnNldFBvc1sxXSwgXCJweCk7XCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aDpcIi5jb25jYXQob2Zmc2V0U2l6ZVswXSwgXCJweDtoZWlnaHQ6XCIpLmNvbmNhdChvZmZzZXRTaXplWzFdLCBcInB4O1wiKTtcbiAgICAgICAgICAgIHZhciBwYXNzZWRUYXJnZXRzID0gdGhpcy5oaXRUZXN0KHJlY3QsIGRhdGEsIHRydWUsIGUpO1xuICAgICAgICAgICAgc2VsZWN0ZWRUYXJnZXRzID0gcGFzc1RhcmdldHMoZGF0YS5zdGFydFBhc3NlZFRhcmdldHMsIHBhc3NlZFRhcmdldHMsIHRoaXMuY29udGludWVTZWxlY3QgJiYgdGhpcy5jb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdGhlIGRyYWcsIHRoZSBkcmFnIGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAgICogQ2FsbCB0aGUgc3RvcCAoKSBmdW5jdGlvbiBpZiB5b3UgaGF2ZSBhIHNwZWNpZmljIGVsZW1lbnQgb3IgZG9uJ3Qgd2FudCB0byByYWlzZSBhIHNlbGVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICAgKiBAZXZlbnQgZHJhZ1xuICAgICAgICAgKiBAcGFyYW0ge09uRHJhZ30gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZyBldmVudFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAgICAgKiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICogICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgICAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogc2VsZWN0by5vbihcImRyYWdcIiwgZSA9PiB7XG4gICAgICAgICAqICAgZS5zdG9wKCk7XG4gICAgICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAgICAgKiAgIGUuYWRkZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAqICAgfSk7XG4gICAgICAgICAqICAgZS5yZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmVtaXQoXCJkcmFnXCIsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBkYXRhOiBkYXRhLmRhdGEsIGlzU2VsZWN0OiBzZWxlY3RGbGFnLCByZWN0OiByZWN0IH0pKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gXCJkaXNwbGF5OiBub25lO1wiO1xuICAgICAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdEZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdChzZWxlY3RlZFRhcmdldHMsIHJlY3QsIGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3RvLnByb3RvdHlwZS5fc2FtZUNvbWJpS2V5ID0gZnVuY3Rpb24gKGUsIGtleXMsIGlzS2V5dXApIHtcbiAgICAgICAgaWYgKCFrZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbWJpID0gZ2V0Q29tYmkoZS5pbnB1dEV2ZW50LCBlLmtleSk7XG4gICAgICAgIHZhciBuZXh0S2V5cyA9IFtdLmNvbmNhdChrZXlzKTtcbiAgICAgICAgdmFyIHRvZ2dsZUtleXMgPSBpc0FycmF5KG5leHRLZXlzWzBdKSA/IG5leHRLZXlzIDogW25leHRLZXlzXTtcbiAgICAgICAgaWYgKGlzS2V5dXApIHtcbiAgICAgICAgICAgIHZhciBzaW5nbGVLZXlfMSA9IGUua2V5O1xuICAgICAgICAgICAgcmV0dXJuIHRvZ2dsZUtleXMuc29tZShmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5ID09PSBzaW5nbGVLZXlfMTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9nZ2xlS2V5cy5zb21lKGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb21iaS5pbmRleE9mKGtleSkgPiAtMTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0by5wcm90b3R5cGUuX2ZpbmRFbGVtZW50ID0gZnVuY3Rpb24gKGNsaWNrZWRUYXJnZXQsIHNlbGVjdGFibGVUYXJnZXRzKSB7XG4gICAgICAgIHZhciBwb2ludFRhcmdldCA9IGNsaWNrZWRUYXJnZXQ7XG4gICAgICAgIHdoaWxlIChwb2ludFRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGFibGVUYXJnZXRzLmluZGV4T2YocG9pbnRUYXJnZXQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50VGFyZ2V0ID0gcG9pbnRUYXJnZXQucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnRUYXJnZXQ7XG4gICAgfTtcbiAgICBTZWxlY3RvLnByb3RvdHlwZS5fcmVmcmVzaEdyb3VwcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGlubmVyV2lkdGggPSBkYXRhLmlubmVyV2lkdGg7XG4gICAgICAgIHZhciBpbm5lckhlaWdodCA9IGRhdGEuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHZhciBzZWxlY3RhYmxlUG9pbnRzID0gZGF0YS5zZWxlY3RhYmxlUG9pbnRzO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNoZWNrT3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHZhciBpbm5lclNjcm9sbENvbnRhaW5lcl8xID0gKF9hID0gdGhpcy5nZXN0by5nZXRFdmVudERhdGEoKS5pbm5lclNjcm9sbE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWluZXI7XG4gICAgICAgICAgICB2YXIgcGFyZW50TWFwXzMgPSBkYXRhLnNlbGVjdGFibGVJbm5lclNjcm9sbFBhcmVudE1hcDtcbiAgICAgICAgICAgIHZhciBpbm5lclNjcm9sbFBhdGhzTGlzdCA9IGRhdGEuc2VsZWN0YWJsZUlubmVyU2Nyb2xsUGF0aHNMaXN0O1xuICAgICAgICAgICAgZGF0YS5zZWxlY3RhYmxlSW5uZXJzID0gaW5uZXJTY3JvbGxQYXRoc0xpc3QubWFwKGZ1bmN0aW9uIChpbm5lclNjcm9sbFBhdGhzLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzQWx3YXlzVHJ1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lclNjcm9sbFBhdGhzLmV2ZXJ5KGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWx3YXlzVHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gaW5uZXJTY3JvbGxDb250YWluZXJfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbHdheXNUcnVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gcGFyZW50TWFwXzMuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzMSA9IHNlbGVjdGFibGVQb2ludHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzMiA9IHJlY3QucG9pbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBQb2ludHMgPSBnZXRPdmVybGFwUG9pbnRzKHBvaW50czEsIHBvaW50czIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdmVybGFwUG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5uZXJXaWR0aCB8fCAhaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIGRhdGEuaW5uZXJHcm91cHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGFibGVQb2ludHNfMSA9IGRhdGEuc2VsZWN0YWJsZVBvaW50cztcbiAgICAgICAgICAgIHZhciBncm91cHNfMSA9IHt9O1xuICAgICAgICAgICAgc2VsZWN0YWJsZVBvaW50c18xLmZvckVhY2goZnVuY3Rpb24gKHBvaW50cywgaSkge1xuICAgICAgICAgICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihwb3NbMF0gLyBpbm5lcldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKHBvc1sxXSAvIGlubmVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKHgsIG1pblgpO1xuICAgICAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgoeCwgbWF4WCk7XG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbih5LCBtaW5ZKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KHksIG1heFkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSBtaW5YOyB4IDw9IG1heFg7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gbWluWTsgeSA8PSBtYXhZOyArK3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc18xW3hdID0gZ3JvdXBzXzFbeF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHNfMVt4XVt5XSA9IGdyb3Vwc18xW3hdW3ldIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzXzFbeF1beV0ucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YS5pbm5lckdyb3VwcyA9IGdyb3Vwc18xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3RvID0gX19kZWNvcmF0ZShbXG4gICAgICAgIFByb3BlcnRpZXMoUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBjYW1lbGl6ZShcImdldCBcIi5jb25jYXQocHJvcGVydHkpKTtcbiAgICAgICAgICAgIGlmIChwcm90b3R5cGVbZ2V0dGVyXSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tnZXR0ZXJdKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNldHRlciA9IGNhbWVsaXplKFwic2V0IFwiLmNvbmNhdChwcm9wZXJ0eSkpO1xuICAgICAgICAgICAgaWYgKHByb3RvdHlwZVtzZXR0ZXJdKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzZXR0ZXJdKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBwcm9wZXJ0eSwgYXR0cmlidXRlcyk7XG4gICAgICAgIH0pXG4gICAgXSwgU2VsZWN0byk7XG4gICAgcmV0dXJuIFNlbGVjdG87XG59KEV2ZW50RW1pdHRlcikpO1xuXG52YXIgU2VsZWN0byA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VsZWN0bywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWxlY3RvKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTZWxlY3RvO1xufShTZWxlY3RvJDEpKTtcblxuZXhwb3J0IHsgQ0xBU1NfTkFNRSwgRVZFTlRTLCBNRVRIT0RTLCBPUFRJT05TLCBPUFRJT05fVFlQRVMsIFBST1BFUlRJRVMsIFNlbGVjdG8gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0by5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@interactify/selection/dist/selecto.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@interactify/infinite-viewer/dist/index.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@interactify/infinite-viewer/dist/index.es.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLASS_NAME: () => (/* binding */ qe),\n/* harmony export */   EVENTS: () => (/* binding */ Ge),\n/* harmony export */   METHODS: () => (/* binding */ wn),\n/* harmony export */   OPTIONS: () => (/* binding */ vn),\n/* harmony export */   PROPERTIES: () => (/* binding */ Gt),\n/* harmony export */   \"default\": () => (/* binding */ Cn)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar Tr = Object.defineProperty;\nvar zr = (i, n, t) => n in i ? Tr(i, n, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[n] = t;\nvar _ = (i, n, t) => zr(i, typeof n != \"symbol\" ? n + \"\" : n, t);\n\n\nvar Lt = { exports: {} }, ht = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar pe;\nfunction Dr() {\n  if (pe) return ht;\n  pe = 1;\n  var i = react__WEBPACK_IMPORTED_MODULE_0__, n = Symbol.for(\"react.element\"), t = Symbol.for(\"react.fragment\"), r = Object.prototype.hasOwnProperty, e = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function a(l, h, u) {\n    var d, v = {}, c = null, m = null;\n    u !== void 0 && (c = \"\" + u), h.key !== void 0 && (c = \"\" + h.key), h.ref !== void 0 && (m = h.ref);\n    for (d in h) r.call(h, d) && !o.hasOwnProperty(d) && (v[d] = h[d]);\n    if (l && l.defaultProps) for (d in h = l.defaultProps, h) v[d] === void 0 && (v[d] = h[d]);\n    return { $$typeof: n, type: l, key: c, ref: m, props: v, _owner: e.current };\n  }\n  return ht.Fragment = t, ht.jsx = a, ht.jsxs = a, ht;\n}\nvar ft = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar ge;\nfunction Yr() {\n  return ge || (ge = 1,  true && function() {\n    var i = react__WEBPACK_IMPORTED_MODULE_0__, n = Symbol.for(\"react.element\"), t = Symbol.for(\"react.portal\"), r = Symbol.for(\"react.fragment\"), e = Symbol.for(\"react.strict_mode\"), o = Symbol.for(\"react.profiler\"), a = Symbol.for(\"react.provider\"), l = Symbol.for(\"react.context\"), h = Symbol.for(\"react.forward_ref\"), u = Symbol.for(\"react.suspense\"), d = Symbol.for(\"react.suspense_list\"), v = Symbol.for(\"react.memo\"), c = Symbol.for(\"react.lazy\"), m = Symbol.for(\"react.offscreen\"), p = Symbol.iterator, S = \"@@iterator\";\n    function T(s) {\n      if (s === null || typeof s != \"object\")\n        return null;\n      var f = p && s[p] || s[S];\n      return typeof f == \"function\" ? f : null;\n    }\n    var z = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function b(s) {\n      {\n        for (var f = arguments.length, g = new Array(f > 1 ? f - 1 : 0), E = 1; E < f; E++)\n          g[E - 1] = arguments[E];\n        W(\"error\", s, g);\n      }\n    }\n    function W(s, f, g) {\n      {\n        var E = z.ReactDebugCurrentFrame, R = E.getStackAddendum();\n        R !== \"\" && (f += \"%s\", g = g.concat([R]));\n        var D = g.map(function(y) {\n          return String(y);\n        });\n        D.unshift(\"Warning: \" + f), Function.prototype.apply.call(console[s], console, D);\n      }\n    }\n    var k = !1, H = !1, V = !1, C = !1, P = !1, L;\n    L = Symbol.for(\"react.module.reference\");\n    function q(s) {\n      return !!(typeof s == \"string\" || typeof s == \"function\" || s === r || s === o || P || s === e || s === u || s === d || C || s === m || k || H || V || typeof s == \"object\" && s !== null && (s.$$typeof === c || s.$$typeof === v || s.$$typeof === a || s.$$typeof === l || s.$$typeof === h || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      s.$$typeof === L || s.getModuleId !== void 0));\n    }\n    function Z(s, f, g) {\n      var E = s.displayName;\n      if (E)\n        return E;\n      var R = f.displayName || f.name || \"\";\n      return R !== \"\" ? g + \"(\" + R + \")\" : g;\n    }\n    function F(s) {\n      return s.displayName || \"Context\";\n    }\n    function x(s) {\n      if (s == null)\n        return null;\n      if (typeof s.tag == \"number\" && b(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof s == \"function\")\n        return s.displayName || s.name || null;\n      if (typeof s == \"string\")\n        return s;\n      switch (s) {\n        case r:\n          return \"Fragment\";\n        case t:\n          return \"Portal\";\n        case o:\n          return \"Profiler\";\n        case e:\n          return \"StrictMode\";\n        case u:\n          return \"Suspense\";\n        case d:\n          return \"SuspenseList\";\n      }\n      if (typeof s == \"object\")\n        switch (s.$$typeof) {\n          case l:\n            var f = s;\n            return F(f) + \".Consumer\";\n          case a:\n            var g = s;\n            return F(g._context) + \".Provider\";\n          case h:\n            return Z(s, s.render, \"ForwardRef\");\n          case v:\n            var E = s.displayName || null;\n            return E !== null ? E : x(s.type) || \"Memo\";\n          case c: {\n            var R = s, D = R._payload, y = R._init;\n            try {\n              return x(y(D));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var B = Object.assign, K = 0, at, mt, _t, lt, Kt, Jt, Qt;\n    function te() {\n    }\n    te.__reactDisabledLog = !0;\n    function Je() {\n      {\n        if (K === 0) {\n          at = console.log, mt = console.info, _t = console.warn, lt = console.error, Kt = console.group, Jt = console.groupCollapsed, Qt = console.groupEnd;\n          var s = {\n            configurable: !0,\n            enumerable: !0,\n            value: te,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: s,\n            log: s,\n            warn: s,\n            error: s,\n            group: s,\n            groupCollapsed: s,\n            groupEnd: s\n          });\n        }\n        K++;\n      }\n    }\n    function Qe() {\n      {\n        if (K--, K === 0) {\n          var s = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: B({}, s, {\n              value: at\n            }),\n            info: B({}, s, {\n              value: mt\n            }),\n            warn: B({}, s, {\n              value: _t\n            }),\n            error: B({}, s, {\n              value: lt\n            }),\n            group: B({}, s, {\n              value: Kt\n            }),\n            groupCollapsed: B({}, s, {\n              value: Jt\n            }),\n            groupEnd: B({}, s, {\n              value: Qt\n            })\n          });\n        }\n        K < 0 && b(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var zt = z.ReactCurrentDispatcher, Rt;\n    function St(s, f, g) {\n      {\n        if (Rt === void 0)\n          try {\n            throw Error();\n          } catch (R) {\n            var E = R.stack.trim().match(/\\n( *(at )?)/);\n            Rt = E && E[1] || \"\";\n          }\n        return `\n` + Rt + s;\n      }\n    }\n    var Dt = !1, Et;\n    {\n      var tr = typeof WeakMap == \"function\" ? WeakMap : Map;\n      Et = new tr();\n    }\n    function ee(s, f) {\n      if (!s || Dt)\n        return \"\";\n      {\n        var g = Et.get(s);\n        if (g !== void 0)\n          return g;\n      }\n      var E;\n      Dt = !0;\n      var R = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var D;\n      D = zt.current, zt.current = null, Je();\n      try {\n        if (f) {\n          var y = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(y.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(y, []);\n            } catch ($) {\n              E = $;\n            }\n            Reflect.construct(s, [], y);\n          } else {\n            try {\n              y.call();\n            } catch ($) {\n              E = $;\n            }\n            s.call(y.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch ($) {\n            E = $;\n          }\n          s();\n        }\n      } catch ($) {\n        if ($ && E && typeof $.stack == \"string\") {\n          for (var w = $.stack.split(`\n`), j = E.stack.split(`\n`), X = w.length - 1, A = j.length - 1; X >= 1 && A >= 0 && w[X] !== j[A]; )\n            A--;\n          for (; X >= 1 && A >= 0; X--, A--)\n            if (w[X] !== j[A]) {\n              if (X !== 1 || A !== 1)\n                do\n                  if (X--, A--, A < 0 || w[X] !== j[A]) {\n                    var N = `\n` + w[X].replace(\" at new \", \" at \");\n                    return s.displayName && N.includes(\"<anonymous>\") && (N = N.replace(\"<anonymous>\", s.displayName)), typeof s == \"function\" && Et.set(s, N), N;\n                  }\n                while (X >= 1 && A >= 0);\n              break;\n            }\n        }\n      } finally {\n        Dt = !1, zt.current = D, Qe(), Error.prepareStackTrace = R;\n      }\n      var nt = s ? s.displayName || s.name : \"\", J = nt ? St(nt) : \"\";\n      return typeof s == \"function\" && Et.set(s, J), J;\n    }\n    function er(s, f, g) {\n      return ee(s, !1);\n    }\n    function rr(s) {\n      var f = s.prototype;\n      return !!(f && f.isReactComponent);\n    }\n    function wt(s, f, g) {\n      if (s == null)\n        return \"\";\n      if (typeof s == \"function\")\n        return ee(s, rr(s));\n      if (typeof s == \"string\")\n        return St(s);\n      switch (s) {\n        case u:\n          return St(\"Suspense\");\n        case d:\n          return St(\"SuspenseList\");\n      }\n      if (typeof s == \"object\")\n        switch (s.$$typeof) {\n          case h:\n            return er(s.render);\n          case v:\n            return wt(s.type, f, g);\n          case c: {\n            var E = s, R = E._payload, D = E._init;\n            try {\n              return wt(D(R), f, g);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var ct = Object.prototype.hasOwnProperty, re = {}, ne = z.ReactDebugCurrentFrame;\n    function bt(s) {\n      if (s) {\n        var f = s._owner, g = wt(s.type, s._source, f ? f.type : null);\n        ne.setExtraStackFrame(g);\n      } else\n        ne.setExtraStackFrame(null);\n    }\n    function nr(s, f, g, E, R) {\n      {\n        var D = Function.call.bind(ct);\n        for (var y in s)\n          if (D(s, y)) {\n            var w = void 0;\n            try {\n              if (typeof s[y] != \"function\") {\n                var j = Error((E || \"React class\") + \": \" + g + \" type `\" + y + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof s[y] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw j.name = \"Invariant Violation\", j;\n              }\n              w = s[y](f, y, E, g, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (X) {\n              w = X;\n            }\n            w && !(w instanceof Error) && (bt(R), b(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", E || \"React class\", g, y, typeof w), bt(null)), w instanceof Error && !(w.message in re) && (re[w.message] = !0, bt(R), b(\"Failed %s type: %s\", g, w.message), bt(null));\n          }\n      }\n    }\n    var ir = Array.isArray;\n    function Yt(s) {\n      return ir(s);\n    }\n    function or(s) {\n      {\n        var f = typeof Symbol == \"function\" && Symbol.toStringTag, g = f && s[Symbol.toStringTag] || s.constructor.name || \"Object\";\n        return g;\n      }\n    }\n    function sr(s) {\n      try {\n        return ie(s), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function ie(s) {\n      return \"\" + s;\n    }\n    function oe(s) {\n      if (sr(s))\n        return b(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", or(s)), ie(s);\n    }\n    var ut = z.ReactCurrentOwner, ar = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, se, ae, xt;\n    xt = {};\n    function lr(s) {\n      if (ct.call(s, \"ref\")) {\n        var f = Object.getOwnPropertyDescriptor(s, \"ref\").get;\n        if (f && f.isReactWarning)\n          return !1;\n      }\n      return s.ref !== void 0;\n    }\n    function cr(s) {\n      if (ct.call(s, \"key\")) {\n        var f = Object.getOwnPropertyDescriptor(s, \"key\").get;\n        if (f && f.isReactWarning)\n          return !1;\n      }\n      return s.key !== void 0;\n    }\n    function ur(s, f) {\n      if (typeof s.ref == \"string\" && ut.current && f && ut.current.stateNode !== f) {\n        var g = x(ut.current.type);\n        xt[g] || (b('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', x(ut.current.type), s.ref), xt[g] = !0);\n      }\n    }\n    function hr(s, f) {\n      {\n        var g = function() {\n          se || (se = !0, b(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", f));\n        };\n        g.isReactWarning = !0, Object.defineProperty(s, \"key\", {\n          get: g,\n          configurable: !0\n        });\n      }\n    }\n    function fr(s, f) {\n      {\n        var g = function() {\n          ae || (ae = !0, b(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", f));\n        };\n        g.isReactWarning = !0, Object.defineProperty(s, \"ref\", {\n          get: g,\n          configurable: !0\n        });\n      }\n    }\n    var vr = function(s, f, g, E, R, D, y) {\n      var w = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: n,\n        // Built-in properties that belong on the element\n        type: s,\n        key: f,\n        ref: g,\n        props: y,\n        // Record the component responsible for creating this element.\n        _owner: D\n      };\n      return w._store = {}, Object.defineProperty(w._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(w, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: E\n      }), Object.defineProperty(w, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: R\n      }), Object.freeze && (Object.freeze(w.props), Object.freeze(w)), w;\n    };\n    function dr(s, f, g, E, R) {\n      {\n        var D, y = {}, w = null, j = null;\n        g !== void 0 && (oe(g), w = \"\" + g), cr(f) && (oe(f.key), w = \"\" + f.key), lr(f) && (j = f.ref, ur(f, R));\n        for (D in f)\n          ct.call(f, D) && !ar.hasOwnProperty(D) && (y[D] = f[D]);\n        if (s && s.defaultProps) {\n          var X = s.defaultProps;\n          for (D in X)\n            y[D] === void 0 && (y[D] = X[D]);\n        }\n        if (w || j) {\n          var A = typeof s == \"function\" ? s.displayName || s.name || \"Unknown\" : s;\n          w && hr(y, A), j && fr(y, A);\n        }\n        return vr(s, w, j, R, E, ut.current, y);\n      }\n    }\n    var Ot = z.ReactCurrentOwner, le = z.ReactDebugCurrentFrame;\n    function rt(s) {\n      if (s) {\n        var f = s._owner, g = wt(s.type, s._source, f ? f.type : null);\n        le.setExtraStackFrame(g);\n      } else\n        le.setExtraStackFrame(null);\n    }\n    var Xt;\n    Xt = !1;\n    function Pt(s) {\n      return typeof s == \"object\" && s !== null && s.$$typeof === n;\n    }\n    function ce() {\n      {\n        if (Ot.current) {\n          var s = x(Ot.current.type);\n          if (s)\n            return `\n\nCheck the render method of \\`` + s + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function pr(s) {\n      return \"\";\n    }\n    var ue = {};\n    function gr(s) {\n      {\n        var f = ce();\n        if (!f) {\n          var g = typeof s == \"string\" ? s : s.displayName || s.name;\n          g && (f = `\n\nCheck the top-level render call using <` + g + \">.\");\n        }\n        return f;\n      }\n    }\n    function he(s, f) {\n      {\n        if (!s._store || s._store.validated || s.key != null)\n          return;\n        s._store.validated = !0;\n        var g = gr(f);\n        if (ue[g])\n          return;\n        ue[g] = !0;\n        var E = \"\";\n        s && s._owner && s._owner !== Ot.current && (E = \" It was passed a child from \" + x(s._owner.type) + \".\"), rt(s), b('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', g, E), rt(null);\n      }\n    }\n    function fe(s, f) {\n      {\n        if (typeof s != \"object\")\n          return;\n        if (Yt(s))\n          for (var g = 0; g < s.length; g++) {\n            var E = s[g];\n            Pt(E) && he(E, f);\n          }\n        else if (Pt(s))\n          s._store && (s._store.validated = !0);\n        else if (s) {\n          var R = T(s);\n          if (typeof R == \"function\" && R !== s.entries)\n            for (var D = R.call(s), y; !(y = D.next()).done; )\n              Pt(y.value) && he(y.value, f);\n        }\n      }\n    }\n    function mr(s) {\n      {\n        var f = s.type;\n        if (f == null || typeof f == \"string\")\n          return;\n        var g;\n        if (typeof f == \"function\")\n          g = f.propTypes;\n        else if (typeof f == \"object\" && (f.$$typeof === h || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        f.$$typeof === v))\n          g = f.propTypes;\n        else\n          return;\n        if (g) {\n          var E = x(f);\n          nr(g, s.props, \"prop\", E, s);\n        } else if (f.PropTypes !== void 0 && !Xt) {\n          Xt = !0;\n          var R = x(f);\n          b(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", R || \"Unknown\");\n        }\n        typeof f.getDefaultProps == \"function\" && !f.getDefaultProps.isReactClassApproved && b(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function _r(s) {\n      {\n        for (var f = Object.keys(s.props), g = 0; g < f.length; g++) {\n          var E = f[g];\n          if (E !== \"children\" && E !== \"key\") {\n            rt(s), b(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", E), rt(null);\n            break;\n          }\n        }\n        s.ref !== null && (rt(s), b(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), rt(null));\n      }\n    }\n    var ve = {};\n    function de(s, f, g, E, R, D) {\n      {\n        var y = q(s);\n        if (!y) {\n          var w = \"\";\n          (s === void 0 || typeof s == \"object\" && s !== null && Object.keys(s).length === 0) && (w += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var j = pr();\n          j ? w += j : w += ce();\n          var X;\n          s === null ? X = \"null\" : Yt(s) ? X = \"array\" : s !== void 0 && s.$$typeof === n ? (X = \"<\" + (x(s.type) || \"Unknown\") + \" />\", w = \" Did you accidentally export a JSX literal instead of a component?\") : X = typeof s, b(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", X, w);\n        }\n        var A = dr(s, f, g, R, D);\n        if (A == null)\n          return A;\n        if (y) {\n          var N = f.children;\n          if (N !== void 0)\n            if (E)\n              if (Yt(N)) {\n                for (var nt = 0; nt < N.length; nt++)\n                  fe(N[nt], s);\n                Object.freeze && Object.freeze(N);\n              } else\n                b(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              fe(N, s);\n        }\n        if (ct.call(f, \"key\")) {\n          var J = x(s), $ = Object.keys(f).filter(function(Cr) {\n            return Cr !== \"key\";\n          }), At = $.length > 0 ? \"{key: someKey, \" + $.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n          if (!ve[J + At]) {\n            var yr = $.length > 0 ? \"{\" + $.join(\": ..., \") + \": ...}\" : \"{}\";\n            b(`A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />`, At, J, yr, J), ve[J + At] = !0;\n          }\n        }\n        return s === r ? _r(A) : mr(A), A;\n      }\n    }\n    function Sr(s, f, g) {\n      return de(s, f, g, !0);\n    }\n    function Er(s, f, g) {\n      return de(s, f, g, !1);\n    }\n    var wr = Er, br = Sr;\n    ft.Fragment = r, ft.jsx = wr, ft.jsxs = br;\n  }()), ft;\n}\n false ? 0 : Lt.exports = Yr();\nvar Q = Lt.exports, xr = \"function\", Or = \"object\", Xr = \"string\", Pr = \"undefined\", Ar = typeof document !== Pr && document, Mr = [{\n  open: \"(\",\n  close: \")\"\n}, {\n  open: '\"',\n  close: '\"'\n}, {\n  open: \"'\",\n  close: \"'\"\n}, {\n  open: '\\\\\"',\n  close: '\\\\\"'\n}, {\n  open: \"\\\\'\",\n  close: \"\\\\'\"\n}], yt = {\n  cm: function(i) {\n    return i * 96 / 2.54;\n  },\n  mm: function(i) {\n    return i * 96 / 254;\n  },\n  in: function(i) {\n    return i * 96;\n  },\n  pt: function(i) {\n    return i * 96 / 72;\n  },\n  pc: function(i) {\n    return i * 96 / 6;\n  },\n  \"%\": function(i, n) {\n    return i * n / 100;\n  },\n  vw: function(i, n) {\n    return n === void 0 && (n = window.innerWidth), i / 100 * n;\n  },\n  vh: function(i, n) {\n    return n === void 0 && (n = window.innerHeight), i / 100 * n;\n  },\n  vmax: function(i, n) {\n    return n === void 0 && (n = Math.max(window.innerWidth, window.innerHeight)), i / 100 * n;\n  },\n  vmin: function(i, n) {\n    return n === void 0 && (n = Math.min(window.innerWidth, window.innerHeight)), i / 100 * n;\n  }\n};\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction kr() {\n  for (var i = 0, n = 0, t = arguments.length; n < t; n++) i += arguments[n].length;\n  for (var r = Array(i), e = 0, n = 0; n < t; n++) for (var o = arguments[n], a = 0, l = o.length; a < l; a++, e++) r[e] = o[a];\n  return r;\n}\nfunction st(i) {\n  return i && typeof i === Or;\n}\nfunction vt(i) {\n  return Array.isArray(i);\n}\nfunction Oe(i) {\n  return typeof i === Xr;\n}\nfunction Wr(i) {\n  return typeof i === xr;\n}\nfunction Lr(i, n) {\n  var t = i === \"\" || i == \" \", r = n === \"\" || n == \" \";\n  return r && t || i === n;\n}\nfunction Xe(i, n, t, r, e) {\n  var o = Vt(i, n, t);\n  return o ? t : Fr(i, n, t + 1, r, e);\n}\nfunction Vt(i, n, t) {\n  if (!i.ignore)\n    return null;\n  var r = n.slice(Math.max(t - 3, 0), t + 3).join(\"\");\n  return new RegExp(i.ignore).exec(r);\n}\nfunction Fr(i, n, t, r, e) {\n  for (var o = function(u) {\n    var d = n[u].trim();\n    if (d === i.close && !Vt(i, n, u))\n      return {\n        value: u\n      };\n    var v = u, c = Ft(e, function(m) {\n      var p = m.open;\n      return p === d;\n    });\n    if (c && (v = Xe(c, n, u, r, e)), v === -1)\n      return a = u, \"break\";\n    u = v, a = u;\n  }, a, l = t; l < r; ++l) {\n    var h = o(l);\n    if (l = a, typeof h == \"object\") return h.value;\n    if (h === \"break\") break;\n  }\n  return -1;\n}\nfunction Pe(i, n) {\n  var t = Oe(n) ? {\n    separator: n\n  } : n, r = t.separator, e = r === void 0 ? \",\" : r, o = t.isSeparateFirst, a = t.isSeparateOnlyOpenClose, l = t.isSeparateOpenClose, h = l === void 0 ? a : l, u = t.openCloseCharacters, d = u === void 0 ? Mr : u, v = d.map(function(C) {\n    var P = C.open, L = C.close;\n    return P === L ? P : P + \"|\" + L;\n  }).join(\"|\"), c = \"(\\\\s*\" + e + \"\\\\s*|\" + v + \"|\\\\s+)\", m = new RegExp(c, \"g\"), p = i.split(m).filter(function(C) {\n    return C && C !== \"undefined\";\n  }), S = p.length, T = [], z = [];\n  function b() {\n    return z.length ? (T.push(z.join(\"\")), z = [], !0) : !1;\n  }\n  for (var W = function(C) {\n    var P = p[C].trim(), L = C, q = Ft(d, function(x) {\n      var B = x.open;\n      return B === P;\n    }), Z = Ft(d, function(x) {\n      var B = x.close;\n      return B === P;\n    });\n    if (q) {\n      if (L = Xe(q, p, C, S, d), L !== -1 && h)\n        return b() && o || (T.push(p.slice(C, L + 1).join(\"\")), C = L, o) ? (k = C, \"break\") : (k = C, \"continue\");\n    } else if (Z && !Vt(Z, p, C)) {\n      var F = kr(d);\n      return F.splice(d.indexOf(Z), 1), {\n        value: Pe(i, {\n          separator: e,\n          isSeparateFirst: o,\n          isSeparateOnlyOpenClose: a,\n          isSeparateOpenClose: h,\n          openCloseCharacters: F\n        })\n      };\n    } else if (Lr(P, e) && !a)\n      return b(), o ? (k = C, \"break\") : (k = C, \"continue\");\n    L === -1 && (L = S - 1), z.push(p.slice(C, L + 1).join(\"\")), C = L, k = C;\n  }, k, H = 0; H < S; ++H) {\n    var V = W(H);\n    if (H = k, typeof V == \"object\") return V.value;\n    if (V === \"break\") break;\n  }\n  return z.length && T.push(z.join(\"\")), T;\n}\nfunction jr(i) {\n  return Pe(i, \",\");\n}\nfunction Ir(i) {\n  var n = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(i);\n  if (!n)\n    return {\n      prefix: \"\",\n      unit: \"\",\n      value: NaN\n    };\n  var t = n[1], r = n[2], e = n[3];\n  return {\n    prefix: t,\n    unit: e,\n    value: parseFloat(r)\n  };\n}\nfunction Ae(i) {\n  return i.replace(/[\\s-_]+([^\\s-_])/g, function(n, t) {\n    return t.toUpperCase();\n  });\n}\nfunction me() {\n  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();\n}\nfunction Me(i, n, t) {\n  t === void 0 && (t = -1);\n  for (var r = i.length, e = 0; e < r; ++e)\n    if (n(i[e], e, i))\n      return e;\n  return t;\n}\nfunction Ft(i, n, t) {\n  var r = Me(i, n);\n  return r > -1 ? i[r] : t;\n}\nfunction G(i, n) {\n  var t = Ir(i), r = t.value, e = t.unit;\n  if (st(n)) {\n    var o = n[e];\n    if (o) {\n      if (Wr(o))\n        return o(r);\n      if (yt[e])\n        return yt[e](r, o);\n    }\n  } else if (e === \"%\")\n    return r * n / 100;\n  return yt[e] ? yt[e](r) : r;\n}\nfunction tt(i, n, t) {\n  return Math.max(n, Math.min(i, t));\n}\nfunction $r(i, n) {\n  var t = 1 / n;\n  return Math.round(i / n) / t;\n}\nfunction it(i, n) {\n  i.classList ? i.classList.add(n) : i.className += \" \" + n;\n}\nfunction O(i, n, t, r) {\n  i.addEventListener(n, t, r);\n}\nfunction Y(i, n, t, r) {\n  i.removeEventListener(n, t, r);\n}\nfunction Nt(i) {\n  return (i == null ? void 0 : i.ownerDocument) || Ar;\n}\nfunction ot(i) {\n  var n;\n  return ((n = i == null ? void 0 : i.ownerDocument) === null || n === void 0 ? void 0 : n.defaultView) || window;\n}\nfunction Br(i) {\n  return i && \"postMessage\" in i && \"blur\" in i && \"self\" in i;\n}\nfunction _e(i) {\n  return st(i) && i.nodeName && i.nodeType && \"ownerDocument\" in i;\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar jt = function() {\n  return jt = Object.assign || function(n) {\n    for (var t, r = 1, e = arguments.length; r < e; r++) {\n      t = arguments[r];\n      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (n[o] = t[o]);\n    }\n    return n;\n  }, jt.apply(this, arguments);\n};\nfunction Hr() {\n  for (var i = 0, n = 0, t = arguments.length; n < t; n++) i += arguments[n].length;\n  for (var r = Array(i), e = 0, n = 0; n < t; n++) for (var o = arguments[n], a = 0, l = o.length; a < l; a++, e++) r[e] = o[a];\n  return r;\n}\nvar Zt = /* @__PURE__ */ function() {\n  function i() {\n    this._events = {};\n  }\n  var n = i.prototype;\n  return n.on = function(t, r) {\n    if (st(t))\n      for (var e in t)\n        this.on(e, t[e]);\n    else\n      this._addEvent(t, r, {});\n    return this;\n  }, n.off = function(t, r) {\n    if (!t)\n      this._events = {};\n    else if (st(t))\n      for (var e in t)\n        this.off(e);\n    else if (!r)\n      this._events[t] = [];\n    else {\n      var o = this._events[t];\n      if (o) {\n        var a = Me(o, function(l) {\n          return l.listener === r;\n        });\n        a > -1 && o.splice(a, 1);\n      }\n    }\n    return this;\n  }, n.once = function(t, r) {\n    var e = this;\n    return r && this._addEvent(t, r, {\n      once: !0\n    }), new Promise(function(o) {\n      e._addEvent(t, o, {\n        once: !0\n      });\n    });\n  }, n.emit = function(t, r) {\n    var e = this;\n    r === void 0 && (r = {});\n    var o = this._events[t];\n    if (!t || !o)\n      return !0;\n    var a = !1;\n    return r.eventType = t, r.stop = function() {\n      a = !0;\n    }, r.currentTarget = this, Hr(o).forEach(function(l) {\n      l.listener(r), l.once && e.off(t, l.listener);\n    }), !a;\n  }, n.trigger = function(t, r) {\n    return r === void 0 && (r = {}), this.emit(t, r);\n  }, n._addEvent = function(t, r, e) {\n    var o = this._events;\n    o[t] = o[t] || [];\n    var a = o[t];\n    a.push(jt({\n      listener: r\n    }, e));\n  }, i;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar It = function(i, n) {\n  return It = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {\n    t.__proto__ = r;\n  } || function(t, r) {\n    for (var e in r) r.hasOwnProperty(e) && (t[e] = r[e]);\n  }, It(i, n);\n};\nfunction Vr(i, n) {\n  It(i, n);\n  function t() {\n    this.constructor = i;\n  }\n  i.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());\n}\nvar M = function() {\n  return M = Object.assign || function(n) {\n    for (var t, r = 1, e = arguments.length; r < e; r++) {\n      t = arguments[r];\n      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (n[o] = t[o]);\n    }\n    return n;\n  }, M.apply(this, arguments);\n};\nfunction Nr(i, n) {\n  var t = n[0] - i[0], r = n[1] - i[1], e = Math.atan2(r, t);\n  return e >= 0 ? e : e + Math.PI * 2;\n}\nfunction Mt(i) {\n  return Nr([\n    i[0].clientX,\n    i[0].clientY\n  ], [\n    i[1].clientX,\n    i[1].clientY\n  ]) / Math.PI * 180;\n}\nfunction Zr(i) {\n  return i.touches && i.touches.length >= 2;\n}\nfunction Ct(i) {\n  return i ? i.touches ? qr(i.touches) : [ke(i)] : [];\n}\nfunction Ur(i) {\n  return i && (i.type.indexOf(\"mouse\") > -1 || \"button\" in i);\n}\nfunction Se(i, n, t) {\n  var r = t.length, e = gt(i, r), o = e.clientX, a = e.clientY, l = e.originalClientX, h = e.originalClientY, u = gt(n, r), d = u.clientX, v = u.clientY, c = gt(t, r), m = c.clientX, p = c.clientY, S = o - d, T = a - v, z = o - m, b = a - p;\n  return {\n    clientX: l,\n    clientY: h,\n    deltaX: S,\n    deltaY: T,\n    distX: z,\n    distY: b\n  };\n}\nfunction kt(i) {\n  return Math.sqrt(Math.pow(i[0].clientX - i[1].clientX, 2) + Math.pow(i[0].clientY - i[1].clientY, 2));\n}\nfunction qr(i) {\n  for (var n = Math.min(i.length, 2), t = [], r = 0; r < n; ++r)\n    t.push(ke(i[r]));\n  return t;\n}\nfunction ke(i) {\n  return {\n    clientX: i.clientX,\n    clientY: i.clientY\n  };\n}\nfunction gt(i, n) {\n  n === void 0 && (n = i.length);\n  for (var t = {\n    clientX: 0,\n    clientY: 0,\n    originalClientX: 0,\n    originalClientY: 0\n  }, r = Math.min(i.length, n), e = 0; e < r; ++e) {\n    var o = i[e];\n    t.originalClientX += \"originalClientX\" in o ? o.originalClientX : o.clientX, t.originalClientY += \"originalClientY\" in o ? o.originalClientY : o.clientY, t.clientX += o.clientX, t.clientY += o.clientY;\n  }\n  return n ? {\n    clientX: t.clientX / n,\n    clientY: t.clientY / n,\n    originalClientX: t.originalClientX / n,\n    originalClientY: t.originalClientY / n\n  } : t;\n}\nvar Wt = /* @__PURE__ */ function() {\n  function i(n) {\n    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = n, this.prevClients = n, this.length = n.length;\n  }\n  return i.prototype.getAngle = function(n) {\n    return n === void 0 && (n = this.prevClients), Mt(n);\n  }, i.prototype.getRotation = function(n) {\n    return n === void 0 && (n = this.prevClients), Mt(n) - Mt(this.startClients);\n  }, i.prototype.getPosition = function(n, t) {\n    n === void 0 && (n = this.prevClients);\n    var r = Se(n || this.prevClients, this.prevClients, this.startClients), e = r.deltaX, o = r.deltaY;\n    return this.movement += Math.sqrt(e * e + o * o), this.prevClients = n, r;\n  }, i.prototype.getPositions = function(n) {\n    n === void 0 && (n = this.prevClients);\n    for (var t = this.prevClients, r = this.startClients, e = Math.min(this.length, t.length), o = [], a = 0; a < e; ++a)\n      o[a] = Se([n[a]], [t[a]], [r[a]]);\n    return o;\n  }, i.prototype.getMovement = function(n) {\n    var t = this.movement;\n    if (!n)\n      return t;\n    var r = gt(n, this.length), e = gt(this.prevClients, this.length), o = r.clientX - e.clientX, a = r.clientY - e.clientY;\n    return Math.sqrt(o * o + a * a) + t;\n  }, i.prototype.getDistance = function(n) {\n    return n === void 0 && (n = this.prevClients), kt(n);\n  }, i.prototype.getScale = function(n) {\n    return n === void 0 && (n = this.prevClients), kt(n) / kt(this.startClients);\n  }, i.prototype.move = function(n, t) {\n    this.startClients.forEach(function(r) {\n      r.clientX -= n, r.clientY -= t;\n    }), this.prevClients.forEach(function(r) {\n      r.clientX -= n, r.clientY -= t;\n    });\n  }, i;\n}(), Ee = [\"textarea\", \"input\"], We = /* @__PURE__ */ function(i) {\n  Vr(n, i);\n  function n(t, r) {\n    r === void 0 && (r = {});\n    var e = i.call(this) || this;\n    e.options = {}, e.flag = !1, e.pinchFlag = !1, e.data = {}, e.isDrag = !1, e.isPinch = !1, e.clientStores = [], e.targets = [], e.prevTime = 0, e.doubleFlag = !1, e._useMouse = !1, e._useTouch = !1, e._useDrag = !1, e._dragFlag = !1, e._isTrusted = !1, e._isMouseEvent = !1, e._isSecondaryButton = !1, e._preventMouseEvent = !1, e._prevInputEvent = null, e._isDragAPI = !1, e._isIdle = !0, e._preventMouseEventId = 0, e._window = window, e.onDragStart = function(c, m) {\n      if (m === void 0 && (m = !0), !(!e.flag && c.cancelable === !1)) {\n        var p = c.type.indexOf(\"drag\") >= -1;\n        if (!(e.flag && p)) {\n          e._isDragAPI = !0;\n          var S = e.options, T = S.container, z = S.pinchOutside, b = S.preventWheelClick, W = S.preventRightClick, k = S.preventDefault, H = S.checkInput, V = S.dragFocusedInput, C = S.preventClickEventOnDragStart, P = S.preventClickEventOnDrag, L = S.preventClickEventByCondition, q = e._useTouch, Z = !e.flag;\n          if (e._isSecondaryButton = c.which === 3 || c.button === 2, b && (c.which === 2 || c.button === 1) || W && (c.which === 3 || c.button === 2))\n            return e.stop(), !1;\n          if (Z) {\n            var F = e._window.document.activeElement, x = c.target;\n            if (x) {\n              var B = x.tagName.toLowerCase(), K = Ee.indexOf(B) > -1, at = x.isContentEditable;\n              if (K || at) {\n                if (H || !V && F === x)\n                  return !1;\n                if (F && (F === x || at && F.isContentEditable && F.contains(x)))\n                  if (V)\n                    x.blur();\n                  else\n                    return !1;\n              } else if ((k || c.type === \"touchstart\") && F) {\n                var mt = F.tagName.toLowerCase();\n                (F.isContentEditable || Ee.indexOf(mt) > -1) && F.blur();\n              }\n              (C || P || L) && O(e._window, \"click\", e._onClick, !0);\n            }\n            e.clientStores = [new Wt(Ct(c))], e._isIdle = !1, e.flag = !0, e.isDrag = !1, e._isTrusted = m, e._dragFlag = !0, e._prevInputEvent = c, e.data = {}, e.doubleFlag = me() - e.prevTime < 200, e._isMouseEvent = Ur(c), !e._isMouseEvent && e._preventMouseEvent && e._allowMouseEvent();\n            var _t = e._preventMouseEvent || e.emit(\"dragStart\", M(M({ data: e.data, datas: e.data, inputEvent: c, isMouseEvent: e._isMouseEvent, isSecondaryButton: e._isSecondaryButton, isTrusted: m, isDouble: e.doubleFlag }, e.getCurrentStore().getPosition()), { preventDefault: function() {\n              c.preventDefault();\n            }, preventDrag: function() {\n              e._dragFlag = !1;\n            } }));\n            _t === !1 && e.stop(), e._isMouseEvent && e.flag && k && c.preventDefault();\n          }\n          if (!e.flag)\n            return !1;\n          var lt = 0;\n          if (Z ? (e._attchDragEvent(), q && z && (lt = setTimeout(function() {\n            O(T, \"touchstart\", e.onDragStart, {\n              passive: !1\n            });\n          }))) : q && z && Y(T, \"touchstart\", e.onDragStart), e.flag && Zr(c)) {\n            if (clearTimeout(lt), Z && c.touches.length !== c.changedTouches.length)\n              return;\n            e.pinchFlag || e.onPinchStart(c);\n          }\n        }\n      }\n    }, e.onDrag = function(c, m) {\n      if (e.flag) {\n        var p = e.options.preventDefault;\n        !e._isMouseEvent && p && c.preventDefault(), e._prevInputEvent = c;\n        var S = Ct(c), T = e.moveClients(S, c, !1);\n        if (e._dragFlag) {\n          if (e.pinchFlag || T.deltaX || T.deltaY) {\n            var z = e._preventMouseEvent || e.emit(\"drag\", M(M({}, T), { isScroll: !!m, inputEvent: c }));\n            if (z === !1) {\n              e.stop();\n              return;\n            }\n          }\n          e.pinchFlag && e.onPinch(c, S);\n        }\n        e.getCurrentStore().getPosition(S, !0);\n      }\n    }, e.onDragEnd = function(c) {\n      if (e.flag) {\n        var m = e.options, p = m.pinchOutside, S = m.container, T = m.preventClickEventOnDrag, z = m.preventClickEventOnDragStart, b = m.preventClickEventByCondition, W = e.isDrag;\n        (T || z || b) && requestAnimationFrame(function() {\n          e._allowClickEvent();\n        }), !b && !z && T && !W && e._allowClickEvent(), e._useTouch && p && Y(S, \"touchstart\", e.onDragStart), e.pinchFlag && e.onPinchEnd(c);\n        var k = c != null && c.touches ? Ct(c) : [], H = k.length;\n        H === 0 || !e.options.keepDragging ? e.flag = !1 : e._addStore(new Wt(k));\n        var V = e._getPosition(), C = me(), P = !W && e.doubleFlag;\n        e._prevInputEvent = null, e.prevTime = W || P ? 0 : C, e.flag || (e._dettachDragEvent(), e._preventMouseEvent || e.emit(\"dragEnd\", M({ data: e.data, datas: e.data, isDouble: P, isDrag: W, isClick: !W, isMouseEvent: e._isMouseEvent, isSecondaryButton: e._isSecondaryButton, inputEvent: c, isTrusted: e._isTrusted }, V)), e.clientStores = [], e._isMouseEvent || (e._preventMouseEvent = !0, clearTimeout(e._preventMouseEventId), e._preventMouseEventId = setTimeout(function() {\n          e._preventMouseEvent = !1;\n        }, 200)), e._isIdle = !0);\n      }\n    }, e.onBlur = function() {\n      e.onDragEnd();\n    }, e._allowClickEvent = function() {\n      Y(e._window, \"click\", e._onClick, !0);\n    }, e._onClick = function(c) {\n      e._allowClickEvent(), e._allowMouseEvent();\n      var m = e.options.preventClickEventByCondition;\n      m != null && m(c) || (c.stopPropagation(), c.preventDefault());\n    }, e._onContextMenu = function(c) {\n      var m = e.options;\n      m.preventRightClick ? e.onDragEnd(c) : c.preventDefault();\n    }, e._passCallback = function() {\n    };\n    var o = [].concat(t), a = o[0];\n    e._window = Br(a) ? a : ot(a), e.options = M({ checkInput: !1, container: a && !(\"document\" in a) ? ot(a) : a, preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: [\"touch\", \"mouse\"] }, r);\n    var l = e.options, h = l.container, u = l.events, d = l.checkWindowBlur;\n    if (e._useDrag = u.indexOf(\"drag\") > -1, e._useTouch = u.indexOf(\"touch\") > -1, e._useMouse = u.indexOf(\"mouse\") > -1, e.targets = o, e._useDrag && o.forEach(function(c) {\n      O(c, \"dragstart\", e.onDragStart);\n    }), e._useMouse && (o.forEach(function(c) {\n      O(c, \"mousedown\", e.onDragStart), O(c, \"mousemove\", e._passCallback);\n    }), O(h, \"contextmenu\", e._onContextMenu)), d && O(ot(), \"blur\", e.onBlur), e._useTouch) {\n      var v = {\n        passive: !1\n      };\n      o.forEach(function(c) {\n        O(c, \"touchstart\", e.onDragStart, v), O(c, \"touchmove\", e._passCallback, v);\n      });\n    }\n    return e;\n  }\n  return n.prototype.stop = function() {\n    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._isIdle = !0, this._allowClickEvent(), this._dettachDragEvent(), this._isDragAPI = !1;\n  }, n.prototype.getMovement = function(t) {\n    return this.getCurrentStore().getMovement(t) + this.clientStores.slice(1).reduce(function(r, e) {\n      return r + e.movement;\n    }, 0);\n  }, n.prototype.isDragging = function() {\n    return this.isDrag;\n  }, n.prototype.isIdle = function() {\n    return this._isIdle;\n  }, n.prototype.isFlag = function() {\n    return this.flag;\n  }, n.prototype.isPinchFlag = function() {\n    return this.pinchFlag;\n  }, n.prototype.isDoubleFlag = function() {\n    return this.doubleFlag;\n  }, n.prototype.isPinching = function() {\n    return this.isPinch;\n  }, n.prototype.scrollBy = function(t, r, e, o) {\n    o === void 0 && (o = !0), this.flag && (this.clientStores[0].move(t, r), o && this.onDrag(e, !0));\n  }, n.prototype.move = function(t, r) {\n    var e = t[0], o = t[1], a = this.getCurrentStore(), l = a.prevClients;\n    return this.moveClients(l.map(function(h) {\n      var u = h.clientX, d = h.clientY;\n      return {\n        clientX: u + e,\n        clientY: d + o,\n        originalClientX: u,\n        originalClientY: d\n      };\n    }), r, !0);\n  }, n.prototype.triggerDragStart = function(t) {\n    this.onDragStart(t, !1);\n  }, n.prototype.setEventData = function(t) {\n    var r = this.data;\n    for (var e in t)\n      r[e] = t[e];\n    return this;\n  }, n.prototype.setEventDatas = function(t) {\n    return this.setEventData(t);\n  }, n.prototype.getCurrentEvent = function(t) {\n    return t === void 0 && (t = this._prevInputEvent), M(M({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: t });\n  }, n.prototype.getEventData = function() {\n    return this.data;\n  }, n.prototype.getEventDatas = function() {\n    return this.data;\n  }, n.prototype.unset = function() {\n    var t = this, r = this.targets, e = this.options.container;\n    this.off(), Y(this._window, \"blur\", this.onBlur), this._useDrag && r.forEach(function(o) {\n      Y(o, \"dragstart\", t.onDragStart);\n    }), this._useMouse && (r.forEach(function(o) {\n      Y(o, \"mousedown\", t.onDragStart);\n    }), Y(e, \"contextmenu\", this._onContextMenu)), this._useTouch && (r.forEach(function(o) {\n      Y(o, \"touchstart\", t.onDragStart);\n    }), Y(e, \"touchstart\", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();\n  }, n.prototype.onPinchStart = function(t) {\n    var r = this, e = this.options.pinchThreshold;\n    if (!(this.isDrag && this.getMovement() > e)) {\n      var o = new Wt(Ct(t));\n      this.pinchFlag = !0, this._addStore(o);\n      var a = this.emit(\"pinchStart\", M(M({ data: this.data, datas: this.data, angle: o.getAngle(), touches: this.getCurrentStore().getPositions() }, o.getPosition()), { inputEvent: t, isTrusted: this._isTrusted, preventDefault: function() {\n        t.preventDefault();\n      }, preventDrag: function() {\n        r._dragFlag = !1;\n      } }));\n      a === !1 && (this.pinchFlag = !1);\n    }\n  }, n.prototype.onPinch = function(t, r) {\n    if (!(!this.flag || !this.pinchFlag || r.length < 2)) {\n      var e = this.getCurrentStore();\n      this.isPinch = !0, this.emit(\"pinch\", M(M({ data: this.data, datas: this.data, movement: this.getMovement(r), angle: e.getAngle(r), rotation: e.getRotation(r), touches: e.getPositions(r), scale: e.getScale(r), distance: e.getDistance(r) }, e.getPosition(r)), { inputEvent: t, isTrusted: this._isTrusted }));\n    }\n  }, n.prototype.onPinchEnd = function(t) {\n    if (this.pinchFlag) {\n      var r = this.isPinch;\n      this.isPinch = !1, this.pinchFlag = !1;\n      var e = this.getCurrentStore();\n      this.emit(\"pinchEnd\", M(M({ data: this.data, datas: this.data, isPinch: r, touches: e.getPositions() }, e.getPosition()), { inputEvent: t }));\n    }\n  }, n.prototype.getCurrentStore = function() {\n    return this.clientStores[0];\n  }, n.prototype.moveClients = function(t, r, e) {\n    var o = this._getPosition(t, e), a = this.isDrag;\n    (o.deltaX || o.deltaY) && (this.isDrag = !0);\n    var l = !1;\n    return !a && this.isDrag && (l = !0), M(M({ data: this.data, datas: this.data }, o), { movement: this.getMovement(t), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: r, isTrusted: this._isTrusted, isFirstDrag: l });\n  }, n.prototype._addStore = function(t) {\n    this.clientStores.splice(0, 0, t);\n  }, n.prototype._getPosition = function(t, r) {\n    var e = this.getCurrentStore(), o = e.getPosition(t, r), a = this.clientStores.slice(1).reduce(function(u, d) {\n      var v = d.getPosition();\n      return u.distX += v.distX, u.distY += v.distY, u;\n    }, o), l = a.distX, h = a.distY;\n    return M(M({}, o), { distX: l, distY: h });\n  }, n.prototype._attchDragEvent = function() {\n    var t = this._window, r = this.options.container, e = {\n      passive: !1\n    };\n    this._isDragAPI && (O(r, \"dragover\", this.onDrag, e), O(t, \"dragend\", this.onDragEnd)), this._useMouse && (O(r, \"mousemove\", this.onDrag), O(t, \"mouseup\", this.onDragEnd)), this._useTouch && (O(r, \"touchmove\", this.onDrag, e), O(t, \"touchend\", this.onDragEnd, e), O(t, \"touchcancel\", this.onDragEnd, e));\n  }, n.prototype._dettachDragEvent = function() {\n    var t = this._window, r = this.options.container;\n    this._isDragAPI && (Y(r, \"dragover\", this.onDrag), Y(t, \"dragend\", this.onDragEnd)), this._useMouse && (Y(r, \"mousemove\", this.onDrag), Y(t, \"mouseup\", this.onDragEnd)), this._useTouch && (Y(r, \"touchstart\", this.onDragStart), Y(r, \"touchmove\", this.onDrag), Y(t, \"touchend\", this.onDragEnd), Y(t, \"touchcancel\", this.onDragEnd));\n  }, n.prototype._allowMouseEvent = function() {\n    this._preventMouseEvent = !1, clearTimeout(this._preventMouseEventId);\n  }, n;\n}(Zt);\nfunction Gr(i) {\n  for (var n = 5381, t = i.length; t; )\n    n = n * 33 ^ i.charCodeAt(--t);\n  return n >>> 0;\n}\nvar Kr = Gr;\nfunction Jr(i) {\n  return Kr(i).toString(36);\n}\nfunction Qr(i) {\n  if (i && i.getRootNode) {\n    var n = i.getRootNode();\n    if (n.nodeType === 11)\n      return n;\n  }\n}\nfunction tn(i, n, t) {\n  return t.original ? n : n.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, function(r, e) {\n    var o = e.trim();\n    return (o ? jr(o) : [\"\"]).map(function(a) {\n      var l = a.trim();\n      return l.indexOf(\"@\") === 0 ? l : l.indexOf(\":global\") > -1 ? l.replace(/\\:global/g, \"\") : l.indexOf(\":host\") > -1 ? \"\".concat(l.replace(/\\:host/g, \".\".concat(i))) : l ? \".\".concat(i, \" \").concat(l) : \".\".concat(i);\n    }).join(\", \") + \" {\";\n  });\n}\nfunction en(i, n, t, r, e) {\n  var o = Nt(r), a = o.createElement(\"style\");\n  return a.setAttribute(\"type\", \"text/css\"), a.setAttribute(\"data-styled-id\", i), a.setAttribute(\"data-styled-count\", \"1\"), t.nonce && a.setAttribute(\"nonce\", t.nonce), a.innerHTML = tn(i, n, t), (e || o.head || o.body).appendChild(a), a;\n}\nfunction rn(i) {\n  var n = \"rCS\" + Jr(i);\n  return {\n    className: n,\n    inject: function(t, r) {\n      r === void 0 && (r = {});\n      var e = Qr(t), o = (e || t.ownerDocument || document).querySelector('style[data-styled-id=\"'.concat(n, '\"]'));\n      if (!o)\n        o = en(n, i, r, t, e);\n      else {\n        var a = parseFloat(o.getAttribute(\"data-styled-count\")) || 0;\n        o.setAttribute(\"data-styled-count\", \"\".concat(a + 1));\n      }\n      return {\n        destroy: function() {\n          var l, h = parseFloat(o.getAttribute(\"data-styled-count\")) || 0;\n          h <= 1 ? (o.remove ? o.remove() : (l = o.parentNode) === null || l === void 0 || l.removeChild(o), o = null) : o.setAttribute(\"data-styled-count\", \"\".concat(h - 1));\n        }\n      };\n    }\n  };\n}\nfunction Ut(i, n) {\n  for (var t = i.length, r = 0; r < t; ++r)\n    if (n(i[r], r))\n      return !0;\n  return !1;\n}\nfunction Le(i, n) {\n  for (var t = i.length, r = 0; r < t; ++r)\n    if (n(i[r], r))\n      return i[r];\n  return null;\n}\nfunction Fe(i) {\n  var n = i;\n  if (typeof n > \"u\") {\n    if (typeof navigator > \"u\" || !navigator)\n      return \"\";\n    n = navigator.userAgent || \"\";\n  }\n  return n.toLowerCase();\n}\nfunction qt(i, n) {\n  try {\n    return new RegExp(i, \"g\").exec(n);\n  } catch {\n    return null;\n  }\n}\nfunction nn() {\n  if (typeof navigator > \"u\" || !navigator || !navigator.userAgentData)\n    return !1;\n  var i = navigator.userAgentData, n = i.brands || i.uaList;\n  return !!(n && n.length);\n}\nfunction on(i, n) {\n  var t = qt(\"(\" + i + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", n);\n  return t ? t[3] : \"\";\n}\nfunction $t(i) {\n  return i.replace(/_/g, \".\");\n}\nfunction pt(i, n) {\n  var t = null, r = \"-1\";\n  return Ut(i, function(e) {\n    var o = qt(\"(\" + e.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", n);\n    return !o || e.brand ? !1 : (t = e, r = o[3] || \"-1\", e.versionAlias ? r = e.versionAlias : e.versionTest && (r = on(e.versionTest.toLowerCase(), n) || r), r = $t(r), !0);\n  }), {\n    preset: t,\n    version: r\n  };\n}\nfunction Tt(i, n) {\n  var t = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  return Ut(i, function(r) {\n    var e = je(n, r);\n    return e ? (t.brand = r.id, t.version = r.versionAlias || e.version, t.version !== \"-1\") : !1;\n  }), t;\n}\nfunction je(i, n) {\n  return Le(i, function(t) {\n    var r = t.brand;\n    return qt(\"\" + n.test, r.toLowerCase());\n  });\n}\nvar Ie = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}], $e = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: !0\n}], Bt = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}], Be = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  // test webview\n  test: \"webview\",\n  id: \"webview\"\n}], He = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\nfunction Ve(i) {\n  return !!pt(Be, i).preset;\n}\nfunction sn(i) {\n  var n = Fe(i), t = !!/mobi/g.exec(n), r = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: Ve(n),\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webkit: !1,\n    webkitVersion: \"-1\"\n  }, e = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  }, o = pt(Ie, n), a = o.preset, l = o.version, h = pt(He, n), u = h.preset, d = h.version, v = pt($e, n);\n  if (r.chromium = !!v.preset, r.chromiumVersion = v.version, !r.chromium) {\n    var c = pt(Bt, n);\n    r.webkit = !!c.preset, r.webkitVersion = c.version;\n  }\n  return u && (e.name = u.id, e.version = d, e.majorVersion = parseInt(d, 10)), a && (r.name = a.id, r.version = l, r.webview && e.name === \"ios\" && r.name !== \"safari\" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {\n    browser: r,\n    os: e,\n    isMobile: t,\n    isHints: !1\n  };\n}\nfunction an(i) {\n  var n = navigator.userAgentData, t = (n.uaList || n.brands).slice(), r = n.mobile || !1, e = t[0], o = (n.platform || navigator.platform).toLowerCase(), a = {\n    name: e.brand,\n    version: e.version,\n    majorVersion: -1,\n    webkit: !1,\n    webkitVersion: \"-1\",\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webview: !!Tt(Be, t).brand || Ve(Fe())\n  }, l = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  a.webkit = !a.chromium && Ut(Bt, function(c) {\n    return je(t, c);\n  });\n  var h = Tt($e, t);\n  if (a.chromium = !!h.brand, a.chromiumVersion = h.version || \"-1\", !a.chromium) {\n    var u = Tt(Bt, t);\n    a.webkit = !!u.brand, a.webkitVersion = u.version || \"-1\";\n  }\n  var d = Le(He, function(c) {\n    return new RegExp(\"\" + c.test, \"g\").exec(o);\n  });\n  l.name = d ? d.id : \"\";\n  {\n    var v = Tt(Ie, t);\n    a.name = v.brand || a.name, a.version = v.brand && i ? i.uaFullVersion : v.version;\n  }\n  return a.webkit && (l.name = r ? \"ios\" : \"mac\"), l.name === \"ios\" && a.webview && (a.version = \"-1\"), l.version = $t(l.version), a.version = $t(a.version), l.majorVersion = parseInt(l.version, 10), a.majorVersion = parseInt(a.version, 10), {\n    browser: a,\n    os: l,\n    isMobile: r,\n    isHints: !0\n  };\n}\nfunction ln(i) {\n  return nn() ? an() : sn(i);\n}\nfunction cn(i, n) {\n  return n.replace(/([^}{]*){/gm, (t, r) => `${r.replace(/\\.([^{,\\s\\d.]+)/g, `.${i}$1`)}{`);\n}\nfunction dt(i, n) {\n  return (t) => {\n    t && (i[n] = t);\n  };\n}\nconst un = ln(), hn = un.browser.name === \"safari\", et = \"infinite-viewer-\", we = `${et}wrapper`, be = `${et}scroll-area`, fn = `${et}scroll-bar`, Ne = `${et}horizontal-scroll-bar`, Ze = `${et}vertical-scroll-bar`, ye = `${et}scroll-thumb`, Ue = rn(\n  cn(\n    et,\n    `\n{\n    position: relative;\n    overscroll-behavior: none;\n}\n.wrapper {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    overflow: auto;\n    scrollbar-width: none;\n    top: 0;\n    left: 0;\n    will-change: scroll-position;\n}\n.restrict-wrapper {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n}\n.wrapper::-webkit-scrollbar {\n    display: none;\n}\n.scroll-area {\n    position:absolute;\n    top:0;\n    left:0;\n    transform-origin: 0 0;\n}\n.scroll-bar {\n    position:absolute;\n    width: 10px;\n    height: 10px;\n    box-sizing: border-box;\n    right: 0;\n    bottom: 0;\n    overflow: hidden;\n}\n.horizontal-scroll-bar {\n    width: calc(100% - 20px);\n    right: 10px;\n    height: 14px;\n}\n.vertical-scroll-bar {\n    height: calc(100% - 20px);\n    bottom: 10px;\n    width: 14px;\n}\n.scroll-thumb {\n    position:relative;\n    opacity: 0.7;\n    background: #333;\n    border-radius: 3px;\n    left: 0px;\n    top: 0px;\n    z-index: 10;\n    width: 6px;\n    height: 6px;\n    transition: all ease 0.2s;\n    opacity: 0;\n}\n.scroll-bar:hover .scroll-thumb {\n    border-radius: 5px;\n    opacity: 1;\n}\n.horizontal-scroll-bar .scroll-thumb {\n    margin: 4px 0px;\n    transition-property: opacity, margin, height, border-radius;\n}\n.vertical-scroll-bar .scroll-thumb {\n    margin: 0px 4px;\n    transition-property: opacity, margin, width, border-radius;\n}\n.horizontal-scroll-bar:hover .scroll-thumb {\n    height: 10px;\n    margin: 2px 0px;\n}\n.vertical-scroll-bar:hover .scroll-thumb {\n    width: 10px;\n    margin: 0px 2px;\n}\n`\n  )\n), I = {\n  margin: 500,\n  threshold: 100,\n  zoom: 1,\n  zoomX: 1,\n  zoomY: 1,\n  rangeX: [-1 / 0, 1 / 0],\n  rangeY: [-1 / 0, 1 / 0],\n  rangeOffsetX: [0, 0],\n  rangeOffsetY: [0, 0],\n  wrapperElement: null,\n  scrollAreaElement: null,\n  horizontalScrollElement: null,\n  verticalScrollElement: null,\n  usePinch: !1,\n  useAutoZoom: !1,\n  useMouseDrag: !1,\n  pinchThreshold: 30,\n  cspNonce: \"\",\n  maxPinchWheel: 1 / 0,\n  wheelScale: 0.01,\n  displayHorizontalScroll: !0,\n  displayVerticalScroll: !0,\n  useTransform: !0,\n  useWheelPinch: !0,\n  zoomRange: [1e-3, 1 / 0],\n  wheelPinchKey: \"ctrl\",\n  useWheelScroll: hn,\n  zoomOffsetX: \"50%\",\n  zoomOffsetY: \"50%\",\n  translateZ: 0,\n  useGesture: !0,\n  useResizeObserver: !1,\n  pinchDirection: \"all\",\n  preventWheelClick: !0,\n  useBounceScrollBar: !1,\n  useOverflowScroll: !1\n}, Ce = (i) => 1 - Math.pow(1 - i, 3), Te = {\n  horizontal: {\n    pos: \"Left\",\n    coord: \"X\",\n    size: \"Width\"\n  },\n  vertical: {\n    pos: \"Top\",\n    coord: \"Y\",\n    size: \"Height\"\n  }\n}, qe = Ue.className, Gt = [\n  \"margin\",\n  \"threshold\",\n  \"zoomOffsetX\",\n  \"zoomOffsetY\",\n  \"zoom\",\n  \"zoomX\",\n  \"zoomY\",\n  \"rangeX\",\n  \"rangeY\",\n  \"rangeOffsetX\",\n  \"rangeOffsetY\",\n  \"usePinch\",\n  \"useMouseDrag\",\n  \"pinchThreshold\",\n  \"maxPinchWheel\",\n  \"wheelScale\",\n  \"displayVerticalScroll\",\n  \"displayHorizontalScroll\",\n  \"translateZ\",\n  \"useAutoZoom\",\n  \"wheelPinchKey\",\n  \"zoomRange\",\n  \"zoomRangeX\",\n  \"zoomRangeY\",\n  \"pinchDirection\",\n  \"useOverflowScroll\"\n], vn = [\n  // ignore target, container,\n  ...Gt,\n  \"preventWheelClick\",\n  \"useWheelPinch\",\n  \"useWheelScroll\",\n  \"useGesture\",\n  \"cspNonce\",\n  \"wrapperElement\",\n  \"scrollAreaElement\",\n  \"verticalScrollElement\",\n  \"horizontalScrollElement\",\n  \"useResizeObserver\",\n  \"wheelContainer\",\n  \"useBounceScrollBar\"\n], Ge = [\n  \"scroll\",\n  \"abortPinch\",\n  \"dragStart\",\n  \"dragEnd\",\n  \"pinchStart\",\n  \"pinch\"\n], wn = [\n  \"getScrollLeft\",\n  \"getScrollTop\",\n  \"getScrollWidth\",\n  \"getScrollHeight\",\n  \"getContainerWidth\",\n  \"getContainerHeight\",\n  \"getViewportWidth\",\n  \"getViewportHeight\",\n  \"getViewportScrollWidth\",\n  \"getViewportScrollHeight\",\n  \"scrollTo\",\n  \"scrollBy\",\n  \"zoomBy\",\n  \"scrollCenter\",\n  \"getContainer\",\n  \"getViewport\",\n  \"getWrapper\",\n  \"setZoom\",\n  \"getRangeX\",\n  \"getRangeY\",\n  \"resize\",\n  \"getZoom\",\n  \"getZoomX\",\n  \"getZoomY\",\n  \"getWheelContainer\",\n  \"setTo\",\n  \"setBy\"\n], dn = 1e-6;\nfunction pn(i) {\n  const { deltaX: n, deltaY: t, datas: r } = i, e = Date.now(), o = r.speed;\n  if (!o) {\n    r.speed = [0, 0], r.time = e;\n    return;\n  }\n  const a = e - r.time;\n  r.speed = [o[0] / 2 + n / a, o[1] / 2 + t / a];\n}\nfunction Ke(i, n) {\n  const t = Math.sqrt(i[0] * i[0] + i[1] * i[1]);\n  return Math.abs(t / n);\n}\nfunction gn(i, n) {\n  const t = Ke(i, n);\n  return [\n    -i[0] / 2 * t,\n    -i[1] / 2 * t\n  ];\n}\nfunction U(i) {\n  return Math.abs(i);\n}\nfunction mn(i, n, t, r, e) {\n  const o = e || isFinite(t[0]) ? t[0] : Math.min(-1, Math.floor(i / n)) * n - r, a = e || isFinite(t[1]) ? t[1] : Math.max(1, Math.ceil(i / n)) * n + r;\n  return [o, a];\n}\nfunction ze(i, n) {\n  return i ?? n;\n}\nfunction Re(i, n, t) {\n  const r = t.duration, e = t.easing || ((h) => 1 - Math.pow(1 - h, 3)), o = Date.now();\n  let a = o;\n  const l = () => {\n    const h = Date.now();\n    let u = h - o;\n    r < u && (u = r);\n    const d = e(u / r), v = e((a - o) / r);\n    a = h, i(d - v), !(u >= r) && n(l);\n  };\n  n(l);\n}\nclass De extends Zt {\n  constructor(t, r, e) {\n    super();\n    _(this, \"isAppend\", !1);\n    _(this, \"thumbElement\");\n    _(this, \"barElement\");\n    _(this, \"gesto\");\n    _(this, \"size\", 0);\n    _(this, \"scrollSize\", 0);\n    _(this, \"isHorizontal\", !1);\n    _(this, \"_onDragStart\", (t) => {\n      const r = this.isHorizontal, e = t.inputEvent.target, o = t.datas, a = this.thumbElement === e;\n      a || setTimeout(() => {\n        requestAnimationFrame(() => {\n          const l = this.thumbElement.getBoundingClientRect(), h = l[r ? \"left\" : \"top\"], u = l[r ? \"width\" : \"height\"], d = h + u, v = t[r ? \"clientX\" : \"clientY\"];\n          if (h <= v && v <= d)\n            return;\n          const c = this.size, m = c * c / this.scrollSize;\n          this.scrollBy(h < v ? m : -m);\n        });\n      }, 100), o.isThumb = a, t.inputEvent.stopPropagation(), t.inputEvent.preventDefault();\n    });\n    _(this, \"_onDrag\", (t) => {\n      t.datas.isThumb && this.scrollBy(this.isHorizontal ? t.deltaX : t.deltaY);\n    });\n    _(this, \"_onWheel\", (t) => {\n      const r = this.isHorizontal ? t.deltaX : t.deltaY;\n      r && t.preventDefault(), this.trigger(\"scroll\", {\n        delta: r\n      });\n    });\n    this.type = r;\n    const o = r === \"horizontal\", a = Nt(t);\n    let l, h = e;\n    e ? l = e.querySelector(`.${ye}`) : (h = a.createElement(\"div\"), l = a.createElement(\"div\"), h.insertBefore(l, null), this.isAppend = !0), it(\n      h,\n      o ? Ne : Ze\n    ), it(h, fn), it(l, ye), this.thumbElement = l, this.barElement = h, this.isHorizontal = o, this.gesto = new We(h, {\n      container: ot(a)\n    }).on(\"dragStart\", (u) => this._onDragStart(u)).on(\"drag\", (u) => this._onDrag(u)), O(this.barElement, \"wheel\", this._onWheel, {\n      passive: !1\n    });\n  }\n  scrollBy(t, r) {\n    const e = t / this.size;\n    this.trigger(\"scroll\", {\n      delta: r ? t : this.scrollSize * e\n    });\n  }\n  render(t, r, e, o) {\n    this.size = e, this.scrollSize = o;\n    const a = t && $r(o - e, 1e-3) > 0 ? 1 : 0, [l, h] = this.isHorizontal ? [\"X\", \"width\"] : [\"Y\", \"height\"], u = e / o * 100, d = Math.max(0, r) / o * 100;\n    this.thumbElement.style.cssText += `${h}: ${u}%;opacity: ${a};transform: translate${l}(${100 / u * d}%)`;\n  }\n  destroy() {\n    Y(this.barElement, \"wheel\", this._onWheel), this.gesto.off(), this.off();\n  }\n}\nlet Ht = class extends Zt {\n  /**\n   * @sort 1\n   */\n  constructor(t, r = {}, e = {}) {\n    super();\n    _(this, \"options\");\n    _(this, \"injectResult\");\n    _(this, \"wrapperElement\");\n    _(this, \"scrollAreaElement\");\n    _(this, \"horizontalScrollbar\");\n    _(this, \"verticalScrollbar\");\n    _(this, \"gesto\");\n    _(this, \"offsetX\", 0);\n    _(this, \"offsetY\", 0);\n    _(this, \"containerWidth\", 0);\n    _(this, \"containerHeight\", 0);\n    _(this, \"viewportWidth\", 0);\n    _(this, \"viewportHeight\", 0);\n    _(this, \"viewportScrollWidth\", 0);\n    _(this, \"viewportScrollHeight\", 0);\n    _(this, \"scrollLeft\", 0);\n    _(this, \"scrollTop\", 0);\n    _(this, \"_scrollTimer\", 0);\n    _(this, \"_zoomTimer\", 0);\n    _(this, \"_viewportElement\", null);\n    _(this, \"_wheelContainerElement\", null);\n    _(this, \"dragFlag\", !1);\n    _(this, \"isLoop\", !1);\n    _(this, \"_tempScale\", [1, 1]);\n    _(this, \"_tempRect\", null);\n    _(this, \"_tempRectTimer\", null);\n    _(this, \"_onDestroys\", []);\n    _(this, \"_asLeft\", 0);\n    _(this, \"_asTop\", 0);\n    /**\n     * Update Viewer Sizes\n     * @method\n     */\n    _(this, \"resize\", () => {\n      const { offsetWidth: t, offsetHeight: r } = this._containerElement, {\n        offsetWidth: e,\n        offsetHeight: o,\n        scrollWidth: a,\n        scrollHeight: l\n      } = this._viewportElement;\n      this.containerWidth = t, this.containerHeight = r, this.viewportWidth = e, this.viewportHeight = o, this.viewportScrollWidth = Math.max(e, a), this.viewportScrollHeight = Math.max(o, l), this.render(), this._scrollBy(0, 0);\n    });\n    _(this, \"_onScroll\", () => {\n      const { scrollLeft: t, scrollTop: r } = this.wrapperElement, { zoom: e = I.zoom } = this, o = t - this.scrollLeft, a = r - this.scrollTop, l = this.getScrollLeft(), h = this.getScrollTop();\n      this.isLoop && (this.isLoop = !1), this.scrollLeft = t, this.scrollTop = r, this.scrollTo(\n        l + o / e,\n        h + a / e\n      );\n    });\n    _(this, \"onWheel\", (t) => {\n      const r = this.options, e = r.pinchDirection, o = r.maxPinchWheel || 1 / 0, a = t[`${this.wheelPinchKey}Key`] || t.ctrlKey;\n      if (r.useWheelPinch && a) {\n        let l = t.deltaY;\n        const h = l >= 0 ? 1 : -1, u = Math.min(o, Math.abs(l));\n        l = h * u;\n        const d = -l, v = Math.max(\n          1 + d * (r.wheelScale || 0.01),\n          dn\n        );\n        clearTimeout(this._tempRectTimer), this._tempRectTimer = window.setTimeout(() => {\n          this._tempRect = null;\n        }, 100), this._triggerPinch({\n          distance: u,\n          scale: v,\n          rotation: 0,\n          zoom: this.zoom * v,\n          zoomX: this.zoomX * (e === \"vertical\" ? 1 : v),\n          zoomY: this.zoomY * (e === \"horizontal\" ? 1 : v),\n          inputEvent: t,\n          isWheel: !0,\n          clientX: t.clientX,\n          clientY: t.clientY,\n          ratioX: 0,\n          ratioY: 0\n        });\n      } else if (r.useWheelScroll) {\n        let l = t.deltaX, h = t.deltaY;\n        t.shiftKey && !l && (l = h, h = 0), this.scrollBy(l / this.zoomX, h / this.zoomY);\n      } else\n        return;\n      t.preventDefault();\n    });\n    _(this, \"onGestureStart\", (t) => {\n      this._tempScale = [this.zoomX, this.zoomY], this._setClientRect(), t.preventDefault();\n    });\n    _(this, \"onGestureChange\", (t) => {\n      if (t.preventDefault(), this.gesto.isFlag() || !this._tempScale) {\n        this._tempScale = [1, 1];\n        return;\n      }\n      const r = t.scale, e = this._tempScale[0], o = this._tempScale[1], a = this.options.pinchDirection;\n      this._triggerPinch({\n        distance: 0,\n        scale: r,\n        rotation: t.rotation,\n        inputEvent: t,\n        isWheel: !0,\n        zoom: (e + o) * r / 2,\n        zoomX: e * (a === \"vertical\" ? 1 : r),\n        zoomY: o * (a === \"horizontal\" ? 1 : r),\n        clientX: t.clientX,\n        clientY: t.clientY,\n        ratioX: 0,\n        ratioY: 0\n      });\n    });\n    _(this, \"onGestureEnd\", () => {\n    });\n    this._containerElement = t, _e(r) ? (this._viewportElement = r, this.options = {\n      ...I,\n      ...e\n    }) : (this._viewportElement = t.children[0], this.options = {\n      ...I,\n      ...r\n    }), this.init();\n  }\n  static addProperties(t, r) {\n    t.forEach((e) => {\n      const o = {\n        enumerable: !0,\n        configurable: !0,\n        get() {\n          return this.options[e];\n        }\n      }, a = Ae(`set ${e}`);\n      r[a] ? o.set = function(l) {\n        this[a](l);\n      } : o.set = function(l) {\n        this.options[e] = l;\n      }, Object.defineProperty(r, e, o);\n    });\n  }\n  /**\n   * Get Container Element\n   */\n  getContainer() {\n    return this._containerElement;\n  }\n  /**\n   * Get Wheel Container Element\n   */\n  getWheelContainer() {\n    return this._wheelContainerElement;\n  }\n  /**\n   * Get Viewport Element\n   */\n  getViewport() {\n    return this._viewportElement;\n  }\n  /**\n   * Get Wrapper Element\n   */\n  getWrapper() {\n    return this.wrapperElement;\n  }\n  /**\n   * Get Scroll Area Element\n   */\n  geScrollArea() {\n    return this.scrollAreaElement;\n  }\n  /**\n   * Destroy elements, properties, and events.\n   */\n  destroy() {\n    this.off(), this.gesto.unset(), this.verticalScrollbar.destroy(), this.horizontalScrollbar.destroy(), this.injectResult.destroy();\n    const t = this._containerElement;\n    this._onDestroys.forEach((r) => {\n      r();\n    }), Y(this.wrapperElement, \"scroll\", this._onScroll), Y(this._wheelContainerElement, \"wheel\", this.onWheel), Y(t, \"gesturestart\", this.onGestureStart), Y(t, \"gesturechange\", this.onGestureChange), Y(t, \"gesturesend\", this.onGestureEnd), this.gesto = null, this.injectResult = null, this._containerElement = null, this._viewportElement = null, this.options = null;\n  }\n  /**\n   * Gets the number of pixels that an element's content is scrolled vertically.\n   */\n  getScrollTop(t = {}) {\n    let r = !1, e = !1;\n    st(t) ? (r = t.range, e = t.absolute) : r = t;\n    const o = this.zoomY, a = this.scrollTop / o + this.offsetY + (r ? U(this.getRangeY()[0]) : 0);\n    return e ? a * o : a;\n  }\n  /**\n   * Gets the number of pixels that an element's content is scrolled vertically.\n   */\n  getScrollLeft(t = {}) {\n    let r = !1, e = !1;\n    st(t) ? (r = t.range, e = t.absolute) : r = t;\n    const o = this.zoomX, a = this.scrollLeft / o + this.offsetX + (r ? U(this.getRangeX()[0]) : 0);\n    return e ? a * o : a;\n  }\n  /**\n   * Gets measurement of the width of an element's content with overflow\n   */\n  getScrollWidth(t) {\n    const r = this._getScrollRangeX(), e = this.zoomX, o = this.containerWidth / e + U(r[0]) + r[1];\n    return t ? o : o * e;\n  }\n  /**\n   * Gets measurement of the height of an element's content with overflow\n   */\n  getScrollHeight(t) {\n    const r = this._getScrollRangeY(), e = this.zoomY, o = this.containerHeight / e + U(r[0]) + r[1];\n    return t ? o : o * e;\n  }\n  /**\n   * Scroll the element to the center\n   */\n  scrollCenter(t = {}) {\n    this.resize();\n    const r = this.zoomX, e = this.zoomY;\n    let o = -(this.containerWidth / r - this.viewportWidth) / 2, a = -(this.containerHeight / e - this.viewportHeight) / 2;\n    return t.absolute && (o *= r, a *= e), t.horizontal === !1 && (o = this.getScrollLeft()), t.vertical === !1 && (a = this.getScrollTop()), this.scrollTo(o, a, t);\n  }\n  /**\n   * Move to that position or zoom.\n   * @since 0.25.0\n   */\n  setTo(t) {\n    const {\n      x: r = this.getScrollLeft(),\n      y: e = this.getScrollTop(),\n      zoom: o = [this.getZoomX(), this.getZoomY()],\n      duration: a\n    } = t, { zoomX: l, zoomY: h, zoomRange: u } = this;\n    let {\n      zoomOffsetX: d = I.zoomOffsetX,\n      zoomOffsetY: v = I.zoomOffsetY\n    } = this;\n    \"zoomOffsetX\" in t && (d = t.zoomOffsetX), \"zoomOffsetY\" in t && (v = t.zoomOffsetY);\n    const [c, m] = vt(o) ? o : [o, o], p = this.zoomRangeX || u, S = this.zoomRangeY || u, T = tt(c, p[0], p[1]), z = tt(m, S[0], S[1]), b = G(`${d}`, this.viewportWidth) * (1 / l - 1 / T), W = G(`${v}`, this.viewportHeight) * (1 / h - 1 / z);\n    this.scrollTo(r - b, e - W, {\n      duration: a\n    }), this.setZoom(o, {\n      zoomOffsetX: d,\n      zoomOffsetY: v,\n      duration: a,\n      zoomBase: \"fixed\"\n    });\n  }\n  /**\n   * Move by the position or zoom delta value.\n   * @since 0.25.0\n   */\n  setBy(t) {\n    const { x: r = 0, y: e = 0, zoom: o = [0, 0] } = t, [a, l] = vt(o) ? o : [o, o];\n    this.setTo({\n      ...t,\n      x: this.getScrollLeft() + r,\n      y: this.getScrollTop() + e,\n      zoom: [this.zoomX + a, this.zoomY + l]\n    });\n  }\n  /**\n   * Scrolls the container by the given amount.\n   */\n  scrollBy(t, r, e) {\n    if (this._pauseScrollAnimation(), !e || !e.duration) {\n      let o = this.getScrollLeft(), a = this.getScrollTop();\n      return e != null && e.absolute && (o *= this.zoomX, a *= this.zoomY), this._scrollTo(o + t, a + r, e);\n    } else\n      return this._startScrollAnimation([t, r], e), !0;\n  }\n  /**\n   * Scrolls the container to set of coordinates.\n   * @param scrollLeft\n   * @param scrollTop\n   */\n  scrollTo(t, r, e) {\n    if (this._pauseScrollAnimation(), !e || !e.duration)\n      return this._scrollTo(t, r, e);\n    {\n      let o = this.getScrollLeft(), a = this.getScrollTop();\n      return e != null && e.absolute && (o *= this.zoomX, a *= this.zoomY), this.scrollBy(t - o, r - a, e);\n    }\n  }\n  /**\n   * Set viewer zoom by the given amount\n   */\n  zoomBy(t, r) {\n    this._pauseZoomAnimation();\n    const [e, o] = vt(t) ? t : [t, t];\n    !r || !r.duration ? this._setZoom([this.zoomX + e, this.zoomY + o], r) : this._startZoomAnimation([e, o], r);\n  }\n  /**\n   * Set viewer zoom\n   */\n  setZoom(t, r) {\n    if (this._pauseZoomAnimation(), !r || !r.duration)\n      this._setZoom(t, r);\n    else {\n      const [e, o] = vt(t) ? t : [t, t];\n      this._startZoomAnimation(\n        [e - this.zoomX, o - this.zoomY],\n        r\n      );\n    }\n  }\n  getViewportWidth() {\n    return this.viewportWidth;\n  }\n  getViewportHeight() {\n    return this.viewportWidth;\n  }\n  getViewportScrollWidth() {\n    return this.viewportScrollWidth;\n  }\n  getViewportScrollHeight() {\n    return this.viewportScrollHeight;\n  }\n  getContainerWidth() {\n    return this.containerWidth;\n  }\n  getContainerHeight() {\n    return this.containerHeight;\n  }\n  /**\n   * Get viewer zoom\n   */\n  getZoom() {\n    return (this.zoomX + this.zoomY) / 2;\n  }\n  /**\n   * Get viewer zoomX\n   * @since 0.20.0\n   */\n  getZoomX() {\n    return this.zoomX;\n  }\n  /**\n   * Get viewer zoom\n   * @since 0.20.0\n   */\n  getZoomY() {\n    return this.zoomY;\n  }\n  /**\n   * get x ranges\n   */\n  getRangeX(t, r) {\n    return this._getRangeCoord(\"horizontal\", t, r);\n  }\n  /**\n   * get y ranges\n   */\n  getRangeY(t, r) {\n    return this._getRangeCoord(\"vertical\", t, r);\n  }\n  init() {\n    const t = this._containerElement, r = this.options, e = Nt(t), o = ot(t);\n    let a = r.wrapperElement || t.querySelector(`.${we}`), l = r.scrollAreaElement || t.querySelector(`.${be}`);\n    const h = r.horizontalScrollElement || t.querySelector(`.${Ne}`), u = r.verticalScrollElement || t.querySelector(`.${Ze}`);\n    a || (a = e.createElement(\"div\"), a.insertBefore(this._viewportElement, null), t.insertBefore(a, null)), this.wrapperElement = a, l || (l = e.createElement(\"div\"), a.insertBefore(l, a.firstChild)), this.scrollAreaElement = l, it(t, qe), it(a, we), it(l, be);\n    const d = new De(\n      t,\n      \"horizontal\",\n      h\n    ), v = new De(\n      t,\n      \"vertical\",\n      u\n    );\n    this.horizontalScrollbar = d, this.verticalScrollbar = v, d.on(\"scroll\", (p) => {\n      this.scrollBy(p.delta / this.zoomX, 0);\n    }), v.on(\"scroll\", (p) => {\n      this.scrollBy(0, p.delta / this.zoomY);\n    }), d.isAppend && t.insertBefore(d.barElement, null), v.isAppend && t.insertBefore(v.barElement, null), this.injectResult = Ue.inject(t, {\n      nonce: this.options.cspNonce\n    });\n    const c = r.wheelContainer;\n    let m = null;\n    if (c && (Oe(c) ? m = e.querySelector(c) : _e(c) ? m = c : (\"value\" in c || \"current\" in c) && (m = c.current || c.value)), m || (m = t), this._wheelContainerElement = m, this.gesto = new We(t, {\n      container: ot(t),\n      events: [\"touch\", \"mouse\"],\n      preventWheelClick: this.options.preventWheelClick ?? !0\n    }).on(\"dragStart\", (p) => {\n      const { inputEvent: S, stop: T, datas: z } = p;\n      if (!this.useMouseDrag && p.isMouseEvent) {\n        T();\n        return;\n      }\n      if (this._pauseScrollAnimation(), this.dragFlag = !1, this.trigger(\"dragStart\", p) === !1) {\n        T();\n        return;\n      }\n      S.preventDefault(), z.startEvent = S;\n    }).on(\"drag\", (p) => {\n      !this.options.usePinch || p.isPinch || this.useMouseDrag && p.isMouseEvent ? (this.trigger(\"drag\", {\n        ...p,\n        inputEvent: p.inputEvent\n      }), pn(p), this.scrollBy(-p.deltaX / this.zoomX, -p.deltaY / this.zoomY)) : !this.dragFlag && p.movement > r.pinchThreshold && (this.dragFlag = !0, this.trigger(\"abortPinch\", {\n        inputEvent: p.datas.startEvent || p.inputEvent\n      }));\n    }).on(\"dragEnd\", (p) => {\n      this.trigger(\"dragEnd\", {\n        isDrag: p.isDrag,\n        isDouble: p.isDouble,\n        inputEvent: p.inputEvent\n      }), this._startScrollAnimationBySpeed(p.datas.speed);\n    }).on(\"pinchStart\", ({ inputEvent: p, datas: S, stop: T }) => {\n      p.preventDefault(), this._pauseScrollAnimation(), S.startZoom = [this.zoomX, this.zoomY], this.trigger(\"pinchStart\", {\n        inputEvent: p\n      }) === !1 && T(), this._setClientRect();\n    }).on(\"pinch\", (p) => {\n      const S = p.scale, T = this.options.pinchDirection;\n      this._triggerPinch({\n        rotation: p.rotation,\n        distance: p.distance,\n        scale: p.scale,\n        inputEvent: p.inputEvent,\n        isWheel: !1,\n        zoom: p.datas.startZoom * S,\n        zoomX: this.zoomX * (T === \"vertical\" ? 1 : S),\n        zoomY: this.zoomY * (T === \"horizontal\" ? 1 : S),\n        clientX: p.clientX,\n        clientY: p.clientY,\n        ratioX: 0,\n        ratioY: 0\n      });\n    }).on(\"pinchEnd\", () => {\n      this._tempRect = null;\n    }), O(a, \"scroll\", this._onScroll), r.useResizeObserver) {\n      const p = new o.ResizeObserver(() => {\n        this.resize();\n      });\n      p.observe(this._viewportElement), p.observe(this._containerElement), this._onDestroys.push(() => {\n        p.disconnect();\n      });\n    } else\n      O(o, \"resize\", this.resize), this._onDestroys.push(() => {\n        Y(o, \"resize\", this.resize);\n      });\n    (r.useWheelPinch || r.useWheelScroll) && O(m, \"wheel\", this.onWheel, {\n      passive: !1\n    }), r.useGesture && (O(t, \"gesturestart\", this.onGestureStart, {\n      passive: !1\n    }), O(t, \"gesturechange\", this.onGestureChange, {\n      passive: !1\n    })), this.resize();\n  }\n  render() {\n    const {\n      offsetX: t,\n      offsetY: r,\n      zoomX: e = I.zoomX,\n      zoomY: o = I.zoomY,\n      translateZ: a = 0,\n      rangeX: l,\n      rangeY: h,\n      containerWidth: u,\n      containerHeight: d\n    } = this, { useTransform: v = I.useTransform } = this.options;\n    let c = -t * e, m = -r * o;\n    this.scrollAreaElement.style.cssText = `width:calc(100% + ${this.getScrollAreaWidth()}px);height:calc(100% + ${this.getScrollAreaHeight()}px);`;\n    const p = this._viewportElement.style;\n    v === !1 ? p.cssText += `position: relative; left: ${c}px; top: ${m}px; ` : p.cssText += `transform-origin: 0 0;transform:translate3d(${c}px, ${m}px, ${a}px) scale(${e}, ${o});`, this.renderScroll();\n  }\n  renderScroll() {\n    const { zoomX: t, zoomY: r, containerWidth: e, containerHeight: o } = this, a = this.horizontalScrollbar, l = this.verticalScrollbar;\n    if (this.options.useBounceScrollBar) {\n      const h = this.getScrollLeft(!0) * t, u = this.getRangeX(!0), d = e + U(u[0]) + U(u[1]), v = this.getScrollTop(!0) * r, c = this.getRangeY(!0), m = o + U(c[0]) + U(c[1]);\n      a.render(\n        this.displayHorizontalScroll,\n        h,\n        e,\n        d\n      ), l.render(\n        this.displayVerticalScroll,\n        v,\n        o,\n        m\n      );\n    } else {\n      const h = this._getScrollRangeX(), u = this._getScrollRangeY(), d = this.getScrollLeft(), v = this.getScrollTop(), c = this.containerWidth + U(h[0]) + h[1], m = this.containerHeight + U(u[0]) + u[1];\n      a.render(\n        this.displayHorizontalScroll,\n        d - h[0],\n        e,\n        c\n      ), l.render(\n        this.displayVerticalScroll,\n        v - u[0],\n        o,\n        m\n      );\n    }\n  }\n  move(t, r) {\n    const e = this.wrapperElement;\n    e.scrollLeft = t, e.scrollTop = r;\n  }\n  setDisplayVerticalScroll(t) {\n    this.options.displayVerticalScroll = t, this.renderScroll();\n  }\n  setDisplayHorizontalScroll(t) {\n    this.options.displayHorizontalScroll = t, this.renderScroll();\n  }\n  _startZoomAnimation(t, r) {\n    if (!t)\n      return;\n    const e = r.duration, o = r.easing || Ce;\n    Re(\n      (a) => this._setZoom(\n        [this.zoomX + t[0] * a, this.zoomY + t[1] * a],\n        r\n      ),\n      (a) => {\n        this._zoomTimer = requestAnimationFrame(a);\n      },\n      {\n        easing: o,\n        duration: e\n      }\n    );\n  }\n  _startScrollAnimation(t, r) {\n    if (!t[0] && !t[1])\n      return;\n    const e = r.duration, o = r.easing || Ce;\n    Re(\n      (a) => this._scrollBy(t[0] * a, t[1] * a, r),\n      (a) => {\n        this._scrollTimer = requestAnimationFrame(a);\n      },\n      {\n        easing: o,\n        duration: e\n      }\n    );\n  }\n  _startScrollAnimationBySpeed(t) {\n    if (!t || !t[0] && !t[1])\n      return;\n    const r = -6e-4, e = Ke(t, r), o = gn(t, r);\n    return this._startScrollAnimation(o, {\n      duration: e\n    });\n  }\n  _pauseScrollAnimation() {\n    cancelAnimationFrame(this._scrollTimer), this._scrollTimer = 0;\n  }\n  _pauseZoomAnimation() {\n    cancelAnimationFrame(this._zoomTimer), this._zoomTimer = 0;\n  }\n  getScrollAreaWidth() {\n    const [t, r] = this.getRangeX(!0);\n    return t || r ? this.margin * 2 : 0;\n  }\n  getScrollAreaHeight() {\n    const [t, r] = this.getRangeY(!0);\n    return t || r ? this.margin * 2 : 0;\n  }\n  _triggerPinch(t) {\n    const { clientX: r, clientY: e, zoomX: o, zoomY: a } = t;\n    this.useAutoZoom && this._zoomByClient([o, a], r, e), this._tempRect || this._setClientRect();\n    const l = this.zoomRange, h = this.zoomRangeX || l, u = this.zoomRangeY || l, { left: d, top: v, width: c, height: m } = this._tempRect, p = (r - d) / c * 100, S = (e - v) / m * 100;\n    this.trigger(\"pinch\", {\n      ...t,\n      zoom: tt((o + a) / 2, l[0], l[1]),\n      zoomX: tt(o, h[0], h[1]),\n      zoomY: tt(a, u[0], u[1]),\n      ratioX: p,\n      ratioY: S\n    });\n  }\n  _setClientRect() {\n    const t = this.getContainer().getBoundingClientRect();\n    this._tempRect = {\n      left: t.left,\n      top: t.top,\n      width: t.width,\n      height: t.height\n    };\n  }\n  _zoomByClient(t, r, e) {\n    this._tempRect || this._setClientRect();\n    const { left: o, top: a, width: l, height: h } = this._tempRect, u = this.options, d = u.zoomOffsetX, v = u.zoomOffsetY;\n    u.zoomOffsetX = `${(r - o) / l * 100}%`, u.zoomOffsetY = `${(e - a) / h * 100}%`, this._setZoom(t, {\n      zoomBase: \"screen\"\n    }), u.zoomOffsetX = d, u.zoomOffsetY = v;\n  }\n  _setZoom(t, r = {}) {\n    const e = r.zoomBase, {\n      containerWidth: o,\n      containerHeight: a,\n      zoomX: l,\n      zoomY: h,\n      zoomRange: u\n    } = this;\n    let {\n      zoomOffsetX: d = I.zoomOffsetX,\n      zoomOffsetY: v = I.zoomOffsetY\n    } = this;\n    \"zoomOffsetX\" in r && (d = r.zoomOffsetX), \"zoomOffsetY\" in r && (v = r.zoomOffsetY);\n    const c = this.getScrollLeft(), m = this.getScrollTop(), [p, S] = vt(t) ? t : [t, t], T = this.zoomRangeX || u, z = this.zoomRangeY || u, b = tt(p, T[0], T[1]), W = tt(S, z[0], z[1]), k = this.options;\n    k.zoomX = b, k.zoomY = W, k.zoom = (b + W) / 2;\n    const H = this.getScrollLeft(), V = this.getScrollTop();\n    let C = 0, P = 0;\n    e === \"fixed\" ? (C = G(`${d}`, this.viewportWidth), P = G(`${v}`, this.viewportHeight)) : e === \"viewport\" ? (C = (-c + G(`${d}`, this.viewportWidth)) * l, P = (-m + G(`${v}`, this.viewportHeight)) * h) : (C = G(`${d}`, o), P = G(`${v}`, a));\n    const L = c + C / l, q = m + P / h, Z = H + C / b, F = V + P / W;\n    this._scrollBy(L - Z, q - F, {\n      zoom: !!(b - l || W - h)\n    }), this.render();\n  }\n  _scrollBy(t, r, e) {\n    let o = this.getScrollLeft(), a = this.getScrollTop();\n    return e != null && e.absolute && (o *= this.zoomX, a *= this.zoomY), this._scrollTo(o + t, a + r, e);\n  }\n  _scrollTo(t, r, e) {\n    const { scrollLeft: o, scrollTop: a } = this, l = e == null ? void 0 : e.absolute;\n    this._scrollToType(\"horizontal\", t, l), this._scrollToType(\"vertical\", r, l);\n    const h = this.scrollLeft, u = this.scrollTop;\n    this.render();\n    const d = this.getScrollLeft(), v = this.getScrollTop();\n    return this._emitScrollEvent(\n      d,\n      v,\n      e == null ? void 0 : e.zoom\n    ), Math.round(o) !== h || Math.round(a) !== u ? (this.isLoop = !0, this.move(h, u), requestAnimationFrame(() => {\n      if (!this.isLoop)\n        return;\n      this.isLoop = !1;\n      const { scrollLeft: c, scrollTop: m } = this.wrapperElement;\n      this.scrollLeft = c, this.scrollTop = m, (h !== Math.round(c) || u !== Math.round(m)) && this._scrollTo(d, v);\n    }), !1) : !0;\n  }\n  _scrollToType(t, r, e) {\n    const o = Te[t], {\n      margin: a = I.margin,\n      threshold: l = I.threshold\n    } = this, h = this[`scroll${o.pos}`], [u, d] = this[`getRange${o.coord}`](!0, !0);\n    let v = Math.round(h);\n    const c = this[`getScrollArea${o.size}`](), m = this[`zoom${o.coord}`];\n    e && (r = r / m);\n    const p = r * m;\n    if (u === d)\n      v = u, r = u / m;\n    else if (p - l <= u) {\n      const S = Math.max(0, p - u);\n      v = S, r = (u + S) / m;\n    } else if (p + l >= d) {\n      const S = Math.max(0, d - p);\n      v = c - S, r = (d - S) / m;\n    } else v < l ? v += a : v > c - l && (v -= a);\n    v = Math.round(v), this[`scroll${o.pos}`] = v, this[`offset${o.coord}`] = r - v / m;\n  }\n  _getRangeCoord(t, r, e) {\n    const { margin: o = I.margin, threshold: a } = this, l = Te[t], h = ze(\n      this[`range${l.coord}`],\n      I[`range${l.coord}`]\n    ), u = ze(\n      this[`rangeOffset${l.coord}`],\n      I[`rangeOffset${l.coord}`]\n    ), d = this[`zoom${l.coord}`], v = mn(\n      this[`getScroll${l.pos}`](),\n      o,\n      h,\n      a,\n      e\n    );\n    return r ? [\n      v[0] * d + u[0],\n      this.options.useOverflowScroll ? Math.max(\n        this[`viewport${l.size}`] * d - this[`container${l.size}`],\n        v[1] * d + u[1]\n      ) : v[1] * d + u[1]\n    ] : [v[0] + u[0], v[1] + u[1]];\n  }\n  _emitScrollEvent(t, r, e) {\n    const o = this._asLeft, a = this._asTop;\n    !e && o === t && a === r || (this._asLeft = t, this._asTop = r, this.trigger(\"scroll\", {\n      scrollLeft: t,\n      scrollTop: r,\n      zoomX: this.zoomX,\n      zoomY: this.zoomY\n    }));\n  }\n  _getScrollRangeX() {\n    const t = this.getScrollLeft(), r = this.rangeX, e = r[0];\n    let o = r[1];\n    this.useOverflowScroll && isFinite(o) && (o = Math.max(\n      o,\n      this.viewportWidth - this.containerWidth / this.zoomX\n    ));\n    const a = Math.min(\n      0,\n      isFinite(e) ? Math.min(e, t) : t\n    ), l = Math.max(\n      0,\n      isFinite(o) ? Math.max(o, t) : t\n    ), h = this.viewportScrollWidth, u = Math.max(this.containerWidth / this.zoomX, h) - h;\n    return [Math.min(0, u + a), l];\n  }\n  _getScrollRangeY() {\n    const t = this.getScrollTop(), r = this.rangeY, e = r[0];\n    let o = r[1];\n    this.useOverflowScroll && isFinite(o) && (o = Math.max(\n      o,\n      this.viewportHeight - this.containerHeight / this.zoomY\n    ));\n    const a = Math.min(\n      0,\n      isFinite(e) ? Math.min(e, t) : t\n    ), l = Math.max(\n      0,\n      isFinite(o) ? Math.max(o, t) : t\n    ), h = this.viewportScrollHeight, u = Math.max(this.containerHeight / this.zoomY, h) - h;\n    return [Math.min(0, u + a), l];\n  }\n};\nHt.addProperties(Gt, Ht.prototype);\nlet _n = class extends Ht {\n};\nconst Ye = Ge.map((i) => Ae(`on ${i}`));\nclass Cn extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _(this, \"infiniteViewer\");\n    _(this, \"containerElement\");\n    _(this, \"wrapperElement\");\n    _(this, \"scrollAreaElement\");\n    _(this, \"horizontalScrollElement\");\n    _(this, \"verticalScrollElement\");\n  }\n  render() {\n    const t = this.props.className;\n    return /* @__PURE__ */ Q.jsxs(\n      \"div\",\n      {\n        className: `${t || \"\"} ${qe}`,\n        ref: dt(this, \"containerElement\"),\n        children: [\n          /* @__PURE__ */ Q.jsxs(\n            \"div\",\n            {\n              className: \"infinite-viewer-wrapper\",\n              ref: dt(this, \"wrapperElement\"),\n              children: [\n                /* @__PURE__ */ Q.jsx(\n                  \"div\",\n                  {\n                    className: \"infinite-viewer-scroll-area\",\n                    ref: dt(this, \"scrollAreaElement\")\n                  }\n                ),\n                this.props.children\n              ]\n            }\n          ),\n          /* @__PURE__ */ Q.jsx(\n            \"div\",\n            {\n              className: \"infinite-viewer-scroll-bar infinite-viewer-horizontal-scroll-bar\",\n              ref: dt(this, \"horizontalScrollElement\"),\n              children: /* @__PURE__ */ Q.jsx(\"div\", { className: \"infinite-viewer-scroll-thumb\" })\n            }\n          ),\n          /* @__PURE__ */ Q.jsx(\n            \"div\",\n            {\n              className: \"infinite-viewer-scroll-bar infinite-viewer-vertical-scroll-bar\",\n              ref: dt(this, \"verticalScrollElement\"),\n              children: /* @__PURE__ */ Q.jsx(\"div\", { className: \"infinite-viewer-scroll-thumb\" })\n            }\n          )\n        ]\n      }\n    );\n  }\n  componentDidMount() {\n    const t = this.props, r = {};\n    vn.forEach((e) => {\n      e in t && typeof t[e] < \"u\" && (r[e] = t[e]);\n    }), this.infiniteViewer = new _n(\n      this.containerElement,\n      this.scrollAreaElement.nextElementSibling,\n      {\n        ...r,\n        wrapperElement: this.wrapperElement,\n        scrollAreaElement: this.scrollAreaElement,\n        horizontalScrollElement: this.horizontalScrollElement,\n        verticalScrollElement: this.verticalScrollElement\n      }\n    ), Ge.forEach((e, o) => {\n      this.infiniteViewer.on(e, (a) => {\n        const l = this.props;\n        (l[Ye[o]] && l[Ye[o]](a)) === !1 && a.stop();\n      });\n    });\n  }\n  componentDidUpdate() {\n    const t = this.props, r = this.infiniteViewer;\n    Gt.forEach((e) => {\n      e in t && r[e] !== t[e] && (r[e] = t[e]);\n    });\n  }\n  componentWillUnmount() {\n    this.infiniteViewer.destroy();\n  }\n  getElement() {\n    return this.containerElement;\n  }\n}\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGludGVyYWN0aWZ5L2luZmluaXRlLXZpZXdlci9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDNEI7QUFDTDtBQUN2QixXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFFLDRMQUE0TDtBQUN4TTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdELFlBQVksa0NBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQ0FBbUM7QUFDM0U7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5Qiw2Q0FBNkMsTUFBTSxhQUFhO0FBQ3BHO0FBQ0Esc0NBQXNDLCtCQUErQixPQUFPO0FBQzVFO0FBQ0E7QUFDQSxPQUFPLFVBQVU7QUFDakI7QUFDQTtBQUNBLFdBQVcsVUFBVSxVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsTUFBcUMsR0FBRyxDQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RCx1Q0FBdUMsT0FBTyxxREFBcUQsT0FBTztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUcsWUFBWSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RCx1Q0FBdUMsT0FBTyxxREFBcUQsT0FBTztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0NBQW9DLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4R0FBOEcsT0FBTztBQUNySDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxrQkFBa0IsNENBQTRDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnS0FBZ0s7QUFDaEssdUVBQXVFLDBKQUEwSix3Q0FBd0M7QUFDelE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxRQUFRLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0lBQStJLGtMQUFrTDtBQUNqVTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbURBQW1ELDJUQUEyVDtBQUM5VztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCw2REFBNkQsbUNBQW1DLDBCQUEwQix1R0FBdUc7QUFDak8sR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0dBQXdHLHNCQUFzQjtBQUMxSztBQUNBLE9BQU87QUFDUDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrREFBa0Qsa01BQWtNLHVCQUF1QiwyQ0FBMkM7QUFDdFQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEVBQTBFLHNCQUFzQixlQUFlO0FBQ2pKO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxtQ0FBbUMsUUFBUSxrT0FBa087QUFDN1QsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsUUFBUSxvQkFBb0I7QUFDN0MsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsbUNBQW1DLEdBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEdBQUcsTUFBTSxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxrQkFBa0I7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCxxREFBcUQ7QUFDckQ7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJLGtCQUFrQixpQkFBaUIsaUJBQWlCLEVBQUUsTUFBTTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsR0FBRyxrQkFBa0IsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUIsR0FBRyxnQ0FBZ0MsR0FBRyw4QkFBOEIsR0FBRztBQUNsTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsR0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEVBQUUsSUFBSSxFQUFFLEVBQUUsV0FBVyxHQUFHLHNCQUFzQixFQUFFLEdBQUcsWUFBWTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLDhCQUE4Qix5QkFBeUIsbUJBQW1CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkZBQTJGLG1CQUFtQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdCQUFnQixFQUFFO0FBQ3pCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTyxtQ0FBbUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0pBQWtKLEVBQUUsbURBQW1ELEVBQUU7QUFDek07QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxHQUFHLG1EQUFtRCxHQUFHO0FBQzdHLCtEQUErRCxHQUFHLHVEQUF1RCxHQUFHO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxtQ0FBbUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSyxzQkFBc0Isa0NBQWtDO0FBQzdEO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sVUFBVSxtQ0FBbUM7QUFDbkQ7QUFDQSxnRUFBZ0UsMEJBQTBCLElBQUkscUJBQXFCLDJCQUEyQixJQUFJO0FBQ2xKO0FBQ0EsaURBQWlELFFBQVEsRUFBRSxJQUFJLE9BQU8sRUFBRSxJQUFJLHdDQUF3Qyx3QkFBd0IsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsRUFBRTtBQUNwTDtBQUNBO0FBQ0EsWUFBWSw0REFBNEQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0Esb0ZBQW9GLHVDQUF1QztBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRCx1QkFBdUIsa0JBQWtCLHVCQUF1QixrQkFBa0I7QUFDbEY7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUUsaUNBQWlDLEVBQUUsOERBQThELEVBQUUsNENBQTRDLEVBQUUsMENBQTBDLEVBQUUsZ0JBQWdCLEVBQUU7QUFDL087QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBCQUEwQixNQUFNLDZCQUE2QixRQUFRO0FBQzNFO0FBQ0EsbUNBQW1DLE9BQU8sc0JBQXNCLFFBQVE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTixxQ0FBcUMsTUFBTSxzQkFBc0IsUUFBUTtBQUN6RTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsbUJBQW1CLFFBQVE7QUFDM0IsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQyxzQkFBc0IsUUFBUTtBQUM5Qix1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sMEJBQTBCLE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFO0FBQ3BDLGlCQUFpQixnREFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTLEVBQUUsR0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkNBQTJDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJDQUEyQztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlbW90aW9uLWNhcHRpb25zLy4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGlmeS9pbmZpbml0ZS12aWV3ZXIvZGlzdC9pbmRleC5lcy5qcz84NDNjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBUciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciB6ciA9IChpLCBuLCB0KSA9PiBuIGluIGkgPyBUcihpLCBuLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtuXSA9IHQ7XG52YXIgXyA9IChpLCBuLCB0KSA9PiB6cihpLCB0eXBlb2YgbiAhPSBcInN5bWJvbFwiID8gbiArIFwiXCIgOiBuLCB0KTtcbmltcG9ydCAqIGFzIFJyIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHhlIGZyb20gXCJyZWFjdFwiO1xudmFyIEx0ID0geyBleHBvcnRzOiB7fSB9LCBodCA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIHBlO1xuZnVuY3Rpb24gRHIoKSB7XG4gIGlmIChwZSkgcmV0dXJuIGh0O1xuICBwZSA9IDE7XG4gIHZhciBpID0geGUsIG4gPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGUgPSBpLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCBvID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24gYShsLCBoLCB1KSB7XG4gICAgdmFyIGQsIHYgPSB7fSwgYyA9IG51bGwsIG0gPSBudWxsO1xuICAgIHUgIT09IHZvaWQgMCAmJiAoYyA9IFwiXCIgKyB1KSwgaC5rZXkgIT09IHZvaWQgMCAmJiAoYyA9IFwiXCIgKyBoLmtleSksIGgucmVmICE9PSB2b2lkIDAgJiYgKG0gPSBoLnJlZik7XG4gICAgZm9yIChkIGluIGgpIHIuY2FsbChoLCBkKSAmJiAhby5oYXNPd25Qcm9wZXJ0eShkKSAmJiAodltkXSA9IGhbZF0pO1xuICAgIGlmIChsICYmIGwuZGVmYXVsdFByb3BzKSBmb3IgKGQgaW4gaCA9IGwuZGVmYXVsdFByb3BzLCBoKSB2W2RdID09PSB2b2lkIDAgJiYgKHZbZF0gPSBoW2RdKTtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogbiwgdHlwZTogbCwga2V5OiBjLCByZWY6IG0sIHByb3BzOiB2LCBfb3duZXI6IGUuY3VycmVudCB9O1xuICB9XG4gIHJldHVybiBodC5GcmFnbWVudCA9IHQsIGh0LmpzeCA9IGEsIGh0LmpzeHMgPSBhLCBodDtcbn1cbnZhciBmdCA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGdlO1xuZnVuY3Rpb24gWXIoKSB7XG4gIHJldHVybiBnZSB8fCAoZ2UgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSB4ZSwgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCB0ID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgbyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgYSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgbCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBoID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCB1ID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBkID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIHYgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgYyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCBtID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgcCA9IFN5bWJvbC5pdGVyYXRvciwgUyA9IFwiQEBpdGVyYXRvclwiO1xuICAgIGZ1bmN0aW9uIFQocykge1xuICAgICAgaWYgKHMgPT09IG51bGwgfHwgdHlwZW9mIHMgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZiA9IHAgJiYgc1twXSB8fCBzW1NdO1xuICAgICAgcmV0dXJuIHR5cGVvZiBmID09IFwiZnVuY3Rpb25cIiA/IGYgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgeiA9IGkuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gICAgZnVuY3Rpb24gYihzKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIGYgPSBhcmd1bWVudHMubGVuZ3RoLCBnID0gbmV3IEFycmF5KGYgPiAxID8gZiAtIDEgOiAwKSwgRSA9IDE7IEUgPCBmOyBFKyspXG4gICAgICAgICAgZ1tFIC0gMV0gPSBhcmd1bWVudHNbRV07XG4gICAgICAgIFcoXCJlcnJvclwiLCBzLCBnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gVyhzLCBmLCBnKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBFID0gei5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCBSID0gRS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIFIgIT09IFwiXCIgJiYgKGYgKz0gXCIlc1wiLCBnID0gZy5jb25jYXQoW1JdKSk7XG4gICAgICAgIHZhciBEID0gZy5tYXAoZnVuY3Rpb24oeSkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcoeSk7XG4gICAgICAgIH0pO1xuICAgICAgICBELnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIGYpLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW3NdLCBjb25zb2xlLCBEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGsgPSAhMSwgSCA9ICExLCBWID0gITEsIEMgPSAhMSwgUCA9ICExLCBMO1xuICAgIEwgPSBTeW1ib2wuZm9yKFwicmVhY3QubW9kdWxlLnJlZmVyZW5jZVwiKTtcbiAgICBmdW5jdGlvbiBxKHMpIHtcbiAgICAgIHJldHVybiAhISh0eXBlb2YgcyA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBzID09IFwiZnVuY3Rpb25cIiB8fCBzID09PSByIHx8IHMgPT09IG8gfHwgUCB8fCBzID09PSBlIHx8IHMgPT09IHUgfHwgcyA9PT0gZCB8fCBDIHx8IHMgPT09IG0gfHwgayB8fCBIIHx8IFYgfHwgdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiBzICE9PSBudWxsICYmIChzLiQkdHlwZW9mID09PSBjIHx8IHMuJCR0eXBlb2YgPT09IHYgfHwgcy4kJHR5cGVvZiA9PT0gYSB8fCBzLiQkdHlwZW9mID09PSBsIHx8IHMuJCR0eXBlb2YgPT09IGggfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgICAvLyB3aXRoLlxuICAgICAgcy4kJHR5cGVvZiA9PT0gTCB8fCBzLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gWihzLCBmLCBnKSB7XG4gICAgICB2YXIgRSA9IHMuZGlzcGxheU5hbWU7XG4gICAgICBpZiAoRSlcbiAgICAgICAgcmV0dXJuIEU7XG4gICAgICB2YXIgUiA9IGYuZGlzcGxheU5hbWUgfHwgZi5uYW1lIHx8IFwiXCI7XG4gICAgICByZXR1cm4gUiAhPT0gXCJcIiA/IGcgKyBcIihcIiArIFIgKyBcIilcIiA6IGc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEYocykge1xuICAgICAgcmV0dXJuIHMuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHgocykge1xuICAgICAgaWYgKHMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIHMudGFnID09IFwibnVtYmVyXCIgJiYgYihcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpLCB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBzLmRpc3BsYXlOYW1lIHx8IHMubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBzID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBzO1xuICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgcjpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIHQ6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgbzpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIGU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBkOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAocy4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgIHZhciBmID0gcztcbiAgICAgICAgICAgIHJldHVybiBGKGYpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIGE6XG4gICAgICAgICAgICB2YXIgZyA9IHM7XG4gICAgICAgICAgICByZXR1cm4gRihnLl9jb250ZXh0KSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBoOlxuICAgICAgICAgICAgcmV0dXJuIFoocywgcy5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICBjYXNlIHY6XG4gICAgICAgICAgICB2YXIgRSA9IHMuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBFICE9PSBudWxsID8gRSA6IHgocy50eXBlKSB8fCBcIk1lbW9cIjtcbiAgICAgICAgICBjYXNlIGM6IHtcbiAgICAgICAgICAgIHZhciBSID0gcywgRCA9IFIuX3BheWxvYWQsIHkgPSBSLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHgoeShEKSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEIgPSBPYmplY3QuYXNzaWduLCBLID0gMCwgYXQsIG10LCBfdCwgbHQsIEt0LCBKdCwgUXQ7XG4gICAgZnVuY3Rpb24gdGUoKSB7XG4gICAgfVxuICAgIHRlLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIGZ1bmN0aW9uIEplKCkge1xuICAgICAge1xuICAgICAgICBpZiAoSyA9PT0gMCkge1xuICAgICAgICAgIGF0ID0gY29uc29sZS5sb2csIG10ID0gY29uc29sZS5pbmZvLCBfdCA9IGNvbnNvbGUud2FybiwgbHQgPSBjb25zb2xlLmVycm9yLCBLdCA9IGNvbnNvbGUuZ3JvdXAsIEp0ID0gY29uc29sZS5ncm91cENvbGxhcHNlZCwgUXQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICAgIHZhciBzID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IHRlLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBpbmZvOiBzLFxuICAgICAgICAgICAgbG9nOiBzLFxuICAgICAgICAgICAgd2FybjogcyxcbiAgICAgICAgICAgIGVycm9yOiBzLFxuICAgICAgICAgICAgZ3JvdXA6IHMsXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogcyxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgSysrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBRZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEstLSwgSyA9PT0gMCkge1xuICAgICAgICAgIHZhciBzID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBsb2c6IEIoe30sIHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGF0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZm86IEIoe30sIHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG10XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm46IEIoe30sIHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IF90XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVycm9yOiBCKHt9LCBzLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBsdFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogQih7fSwgcywge1xuICAgICAgICAgICAgICB2YWx1ZTogS3RcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IEIoe30sIHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IEp0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBCKHt9LCBzLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBRdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBLIDwgMCAmJiBiKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHp0ID0gei5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBSdDtcbiAgICBmdW5jdGlvbiBTdChzLCBmLCBnKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChSdCA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKFIpIHtcbiAgICAgICAgICAgIHZhciBFID0gUi5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgIFJ0ID0gRSAmJiBFWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIFJ0ICsgcztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIER0ID0gITEsIEV0O1xuICAgIHtcbiAgICAgIHZhciB0ciA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBFdCA9IG5ldyB0cigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlZShzLCBmKSB7XG4gICAgICBpZiAoIXMgfHwgRHQpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgZyA9IEV0LmdldChzKTtcbiAgICAgICAgaWYgKGcgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gZztcbiAgICAgIH1cbiAgICAgIHZhciBFO1xuICAgICAgRHQgPSAhMDtcbiAgICAgIHZhciBSID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBEO1xuICAgICAgRCA9IHp0LmN1cnJlbnQsIHp0LmN1cnJlbnQgPSBudWxsLCBKZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICB2YXIgeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoeS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoeSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoJCkge1xuICAgICAgICAgICAgICBFID0gJDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KHMsIFtdLCB5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgeS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICgkKSB7XG4gICAgICAgICAgICAgIEUgPSAkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcy5jYWxsKHkucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoJCkge1xuICAgICAgICAgICAgRSA9ICQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoJCkge1xuICAgICAgICBpZiAoJCAmJiBFICYmIHR5cGVvZiAkLnN0YWNrID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciB3ID0gJC5zdGFjay5zcGxpdChgXG5gKSwgaiA9IEUuc3RhY2suc3BsaXQoYFxuYCksIFggPSB3Lmxlbmd0aCAtIDEsIEEgPSBqLmxlbmd0aCAtIDE7IFggPj0gMSAmJiBBID49IDAgJiYgd1tYXSAhPT0galtBXTsgKVxuICAgICAgICAgICAgQS0tO1xuICAgICAgICAgIGZvciAoOyBYID49IDEgJiYgQSA+PSAwOyBYLS0sIEEtLSlcbiAgICAgICAgICAgIGlmICh3W1hdICE9PSBqW0FdKSB7XG4gICAgICAgICAgICAgIGlmIChYICE9PSAxIHx8IEEgIT09IDEpXG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChYLS0sIEEtLSwgQSA8IDAgfHwgd1tYXSAhPT0galtBXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgTiA9IGBcbmAgKyB3W1hdLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmRpc3BsYXlOYW1lICYmIE4uaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJiAoTiA9IE4ucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIHMuZGlzcGxheU5hbWUpKSwgdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiICYmIEV0LnNldChzLCBOKSwgTjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoWCA+PSAxICYmIEEgPj0gMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBEdCA9ICExLCB6dC5jdXJyZW50ID0gRCwgUWUoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBSO1xuICAgICAgfVxuICAgICAgdmFyIG50ID0gcyA/IHMuZGlzcGxheU5hbWUgfHwgcy5uYW1lIDogXCJcIiwgSiA9IG50ID8gU3QobnQpIDogXCJcIjtcbiAgICAgIHJldHVybiB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgJiYgRXQuc2V0KHMsIEopLCBKO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcihzLCBmLCBnKSB7XG4gICAgICByZXR1cm4gZWUocywgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBycihzKSB7XG4gICAgICB2YXIgZiA9IHMucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKGYgJiYgZi5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3QocywgZiwgZykge1xuICAgICAgaWYgKHMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gZWUocywgcnIocykpO1xuICAgICAgaWYgKHR5cGVvZiBzID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBTdChzKTtcbiAgICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgcmV0dXJuIFN0KFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgZDpcbiAgICAgICAgICByZXR1cm4gU3QoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChzLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBoOlxuICAgICAgICAgICAgcmV0dXJuIGVyKHMucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIHY6XG4gICAgICAgICAgICByZXR1cm4gd3Qocy50eXBlLCBmLCBnKTtcbiAgICAgICAgICBjYXNlIGM6IHtcbiAgICAgICAgICAgIHZhciBFID0gcywgUiA9IEUuX3BheWxvYWQsIEQgPSBFLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHd0KEQoUiksIGYsIGcpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIGN0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgcmUgPSB7fSwgbmUgPSB6LlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gYnQocykge1xuICAgICAgaWYgKHMpIHtcbiAgICAgICAgdmFyIGYgPSBzLl9vd25lciwgZyA9IHd0KHMudHlwZSwgcy5fc291cmNlLCBmID8gZi50eXBlIDogbnVsbCk7XG4gICAgICAgIG5lLnNldEV4dHJhU3RhY2tGcmFtZShnKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBuZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5yKHMsIGYsIGcsIEUsIFIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIEQgPSBGdW5jdGlvbi5jYWxsLmJpbmQoY3QpO1xuICAgICAgICBmb3IgKHZhciB5IGluIHMpXG4gICAgICAgICAgaWYgKEQocywgeSkpIHtcbiAgICAgICAgICAgIHZhciB3ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzW3ldICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBqID0gRXJyb3IoKEUgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIGcgKyBcIiB0eXBlIGBcIiArIHkgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIHNbeV0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IGoubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBqO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHcgPSBzW3ldKGYsIHksIEUsIGcsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChYKSB7XG4gICAgICAgICAgICAgIHcgPSBYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdyAmJiAhKHcgaW5zdGFuY2VvZiBFcnJvcikgJiYgKGJ0KFIpLCBiKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCBFIHx8IFwiUmVhY3QgY2xhc3NcIiwgZywgeSwgdHlwZW9mIHcpLCBidChudWxsKSksIHcgaW5zdGFuY2VvZiBFcnJvciAmJiAhKHcubWVzc2FnZSBpbiByZSkgJiYgKHJlW3cubWVzc2FnZV0gPSAhMCwgYnQoUiksIGIoXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgZywgdy5tZXNzYWdlKSwgYnQobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGlyID0gQXJyYXkuaXNBcnJheTtcbiAgICBmdW5jdGlvbiBZdChzKSB7XG4gICAgICByZXR1cm4gaXIocyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9yKHMpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGYgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIGcgPSBmICYmIHNbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBzLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNyKHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBpZShzKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpZShzKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9lKHMpIHtcbiAgICAgIGlmIChzcihzKSlcbiAgICAgICAgcmV0dXJuIGIoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgb3IocykpLCBpZShzKTtcbiAgICB9XG4gICAgdmFyIHV0ID0gei5SZWFjdEN1cnJlbnRPd25lciwgYXIgPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBzZSwgYWUsIHh0O1xuICAgIHh0ID0ge307XG4gICAgZnVuY3Rpb24gbHIocykge1xuICAgICAgaWYgKGN0LmNhbGwocywgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIGYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHMsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKGYgJiYgZi5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcy5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3Iocykge1xuICAgICAgaWYgKGN0LmNhbGwocywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHMsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGYgJiYgZi5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcy5rZXkgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXIocywgZikge1xuICAgICAgaWYgKHR5cGVvZiBzLnJlZiA9PSBcInN0cmluZ1wiICYmIHV0LmN1cnJlbnQgJiYgZiAmJiB1dC5jdXJyZW50LnN0YXRlTm9kZSAhPT0gZikge1xuICAgICAgICB2YXIgZyA9IHgodXQuY3VycmVudC50eXBlKTtcbiAgICAgICAgeHRbZ10gfHwgKGIoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCB4KHV0LmN1cnJlbnQudHlwZSksIHMucmVmKSwgeHRbZ10gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhyKHMsIGYpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZSB8fCAoc2UgPSAhMCwgYihcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIGYpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZy5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgXCJrZXlcIiwge1xuICAgICAgICAgIGdldDogZyxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmcihzLCBmKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYWUgfHwgKGFlID0gITAsIGIoXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBmKSk7XG4gICAgICAgIH07XG4gICAgICAgIGcuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFwicmVmXCIsIHtcbiAgICAgICAgICBnZXQ6IGcsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHZyID0gZnVuY3Rpb24ocywgZiwgZywgRSwgUiwgRCwgeSkge1xuICAgICAgdmFyIHcgPSB7XG4gICAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgICAkJHR5cGVvZjogbixcbiAgICAgICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgICAgICB0eXBlOiBzLFxuICAgICAgICBrZXk6IGYsXG4gICAgICAgIHJlZjogZyxcbiAgICAgICAgcHJvcHM6IHksXG4gICAgICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgIF9vd25lcjogRFxuICAgICAgfTtcbiAgICAgIHJldHVybiB3Ll9zdG9yZSA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkody5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6ICExXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHcsIFwiX3NlbGZcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogRVxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3LCBcIl9zb3VyY2VcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogUlxuICAgICAgfSksIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUody5wcm9wcyksIE9iamVjdC5mcmVlemUodykpLCB3O1xuICAgIH07XG4gICAgZnVuY3Rpb24gZHIocywgZiwgZywgRSwgUikge1xuICAgICAge1xuICAgICAgICB2YXIgRCwgeSA9IHt9LCB3ID0gbnVsbCwgaiA9IG51bGw7XG4gICAgICAgIGcgIT09IHZvaWQgMCAmJiAob2UoZyksIHcgPSBcIlwiICsgZyksIGNyKGYpICYmIChvZShmLmtleSksIHcgPSBcIlwiICsgZi5rZXkpLCBscihmKSAmJiAoaiA9IGYucmVmLCB1cihmLCBSKSk7XG4gICAgICAgIGZvciAoRCBpbiBmKVxuICAgICAgICAgIGN0LmNhbGwoZiwgRCkgJiYgIWFyLmhhc093blByb3BlcnR5KEQpICYmICh5W0RdID0gZltEXSk7XG4gICAgICAgIGlmIChzICYmIHMuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgdmFyIFggPSBzLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBmb3IgKEQgaW4gWClcbiAgICAgICAgICAgIHlbRF0gPT09IHZvaWQgMCAmJiAoeVtEXSA9IFhbRF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3IHx8IGopIHtcbiAgICAgICAgICB2YXIgQSA9IHR5cGVvZiBzID09IFwiZnVuY3Rpb25cIiA/IHMuZGlzcGxheU5hbWUgfHwgcy5uYW1lIHx8IFwiVW5rbm93blwiIDogcztcbiAgICAgICAgICB3ICYmIGhyKHksIEEpLCBqICYmIGZyKHksIEEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2cihzLCB3LCBqLCBSLCBFLCB1dC5jdXJyZW50LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIE90ID0gei5SZWFjdEN1cnJlbnRPd25lciwgbGUgPSB6LlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gcnQocykge1xuICAgICAgaWYgKHMpIHtcbiAgICAgICAgdmFyIGYgPSBzLl9vd25lciwgZyA9IHd0KHMudHlwZSwgcy5fc291cmNlLCBmID8gZi50eXBlIDogbnVsbCk7XG4gICAgICAgIGxlLnNldEV4dHJhU3RhY2tGcmFtZShnKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBsZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIHZhciBYdDtcbiAgICBYdCA9ICExO1xuICAgIGZ1bmN0aW9uIFB0KHMpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiICYmIHMgIT09IG51bGwgJiYgcy4kJHR5cGVvZiA9PT0gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2UoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChPdC5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIHMgPSB4KE90LmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgaWYgKHMpXG4gICAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBcXGBgICsgcyArIFwiYC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHIocykge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciB1ZSA9IHt9O1xuICAgIGZ1bmN0aW9uIGdyKHMpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGYgPSBjZSgpO1xuICAgICAgICBpZiAoIWYpIHtcbiAgICAgICAgICB2YXIgZyA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzIDogcy5kaXNwbGF5TmFtZSB8fCBzLm5hbWU7XG4gICAgICAgICAgZyAmJiAoZiA9IGBcblxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8YCArIGcgKyBcIj4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoZShzLCBmKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghcy5fc3RvcmUgfHwgcy5fc3RvcmUudmFsaWRhdGVkIHx8IHMua2V5ICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzLl9zdG9yZS52YWxpZGF0ZWQgPSAhMDtcbiAgICAgICAgdmFyIGcgPSBncihmKTtcbiAgICAgICAgaWYgKHVlW2ddKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdWVbZ10gPSAhMDtcbiAgICAgICAgdmFyIEUgPSBcIlwiO1xuICAgICAgICBzICYmIHMuX293bmVyICYmIHMuX293bmVyICE9PSBPdC5jdXJyZW50ICYmIChFID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyB4KHMuX293bmVyLnR5cGUpICsgXCIuXCIpLCBydChzKSwgYignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgZywgRSksIHJ0KG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmZShzLCBmKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgcyAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKFl0KHMpKVxuICAgICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgcy5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgdmFyIEUgPSBzW2ddO1xuICAgICAgICAgICAgUHQoRSkgJiYgaGUoRSwgZik7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQdChzKSlcbiAgICAgICAgICBzLl9zdG9yZSAmJiAocy5fc3RvcmUudmFsaWRhdGVkID0gITApO1xuICAgICAgICBlbHNlIGlmIChzKSB7XG4gICAgICAgICAgdmFyIFIgPSBUKHMpO1xuICAgICAgICAgIGlmICh0eXBlb2YgUiA9PSBcImZ1bmN0aW9uXCIgJiYgUiAhPT0gcy5lbnRyaWVzKVxuICAgICAgICAgICAgZm9yICh2YXIgRCA9IFIuY2FsbChzKSwgeTsgISh5ID0gRC5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgUHQoeS52YWx1ZSkgJiYgaGUoeS52YWx1ZSwgZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbXIocykge1xuICAgICAge1xuICAgICAgICB2YXIgZiA9IHMudHlwZTtcbiAgICAgICAgaWYgKGYgPT0gbnVsbCB8fCB0eXBlb2YgZiA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGc7XG4gICAgICAgIGlmICh0eXBlb2YgZiA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgZyA9IGYucHJvcFR5cGVzO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZiA9PSBcIm9iamVjdFwiICYmIChmLiQkdHlwZW9mID09PSBoIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAgICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgICAgIGYuJCR0eXBlb2YgPT09IHYpKVxuICAgICAgICAgIGcgPSBmLnByb3BUeXBlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICB2YXIgRSA9IHgoZik7XG4gICAgICAgICAgbnIoZywgcy5wcm9wcywgXCJwcm9wXCIsIEUsIHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGYuUHJvcFR5cGVzICE9PSB2b2lkIDAgJiYgIVh0KSB7XG4gICAgICAgICAgWHQgPSAhMDtcbiAgICAgICAgICB2YXIgUiA9IHgoZik7XG4gICAgICAgICAgYihcIkNvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50P1wiLCBSIHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlb2YgZi5nZXREZWZhdWx0UHJvcHMgPT0gXCJmdW5jdGlvblwiICYmICFmLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiBiKFwiZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzIGRlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9yKHMpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgZiA9IE9iamVjdC5rZXlzKHMucHJvcHMpLCBnID0gMDsgZyA8IGYubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgICB2YXIgRSA9IGZbZ107XG4gICAgICAgICAgaWYgKEUgIT09IFwiY2hpbGRyZW5cIiAmJiBFICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICBydChzKSwgYihcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIEUpLCBydChudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzLnJlZiAhPT0gbnVsbCAmJiAocnQocyksIGIoXCJJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLlwiKSwgcnQobnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdmUgPSB7fTtcbiAgICBmdW5jdGlvbiBkZShzLCBmLCBnLCBFLCBSLCBEKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB5ID0gcShzKTtcbiAgICAgICAgaWYgKCF5KSB7XG4gICAgICAgICAgdmFyIHcgPSBcIlwiO1xuICAgICAgICAgIChzID09PSB2b2lkIDAgfHwgdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiBzICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHMpLmxlbmd0aCA9PT0gMCkgJiYgKHcgKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKTtcbiAgICAgICAgICB2YXIgaiA9IHByKCk7XG4gICAgICAgICAgaiA/IHcgKz0gaiA6IHcgKz0gY2UoKTtcbiAgICAgICAgICB2YXIgWDtcbiAgICAgICAgICBzID09PSBudWxsID8gWCA9IFwibnVsbFwiIDogWXQocykgPyBYID0gXCJhcnJheVwiIDogcyAhPT0gdm9pZCAwICYmIHMuJCR0eXBlb2YgPT09IG4gPyAoWCA9IFwiPFwiICsgKHgocy50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCB3ID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBYID0gdHlwZW9mIHMsIGIoXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgWCwgdyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEEgPSBkcihzLCBmLCBnLCBSLCBEKTtcbiAgICAgICAgaWYgKEEgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gQTtcbiAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICB2YXIgTiA9IGYuY2hpbGRyZW47XG4gICAgICAgICAgaWYgKE4gIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmIChFKVxuICAgICAgICAgICAgICBpZiAoWXQoTikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBudCA9IDA7IG50IDwgTi5sZW5ndGg7IG50KyspXG4gICAgICAgICAgICAgICAgICBmZShOW250XSwgcyk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKE4pO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBiKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZmUoTiwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0LmNhbGwoZiwgXCJrZXlcIikpIHtcbiAgICAgICAgICB2YXIgSiA9IHgocyksICQgPSBPYmplY3Qua2V5cyhmKS5maWx0ZXIoZnVuY3Rpb24oQ3IpIHtcbiAgICAgICAgICAgIHJldHVybiBDciAhPT0gXCJrZXlcIjtcbiAgICAgICAgICB9KSwgQXQgPSAkLmxlbmd0aCA+IDAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsgJC5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgICAgaWYgKCF2ZVtKICsgQXRdKSB7XG4gICAgICAgICAgICB2YXIgeXIgPSAkLmxlbmd0aCA+IDAgPyBcIntcIiArICQuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiO1xuICAgICAgICAgICAgYihgQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XG4gIGxldCBwcm9wcyA9ICVzO1xuICA8JXMgey4uLnByb3BzfSAvPlxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XG4gIGxldCBwcm9wcyA9ICVzO1xuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+YCwgQXQsIEosIHlyLCBKKSwgdmVbSiArIEF0XSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcyA9PT0gciA/IF9yKEEpIDogbXIoQSksIEE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNyKHMsIGYsIGcpIHtcbiAgICAgIHJldHVybiBkZShzLCBmLCBnLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEVyKHMsIGYsIGcpIHtcbiAgICAgIHJldHVybiBkZShzLCBmLCBnLCAhMSk7XG4gICAgfVxuICAgIHZhciB3ciA9IEVyLCBiciA9IFNyO1xuICAgIGZ0LkZyYWdtZW50ID0gciwgZnQuanN4ID0gd3IsIGZ0LmpzeHMgPSBicjtcbiAgfSgpKSwgZnQ7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBMdC5leHBvcnRzID0gRHIoKSA6IEx0LmV4cG9ydHMgPSBZcigpO1xudmFyIFEgPSBMdC5leHBvcnRzLCB4ciA9IFwiZnVuY3Rpb25cIiwgT3IgPSBcIm9iamVjdFwiLCBYciA9IFwic3RyaW5nXCIsIFByID0gXCJ1bmRlZmluZWRcIiwgQXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFByICYmIGRvY3VtZW50LCBNciA9IFt7XG4gIG9wZW46IFwiKFwiLFxuICBjbG9zZTogXCIpXCJcbn0sIHtcbiAgb3BlbjogJ1wiJyxcbiAgY2xvc2U6ICdcIidcbn0sIHtcbiAgb3BlbjogXCInXCIsXG4gIGNsb3NlOiBcIidcIlxufSwge1xuICBvcGVuOiAnXFxcXFwiJyxcbiAgY2xvc2U6ICdcXFxcXCInXG59LCB7XG4gIG9wZW46IFwiXFxcXCdcIixcbiAgY2xvc2U6IFwiXFxcXCdcIlxufV0sIHl0ID0ge1xuICBjbTogZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBpICogOTYgLyAyLjU0O1xuICB9LFxuICBtbTogZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBpICogOTYgLyAyNTQ7XG4gIH0sXG4gIGluOiBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIGkgKiA5NjtcbiAgfSxcbiAgcHQ6IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gaSAqIDk2IC8gNzI7XG4gIH0sXG4gIHBjOiBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIGkgKiA5NiAvIDY7XG4gIH0sXG4gIFwiJVwiOiBmdW5jdGlvbihpLCBuKSB7XG4gICAgcmV0dXJuIGkgKiBuIC8gMTAwO1xuICB9LFxuICB2dzogZnVuY3Rpb24oaSwgbikge1xuICAgIHJldHVybiBuID09PSB2b2lkIDAgJiYgKG4gPSB3aW5kb3cuaW5uZXJXaWR0aCksIGkgLyAxMDAgKiBuO1xuICB9LFxuICB2aDogZnVuY3Rpb24oaSwgbikge1xuICAgIHJldHVybiBuID09PSB2b2lkIDAgJiYgKG4gPSB3aW5kb3cuaW5uZXJIZWlnaHQpLCBpIC8gMTAwICogbjtcbiAgfSxcbiAgdm1heDogZnVuY3Rpb24oaSwgbikge1xuICAgIHJldHVybiBuID09PSB2b2lkIDAgJiYgKG4gPSBNYXRoLm1heCh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSksIGkgLyAxMDAgKiBuO1xuICB9LFxuICB2bWluOiBmdW5jdGlvbihpLCBuKSB7XG4gICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpKSwgaSAvIDEwMCAqIG47XG4gIH1cbn07XG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbmZ1bmN0aW9uIGtyKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IDAsIHQgPSBhcmd1bWVudHMubGVuZ3RoOyBuIDwgdDsgbisrKSBpICs9IGFyZ3VtZW50c1tuXS5sZW5ndGg7XG4gIGZvciAodmFyIHIgPSBBcnJheShpKSwgZSA9IDAsIG4gPSAwOyBuIDwgdDsgbisrKSBmb3IgKHZhciBvID0gYXJndW1lbnRzW25dLCBhID0gMCwgbCA9IG8ubGVuZ3RoOyBhIDwgbDsgYSsrLCBlKyspIHJbZV0gPSBvW2FdO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHN0KGkpIHtcbiAgcmV0dXJuIGkgJiYgdHlwZW9mIGkgPT09IE9yO1xufVxuZnVuY3Rpb24gdnQoaSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpKTtcbn1cbmZ1bmN0aW9uIE9lKGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpID09PSBYcjtcbn1cbmZ1bmN0aW9uIFdyKGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpID09PSB4cjtcbn1cbmZ1bmN0aW9uIExyKGksIG4pIHtcbiAgdmFyIHQgPSBpID09PSBcIlwiIHx8IGkgPT0gXCIgXCIsIHIgPSBuID09PSBcIlwiIHx8IG4gPT0gXCIgXCI7XG4gIHJldHVybiByICYmIHQgfHwgaSA9PT0gbjtcbn1cbmZ1bmN0aW9uIFhlKGksIG4sIHQsIHIsIGUpIHtcbiAgdmFyIG8gPSBWdChpLCBuLCB0KTtcbiAgcmV0dXJuIG8gPyB0IDogRnIoaSwgbiwgdCArIDEsIHIsIGUpO1xufVxuZnVuY3Rpb24gVnQoaSwgbiwgdCkge1xuICBpZiAoIWkuaWdub3JlKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgciA9IG4uc2xpY2UoTWF0aC5tYXgodCAtIDMsIDApLCB0ICsgMykuam9pbihcIlwiKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoaS5pZ25vcmUpLmV4ZWMocik7XG59XG5mdW5jdGlvbiBGcihpLCBuLCB0LCByLCBlKSB7XG4gIGZvciAodmFyIG8gPSBmdW5jdGlvbih1KSB7XG4gICAgdmFyIGQgPSBuW3VdLnRyaW0oKTtcbiAgICBpZiAoZCA9PT0gaS5jbG9zZSAmJiAhVnQoaSwgbiwgdSkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdVxuICAgICAgfTtcbiAgICB2YXIgdiA9IHUsIGMgPSBGdChlLCBmdW5jdGlvbihtKSB7XG4gICAgICB2YXIgcCA9IG0ub3BlbjtcbiAgICAgIHJldHVybiBwID09PSBkO1xuICAgIH0pO1xuICAgIGlmIChjICYmICh2ID0gWGUoYywgbiwgdSwgciwgZSkpLCB2ID09PSAtMSlcbiAgICAgIHJldHVybiBhID0gdSwgXCJicmVha1wiO1xuICAgIHUgPSB2LCBhID0gdTtcbiAgfSwgYSwgbCA9IHQ7IGwgPCByOyArK2wpIHtcbiAgICB2YXIgaCA9IG8obCk7XG4gICAgaWYgKGwgPSBhLCB0eXBlb2YgaCA9PSBcIm9iamVjdFwiKSByZXR1cm4gaC52YWx1ZTtcbiAgICBpZiAoaCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBQZShpLCBuKSB7XG4gIHZhciB0ID0gT2UobikgPyB7XG4gICAgc2VwYXJhdG9yOiBuXG4gIH0gOiBuLCByID0gdC5zZXBhcmF0b3IsIGUgPSByID09PSB2b2lkIDAgPyBcIixcIiA6IHIsIG8gPSB0LmlzU2VwYXJhdGVGaXJzdCwgYSA9IHQuaXNTZXBhcmF0ZU9ubHlPcGVuQ2xvc2UsIGwgPSB0LmlzU2VwYXJhdGVPcGVuQ2xvc2UsIGggPSBsID09PSB2b2lkIDAgPyBhIDogbCwgdSA9IHQub3BlbkNsb3NlQ2hhcmFjdGVycywgZCA9IHUgPT09IHZvaWQgMCA/IE1yIDogdSwgdiA9IGQubWFwKGZ1bmN0aW9uKEMpIHtcbiAgICB2YXIgUCA9IEMub3BlbiwgTCA9IEMuY2xvc2U7XG4gICAgcmV0dXJuIFAgPT09IEwgPyBQIDogUCArIFwifFwiICsgTDtcbiAgfSkuam9pbihcInxcIiksIGMgPSBcIihcXFxccypcIiArIGUgKyBcIlxcXFxzKnxcIiArIHYgKyBcInxcXFxccyspXCIsIG0gPSBuZXcgUmVnRXhwKGMsIFwiZ1wiKSwgcCA9IGkuc3BsaXQobSkuZmlsdGVyKGZ1bmN0aW9uKEMpIHtcbiAgICByZXR1cm4gQyAmJiBDICE9PSBcInVuZGVmaW5lZFwiO1xuICB9KSwgUyA9IHAubGVuZ3RoLCBUID0gW10sIHogPSBbXTtcbiAgZnVuY3Rpb24gYigpIHtcbiAgICByZXR1cm4gei5sZW5ndGggPyAoVC5wdXNoKHouam9pbihcIlwiKSksIHogPSBbXSwgITApIDogITE7XG4gIH1cbiAgZm9yICh2YXIgVyA9IGZ1bmN0aW9uKEMpIHtcbiAgICB2YXIgUCA9IHBbQ10udHJpbSgpLCBMID0gQywgcSA9IEZ0KGQsIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBCID0geC5vcGVuO1xuICAgICAgcmV0dXJuIEIgPT09IFA7XG4gICAgfSksIFogPSBGdChkLCBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgQiA9IHguY2xvc2U7XG4gICAgICByZXR1cm4gQiA9PT0gUDtcbiAgICB9KTtcbiAgICBpZiAocSkge1xuICAgICAgaWYgKEwgPSBYZShxLCBwLCBDLCBTLCBkKSwgTCAhPT0gLTEgJiYgaClcbiAgICAgICAgcmV0dXJuIGIoKSAmJiBvIHx8IChULnB1c2gocC5zbGljZShDLCBMICsgMSkuam9pbihcIlwiKSksIEMgPSBMLCBvKSA/IChrID0gQywgXCJicmVha1wiKSA6IChrID0gQywgXCJjb250aW51ZVwiKTtcbiAgICB9IGVsc2UgaWYgKFogJiYgIVZ0KFosIHAsIEMpKSB7XG4gICAgICB2YXIgRiA9IGtyKGQpO1xuICAgICAgcmV0dXJuIEYuc3BsaWNlKGQuaW5kZXhPZihaKSwgMSksIHtcbiAgICAgICAgdmFsdWU6IFBlKGksIHtcbiAgICAgICAgICBzZXBhcmF0b3I6IGUsXG4gICAgICAgICAgaXNTZXBhcmF0ZUZpcnN0OiBvLFxuICAgICAgICAgIGlzU2VwYXJhdGVPbmx5T3BlbkNsb3NlOiBhLFxuICAgICAgICAgIGlzU2VwYXJhdGVPcGVuQ2xvc2U6IGgsXG4gICAgICAgICAgb3BlbkNsb3NlQ2hhcmFjdGVyczogRlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKExyKFAsIGUpICYmICFhKVxuICAgICAgcmV0dXJuIGIoKSwgbyA/IChrID0gQywgXCJicmVha1wiKSA6IChrID0gQywgXCJjb250aW51ZVwiKTtcbiAgICBMID09PSAtMSAmJiAoTCA9IFMgLSAxKSwgei5wdXNoKHAuc2xpY2UoQywgTCArIDEpLmpvaW4oXCJcIikpLCBDID0gTCwgayA9IEM7XG4gIH0sIGssIEggPSAwOyBIIDwgUzsgKytIKSB7XG4gICAgdmFyIFYgPSBXKEgpO1xuICAgIGlmIChIID0gaywgdHlwZW9mIFYgPT0gXCJvYmplY3RcIikgcmV0dXJuIFYudmFsdWU7XG4gICAgaWYgKFYgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHoubGVuZ3RoICYmIFQucHVzaCh6LmpvaW4oXCJcIikpLCBUO1xufVxuZnVuY3Rpb24ganIoaSkge1xuICByZXR1cm4gUGUoaSwgXCIsXCIpO1xufVxuZnVuY3Rpb24gSXIoaSkge1xuICB2YXIgbiA9IC9eKFteXFxkfGV8XFwtfFxcK10qKSgoPzpcXGR8XFwufC18ZS18ZVxcKykrKShcXFMqKSQvZy5leGVjKGkpO1xuICBpZiAoIW4pXG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeDogXCJcIixcbiAgICAgIHVuaXQ6IFwiXCIsXG4gICAgICB2YWx1ZTogTmFOXG4gICAgfTtcbiAgdmFyIHQgPSBuWzFdLCByID0gblsyXSwgZSA9IG5bM107XG4gIHJldHVybiB7XG4gICAgcHJlZml4OiB0LFxuICAgIHVuaXQ6IGUsXG4gICAgdmFsdWU6IHBhcnNlRmxvYXQocilcbiAgfTtcbn1cbmZ1bmN0aW9uIEFlKGkpIHtcbiAgcmV0dXJuIGkucmVwbGFjZSgvW1xccy1fXSsoW15cXHMtX10pL2csIGZ1bmN0aW9uKG4sIHQpIHtcbiAgICByZXR1cm4gdC50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1lKCkge1xuICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG59XG5mdW5jdGlvbiBNZShpLCBuLCB0KSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IC0xKTtcbiAgZm9yICh2YXIgciA9IGkubGVuZ3RoLCBlID0gMDsgZSA8IHI7ICsrZSlcbiAgICBpZiAobihpW2VdLCBlLCBpKSlcbiAgICAgIHJldHVybiBlO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIEZ0KGksIG4sIHQpIHtcbiAgdmFyIHIgPSBNZShpLCBuKTtcbiAgcmV0dXJuIHIgPiAtMSA/IGlbcl0gOiB0O1xufVxuZnVuY3Rpb24gRyhpLCBuKSB7XG4gIHZhciB0ID0gSXIoaSksIHIgPSB0LnZhbHVlLCBlID0gdC51bml0O1xuICBpZiAoc3QobikpIHtcbiAgICB2YXIgbyA9IG5bZV07XG4gICAgaWYgKG8pIHtcbiAgICAgIGlmIChXcihvKSlcbiAgICAgICAgcmV0dXJuIG8ocik7XG4gICAgICBpZiAoeXRbZV0pXG4gICAgICAgIHJldHVybiB5dFtlXShyLCBvKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZSA9PT0gXCIlXCIpXG4gICAgcmV0dXJuIHIgKiBuIC8gMTAwO1xuICByZXR1cm4geXRbZV0gPyB5dFtlXShyKSA6IHI7XG59XG5mdW5jdGlvbiB0dChpLCBuLCB0KSB7XG4gIHJldHVybiBNYXRoLm1heChuLCBNYXRoLm1pbihpLCB0KSk7XG59XG5mdW5jdGlvbiAkcihpLCBuKSB7XG4gIHZhciB0ID0gMSAvIG47XG4gIHJldHVybiBNYXRoLnJvdW5kKGkgLyBuKSAvIHQ7XG59XG5mdW5jdGlvbiBpdChpLCBuKSB7XG4gIGkuY2xhc3NMaXN0ID8gaS5jbGFzc0xpc3QuYWRkKG4pIDogaS5jbGFzc05hbWUgKz0gXCIgXCIgKyBuO1xufVxuZnVuY3Rpb24gTyhpLCBuLCB0LCByKSB7XG4gIGkuYWRkRXZlbnRMaXN0ZW5lcihuLCB0LCByKTtcbn1cbmZ1bmN0aW9uIFkoaSwgbiwgdCwgcikge1xuICBpLnJlbW92ZUV2ZW50TGlzdGVuZXIobiwgdCwgcik7XG59XG5mdW5jdGlvbiBOdChpKSB7XG4gIHJldHVybiAoaSA9PSBudWxsID8gdm9pZCAwIDogaS5vd25lckRvY3VtZW50KSB8fCBBcjtcbn1cbmZ1bmN0aW9uIG90KGkpIHtcbiAgdmFyIG47XG4gIHJldHVybiAoKG4gPSBpID09IG51bGwgPyB2b2lkIDAgOiBpLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIEJyKGkpIHtcbiAgcmV0dXJuIGkgJiYgXCJwb3N0TWVzc2FnZVwiIGluIGkgJiYgXCJibHVyXCIgaW4gaSAmJiBcInNlbGZcIiBpbiBpO1xufVxuZnVuY3Rpb24gX2UoaSkge1xuICByZXR1cm4gc3QoaSkgJiYgaS5ub2RlTmFtZSAmJiBpLm5vZGVUeXBlICYmIFwib3duZXJEb2N1bWVudFwiIGluIGk7XG59XG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbnZhciBqdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ganQgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKG4pIHtcbiAgICBmb3IgKHZhciB0LCByID0gMSwgZSA9IGFyZ3VtZW50cy5sZW5ndGg7IHIgPCBlOyByKyspIHtcbiAgICAgIHQgPSBhcmd1bWVudHNbcl07XG4gICAgICBmb3IgKHZhciBvIGluIHQpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBvKSAmJiAobltvXSA9IHRbb10pO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfSwganQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBIcigpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSAwLCB0ID0gYXJndW1lbnRzLmxlbmd0aDsgbiA8IHQ7IG4rKykgaSArPSBhcmd1bWVudHNbbl0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkoaSksIGUgPSAwLCBuID0gMDsgbiA8IHQ7IG4rKykgZm9yICh2YXIgbyA9IGFyZ3VtZW50c1tuXSwgYSA9IDAsIGwgPSBvLmxlbmd0aDsgYSA8IGw7IGErKywgZSsrKSByW2VdID0gb1thXTtcbiAgcmV0dXJuIHI7XG59XG52YXIgWnQgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGkoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gIH1cbiAgdmFyIG4gPSBpLnByb3RvdHlwZTtcbiAgcmV0dXJuIG4ub24gPSBmdW5jdGlvbih0LCByKSB7XG4gICAgaWYgKHN0KHQpKVxuICAgICAgZm9yICh2YXIgZSBpbiB0KVxuICAgICAgICB0aGlzLm9uKGUsIHRbZV0pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuX2FkZEV2ZW50KHQsIHIsIHt9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSwgbi5vZmYgPSBmdW5jdGlvbih0LCByKSB7XG4gICAgaWYgKCF0KVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAoc3QodCkpXG4gICAgICBmb3IgKHZhciBlIGluIHQpXG4gICAgICAgIHRoaXMub2ZmKGUpO1xuICAgIGVsc2UgaWYgKCFyKVxuICAgICAgdGhpcy5fZXZlbnRzW3RdID0gW107XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbyA9IHRoaXMuX2V2ZW50c1t0XTtcbiAgICAgIGlmIChvKSB7XG4gICAgICAgIHZhciBhID0gTWUobywgZnVuY3Rpb24obCkge1xuICAgICAgICAgIHJldHVybiBsLmxpc3RlbmVyID09PSByO1xuICAgICAgICB9KTtcbiAgICAgICAgYSA+IC0xICYmIG8uc3BsaWNlKGEsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSwgbi5vbmNlID0gZnVuY3Rpb24odCwgcikge1xuICAgIHZhciBlID0gdGhpcztcbiAgICByZXR1cm4gciAmJiB0aGlzLl9hZGRFdmVudCh0LCByLCB7XG4gICAgICBvbmNlOiAhMFxuICAgIH0pLCBuZXcgUHJvbWlzZShmdW5jdGlvbihvKSB7XG4gICAgICBlLl9hZGRFdmVudCh0LCBvLCB7XG4gICAgICAgIG9uY2U6ICEwXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgbi5lbWl0ID0gZnVuY3Rpb24odCwgcikge1xuICAgIHZhciBlID0gdGhpcztcbiAgICByID09PSB2b2lkIDAgJiYgKHIgPSB7fSk7XG4gICAgdmFyIG8gPSB0aGlzLl9ldmVudHNbdF07XG4gICAgaWYgKCF0IHx8ICFvKVxuICAgICAgcmV0dXJuICEwO1xuICAgIHZhciBhID0gITE7XG4gICAgcmV0dXJuIHIuZXZlbnRUeXBlID0gdCwgci5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICBhID0gITA7XG4gICAgfSwgci5jdXJyZW50VGFyZ2V0ID0gdGhpcywgSHIobykuZm9yRWFjaChmdW5jdGlvbihsKSB7XG4gICAgICBsLmxpc3RlbmVyKHIpLCBsLm9uY2UgJiYgZS5vZmYodCwgbC5saXN0ZW5lcik7XG4gICAgfSksICFhO1xuICB9LCBuLnRyaWdnZXIgPSBmdW5jdGlvbih0LCByKSB7XG4gICAgcmV0dXJuIHIgPT09IHZvaWQgMCAmJiAociA9IHt9KSwgdGhpcy5lbWl0KHQsIHIpO1xuICB9LCBuLl9hZGRFdmVudCA9IGZ1bmN0aW9uKHQsIHIsIGUpIHtcbiAgICB2YXIgbyA9IHRoaXMuX2V2ZW50cztcbiAgICBvW3RdID0gb1t0XSB8fCBbXTtcbiAgICB2YXIgYSA9IG9bdF07XG4gICAgYS5wdXNoKGp0KHtcbiAgICAgIGxpc3RlbmVyOiByXG4gICAgfSwgZSkpO1xuICB9LCBpO1xufSgpO1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG52YXIgSXQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIHJldHVybiBJdCA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKHQsIHIpIHtcbiAgICB0Ll9fcHJvdG9fXyA9IHI7XG4gIH0gfHwgZnVuY3Rpb24odCwgcikge1xuICAgIGZvciAodmFyIGUgaW4gcikgci5oYXNPd25Qcm9wZXJ0eShlKSAmJiAodFtlXSA9IHJbZV0pO1xuICB9LCBJdChpLCBuKTtcbn07XG5mdW5jdGlvbiBWcihpLCBuKSB7XG4gIEl0KGksIG4pO1xuICBmdW5jdGlvbiB0KCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBpO1xuICB9XG4gIGkucHJvdG90eXBlID0gbiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUobikgOiAodC5wcm90b3R5cGUgPSBuLnByb3RvdHlwZSwgbmV3IHQoKSk7XG59XG52YXIgTSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24obikge1xuICAgIGZvciAodmFyIHQsIHIgPSAxLCBlID0gYXJndW1lbnRzLmxlbmd0aDsgciA8IGU7IHIrKykge1xuICAgICAgdCA9IGFyZ3VtZW50c1tyXTtcbiAgICAgIGZvciAodmFyIG8gaW4gdCkgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIG8pICYmIChuW29dID0gdFtvXSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBNLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gTnIoaSwgbikge1xuICB2YXIgdCA9IG5bMF0gLSBpWzBdLCByID0gblsxXSAtIGlbMV0sIGUgPSBNYXRoLmF0YW4yKHIsIHQpO1xuICByZXR1cm4gZSA+PSAwID8gZSA6IGUgKyBNYXRoLlBJICogMjtcbn1cbmZ1bmN0aW9uIE10KGkpIHtcbiAgcmV0dXJuIE5yKFtcbiAgICBpWzBdLmNsaWVudFgsXG4gICAgaVswXS5jbGllbnRZXG4gIF0sIFtcbiAgICBpWzFdLmNsaWVudFgsXG4gICAgaVsxXS5jbGllbnRZXG4gIF0pIC8gTWF0aC5QSSAqIDE4MDtcbn1cbmZ1bmN0aW9uIFpyKGkpIHtcbiAgcmV0dXJuIGkudG91Y2hlcyAmJiBpLnRvdWNoZXMubGVuZ3RoID49IDI7XG59XG5mdW5jdGlvbiBDdChpKSB7XG4gIHJldHVybiBpID8gaS50b3VjaGVzID8gcXIoaS50b3VjaGVzKSA6IFtrZShpKV0gOiBbXTtcbn1cbmZ1bmN0aW9uIFVyKGkpIHtcbiAgcmV0dXJuIGkgJiYgKGkudHlwZS5pbmRleE9mKFwibW91c2VcIikgPiAtMSB8fCBcImJ1dHRvblwiIGluIGkpO1xufVxuZnVuY3Rpb24gU2UoaSwgbiwgdCkge1xuICB2YXIgciA9IHQubGVuZ3RoLCBlID0gZ3QoaSwgciksIG8gPSBlLmNsaWVudFgsIGEgPSBlLmNsaWVudFksIGwgPSBlLm9yaWdpbmFsQ2xpZW50WCwgaCA9IGUub3JpZ2luYWxDbGllbnRZLCB1ID0gZ3QobiwgciksIGQgPSB1LmNsaWVudFgsIHYgPSB1LmNsaWVudFksIGMgPSBndCh0LCByKSwgbSA9IGMuY2xpZW50WCwgcCA9IGMuY2xpZW50WSwgUyA9IG8gLSBkLCBUID0gYSAtIHYsIHogPSBvIC0gbSwgYiA9IGEgLSBwO1xuICByZXR1cm4ge1xuICAgIGNsaWVudFg6IGwsXG4gICAgY2xpZW50WTogaCxcbiAgICBkZWx0YVg6IFMsXG4gICAgZGVsdGFZOiBULFxuICAgIGRpc3RYOiB6LFxuICAgIGRpc3RZOiBiXG4gIH07XG59XG5mdW5jdGlvbiBrdChpKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coaVswXS5jbGllbnRYIC0gaVsxXS5jbGllbnRYLCAyKSArIE1hdGgucG93KGlbMF0uY2xpZW50WSAtIGlbMV0uY2xpZW50WSwgMikpO1xufVxuZnVuY3Rpb24gcXIoaSkge1xuICBmb3IgKHZhciBuID0gTWF0aC5taW4oaS5sZW5ndGgsIDIpLCB0ID0gW10sIHIgPSAwOyByIDwgbjsgKytyKVxuICAgIHQucHVzaChrZShpW3JdKSk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24ga2UoaSkge1xuICByZXR1cm4ge1xuICAgIGNsaWVudFg6IGkuY2xpZW50WCxcbiAgICBjbGllbnRZOiBpLmNsaWVudFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGd0KGksIG4pIHtcbiAgbiA9PT0gdm9pZCAwICYmIChuID0gaS5sZW5ndGgpO1xuICBmb3IgKHZhciB0ID0ge1xuICAgIGNsaWVudFg6IDAsXG4gICAgY2xpZW50WTogMCxcbiAgICBvcmlnaW5hbENsaWVudFg6IDAsXG4gICAgb3JpZ2luYWxDbGllbnRZOiAwXG4gIH0sIHIgPSBNYXRoLm1pbihpLmxlbmd0aCwgbiksIGUgPSAwOyBlIDwgcjsgKytlKSB7XG4gICAgdmFyIG8gPSBpW2VdO1xuICAgIHQub3JpZ2luYWxDbGllbnRYICs9IFwib3JpZ2luYWxDbGllbnRYXCIgaW4gbyA/IG8ub3JpZ2luYWxDbGllbnRYIDogby5jbGllbnRYLCB0Lm9yaWdpbmFsQ2xpZW50WSArPSBcIm9yaWdpbmFsQ2xpZW50WVwiIGluIG8gPyBvLm9yaWdpbmFsQ2xpZW50WSA6IG8uY2xpZW50WSwgdC5jbGllbnRYICs9IG8uY2xpZW50WCwgdC5jbGllbnRZICs9IG8uY2xpZW50WTtcbiAgfVxuICByZXR1cm4gbiA/IHtcbiAgICBjbGllbnRYOiB0LmNsaWVudFggLyBuLFxuICAgIGNsaWVudFk6IHQuY2xpZW50WSAvIG4sXG4gICAgb3JpZ2luYWxDbGllbnRYOiB0Lm9yaWdpbmFsQ2xpZW50WCAvIG4sXG4gICAgb3JpZ2luYWxDbGllbnRZOiB0Lm9yaWdpbmFsQ2xpZW50WSAvIG5cbiAgfSA6IHQ7XG59XG52YXIgV3QgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGkobikge1xuICAgIHRoaXMucHJldkNsaWVudHMgPSBbXSwgdGhpcy5zdGFydENsaWVudHMgPSBbXSwgdGhpcy5tb3ZlbWVudCA9IDAsIHRoaXMubGVuZ3RoID0gMCwgdGhpcy5zdGFydENsaWVudHMgPSBuLCB0aGlzLnByZXZDbGllbnRzID0gbiwgdGhpcy5sZW5ndGggPSBuLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gaS5wcm90b3R5cGUuZ2V0QW5nbGUgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IHRoaXMucHJldkNsaWVudHMpLCBNdChuKTtcbiAgfSwgaS5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IHRoaXMucHJldkNsaWVudHMpLCBNdChuKSAtIE10KHRoaXMuc3RhcnRDbGllbnRzKTtcbiAgfSwgaS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbihuLCB0KSB7XG4gICAgbiA9PT0gdm9pZCAwICYmIChuID0gdGhpcy5wcmV2Q2xpZW50cyk7XG4gICAgdmFyIHIgPSBTZShuIHx8IHRoaXMucHJldkNsaWVudHMsIHRoaXMucHJldkNsaWVudHMsIHRoaXMuc3RhcnRDbGllbnRzKSwgZSA9IHIuZGVsdGFYLCBvID0gci5kZWx0YVk7XG4gICAgcmV0dXJuIHRoaXMubW92ZW1lbnQgKz0gTWF0aC5zcXJ0KGUgKiBlICsgbyAqIG8pLCB0aGlzLnByZXZDbGllbnRzID0gbiwgcjtcbiAgfSwgaS5wcm90b3R5cGUuZ2V0UG9zaXRpb25zID0gZnVuY3Rpb24obikge1xuICAgIG4gPT09IHZvaWQgMCAmJiAobiA9IHRoaXMucHJldkNsaWVudHMpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLnByZXZDbGllbnRzLCByID0gdGhpcy5zdGFydENsaWVudHMsIGUgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdC5sZW5ndGgpLCBvID0gW10sIGEgPSAwOyBhIDwgZTsgKythKVxuICAgICAgb1thXSA9IFNlKFtuW2FdXSwgW3RbYV1dLCBbclthXV0pO1xuICAgIHJldHVybiBvO1xuICB9LCBpLnByb3RvdHlwZS5nZXRNb3ZlbWVudCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgdCA9IHRoaXMubW92ZW1lbnQ7XG4gICAgaWYgKCFuKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgdmFyIHIgPSBndChuLCB0aGlzLmxlbmd0aCksIGUgPSBndCh0aGlzLnByZXZDbGllbnRzLCB0aGlzLmxlbmd0aCksIG8gPSByLmNsaWVudFggLSBlLmNsaWVudFgsIGEgPSByLmNsaWVudFkgLSBlLmNsaWVudFk7XG4gICAgcmV0dXJuIE1hdGguc3FydChvICogbyArIGEgKiBhKSArIHQ7XG4gIH0sIGkucHJvdG90eXBlLmdldERpc3RhbmNlID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBuID09PSB2b2lkIDAgJiYgKG4gPSB0aGlzLnByZXZDbGllbnRzKSwga3Qobik7XG4gIH0sIGkucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBuID09PSB2b2lkIDAgJiYgKG4gPSB0aGlzLnByZXZDbGllbnRzKSwga3QobikgLyBrdCh0aGlzLnN0YXJ0Q2xpZW50cyk7XG4gIH0sIGkucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihuLCB0KSB7XG4gICAgdGhpcy5zdGFydENsaWVudHMuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICByLmNsaWVudFggLT0gbiwgci5jbGllbnRZIC09IHQ7XG4gICAgfSksIHRoaXMucHJldkNsaWVudHMuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICByLmNsaWVudFggLT0gbiwgci5jbGllbnRZIC09IHQ7XG4gICAgfSk7XG4gIH0sIGk7XG59KCksIEVlID0gW1widGV4dGFyZWFcIiwgXCJpbnB1dFwiXSwgV2UgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oaSkge1xuICBWcihuLCBpKTtcbiAgZnVuY3Rpb24gbih0LCByKSB7XG4gICAgciA9PT0gdm9pZCAwICYmIChyID0ge30pO1xuICAgIHZhciBlID0gaS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgZS5vcHRpb25zID0ge30sIGUuZmxhZyA9ICExLCBlLnBpbmNoRmxhZyA9ICExLCBlLmRhdGEgPSB7fSwgZS5pc0RyYWcgPSAhMSwgZS5pc1BpbmNoID0gITEsIGUuY2xpZW50U3RvcmVzID0gW10sIGUudGFyZ2V0cyA9IFtdLCBlLnByZXZUaW1lID0gMCwgZS5kb3VibGVGbGFnID0gITEsIGUuX3VzZU1vdXNlID0gITEsIGUuX3VzZVRvdWNoID0gITEsIGUuX3VzZURyYWcgPSAhMSwgZS5fZHJhZ0ZsYWcgPSAhMSwgZS5faXNUcnVzdGVkID0gITEsIGUuX2lzTW91c2VFdmVudCA9ICExLCBlLl9pc1NlY29uZGFyeUJ1dHRvbiA9ICExLCBlLl9wcmV2ZW50TW91c2VFdmVudCA9ICExLCBlLl9wcmV2SW5wdXRFdmVudCA9IG51bGwsIGUuX2lzRHJhZ0FQSSA9ICExLCBlLl9pc0lkbGUgPSAhMCwgZS5fcHJldmVudE1vdXNlRXZlbnRJZCA9IDAsIGUuX3dpbmRvdyA9IHdpbmRvdywgZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGMsIG0pIHtcbiAgICAgIGlmIChtID09PSB2b2lkIDAgJiYgKG0gPSAhMCksICEoIWUuZmxhZyAmJiBjLmNhbmNlbGFibGUgPT09ICExKSkge1xuICAgICAgICB2YXIgcCA9IGMudHlwZS5pbmRleE9mKFwiZHJhZ1wiKSA+PSAtMTtcbiAgICAgICAgaWYgKCEoZS5mbGFnICYmIHApKSB7XG4gICAgICAgICAgZS5faXNEcmFnQVBJID0gITA7XG4gICAgICAgICAgdmFyIFMgPSBlLm9wdGlvbnMsIFQgPSBTLmNvbnRhaW5lciwgeiA9IFMucGluY2hPdXRzaWRlLCBiID0gUy5wcmV2ZW50V2hlZWxDbGljaywgVyA9IFMucHJldmVudFJpZ2h0Q2xpY2ssIGsgPSBTLnByZXZlbnREZWZhdWx0LCBIID0gUy5jaGVja0lucHV0LCBWID0gUy5kcmFnRm9jdXNlZElucHV0LCBDID0gUy5wcmV2ZW50Q2xpY2tFdmVudE9uRHJhZ1N0YXJ0LCBQID0gUy5wcmV2ZW50Q2xpY2tFdmVudE9uRHJhZywgTCA9IFMucHJldmVudENsaWNrRXZlbnRCeUNvbmRpdGlvbiwgcSA9IGUuX3VzZVRvdWNoLCBaID0gIWUuZmxhZztcbiAgICAgICAgICBpZiAoZS5faXNTZWNvbmRhcnlCdXR0b24gPSBjLndoaWNoID09PSAzIHx8IGMuYnV0dG9uID09PSAyLCBiICYmIChjLndoaWNoID09PSAyIHx8IGMuYnV0dG9uID09PSAxKSB8fCBXICYmIChjLndoaWNoID09PSAzIHx8IGMuYnV0dG9uID09PSAyKSlcbiAgICAgICAgICAgIHJldHVybiBlLnN0b3AoKSwgITE7XG4gICAgICAgICAgaWYgKFopIHtcbiAgICAgICAgICAgIHZhciBGID0gZS5fd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsIHggPSBjLnRhcmdldDtcbiAgICAgICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICAgIHZhciBCID0geC50YWdOYW1lLnRvTG93ZXJDYXNlKCksIEsgPSBFZS5pbmRleE9mKEIpID4gLTEsIGF0ID0geC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgICAgICAgaWYgKEsgfHwgYXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoSCB8fCAhViAmJiBGID09PSB4KVxuICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGlmIChGICYmIChGID09PSB4IHx8IGF0ICYmIEYuaXNDb250ZW50RWRpdGFibGUgJiYgRi5jb250YWlucyh4KSkpXG4gICAgICAgICAgICAgICAgICBpZiAoVilcbiAgICAgICAgICAgICAgICAgICAgeC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgoayB8fCBjLnR5cGUgPT09IFwidG91Y2hzdGFydFwiKSAmJiBGKSB7XG4gICAgICAgICAgICAgICAgdmFyIG10ID0gRi50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgKEYuaXNDb250ZW50RWRpdGFibGUgfHwgRWUuaW5kZXhPZihtdCkgPiAtMSkgJiYgRi5ibHVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKEMgfHwgUCB8fCBMKSAmJiBPKGUuX3dpbmRvdywgXCJjbGlja1wiLCBlLl9vbkNsaWNrLCAhMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLmNsaWVudFN0b3JlcyA9IFtuZXcgV3QoQ3QoYykpXSwgZS5faXNJZGxlID0gITEsIGUuZmxhZyA9ICEwLCBlLmlzRHJhZyA9ICExLCBlLl9pc1RydXN0ZWQgPSBtLCBlLl9kcmFnRmxhZyA9ICEwLCBlLl9wcmV2SW5wdXRFdmVudCA9IGMsIGUuZGF0YSA9IHt9LCBlLmRvdWJsZUZsYWcgPSBtZSgpIC0gZS5wcmV2VGltZSA8IDIwMCwgZS5faXNNb3VzZUV2ZW50ID0gVXIoYyksICFlLl9pc01vdXNlRXZlbnQgJiYgZS5fcHJldmVudE1vdXNlRXZlbnQgJiYgZS5fYWxsb3dNb3VzZUV2ZW50KCk7XG4gICAgICAgICAgICB2YXIgX3QgPSBlLl9wcmV2ZW50TW91c2VFdmVudCB8fCBlLmVtaXQoXCJkcmFnU3RhcnRcIiwgTShNKHsgZGF0YTogZS5kYXRhLCBkYXRhczogZS5kYXRhLCBpbnB1dEV2ZW50OiBjLCBpc01vdXNlRXZlbnQ6IGUuX2lzTW91c2VFdmVudCwgaXNTZWNvbmRhcnlCdXR0b246IGUuX2lzU2Vjb25kYXJ5QnV0dG9uLCBpc1RydXN0ZWQ6IG0sIGlzRG91YmxlOiBlLmRvdWJsZUZsYWcgfSwgZS5nZXRDdXJyZW50U3RvcmUoKS5nZXRQb3NpdGlvbigpKSwgeyBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGMucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0sIHByZXZlbnREcmFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZS5fZHJhZ0ZsYWcgPSAhMTtcbiAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICAgICAgX3QgPT09ICExICYmIGUuc3RvcCgpLCBlLl9pc01vdXNlRXZlbnQgJiYgZS5mbGFnICYmIGsgJiYgYy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUuZmxhZylcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICB2YXIgbHQgPSAwO1xuICAgICAgICAgIGlmIChaID8gKGUuX2F0dGNoRHJhZ0V2ZW50KCksIHEgJiYgeiAmJiAobHQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgTyhULCBcInRvdWNoc3RhcnRcIiwgZS5vbkRyYWdTdGFydCwge1xuICAgICAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkpKSA6IHEgJiYgeiAmJiBZKFQsIFwidG91Y2hzdGFydFwiLCBlLm9uRHJhZ1N0YXJ0KSwgZS5mbGFnICYmIFpyKGMpKSB7XG4gICAgICAgICAgICBpZiAoY2xlYXJUaW1lb3V0KGx0KSwgWiAmJiBjLnRvdWNoZXMubGVuZ3RoICE9PSBjLmNoYW5nZWRUb3VjaGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZS5waW5jaEZsYWcgfHwgZS5vblBpbmNoU3RhcnQoYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgZS5vbkRyYWcgPSBmdW5jdGlvbihjLCBtKSB7XG4gICAgICBpZiAoZS5mbGFnKSB7XG4gICAgICAgIHZhciBwID0gZS5vcHRpb25zLnByZXZlbnREZWZhdWx0O1xuICAgICAgICAhZS5faXNNb3VzZUV2ZW50ICYmIHAgJiYgYy5wcmV2ZW50RGVmYXVsdCgpLCBlLl9wcmV2SW5wdXRFdmVudCA9IGM7XG4gICAgICAgIHZhciBTID0gQ3QoYyksIFQgPSBlLm1vdmVDbGllbnRzKFMsIGMsICExKTtcbiAgICAgICAgaWYgKGUuX2RyYWdGbGFnKSB7XG4gICAgICAgICAgaWYgKGUucGluY2hGbGFnIHx8IFQuZGVsdGFYIHx8IFQuZGVsdGFZKSB7XG4gICAgICAgICAgICB2YXIgeiA9IGUuX3ByZXZlbnRNb3VzZUV2ZW50IHx8IGUuZW1pdChcImRyYWdcIiwgTShNKHt9LCBUKSwgeyBpc1Njcm9sbDogISFtLCBpbnB1dEV2ZW50OiBjIH0pKTtcbiAgICAgICAgICAgIGlmICh6ID09PSAhMSkge1xuICAgICAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlLnBpbmNoRmxhZyAmJiBlLm9uUGluY2goYywgUyk7XG4gICAgICAgIH1cbiAgICAgICAgZS5nZXRDdXJyZW50U3RvcmUoKS5nZXRQb3NpdGlvbihTLCAhMCk7XG4gICAgICB9XG4gICAgfSwgZS5vbkRyYWdFbmQgPSBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAoZS5mbGFnKSB7XG4gICAgICAgIHZhciBtID0gZS5vcHRpb25zLCBwID0gbS5waW5jaE91dHNpZGUsIFMgPSBtLmNvbnRhaW5lciwgVCA9IG0ucHJldmVudENsaWNrRXZlbnRPbkRyYWcsIHogPSBtLnByZXZlbnRDbGlja0V2ZW50T25EcmFnU3RhcnQsIGIgPSBtLnByZXZlbnRDbGlja0V2ZW50QnlDb25kaXRpb24sIFcgPSBlLmlzRHJhZztcbiAgICAgICAgKFQgfHwgeiB8fCBiKSAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZS5fYWxsb3dDbGlja0V2ZW50KCk7XG4gICAgICAgIH0pLCAhYiAmJiAheiAmJiBUICYmICFXICYmIGUuX2FsbG93Q2xpY2tFdmVudCgpLCBlLl91c2VUb3VjaCAmJiBwICYmIFkoUywgXCJ0b3VjaHN0YXJ0XCIsIGUub25EcmFnU3RhcnQpLCBlLnBpbmNoRmxhZyAmJiBlLm9uUGluY2hFbmQoYyk7XG4gICAgICAgIHZhciBrID0gYyAhPSBudWxsICYmIGMudG91Y2hlcyA/IEN0KGMpIDogW10sIEggPSBrLmxlbmd0aDtcbiAgICAgICAgSCA9PT0gMCB8fCAhZS5vcHRpb25zLmtlZXBEcmFnZ2luZyA/IGUuZmxhZyA9ICExIDogZS5fYWRkU3RvcmUobmV3IFd0KGspKTtcbiAgICAgICAgdmFyIFYgPSBlLl9nZXRQb3NpdGlvbigpLCBDID0gbWUoKSwgUCA9ICFXICYmIGUuZG91YmxlRmxhZztcbiAgICAgICAgZS5fcHJldklucHV0RXZlbnQgPSBudWxsLCBlLnByZXZUaW1lID0gVyB8fCBQID8gMCA6IEMsIGUuZmxhZyB8fCAoZS5fZGV0dGFjaERyYWdFdmVudCgpLCBlLl9wcmV2ZW50TW91c2VFdmVudCB8fCBlLmVtaXQoXCJkcmFnRW5kXCIsIE0oeyBkYXRhOiBlLmRhdGEsIGRhdGFzOiBlLmRhdGEsIGlzRG91YmxlOiBQLCBpc0RyYWc6IFcsIGlzQ2xpY2s6ICFXLCBpc01vdXNlRXZlbnQ6IGUuX2lzTW91c2VFdmVudCwgaXNTZWNvbmRhcnlCdXR0b246IGUuX2lzU2Vjb25kYXJ5QnV0dG9uLCBpbnB1dEV2ZW50OiBjLCBpc1RydXN0ZWQ6IGUuX2lzVHJ1c3RlZCB9LCBWKSksIGUuY2xpZW50U3RvcmVzID0gW10sIGUuX2lzTW91c2VFdmVudCB8fCAoZS5fcHJldmVudE1vdXNlRXZlbnQgPSAhMCwgY2xlYXJUaW1lb3V0KGUuX3ByZXZlbnRNb3VzZUV2ZW50SWQpLCBlLl9wcmV2ZW50TW91c2VFdmVudElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBlLl9wcmV2ZW50TW91c2VFdmVudCA9ICExO1xuICAgICAgICB9LCAyMDApKSwgZS5faXNJZGxlID0gITApO1xuICAgICAgfVxuICAgIH0sIGUub25CbHVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBlLm9uRHJhZ0VuZCgpO1xuICAgIH0sIGUuX2FsbG93Q2xpY2tFdmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgWShlLl93aW5kb3csIFwiY2xpY2tcIiwgZS5fb25DbGljaywgITApO1xuICAgIH0sIGUuX29uQ2xpY2sgPSBmdW5jdGlvbihjKSB7XG4gICAgICBlLl9hbGxvd0NsaWNrRXZlbnQoKSwgZS5fYWxsb3dNb3VzZUV2ZW50KCk7XG4gICAgICB2YXIgbSA9IGUub3B0aW9ucy5wcmV2ZW50Q2xpY2tFdmVudEJ5Q29uZGl0aW9uO1xuICAgICAgbSAhPSBudWxsICYmIG0oYykgfHwgKGMuc3RvcFByb3BhZ2F0aW9uKCksIGMucHJldmVudERlZmF1bHQoKSk7XG4gICAgfSwgZS5fb25Db250ZXh0TWVudSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBtID0gZS5vcHRpb25zO1xuICAgICAgbS5wcmV2ZW50UmlnaHRDbGljayA/IGUub25EcmFnRW5kKGMpIDogYy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIGUuX3Bhc3NDYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gICAgdmFyIG8gPSBbXS5jb25jYXQodCksIGEgPSBvWzBdO1xuICAgIGUuX3dpbmRvdyA9IEJyKGEpID8gYSA6IG90KGEpLCBlLm9wdGlvbnMgPSBNKHsgY2hlY2tJbnB1dDogITEsIGNvbnRhaW5lcjogYSAmJiAhKFwiZG9jdW1lbnRcIiBpbiBhKSA/IG90KGEpIDogYSwgcHJldmVudFJpZ2h0Q2xpY2s6ICEwLCBwcmV2ZW50V2hlZWxDbGljazogITAsIHByZXZlbnRDbGlja0V2ZW50T25EcmFnU3RhcnQ6ICExLCBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZzogITEsIHByZXZlbnRDbGlja0V2ZW50QnlDb25kaXRpb246IG51bGwsIHByZXZlbnREZWZhdWx0OiAhMCwgY2hlY2tXaW5kb3dCbHVyOiAhMSwga2VlcERyYWdnaW5nOiAhMSwgcGluY2hUaHJlc2hvbGQ6IDAsIGV2ZW50czogW1widG91Y2hcIiwgXCJtb3VzZVwiXSB9LCByKTtcbiAgICB2YXIgbCA9IGUub3B0aW9ucywgaCA9IGwuY29udGFpbmVyLCB1ID0gbC5ldmVudHMsIGQgPSBsLmNoZWNrV2luZG93Qmx1cjtcbiAgICBpZiAoZS5fdXNlRHJhZyA9IHUuaW5kZXhPZihcImRyYWdcIikgPiAtMSwgZS5fdXNlVG91Y2ggPSB1LmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xLCBlLl91c2VNb3VzZSA9IHUuaW5kZXhPZihcIm1vdXNlXCIpID4gLTEsIGUudGFyZ2V0cyA9IG8sIGUuX3VzZURyYWcgJiYgby5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgIE8oYywgXCJkcmFnc3RhcnRcIiwgZS5vbkRyYWdTdGFydCk7XG4gICAgfSksIGUuX3VzZU1vdXNlICYmIChvLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgTyhjLCBcIm1vdXNlZG93blwiLCBlLm9uRHJhZ1N0YXJ0KSwgTyhjLCBcIm1vdXNlbW92ZVwiLCBlLl9wYXNzQ2FsbGJhY2spO1xuICAgIH0pLCBPKGgsIFwiY29udGV4dG1lbnVcIiwgZS5fb25Db250ZXh0TWVudSkpLCBkICYmIE8ob3QoKSwgXCJibHVyXCIsIGUub25CbHVyKSwgZS5fdXNlVG91Y2gpIHtcbiAgICAgIHZhciB2ID0ge1xuICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgfTtcbiAgICAgIG8uZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICAgIE8oYywgXCJ0b3VjaHN0YXJ0XCIsIGUub25EcmFnU3RhcnQsIHYpLCBPKGMsIFwidG91Y2htb3ZlXCIsIGUuX3Bhc3NDYWxsYmFjaywgdik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgcmV0dXJuIG4ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzRHJhZyA9ICExLCB0aGlzLmRhdGEgPSB7fSwgdGhpcy5jbGllbnRTdG9yZXMgPSBbXSwgdGhpcy5waW5jaEZsYWcgPSAhMSwgdGhpcy5kb3VibGVGbGFnID0gITEsIHRoaXMucHJldlRpbWUgPSAwLCB0aGlzLmZsYWcgPSAhMSwgdGhpcy5faXNJZGxlID0gITAsIHRoaXMuX2FsbG93Q2xpY2tFdmVudCgpLCB0aGlzLl9kZXR0YWNoRHJhZ0V2ZW50KCksIHRoaXMuX2lzRHJhZ0FQSSA9ICExO1xuICB9LCBuLnByb3RvdHlwZS5nZXRNb3ZlbWVudCA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50U3RvcmUoKS5nZXRNb3ZlbWVudCh0KSArIHRoaXMuY2xpZW50U3RvcmVzLnNsaWNlKDEpLnJlZHVjZShmdW5jdGlvbihyLCBlKSB7XG4gICAgICByZXR1cm4gciArIGUubW92ZW1lbnQ7XG4gICAgfSwgMCk7XG4gIH0sIG4ucHJvdG90eXBlLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0RyYWc7XG4gIH0sIG4ucHJvdG90eXBlLmlzSWRsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0lkbGU7XG4gIH0sIG4ucHJvdG90eXBlLmlzRmxhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZsYWc7XG4gIH0sIG4ucHJvdG90eXBlLmlzUGluY2hGbGFnID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGluY2hGbGFnO1xuICB9LCBuLnByb3RvdHlwZS5pc0RvdWJsZUZsYWcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kb3VibGVGbGFnO1xuICB9LCBuLnByb3RvdHlwZS5pc1BpbmNoaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQaW5jaDtcbiAgfSwgbi5wcm90b3R5cGUuc2Nyb2xsQnkgPSBmdW5jdGlvbih0LCByLCBlLCBvKSB7XG4gICAgbyA9PT0gdm9pZCAwICYmIChvID0gITApLCB0aGlzLmZsYWcgJiYgKHRoaXMuY2xpZW50U3RvcmVzWzBdLm1vdmUodCwgciksIG8gJiYgdGhpcy5vbkRyYWcoZSwgITApKTtcbiAgfSwgbi5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHQsIHIpIHtcbiAgICB2YXIgZSA9IHRbMF0sIG8gPSB0WzFdLCBhID0gdGhpcy5nZXRDdXJyZW50U3RvcmUoKSwgbCA9IGEucHJldkNsaWVudHM7XG4gICAgcmV0dXJuIHRoaXMubW92ZUNsaWVudHMobC5tYXAoZnVuY3Rpb24oaCkge1xuICAgICAgdmFyIHUgPSBoLmNsaWVudFgsIGQgPSBoLmNsaWVudFk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRYOiB1ICsgZSxcbiAgICAgICAgY2xpZW50WTogZCArIG8sXG4gICAgICAgIG9yaWdpbmFsQ2xpZW50WDogdSxcbiAgICAgICAgb3JpZ2luYWxDbGllbnRZOiBkXG4gICAgICB9O1xuICAgIH0pLCByLCAhMCk7XG4gIH0sIG4ucHJvdG90eXBlLnRyaWdnZXJEcmFnU3RhcnQgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5vbkRyYWdTdGFydCh0LCAhMSk7XG4gIH0sIG4ucHJvdG90eXBlLnNldEV2ZW50RGF0YSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgciA9IHRoaXMuZGF0YTtcbiAgICBmb3IgKHZhciBlIGluIHQpXG4gICAgICByW2VdID0gdFtlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSwgbi5wcm90b3R5cGUuc2V0RXZlbnREYXRhcyA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRFdmVudERhdGEodCk7XG4gIH0sIG4ucHJvdG90eXBlLmdldEN1cnJlbnRFdmVudCA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gdm9pZCAwICYmICh0ID0gdGhpcy5fcHJldklucHV0RXZlbnQpLCBNKE0oeyBkYXRhOiB0aGlzLmRhdGEsIGRhdGFzOiB0aGlzLmRhdGEgfSwgdGhpcy5fZ2V0UG9zaXRpb24oKSksIHsgbW92ZW1lbnQ6IHRoaXMuZ2V0TW92ZW1lbnQoKSwgaXNEcmFnOiB0aGlzLmlzRHJhZywgaXNQaW5jaDogdGhpcy5pc1BpbmNoLCBpc1Njcm9sbDogITEsIGlucHV0RXZlbnQ6IHQgfSk7XG4gIH0sIG4ucHJvdG90eXBlLmdldEV2ZW50RGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH0sIG4ucHJvdG90eXBlLmdldEV2ZW50RGF0YXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9LCBuLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gdGhpcywgciA9IHRoaXMudGFyZ2V0cywgZSA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5vZmYoKSwgWSh0aGlzLl93aW5kb3csIFwiYmx1clwiLCB0aGlzLm9uQmx1ciksIHRoaXMuX3VzZURyYWcgJiYgci5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIFkobywgXCJkcmFnc3RhcnRcIiwgdC5vbkRyYWdTdGFydCk7XG4gICAgfSksIHRoaXMuX3VzZU1vdXNlICYmIChyLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgICAgWShvLCBcIm1vdXNlZG93blwiLCB0Lm9uRHJhZ1N0YXJ0KTtcbiAgICB9KSwgWShlLCBcImNvbnRleHRtZW51XCIsIHRoaXMuX29uQ29udGV4dE1lbnUpKSwgdGhpcy5fdXNlVG91Y2ggJiYgKHIuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgICBZKG8sIFwidG91Y2hzdGFydFwiLCB0Lm9uRHJhZ1N0YXJ0KTtcbiAgICB9KSwgWShlLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5vbkRyYWdTdGFydCkpLCB0aGlzLl9wcmV2SW5wdXRFdmVudCA9IG51bGwsIHRoaXMuX2FsbG93Q2xpY2tFdmVudCgpLCB0aGlzLl9kZXR0YWNoRHJhZ0V2ZW50KCk7XG4gIH0sIG4ucHJvdG90eXBlLm9uUGluY2hTdGFydCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgciA9IHRoaXMsIGUgPSB0aGlzLm9wdGlvbnMucGluY2hUaHJlc2hvbGQ7XG4gICAgaWYgKCEodGhpcy5pc0RyYWcgJiYgdGhpcy5nZXRNb3ZlbWVudCgpID4gZSkpIHtcbiAgICAgIHZhciBvID0gbmV3IFd0KEN0KHQpKTtcbiAgICAgIHRoaXMucGluY2hGbGFnID0gITAsIHRoaXMuX2FkZFN0b3JlKG8pO1xuICAgICAgdmFyIGEgPSB0aGlzLmVtaXQoXCJwaW5jaFN0YXJ0XCIsIE0oTSh7IGRhdGE6IHRoaXMuZGF0YSwgZGF0YXM6IHRoaXMuZGF0YSwgYW5nbGU6IG8uZ2V0QW5nbGUoKSwgdG91Y2hlczogdGhpcy5nZXRDdXJyZW50U3RvcmUoKS5nZXRQb3NpdGlvbnMoKSB9LCBvLmdldFBvc2l0aW9uKCkpLCB7IGlucHV0RXZlbnQ6IHQsIGlzVHJ1c3RlZDogdGhpcy5faXNUcnVzdGVkLCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sIHByZXZlbnREcmFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgci5fZHJhZ0ZsYWcgPSAhMTtcbiAgICAgIH0gfSkpO1xuICAgICAgYSA9PT0gITEgJiYgKHRoaXMucGluY2hGbGFnID0gITEpO1xuICAgIH1cbiAgfSwgbi5wcm90b3R5cGUub25QaW5jaCA9IGZ1bmN0aW9uKHQsIHIpIHtcbiAgICBpZiAoISghdGhpcy5mbGFnIHx8ICF0aGlzLnBpbmNoRmxhZyB8fCByLmxlbmd0aCA8IDIpKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuZ2V0Q3VycmVudFN0b3JlKCk7XG4gICAgICB0aGlzLmlzUGluY2ggPSAhMCwgdGhpcy5lbWl0KFwicGluY2hcIiwgTShNKHsgZGF0YTogdGhpcy5kYXRhLCBkYXRhczogdGhpcy5kYXRhLCBtb3ZlbWVudDogdGhpcy5nZXRNb3ZlbWVudChyKSwgYW5nbGU6IGUuZ2V0QW5nbGUociksIHJvdGF0aW9uOiBlLmdldFJvdGF0aW9uKHIpLCB0b3VjaGVzOiBlLmdldFBvc2l0aW9ucyhyKSwgc2NhbGU6IGUuZ2V0U2NhbGUociksIGRpc3RhbmNlOiBlLmdldERpc3RhbmNlKHIpIH0sIGUuZ2V0UG9zaXRpb24ocikpLCB7IGlucHV0RXZlbnQ6IHQsIGlzVHJ1c3RlZDogdGhpcy5faXNUcnVzdGVkIH0pKTtcbiAgICB9XG4gIH0sIG4ucHJvdG90eXBlLm9uUGluY2hFbmQgPSBmdW5jdGlvbih0KSB7XG4gICAgaWYgKHRoaXMucGluY2hGbGFnKSB7XG4gICAgICB2YXIgciA9IHRoaXMuaXNQaW5jaDtcbiAgICAgIHRoaXMuaXNQaW5jaCA9ICExLCB0aGlzLnBpbmNoRmxhZyA9ICExO1xuICAgICAgdmFyIGUgPSB0aGlzLmdldEN1cnJlbnRTdG9yZSgpO1xuICAgICAgdGhpcy5lbWl0KFwicGluY2hFbmRcIiwgTShNKHsgZGF0YTogdGhpcy5kYXRhLCBkYXRhczogdGhpcy5kYXRhLCBpc1BpbmNoOiByLCB0b3VjaGVzOiBlLmdldFBvc2l0aW9ucygpIH0sIGUuZ2V0UG9zaXRpb24oKSksIHsgaW5wdXRFdmVudDogdCB9KSk7XG4gICAgfVxuICB9LCBuLnByb3RvdHlwZS5nZXRDdXJyZW50U3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRTdG9yZXNbMF07XG4gIH0sIG4ucHJvdG90eXBlLm1vdmVDbGllbnRzID0gZnVuY3Rpb24odCwgciwgZSkge1xuICAgIHZhciBvID0gdGhpcy5fZ2V0UG9zaXRpb24odCwgZSksIGEgPSB0aGlzLmlzRHJhZztcbiAgICAoby5kZWx0YVggfHwgby5kZWx0YVkpICYmICh0aGlzLmlzRHJhZyA9ICEwKTtcbiAgICB2YXIgbCA9ICExO1xuICAgIHJldHVybiAhYSAmJiB0aGlzLmlzRHJhZyAmJiAobCA9ICEwKSwgTShNKHsgZGF0YTogdGhpcy5kYXRhLCBkYXRhczogdGhpcy5kYXRhIH0sIG8pLCB7IG1vdmVtZW50OiB0aGlzLmdldE1vdmVtZW50KHQpLCBpc0RyYWc6IHRoaXMuaXNEcmFnLCBpc1BpbmNoOiB0aGlzLmlzUGluY2gsIGlzU2Nyb2xsOiAhMSwgaXNNb3VzZUV2ZW50OiB0aGlzLl9pc01vdXNlRXZlbnQsIGlzU2Vjb25kYXJ5QnV0dG9uOiB0aGlzLl9pc1NlY29uZGFyeUJ1dHRvbiwgaW5wdXRFdmVudDogciwgaXNUcnVzdGVkOiB0aGlzLl9pc1RydXN0ZWQsIGlzRmlyc3REcmFnOiBsIH0pO1xuICB9LCBuLnByb3RvdHlwZS5fYWRkU3RvcmUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5jbGllbnRTdG9yZXMuc3BsaWNlKDAsIDAsIHQpO1xuICB9LCBuLnByb3RvdHlwZS5fZ2V0UG9zaXRpb24gPSBmdW5jdGlvbih0LCByKSB7XG4gICAgdmFyIGUgPSB0aGlzLmdldEN1cnJlbnRTdG9yZSgpLCBvID0gZS5nZXRQb3NpdGlvbih0LCByKSwgYSA9IHRoaXMuY2xpZW50U3RvcmVzLnNsaWNlKDEpLnJlZHVjZShmdW5jdGlvbih1LCBkKSB7XG4gICAgICB2YXIgdiA9IGQuZ2V0UG9zaXRpb24oKTtcbiAgICAgIHJldHVybiB1LmRpc3RYICs9IHYuZGlzdFgsIHUuZGlzdFkgKz0gdi5kaXN0WSwgdTtcbiAgICB9LCBvKSwgbCA9IGEuZGlzdFgsIGggPSBhLmRpc3RZO1xuICAgIHJldHVybiBNKE0oe30sIG8pLCB7IGRpc3RYOiBsLCBkaXN0WTogaCB9KTtcbiAgfSwgbi5wcm90b3R5cGUuX2F0dGNoRHJhZ0V2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSB0aGlzLl93aW5kb3csIHIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyLCBlID0ge1xuICAgICAgcGFzc2l2ZTogITFcbiAgICB9O1xuICAgIHRoaXMuX2lzRHJhZ0FQSSAmJiAoTyhyLCBcImRyYWdvdmVyXCIsIHRoaXMub25EcmFnLCBlKSwgTyh0LCBcImRyYWdlbmRcIiwgdGhpcy5vbkRyYWdFbmQpKSwgdGhpcy5fdXNlTW91c2UgJiYgKE8ociwgXCJtb3VzZW1vdmVcIiwgdGhpcy5vbkRyYWcpLCBPKHQsIFwibW91c2V1cFwiLCB0aGlzLm9uRHJhZ0VuZCkpLCB0aGlzLl91c2VUb3VjaCAmJiAoTyhyLCBcInRvdWNobW92ZVwiLCB0aGlzLm9uRHJhZywgZSksIE8odCwgXCJ0b3VjaGVuZFwiLCB0aGlzLm9uRHJhZ0VuZCwgZSksIE8odCwgXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLm9uRHJhZ0VuZCwgZSkpO1xuICB9LCBuLnByb3RvdHlwZS5fZGV0dGFjaERyYWdFdmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gdGhpcy5fd2luZG93LCByID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB0aGlzLl9pc0RyYWdBUEkgJiYgKFkociwgXCJkcmFnb3ZlclwiLCB0aGlzLm9uRHJhZyksIFkodCwgXCJkcmFnZW5kXCIsIHRoaXMub25EcmFnRW5kKSksIHRoaXMuX3VzZU1vdXNlICYmIChZKHIsIFwibW91c2Vtb3ZlXCIsIHRoaXMub25EcmFnKSwgWSh0LCBcIm1vdXNldXBcIiwgdGhpcy5vbkRyYWdFbmQpKSwgdGhpcy5fdXNlVG91Y2ggJiYgKFkociwgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMub25EcmFnU3RhcnQpLCBZKHIsIFwidG91Y2htb3ZlXCIsIHRoaXMub25EcmFnKSwgWSh0LCBcInRvdWNoZW5kXCIsIHRoaXMub25EcmFnRW5kKSwgWSh0LCBcInRvdWNoY2FuY2VsXCIsIHRoaXMub25EcmFnRW5kKSk7XG4gIH0sIG4ucHJvdG90eXBlLl9hbGxvd01vdXNlRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wcmV2ZW50TW91c2VFdmVudCA9ICExLCBjbGVhclRpbWVvdXQodGhpcy5fcHJldmVudE1vdXNlRXZlbnRJZCk7XG4gIH0sIG47XG59KFp0KTtcbmZ1bmN0aW9uIEdyKGkpIHtcbiAgZm9yICh2YXIgbiA9IDUzODEsIHQgPSBpLmxlbmd0aDsgdDsgKVxuICAgIG4gPSBuICogMzMgXiBpLmNoYXJDb2RlQXQoLS10KTtcbiAgcmV0dXJuIG4gPj4+IDA7XG59XG52YXIgS3IgPSBHcjtcbmZ1bmN0aW9uIEpyKGkpIHtcbiAgcmV0dXJuIEtyKGkpLnRvU3RyaW5nKDM2KTtcbn1cbmZ1bmN0aW9uIFFyKGkpIHtcbiAgaWYgKGkgJiYgaS5nZXRSb290Tm9kZSkge1xuICAgIHZhciBuID0gaS5nZXRSb290Tm9kZSgpO1xuICAgIGlmIChuLm5vZGVUeXBlID09PSAxMSlcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5mdW5jdGlvbiB0bihpLCBuLCB0KSB7XG4gIHJldHVybiB0Lm9yaWdpbmFsID8gbiA6IG4ucmVwbGFjZSgvKFtefTt7XFxzfV1bXn07e10qfF5cXHMqKXsvbWcsIGZ1bmN0aW9uKHIsIGUpIHtcbiAgICB2YXIgbyA9IGUudHJpbSgpO1xuICAgIHJldHVybiAobyA/IGpyKG8pIDogW1wiXCJdKS5tYXAoZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGwgPSBhLnRyaW0oKTtcbiAgICAgIHJldHVybiBsLmluZGV4T2YoXCJAXCIpID09PSAwID8gbCA6IGwuaW5kZXhPZihcIjpnbG9iYWxcIikgPiAtMSA/IGwucmVwbGFjZSgvXFw6Z2xvYmFsL2csIFwiXCIpIDogbC5pbmRleE9mKFwiOmhvc3RcIikgPiAtMSA/IFwiXCIuY29uY2F0KGwucmVwbGFjZSgvXFw6aG9zdC9nLCBcIi5cIi5jb25jYXQoaSkpKSA6IGwgPyBcIi5cIi5jb25jYXQoaSwgXCIgXCIpLmNvbmNhdChsKSA6IFwiLlwiLmNvbmNhdChpKTtcbiAgICB9KS5qb2luKFwiLCBcIikgKyBcIiB7XCI7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW4oaSwgbiwgdCwgciwgZSkge1xuICB2YXIgbyA9IE50KHIpLCBhID0gby5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHJldHVybiBhLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2Nzc1wiKSwgYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlZC1pZFwiLCBpKSwgYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlZC1jb3VudFwiLCBcIjFcIiksIHQubm9uY2UgJiYgYS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCB0Lm5vbmNlKSwgYS5pbm5lckhUTUwgPSB0bihpLCBuLCB0KSwgKGUgfHwgby5oZWFkIHx8IG8uYm9keSkuYXBwZW5kQ2hpbGQoYSksIGE7XG59XG5mdW5jdGlvbiBybihpKSB7XG4gIHZhciBuID0gXCJyQ1NcIiArIEpyKGkpO1xuICByZXR1cm4ge1xuICAgIGNsYXNzTmFtZTogbixcbiAgICBpbmplY3Q6IGZ1bmN0aW9uKHQsIHIpIHtcbiAgICAgIHIgPT09IHZvaWQgMCAmJiAociA9IHt9KTtcbiAgICAgIHZhciBlID0gUXIodCksIG8gPSAoZSB8fCB0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtc3R5bGVkLWlkPVwiJy5jb25jYXQobiwgJ1wiXScpKTtcbiAgICAgIGlmICghbylcbiAgICAgICAgbyA9IGVuKG4sIGksIHIsIHQsIGUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBhID0gcGFyc2VGbG9hdChvLmdldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVkLWNvdW50XCIpKSB8fCAwO1xuICAgICAgICBvLnNldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVkLWNvdW50XCIsIFwiXCIuY29uY2F0KGEgKyAxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbCwgaCA9IHBhcnNlRmxvYXQoby5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlZC1jb3VudFwiKSkgfHwgMDtcbiAgICAgICAgICBoIDw9IDEgPyAoby5yZW1vdmUgPyBvLnJlbW92ZSgpIDogKGwgPSBvLnBhcmVudE5vZGUpID09PSBudWxsIHx8IGwgPT09IHZvaWQgMCB8fCBsLnJlbW92ZUNoaWxkKG8pLCBvID0gbnVsbCkgOiBvLnNldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVkLWNvdW50XCIsIFwiXCIuY29uY2F0KGggLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gVXQoaSwgbikge1xuICBmb3IgKHZhciB0ID0gaS5sZW5ndGgsIHIgPSAwOyByIDwgdDsgKytyKVxuICAgIGlmIChuKGlbcl0sIHIpKVxuICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBMZShpLCBuKSB7XG4gIGZvciAodmFyIHQgPSBpLmxlbmd0aCwgciA9IDA7IHIgPCB0OyArK3IpXG4gICAgaWYgKG4oaVtyXSwgcikpXG4gICAgICByZXR1cm4gaVtyXTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBGZShpKSB7XG4gIHZhciBuID0gaTtcbiAgaWYgKHR5cGVvZiBuID4gXCJ1XCIpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA+IFwidVwiIHx8ICFuYXZpZ2F0b3IpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBuID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiO1xuICB9XG4gIHJldHVybiBuLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBxdChpLCBuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoaSwgXCJnXCIpLmV4ZWMobik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBubigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPiBcInVcIiB8fCAhbmF2aWdhdG9yIHx8ICFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSlcbiAgICByZXR1cm4gITE7XG4gIHZhciBpID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEsIG4gPSBpLmJyYW5kcyB8fCBpLnVhTGlzdDtcbiAgcmV0dXJuICEhKG4gJiYgbi5sZW5ndGgpO1xufVxuZnVuY3Rpb24gb24oaSwgbikge1xuICB2YXIgdCA9IHF0KFwiKFwiICsgaSArIFwiKSgoPzpcXFxcL3xcXFxcc3w6KShbMC05fFxcXFwufF9dKykpXCIsIG4pO1xuICByZXR1cm4gdCA/IHRbM10gOiBcIlwiO1xufVxuZnVuY3Rpb24gJHQoaSkge1xuICByZXR1cm4gaS5yZXBsYWNlKC9fL2csIFwiLlwiKTtcbn1cbmZ1bmN0aW9uIHB0KGksIG4pIHtcbiAgdmFyIHQgPSBudWxsLCByID0gXCItMVwiO1xuICByZXR1cm4gVXQoaSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBvID0gcXQoXCIoXCIgKyBlLnRlc3QgKyBcIikoKD86XFxcXC98XFxcXHN8OikoWzAtOXxcXFxcLnxfXSspKT9cIiwgbik7XG4gICAgcmV0dXJuICFvIHx8IGUuYnJhbmQgPyAhMSA6ICh0ID0gZSwgciA9IG9bM10gfHwgXCItMVwiLCBlLnZlcnNpb25BbGlhcyA/IHIgPSBlLnZlcnNpb25BbGlhcyA6IGUudmVyc2lvblRlc3QgJiYgKHIgPSBvbihlLnZlcnNpb25UZXN0LnRvTG93ZXJDYXNlKCksIG4pIHx8IHIpLCByID0gJHQociksICEwKTtcbiAgfSksIHtcbiAgICBwcmVzZXQ6IHQsXG4gICAgdmVyc2lvbjogclxuICB9O1xufVxuZnVuY3Rpb24gVHQoaSwgbikge1xuICB2YXIgdCA9IHtcbiAgICBicmFuZDogXCJcIixcbiAgICB2ZXJzaW9uOiBcIi0xXCJcbiAgfTtcbiAgcmV0dXJuIFV0KGksIGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgZSA9IGplKG4sIHIpO1xuICAgIHJldHVybiBlID8gKHQuYnJhbmQgPSByLmlkLCB0LnZlcnNpb24gPSByLnZlcnNpb25BbGlhcyB8fCBlLnZlcnNpb24sIHQudmVyc2lvbiAhPT0gXCItMVwiKSA6ICExO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIGplKGksIG4pIHtcbiAgcmV0dXJuIExlKGksIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgciA9IHQuYnJhbmQ7XG4gICAgcmV0dXJuIHF0KFwiXCIgKyBuLnRlc3QsIHIudG9Mb3dlckNhc2UoKSk7XG4gIH0pO1xufVxudmFyIEllID0gW3tcbiAgdGVzdDogXCJwaGFudG9tanNcIixcbiAgaWQ6IFwicGhhbnRvbWpzXCJcbn0sIHtcbiAgdGVzdDogXCJ3aGFsZVwiLFxuICBpZDogXCJ3aGFsZVwiXG59LCB7XG4gIHRlc3Q6IFwiZWRnaW9zfGVkZ2V8ZWRnXCIsXG4gIGlkOiBcImVkZ2VcIlxufSwge1xuICB0ZXN0OiBcIm1zaWV8dHJpZGVudHx3aW5kb3dzIHBob25lXCIsXG4gIGlkOiBcImllXCIsXG4gIHZlcnNpb25UZXN0OiBcImllbW9iaWxlfG1zaWV8cnZcIlxufSwge1xuICB0ZXN0OiBcIm1pdWlicm93c2VyXCIsXG4gIGlkOiBcIm1pdWkgYnJvd3NlclwiXG59LCB7XG4gIHRlc3Q6IFwic2Ftc3VuZ2Jyb3dzZXJcIixcbiAgaWQ6IFwic2Ftc3VuZyBpbnRlcm5ldFwiXG59LCB7XG4gIHRlc3Q6IFwic2Ftc3VuZ1wiLFxuICBpZDogXCJzYW1zdW5nIGludGVybmV0XCIsXG4gIHZlcnNpb25UZXN0OiBcInZlcnNpb25cIlxufSwge1xuICB0ZXN0OiBcImNocm9tZXxjcmlvc1wiLFxuICBpZDogXCJjaHJvbWVcIlxufSwge1xuICB0ZXN0OiBcImZpcmVmb3h8Znhpb3NcIixcbiAgaWQ6IFwiZmlyZWZveFwiXG59LCB7XG4gIHRlc3Q6IFwiYW5kcm9pZFwiLFxuICBpZDogXCJhbmRyb2lkIGJyb3dzZXJcIixcbiAgdmVyc2lvblRlc3Q6IFwidmVyc2lvblwiXG59LCB7XG4gIHRlc3Q6IFwic2FmYXJpfGlwaG9uZXxpcGFkfGlwb2RcIixcbiAgaWQ6IFwic2FmYXJpXCIsXG4gIHZlcnNpb25UZXN0OiBcInZlcnNpb25cIlxufV0sICRlID0gW3tcbiAgdGVzdDogXCIoPz0uKmFwcGxld2Via2l0Lyg1M1swLTddfDVbMC0yXXxbMC00XSkpKD89LipcXFxcc2Nocm9tZSlcIixcbiAgaWQ6IFwiY2hyb21lXCIsXG4gIHZlcnNpb25UZXN0OiBcImNocm9tZVwiXG59LCB7XG4gIHRlc3Q6IFwiY2hyb21pdW1cIixcbiAgaWQ6IFwiY2hyb21lXCJcbn0sIHtcbiAgdGVzdDogXCJ3aGFsZVwiLFxuICBpZDogXCJjaHJvbWVcIixcbiAgdmVyc2lvbkFsaWFzOiBcIi0xXCIsXG4gIGJyYW5kOiAhMFxufV0sIEJ0ID0gW3tcbiAgdGVzdDogXCJhcHBsZXdlYmtpdFwiLFxuICBpZDogXCJ3ZWJraXRcIixcbiAgdmVyc2lvblRlc3Q6IFwiYXBwbGV3ZWJraXR8c2FmYXJpXCJcbn1dLCBCZSA9IFt7XG4gIHRlc3Q6IFwiKD89KGlwaG9uZXxpcGFkKSkoPyEoLip2ZXJzaW9uKSlcIixcbiAgaWQ6IFwid2Vidmlld1wiXG59LCB7XG4gIHRlc3Q6IFwiKD89KGFuZHJvaWR8aXBob25lfGlwYWQpKSg/PS4qKG5hdmVyfGRhdW18OyB3dikpXCIsXG4gIGlkOiBcIndlYnZpZXdcIlxufSwge1xuICAvLyB0ZXN0IHdlYnZpZXdcbiAgdGVzdDogXCJ3ZWJ2aWV3XCIsXG4gIGlkOiBcIndlYnZpZXdcIlxufV0sIEhlID0gW3tcbiAgdGVzdDogXCJ3aW5kb3dzIHBob25lXCIsXG4gIGlkOiBcIndpbmRvd3MgcGhvbmVcIlxufSwge1xuICB0ZXN0OiBcIndpbmRvd3MgMjAwMFwiLFxuICBpZDogXCJ3aW5kb3dcIixcbiAgdmVyc2lvbkFsaWFzOiBcIjUuMFwiXG59LCB7XG4gIHRlc3Q6IFwid2luZG93cyBudFwiLFxuICBpZDogXCJ3aW5kb3dcIlxufSwge1xuICB0ZXN0OiBcIndpbjMyfHdpbmRvd3NcIixcbiAgaWQ6IFwid2luZG93XCJcbn0sIHtcbiAgdGVzdDogXCJpcGhvbmV8aXBhZHxpcG9kXCIsXG4gIGlkOiBcImlvc1wiLFxuICB2ZXJzaW9uVGVzdDogXCJpcGhvbmUgb3N8Y3B1IG9zXCJcbn0sIHtcbiAgdGVzdDogXCJtYWNvc3xtYWNpbnRlbHxtYWMgb3MgeFwiLFxuICBpZDogXCJtYWNcIlxufSwge1xuICB0ZXN0OiBcImFuZHJvaWR8bGludXggYXJtdjgxXCIsXG4gIGlkOiBcImFuZHJvaWRcIlxufSwge1xuICB0ZXN0OiBcInRpemVuXCIsXG4gIGlkOiBcInRpemVuXCJcbn0sIHtcbiAgdGVzdDogXCJ3ZWJvc3x3ZWIwc1wiLFxuICBpZDogXCJ3ZWJvc1wiXG59XTtcbmZ1bmN0aW9uIFZlKGkpIHtcbiAgcmV0dXJuICEhcHQoQmUsIGkpLnByZXNldDtcbn1cbmZ1bmN0aW9uIHNuKGkpIHtcbiAgdmFyIG4gPSBGZShpKSwgdCA9ICEhL21vYmkvZy5leGVjKG4pLCByID0ge1xuICAgIG5hbWU6IFwidW5rbm93blwiLFxuICAgIHZlcnNpb246IFwiLTFcIixcbiAgICBtYWpvclZlcnNpb246IC0xLFxuICAgIHdlYnZpZXc6IFZlKG4pLFxuICAgIGNocm9taXVtOiAhMSxcbiAgICBjaHJvbWl1bVZlcnNpb246IFwiLTFcIixcbiAgICB3ZWJraXQ6ICExLFxuICAgIHdlYmtpdFZlcnNpb246IFwiLTFcIlxuICB9LCBlID0ge1xuICAgIG5hbWU6IFwidW5rbm93blwiLFxuICAgIHZlcnNpb246IFwiLTFcIixcbiAgICBtYWpvclZlcnNpb246IC0xXG4gIH0sIG8gPSBwdChJZSwgbiksIGEgPSBvLnByZXNldCwgbCA9IG8udmVyc2lvbiwgaCA9IHB0KEhlLCBuKSwgdSA9IGgucHJlc2V0LCBkID0gaC52ZXJzaW9uLCB2ID0gcHQoJGUsIG4pO1xuICBpZiAoci5jaHJvbWl1bSA9ICEhdi5wcmVzZXQsIHIuY2hyb21pdW1WZXJzaW9uID0gdi52ZXJzaW9uLCAhci5jaHJvbWl1bSkge1xuICAgIHZhciBjID0gcHQoQnQsIG4pO1xuICAgIHIud2Via2l0ID0gISFjLnByZXNldCwgci53ZWJraXRWZXJzaW9uID0gYy52ZXJzaW9uO1xuICB9XG4gIHJldHVybiB1ICYmIChlLm5hbWUgPSB1LmlkLCBlLnZlcnNpb24gPSBkLCBlLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KGQsIDEwKSksIGEgJiYgKHIubmFtZSA9IGEuaWQsIHIudmVyc2lvbiA9IGwsIHIud2VidmlldyAmJiBlLm5hbWUgPT09IFwiaW9zXCIgJiYgci5uYW1lICE9PSBcInNhZmFyaVwiICYmIChyLndlYnZpZXcgPSAhMSkpLCByLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KHIudmVyc2lvbiwgMTApLCB7XG4gICAgYnJvd3NlcjogcixcbiAgICBvczogZSxcbiAgICBpc01vYmlsZTogdCxcbiAgICBpc0hpbnRzOiAhMVxuICB9O1xufVxuZnVuY3Rpb24gYW4oaSkge1xuICB2YXIgbiA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhLCB0ID0gKG4udWFMaXN0IHx8IG4uYnJhbmRzKS5zbGljZSgpLCByID0gbi5tb2JpbGUgfHwgITEsIGUgPSB0WzBdLCBvID0gKG4ucGxhdGZvcm0gfHwgbmF2aWdhdG9yLnBsYXRmb3JtKS50b0xvd2VyQ2FzZSgpLCBhID0ge1xuICAgIG5hbWU6IGUuYnJhbmQsXG4gICAgdmVyc2lvbjogZS52ZXJzaW9uLFxuICAgIG1ham9yVmVyc2lvbjogLTEsXG4gICAgd2Via2l0OiAhMSxcbiAgICB3ZWJraXRWZXJzaW9uOiBcIi0xXCIsXG4gICAgY2hyb21pdW06ICExLFxuICAgIGNocm9taXVtVmVyc2lvbjogXCItMVwiLFxuICAgIHdlYnZpZXc6ICEhVHQoQmUsIHQpLmJyYW5kIHx8IFZlKEZlKCkpXG4gIH0sIGwgPSB7XG4gICAgbmFtZTogXCJ1bmtub3duXCIsXG4gICAgdmVyc2lvbjogXCItMVwiLFxuICAgIG1ham9yVmVyc2lvbjogLTFcbiAgfTtcbiAgYS53ZWJraXQgPSAhYS5jaHJvbWl1bSAmJiBVdChCdCwgZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBqZSh0LCBjKTtcbiAgfSk7XG4gIHZhciBoID0gVHQoJGUsIHQpO1xuICBpZiAoYS5jaHJvbWl1bSA9ICEhaC5icmFuZCwgYS5jaHJvbWl1bVZlcnNpb24gPSBoLnZlcnNpb24gfHwgXCItMVwiLCAhYS5jaHJvbWl1bSkge1xuICAgIHZhciB1ID0gVHQoQnQsIHQpO1xuICAgIGEud2Via2l0ID0gISF1LmJyYW5kLCBhLndlYmtpdFZlcnNpb24gPSB1LnZlcnNpb24gfHwgXCItMVwiO1xuICB9XG4gIHZhciBkID0gTGUoSGUsIGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIlwiICsgYy50ZXN0LCBcImdcIikuZXhlYyhvKTtcbiAgfSk7XG4gIGwubmFtZSA9IGQgPyBkLmlkIDogXCJcIjtcbiAge1xuICAgIHZhciB2ID0gVHQoSWUsIHQpO1xuICAgIGEubmFtZSA9IHYuYnJhbmQgfHwgYS5uYW1lLCBhLnZlcnNpb24gPSB2LmJyYW5kICYmIGkgPyBpLnVhRnVsbFZlcnNpb24gOiB2LnZlcnNpb247XG4gIH1cbiAgcmV0dXJuIGEud2Via2l0ICYmIChsLm5hbWUgPSByID8gXCJpb3NcIiA6IFwibWFjXCIpLCBsLm5hbWUgPT09IFwiaW9zXCIgJiYgYS53ZWJ2aWV3ICYmIChhLnZlcnNpb24gPSBcIi0xXCIpLCBsLnZlcnNpb24gPSAkdChsLnZlcnNpb24pLCBhLnZlcnNpb24gPSAkdChhLnZlcnNpb24pLCBsLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KGwudmVyc2lvbiwgMTApLCBhLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KGEudmVyc2lvbiwgMTApLCB7XG4gICAgYnJvd3NlcjogYSxcbiAgICBvczogbCxcbiAgICBpc01vYmlsZTogcixcbiAgICBpc0hpbnRzOiAhMFxuICB9O1xufVxuZnVuY3Rpb24gbG4oaSkge1xuICByZXR1cm4gbm4oKSA/IGFuKCkgOiBzbihpKTtcbn1cbmZ1bmN0aW9uIGNuKGksIG4pIHtcbiAgcmV0dXJuIG4ucmVwbGFjZSgvKFtefXtdKil7L2dtLCAodCwgcikgPT4gYCR7ci5yZXBsYWNlKC9cXC4oW157LFxcc1xcZC5dKykvZywgYC4ke2l9JDFgKX17YCk7XG59XG5mdW5jdGlvbiBkdChpLCBuKSB7XG4gIHJldHVybiAodCkgPT4ge1xuICAgIHQgJiYgKGlbbl0gPSB0KTtcbiAgfTtcbn1cbmNvbnN0IHVuID0gbG4oKSwgaG4gPSB1bi5icm93c2VyLm5hbWUgPT09IFwic2FmYXJpXCIsIGV0ID0gXCJpbmZpbml0ZS12aWV3ZXItXCIsIHdlID0gYCR7ZXR9d3JhcHBlcmAsIGJlID0gYCR7ZXR9c2Nyb2xsLWFyZWFgLCBmbiA9IGAke2V0fXNjcm9sbC1iYXJgLCBOZSA9IGAke2V0fWhvcml6b250YWwtc2Nyb2xsLWJhcmAsIFplID0gYCR7ZXR9dmVydGljYWwtc2Nyb2xsLWJhcmAsIHllID0gYCR7ZXR9c2Nyb2xsLXRodW1iYCwgVWUgPSBybihcbiAgY24oXG4gICAgZXQsXG4gICAgYFxue1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBvdmVyc2Nyb2xsLWJlaGF2aW9yOiBub25lO1xufVxuLndyYXBwZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgc2Nyb2xsYmFyLXdpZHRoOiBub25lO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpbGwtY2hhbmdlOiBzY3JvbGwtcG9zaXRpb247XG59XG4ucmVzdHJpY3Qtd3JhcHBlciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbn1cbi53cmFwcGVyOjotd2Via2l0LXNjcm9sbGJhciB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cbi5zY3JvbGwtYXJlYSB7XG4gICAgcG9zaXRpb246YWJzb2x1dGU7XG4gICAgdG9wOjA7XG4gICAgbGVmdDowO1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcbn1cbi5zY3JvbGwtYmFyIHtcbiAgICBwb3NpdGlvbjphYnNvbHV0ZTtcbiAgICB3aWR0aDogMTBweDtcbiAgICBoZWlnaHQ6IDEwcHg7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICByaWdodDogMDtcbiAgICBib3R0b206IDA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cbi5ob3Jpem9udGFsLXNjcm9sbC1iYXIge1xuICAgIHdpZHRoOiBjYWxjKDEwMCUgLSAyMHB4KTtcbiAgICByaWdodDogMTBweDtcbiAgICBoZWlnaHQ6IDE0cHg7XG59XG4udmVydGljYWwtc2Nyb2xsLWJhciB7XG4gICAgaGVpZ2h0OiBjYWxjKDEwMCUgLSAyMHB4KTtcbiAgICBib3R0b206IDEwcHg7XG4gICAgd2lkdGg6IDE0cHg7XG59XG4uc2Nyb2xsLXRodW1iIHtcbiAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcbiAgICBvcGFjaXR5OiAwLjc7XG4gICAgYmFja2dyb3VuZDogIzMzMztcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgbGVmdDogMHB4O1xuICAgIHRvcDogMHB4O1xuICAgIHotaW5kZXg6IDEwO1xuICAgIHdpZHRoOiA2cHg7XG4gICAgaGVpZ2h0OiA2cHg7XG4gICAgdHJhbnNpdGlvbjogYWxsIGVhc2UgMC4ycztcbiAgICBvcGFjaXR5OiAwO1xufVxuLnNjcm9sbC1iYXI6aG92ZXIgLnNjcm9sbC10aHVtYiB7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIG9wYWNpdHk6IDE7XG59XG4uaG9yaXpvbnRhbC1zY3JvbGwtYmFyIC5zY3JvbGwtdGh1bWIge1xuICAgIG1hcmdpbjogNHB4IDBweDtcbiAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiBvcGFjaXR5LCBtYXJnaW4sIGhlaWdodCwgYm9yZGVyLXJhZGl1cztcbn1cbi52ZXJ0aWNhbC1zY3JvbGwtYmFyIC5zY3JvbGwtdGh1bWIge1xuICAgIG1hcmdpbjogMHB4IDRweDtcbiAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiBvcGFjaXR5LCBtYXJnaW4sIHdpZHRoLCBib3JkZXItcmFkaXVzO1xufVxuLmhvcml6b250YWwtc2Nyb2xsLWJhcjpob3ZlciAuc2Nyb2xsLXRodW1iIHtcbiAgICBoZWlnaHQ6IDEwcHg7XG4gICAgbWFyZ2luOiAycHggMHB4O1xufVxuLnZlcnRpY2FsLXNjcm9sbC1iYXI6aG92ZXIgLnNjcm9sbC10aHVtYiB7XG4gICAgd2lkdGg6IDEwcHg7XG4gICAgbWFyZ2luOiAwcHggMnB4O1xufVxuYFxuICApXG4pLCBJID0ge1xuICBtYXJnaW46IDUwMCxcbiAgdGhyZXNob2xkOiAxMDAsXG4gIHpvb206IDEsXG4gIHpvb21YOiAxLFxuICB6b29tWTogMSxcbiAgcmFuZ2VYOiBbLTEgLyAwLCAxIC8gMF0sXG4gIHJhbmdlWTogWy0xIC8gMCwgMSAvIDBdLFxuICByYW5nZU9mZnNldFg6IFswLCAwXSxcbiAgcmFuZ2VPZmZzZXRZOiBbMCwgMF0sXG4gIHdyYXBwZXJFbGVtZW50OiBudWxsLFxuICBzY3JvbGxBcmVhRWxlbWVudDogbnVsbCxcbiAgaG9yaXpvbnRhbFNjcm9sbEVsZW1lbnQ6IG51bGwsXG4gIHZlcnRpY2FsU2Nyb2xsRWxlbWVudDogbnVsbCxcbiAgdXNlUGluY2g6ICExLFxuICB1c2VBdXRvWm9vbTogITEsXG4gIHVzZU1vdXNlRHJhZzogITEsXG4gIHBpbmNoVGhyZXNob2xkOiAzMCxcbiAgY3NwTm9uY2U6IFwiXCIsXG4gIG1heFBpbmNoV2hlZWw6IDEgLyAwLFxuICB3aGVlbFNjYWxlOiAwLjAxLFxuICBkaXNwbGF5SG9yaXpvbnRhbFNjcm9sbDogITAsXG4gIGRpc3BsYXlWZXJ0aWNhbFNjcm9sbDogITAsXG4gIHVzZVRyYW5zZm9ybTogITAsXG4gIHVzZVdoZWVsUGluY2g6ICEwLFxuICB6b29tUmFuZ2U6IFsxZS0zLCAxIC8gMF0sXG4gIHdoZWVsUGluY2hLZXk6IFwiY3RybFwiLFxuICB1c2VXaGVlbFNjcm9sbDogaG4sXG4gIHpvb21PZmZzZXRYOiBcIjUwJVwiLFxuICB6b29tT2Zmc2V0WTogXCI1MCVcIixcbiAgdHJhbnNsYXRlWjogMCxcbiAgdXNlR2VzdHVyZTogITAsXG4gIHVzZVJlc2l6ZU9ic2VydmVyOiAhMSxcbiAgcGluY2hEaXJlY3Rpb246IFwiYWxsXCIsXG4gIHByZXZlbnRXaGVlbENsaWNrOiAhMCxcbiAgdXNlQm91bmNlU2Nyb2xsQmFyOiAhMSxcbiAgdXNlT3ZlcmZsb3dTY3JvbGw6ICExXG59LCBDZSA9IChpKSA9PiAxIC0gTWF0aC5wb3coMSAtIGksIDMpLCBUZSA9IHtcbiAgaG9yaXpvbnRhbDoge1xuICAgIHBvczogXCJMZWZ0XCIsXG4gICAgY29vcmQ6IFwiWFwiLFxuICAgIHNpemU6IFwiV2lkdGhcIlxuICB9LFxuICB2ZXJ0aWNhbDoge1xuICAgIHBvczogXCJUb3BcIixcbiAgICBjb29yZDogXCJZXCIsXG4gICAgc2l6ZTogXCJIZWlnaHRcIlxuICB9XG59LCBxZSA9IFVlLmNsYXNzTmFtZSwgR3QgPSBbXG4gIFwibWFyZ2luXCIsXG4gIFwidGhyZXNob2xkXCIsXG4gIFwiem9vbU9mZnNldFhcIixcbiAgXCJ6b29tT2Zmc2V0WVwiLFxuICBcInpvb21cIixcbiAgXCJ6b29tWFwiLFxuICBcInpvb21ZXCIsXG4gIFwicmFuZ2VYXCIsXG4gIFwicmFuZ2VZXCIsXG4gIFwicmFuZ2VPZmZzZXRYXCIsXG4gIFwicmFuZ2VPZmZzZXRZXCIsXG4gIFwidXNlUGluY2hcIixcbiAgXCJ1c2VNb3VzZURyYWdcIixcbiAgXCJwaW5jaFRocmVzaG9sZFwiLFxuICBcIm1heFBpbmNoV2hlZWxcIixcbiAgXCJ3aGVlbFNjYWxlXCIsXG4gIFwiZGlzcGxheVZlcnRpY2FsU2Nyb2xsXCIsXG4gIFwiZGlzcGxheUhvcml6b250YWxTY3JvbGxcIixcbiAgXCJ0cmFuc2xhdGVaXCIsXG4gIFwidXNlQXV0b1pvb21cIixcbiAgXCJ3aGVlbFBpbmNoS2V5XCIsXG4gIFwiem9vbVJhbmdlXCIsXG4gIFwiem9vbVJhbmdlWFwiLFxuICBcInpvb21SYW5nZVlcIixcbiAgXCJwaW5jaERpcmVjdGlvblwiLFxuICBcInVzZU92ZXJmbG93U2Nyb2xsXCJcbl0sIHZuID0gW1xuICAvLyBpZ25vcmUgdGFyZ2V0LCBjb250YWluZXIsXG4gIC4uLkd0LFxuICBcInByZXZlbnRXaGVlbENsaWNrXCIsXG4gIFwidXNlV2hlZWxQaW5jaFwiLFxuICBcInVzZVdoZWVsU2Nyb2xsXCIsXG4gIFwidXNlR2VzdHVyZVwiLFxuICBcImNzcE5vbmNlXCIsXG4gIFwid3JhcHBlckVsZW1lbnRcIixcbiAgXCJzY3JvbGxBcmVhRWxlbWVudFwiLFxuICBcInZlcnRpY2FsU2Nyb2xsRWxlbWVudFwiLFxuICBcImhvcml6b250YWxTY3JvbGxFbGVtZW50XCIsXG4gIFwidXNlUmVzaXplT2JzZXJ2ZXJcIixcbiAgXCJ3aGVlbENvbnRhaW5lclwiLFxuICBcInVzZUJvdW5jZVNjcm9sbEJhclwiXG5dLCBHZSA9IFtcbiAgXCJzY3JvbGxcIixcbiAgXCJhYm9ydFBpbmNoXCIsXG4gIFwiZHJhZ1N0YXJ0XCIsXG4gIFwiZHJhZ0VuZFwiLFxuICBcInBpbmNoU3RhcnRcIixcbiAgXCJwaW5jaFwiXG5dLCB3biA9IFtcbiAgXCJnZXRTY3JvbGxMZWZ0XCIsXG4gIFwiZ2V0U2Nyb2xsVG9wXCIsXG4gIFwiZ2V0U2Nyb2xsV2lkdGhcIixcbiAgXCJnZXRTY3JvbGxIZWlnaHRcIixcbiAgXCJnZXRDb250YWluZXJXaWR0aFwiLFxuICBcImdldENvbnRhaW5lckhlaWdodFwiLFxuICBcImdldFZpZXdwb3J0V2lkdGhcIixcbiAgXCJnZXRWaWV3cG9ydEhlaWdodFwiLFxuICBcImdldFZpZXdwb3J0U2Nyb2xsV2lkdGhcIixcbiAgXCJnZXRWaWV3cG9ydFNjcm9sbEhlaWdodFwiLFxuICBcInNjcm9sbFRvXCIsXG4gIFwic2Nyb2xsQnlcIixcbiAgXCJ6b29tQnlcIixcbiAgXCJzY3JvbGxDZW50ZXJcIixcbiAgXCJnZXRDb250YWluZXJcIixcbiAgXCJnZXRWaWV3cG9ydFwiLFxuICBcImdldFdyYXBwZXJcIixcbiAgXCJzZXRab29tXCIsXG4gIFwiZ2V0UmFuZ2VYXCIsXG4gIFwiZ2V0UmFuZ2VZXCIsXG4gIFwicmVzaXplXCIsXG4gIFwiZ2V0Wm9vbVwiLFxuICBcImdldFpvb21YXCIsXG4gIFwiZ2V0Wm9vbVlcIixcbiAgXCJnZXRXaGVlbENvbnRhaW5lclwiLFxuICBcInNldFRvXCIsXG4gIFwic2V0QnlcIlxuXSwgZG4gPSAxZS02O1xuZnVuY3Rpb24gcG4oaSkge1xuICBjb25zdCB7IGRlbHRhWDogbiwgZGVsdGFZOiB0LCBkYXRhczogciB9ID0gaSwgZSA9IERhdGUubm93KCksIG8gPSByLnNwZWVkO1xuICBpZiAoIW8pIHtcbiAgICByLnNwZWVkID0gWzAsIDBdLCByLnRpbWUgPSBlO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhID0gZSAtIHIudGltZTtcbiAgci5zcGVlZCA9IFtvWzBdIC8gMiArIG4gLyBhLCBvWzFdIC8gMiArIHQgLyBhXTtcbn1cbmZ1bmN0aW9uIEtlKGksIG4pIHtcbiAgY29uc3QgdCA9IE1hdGguc3FydChpWzBdICogaVswXSArIGlbMV0gKiBpWzFdKTtcbiAgcmV0dXJuIE1hdGguYWJzKHQgLyBuKTtcbn1cbmZ1bmN0aW9uIGduKGksIG4pIHtcbiAgY29uc3QgdCA9IEtlKGksIG4pO1xuICByZXR1cm4gW1xuICAgIC1pWzBdIC8gMiAqIHQsXG4gICAgLWlbMV0gLyAyICogdFxuICBdO1xufVxuZnVuY3Rpb24gVShpKSB7XG4gIHJldHVybiBNYXRoLmFicyhpKTtcbn1cbmZ1bmN0aW9uIG1uKGksIG4sIHQsIHIsIGUpIHtcbiAgY29uc3QgbyA9IGUgfHwgaXNGaW5pdGUodFswXSkgPyB0WzBdIDogTWF0aC5taW4oLTEsIE1hdGguZmxvb3IoaSAvIG4pKSAqIG4gLSByLCBhID0gZSB8fCBpc0Zpbml0ZSh0WzFdKSA/IHRbMV0gOiBNYXRoLm1heCgxLCBNYXRoLmNlaWwoaSAvIG4pKSAqIG4gKyByO1xuICByZXR1cm4gW28sIGFdO1xufVxuZnVuY3Rpb24gemUoaSwgbikge1xuICByZXR1cm4gaSA/PyBuO1xufVxuZnVuY3Rpb24gUmUoaSwgbiwgdCkge1xuICBjb25zdCByID0gdC5kdXJhdGlvbiwgZSA9IHQuZWFzaW5nIHx8ICgoaCkgPT4gMSAtIE1hdGgucG93KDEgLSBoLCAzKSksIG8gPSBEYXRlLm5vdygpO1xuICBsZXQgYSA9IG87XG4gIGNvbnN0IGwgPSAoKSA9PiB7XG4gICAgY29uc3QgaCA9IERhdGUubm93KCk7XG4gICAgbGV0IHUgPSBoIC0gbztcbiAgICByIDwgdSAmJiAodSA9IHIpO1xuICAgIGNvbnN0IGQgPSBlKHUgLyByKSwgdiA9IGUoKGEgLSBvKSAvIHIpO1xuICAgIGEgPSBoLCBpKGQgLSB2KSwgISh1ID49IHIpICYmIG4obCk7XG4gIH07XG4gIG4obCk7XG59XG5jbGFzcyBEZSBleHRlbmRzIFp0IHtcbiAgY29uc3RydWN0b3IodCwgciwgZSkge1xuICAgIHN1cGVyKCk7XG4gICAgXyh0aGlzLCBcImlzQXBwZW5kXCIsICExKTtcbiAgICBfKHRoaXMsIFwidGh1bWJFbGVtZW50XCIpO1xuICAgIF8odGhpcywgXCJiYXJFbGVtZW50XCIpO1xuICAgIF8odGhpcywgXCJnZXN0b1wiKTtcbiAgICBfKHRoaXMsIFwic2l6ZVwiLCAwKTtcbiAgICBfKHRoaXMsIFwic2Nyb2xsU2l6ZVwiLCAwKTtcbiAgICBfKHRoaXMsIFwiaXNIb3Jpem9udGFsXCIsICExKTtcbiAgICBfKHRoaXMsIFwiX29uRHJhZ1N0YXJ0XCIsICh0KSA9PiB7XG4gICAgICBjb25zdCByID0gdGhpcy5pc0hvcml6b250YWwsIGUgPSB0LmlucHV0RXZlbnQudGFyZ2V0LCBvID0gdC5kYXRhcywgYSA9IHRoaXMudGh1bWJFbGVtZW50ID09PSBlO1xuICAgICAgYSB8fCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBsID0gdGhpcy50aHVtYkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGggPSBsW3IgPyBcImxlZnRcIiA6IFwidG9wXCJdLCB1ID0gbFtyID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0sIGQgPSBoICsgdSwgdiA9IHRbciA/IFwiY2xpZW50WFwiIDogXCJjbGllbnRZXCJdO1xuICAgICAgICAgIGlmIChoIDw9IHYgJiYgdiA8PSBkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLnNpemUsIG0gPSBjICogYyAvIHRoaXMuc2Nyb2xsU2l6ZTtcbiAgICAgICAgICB0aGlzLnNjcm9sbEJ5KGggPCB2ID8gbSA6IC1tKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMDApLCBvLmlzVGh1bWIgPSBhLCB0LmlucHV0RXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksIHQuaW5wdXRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuICAgIF8odGhpcywgXCJfb25EcmFnXCIsICh0KSA9PiB7XG4gICAgICB0LmRhdGFzLmlzVGh1bWIgJiYgdGhpcy5zY3JvbGxCeSh0aGlzLmlzSG9yaXpvbnRhbCA/IHQuZGVsdGFYIDogdC5kZWx0YVkpO1xuICAgIH0pO1xuICAgIF8odGhpcywgXCJfb25XaGVlbFwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgciA9IHRoaXMuaXNIb3Jpem9udGFsID8gdC5kZWx0YVggOiB0LmRlbHRhWTtcbiAgICAgIHIgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnRyaWdnZXIoXCJzY3JvbGxcIiwge1xuICAgICAgICBkZWx0YTogclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy50eXBlID0gcjtcbiAgICBjb25zdCBvID0gciA9PT0gXCJob3Jpem9udGFsXCIsIGEgPSBOdCh0KTtcbiAgICBsZXQgbCwgaCA9IGU7XG4gICAgZSA/IGwgPSBlLnF1ZXJ5U2VsZWN0b3IoYC4ke3llfWApIDogKGggPSBhLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGwgPSBhLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGguaW5zZXJ0QmVmb3JlKGwsIG51bGwpLCB0aGlzLmlzQXBwZW5kID0gITApLCBpdChcbiAgICAgIGgsXG4gICAgICBvID8gTmUgOiBaZVxuICAgICksIGl0KGgsIGZuKSwgaXQobCwgeWUpLCB0aGlzLnRodW1iRWxlbWVudCA9IGwsIHRoaXMuYmFyRWxlbWVudCA9IGgsIHRoaXMuaXNIb3Jpem9udGFsID0gbywgdGhpcy5nZXN0byA9IG5ldyBXZShoLCB7XG4gICAgICBjb250YWluZXI6IG90KGEpXG4gICAgfSkub24oXCJkcmFnU3RhcnRcIiwgKHUpID0+IHRoaXMuX29uRHJhZ1N0YXJ0KHUpKS5vbihcImRyYWdcIiwgKHUpID0+IHRoaXMuX29uRHJhZyh1KSksIE8odGhpcy5iYXJFbGVtZW50LCBcIndoZWVsXCIsIHRoaXMuX29uV2hlZWwsIHtcbiAgICAgIHBhc3NpdmU6ICExXG4gICAgfSk7XG4gIH1cbiAgc2Nyb2xsQnkodCwgcikge1xuICAgIGNvbnN0IGUgPSB0IC8gdGhpcy5zaXplO1xuICAgIHRoaXMudHJpZ2dlcihcInNjcm9sbFwiLCB7XG4gICAgICBkZWx0YTogciA/IHQgOiB0aGlzLnNjcm9sbFNpemUgKiBlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKHQsIHIsIGUsIG8pIHtcbiAgICB0aGlzLnNpemUgPSBlLCB0aGlzLnNjcm9sbFNpemUgPSBvO1xuICAgIGNvbnN0IGEgPSB0ICYmICRyKG8gLSBlLCAxZS0zKSA+IDAgPyAxIDogMCwgW2wsIGhdID0gdGhpcy5pc0hvcml6b250YWwgPyBbXCJYXCIsIFwid2lkdGhcIl0gOiBbXCJZXCIsIFwiaGVpZ2h0XCJdLCB1ID0gZSAvIG8gKiAxMDAsIGQgPSBNYXRoLm1heCgwLCByKSAvIG8gKiAxMDA7XG4gICAgdGhpcy50aHVtYkVsZW1lbnQuc3R5bGUuY3NzVGV4dCArPSBgJHtofTogJHt1fSU7b3BhY2l0eTogJHthfTt0cmFuc2Zvcm06IHRyYW5zbGF0ZSR7bH0oJHsxMDAgLyB1ICogZH0lKWA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBZKHRoaXMuYmFyRWxlbWVudCwgXCJ3aGVlbFwiLCB0aGlzLl9vbldoZWVsKSwgdGhpcy5nZXN0by5vZmYoKSwgdGhpcy5vZmYoKTtcbiAgfVxufVxubGV0IEh0ID0gY2xhc3MgZXh0ZW5kcyBadCB7XG4gIC8qKlxuICAgKiBAc29ydCAxXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0LCByID0ge30sIGUgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgXyh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgXyh0aGlzLCBcImluamVjdFJlc3VsdFwiKTtcbiAgICBfKHRoaXMsIFwid3JhcHBlckVsZW1lbnRcIik7XG4gICAgXyh0aGlzLCBcInNjcm9sbEFyZWFFbGVtZW50XCIpO1xuICAgIF8odGhpcywgXCJob3Jpem9udGFsU2Nyb2xsYmFyXCIpO1xuICAgIF8odGhpcywgXCJ2ZXJ0aWNhbFNjcm9sbGJhclwiKTtcbiAgICBfKHRoaXMsIFwiZ2VzdG9cIik7XG4gICAgXyh0aGlzLCBcIm9mZnNldFhcIiwgMCk7XG4gICAgXyh0aGlzLCBcIm9mZnNldFlcIiwgMCk7XG4gICAgXyh0aGlzLCBcImNvbnRhaW5lcldpZHRoXCIsIDApO1xuICAgIF8odGhpcywgXCJjb250YWluZXJIZWlnaHRcIiwgMCk7XG4gICAgXyh0aGlzLCBcInZpZXdwb3J0V2lkdGhcIiwgMCk7XG4gICAgXyh0aGlzLCBcInZpZXdwb3J0SGVpZ2h0XCIsIDApO1xuICAgIF8odGhpcywgXCJ2aWV3cG9ydFNjcm9sbFdpZHRoXCIsIDApO1xuICAgIF8odGhpcywgXCJ2aWV3cG9ydFNjcm9sbEhlaWdodFwiLCAwKTtcbiAgICBfKHRoaXMsIFwic2Nyb2xsTGVmdFwiLCAwKTtcbiAgICBfKHRoaXMsIFwic2Nyb2xsVG9wXCIsIDApO1xuICAgIF8odGhpcywgXCJfc2Nyb2xsVGltZXJcIiwgMCk7XG4gICAgXyh0aGlzLCBcIl96b29tVGltZXJcIiwgMCk7XG4gICAgXyh0aGlzLCBcIl92aWV3cG9ydEVsZW1lbnRcIiwgbnVsbCk7XG4gICAgXyh0aGlzLCBcIl93aGVlbENvbnRhaW5lckVsZW1lbnRcIiwgbnVsbCk7XG4gICAgXyh0aGlzLCBcImRyYWdGbGFnXCIsICExKTtcbiAgICBfKHRoaXMsIFwiaXNMb29wXCIsICExKTtcbiAgICBfKHRoaXMsIFwiX3RlbXBTY2FsZVwiLCBbMSwgMV0pO1xuICAgIF8odGhpcywgXCJfdGVtcFJlY3RcIiwgbnVsbCk7XG4gICAgXyh0aGlzLCBcIl90ZW1wUmVjdFRpbWVyXCIsIG51bGwpO1xuICAgIF8odGhpcywgXCJfb25EZXN0cm95c1wiLCBbXSk7XG4gICAgXyh0aGlzLCBcIl9hc0xlZnRcIiwgMCk7XG4gICAgXyh0aGlzLCBcIl9hc1RvcFwiLCAwKTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgVmlld2VyIFNpemVzXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIF8odGhpcywgXCJyZXNpemVcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyBvZmZzZXRXaWR0aDogdCwgb2Zmc2V0SGVpZ2h0OiByIH0gPSB0aGlzLl9jb250YWluZXJFbGVtZW50LCB7XG4gICAgICAgIG9mZnNldFdpZHRoOiBlLFxuICAgICAgICBvZmZzZXRIZWlnaHQ6IG8sXG4gICAgICAgIHNjcm9sbFdpZHRoOiBhLFxuICAgICAgICBzY3JvbGxIZWlnaHQ6IGxcbiAgICAgIH0gPSB0aGlzLl92aWV3cG9ydEVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gdCwgdGhpcy5jb250YWluZXJIZWlnaHQgPSByLCB0aGlzLnZpZXdwb3J0V2lkdGggPSBlLCB0aGlzLnZpZXdwb3J0SGVpZ2h0ID0gbywgdGhpcy52aWV3cG9ydFNjcm9sbFdpZHRoID0gTWF0aC5tYXgoZSwgYSksIHRoaXMudmlld3BvcnRTY3JvbGxIZWlnaHQgPSBNYXRoLm1heChvLCBsKSwgdGhpcy5yZW5kZXIoKSwgdGhpcy5fc2Nyb2xsQnkoMCwgMCk7XG4gICAgfSk7XG4gICAgXyh0aGlzLCBcIl9vblNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHNjcm9sbExlZnQ6IHQsIHNjcm9sbFRvcDogciB9ID0gdGhpcy53cmFwcGVyRWxlbWVudCwgeyB6b29tOiBlID0gSS56b29tIH0gPSB0aGlzLCBvID0gdCAtIHRoaXMuc2Nyb2xsTGVmdCwgYSA9IHIgLSB0aGlzLnNjcm9sbFRvcCwgbCA9IHRoaXMuZ2V0U2Nyb2xsTGVmdCgpLCBoID0gdGhpcy5nZXRTY3JvbGxUb3AoKTtcbiAgICAgIHRoaXMuaXNMb29wICYmICh0aGlzLmlzTG9vcCA9ICExKSwgdGhpcy5zY3JvbGxMZWZ0ID0gdCwgdGhpcy5zY3JvbGxUb3AgPSByLCB0aGlzLnNjcm9sbFRvKFxuICAgICAgICBsICsgbyAvIGUsXG4gICAgICAgIGggKyBhIC8gZVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBfKHRoaXMsIFwib25XaGVlbFwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgciA9IHRoaXMub3B0aW9ucywgZSA9IHIucGluY2hEaXJlY3Rpb24sIG8gPSByLm1heFBpbmNoV2hlZWwgfHwgMSAvIDAsIGEgPSB0W2Ake3RoaXMud2hlZWxQaW5jaEtleX1LZXlgXSB8fCB0LmN0cmxLZXk7XG4gICAgICBpZiAoci51c2VXaGVlbFBpbmNoICYmIGEpIHtcbiAgICAgICAgbGV0IGwgPSB0LmRlbHRhWTtcbiAgICAgICAgY29uc3QgaCA9IGwgPj0gMCA/IDEgOiAtMSwgdSA9IE1hdGgubWluKG8sIE1hdGguYWJzKGwpKTtcbiAgICAgICAgbCA9IGggKiB1O1xuICAgICAgICBjb25zdCBkID0gLWwsIHYgPSBNYXRoLm1heChcbiAgICAgICAgICAxICsgZCAqIChyLndoZWVsU2NhbGUgfHwgMC4wMSksXG4gICAgICAgICAgZG5cbiAgICAgICAgKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RlbXBSZWN0VGltZXIpLCB0aGlzLl90ZW1wUmVjdFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3RlbXBSZWN0ID0gbnVsbDtcbiAgICAgICAgfSwgMTAwKSwgdGhpcy5fdHJpZ2dlclBpbmNoKHtcbiAgICAgICAgICBkaXN0YW5jZTogdSxcbiAgICAgICAgICBzY2FsZTogdixcbiAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICB6b29tOiB0aGlzLnpvb20gKiB2LFxuICAgICAgICAgIHpvb21YOiB0aGlzLnpvb21YICogKGUgPT09IFwidmVydGljYWxcIiA/IDEgOiB2KSxcbiAgICAgICAgICB6b29tWTogdGhpcy56b29tWSAqIChlID09PSBcImhvcml6b250YWxcIiA/IDEgOiB2KSxcbiAgICAgICAgICBpbnB1dEV2ZW50OiB0LFxuICAgICAgICAgIGlzV2hlZWw6ICEwLFxuICAgICAgICAgIGNsaWVudFg6IHQuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZOiB0LmNsaWVudFksXG4gICAgICAgICAgcmF0aW9YOiAwLFxuICAgICAgICAgIHJhdGlvWTogMFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoci51c2VXaGVlbFNjcm9sbCkge1xuICAgICAgICBsZXQgbCA9IHQuZGVsdGFYLCBoID0gdC5kZWx0YVk7XG4gICAgICAgIHQuc2hpZnRLZXkgJiYgIWwgJiYgKGwgPSBoLCBoID0gMCksIHRoaXMuc2Nyb2xsQnkobCAvIHRoaXMuem9vbVgsIGggLyB0aGlzLnpvb21ZKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm47XG4gICAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG4gICAgXyh0aGlzLCBcIm9uR2VzdHVyZVN0YXJ0XCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl90ZW1wU2NhbGUgPSBbdGhpcy56b29tWCwgdGhpcy56b29tWV0sIHRoaXMuX3NldENsaWVudFJlY3QoKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuICAgIF8odGhpcywgXCJvbkdlc3R1cmVDaGFuZ2VcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuZ2VzdG8uaXNGbGFnKCkgfHwgIXRoaXMuX3RlbXBTY2FsZSkge1xuICAgICAgICB0aGlzLl90ZW1wU2NhbGUgPSBbMSwgMV07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHIgPSB0LnNjYWxlLCBlID0gdGhpcy5fdGVtcFNjYWxlWzBdLCBvID0gdGhpcy5fdGVtcFNjYWxlWzFdLCBhID0gdGhpcy5vcHRpb25zLnBpbmNoRGlyZWN0aW9uO1xuICAgICAgdGhpcy5fdHJpZ2dlclBpbmNoKHtcbiAgICAgICAgZGlzdGFuY2U6IDAsXG4gICAgICAgIHNjYWxlOiByLFxuICAgICAgICByb3RhdGlvbjogdC5yb3RhdGlvbixcbiAgICAgICAgaW5wdXRFdmVudDogdCxcbiAgICAgICAgaXNXaGVlbDogITAsXG4gICAgICAgIHpvb206IChlICsgbykgKiByIC8gMixcbiAgICAgICAgem9vbVg6IGUgKiAoYSA9PT0gXCJ2ZXJ0aWNhbFwiID8gMSA6IHIpLFxuICAgICAgICB6b29tWTogbyAqIChhID09PSBcImhvcml6b250YWxcIiA/IDEgOiByKSxcbiAgICAgICAgY2xpZW50WDogdC5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiB0LmNsaWVudFksXG4gICAgICAgIHJhdGlvWDogMCxcbiAgICAgICAgcmF0aW9ZOiAwXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfKHRoaXMsIFwib25HZXN0dXJlRW5kXCIsICgpID0+IHtcbiAgICB9KTtcbiAgICB0aGlzLl9jb250YWluZXJFbGVtZW50ID0gdCwgX2UocikgPyAodGhpcy5fdmlld3BvcnRFbGVtZW50ID0gciwgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4uSSxcbiAgICAgIC4uLmVcbiAgICB9KSA6ICh0aGlzLl92aWV3cG9ydEVsZW1lbnQgPSB0LmNoaWxkcmVuWzBdLCB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5JLFxuICAgICAgLi4uclxuICAgIH0pLCB0aGlzLmluaXQoKTtcbiAgfVxuICBzdGF0aWMgYWRkUHJvcGVydGllcyh0LCByKSB7XG4gICAgdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCBvID0ge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbZV07XG4gICAgICAgIH1cbiAgICAgIH0sIGEgPSBBZShgc2V0ICR7ZX1gKTtcbiAgICAgIHJbYV0gPyBvLnNldCA9IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgdGhpc1thXShsKTtcbiAgICAgIH0gOiBvLnNldCA9IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zW2VdID0gbDtcbiAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBlLCBvKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IENvbnRhaW5lciBFbGVtZW50XG4gICAqL1xuICBnZXRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBXaGVlbCBDb250YWluZXIgRWxlbWVudFxuICAgKi9cbiAgZ2V0V2hlZWxDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3doZWVsQ29udGFpbmVyRWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogR2V0IFZpZXdwb3J0IEVsZW1lbnRcbiAgICovXG4gIGdldFZpZXdwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydEVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBXcmFwcGVyIEVsZW1lbnRcbiAgICovXG4gIGdldFdyYXBwZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcHBlckVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBTY3JvbGwgQXJlYSBFbGVtZW50XG4gICAqL1xuICBnZVNjcm9sbEFyZWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsQXJlYUVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgZWxlbWVudHMsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMub2ZmKCksIHRoaXMuZ2VzdG8udW5zZXQoKSwgdGhpcy52ZXJ0aWNhbFNjcm9sbGJhci5kZXN0cm95KCksIHRoaXMuaG9yaXpvbnRhbFNjcm9sbGJhci5kZXN0cm95KCksIHRoaXMuaW5qZWN0UmVzdWx0LmRlc3Ryb3koKTtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29udGFpbmVyRWxlbWVudDtcbiAgICB0aGlzLl9vbkRlc3Ryb3lzLmZvckVhY2goKHIpID0+IHtcbiAgICAgIHIoKTtcbiAgICB9KSwgWSh0aGlzLndyYXBwZXJFbGVtZW50LCBcInNjcm9sbFwiLCB0aGlzLl9vblNjcm9sbCksIFkodGhpcy5fd2hlZWxDb250YWluZXJFbGVtZW50LCBcIndoZWVsXCIsIHRoaXMub25XaGVlbCksIFkodCwgXCJnZXN0dXJlc3RhcnRcIiwgdGhpcy5vbkdlc3R1cmVTdGFydCksIFkodCwgXCJnZXN0dXJlY2hhbmdlXCIsIHRoaXMub25HZXN0dXJlQ2hhbmdlKSwgWSh0LCBcImdlc3R1cmVzZW5kXCIsIHRoaXMub25HZXN0dXJlRW5kKSwgdGhpcy5nZXN0byA9IG51bGwsIHRoaXMuaW5qZWN0UmVzdWx0ID0gbnVsbCwgdGhpcy5fY29udGFpbmVyRWxlbWVudCA9IG51bGwsIHRoaXMuX3ZpZXdwb3J0RWxlbWVudCA9IG51bGwsIHRoaXMub3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCBhbiBlbGVtZW50J3MgY29udGVudCBpcyBzY3JvbGxlZCB2ZXJ0aWNhbGx5LlxuICAgKi9cbiAgZ2V0U2Nyb2xsVG9wKHQgPSB7fSkge1xuICAgIGxldCByID0gITEsIGUgPSAhMTtcbiAgICBzdCh0KSA/IChyID0gdC5yYW5nZSwgZSA9IHQuYWJzb2x1dGUpIDogciA9IHQ7XG4gICAgY29uc3QgbyA9IHRoaXMuem9vbVksIGEgPSB0aGlzLnNjcm9sbFRvcCAvIG8gKyB0aGlzLm9mZnNldFkgKyAociA/IFUodGhpcy5nZXRSYW5nZVkoKVswXSkgOiAwKTtcbiAgICByZXR1cm4gZSA/IGEgKiBvIDogYTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IGFuIGVsZW1lbnQncyBjb250ZW50IGlzIHNjcm9sbGVkIHZlcnRpY2FsbHkuXG4gICAqL1xuICBnZXRTY3JvbGxMZWZ0KHQgPSB7fSkge1xuICAgIGxldCByID0gITEsIGUgPSAhMTtcbiAgICBzdCh0KSA/IChyID0gdC5yYW5nZSwgZSA9IHQuYWJzb2x1dGUpIDogciA9IHQ7XG4gICAgY29uc3QgbyA9IHRoaXMuem9vbVgsIGEgPSB0aGlzLnNjcm9sbExlZnQgLyBvICsgdGhpcy5vZmZzZXRYICsgKHIgPyBVKHRoaXMuZ2V0UmFuZ2VYKClbMF0pIDogMCk7XG4gICAgcmV0dXJuIGUgPyBhICogbyA6IGE7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgbWVhc3VyZW1lbnQgb2YgdGhlIHdpZHRoIG9mIGFuIGVsZW1lbnQncyBjb250ZW50IHdpdGggb3ZlcmZsb3dcbiAgICovXG4gIGdldFNjcm9sbFdpZHRoKHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5fZ2V0U2Nyb2xsUmFuZ2VYKCksIGUgPSB0aGlzLnpvb21YLCBvID0gdGhpcy5jb250YWluZXJXaWR0aCAvIGUgKyBVKHJbMF0pICsgclsxXTtcbiAgICByZXR1cm4gdCA/IG8gOiBvICogZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBtZWFzdXJlbWVudCBvZiB0aGUgaGVpZ2h0IG9mIGFuIGVsZW1lbnQncyBjb250ZW50IHdpdGggb3ZlcmZsb3dcbiAgICovXG4gIGdldFNjcm9sbEhlaWdodCh0KSB7XG4gICAgY29uc3QgciA9IHRoaXMuX2dldFNjcm9sbFJhbmdlWSgpLCBlID0gdGhpcy56b29tWSwgbyA9IHRoaXMuY29udGFpbmVySGVpZ2h0IC8gZSArIFUoclswXSkgKyByWzFdO1xuICAgIHJldHVybiB0ID8gbyA6IG8gKiBlO1xuICB9XG4gIC8qKlxuICAgKiBTY3JvbGwgdGhlIGVsZW1lbnQgdG8gdGhlIGNlbnRlclxuICAgKi9cbiAgc2Nyb2xsQ2VudGVyKHQgPSB7fSkge1xuICAgIHRoaXMucmVzaXplKCk7XG4gICAgY29uc3QgciA9IHRoaXMuem9vbVgsIGUgPSB0aGlzLnpvb21ZO1xuICAgIGxldCBvID0gLSh0aGlzLmNvbnRhaW5lcldpZHRoIC8gciAtIHRoaXMudmlld3BvcnRXaWR0aCkgLyAyLCBhID0gLSh0aGlzLmNvbnRhaW5lckhlaWdodCAvIGUgLSB0aGlzLnZpZXdwb3J0SGVpZ2h0KSAvIDI7XG4gICAgcmV0dXJuIHQuYWJzb2x1dGUgJiYgKG8gKj0gciwgYSAqPSBlKSwgdC5ob3Jpem9udGFsID09PSAhMSAmJiAobyA9IHRoaXMuZ2V0U2Nyb2xsTGVmdCgpKSwgdC52ZXJ0aWNhbCA9PT0gITEgJiYgKGEgPSB0aGlzLmdldFNjcm9sbFRvcCgpKSwgdGhpcy5zY3JvbGxUbyhvLCBhLCB0KTtcbiAgfVxuICAvKipcbiAgICogTW92ZSB0byB0aGF0IHBvc2l0aW9uIG9yIHpvb20uXG4gICAqIEBzaW5jZSAwLjI1LjBcbiAgICovXG4gIHNldFRvKHQpIHtcbiAgICBjb25zdCB7XG4gICAgICB4OiByID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCksXG4gICAgICB5OiBlID0gdGhpcy5nZXRTY3JvbGxUb3AoKSxcbiAgICAgIHpvb206IG8gPSBbdGhpcy5nZXRab29tWCgpLCB0aGlzLmdldFpvb21ZKCldLFxuICAgICAgZHVyYXRpb246IGFcbiAgICB9ID0gdCwgeyB6b29tWDogbCwgem9vbVk6IGgsIHpvb21SYW5nZTogdSB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgem9vbU9mZnNldFg6IGQgPSBJLnpvb21PZmZzZXRYLFxuICAgICAgem9vbU9mZnNldFk6IHYgPSBJLnpvb21PZmZzZXRZXG4gICAgfSA9IHRoaXM7XG4gICAgXCJ6b29tT2Zmc2V0WFwiIGluIHQgJiYgKGQgPSB0Lnpvb21PZmZzZXRYKSwgXCJ6b29tT2Zmc2V0WVwiIGluIHQgJiYgKHYgPSB0Lnpvb21PZmZzZXRZKTtcbiAgICBjb25zdCBbYywgbV0gPSB2dChvKSA/IG8gOiBbbywgb10sIHAgPSB0aGlzLnpvb21SYW5nZVggfHwgdSwgUyA9IHRoaXMuem9vbVJhbmdlWSB8fCB1LCBUID0gdHQoYywgcFswXSwgcFsxXSksIHogPSB0dChtLCBTWzBdLCBTWzFdKSwgYiA9IEcoYCR7ZH1gLCB0aGlzLnZpZXdwb3J0V2lkdGgpICogKDEgLyBsIC0gMSAvIFQpLCBXID0gRyhgJHt2fWAsIHRoaXMudmlld3BvcnRIZWlnaHQpICogKDEgLyBoIC0gMSAvIHopO1xuICAgIHRoaXMuc2Nyb2xsVG8ociAtIGIsIGUgLSBXLCB7XG4gICAgICBkdXJhdGlvbjogYVxuICAgIH0pLCB0aGlzLnNldFpvb20obywge1xuICAgICAgem9vbU9mZnNldFg6IGQsXG4gICAgICB6b29tT2Zmc2V0WTogdixcbiAgICAgIGR1cmF0aW9uOiBhLFxuICAgICAgem9vbUJhc2U6IFwiZml4ZWRcIlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIGJ5IHRoZSBwb3NpdGlvbiBvciB6b29tIGRlbHRhIHZhbHVlLlxuICAgKiBAc2luY2UgMC4yNS4wXG4gICAqL1xuICBzZXRCeSh0KSB7XG4gICAgY29uc3QgeyB4OiByID0gMCwgeTogZSA9IDAsIHpvb206IG8gPSBbMCwgMF0gfSA9IHQsIFthLCBsXSA9IHZ0KG8pID8gbyA6IFtvLCBvXTtcbiAgICB0aGlzLnNldFRvKHtcbiAgICAgIC4uLnQsXG4gICAgICB4OiB0aGlzLmdldFNjcm9sbExlZnQoKSArIHIsXG4gICAgICB5OiB0aGlzLmdldFNjcm9sbFRvcCgpICsgZSxcbiAgICAgIHpvb206IFt0aGlzLnpvb21YICsgYSwgdGhpcy56b29tWSArIGxdXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNjcm9sbHMgdGhlIGNvbnRhaW5lciBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKi9cbiAgc2Nyb2xsQnkodCwgciwgZSkge1xuICAgIGlmICh0aGlzLl9wYXVzZVNjcm9sbEFuaW1hdGlvbigpLCAhZSB8fCAhZS5kdXJhdGlvbikge1xuICAgICAgbGV0IG8gPSB0aGlzLmdldFNjcm9sbExlZnQoKSwgYSA9IHRoaXMuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICByZXR1cm4gZSAhPSBudWxsICYmIGUuYWJzb2x1dGUgJiYgKG8gKj0gdGhpcy56b29tWCwgYSAqPSB0aGlzLnpvb21ZKSwgdGhpcy5fc2Nyb2xsVG8obyArIHQsIGEgKyByLCBlKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydFNjcm9sbEFuaW1hdGlvbihbdCwgcl0sIGUpLCAhMDtcbiAgfVxuICAvKipcbiAgICogU2Nyb2xscyB0aGUgY29udGFpbmVyIHRvIHNldCBvZiBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHNjcm9sbExlZnRcbiAgICogQHBhcmFtIHNjcm9sbFRvcFxuICAgKi9cbiAgc2Nyb2xsVG8odCwgciwgZSkge1xuICAgIGlmICh0aGlzLl9wYXVzZVNjcm9sbEFuaW1hdGlvbigpLCAhZSB8fCAhZS5kdXJhdGlvbilcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxUbyh0LCByLCBlKTtcbiAgICB7XG4gICAgICBsZXQgbyA9IHRoaXMuZ2V0U2Nyb2xsTGVmdCgpLCBhID0gdGhpcy5nZXRTY3JvbGxUb3AoKTtcbiAgICAgIHJldHVybiBlICE9IG51bGwgJiYgZS5hYnNvbHV0ZSAmJiAobyAqPSB0aGlzLnpvb21YLCBhICo9IHRoaXMuem9vbVkpLCB0aGlzLnNjcm9sbEJ5KHQgLSBvLCByIC0gYSwgZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXQgdmlld2VyIHpvb20gYnkgdGhlIGdpdmVuIGFtb3VudFxuICAgKi9cbiAgem9vbUJ5KHQsIHIpIHtcbiAgICB0aGlzLl9wYXVzZVpvb21BbmltYXRpb24oKTtcbiAgICBjb25zdCBbZSwgb10gPSB2dCh0KSA/IHQgOiBbdCwgdF07XG4gICAgIXIgfHwgIXIuZHVyYXRpb24gPyB0aGlzLl9zZXRab29tKFt0aGlzLnpvb21YICsgZSwgdGhpcy56b29tWSArIG9dLCByKSA6IHRoaXMuX3N0YXJ0Wm9vbUFuaW1hdGlvbihbZSwgb10sIHIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdmlld2VyIHpvb21cbiAgICovXG4gIHNldFpvb20odCwgcikge1xuICAgIGlmICh0aGlzLl9wYXVzZVpvb21BbmltYXRpb24oKSwgIXIgfHwgIXIuZHVyYXRpb24pXG4gICAgICB0aGlzLl9zZXRab29tKHQsIHIpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgW2UsIG9dID0gdnQodCkgPyB0IDogW3QsIHRdO1xuICAgICAgdGhpcy5fc3RhcnRab29tQW5pbWF0aW9uKFxuICAgICAgICBbZSAtIHRoaXMuem9vbVgsIG8gLSB0aGlzLnpvb21ZXSxcbiAgICAgICAgclxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZ2V0Vmlld3BvcnRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3cG9ydFdpZHRoO1xuICB9XG4gIGdldFZpZXdwb3J0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdwb3J0V2lkdGg7XG4gIH1cbiAgZ2V0Vmlld3BvcnRTY3JvbGxXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3cG9ydFNjcm9sbFdpZHRoO1xuICB9XG4gIGdldFZpZXdwb3J0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdwb3J0U2Nyb2xsSGVpZ2h0O1xuICB9XG4gIGdldENvbnRhaW5lcldpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcldpZHRoO1xuICB9XG4gIGdldENvbnRhaW5lckhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJIZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB2aWV3ZXIgem9vbVxuICAgKi9cbiAgZ2V0Wm9vbSgpIHtcbiAgICByZXR1cm4gKHRoaXMuem9vbVggKyB0aGlzLnpvb21ZKSAvIDI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB2aWV3ZXIgem9vbVhcbiAgICogQHNpbmNlIDAuMjAuMFxuICAgKi9cbiAgZ2V0Wm9vbVgoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9vbVg7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB2aWV3ZXIgem9vbVxuICAgKiBAc2luY2UgMC4yMC4wXG4gICAqL1xuICBnZXRab29tWSgpIHtcbiAgICByZXR1cm4gdGhpcy56b29tWTtcbiAgfVxuICAvKipcbiAgICogZ2V0IHggcmFuZ2VzXG4gICAqL1xuICBnZXRSYW5nZVgodCwgcikge1xuICAgIHJldHVybiB0aGlzLl9nZXRSYW5nZUNvb3JkKFwiaG9yaXpvbnRhbFwiLCB0LCByKTtcbiAgfVxuICAvKipcbiAgICogZ2V0IHkgcmFuZ2VzXG4gICAqL1xuICBnZXRSYW5nZVkodCwgcikge1xuICAgIHJldHVybiB0aGlzLl9nZXRSYW5nZUNvb3JkKFwidmVydGljYWxcIiwgdCwgcik7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29udGFpbmVyRWxlbWVudCwgciA9IHRoaXMub3B0aW9ucywgZSA9IE50KHQpLCBvID0gb3QodCk7XG4gICAgbGV0IGEgPSByLndyYXBwZXJFbGVtZW50IHx8IHQucXVlcnlTZWxlY3RvcihgLiR7d2V9YCksIGwgPSByLnNjcm9sbEFyZWFFbGVtZW50IHx8IHQucXVlcnlTZWxlY3RvcihgLiR7YmV9YCk7XG4gICAgY29uc3QgaCA9IHIuaG9yaXpvbnRhbFNjcm9sbEVsZW1lbnQgfHwgdC5xdWVyeVNlbGVjdG9yKGAuJHtOZX1gKSwgdSA9IHIudmVydGljYWxTY3JvbGxFbGVtZW50IHx8IHQucXVlcnlTZWxlY3RvcihgLiR7WmV9YCk7XG4gICAgYSB8fCAoYSA9IGUuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgYS5pbnNlcnRCZWZvcmUodGhpcy5fdmlld3BvcnRFbGVtZW50LCBudWxsKSwgdC5pbnNlcnRCZWZvcmUoYSwgbnVsbCkpLCB0aGlzLndyYXBwZXJFbGVtZW50ID0gYSwgbCB8fCAobCA9IGUuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgYS5pbnNlcnRCZWZvcmUobCwgYS5maXJzdENoaWxkKSksIHRoaXMuc2Nyb2xsQXJlYUVsZW1lbnQgPSBsLCBpdCh0LCBxZSksIGl0KGEsIHdlKSwgaXQobCwgYmUpO1xuICAgIGNvbnN0IGQgPSBuZXcgRGUoXG4gICAgICB0LFxuICAgICAgXCJob3Jpem9udGFsXCIsXG4gICAgICBoXG4gICAgKSwgdiA9IG5ldyBEZShcbiAgICAgIHQsXG4gICAgICBcInZlcnRpY2FsXCIsXG4gICAgICB1XG4gICAgKTtcbiAgICB0aGlzLmhvcml6b250YWxTY3JvbGxiYXIgPSBkLCB0aGlzLnZlcnRpY2FsU2Nyb2xsYmFyID0gdiwgZC5vbihcInNjcm9sbFwiLCAocCkgPT4ge1xuICAgICAgdGhpcy5zY3JvbGxCeShwLmRlbHRhIC8gdGhpcy56b29tWCwgMCk7XG4gICAgfSksIHYub24oXCJzY3JvbGxcIiwgKHApID0+IHtcbiAgICAgIHRoaXMuc2Nyb2xsQnkoMCwgcC5kZWx0YSAvIHRoaXMuem9vbVkpO1xuICAgIH0pLCBkLmlzQXBwZW5kICYmIHQuaW5zZXJ0QmVmb3JlKGQuYmFyRWxlbWVudCwgbnVsbCksIHYuaXNBcHBlbmQgJiYgdC5pbnNlcnRCZWZvcmUodi5iYXJFbGVtZW50LCBudWxsKSwgdGhpcy5pbmplY3RSZXN1bHQgPSBVZS5pbmplY3QodCwge1xuICAgICAgbm9uY2U6IHRoaXMub3B0aW9ucy5jc3BOb25jZVxuICAgIH0pO1xuICAgIGNvbnN0IGMgPSByLndoZWVsQ29udGFpbmVyO1xuICAgIGxldCBtID0gbnVsbDtcbiAgICBpZiAoYyAmJiAoT2UoYykgPyBtID0gZS5xdWVyeVNlbGVjdG9yKGMpIDogX2UoYykgPyBtID0gYyA6IChcInZhbHVlXCIgaW4gYyB8fCBcImN1cnJlbnRcIiBpbiBjKSAmJiAobSA9IGMuY3VycmVudCB8fCBjLnZhbHVlKSksIG0gfHwgKG0gPSB0KSwgdGhpcy5fd2hlZWxDb250YWluZXJFbGVtZW50ID0gbSwgdGhpcy5nZXN0byA9IG5ldyBXZSh0LCB7XG4gICAgICBjb250YWluZXI6IG90KHQpLFxuICAgICAgZXZlbnRzOiBbXCJ0b3VjaFwiLCBcIm1vdXNlXCJdLFxuICAgICAgcHJldmVudFdoZWVsQ2xpY2s6IHRoaXMub3B0aW9ucy5wcmV2ZW50V2hlZWxDbGljayA/PyAhMFxuICAgIH0pLm9uKFwiZHJhZ1N0YXJ0XCIsIChwKSA9PiB7XG4gICAgICBjb25zdCB7IGlucHV0RXZlbnQ6IFMsIHN0b3A6IFQsIGRhdGFzOiB6IH0gPSBwO1xuICAgICAgaWYgKCF0aGlzLnVzZU1vdXNlRHJhZyAmJiBwLmlzTW91c2VFdmVudCkge1xuICAgICAgICBUKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wYXVzZVNjcm9sbEFuaW1hdGlvbigpLCB0aGlzLmRyYWdGbGFnID0gITEsIHRoaXMudHJpZ2dlcihcImRyYWdTdGFydFwiLCBwKSA9PT0gITEpIHtcbiAgICAgICAgVCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBTLnByZXZlbnREZWZhdWx0KCksIHouc3RhcnRFdmVudCA9IFM7XG4gICAgfSkub24oXCJkcmFnXCIsIChwKSA9PiB7XG4gICAgICAhdGhpcy5vcHRpb25zLnVzZVBpbmNoIHx8IHAuaXNQaW5jaCB8fCB0aGlzLnVzZU1vdXNlRHJhZyAmJiBwLmlzTW91c2VFdmVudCA/ICh0aGlzLnRyaWdnZXIoXCJkcmFnXCIsIHtcbiAgICAgICAgLi4ucCxcbiAgICAgICAgaW5wdXRFdmVudDogcC5pbnB1dEV2ZW50XG4gICAgICB9KSwgcG4ocCksIHRoaXMuc2Nyb2xsQnkoLXAuZGVsdGFYIC8gdGhpcy56b29tWCwgLXAuZGVsdGFZIC8gdGhpcy56b29tWSkpIDogIXRoaXMuZHJhZ0ZsYWcgJiYgcC5tb3ZlbWVudCA+IHIucGluY2hUaHJlc2hvbGQgJiYgKHRoaXMuZHJhZ0ZsYWcgPSAhMCwgdGhpcy50cmlnZ2VyKFwiYWJvcnRQaW5jaFwiLCB7XG4gICAgICAgIGlucHV0RXZlbnQ6IHAuZGF0YXMuc3RhcnRFdmVudCB8fCBwLmlucHV0RXZlbnRcbiAgICAgIH0pKTtcbiAgICB9KS5vbihcImRyYWdFbmRcIiwgKHApID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihcImRyYWdFbmRcIiwge1xuICAgICAgICBpc0RyYWc6IHAuaXNEcmFnLFxuICAgICAgICBpc0RvdWJsZTogcC5pc0RvdWJsZSxcbiAgICAgICAgaW5wdXRFdmVudDogcC5pbnB1dEV2ZW50XG4gICAgICB9KSwgdGhpcy5fc3RhcnRTY3JvbGxBbmltYXRpb25CeVNwZWVkKHAuZGF0YXMuc3BlZWQpO1xuICAgIH0pLm9uKFwicGluY2hTdGFydFwiLCAoeyBpbnB1dEV2ZW50OiBwLCBkYXRhczogUywgc3RvcDogVCB9KSA9PiB7XG4gICAgICBwLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3BhdXNlU2Nyb2xsQW5pbWF0aW9uKCksIFMuc3RhcnRab29tID0gW3RoaXMuem9vbVgsIHRoaXMuem9vbVldLCB0aGlzLnRyaWdnZXIoXCJwaW5jaFN0YXJ0XCIsIHtcbiAgICAgICAgaW5wdXRFdmVudDogcFxuICAgICAgfSkgPT09ICExICYmIFQoKSwgdGhpcy5fc2V0Q2xpZW50UmVjdCgpO1xuICAgIH0pLm9uKFwicGluY2hcIiwgKHApID0+IHtcbiAgICAgIGNvbnN0IFMgPSBwLnNjYWxlLCBUID0gdGhpcy5vcHRpb25zLnBpbmNoRGlyZWN0aW9uO1xuICAgICAgdGhpcy5fdHJpZ2dlclBpbmNoKHtcbiAgICAgICAgcm90YXRpb246IHAucm90YXRpb24sXG4gICAgICAgIGRpc3RhbmNlOiBwLmRpc3RhbmNlLFxuICAgICAgICBzY2FsZTogcC5zY2FsZSxcbiAgICAgICAgaW5wdXRFdmVudDogcC5pbnB1dEV2ZW50LFxuICAgICAgICBpc1doZWVsOiAhMSxcbiAgICAgICAgem9vbTogcC5kYXRhcy5zdGFydFpvb20gKiBTLFxuICAgICAgICB6b29tWDogdGhpcy56b29tWCAqIChUID09PSBcInZlcnRpY2FsXCIgPyAxIDogUyksXG4gICAgICAgIHpvb21ZOiB0aGlzLnpvb21ZICogKFQgPT09IFwiaG9yaXpvbnRhbFwiID8gMSA6IFMpLFxuICAgICAgICBjbGllbnRYOiBwLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IHAuY2xpZW50WSxcbiAgICAgICAgcmF0aW9YOiAwLFxuICAgICAgICByYXRpb1k6IDBcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwicGluY2hFbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdGVtcFJlY3QgPSBudWxsO1xuICAgIH0pLCBPKGEsIFwic2Nyb2xsXCIsIHRoaXMuX29uU2Nyb2xsKSwgci51c2VSZXNpemVPYnNlcnZlcikge1xuICAgICAgY29uc3QgcCA9IG5ldyBvLlJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIH0pO1xuICAgICAgcC5vYnNlcnZlKHRoaXMuX3ZpZXdwb3J0RWxlbWVudCksIHAub2JzZXJ2ZSh0aGlzLl9jb250YWluZXJFbGVtZW50KSwgdGhpcy5fb25EZXN0cm95cy5wdXNoKCgpID0+IHtcbiAgICAgICAgcC5kaXNjb25uZWN0KCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICAgIE8obywgXCJyZXNpemVcIiwgdGhpcy5yZXNpemUpLCB0aGlzLl9vbkRlc3Ryb3lzLnB1c2goKCkgPT4ge1xuICAgICAgICBZKG8sIFwicmVzaXplXCIsIHRoaXMucmVzaXplKTtcbiAgICAgIH0pO1xuICAgIChyLnVzZVdoZWVsUGluY2ggfHwgci51c2VXaGVlbFNjcm9sbCkgJiYgTyhtLCBcIndoZWVsXCIsIHRoaXMub25XaGVlbCwge1xuICAgICAgcGFzc2l2ZTogITFcbiAgICB9KSwgci51c2VHZXN0dXJlICYmIChPKHQsIFwiZ2VzdHVyZXN0YXJ0XCIsIHRoaXMub25HZXN0dXJlU3RhcnQsIHtcbiAgICAgIHBhc3NpdmU6ICExXG4gICAgfSksIE8odCwgXCJnZXN0dXJlY2hhbmdlXCIsIHRoaXMub25HZXN0dXJlQ2hhbmdlLCB7XG4gICAgICBwYXNzaXZlOiAhMVxuICAgIH0pKSwgdGhpcy5yZXNpemUoKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0WDogdCxcbiAgICAgIG9mZnNldFk6IHIsXG4gICAgICB6b29tWDogZSA9IEkuem9vbVgsXG4gICAgICB6b29tWTogbyA9IEkuem9vbVksXG4gICAgICB0cmFuc2xhdGVaOiBhID0gMCxcbiAgICAgIHJhbmdlWDogbCxcbiAgICAgIHJhbmdlWTogaCxcbiAgICAgIGNvbnRhaW5lcldpZHRoOiB1LFxuICAgICAgY29udGFpbmVySGVpZ2h0OiBkXG4gICAgfSA9IHRoaXMsIHsgdXNlVHJhbnNmb3JtOiB2ID0gSS51c2VUcmFuc2Zvcm0gfSA9IHRoaXMub3B0aW9ucztcbiAgICBsZXQgYyA9IC10ICogZSwgbSA9IC1yICogbztcbiAgICB0aGlzLnNjcm9sbEFyZWFFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgd2lkdGg6Y2FsYygxMDAlICsgJHt0aGlzLmdldFNjcm9sbEFyZWFXaWR0aCgpfXB4KTtoZWlnaHQ6Y2FsYygxMDAlICsgJHt0aGlzLmdldFNjcm9sbEFyZWFIZWlnaHQoKX1weCk7YDtcbiAgICBjb25zdCBwID0gdGhpcy5fdmlld3BvcnRFbGVtZW50LnN0eWxlO1xuICAgIHYgPT09ICExID8gcC5jc3NUZXh0ICs9IGBwb3NpdGlvbjogcmVsYXRpdmU7IGxlZnQ6ICR7Y31weDsgdG9wOiAke219cHg7IGAgOiBwLmNzc1RleHQgKz0gYHRyYW5zZm9ybS1vcmlnaW46IDAgMDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoJHtjfXB4LCAke219cHgsICR7YX1weCkgc2NhbGUoJHtlfSwgJHtvfSk7YCwgdGhpcy5yZW5kZXJTY3JvbGwoKTtcbiAgfVxuICByZW5kZXJTY3JvbGwoKSB7XG4gICAgY29uc3QgeyB6b29tWDogdCwgem9vbVk6IHIsIGNvbnRhaW5lcldpZHRoOiBlLCBjb250YWluZXJIZWlnaHQ6IG8gfSA9IHRoaXMsIGEgPSB0aGlzLmhvcml6b250YWxTY3JvbGxiYXIsIGwgPSB0aGlzLnZlcnRpY2FsU2Nyb2xsYmFyO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudXNlQm91bmNlU2Nyb2xsQmFyKSB7XG4gICAgICBjb25zdCBoID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCEwKSAqIHQsIHUgPSB0aGlzLmdldFJhbmdlWCghMCksIGQgPSBlICsgVSh1WzBdKSArIFUodVsxXSksIHYgPSB0aGlzLmdldFNjcm9sbFRvcCghMCkgKiByLCBjID0gdGhpcy5nZXRSYW5nZVkoITApLCBtID0gbyArIFUoY1swXSkgKyBVKGNbMV0pO1xuICAgICAgYS5yZW5kZXIoXG4gICAgICAgIHRoaXMuZGlzcGxheUhvcml6b250YWxTY3JvbGwsXG4gICAgICAgIGgsXG4gICAgICAgIGUsXG4gICAgICAgIGRcbiAgICAgICksIGwucmVuZGVyKFxuICAgICAgICB0aGlzLmRpc3BsYXlWZXJ0aWNhbFNjcm9sbCxcbiAgICAgICAgdixcbiAgICAgICAgbyxcbiAgICAgICAgbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaCA9IHRoaXMuX2dldFNjcm9sbFJhbmdlWCgpLCB1ID0gdGhpcy5fZ2V0U2Nyb2xsUmFuZ2VZKCksIGQgPSB0aGlzLmdldFNjcm9sbExlZnQoKSwgdiA9IHRoaXMuZ2V0U2Nyb2xsVG9wKCksIGMgPSB0aGlzLmNvbnRhaW5lcldpZHRoICsgVShoWzBdKSArIGhbMV0sIG0gPSB0aGlzLmNvbnRhaW5lckhlaWdodCArIFUodVswXSkgKyB1WzFdO1xuICAgICAgYS5yZW5kZXIoXG4gICAgICAgIHRoaXMuZGlzcGxheUhvcml6b250YWxTY3JvbGwsXG4gICAgICAgIGQgLSBoWzBdLFxuICAgICAgICBlLFxuICAgICAgICBjXG4gICAgICApLCBsLnJlbmRlcihcbiAgICAgICAgdGhpcy5kaXNwbGF5VmVydGljYWxTY3JvbGwsXG4gICAgICAgIHYgLSB1WzBdLFxuICAgICAgICBvLFxuICAgICAgICBtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBtb3ZlKHQsIHIpIHtcbiAgICBjb25zdCBlID0gdGhpcy53cmFwcGVyRWxlbWVudDtcbiAgICBlLnNjcm9sbExlZnQgPSB0LCBlLnNjcm9sbFRvcCA9IHI7XG4gIH1cbiAgc2V0RGlzcGxheVZlcnRpY2FsU2Nyb2xsKHQpIHtcbiAgICB0aGlzLm9wdGlvbnMuZGlzcGxheVZlcnRpY2FsU2Nyb2xsID0gdCwgdGhpcy5yZW5kZXJTY3JvbGwoKTtcbiAgfVxuICBzZXREaXNwbGF5SG9yaXpvbnRhbFNjcm9sbCh0KSB7XG4gICAgdGhpcy5vcHRpb25zLmRpc3BsYXlIb3Jpem9udGFsU2Nyb2xsID0gdCwgdGhpcy5yZW5kZXJTY3JvbGwoKTtcbiAgfVxuICBfc3RhcnRab29tQW5pbWF0aW9uKHQsIHIpIHtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHIuZHVyYXRpb24sIG8gPSByLmVhc2luZyB8fCBDZTtcbiAgICBSZShcbiAgICAgIChhKSA9PiB0aGlzLl9zZXRab29tKFxuICAgICAgICBbdGhpcy56b29tWCArIHRbMF0gKiBhLCB0aGlzLnpvb21ZICsgdFsxXSAqIGFdLFxuICAgICAgICByXG4gICAgICApLFxuICAgICAgKGEpID0+IHtcbiAgICAgICAgdGhpcy5fem9vbVRpbWVyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGEpO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZWFzaW5nOiBvLFxuICAgICAgICBkdXJhdGlvbjogZVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX3N0YXJ0U2Nyb2xsQW5pbWF0aW9uKHQsIHIpIHtcbiAgICBpZiAoIXRbMF0gJiYgIXRbMV0pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHIuZHVyYXRpb24sIG8gPSByLmVhc2luZyB8fCBDZTtcbiAgICBSZShcbiAgICAgIChhKSA9PiB0aGlzLl9zY3JvbGxCeSh0WzBdICogYSwgdFsxXSAqIGEsIHIpLFxuICAgICAgKGEpID0+IHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVGltZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYSk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBlYXNpbmc6IG8sXG4gICAgICAgIGR1cmF0aW9uOiBlXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfc3RhcnRTY3JvbGxBbmltYXRpb25CeVNwZWVkKHQpIHtcbiAgICBpZiAoIXQgfHwgIXRbMF0gJiYgIXRbMV0pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IC02ZS00LCBlID0gS2UodCwgciksIG8gPSBnbih0LCByKTtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRTY3JvbGxBbmltYXRpb24obywge1xuICAgICAgZHVyYXRpb246IGVcbiAgICB9KTtcbiAgfVxuICBfcGF1c2VTY3JvbGxBbmltYXRpb24oKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fc2Nyb2xsVGltZXIpLCB0aGlzLl9zY3JvbGxUaW1lciA9IDA7XG4gIH1cbiAgX3BhdXNlWm9vbUFuaW1hdGlvbigpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl96b29tVGltZXIpLCB0aGlzLl96b29tVGltZXIgPSAwO1xuICB9XG4gIGdldFNjcm9sbEFyZWFXaWR0aCgpIHtcbiAgICBjb25zdCBbdCwgcl0gPSB0aGlzLmdldFJhbmdlWCghMCk7XG4gICAgcmV0dXJuIHQgfHwgciA/IHRoaXMubWFyZ2luICogMiA6IDA7XG4gIH1cbiAgZ2V0U2Nyb2xsQXJlYUhlaWdodCgpIHtcbiAgICBjb25zdCBbdCwgcl0gPSB0aGlzLmdldFJhbmdlWSghMCk7XG4gICAgcmV0dXJuIHQgfHwgciA/IHRoaXMubWFyZ2luICogMiA6IDA7XG4gIH1cbiAgX3RyaWdnZXJQaW5jaCh0KSB7XG4gICAgY29uc3QgeyBjbGllbnRYOiByLCBjbGllbnRZOiBlLCB6b29tWDogbywgem9vbVk6IGEgfSA9IHQ7XG4gICAgdGhpcy51c2VBdXRvWm9vbSAmJiB0aGlzLl96b29tQnlDbGllbnQoW28sIGFdLCByLCBlKSwgdGhpcy5fdGVtcFJlY3QgfHwgdGhpcy5fc2V0Q2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGwgPSB0aGlzLnpvb21SYW5nZSwgaCA9IHRoaXMuem9vbVJhbmdlWCB8fCBsLCB1ID0gdGhpcy56b29tUmFuZ2VZIHx8IGwsIHsgbGVmdDogZCwgdG9wOiB2LCB3aWR0aDogYywgaGVpZ2h0OiBtIH0gPSB0aGlzLl90ZW1wUmVjdCwgcCA9IChyIC0gZCkgLyBjICogMTAwLCBTID0gKGUgLSB2KSAvIG0gKiAxMDA7XG4gICAgdGhpcy50cmlnZ2VyKFwicGluY2hcIiwge1xuICAgICAgLi4udCxcbiAgICAgIHpvb206IHR0KChvICsgYSkgLyAyLCBsWzBdLCBsWzFdKSxcbiAgICAgIHpvb21YOiB0dChvLCBoWzBdLCBoWzFdKSxcbiAgICAgIHpvb21ZOiB0dChhLCB1WzBdLCB1WzFdKSxcbiAgICAgIHJhdGlvWDogcCxcbiAgICAgIHJhdGlvWTogU1xuICAgIH0pO1xuICB9XG4gIF9zZXRDbGllbnRSZWN0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldENvbnRhaW5lcigpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX3RlbXBSZWN0ID0ge1xuICAgICAgbGVmdDogdC5sZWZ0LFxuICAgICAgdG9wOiB0LnRvcCxcbiAgICAgIHdpZHRoOiB0LndpZHRoLFxuICAgICAgaGVpZ2h0OiB0LmhlaWdodFxuICAgIH07XG4gIH1cbiAgX3pvb21CeUNsaWVudCh0LCByLCBlKSB7XG4gICAgdGhpcy5fdGVtcFJlY3QgfHwgdGhpcy5fc2V0Q2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHsgbGVmdDogbywgdG9wOiBhLCB3aWR0aDogbCwgaGVpZ2h0OiBoIH0gPSB0aGlzLl90ZW1wUmVjdCwgdSA9IHRoaXMub3B0aW9ucywgZCA9IHUuem9vbU9mZnNldFgsIHYgPSB1Lnpvb21PZmZzZXRZO1xuICAgIHUuem9vbU9mZnNldFggPSBgJHsociAtIG8pIC8gbCAqIDEwMH0lYCwgdS56b29tT2Zmc2V0WSA9IGAkeyhlIC0gYSkgLyBoICogMTAwfSVgLCB0aGlzLl9zZXRab29tKHQsIHtcbiAgICAgIHpvb21CYXNlOiBcInNjcmVlblwiXG4gICAgfSksIHUuem9vbU9mZnNldFggPSBkLCB1Lnpvb21PZmZzZXRZID0gdjtcbiAgfVxuICBfc2V0Wm9vbSh0LCByID0ge30pIHtcbiAgICBjb25zdCBlID0gci56b29tQmFzZSwge1xuICAgICAgY29udGFpbmVyV2lkdGg6IG8sXG4gICAgICBjb250YWluZXJIZWlnaHQ6IGEsXG4gICAgICB6b29tWDogbCxcbiAgICAgIHpvb21ZOiBoLFxuICAgICAgem9vbVJhbmdlOiB1XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHpvb21PZmZzZXRYOiBkID0gSS56b29tT2Zmc2V0WCxcbiAgICAgIHpvb21PZmZzZXRZOiB2ID0gSS56b29tT2Zmc2V0WVxuICAgIH0gPSB0aGlzO1xuICAgIFwiem9vbU9mZnNldFhcIiBpbiByICYmIChkID0gci56b29tT2Zmc2V0WCksIFwiem9vbU9mZnNldFlcIiBpbiByICYmICh2ID0gci56b29tT2Zmc2V0WSk7XG4gICAgY29uc3QgYyA9IHRoaXMuZ2V0U2Nyb2xsTGVmdCgpLCBtID0gdGhpcy5nZXRTY3JvbGxUb3AoKSwgW3AsIFNdID0gdnQodCkgPyB0IDogW3QsIHRdLCBUID0gdGhpcy56b29tUmFuZ2VYIHx8IHUsIHogPSB0aGlzLnpvb21SYW5nZVkgfHwgdSwgYiA9IHR0KHAsIFRbMF0sIFRbMV0pLCBXID0gdHQoUywgelswXSwgelsxXSksIGsgPSB0aGlzLm9wdGlvbnM7XG4gICAgay56b29tWCA9IGIsIGsuem9vbVkgPSBXLCBrLnpvb20gPSAoYiArIFcpIC8gMjtcbiAgICBjb25zdCBIID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCksIFYgPSB0aGlzLmdldFNjcm9sbFRvcCgpO1xuICAgIGxldCBDID0gMCwgUCA9IDA7XG4gICAgZSA9PT0gXCJmaXhlZFwiID8gKEMgPSBHKGAke2R9YCwgdGhpcy52aWV3cG9ydFdpZHRoKSwgUCA9IEcoYCR7dn1gLCB0aGlzLnZpZXdwb3J0SGVpZ2h0KSkgOiBlID09PSBcInZpZXdwb3J0XCIgPyAoQyA9ICgtYyArIEcoYCR7ZH1gLCB0aGlzLnZpZXdwb3J0V2lkdGgpKSAqIGwsIFAgPSAoLW0gKyBHKGAke3Z9YCwgdGhpcy52aWV3cG9ydEhlaWdodCkpICogaCkgOiAoQyA9IEcoYCR7ZH1gLCBvKSwgUCA9IEcoYCR7dn1gLCBhKSk7XG4gICAgY29uc3QgTCA9IGMgKyBDIC8gbCwgcSA9IG0gKyBQIC8gaCwgWiA9IEggKyBDIC8gYiwgRiA9IFYgKyBQIC8gVztcbiAgICB0aGlzLl9zY3JvbGxCeShMIC0gWiwgcSAtIEYsIHtcbiAgICAgIHpvb206ICEhKGIgLSBsIHx8IFcgLSBoKVxuICAgIH0pLCB0aGlzLnJlbmRlcigpO1xuICB9XG4gIF9zY3JvbGxCeSh0LCByLCBlKSB7XG4gICAgbGV0IG8gPSB0aGlzLmdldFNjcm9sbExlZnQoKSwgYSA9IHRoaXMuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgcmV0dXJuIGUgIT0gbnVsbCAmJiBlLmFic29sdXRlICYmIChvICo9IHRoaXMuem9vbVgsIGEgKj0gdGhpcy56b29tWSksIHRoaXMuX3Njcm9sbFRvKG8gKyB0LCBhICsgciwgZSk7XG4gIH1cbiAgX3Njcm9sbFRvKHQsIHIsIGUpIHtcbiAgICBjb25zdCB7IHNjcm9sbExlZnQ6IG8sIHNjcm9sbFRvcDogYSB9ID0gdGhpcywgbCA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuYWJzb2x1dGU7XG4gICAgdGhpcy5fc2Nyb2xsVG9UeXBlKFwiaG9yaXpvbnRhbFwiLCB0LCBsKSwgdGhpcy5fc2Nyb2xsVG9UeXBlKFwidmVydGljYWxcIiwgciwgbCk7XG4gICAgY29uc3QgaCA9IHRoaXMuc2Nyb2xsTGVmdCwgdSA9IHRoaXMuc2Nyb2xsVG9wO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gICAgY29uc3QgZCA9IHRoaXMuZ2V0U2Nyb2xsTGVmdCgpLCB2ID0gdGhpcy5nZXRTY3JvbGxUb3AoKTtcbiAgICByZXR1cm4gdGhpcy5fZW1pdFNjcm9sbEV2ZW50KFxuICAgICAgZCxcbiAgICAgIHYsXG4gICAgICBlID09IG51bGwgPyB2b2lkIDAgOiBlLnpvb21cbiAgICApLCBNYXRoLnJvdW5kKG8pICE9PSBoIHx8IE1hdGgucm91bmQoYSkgIT09IHUgPyAodGhpcy5pc0xvb3AgPSAhMCwgdGhpcy5tb3ZlKGgsIHUpLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzTG9vcClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5pc0xvb3AgPSAhMTtcbiAgICAgIGNvbnN0IHsgc2Nyb2xsTGVmdDogYywgc2Nyb2xsVG9wOiBtIH0gPSB0aGlzLndyYXBwZXJFbGVtZW50O1xuICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gYywgdGhpcy5zY3JvbGxUb3AgPSBtLCAoaCAhPT0gTWF0aC5yb3VuZChjKSB8fCB1ICE9PSBNYXRoLnJvdW5kKG0pKSAmJiB0aGlzLl9zY3JvbGxUbyhkLCB2KTtcbiAgICB9KSwgITEpIDogITA7XG4gIH1cbiAgX3Njcm9sbFRvVHlwZSh0LCByLCBlKSB7XG4gICAgY29uc3QgbyA9IFRlW3RdLCB7XG4gICAgICBtYXJnaW46IGEgPSBJLm1hcmdpbixcbiAgICAgIHRocmVzaG9sZDogbCA9IEkudGhyZXNob2xkXG4gICAgfSA9IHRoaXMsIGggPSB0aGlzW2BzY3JvbGwke28ucG9zfWBdLCBbdSwgZF0gPSB0aGlzW2BnZXRSYW5nZSR7by5jb29yZH1gXSghMCwgITApO1xuICAgIGxldCB2ID0gTWF0aC5yb3VuZChoKTtcbiAgICBjb25zdCBjID0gdGhpc1tgZ2V0U2Nyb2xsQXJlYSR7by5zaXplfWBdKCksIG0gPSB0aGlzW2B6b29tJHtvLmNvb3JkfWBdO1xuICAgIGUgJiYgKHIgPSByIC8gbSk7XG4gICAgY29uc3QgcCA9IHIgKiBtO1xuICAgIGlmICh1ID09PSBkKVxuICAgICAgdiA9IHUsIHIgPSB1IC8gbTtcbiAgICBlbHNlIGlmIChwIC0gbCA8PSB1KSB7XG4gICAgICBjb25zdCBTID0gTWF0aC5tYXgoMCwgcCAtIHUpO1xuICAgICAgdiA9IFMsIHIgPSAodSArIFMpIC8gbTtcbiAgICB9IGVsc2UgaWYgKHAgKyBsID49IGQpIHtcbiAgICAgIGNvbnN0IFMgPSBNYXRoLm1heCgwLCBkIC0gcCk7XG4gICAgICB2ID0gYyAtIFMsIHIgPSAoZCAtIFMpIC8gbTtcbiAgICB9IGVsc2UgdiA8IGwgPyB2ICs9IGEgOiB2ID4gYyAtIGwgJiYgKHYgLT0gYSk7XG4gICAgdiA9IE1hdGgucm91bmQodiksIHRoaXNbYHNjcm9sbCR7by5wb3N9YF0gPSB2LCB0aGlzW2BvZmZzZXQke28uY29vcmR9YF0gPSByIC0gdiAvIG07XG4gIH1cbiAgX2dldFJhbmdlQ29vcmQodCwgciwgZSkge1xuICAgIGNvbnN0IHsgbWFyZ2luOiBvID0gSS5tYXJnaW4sIHRocmVzaG9sZDogYSB9ID0gdGhpcywgbCA9IFRlW3RdLCBoID0gemUoXG4gICAgICB0aGlzW2ByYW5nZSR7bC5jb29yZH1gXSxcbiAgICAgIElbYHJhbmdlJHtsLmNvb3JkfWBdXG4gICAgKSwgdSA9IHplKFxuICAgICAgdGhpc1tgcmFuZ2VPZmZzZXQke2wuY29vcmR9YF0sXG4gICAgICBJW2ByYW5nZU9mZnNldCR7bC5jb29yZH1gXVxuICAgICksIGQgPSB0aGlzW2B6b29tJHtsLmNvb3JkfWBdLCB2ID0gbW4oXG4gICAgICB0aGlzW2BnZXRTY3JvbGwke2wucG9zfWBdKCksXG4gICAgICBvLFxuICAgICAgaCxcbiAgICAgIGEsXG4gICAgICBlXG4gICAgKTtcbiAgICByZXR1cm4gciA/IFtcbiAgICAgIHZbMF0gKiBkICsgdVswXSxcbiAgICAgIHRoaXMub3B0aW9ucy51c2VPdmVyZmxvd1Njcm9sbCA/IE1hdGgubWF4KFxuICAgICAgICB0aGlzW2B2aWV3cG9ydCR7bC5zaXplfWBdICogZCAtIHRoaXNbYGNvbnRhaW5lciR7bC5zaXplfWBdLFxuICAgICAgICB2WzFdICogZCArIHVbMV1cbiAgICAgICkgOiB2WzFdICogZCArIHVbMV1cbiAgICBdIDogW3ZbMF0gKyB1WzBdLCB2WzFdICsgdVsxXV07XG4gIH1cbiAgX2VtaXRTY3JvbGxFdmVudCh0LCByLCBlKSB7XG4gICAgY29uc3QgbyA9IHRoaXMuX2FzTGVmdCwgYSA9IHRoaXMuX2FzVG9wO1xuICAgICFlICYmIG8gPT09IHQgJiYgYSA9PT0gciB8fCAodGhpcy5fYXNMZWZ0ID0gdCwgdGhpcy5fYXNUb3AgPSByLCB0aGlzLnRyaWdnZXIoXCJzY3JvbGxcIiwge1xuICAgICAgc2Nyb2xsTGVmdDogdCxcbiAgICAgIHNjcm9sbFRvcDogcixcbiAgICAgIHpvb21YOiB0aGlzLnpvb21YLFxuICAgICAgem9vbVk6IHRoaXMuem9vbVlcbiAgICB9KSk7XG4gIH1cbiAgX2dldFNjcm9sbFJhbmdlWCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCksIHIgPSB0aGlzLnJhbmdlWCwgZSA9IHJbMF07XG4gICAgbGV0IG8gPSByWzFdO1xuICAgIHRoaXMudXNlT3ZlcmZsb3dTY3JvbGwgJiYgaXNGaW5pdGUobykgJiYgKG8gPSBNYXRoLm1heChcbiAgICAgIG8sXG4gICAgICB0aGlzLnZpZXdwb3J0V2lkdGggLSB0aGlzLmNvbnRhaW5lcldpZHRoIC8gdGhpcy56b29tWFxuICAgICkpO1xuICAgIGNvbnN0IGEgPSBNYXRoLm1pbihcbiAgICAgIDAsXG4gICAgICBpc0Zpbml0ZShlKSA/IE1hdGgubWluKGUsIHQpIDogdFxuICAgICksIGwgPSBNYXRoLm1heChcbiAgICAgIDAsXG4gICAgICBpc0Zpbml0ZShvKSA/IE1hdGgubWF4KG8sIHQpIDogdFxuICAgICksIGggPSB0aGlzLnZpZXdwb3J0U2Nyb2xsV2lkdGgsIHUgPSBNYXRoLm1heCh0aGlzLmNvbnRhaW5lcldpZHRoIC8gdGhpcy56b29tWCwgaCkgLSBoO1xuICAgIHJldHVybiBbTWF0aC5taW4oMCwgdSArIGEpLCBsXTtcbiAgfVxuICBfZ2V0U2Nyb2xsUmFuZ2VZKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFNjcm9sbFRvcCgpLCByID0gdGhpcy5yYW5nZVksIGUgPSByWzBdO1xuICAgIGxldCBvID0gclsxXTtcbiAgICB0aGlzLnVzZU92ZXJmbG93U2Nyb2xsICYmIGlzRmluaXRlKG8pICYmIChvID0gTWF0aC5tYXgoXG4gICAgICBvLFxuICAgICAgdGhpcy52aWV3cG9ydEhlaWdodCAtIHRoaXMuY29udGFpbmVySGVpZ2h0IC8gdGhpcy56b29tWVxuICAgICkpO1xuICAgIGNvbnN0IGEgPSBNYXRoLm1pbihcbiAgICAgIDAsXG4gICAgICBpc0Zpbml0ZShlKSA/IE1hdGgubWluKGUsIHQpIDogdFxuICAgICksIGwgPSBNYXRoLm1heChcbiAgICAgIDAsXG4gICAgICBpc0Zpbml0ZShvKSA/IE1hdGgubWF4KG8sIHQpIDogdFxuICAgICksIGggPSB0aGlzLnZpZXdwb3J0U2Nyb2xsSGVpZ2h0LCB1ID0gTWF0aC5tYXgodGhpcy5jb250YWluZXJIZWlnaHQgLyB0aGlzLnpvb21ZLCBoKSAtIGg7XG4gICAgcmV0dXJuIFtNYXRoLm1pbigwLCB1ICsgYSksIGxdO1xuICB9XG59O1xuSHQuYWRkUHJvcGVydGllcyhHdCwgSHQucHJvdG90eXBlKTtcbmxldCBfbiA9IGNsYXNzIGV4dGVuZHMgSHQge1xufTtcbmNvbnN0IFllID0gR2UubWFwKChpKSA9PiBBZShgb24gJHtpfWApKTtcbmNsYXNzIENuIGV4dGVuZHMgUnIuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgXyh0aGlzLCBcImluZmluaXRlVmlld2VyXCIpO1xuICAgIF8odGhpcywgXCJjb250YWluZXJFbGVtZW50XCIpO1xuICAgIF8odGhpcywgXCJ3cmFwcGVyRWxlbWVudFwiKTtcbiAgICBfKHRoaXMsIFwic2Nyb2xsQXJlYUVsZW1lbnRcIik7XG4gICAgXyh0aGlzLCBcImhvcml6b250YWxTY3JvbGxFbGVtZW50XCIpO1xuICAgIF8odGhpcywgXCJ2ZXJ0aWNhbFNjcm9sbEVsZW1lbnRcIik7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnByb3BzLmNsYXNzTmFtZTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFEuanN4cyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogYCR7dCB8fCBcIlwifSAke3FlfWAsXG4gICAgICAgIHJlZjogZHQodGhpcywgXCJjb250YWluZXJFbGVtZW50XCIpLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBRLmpzeHMoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaW5maW5pdGUtdmlld2VyLXdyYXBwZXJcIixcbiAgICAgICAgICAgICAgcmVmOiBkdCh0aGlzLCBcIndyYXBwZXJFbGVtZW50XCIpLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBRLmpzeChcbiAgICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJpbmZpbml0ZS12aWV3ZXItc2Nyb2xsLWFyZWFcIixcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBkdCh0aGlzLCBcInNjcm9sbEFyZWFFbGVtZW50XCIpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBRLmpzeChcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJpbmZpbml0ZS12aWV3ZXItc2Nyb2xsLWJhciBpbmZpbml0ZS12aWV3ZXItaG9yaXpvbnRhbC1zY3JvbGwtYmFyXCIsXG4gICAgICAgICAgICAgIHJlZjogZHQodGhpcywgXCJob3Jpem9udGFsU2Nyb2xsRWxlbWVudFwiKSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBRLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJpbmZpbml0ZS12aWV3ZXItc2Nyb2xsLXRodW1iXCIgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBRLmpzeChcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJpbmZpbml0ZS12aWV3ZXItc2Nyb2xsLWJhciBpbmZpbml0ZS12aWV3ZXItdmVydGljYWwtc2Nyb2xsLWJhclwiLFxuICAgICAgICAgICAgICByZWY6IGR0KHRoaXMsIFwidmVydGljYWxTY3JvbGxFbGVtZW50XCIpLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIFEuanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImluZmluaXRlLXZpZXdlci1zY3JvbGwtdGh1bWJcIiB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMucHJvcHMsIHIgPSB7fTtcbiAgICB2bi5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlIGluIHQgJiYgdHlwZW9mIHRbZV0gPCBcInVcIiAmJiAocltlXSA9IHRbZV0pO1xuICAgIH0pLCB0aGlzLmluZmluaXRlVmlld2VyID0gbmV3IF9uKFxuICAgICAgdGhpcy5jb250YWluZXJFbGVtZW50LFxuICAgICAgdGhpcy5zY3JvbGxBcmVhRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICB7XG4gICAgICAgIC4uLnIsXG4gICAgICAgIHdyYXBwZXJFbGVtZW50OiB0aGlzLndyYXBwZXJFbGVtZW50LFxuICAgICAgICBzY3JvbGxBcmVhRWxlbWVudDogdGhpcy5zY3JvbGxBcmVhRWxlbWVudCxcbiAgICAgICAgaG9yaXpvbnRhbFNjcm9sbEVsZW1lbnQ6IHRoaXMuaG9yaXpvbnRhbFNjcm9sbEVsZW1lbnQsXG4gICAgICAgIHZlcnRpY2FsU2Nyb2xsRWxlbWVudDogdGhpcy52ZXJ0aWNhbFNjcm9sbEVsZW1lbnRcbiAgICAgIH1cbiAgICApLCBHZS5mb3JFYWNoKChlLCBvKSA9PiB7XG4gICAgICB0aGlzLmluZmluaXRlVmlld2VyLm9uKGUsIChhKSA9PiB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLnByb3BzO1xuICAgICAgICAobFtZZVtvXV0gJiYgbFtZZVtvXV0oYSkpID09PSAhMSAmJiBhLnN0b3AoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5wcm9wcywgciA9IHRoaXMuaW5maW5pdGVWaWV3ZXI7XG4gICAgR3QuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZSBpbiB0ICYmIHJbZV0gIT09IHRbZV0gJiYgKHJbZV0gPSB0W2VdKTtcbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmluZmluaXRlVmlld2VyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckVsZW1lbnQ7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIHFlIGFzIENMQVNTX05BTUUsXG4gIEdlIGFzIEVWRU5UUyxcbiAgd24gYXMgTUVUSE9EUyxcbiAgdm4gYXMgT1BUSU9OUyxcbiAgR3QgYXMgUFJPUEVSVElFUyxcbiAgQ24gYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@interactify/infinite-viewer/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@interactify/moveable/dist/index.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/@interactify/moveable/dist/index.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Clippable: () => (/* binding */ tf),\n/* harmony export */   DIRECTIONS: () => (/* binding */ Xr),\n/* harmony export */   Draggable: () => (/* binding */ Ot),\n/* harmony export */   EdgeDraggable: () => (/* binding */ Rf),\n/* harmony export */   InitialMoveable: () => (/* binding */ on),\n/* harmony export */   MOVEABLE_ABLES: () => (/* binding */ Ps),\n/* harmony export */   MOVEABLE_EVENTS: () => (/* binding */ Bf),\n/* harmony export */   MOVEABLE_METHODS: () => (/* binding */ wf),\n/* harmony export */   MOVEABLE_PROPS: () => (/* binding */ zf),\n/* harmony export */   Pinchable: () => (/* binding */ bu),\n/* harmony export */   Resizable: () => (/* binding */ Tr),\n/* harmony export */   Rotatable: () => (/* binding */ wl),\n/* harmony export */   Roundable: () => (/* binding */ of),\n/* harmony export */   Scalable: () => (/* binding */ yu),\n/* harmony export */   Snappable: () => (/* binding */ su),\n/* harmony export */   Warpable: () => (/* binding */ Mu),\n/* harmony export */   calculateElementPosition: () => (/* binding */ ke),\n/* harmony export */   \"default\": () => (/* binding */ _f),\n/* harmony export */   getElementInfo: () => (/* binding */ If),\n/* harmony export */   makeAble: () => (/* binding */ dn),\n/* harmony export */   makeMoveable: () => (/* binding */ Gf)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar $a = Object.defineProperty;\nvar Fa = (t, e, n) => e in t ? $a(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;\nvar X = (t, e, n) => Fa(t, typeof e != \"symbol\" ? e + \"\" : e, n);\n\n\nfunction dn(t, e) {\n  return {\n    events: [],\n    props: [],\n    name: t,\n    ...e\n  };\n}\nfunction Vr(t, e) {\n  for (var n = t.length, r = 0; r < n; ++r)\n    if (e(t[r], r))\n      return !0;\n  return !1;\n}\nfunction Oo(t, e) {\n  for (var n = t.length, r = 0; r < n; ++r)\n    if (e(t[r], r))\n      return t[r];\n  return null;\n}\nfunction wo(t) {\n  var e = t;\n  if (typeof e > \"u\") {\n    if (typeof navigator > \"u\" || !navigator)\n      return \"\";\n    e = navigator.userAgent || \"\";\n  }\n  return e.toLowerCase();\n}\nfunction jr(t, e) {\n  try {\n    return new RegExp(t, \"g\").exec(e);\n  } catch {\n    return null;\n  }\n}\nfunction Va() {\n  if (typeof navigator > \"u\" || !navigator || !navigator.userAgentData)\n    return !1;\n  var t = navigator.userAgentData, e = t.brands || t.uaList;\n  return !!(e && e.length);\n}\nfunction ja(t, e) {\n  var n = jr(\"(\" + t + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", e);\n  return n ? n[3] : \"\";\n}\nfunction Sr(t) {\n  return t.replace(/_/g, \".\");\n}\nfunction Ke(t, e) {\n  var n = null, r = \"-1\";\n  return Vr(t, function(s) {\n    var o = jr(\"(\" + s.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", e);\n    return !o || s.brand ? !1 : (n = s, r = o[3] || \"-1\", s.versionAlias ? r = s.versionAlias : s.versionTest && (r = ja(s.versionTest.toLowerCase(), e) || r), r = Sr(r), !0);\n  }), {\n    preset: n,\n    version: r\n  };\n}\nfunction xn(t, e) {\n  var n = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  return Vr(t, function(r) {\n    var s = Io(e, r);\n    return s ? (n.brand = r.id, n.version = r.versionAlias || s.version, n.version !== \"-1\") : !1;\n  }), n;\n}\nfunction Io(t, e) {\n  return Oo(t, function(n) {\n    var r = n.brand;\n    return jr(\"\" + e.test, r.toLowerCase());\n  });\n}\nvar Bo = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}], zo = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: !0\n}], Er = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}], Ao = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  // test webview\n  test: \"webview\",\n  id: \"webview\"\n}], Go = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\nfunction ko(t) {\n  return !!Ke(Ao, t).preset;\n}\nfunction Xa(t) {\n  var e = wo(t), n = !!/mobi/g.exec(e), r = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: ko(e),\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webkit: !1,\n    webkitVersion: \"-1\"\n  }, s = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  }, o = Ke(Bo, e), i = o.preset, a = o.version, c = Ke(Go, e), l = c.preset, u = c.version, f = Ke(zo, e);\n  if (r.chromium = !!f.preset, r.chromiumVersion = f.version, !r.chromium) {\n    var d = Ke(Er, e);\n    r.webkit = !!d.preset, r.webkitVersion = d.version;\n  }\n  return l && (s.name = l.id, s.version = u, s.majorVersion = parseInt(u, 10)), i && (r.name = i.id, r.version = a, r.webview && s.name === \"ios\" && r.name !== \"safari\" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {\n    browser: r,\n    os: s,\n    isMobile: n,\n    isHints: !1\n  };\n}\nfunction Ha(t) {\n  var e = navigator.userAgentData, n = (e.uaList || e.brands).slice(), r = e.mobile || !1, s = n[0], o = (e.platform || navigator.platform).toLowerCase(), i = {\n    name: s.brand,\n    version: s.version,\n    majorVersion: -1,\n    webkit: !1,\n    webkitVersion: \"-1\",\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webview: !!xn(Ao, n).brand || ko(wo())\n  }, a = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  i.webkit = !i.chromium && Vr(Er, function(d) {\n    return Io(n, d);\n  });\n  var c = xn(zo, n);\n  if (i.chromium = !!c.brand, i.chromiumVersion = c.version, !i.chromium) {\n    var l = xn(Er, n);\n    i.webkit = !!l.brand, i.webkitVersion = l.version;\n  }\n  var u = Oo(Go, function(d) {\n    return new RegExp(\"\" + d.test, \"g\").exec(o);\n  });\n  a.name = u ? u.id : \"\";\n  {\n    var f = xn(Bo, n);\n    i.name = f.brand || i.name, i.version = f.brand && t ? t.uaFullVersion : f.version;\n  }\n  return i.webkit && (a.name = r ? \"ios\" : \"mac\"), a.name === \"ios\" && i.webview && (i.version = \"-1\"), a.version = Sr(a.version), i.version = Sr(i.version), a.majorVersion = parseInt(a.version, 10), i.majorVersion = parseInt(i.version, 10), {\n    browser: i,\n    os: a,\n    isMobile: r,\n    isHints: !0\n  };\n}\nfunction qa(t) {\n  return Va() ? Ha() : Xa(t);\n}\nconst Ua = [\"n\", \"w\", \"s\", \"e\"], Xr = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\nfunction Ka(t, e) {\n  return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * t}px\" height=\"${32 * t}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${e}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction Za(t) {\n  const e = Ka(1, t), n = Math.round(t / 45) * 45 % 180;\n  let r = \"ns-resize\";\n  return n === 135 ? r = \"nwse-resize\" : n === 45 ? r = \"nesw-resize\" : n === 90 && (r = \"ew-resize\"), `cursor:${r};cursor: url('${e}') 16 16, ${r};`;\n}\nconst Ye = qa(), $o = Ye.browser.webkit, Fo = $o && (() => {\n  const t = typeof window > \"u\" ? { userAgent: \"\" } : window.navigator, e = /applewebkit\\/([^\\s]+)/g.exec(t.userAgent.toLowerCase());\n  return e ? parseFloat(e[1]) < 605 : !1;\n})(), Lo = Ye.browser.name, No = parseInt(Ye.browser.version, 10), Ja = Lo === \"chrome\", Qa = Ye.browser.chromium, tc = parseInt(Ye.browser.chromiumVersion, 10) || 0, ec = Ja && No >= 109 || Qa && tc >= 109, nc = Lo === \"firefox\", rc = parseInt(Ye.browser.webkitVersion, 10) >= 612 || No >= 15, Hr = \"moveable-\", sc = Xr.map((t) => {\n  let e = \"\", n = \"\", r = \"center\", s = \"center\";\n  const o = \"calc(var(--moveable-control-padding, 20) * -1px)\";\n  return t.indexOf(\"n\") > -1 && (e = `top: ${o};`, s = \"bottom\"), t.indexOf(\"s\") > -1 && (e = \"top: 0px;\", s = \"top\"), t.indexOf(\"w\") > -1 && (n = `left: ${o};`, r = \"right\"), t.indexOf(\"e\") > -1 && (n = \"left: 0px;\", r = \"left\"), `.around-control[data-direction*=\"${t}\"] {\n        ${n}${e}\n        transform-origin: ${r} ${s};\n    }`;\n}).join(`\n`), oc = `\n{\nposition: absolute;\nwidth: 1px;\nheight: 1px;\nleft: 0;\ntop: 0;\nz-index: 3000;\n--moveable-color: #4af;\n--zoom: 1;\n--zoompx: 1px;\n--moveable-line-padding: 0;\n--moveable-control-padding: 0;\nwill-change: transform;\noutline: 1px solid transparent;\n}\n.control-box {\nz-index: 0;\n}\n.line, .control {\nposition: absolute;\nleft: 0;\ntop: 0;\nwill-change: transform;\n}\n.control {\nwidth: 14px;\nheight: 14px;\nborder-radius: 50%;\nborder: 2px solid #fff;\nbox-sizing: border-box;\nbackground: #4af;\nbackground: var(--moveable-color);\nmargin-top: -7px;\nmargin-left: -7px;\nborder: 2px solid #fff;\nz-index: 10;\n}\n.around-control {\nposition: absolute;\nwill-change: transform;\nwidth: calc(var(--moveable-control-padding, 20) * 1px);\nheight: calc(var(--moveable-control-padding, 20) * 1px);\nleft: calc(var(--moveable-control-padding, 20) * -0.5px);\ntop: calc(var(--moveable-control-padding, 20) * -0.5px);\nbox-sizing: border-box;\nbackground: transparent;\nz-index: 8;\ncursor: alias;\ntransform-origin: center center;\n}\n${sc}\n.padding {\nposition: absolute;\ntop: 0px;\nleft: 0px;\nwidth: 100px;\nheight: 100px;\ntransform-origin: 0 0;\n}\n.line {\nwidth: 1px;\nheight: 1px;\nbackground: #4af;\nbackground: var(--moveable-color);\ntransform-origin: 0px 50%;\n}\n.line.edge {\nz-index: 1;\nbackground: transparent;\n}\n.line.dashed {\nbox-sizing: border-box;\nbackground: transparent;\n}\n.line.dashed.horizontal {\nborder-top: 1px dashed #4af;\nborder-top-color: #4af;\nborder-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\nborder-left: 1px dashed #4af;\nborder-left-color: #4af;\nborder-left-color: var(--moveable-color);\n}\n.line.vertical {\ntransform: translateX(-50%);\n}\n.line.horizontal {\ntransform: translateY(-50%);\n}\n.line.vertical.bold {\nwidth: 2px;\n}\n.line.horizontal.bold {\nheight: 2px;\n}\n\n.control.origin {\nborder-color: #f55;\nbackground: #fff;\nwidth: 12px;\nheight: 12px;\nmargin-top: -6px;\nmargin-left: -6px;\npointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map((t) => `\n.direction[data-rotation=\"${t}\"], :global .view-control-rotation${t} {\n${Za(t)}\n}\n`).join(`\n`)}\n\n.line.direction:before {\ncontent: \"\";\nposition: absolute;\nwidth: 100%;\nheight: calc(var(--moveable-line-padding, 0) * 1px);\nbottom: 0;\nleft: 0;\n}\n.group {\nz-index: -1;\n}\n.area {\nposition: absolute;\n}\n.area-pieces {\nposition: absolute;\ntop: 0;\nleft: 0;\ndisplay: none;\n}\n.area.avoid, .area.pass {\npointer-events: none;\n}\n.area.avoid+.area-pieces {\ndisplay: block;\n}\n.area-piece {\nposition: absolute;\n}\n\n${Fo ? `:global svg *:before {\ncontent:\"\";\ntransform-origin: inherit;\n}` : \"\"}\n`, ic = [\n  [0, 1, 2],\n  [1, 0, 3],\n  [2, 0, 3],\n  [3, 1, 2]\n], Cr = 1e-4, Bt = 1e-7, Sn = 1e-9, Dr = Math.pow(10, 10), Fs = -Dr, ac = {\n  n: [0, -1],\n  e: [1, 0],\n  s: [0, 1],\n  w: [-1, 0],\n  nw: [-1, -1],\n  ne: [1, -1],\n  sw: [-1, 1],\n  se: [1, 1]\n}, qr = {\n  n: [0, 1],\n  e: [1, 3],\n  s: [3, 2],\n  w: [2, 0],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3]\n}, Wo = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135\n}, wf = [\n  \"isMoveableElement\",\n  \"updateRect\",\n  \"updateTarget\",\n  \"destroy\",\n  \"dragStart\",\n  \"isInside\",\n  \"hitTest\",\n  \"setState\",\n  \"getRect\",\n  \"request\",\n  \"isDragging\",\n  \"getManager\",\n  \"forceUpdate\",\n  \"waitToChangeTarget\",\n  \"updateSelectors\",\n  \"getTargets\",\n  \"stopDrag\",\n  \"getControlBoxElement\",\n  \"getMoveables\",\n  \"getDragElement\"\n];\nfunction cc(t, ...e) {\n  return e.map(\n    (n) => n.split(\" \").map((r) => r ? `${t}${r}` : \"\").join(\" \")\n  ).join(\" \");\n}\nfunction lc(t, e) {\n  return e.replace(/([^}{]*){/gm, (n, r) => `${r.replace(/\\.([^{,\\s\\d.]+)/g, `.${t}$1`)}{`);\n}\nfunction Se(t, e) {\n  return (n) => {\n    n && (t[e] = n);\n  };\n}\nfunction Yo(t, e, n) {\n  return (r) => {\n    r && (t[e][n] = r);\n  };\n}\nvar uc = \"function\", fc = \"object\", dc = \"string\", pc = \"number\", Ur = \"undefined\", Vo = typeof window !== Ur, gc = typeof document !== Ur && document, hc = [{\n  open: \"(\",\n  close: \")\"\n}, {\n  open: '\"',\n  close: '\"'\n}, {\n  open: \"'\",\n  close: \"'\"\n}, {\n  open: '\\\\\"',\n  close: '\\\\\"'\n}, {\n  open: \"\\\\'\",\n  close: \"\\\\'\"\n}], Dt = 1e-7, En = {\n  cm: function(t) {\n    return t * 96 / 2.54;\n  },\n  mm: function(t) {\n    return t * 96 / 254;\n  },\n  in: function(t) {\n    return t * 96;\n  },\n  pt: function(t) {\n    return t * 96 / 72;\n  },\n  pc: function(t) {\n    return t * 96 / 6;\n  },\n  \"%\": function(t, e) {\n    return t * e / 100;\n  },\n  vw: function(t, e) {\n    return e === void 0 && (e = window.innerWidth), t / 100 * e;\n  },\n  vh: function(t, e) {\n    return e === void 0 && (e = window.innerHeight), t / 100 * e;\n  },\n  vmax: function(t, e) {\n    return e === void 0 && (e = Math.max(window.innerWidth, window.innerHeight)), t / 100 * e;\n  },\n  vmin: function(t, e) {\n    return e === void 0 && (e = Math.min(window.innerWidth, window.innerHeight)), t / 100 * e;\n  }\n};\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction vc() {\n  for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;\n  for (var r = Array(t), s = 0, e = 0; e < n; e++) for (var o = arguments[e], i = 0, a = o.length; i < a; i++, s++) r[s] = o[i];\n  return r;\n}\nfunction zn(t, e, n, r) {\n  return (t * r + e * n) / (n + r);\n}\nfunction Kr(t) {\n  return typeof t === Ur;\n}\nfunction qt(t) {\n  return t && typeof t === fc;\n}\nfunction Rt(t) {\n  return Array.isArray(t);\n}\nfunction re(t) {\n  return typeof t === dc;\n}\nfunction an(t) {\n  return typeof t === pc;\n}\nfunction Zr(t) {\n  return typeof t === uc;\n}\nfunction mc(t, e) {\n  var n = t === \"\" || t == \" \", r = e === \"\" || e == \" \";\n  return r && n || t === e;\n}\nfunction jo(t, e, n, r, s) {\n  var o = Jr(t, e, n);\n  return o ? n : xc(t, e, n + 1, r, s);\n}\nfunction Jr(t, e, n) {\n  if (!t.ignore)\n    return null;\n  var r = e.slice(Math.max(n - 3, 0), n + 3).join(\"\");\n  return new RegExp(t.ignore).exec(r);\n}\nfunction xc(t, e, n, r, s) {\n  for (var o = function(l) {\n    var u = e[l].trim();\n    if (u === t.close && !Jr(t, e, l))\n      return {\n        value: l\n      };\n    var f = l, d = kt(s, function(p) {\n      var g = p.open;\n      return g === u;\n    });\n    if (d && (f = jo(d, e, l, r, s)), f === -1)\n      return i = l, \"break\";\n    l = f, i = l;\n  }, i, a = n; a < r; ++a) {\n    var c = o(a);\n    if (a = i, typeof c == \"object\") return c.value;\n    if (c === \"break\") break;\n  }\n  return -1;\n}\nfunction Qr(t, e) {\n  var n = re(e) ? {\n    separator: e\n  } : e, r = n.separator, s = r === void 0 ? \",\" : r, o = n.isSeparateFirst, i = n.isSeparateOnlyOpenClose, a = n.isSeparateOpenClose, c = a === void 0 ? i : a, l = n.openCloseCharacters, u = l === void 0 ? hc : l, f = u.map(function(R) {\n    var y = R.open, M = R.close;\n    return y === M ? y : y + \"|\" + M;\n  }).join(\"|\"), d = \"(\\\\s*\" + s + \"\\\\s*|\" + f + \"|\\\\s+)\", p = new RegExp(d, \"g\"), g = t.split(p).filter(function(R) {\n    return R && R !== \"undefined\";\n  }), h = g.length, v = [], m = [];\n  function S() {\n    return m.length ? (v.push(m.join(\"\")), m = [], !0) : !1;\n  }\n  for (var x = function(R) {\n    var y = g[R].trim(), M = R, P = kt(u, function(T) {\n      var w = T.open;\n      return w === y;\n    }), _ = kt(u, function(T) {\n      var w = T.close;\n      return w === y;\n    });\n    if (P) {\n      if (M = jo(P, g, R, h, u), M !== -1 && c)\n        return S() && o || (v.push(g.slice(R, M + 1).join(\"\")), R = M, o) ? (C = R, \"break\") : (C = R, \"continue\");\n    } else if (_ && !Jr(_, g, R)) {\n      var O = vc(u);\n      return O.splice(u.indexOf(_), 1), {\n        value: Qr(t, {\n          separator: s,\n          isSeparateFirst: o,\n          isSeparateOnlyOpenClose: i,\n          isSeparateOpenClose: c,\n          openCloseCharacters: O\n        })\n      };\n    } else if (mc(y, s) && !i)\n      return S(), o ? (C = R, \"break\") : (C = R, \"continue\");\n    M === -1 && (M = h - 1), m.push(g.slice(R, M + 1).join(\"\")), R = M, C = R;\n  }, C, E = 0; E < h; ++E) {\n    var D = x(E);\n    if (E = C, typeof D == \"object\") return D.value;\n    if (D === \"break\") break;\n  }\n  return m.length && v.push(m.join(\"\")), v;\n}\nfunction ce(t) {\n  return Qr(t, \"\");\n}\nfunction xe(t) {\n  return Qr(t, \",\");\n}\nfunction Xo(t) {\n  var e = /([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g.exec(t);\n  return !e || e.length < 4 ? {} : {\n    prefix: e[1],\n    value: e[2],\n    suffix: e[3]\n  };\n}\nfunction pn(t) {\n  var e = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(t);\n  if (!e)\n    return {\n      prefix: \"\",\n      unit: \"\",\n      value: NaN\n    };\n  var n = e[1], r = e[2], s = e[3];\n  return {\n    prefix: n,\n    unit: s,\n    value: parseFloat(r)\n  };\n}\nfunction Sc(t, e) {\n  return t.replace(/([a-z])([A-Z])/g, function(n, r, s) {\n    return \"\" + r + e + s.toLowerCase();\n  });\n}\nfunction cn() {\n  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();\n}\nfunction ne(t, e, n) {\n  n === void 0 && (n = -1);\n  for (var r = t.length, s = 0; s < r; ++s)\n    if (e(t[s], s, t))\n      return s;\n  return n;\n}\nfunction kt(t, e, n) {\n  var r = ne(t, e);\n  return r > -1 ? t[r] : n;\n}\nvar Ho = /* @__PURE__ */ function() {\n  var t = cn(), e = Vo && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);\n  return e ? e.bind(window) : function(n) {\n    var r = cn(), s = setTimeout(function() {\n      n(r - t);\n    }, 1e3 / 60);\n    return s;\n  };\n}(), Ec = /* @__PURE__ */ function() {\n  var t = Vo && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);\n  return t ? t.bind(window) : function(e) {\n    clearTimeout(e);\n  };\n}();\nfunction Ve(t) {\n  return Object.keys(t);\n}\nfunction ft(t, e) {\n  var n = pn(t), r = n.value, s = n.unit;\n  if (qt(e)) {\n    var o = e[s];\n    if (o) {\n      if (Zr(o))\n        return o(r);\n      if (En[s])\n        return En[s](r, o);\n    }\n  } else if (s === \"%\")\n    return r * e / 100;\n  return En[s] ? En[s](r) : r;\n}\nfunction br(t, e, n) {\n  return Math.max(e, Math.min(t, n));\n}\nfunction Ls(t, e, n, r) {\n  return r === void 0 && (r = t[0] / t[1]), [[tt(e[0], Dt), tt(e[0] / r, Dt)], [tt(e[1] * r, Dt), tt(e[1], Dt)]].filter(function(s) {\n    return s.every(function(o, i) {\n      var a = e[i], c = tt(a, Dt);\n      return n ? o <= a || o <= c : o >= a || o >= c;\n    });\n  })[0] || t;\n}\nfunction qo(t, e, n, r) {\n  if (!r)\n    return t.map(function(p, g) {\n      return br(p, e[g], n[g]);\n    });\n  var s = t[0], o = t[1], i = r === !0 ? s / o : r, a = Ls(t, e, !1, i), c = a[0], l = a[1], u = Ls(t, n, !0, i), f = u[0], d = u[1];\n  return s < c || o < l ? (s = c, o = l) : (s > f || o > d) && (s = f, o = d), [s, o];\n}\nfunction Cc(t) {\n  for (var e = t.length, n = 0, r = e - 1; r >= 0; --r)\n    n += t[r];\n  return n;\n}\nfunction yr(t) {\n  for (var e = t.length, n = 0, r = e - 1; r >= 0; --r)\n    n += t[r];\n  return e ? n / e : 0;\n}\nfunction xt(t, e) {\n  var n = e[0] - t[0], r = e[1] - t[1], s = Math.atan2(r, n);\n  return s >= 0 ? s : s + Math.PI * 2;\n}\nfunction Dc(t) {\n  return [0, 1].map(function(e) {\n    return yr(t.map(function(n) {\n      return n[e];\n    }));\n  });\n}\nfunction Ns(t) {\n  var e = Dc(t), n = xt(e, t[0]), r = xt(e, t[1]);\n  return n < r && r - n < Math.PI || n > r && r - n < -Math.PI ? 1 : -1;\n}\nfunction te(t, e) {\n  return Math.sqrt(Math.pow((e ? e[0] : 0) - t[0], 2) + Math.pow((e ? e[1] : 0) - t[1], 2));\n}\nfunction tt(t, e) {\n  if (!e)\n    return t;\n  var n = 1 / e;\n  return Math.round(t / e) / n;\n}\nfunction Ws(t, e) {\n  return t.forEach(function(n, r) {\n    t[r] = tt(t[r], e);\n  }), t;\n}\nfunction bc(t) {\n  for (var e = [], n = 0; n < t; ++n)\n    e.push(n);\n  return e;\n}\nfunction yc(t) {\n  return t.reduce(function(e, n) {\n    return e.concat(n);\n  }, []);\n}\nfunction Uo(t, e) {\n  t.indexOf(e) === -1 && t.push(e);\n}\nfunction bt(t, e) {\n  return t.classList ? t.classList.contains(e) : !!t.className.match(new RegExp(\"(\\\\s|^)\" + e + \"(\\\\s|$)\"));\n}\nfunction Ko(t, e) {\n  t.classList ? t.classList.add(e) : t.className += \" \" + e;\n}\nfunction Zo(t, e) {\n  if (t.classList)\n    t.classList.remove(e);\n  else {\n    var n = new RegExp(\"(\\\\s|^)\" + e + \"(\\\\s|$)\");\n    t.className = t.className.replace(n, \" \");\n  }\n}\nfunction Pt(t, e, n, r) {\n  t.addEventListener(e, n, r);\n}\nfunction Mt(t, e, n, r) {\n  t.removeEventListener(e, n, r);\n}\nfunction ts(t) {\n  return (t == null ? void 0 : t.ownerDocument) || gc;\n}\nfunction es(t) {\n  return ts(t).documentElement;\n}\nfunction fe(t) {\n  return ts(t).body;\n}\nfunction ae(t) {\n  var e;\n  return ((e = t == null ? void 0 : t.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || window;\n}\nfunction Jo(t) {\n  return t && \"postMessage\" in t && \"blur\" in t && \"self\" in t;\n}\nfunction ns(t) {\n  return qt(t) && t.nodeName && t.nodeType && \"ownerDocument\" in t;\n}\nfunction Rc(t, e, n, r, s, o) {\n  for (var i = 0; i < s; ++i) {\n    var a = n + i * s, c = r + i * s;\n    t[a] += t[c] * o, e[a] += e[c] * o;\n  }\n}\nfunction Mc(t, e, n, r, s) {\n  for (var o = 0; o < s; ++o) {\n    var i = n + o * s, a = r + o * s, c = t[i], l = e[i];\n    t[i] = t[a], t[a] = c, e[i] = e[a], e[a] = l;\n  }\n}\nfunction Pc(t, e, n, r, s) {\n  for (var o = 0; o < r; ++o) {\n    var i = n + o * r;\n    t[i] /= s, e[i] /= s;\n  }\n}\nfunction Qo(t, e, n) {\n  for (var r = t.slice(), s = 0; s < n; ++s)\n    r[s * n + e - 1] = 0, r[(e - 1) * n + s] = 0;\n  return r[(e - 1) * (n + 1)] = 1, r;\n}\nfunction Jt(t, e) {\n  e === void 0 && (e = Math.sqrt(t.length));\n  for (var n = t.slice(), r = gt(e), s = 0; s < e; ++s) {\n    var o = e * s + s;\n    if (!tt(n[o], Dt)) {\n      for (var i = s + 1; i < e; ++i)\n        if (n[e * s + i]) {\n          Mc(n, r, s, i, e);\n          break;\n        }\n    }\n    if (!tt(n[o], Dt))\n      return [];\n    Pc(n, r, s, e, n[o]);\n    for (var i = 0; i < e; ++i) {\n      var a = i, c = i + s * e, l = n[c];\n      !tt(l, Dt) || s === i || Rc(n, r, a, s, e, -l);\n    }\n  }\n  return r;\n}\nfunction _c(t, e) {\n  e === void 0 && (e = Math.sqrt(t.length));\n  for (var n = [], r = 0; r < e; ++r)\n    for (var s = 0; s < e; ++s)\n      n[s * e + r] = t[e * r + s];\n  return n;\n}\nfunction ti(t, e) {\n  e === void 0 && (e = Math.sqrt(t.length));\n  for (var n = [], r = t[e * e - 1], s = 0; s < e - 1; ++s)\n    n[s] = t[e * (e - 1) + s] / r;\n  return n[e - 1] = 0, n;\n}\nfunction Tc(t, e) {\n  for (var n = gt(e), r = 0; r < e - 1; ++r)\n    n[e * (e - 1) + r] = t[r] || 0;\n  return n;\n}\nfunction Ee(t, e) {\n  for (var n = t.slice(), r = t.length; r < e - 1; ++r)\n    n[r] = 0;\n  return n[e - 1] = 1, n;\n}\nfunction Ut(t, e, n) {\n  if (e === void 0 && (e = Math.sqrt(t.length)), e === n)\n    return t;\n  for (var r = gt(n), s = Math.min(e, n), o = 0; o < s - 1; ++o) {\n    for (var i = 0; i < s - 1; ++i)\n      r[o * n + i] = t[o * e + i];\n    r[(o + 1) * n - 1] = t[(o + 1) * e - 1], r[(n - 1) * n + o] = t[(e - 1) * e + o];\n  }\n  return r[n * n - 1] = t[e * e - 1], r;\n}\nfunction An(t) {\n  for (var e = [], n = 1; n < arguments.length; n++)\n    e[n - 1] = arguments[n];\n  var r = gt(t);\n  return e.forEach(function(s) {\n    r = dt(r, s, t);\n  }), r;\n}\nfunction dt(t, e, n) {\n  n === void 0 && (n = Math.sqrt(t.length));\n  var r = [], s = t.length / n, o = e.length / s;\n  if (s) {\n    if (!o)\n      return t;\n  } else return e;\n  for (var i = 0; i < n; ++i)\n    for (var a = 0; a < o; ++a) {\n      r[a * n + i] = 0;\n      for (var c = 0; c < s; ++c)\n        r[a * n + i] += t[c * n + i] * e[a * s + c];\n    }\n  return r;\n}\nfunction at(t, e) {\n  for (var n = Math.min(t.length, e.length), r = t.slice(), s = 0; s < n; ++s)\n    r[s] = r[s] + e[s];\n  return r;\n}\nfunction K(t, e) {\n  for (var n = Math.min(t.length, e.length), r = t.slice(), s = 0; s < n; ++s)\n    r[s] = r[s] - e[s];\n  return r;\n}\nfunction Oc(t, e) {\n  return e === void 0 && (e = t.length === 6), e ? [t[0], t[1], 0, t[2], t[3], 0, t[4], t[5], 1] : t;\n}\nfunction ei(t, e) {\n  return e === void 0 && (e = t.length === 9), e ? [t[0], t[1], t[3], t[4], t[6], t[7]] : t;\n}\nfunction _t(t, e, n) {\n  n === void 0 && (n = e.length);\n  var r = dt(t, e, n), s = r[n - 1];\n  return r.map(function(o) {\n    return o / s;\n  });\n}\nfunction wc(t, e) {\n  return dt(t, [1, 0, 0, 0, 0, Math.cos(e), Math.sin(e), 0, 0, -Math.sin(e), Math.cos(e), 0, 0, 0, 0, 1], 4);\n}\nfunction Ic(t, e) {\n  return dt(t, [Math.cos(e), 0, -Math.sin(e), 0, 0, 1, 0, 0, Math.sin(e), 0, Math.cos(e), 0, 0, 0, 0, 1], 4);\n}\nfunction Bc(t, e) {\n  return dt(t, hn(e, 4));\n}\nfunction Cn(t, e) {\n  var n = e[0], r = n === void 0 ? 1 : n, s = e[1], o = s === void 0 ? 1 : s, i = e[2], a = i === void 0 ? 1 : i;\n  return dt(t, [r, 0, 0, 0, 0, o, 0, 0, 0, 0, a, 0, 0, 0, 0, 1], 4);\n}\nfunction gn(t, e) {\n  return _t(hn(e, 3), Ee(t, 3));\n}\nfunction ir(t, e) {\n  var n = e[0], r = n === void 0 ? 0 : n, s = e[1], o = s === void 0 ? 0 : s, i = e[2], a = i === void 0 ? 0 : i;\n  return dt(t, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, o, a, 1], 4);\n}\nfunction Ys(t, e) {\n  return dt(t, e, 4);\n}\nfunction hn(t, e) {\n  var n = Math.cos(t), r = Math.sin(t), s = gt(e);\n  return s[0] = n, s[1] = r, s[e] = -r, s[e + 1] = n, s;\n}\nfunction gt(t) {\n  for (var e = t * t, n = [], r = 0; r < e; ++r)\n    n[r] = r % (t + 1) ? 0 : 1;\n  return n;\n}\nfunction rs(t, e) {\n  for (var n = gt(e), r = Math.min(t.length, e - 1), s = 0; s < r; ++s)\n    n[(e + 1) * s] = t[s];\n  return n;\n}\nfunction Ce(t, e) {\n  for (var n = gt(e), r = Math.min(t.length, e - 1), s = 0; s < r; ++s)\n    n[e * (e - 1) + s] = t[s];\n  return n;\n}\nfunction ss(t, e, n, r, s, o, i, a) {\n  var c = t[0], l = t[1], u = e[0], f = e[1], d = n[0], p = n[1], g = r[0], h = r[1], v = s[0], m = s[1], S = o[0], x = o[1], C = i[0], E = i[1], D = a[0], R = a[1], y = [c, 0, u, 0, d, 0, g, 0, l, 0, f, 0, p, 0, h, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, c, 0, u, 0, d, 0, g, 0, l, 0, f, 0, p, 0, h, 0, 1, 0, 1, 0, 1, 0, 1, -v * c, -m * c, -S * u, -x * u, -C * d, -E * d, -D * g, -R * g, -v * l, -m * l, -S * f, -x * f, -C * p, -E * p, -D * h, -R * h], M = Jt(y, 8);\n  if (!M.length)\n    return [];\n  var P = dt(M, [v, m, S, x, C, E, D, R], 8);\n  return P[8] = 1, Ut(_c(P), 3, 4);\n}\nvar Qe = function() {\n  return Qe = Object.assign || function(e) {\n    for (var n, r = 1, s = arguments.length; r < s; r++) {\n      n = arguments[r];\n      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);\n    }\n    return e;\n  }, Qe.apply(this, arguments);\n};\nfunction zc() {\n  return [\n    1,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    1\n  ];\n}\nfunction ln(t, e) {\n  return e === void 0 && (e = 0), we($e(t, e));\n}\nfunction Ac(t, e) {\n  var n = _t(t, [e[0], e[1] || 0, e[2] || 0, 1], 4), r = n[3] || 1;\n  return [\n    n[0] / r,\n    n[1] / r,\n    n[2] / r\n  ];\n}\nfunction we(t) {\n  var e = zc();\n  return t.forEach(function(n) {\n    var r = n.matrixFunction, s = n.functionValue;\n    r && (e = r(e, s));\n  }), e;\n}\nfunction $e(t, e) {\n  e === void 0 && (e = 0);\n  var n = Rt(t) ? t : ce(t);\n  return n.map(function(r) {\n    var s = Xo(r), o = s.prefix, i = s.value, a = null, c = o, l = \"\";\n    if (o === \"translate\" || o === \"translateX\" || o === \"translate3d\") {\n      var u = qt(e) ? Qe(Qe({}, e), { \"o%\": e[\"%\"] }) : {\n        \"%\": e,\n        \"o%\": e\n      }, f = xe(i).map(function(T, w) {\n        return w === 0 && \"x%\" in u ? u[\"%\"] = e[\"x%\"] : w === 1 && \"y%\" in u ? u[\"%\"] = e[\"y%\"] : u[\"%\"] = e[\"o%\"], ft(T, u);\n      }), d = f[0], p = f[1], g = p === void 0 ? 0 : p, h = f[2], v = h === void 0 ? 0 : h;\n      a = ir, l = [d, g, v];\n    } else if (o === \"translateY\") {\n      var m = qt(e) ? Qe({ \"%\": e[\"y%\"] }, e) : {\n        \"%\": e\n      }, g = ft(i, m);\n      a = ir, l = [0, g, 0];\n    } else if (o === \"translateZ\") {\n      var v = parseFloat(i);\n      a = ir, l = [0, 0, v];\n    } else if (o === \"scale\" || o === \"scale3d\") {\n      var S = xe(i).map(function(T) {\n        return parseFloat(T);\n      }), x = S[0], C = S[1], E = C === void 0 ? x : C, D = S[2], R = D === void 0 ? 1 : D;\n      a = Cn, l = [x, E, R];\n    } else if (o === \"scaleX\") {\n      var x = parseFloat(i);\n      a = Cn, l = [x, 1, 1];\n    } else if (o === \"scaleY\") {\n      var E = parseFloat(i);\n      a = Cn, l = [1, E, 1];\n    } else if (o === \"scaleZ\") {\n      var R = parseFloat(i);\n      a = Cn, l = [1, 1, R];\n    } else if (o === \"rotate\" || o === \"rotateZ\" || o === \"rotateX\" || o === \"rotateY\") {\n      var y = pn(i), M = y.unit, P = y.value, _ = M === \"rad\" ? P : P * Math.PI / 180;\n      o === \"rotate\" || o === \"rotateZ\" ? (c = \"rotateZ\", a = Bc) : o === \"rotateX\" ? a = wc : o === \"rotateY\" && (a = Ic), l = _;\n    } else if (o === \"matrix3d\")\n      a = Ys, l = xe(i).map(function(T) {\n        return parseFloat(T);\n      });\n    else if (o === \"matrix\") {\n      var O = xe(i).map(function(T) {\n        return parseFloat(T);\n      });\n      a = Ys, l = [\n        O[0],\n        O[1],\n        0,\n        0,\n        O[2],\n        O[3],\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        O[4],\n        O[5],\n        0,\n        1\n      ];\n    } else\n      c = \"\";\n    return {\n      name: o,\n      functionName: c,\n      value: i,\n      matrixFunction: a,\n      functionValue: l\n    };\n  });\n}\nfunction vn(t, e, n, r, s, o = \"draggable\") {\n  var l;\n  const i = ((l = e.gestos[o]) == null ? void 0 : l.move(n, t.inputEvent)) ?? {}, a = i.originalDatas || i.datas, c = a[o] || (a[o] = {});\n  return {\n    ...i,\n    isPinch: !!r,\n    parentEvent: !0,\n    datas: c,\n    originalDatas: t.originalDatas\n  };\n}\nclass Fe {\n  constructor(e = \"draggable\") {\n    X(this, \"prevX\", 0);\n    X(this, \"prevY\", 0);\n    X(this, \"startX\", 0);\n    X(this, \"startY\", 0);\n    X(this, \"isDrag\", !1);\n    X(this, \"isFlag\", !1);\n    X(this, \"datas\", {\n      draggable: {}\n    });\n    this.ableName = e, this.datas = {\n      [e]: {}\n    };\n  }\n  dragStart(e, n) {\n    this.isDrag = !1, this.isFlag = !1;\n    const r = n.originalDatas;\n    return this.datas = r, r[this.ableName] || (r[this.ableName] = {}), {\n      ...this.move(e, n.inputEvent),\n      type: \"dragstart\"\n    };\n  }\n  drag(e, n) {\n    return this.move([\n      e[0] - this.prevX,\n      e[1] - this.prevY\n    ], n);\n  }\n  move(e, n) {\n    let r, s, o = !1;\n    if (!this.isFlag)\n      this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], r = e[0], s = e[1], this.isFlag = !0;\n    else {\n      const i = this.isDrag;\n      r = this.prevX + e[0], s = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0), !i && this.isDrag && (o = !0);\n    }\n    return this.prevX = r, this.prevY = s, {\n      type: \"drag\",\n      clientX: r,\n      clientY: s,\n      inputEvent: n,\n      isFirstDrag: o,\n      isDrag: this.isDrag,\n      distX: r - this.startX,\n      distY: s - this.startY,\n      deltaX: e[0],\n      deltaY: e[1],\n      datas: this.datas[this.ableName],\n      originalDatas: this.datas,\n      parentEvent: !0,\n      parentGesto: this\n    };\n  }\n}\nfunction ke(t, e, n, r) {\n  const o = t.length === 16 ? 4 : 3, i = Me(t, n, r, o);\n  let [[a, c], [l, u], [f, d], [p, g]] = i, [h, v] = ht(t, e, o);\n  const m = Math.min(a, l, f, p), S = Math.min(c, u, d, g), x = Math.max(a, l, f, p), C = Math.max(c, u, d, g);\n  a = a - m || 0, l = l - m || 0, f = f - m || 0, p = p - m || 0, c = c - S || 0, u = u - S || 0, d = d - S || 0, g = g - S || 0, h = h - m || 0, v = v - S || 0;\n  const E = t[0], D = t[o + 1], R = wt(E * D);\n  return {\n    left: m,\n    top: S,\n    right: x,\n    bottom: C,\n    origin: [h, v],\n    pos1: [a, c],\n    pos2: [l, u],\n    pos3: [f, d],\n    pos4: [p, g],\n    direction: R\n  };\n}\nfunction ni(t, e) {\n  const { clientX: n, clientY: r, datas: s } = e, {\n    moveableClientRect: o,\n    rootMatrix: i,\n    is3d: a,\n    pos1: c\n  } = t.state, { left: l, top: u } = o, f = a ? 4 : 3, [d, p] = K(We(i, [n - l, r - u], f), c), [g, h] = Qt({ datas: s, distX: d, distY: p });\n  return [g, h];\n}\nfunction Re(t, { datas: e }) {\n  const {\n    allMatrix: n,\n    beforeMatrix: r,\n    is3d: s,\n    left: o,\n    top: i,\n    origin: a,\n    offsetMatrix: c,\n    targetMatrix: l,\n    transformOrigin: u\n  } = t.state, f = s ? 4 : 3;\n  e.is3d = s, e.matrix = n, e.targetMatrix = l, e.beforeMatrix = r, e.offsetMatrix = c, e.transformOrigin = u, e.inverseMatrix = Jt(n, f), e.inverseBeforeMatrix = Jt(r, f), e.absoluteOrigin = Ee(at([o, i], a), f), e.startDragBeforeDist = _t(e.inverseBeforeMatrix, e.absoluteOrigin, f), e.startDragDist = _t(e.inverseMatrix, e.absoluteOrigin, f);\n}\nfunction Gc(t) {\n  return ke(t.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nfunction jn(t, e, n) {\n  const {\n    datas: r,\n    originalDatas: {\n      beforeRenderable: s\n    }\n  } = e, o = r.transformIndex, i = s.nextTransforms, a = i.length, c = s.nextTransformAppendedIndexes;\n  let l = -1;\n  o === -1 ? (n === \"translate\" ? l = 0 : n === \"rotate\" && (l = ne(i, (p) => p.match(/scale\\(/g))), l === -1 && (l = i.length), r.transformIndex = l) : kt(c, (p) => p.index === o && p.functionName === n) ? l = o : l = o + c.filter((p) => p.index < o).length;\n  const u = Su(i, t.state, l), f = u.targetFunction, d = n === \"rotate\" ? \"rotateZ\" : n;\n  r.beforeFunctionTexts = u.beforeFunctionTexts, r.afterFunctionTexts = u.afterFunctionTexts, r.beforeTransform = u.beforeFunctionMatrix, r.beforeTransform2 = u.beforeFunctionMatrix2, r.targetTansform = u.targetFunctionMatrix, r.afterTransform = u.afterFunctionMatrix, r.afterTransform2 = u.afterFunctionMatrix2, r.targetAllTransform = u.allFunctionMatrix, f.functionName === d ? (r.afterFunctionTexts.splice(0, 1), r.isAppendTransform = !1) : a > l && (r.isAppendTransform = !0, s.nextTransformAppendedIndexes = [...c, {\n    functionName: n,\n    index: l,\n    isAppend: !0\n  }]);\n}\nfunction Xn(t, e, n) {\n  return `${t.beforeFunctionTexts.join(\" \")} ${t.isAppendTransform ? n : e} ${t.afterFunctionTexts.join(\" \")}`;\n}\nfunction kc({ datas: t, distX: e, distY: n }) {\n  const [r, s] = si({ datas: t, distX: e, distY: n }), o = ri(t, Tc([r, s], 4));\n  return _t(o, Ee([0, 0, 0], 4), 4);\n}\nfunction ri(t, e, n) {\n  const {\n    beforeTransform: r,\n    afterTransform: s,\n    beforeTransform2: o,\n    afterTransform2: i,\n    targetAllTransform: a\n  } = t, c = n ? dt(a, e, 4) : dt(e, a, 4), l = dt(Jt(n ? o : r, 4), c, 4);\n  return dt(l, Jt(n ? i : s, 4), 4);\n}\nfunction si({ datas: t, distX: e, distY: n }) {\n  const {\n    inverseBeforeMatrix: r,\n    is3d: s,\n    startDragBeforeDist: o,\n    absoluteOrigin: i\n  } = t, a = s ? 4 : 3;\n  return K(\n    _t(\n      r,\n      at(i, [e, n]),\n      a\n    ),\n    o\n  );\n}\nfunction Qt({ datas: t, distX: e, distY: n }, r) {\n  const {\n    inverseBeforeMatrix: s,\n    inverseMatrix: o,\n    is3d: i,\n    startDragBeforeDist: a,\n    startDragDist: c,\n    absoluteOrigin: l\n  } = t, u = i ? 4 : 3;\n  return K(\n    _t(\n      r ? s : o,\n      at(l, [e, n]),\n      u\n    ),\n    r ? a : c\n  );\n}\nfunction $c({ datas: t, distX: e, distY: n }, r) {\n  const {\n    beforeMatrix: s,\n    matrix: o,\n    is3d: i,\n    startDragBeforeDist: a,\n    startDragDist: c,\n    absoluteOrigin: l\n  } = t, u = i ? 4 : 3;\n  return K(\n    _t(\n      o,\n      at(c, [e, n]),\n      u\n    ),\n    l\n  );\n}\nfunction Fc(t, e, n, r = e, s = n, o = [0, 0]) {\n  return t ? t.map((i, a) => {\n    const { value: c, unit: l } = pn(i), u = a ? s : r, f = a ? n : e;\n    if (i === \"%\" || isNaN(c)) {\n      const d = u ? o[a] / u : 0;\n      return f * d;\n    } else if (l !== \"%\")\n      return c;\n    return f * c / 100;\n  }) : o;\n}\nfunction oi(t) {\n  const e = [];\n  return t[1] >= 0 && (t[0] >= 0 && e.push(3), t[0] <= 0 && e.push(2)), t[1] <= 0 && (t[0] >= 0 && e.push(1), t[0] <= 0 && e.push(0)), e;\n}\nfunction Lc(t, e) {\n  return oi(e).map((n) => t[n]);\n}\nfunction ar(t, e) {\n  const n = (e + 1) / 2;\n  return [\n    zn(t[0][0], t[1][0], n, 1 - n),\n    zn(t[0][1], t[1][1], n, 1 - n)\n  ];\n}\nfunction yt(t, e) {\n  const n = ar([t[0], t[1]], e[0]), r = ar([t[2], t[3]], e[0]);\n  return ar([n, r], e[1]);\n}\nfunction Nc(t, e, n, r, s, o) {\n  const i = Me(e, n, r, s), a = yt(i, o), c = t[0] - a[0], l = t[1] - a[1];\n  return [c, l];\n}\nfunction mn(t, e, n, r) {\n  return dt(\n    t,\n    en(e, r, n),\n    r\n  );\n}\nfunction Wc(t, e, n, r) {\n  const {\n    transformOrigin: s,\n    offsetMatrix: o,\n    is3d: i\n  } = t, a = i ? 4 : 3;\n  let c;\n  if (re(n)) {\n    const {\n      beforeTransform: l,\n      afterTransform: u\n    } = e;\n    r ? c = Ut(ln(n), 4, a) : c = Ut(\n      dt(dt(l, ln([n]), 4), u, 4),\n      4,\n      a\n    );\n  } else\n    c = n;\n  return mn(\n    o,\n    c,\n    s,\n    a\n  );\n}\nfunction Yc(t, e) {\n  const {\n    transformOrigin: n,\n    offsetMatrix: r,\n    is3d: s,\n    targetMatrix: o,\n    targetAllTransform: i\n  } = t, a = s ? 4 : 3;\n  return mn(\n    r,\n    dt(i || o, rs(e, a), a),\n    n,\n    a\n  );\n}\nfunction Hn(t, e) {\n  const n = je(e);\n  return {\n    setTransform: (r, s = -1) => {\n      n.startTransforms = Rt(r) ? r : ce(r), Rr(t, e, s);\n    },\n    setTransformIndex: (r) => {\n      Rr(t, e, r);\n    }\n  };\n}\nfunction qn(t, e, n) {\n  const s = je(e).startTransforms;\n  Rr(t, e, ne(s, (o) => o.indexOf(`${n}(`) === 0));\n}\nfunction Rr(t, e, n) {\n  const r = je(e), s = e.datas;\n  if (s.transformIndex = n, n === -1)\n    return;\n  const o = r.startTransforms[n];\n  if (!o)\n    return;\n  const i = t.state, a = $e([o], {\n    \"x%\": (c) => c / 100 * i.offsetWidth,\n    \"y%\": (c) => c / 100 * i.offsetHeight\n  });\n  s.startValue = a[0].functionValue;\n}\nfunction os(t, e) {\n  const n = je(t);\n  n.nextTransforms = ce(e);\n}\nfunction je(t) {\n  return t.originalDatas.beforeRenderable;\n}\nfunction Gn(t) {\n  const {\n    originalDatas: {\n      beforeRenderable: e\n    }\n  } = t;\n  return e.nextTransforms;\n}\nfunction Dn(t) {\n  return (Gn(t) || []).join(\" \");\n}\nfunction bn(t) {\n  return je(t).nextStyle;\n}\nfunction ii(t, e, n, r, s) {\n  os(s, e);\n  const o = Ot.drag(\n    t,\n    vn(s, t.state, n, r)\n  ), i = o ? o.transform : e;\n  return {\n    transform: e,\n    drag: o,\n    ...It({\n      transform: i\n    }, s),\n    afterTransform: i\n  };\n}\nfunction is(t, e, n, r, s, o) {\n  const i = Wc(t.state, s, e, o);\n  return Xc(\n    t,\n    n,\n    r,\n    i\n  );\n}\nfunction ai(t, e, n, r, s, o, i) {\n  const a = is(\n    t,\n    e,\n    n,\n    s,\n    o,\n    i\n  ), c = t.state, {\n    left: l,\n    top: u\n  } = c, f = t.props.groupable, d = f ? l : 0, p = f ? u : 0, g = K(r, a);\n  return K(g, [d, p]);\n}\nfunction Vc(t, e, n, r, s, o, i) {\n  return ai(\n    t,\n    e,\n    n,\n    r,\n    s,\n    o,\n    i\n  );\n}\nfunction jc(t, e, n) {\n  return [\n    e ? -1 + t[0] / (e / 2) : 0,\n    n ? -1 + t[1] / (n / 2) : 0\n  ];\n}\nfunction Xc(t, e, n, r = t.state.allMatrix) {\n  const {\n    width: s,\n    height: o,\n    is3d: i\n  } = t.state, a = i ? 4 : 3, c = [\n    s / 2 * (1 + e[0]) + n[0],\n    o / 2 * (1 + e[1]) + n[1]\n  ];\n  return ht(r, c, a);\n}\nfunction Hc(t, e, n) {\n  const r = n.fixedDirection, s = n.fixedPosition, o = n.fixedOffset;\n  return ai(\n    t,\n    `rotate(${e}deg)`,\n    r,\n    s,\n    o,\n    n\n  );\n}\nfunction qc(t, e, n, r, s, o) {\n  const {\n    groupable: i\n  } = t.props, a = t.state, {\n    transformOrigin: c,\n    offsetMatrix: l,\n    is3d: u,\n    width: f,\n    height: d,\n    left: p,\n    top: g\n  } = a, h = o.fixedDirection, v = o.nextTargetMatrix || a.targetMatrix, m = u ? 4 : 3, S = Fc(\n    s,\n    e,\n    n,\n    f,\n    d,\n    c\n  ), x = i ? p : 0, C = i ? g : 0, E = mn(l, v, S, m), D = Nc(r, E, e, n, m, h);\n  return K(D, [x, C]);\n}\nfunction Uc(t, e) {\n  return yt(jt(t.state), e);\n}\nfunction Kc(t, e) {\n  const n = t.targetGesto, r = t.controlGesto;\n  let s;\n  return n != null && n.isFlag() && (s = n.getEventData()[e]), !s && (r != null && r.isFlag()) && (s = r.getEventData()[e]), s || {};\n}\nfunction Zc(t) {\n  if (t && t.getRootNode) {\n    const e = t.getRootNode();\n    if (e.nodeType === 11)\n      return e;\n  }\n}\nfunction Jc(t) {\n  const e = t(\"scale\"), n = t(\"rotate\"), r = t(\"translate\"), s = [];\n  return r && r !== \"0px\" && r !== \"none\" && s.push(`translate(${r.split(/\\s+/).join(\",\")})`), n && n !== \"1\" && n !== \"none\" && s.push(`rotate(${n})`), e && e !== \"1\" && e !== \"none\" && s.push(`scale(${e.split(/\\s+/).join(\",\")})`), s;\n}\nfunction ci(t, e, n) {\n  let r = t;\n  const s = [], o = es(t) || fe(t);\n  let i = !n && t === e || t === o, a = i, c = !1, l = 3, u, f, d, p = !1, g = fn(e, e, !0).offsetParent, h = 1;\n  for (; r && !a; ) {\n    a = i;\n    const v = Gt(r), m = v(\"position\"), S = zi(r), x = m === \"fixed\", C = Jc(v);\n    let E = Oc(iu(S)), D, R = !1, y = !1, M = 0, P = 0, _ = 0, O = 0, T = {\n      hasTransform: !1,\n      fixedContainer: null\n    };\n    x && (p = !0, T = fu(r), g = T.fixedContainer);\n    const w = E.length;\n    !c && (w === 16 || C.length) && (c = !0, l = 4, Br(s), d && (d = Ut(d, 3, 4))), c && w === 9 && (E = Ut(E, 3, 4));\n    const {\n      tagName: k,\n      hasOffset: I,\n      isSVG: $,\n      origin: G,\n      targetOrigin: L,\n      offset: z\n    } = uu(r, t);\n    let [\n      N,\n      Z\n    ] = z;\n    k === \"svg\" && !r.ownerSVGElement && d && (s.push({\n      type: \"target\",\n      target: r,\n      matrix: du(r, l)\n    }), s.push({\n      type: \"offset\",\n      target: r,\n      matrix: gt(l)\n    }));\n    const Y = parseFloat(v(\"zoom\")) || 1;\n    if (x)\n      D = T.fixedContainer, R = !0;\n    else {\n      const W = fn(r, e, !1, !0, v), J = W.offsetZoom;\n      if (D = W.offsetParent, R = W.isEnd, y = W.isStatic, h *= J, (W.isCustomElement || J !== 1) && y)\n        N -= D.offsetLeft, Z -= D.offsetTop;\n      else if ((nc || ec) && W.parentSlotElement) {\n        let F = D, H = 0, nt = 0;\n        for (; F && Zc(F); )\n          H += F.offsetLeft, nt += F.offsetTop, F = F.offsetParent;\n        N -= H, Z -= nt;\n      }\n    }\n    if ($o && !rc && I && !$ && y && (m === \"relative\" || m === \"static\") && (N -= D.offsetLeft, Z -= D.offsetTop, i = i || R), x)\n      I && T.hasTransform && (_ = D.clientLeft, O = D.clientTop);\n    else if (I && g !== D && (M = D.clientLeft, P = D.clientTop), I && D === o) {\n      const W = Ai(r, !1);\n      N += W[0], Z += W[1];\n    }\n    if (s.push({\n      type: \"target\",\n      target: r,\n      matrix: en(E, l, G)\n    }), C.length && (s.push({\n      type: \"offset\",\n      target: r,\n      matrix: gt(l)\n    }), s.push({\n      type: \"target\",\n      target: r,\n      matrix: en(ln(C), l, G)\n    })), I) {\n      const W = r === t, J = W ? 0 : r.scrollLeft, q = W ? 0 : r.scrollTop;\n      s.push({\n        type: \"offset\",\n        target: r,\n        matrix: Ce([\n          N - J + M - _,\n          Z - q + P - O\n        ], l)\n      });\n    } else\n      s.push({\n        type: \"offset\",\n        target: r,\n        origin: G\n      });\n    if (Y !== 1 && s.push({\n      type: \"zoom\",\n      target: r,\n      matrix: en(rs([Y, Y], l), l, [0, 0])\n    }), d || (d = E), u || (u = G), f || (f = L), a || x)\n      break;\n    r = D, i = R, (!n || r === o) && (a = i);\n  }\n  return d || (d = gt(l)), u || (u = [0, 0]), f || (f = [0, 0]), {\n    zoom: h,\n    offsetContainer: g,\n    matrixes: s,\n    targetMatrix: d,\n    transformOrigin: u,\n    targetOrigin: f,\n    is3d: c,\n    hasFixed: p\n  };\n}\nlet ge = null, he = null, Ie = null;\nfunction Le(t) {\n  t ? (window.Map && (ge = /* @__PURE__ */ new Map(), he = /* @__PURE__ */ new Map()), Ie = []) : (ge = null, Ie = null, he = null);\n}\nfunction Qc(t) {\n  const e = he == null ? void 0 : he.get(t);\n  if (e)\n    return e;\n  const n = nn(t, !0);\n  return he && he.set(t, n), n;\n}\nfunction tl(t, e) {\n  if (Ie) {\n    const r = kt(Ie, (s) => s[0][0] == t && s[0][1] == e);\n    if (r)\n      return r[1];\n  }\n  const n = ci(t, e, !0);\n  return Ie && Ie.push([[t, e], n]), n;\n}\nfunction Gt(t) {\n  let e = ge == null ? void 0 : ge.get(t);\n  if (!e) {\n    const s = ae(t).getComputedStyle(t);\n    if (!ge)\n      return (o) => s[o];\n    e = {\n      style: s,\n      cached: {}\n    }, ge.set(t, e);\n  }\n  const n = e.cached, r = e.style;\n  return (s) => (s in n || (n[s] = r[s]), n[s]);\n}\nvar Mr = { exports: {} }, qe = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Vs;\nfunction el() {\n  if (Vs) return qe;\n  Vs = 1;\n  var t = react__WEBPACK_IMPORTED_MODULE_0__, e = Symbol.for(\"react.element\"), n = Symbol.for(\"react.fragment\"), r = Object.prototype.hasOwnProperty, s = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function i(a, c, l) {\n    var u, f = {}, d = null, p = null;\n    l !== void 0 && (d = \"\" + l), c.key !== void 0 && (d = \"\" + c.key), c.ref !== void 0 && (p = c.ref);\n    for (u in c) r.call(c, u) && !o.hasOwnProperty(u) && (f[u] = c[u]);\n    if (a && a.defaultProps) for (u in c = a.defaultProps, c) f[u] === void 0 && (f[u] = c[u]);\n    return { $$typeof: e, type: a, key: d, ref: p, props: f, _owner: s.current };\n  }\n  return qe.Fragment = n, qe.jsx = i, qe.jsxs = i, qe;\n}\nvar Ue = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar js;\nfunction nl() {\n  return js || (js = 1,  true && function() {\n    var t = react__WEBPACK_IMPORTED_MODULE_0__, e = Symbol.for(\"react.element\"), n = Symbol.for(\"react.portal\"), r = Symbol.for(\"react.fragment\"), s = Symbol.for(\"react.strict_mode\"), o = Symbol.for(\"react.profiler\"), i = Symbol.for(\"react.provider\"), a = Symbol.for(\"react.context\"), c = Symbol.for(\"react.forward_ref\"), l = Symbol.for(\"react.suspense\"), u = Symbol.for(\"react.suspense_list\"), f = Symbol.for(\"react.memo\"), d = Symbol.for(\"react.lazy\"), p = Symbol.for(\"react.offscreen\"), g = Symbol.iterator, h = \"@@iterator\";\n    function v(b) {\n      if (b === null || typeof b != \"object\")\n        return null;\n      var A = g && b[g] || b[h];\n      return typeof A == \"function\" ? A : null;\n    }\n    var m = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function S(b) {\n      {\n        for (var A = arguments.length, V = new Array(A > 1 ? A - 1 : 0), Q = 1; Q < A; Q++)\n          V[Q - 1] = arguments[Q];\n        x(\"error\", b, V);\n      }\n    }\n    function x(b, A, V) {\n      {\n        var Q = m.ReactDebugCurrentFrame, ct = Q.getStackAddendum();\n        ct !== \"\" && (A += \"%s\", V = V.concat([ct]));\n        var pt = V.map(function(ot) {\n          return String(ot);\n        });\n        pt.unshift(\"Warning: \" + A), Function.prototype.apply.call(console[b], console, pt);\n      }\n    }\n    var C = !1, E = !1, D = !1, R = !1, y = !1, M;\n    M = Symbol.for(\"react.module.reference\");\n    function P(b) {\n      return !!(typeof b == \"string\" || typeof b == \"function\" || b === r || b === o || y || b === s || b === l || b === u || R || b === p || C || E || D || typeof b == \"object\" && b !== null && (b.$$typeof === d || b.$$typeof === f || b.$$typeof === i || b.$$typeof === a || b.$$typeof === c || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      b.$$typeof === M || b.getModuleId !== void 0));\n    }\n    function _(b, A, V) {\n      var Q = b.displayName;\n      if (Q)\n        return Q;\n      var ct = A.displayName || A.name || \"\";\n      return ct !== \"\" ? V + \"(\" + ct + \")\" : V;\n    }\n    function O(b) {\n      return b.displayName || \"Context\";\n    }\n    function T(b) {\n      if (b == null)\n        return null;\n      if (typeof b.tag == \"number\" && S(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof b == \"function\")\n        return b.displayName || b.name || null;\n      if (typeof b == \"string\")\n        return b;\n      switch (b) {\n        case r:\n          return \"Fragment\";\n        case n:\n          return \"Portal\";\n        case o:\n          return \"Profiler\";\n        case s:\n          return \"StrictMode\";\n        case l:\n          return \"Suspense\";\n        case u:\n          return \"SuspenseList\";\n      }\n      if (typeof b == \"object\")\n        switch (b.$$typeof) {\n          case a:\n            var A = b;\n            return O(A) + \".Consumer\";\n          case i:\n            var V = b;\n            return O(V._context) + \".Provider\";\n          case c:\n            return _(b, b.render, \"ForwardRef\");\n          case f:\n            var Q = b.displayName || null;\n            return Q !== null ? Q : T(b.type) || \"Memo\";\n          case d: {\n            var ct = b, pt = ct._payload, ot = ct._init;\n            try {\n              return T(ot(pt));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var w = Object.assign, k = 0, I, $, G, L, z, N, Z;\n    function Y() {\n    }\n    Y.__reactDisabledLog = !0;\n    function W() {\n      {\n        if (k === 0) {\n          I = console.log, $ = console.info, G = console.warn, L = console.error, z = console.group, N = console.groupCollapsed, Z = console.groupEnd;\n          var b = {\n            configurable: !0,\n            enumerable: !0,\n            value: Y,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: b,\n            log: b,\n            warn: b,\n            error: b,\n            group: b,\n            groupCollapsed: b,\n            groupEnd: b\n          });\n        }\n        k++;\n      }\n    }\n    function J() {\n      {\n        if (k--, k === 0) {\n          var b = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: w({}, b, {\n              value: I\n            }),\n            info: w({}, b, {\n              value: $\n            }),\n            warn: w({}, b, {\n              value: G\n            }),\n            error: w({}, b, {\n              value: L\n            }),\n            group: w({}, b, {\n              value: z\n            }),\n            groupCollapsed: w({}, b, {\n              value: N\n            }),\n            groupEnd: w({}, b, {\n              value: Z\n            })\n          });\n        }\n        k < 0 && S(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var q = m.ReactCurrentDispatcher, F;\n    function H(b, A, V) {\n      {\n        if (F === void 0)\n          try {\n            throw Error();\n          } catch (ct) {\n            var Q = ct.stack.trim().match(/\\n( *(at )?)/);\n            F = Q && Q[1] || \"\";\n          }\n        return `\n` + F + b;\n      }\n    }\n    var nt = !1, lt;\n    {\n      var vt = typeof WeakMap == \"function\" ? WeakMap : Map;\n      lt = new vt();\n    }\n    function st(b, A) {\n      if (!b || nt)\n        return \"\";\n      {\n        var V = lt.get(b);\n        if (V !== void 0)\n          return V;\n      }\n      var Q;\n      nt = !0;\n      var ct = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var pt;\n      pt = q.current, q.current = null, W();\n      try {\n        if (A) {\n          var ot = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(ot.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(ot, []);\n            } catch (zt) {\n              Q = zt;\n            }\n            Reflect.construct(b, [], ot);\n          } else {\n            try {\n              ot.call();\n            } catch (zt) {\n              Q = zt;\n            }\n            b.call(ot.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (zt) {\n            Q = zt;\n          }\n          b();\n        }\n      } catch (zt) {\n        if (zt && Q && typeof zt.stack == \"string\") {\n          for (var rt = zt.stack.split(`\n`), Tt = Q.stack.split(`\n`), mt = rt.length - 1, Et = Tt.length - 1; mt >= 1 && Et >= 0 && rt[mt] !== Tt[Et]; )\n            Et--;\n          for (; mt >= 1 && Et >= 0; mt--, Et--)\n            if (rt[mt] !== Tt[Et]) {\n              if (mt !== 1 || Et !== 1)\n                do\n                  if (mt--, Et--, Et < 0 || rt[mt] !== Tt[Et]) {\n                    var Nt = `\n` + rt[mt].replace(\" at new \", \" at \");\n                    return b.displayName && Nt.includes(\"<anonymous>\") && (Nt = Nt.replace(\"<anonymous>\", b.displayName)), typeof b == \"function\" && lt.set(b, Nt), Nt;\n                  }\n                while (mt >= 1 && Et >= 0);\n              break;\n            }\n        }\n      } finally {\n        nt = !1, q.current = pt, J(), Error.prepareStackTrace = ct;\n      }\n      var Te = b ? b.displayName || b.name : \"\", pe = Te ? H(Te) : \"\";\n      return typeof b == \"function\" && lt.set(b, pe), pe;\n    }\n    function Ft(b, A, V) {\n      return st(b, !1);\n    }\n    function Lt(b) {\n      var A = b.prototype;\n      return !!(A && A.isReactComponent);\n    }\n    function ut(b, A, V) {\n      if (b == null)\n        return \"\";\n      if (typeof b == \"function\")\n        return st(b, Lt(b));\n      if (typeof b == \"string\")\n        return H(b);\n      switch (b) {\n        case l:\n          return H(\"Suspense\");\n        case u:\n          return H(\"SuspenseList\");\n      }\n      if (typeof b == \"object\")\n        switch (b.$$typeof) {\n          case c:\n            return Ft(b.render);\n          case f:\n            return ut(b.type, A, V);\n          case d: {\n            var Q = b, ct = Q._payload, pt = Q._init;\n            try {\n              return ut(pt(ct), A, V);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var St = Object.prototype.hasOwnProperty, Kt = {}, de = m.ReactDebugCurrentFrame;\n    function Pe(b) {\n      if (b) {\n        var A = b._owner, V = ut(b.type, b._source, A ? A.type : null);\n        de.setExtraStackFrame(V);\n      } else\n        de.setExtraStackFrame(null);\n    }\n    function va(b, A, V, Q, ct) {\n      {\n        var pt = Function.call.bind(St);\n        for (var ot in b)\n          if (pt(b, ot)) {\n            var rt = void 0;\n            try {\n              if (typeof b[ot] != \"function\") {\n                var Tt = Error((Q || \"React class\") + \": \" + V + \" type `\" + ot + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof b[ot] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw Tt.name = \"Invariant Violation\", Tt;\n              }\n              rt = b[ot](A, ot, Q, V, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (mt) {\n              rt = mt;\n            }\n            rt && !(rt instanceof Error) && (Pe(ct), S(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", Q || \"React class\", V, ot, typeof rt), Pe(null)), rt instanceof Error && !(rt.message in Kt) && (Kt[rt.message] = !0, Pe(ct), S(\"Failed %s type: %s\", V, rt.message), Pe(null));\n          }\n      }\n    }\n    var ma = Array.isArray;\n    function tr(b) {\n      return ma(b);\n    }\n    function xa(b) {\n      {\n        var A = typeof Symbol == \"function\" && Symbol.toStringTag, V = A && b[Symbol.toStringTag] || b.constructor.name || \"Object\";\n        return V;\n      }\n    }\n    function Sa(b) {\n      try {\n        return _s(b), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function _s(b) {\n      return \"\" + b;\n    }\n    function Ts(b) {\n      if (Sa(b))\n        return S(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", xa(b)), _s(b);\n    }\n    var He = m.ReactCurrentOwner, Ea = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Os, ws, er;\n    er = {};\n    function Ca(b) {\n      if (St.call(b, \"ref\")) {\n        var A = Object.getOwnPropertyDescriptor(b, \"ref\").get;\n        if (A && A.isReactWarning)\n          return !1;\n      }\n      return b.ref !== void 0;\n    }\n    function Da(b) {\n      if (St.call(b, \"key\")) {\n        var A = Object.getOwnPropertyDescriptor(b, \"key\").get;\n        if (A && A.isReactWarning)\n          return !1;\n      }\n      return b.key !== void 0;\n    }\n    function ba(b, A) {\n      if (typeof b.ref == \"string\" && He.current && A && He.current.stateNode !== A) {\n        var V = T(He.current.type);\n        er[V] || (S('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', T(He.current.type), b.ref), er[V] = !0);\n      }\n    }\n    function ya(b, A) {\n      {\n        var V = function() {\n          Os || (Os = !0, S(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", A));\n        };\n        V.isReactWarning = !0, Object.defineProperty(b, \"key\", {\n          get: V,\n          configurable: !0\n        });\n      }\n    }\n    function Ra(b, A) {\n      {\n        var V = function() {\n          ws || (ws = !0, S(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", A));\n        };\n        V.isReactWarning = !0, Object.defineProperty(b, \"ref\", {\n          get: V,\n          configurable: !0\n        });\n      }\n    }\n    var Ma = function(b, A, V, Q, ct, pt, ot) {\n      var rt = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: e,\n        // Built-in properties that belong on the element\n        type: b,\n        key: A,\n        ref: V,\n        props: ot,\n        // Record the component responsible for creating this element.\n        _owner: pt\n      };\n      return rt._store = {}, Object.defineProperty(rt._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(rt, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: Q\n      }), Object.defineProperty(rt, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: ct\n      }), Object.freeze && (Object.freeze(rt.props), Object.freeze(rt)), rt;\n    };\n    function Pa(b, A, V, Q, ct) {\n      {\n        var pt, ot = {}, rt = null, Tt = null;\n        V !== void 0 && (Ts(V), rt = \"\" + V), Da(A) && (Ts(A.key), rt = \"\" + A.key), Ca(A) && (Tt = A.ref, ba(A, ct));\n        for (pt in A)\n          St.call(A, pt) && !Ea.hasOwnProperty(pt) && (ot[pt] = A[pt]);\n        if (b && b.defaultProps) {\n          var mt = b.defaultProps;\n          for (pt in mt)\n            ot[pt] === void 0 && (ot[pt] = mt[pt]);\n        }\n        if (rt || Tt) {\n          var Et = typeof b == \"function\" ? b.displayName || b.name || \"Unknown\" : b;\n          rt && ya(ot, Et), Tt && Ra(ot, Et);\n        }\n        return Ma(b, rt, Tt, ct, Q, He.current, ot);\n      }\n    }\n    var nr = m.ReactCurrentOwner, Is = m.ReactDebugCurrentFrame;\n    function _e(b) {\n      if (b) {\n        var A = b._owner, V = ut(b.type, b._source, A ? A.type : null);\n        Is.setExtraStackFrame(V);\n      } else\n        Is.setExtraStackFrame(null);\n    }\n    var rr;\n    rr = !1;\n    function sr(b) {\n      return typeof b == \"object\" && b !== null && b.$$typeof === e;\n    }\n    function Bs() {\n      {\n        if (nr.current) {\n          var b = T(nr.current.type);\n          if (b)\n            return `\n\nCheck the render method of \\`` + b + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function _a(b) {\n      return \"\";\n    }\n    var zs = {};\n    function Ta(b) {\n      {\n        var A = Bs();\n        if (!A) {\n          var V = typeof b == \"string\" ? b : b.displayName || b.name;\n          V && (A = `\n\nCheck the top-level render call using <` + V + \">.\");\n        }\n        return A;\n      }\n    }\n    function As(b, A) {\n      {\n        if (!b._store || b._store.validated || b.key != null)\n          return;\n        b._store.validated = !0;\n        var V = Ta(A);\n        if (zs[V])\n          return;\n        zs[V] = !0;\n        var Q = \"\";\n        b && b._owner && b._owner !== nr.current && (Q = \" It was passed a child from \" + T(b._owner.type) + \".\"), _e(b), S('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', V, Q), _e(null);\n      }\n    }\n    function Gs(b, A) {\n      {\n        if (typeof b != \"object\")\n          return;\n        if (tr(b))\n          for (var V = 0; V < b.length; V++) {\n            var Q = b[V];\n            sr(Q) && As(Q, A);\n          }\n        else if (sr(b))\n          b._store && (b._store.validated = !0);\n        else if (b) {\n          var ct = v(b);\n          if (typeof ct == \"function\" && ct !== b.entries)\n            for (var pt = ct.call(b), ot; !(ot = pt.next()).done; )\n              sr(ot.value) && As(ot.value, A);\n        }\n      }\n    }\n    function Oa(b) {\n      {\n        var A = b.type;\n        if (A == null || typeof A == \"string\")\n          return;\n        var V;\n        if (typeof A == \"function\")\n          V = A.propTypes;\n        else if (typeof A == \"object\" && (A.$$typeof === c || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        A.$$typeof === f))\n          V = A.propTypes;\n        else\n          return;\n        if (V) {\n          var Q = T(A);\n          va(V, b.props, \"prop\", Q, b);\n        } else if (A.PropTypes !== void 0 && !rr) {\n          rr = !0;\n          var ct = T(A);\n          S(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", ct || \"Unknown\");\n        }\n        typeof A.getDefaultProps == \"function\" && !A.getDefaultProps.isReactClassApproved && S(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function wa(b) {\n      {\n        for (var A = Object.keys(b.props), V = 0; V < A.length; V++) {\n          var Q = A[V];\n          if (Q !== \"children\" && Q !== \"key\") {\n            _e(b), S(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", Q), _e(null);\n            break;\n          }\n        }\n        b.ref !== null && (_e(b), S(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), _e(null));\n      }\n    }\n    var ks = {};\n    function $s(b, A, V, Q, ct, pt) {\n      {\n        var ot = P(b);\n        if (!ot) {\n          var rt = \"\";\n          (b === void 0 || typeof b == \"object\" && b !== null && Object.keys(b).length === 0) && (rt += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var Tt = _a();\n          Tt ? rt += Tt : rt += Bs();\n          var mt;\n          b === null ? mt = \"null\" : tr(b) ? mt = \"array\" : b !== void 0 && b.$$typeof === e ? (mt = \"<\" + (T(b.type) || \"Unknown\") + \" />\", rt = \" Did you accidentally export a JSX literal instead of a component?\") : mt = typeof b, S(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", mt, rt);\n        }\n        var Et = Pa(b, A, V, ct, pt);\n        if (Et == null)\n          return Et;\n        if (ot) {\n          var Nt = A.children;\n          if (Nt !== void 0)\n            if (Q)\n              if (tr(Nt)) {\n                for (var Te = 0; Te < Nt.length; Te++)\n                  Gs(Nt[Te], b);\n                Object.freeze && Object.freeze(Nt);\n              } else\n                S(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Gs(Nt, b);\n        }\n        if (St.call(A, \"key\")) {\n          var pe = T(b), zt = Object.keys(A).filter(function(ka) {\n            return ka !== \"key\";\n          }), or = zt.length > 0 ? \"{key: someKey, \" + zt.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n          if (!ks[pe + or]) {\n            var Ga = zt.length > 0 ? \"{\" + zt.join(\": ..., \") + \": ...}\" : \"{}\";\n            S(`A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />`, or, pe, Ga, pe), ks[pe + or] = !0;\n          }\n        }\n        return b === r ? wa(Et) : Oa(Et), Et;\n      }\n    }\n    function Ia(b, A, V) {\n      return $s(b, A, V, !0);\n    }\n    function Ba(b, A, V) {\n      return $s(b, A, V, !1);\n    }\n    var za = Ba, Aa = Ia;\n    Ue.Fragment = r, Ue.jsx = za, Ue.jsxs = Aa;\n  }()), Ue;\n}\n false ? 0 : Mr.exports = nl();\nvar it = Mr.exports;\nfunction Ht(t, e, n) {\n  const r = n.originalDatas;\n  r.groupable = r.groupable || {};\n  const s = r.groupable;\n  s.childDatas = s.childDatas || [];\n  const o = s.childDatas;\n  return t.moveables.map((i, a) => (o[a] = o[a] || {}, o[a][e] = o[a][e] || {}, {\n    ...n,\n    isRequestChild: !0,\n    datas: o[a][e],\n    originalDatas: o[a]\n  }));\n}\nfunction cr(t, e, n, r, s, o, i) {\n  const a = !!n.match(/Start$/g), c = !!n.match(/End$/g), l = s.isPinch, u = s.datas, f = Ht(t, e.name, s), d = t.moveables, p = [], g = f.map((h, v) => {\n    const m = d[v], S = m.state, x = S.gestos;\n    let C = h;\n    if (a)\n      C = new Fe(i).dragStart(r, h), p.push(C);\n    else {\n      if (x[i] || (x[i] = u.childGestos[v]), !x[i])\n        return;\n      C = vn(h, S, r, l, o, i), p.push(C);\n    }\n    const E = e[n](m, { ...C, parentFlag: !0 });\n    return c && (x[i] = null), E;\n  });\n  return a && (u.childGestos = d.map((h) => h.state.gestos[i])), {\n    eventParams: g,\n    childEvents: p\n  };\n}\nfunction ee(t, e, n, r, s = (i, a) => a, o) {\n  const i = !!n.match(/End$/g), a = Ht(t, e.name, r), c = t.moveables;\n  return a.map((u, f) => {\n    const d = c[f];\n    let p = u;\n    p = s(d, u);\n    const g = e[n](d, { ...p, parentFlag: !0 });\n    return g && o && o(d, u, g, f), i && (d.state.gestos = {}), g;\n  });\n}\nfunction kn(t, e, n, r) {\n  const s = n.fixedDirection, o = n.fixedPosition, i = r.datas.startPositions || jt(e.state), a = yt(i, s), [c, l] = _t(\n    hn(-t.rotation / 180 * Math.PI, 3),\n    [a[0] - o[0], a[1] - o[1], 1],\n    3\n  );\n  return r.datas.originalX = c, r.datas.originalY = l, r;\n}\nfunction li(t, e, n, r) {\n  const { renderPoses: s, rotation: o, direction: i } = t.getState(), { zoom: a } = De(t.props, e), c = tn(o / Math.PI * 180), l = {}, u = t.renderState;\n  u.renderDirectionMap || (u.renderDirectionMap = {});\n  const f = u.renderDirectionMap;\n  n.forEach(({ dir: p }) => {\n    l[p] = !0;\n  });\n  const d = wt(i);\n  return n.map(({ data: p, classNames: g, dir: h }) => {\n    const v = qr[h];\n    if (!v || !l[h])\n      return null;\n    f[h] = !0;\n    const m = (tt(c, 15) + d * Wo[h] + 720) % 180, S = {};\n    return Ve(p).forEach((x) => {\n      S[`data-${x}`] = p[x];\n    }), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\n      \"div\",\n      {\n        className: U(\"control\", \"direction\", h, e, ...g),\n        \"data-rotation\": m,\n        \"data-direction\": h,\n        ...S,\n        key: `direction-${h}`,\n        style: Nn(\n          o,\n          a,\n          ...v.map((x) => s[x])\n        )\n      }\n    );\n  });\n}\nfunction ui(t, e, n, r) {\n  const {\n    renderDirections: s = e,\n    displayAroundControls: o\n  } = De(t.props, n);\n  if (!s)\n    return [];\n  const i = s === !0 ? Xr : s;\n  return [\n    ...o ? gi(t, r, n, i) : [],\n    ...li(\n      t,\n      n,\n      i.map((a) => ({\n        data: {},\n        classNames: [],\n        dir: a\n      }))\n    )\n  ];\n}\nfunction un(t, e, n, r, s, o, ...i) {\n  const a = xt(n, r), c = e ? tt(a / Math.PI * 180, 15) % 180 : -1;\n  return /* @__PURE__ */ it.jsx(\n    \"div\",\n    {\n      className: U(\n        \"line\",\n        \"direction\",\n        e ? \"edge\" : \"\",\n        e,\n        ...i\n      ),\n      \"data-rotation\": c,\n      \"data-line-key\": o,\n      \"data-direction\": e,\n      style: Je(n, r, s, a)\n    },\n    `line-${o}`\n  );\n}\nfunction fi(t, e, n, r, s) {\n  return (n === !0 ? Ua : n).map((i, a) => {\n    const [c, l] = qr[i];\n    if (l != null)\n      return un(\n        t,\n        i,\n        r[c],\n        r[l],\n        s,\n        `${e}Edge${a}`,\n        e\n      );\n  }).filter(Boolean);\n}\nfunction di(t) {\n  return (e, n) => {\n    const r = De(e.props, t).edge;\n    return r && (r === !0 || r.length) ? [\n      ...fi(\n        n,\n        t,\n        r,\n        e.getState().renderPoses,\n        e.props.zoom\n      ),\n      ...rl(e, t, n)\n    ] : pi(e, t, n);\n  };\n}\nfunction pi(t, e, n) {\n  return ui(t, Xr, e, n);\n}\nfunction rl(t, e, n) {\n  return ui(\n    t,\n    [\"nw\", \"ne\", \"sw\", \"se\"],\n    e,\n    n\n  );\n}\nfunction gi(t, e, n, r) {\n  const s = t.renderState;\n  s.renderDirectionMap || (s.renderDirectionMap = {});\n  const { renderPoses: o, rotation: i, direction: a } = t.getState(), c = s.renderDirectionMap, { zoom: l } = t.props, u = wt(a), f = i / Math.PI * 180;\n  return (r || Ve(c)).map((d) => {\n    const p = qr[d];\n    if (!p)\n      return null;\n    const g = (tt(f, 15) + u * Wo[d] + 720) % 180, h = [\"around-control\"];\n    return n && h.push(\"direction\", n), /* @__PURE__ */ it.jsx(\n      \"div\",\n      {\n        className: U(...h),\n        \"data-rotation\": g,\n        \"data-direction\": d,\n        style: Nn(\n          i,\n          l,\n          ...p.map((v) => o[v])\n        )\n      },\n      `direction-around-${d}`\n    );\n  });\n}\nfunction as(t, e, n) {\n  const {\n    position: r = \"client\",\n    left: s = -1 / 0,\n    top: o = -1 / 0,\n    right: i = 1 / 0,\n    bottom: a = 1 / 0\n  } = t || {}, c = {\n    position: r,\n    left: s,\n    top: o,\n    right: i,\n    bottom: a\n  };\n  return {\n    vertical: Xs(c, e, !0),\n    horizontal: Xs(c, n, !1)\n  };\n}\nfunction Un(t, e) {\n  const {\n    containerClientRect: {\n      clientHeight: n,\n      clientWidth: r,\n      clientLeft: s,\n      clientTop: o\n    },\n    snapOffset: {\n      left: i,\n      top: a,\n      right: c,\n      bottom: l\n    }\n  } = t.state, u = e || t.props.bounds || {}, d = (u.position || \"client\") === \"css\", {\n    left: p = -1 / 0,\n    top: g = -1 / 0\n  } = u;\n  let {\n    right: h = d ? -1 / 0 : 1 / 0,\n    bottom: v = d ? -1 / 0 : 1 / 0\n  } = u;\n  return d && (h = r + c - i - h, v = n + l - a - v), {\n    left: p + i - s,\n    right: h + i - s,\n    top: g + a - o,\n    bottom: v + a - o\n  };\n}\nfunction sl(t, e, n) {\n  const {\n    left: r,\n    top: s,\n    right: o,\n    bottom: i\n  } = Un(t), [a, c] = n;\n  let [l, u] = K(n, e);\n  B(l) < Bt && (l = 0), B(u) < Bt && (u = 0);\n  const f = u > 0, d = l > 0, p = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }, g = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (l === 0 && u === 0)\n    return {\n      vertical: p,\n      horizontal: g\n    };\n  if (l === 0)\n    f ? i < c && (g.pos = i, g.offset = c - i) : s > c && (g.pos = s, g.offset = c - s);\n  else if (u === 0)\n    d ? o < a && (p.pos = o, p.offset = a - o) : r > a && (p.pos = r, p.offset = a - r);\n  else {\n    const h = u / l, v = n[1] - h * a;\n    let m = 0, S = 0, x = !1;\n    d && o <= a ? (m = h * o + v, S = o, x = !0) : !d && a <= r && (m = h * r + v, S = r, x = !0), x && (m < s || m > i) && (x = !1), x || (f && i <= c ? (m = i, S = (m - v) / h, x = !0) : !f && c <= s && (m = s, S = (m - v) / h, x = !0)), x && (p.isBound = !0, p.pos = S, p.offset = a - S, g.isBound = !0, g.pos = m, g.offset = c - m);\n  }\n  return {\n    vertical: p,\n    horizontal: g\n  };\n}\nfunction Xs(t, e, n) {\n  const r = t[n ? \"left\" : \"top\"], s = t[n ? \"right\" : \"bottom\"], o = Math.min(...e), i = Math.max(...e), a = [];\n  return r + 1 > o && a.push({\n    direction: \"start\",\n    isBound: !0,\n    offset: o - r,\n    pos: r\n  }), s - 1 < i && a.push({\n    direction: \"end\",\n    isBound: !0,\n    offset: i - s,\n    pos: s\n  }), a.length || a.push({\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }), a.sort((c, l) => B(l.offset) - B(c.offset));\n}\nfunction Hs(t, e, n) {\n  return (n ? t.map((s) => gn(s, n)) : t).some((s) => s[0] < e.left && B(s[0] - e.left) > 0.1 || s[0] > e.right && B(s[0] - e.right) > 0.1 || s[1] < e.top && B(s[1] - e.top) > 0.1 || s[1] > e.bottom && B(s[1] - e.bottom) > 0.1);\n}\nfunction ol(t, e, n) {\n  const r = Vt(t), s = Math.sqrt(r * r - e * e) || 0;\n  return [s, -s].sort((o, i) => B(o - t[n ? 0 : 1]) - B(i - t[n ? 0 : 1])).map((o) => xt([0, 0], n ? [o, e] : [e, o]));\n}\nfunction il(t, e, n, r, s) {\n  if (!t.props.bounds)\n    return [];\n  const o = s * Math.PI / 180, {\n    left: i,\n    top: a,\n    right: c,\n    bottom: l\n  } = Un(t), u = i - r[0], f = c - r[0], d = a - r[1], p = l - r[1], g = {\n    left: u,\n    top: d,\n    right: f,\n    bottom: p\n  };\n  if (!Hs(n, g, 0))\n    return [];\n  const h = [];\n  return [\n    [u, 0],\n    [f, 0],\n    [d, 1],\n    [p, 1]\n  ].forEach(([v, m]) => {\n    n.forEach((S) => {\n      const x = xt([0, 0], S);\n      h.push(...ol(S, v, m).map((C) => o + C - x).filter((C) => !Hs(e, g, C)).map((C) => tt(C * 180 / Math.PI, Bt)));\n    });\n  }), h;\n}\nconst al = [\"left\", \"right\", \"center\"], cl = [\"top\", \"bottom\", \"middle\"], qs = {\n  left: \"start\",\n  right: \"end\",\n  center: \"center\",\n  top: \"start\",\n  bottom: \"end\",\n  middle: \"center\"\n}, le = {\n  start: \"left\",\n  end: \"right\",\n  center: \"center\"\n}, ue = {\n  start: \"top\",\n  end: \"bottom\",\n  center: \"middle\"\n};\nfunction Be() {\n  return {\n    left: !1,\n    top: !1,\n    right: !1,\n    bottom: !1\n  };\n}\nfunction Xe(t, e) {\n  const {\n    props: {\n      snappable: n,\n      bounds: r,\n      innerBounds: s,\n      verticalGuidelines: o,\n      horizontalGuidelines: i,\n      snapGridWidth: a,\n      snapGridHeight: c\n    },\n    state: { guidelines: l, enableSnap: u }\n  } = t;\n  return !n || !u || e && n !== !0 && n.indexOf(e) < 0 ? !1 : !!(a || c || r || s || l && l.length || o && o.length || i && i.length);\n}\nfunction cs(t) {\n  return t === !1 ? {} : t === !0 || !t ? { left: !0, right: !0, top: !0, bottom: !0 } : t;\n}\nfunction ll(t, e) {\n  const n = cs(t), r = {};\n  for (const s in n)\n    s in e && n[s] && (r[s] = e[s]);\n  return r;\n}\nfunction ls(t, e) {\n  const n = ll(t, e), r = cl.filter((o) => o in n), s = al.filter((o) => o in n);\n  return {\n    horizontalNames: r,\n    verticalNames: s,\n    horizontal: r.map((o) => n[o]),\n    vertical: s.map((o) => n[o])\n  };\n}\nfunction ul(t, e, n) {\n  const r = ht(\n    t,\n    [e.clientLeft, e.clientTop],\n    n\n  );\n  return [\n    e.left + r[0],\n    e.top + r[1]\n  ];\n}\nfunction fl([t, e]) {\n  let n = e[0] - t[0], r = e[1] - t[1];\n  Math.abs(n) < Dt && (n = 0), Math.abs(r) < Dt && (r = 0);\n  let s = 0, o = 0, i = 0;\n  return n ? r ? (s = -r / n, o = 1, i = s * t[0] - t[1]) : (o = 1, i = -t[1]) : (s = -1, i = t[0]), [s, o, i].map((a) => tt(a, Dt));\n}\nconst hi = \"snapRotationThreshold\", vi = \"snapRotationDegrees\", mi = \"snapHorizontalThreshold\", xi = \"snapVerticalThreshold\";\nfunction Kn(t, e, n, r = [], s = [], o, i) {\n  var f;\n  const a = t.props, c = ((f = t.state.snapThresholdInfo) == null ? void 0 : f.multiples) || [1, 1], l = lo(\n    i,\n    a[mi],\n    5\n  ), u = lo(\n    o,\n    a[xi],\n    5\n  );\n  return Si(\n    t.state.guidelines,\n    e,\n    n,\n    r,\n    s,\n    l,\n    u,\n    c\n  );\n}\nfunction Si(t, e, n, r, s, o, i, a) {\n  return {\n    vertical: Ks(t, \"vertical\", e, i * a[0], r),\n    horizontal: Ks(t, \"horizontal\", n, o * a[1], s)\n  };\n}\nfunction dl(t, e, n) {\n  const [r, s] = n, [o, i] = e;\n  let [a, c] = K(n, e);\n  const l = c > 0, u = a > 0;\n  a = Wn(a), c = Wn(c);\n  const f = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  }, d = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (a === 0 && c === 0)\n    return {\n      vertical: f,\n      horizontal: d\n    };\n  const {\n    vertical: p,\n    horizontal: g\n  } = Kn(\n    t,\n    a ? [r] : [],\n    c ? [s] : [],\n    [],\n    [],\n    void 0,\n    void 0\n  );\n  p.posInfos.filter(({ pos: E }) => u ? E >= o : E <= o), g.posInfos.filter(({ pos: E }) => l ? E >= i : E <= i), p.isSnap = p.posInfos.length > 0, g.isSnap = g.posInfos.length > 0;\n  const {\n    isSnap: h,\n    guideline: v\n  } = Pr(p), {\n    isSnap: m,\n    guideline: S\n  } = Pr(g), x = m ? S.pos[1] : 0, C = h ? v.pos[0] : 0;\n  if (a === 0)\n    m && (d.isSnap = !0, d.pos = S.pos[1], d.offset = s - d.pos);\n  else if (c === 0)\n    h && (f.isSnap = !0, f.pos = C, f.offset = r - C);\n  else {\n    const E = c / a, D = n[1] - E * r;\n    let R = 0, y = 0, M = !1;\n    h ? (y = C, R = E * y + D, M = !0) : m && (R = x, y = (R - D) / E, M = !0), M && (f.isSnap = !0, f.pos = y, f.offset = r - y, d.isSnap = !0, d.pos = R, d.offset = s - R);\n  }\n  return {\n    vertical: f,\n    horizontal: d\n  };\n}\nfunction oe(t) {\n  let e = \"\";\n  return t === -1 || t === \"top\" || t === \"left\" ? e = \"start\" : t === 0 || t === \"center\" || t === \"middle\" ? e = \"center\" : (t === 1 || t === \"right\" || t === \"bottom\") && (e = \"end\"), e;\n}\nfunction Us(t, e, n, r) {\n  const s = ls(t.props.snapDirections, e), o = Kn(\n    t,\n    s.vertical,\n    s.horizontal,\n    s.verticalNames.map((c) => oe(c)),\n    s.horizontalNames.map((c) => oe(c)),\n    n,\n    r\n  ), i = oe(s.horizontalNames[o.horizontal.index]), a = oe(s.verticalNames[o.vertical.index]);\n  return {\n    vertical: {\n      ...o.vertical,\n      direction: a\n    },\n    horizontal: {\n      ...o.horizontal,\n      direction: i\n    }\n  };\n}\nfunction Pr(t) {\n  const e = t.isSnap;\n  if (!e)\n    return {\n      isSnap: !1,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null\n    };\n  const n = t.posInfos[0], r = n.guidelineInfos[0], s = r.offset, o = r.dist, i = r.guideline;\n  return {\n    isSnap: e,\n    offset: s,\n    dist: o,\n    pos: n.pos,\n    guideline: i\n  };\n}\nfunction Ks(t, e, n, r, s = []) {\n  var l;\n  if (!t || !t.length)\n    return {\n      isSnap: !1,\n      index: -1,\n      direction: \"\",\n      posInfos: []\n    };\n  const i = e === \"vertical\" ? 0 : 1, a = n.map((u, f) => {\n    const d = s[f] || \"\", p = t.map((g) => {\n      const { pos: h } = g, v = u - h[i];\n      return {\n        offset: v,\n        dist: B(v),\n        guideline: g,\n        direction: d\n      };\n    }).filter(({ guideline: g, dist: h }) => {\n      const { type: v } = g;\n      return !(v !== e || h > r);\n    }).sort(\n      (g, h) => g.dist - h.dist\n    );\n    return {\n      pos: u,\n      index: f,\n      guidelineInfos: p,\n      direction: d\n    };\n  }).filter((u) => u.guidelineInfos.length > 0).sort((u, f) => u.guidelineInfos[0].dist - f.guidelineInfos[0].dist), c = a.length > 0;\n  return {\n    isSnap: c,\n    index: c ? a[0].index : -1,\n    direction: ((l = a[0]) == null ? void 0 : l.direction) ?? \"\",\n    posInfos: a\n  };\n}\nfunction pl(t, e, n, r, s) {\n  let o = [];\n  n[0] && n[1] ? o = [\n    n,\n    [-n[0], n[1]],\n    [n[0], -n[1]]\n  ] : !n[0] && !n[1] ? [\n    [-1, -1],\n    [1, -1],\n    [1, 1],\n    [-1, 1]\n  ].forEach((d, p, g) => {\n    const h = g[p + 1] || g[0];\n    o.push(d), o.push([\n      (d[0] + h[0]) / 2,\n      (d[1] + h[1]) / 2\n    ]);\n  }) : t.props.keepRatio ? o.push(\n    [-1, -1],\n    [-1, 1],\n    [1, -1],\n    [1, 1],\n    n\n  ) : (o.push(...Lc([\n    [-1, -1],\n    [1, -1],\n    [-1, -1],\n    [1, 1]\n  ], n)), o.length > 1 && o.push([\n    (o[0][0] + o[1][0]) / 2,\n    (o[0][1] + o[1][1]) / 2\n  ]));\n  const i = o.map((d) => yt(e, d)), a = i.map((d) => d[0]), c = i.map((d) => d[1]), l = Kn(\n    t,\n    a,\n    c,\n    o.map((d) => oe(d[0])),\n    o.map((d) => oe(d[1])),\n    r,\n    s\n  ), u = oe(o.map((d) => d[0])[l.vertical.index]), f = oe(o.map((d) => d[1])[l.horizontal.index]);\n  return {\n    vertical: {\n      ...l.vertical,\n      direction: u\n    },\n    horizontal: {\n      ...l.horizontal,\n      direction: f\n    }\n  };\n}\nfunction Ei(t, e) {\n  const n = B(t.offset), r = B(e.offset);\n  return t.isBound && e.isBound ? r - n : t.isBound ? -1 : e.isBound ? 1 : t.isSnap && e.isSnap ? r - n : t.isSnap ? -1 : e.isSnap || n < Bt ? 1 : r < Bt ? -1 : n - r;\n}\nfunction $n(t, e) {\n  return t.slice().sort((n, r) => {\n    const s = n.sign[e], o = r.sign[e], i = n.offset[e], a = r.offset[e];\n    if (s) {\n      if (!o)\n        return -1;\n    } else return 1;\n    return Ei(\n      { isBound: n.isBound, isSnap: n.isSnap, offset: i },\n      { isBound: r.isBound, isSnap: r.isSnap, offset: a }\n    );\n  })[0];\n}\nfunction gl(t, e, n) {\n  const r = [];\n  if (n)\n    B(e[0]) !== 1 || B(e[1]) !== 1 ? r.push(\n      [e, [-1, -1]],\n      [e, [-1, 1]],\n      [e, [1, -1]],\n      [e, [1, 1]]\n    ) : r.push(\n      [e, [t[0], -t[1]]],\n      [e, [-t[0], t[1]]]\n    ), r.push([e, t]);\n  else if (t[0] && t[1] || !t[0] && !t[1]) {\n    const s = t[0] ? t : [1, 1];\n    [1, -1].forEach((o) => {\n      [1, -1].forEach((i) => {\n        const a = [o * s[0], i * s[1]];\n        e[0] === a[0] && e[1] === a[1] || r.push([e, a]);\n      });\n    });\n  } else t[0] ? (B(e[0]) === 1 ? [1] : [1, -1]).forEach((o) => {\n    r.push(\n      [\n        [e[0], -1],\n        [o * t[0], -1]\n      ],\n      [\n        [e[0], 0],\n        [o * t[0], 0]\n      ],\n      [\n        [e[0], 1],\n        [o * t[0], 1]\n      ]\n    );\n  }) : t[1] && (B(e[1]) === 1 ? [1] : [1, -1]).forEach((o) => {\n    r.push(\n      [\n        [-1, e[1]],\n        [-1, o * t[1]]\n      ],\n      [\n        [0, e[1]],\n        [0, o * t[1]]\n      ],\n      [\n        [1, e[1]],\n        [1, o * t[1]]\n      ]\n    );\n  });\n  return r;\n}\nfunction Ci(t, e) {\n  const n = yr([e[0][0], e[1][0]]), r = yr([e[0][1], e[1][1]]);\n  return {\n    vertical: n <= t[0],\n    horizontal: r <= t[1]\n  };\n}\nfunction us(t, [e, n]) {\n  let r = n[0] - e[0], s = n[1] - e[1];\n  B(r) < Bt && (r = 0), B(s) < Bt && (s = 0);\n  let o, i;\n  return r ? s ? (o = s / r * (t[0] - e[0]) + e[1], i = t[1]) : (o = e[1], i = t[1]) : (o = e[0], i = t[0]), o - i;\n}\nfunction Di(t, e, n, r = Bt) {\n  return t.every((s) => {\n    const o = us(s, e);\n    return o <= 0 === n || B(o) <= r;\n  });\n}\nfunction Zs(t, e, n, r, s = 0) {\n  return r && e - s <= t || !r && t <= n + s ? {\n    isBound: !0,\n    offset: r ? e - t : n - t\n  } : {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction hl(t, { line: e, centerSign: n, verticalSign: r, horizontalSign: s, lineConstants: o }) {\n  const i = t.props.innerBounds;\n  if (!i)\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  const { left: a, top: c, width: l, height: u } = i, f = [[a, c], [a, c + u]], d = [[a, c], [a + l, c]], p = [[a + l, c], [a + l, c + u]], g = [[a, c + u], [a + l, c + u]];\n  if (Di([\n    [a, c],\n    [a + l, c],\n    [a, c + u],\n    [a + l, c + u]\n  ], e, n))\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  const h = ie(e, o, d, r), v = ie(e, o, g, r), m = ie(e, o, f, s), S = ie(e, o, p, s), x = h.isBound && v.isBound, C = h.isBound || v.isBound, E = m.isBound && S.isBound, D = m.isBound || S.isBound, R = Ne(h.offset, v.offset), y = Ne(m.offset, S.offset);\n  let M = [0, 0], P = !1, _ = !1;\n  return B(y) < B(R) ? (M = [R, 0], P = C, _ = x) : (M = [0, y], P = D, _ = E), {\n    isAllBound: _,\n    isVerticalBound: C,\n    isHorizontalBound: D,\n    isBound: P,\n    offset: M\n  };\n}\nfunction ie(t, [e, n], r, s, o, i) {\n  const a = t[0], c = r[0], l = r[1], u = Wn(l[1] - c[1]), f = Wn(l[0] - c[0]), d = n, p = e, g = -e / n;\n  if (f) {\n    if (!u) {\n      if (i && !d)\n        return {\n          isBound: !1,\n          offset: 0\n        };\n      if (p) {\n        const h = (c[1] - a[1]) / g + a[0];\n        return Zs(h, c[0], l[0], s, o);\n      } else {\n        const h = c[1] - a[1], v = B(h) <= (o || 0);\n        return {\n          isBound: v,\n          offset: v ? h : 0\n        };\n      }\n    }\n  } else {\n    if (i && !p)\n      return {\n        isBound: !1,\n        offset: 0\n      };\n    if (d) {\n      const h = g * (c[0] - a[0]) + a[1];\n      return Zs(h, c[1], l[1], s, o);\n    } else {\n      const h = c[0] - a[0], v = B(h) <= (o || 0);\n      return {\n        isBound: v,\n        offset: v ? h : 0\n      };\n    }\n  }\n  return {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction bi(t, e, n) {\n  return e.map((r) => {\n    const {\n      isBound: s,\n      offset: o,\n      isVerticalBound: i,\n      isHorizontalBound: a\n    } = hl(t, r), c = r.multiple, l = Qt({\n      datas: n,\n      distX: o[0],\n      distY: o[1]\n    }).map((u, f) => u * (c[f] ? 2 / c[f] : 0));\n    return {\n      sign: c,\n      isBound: s,\n      isVerticalBound: i,\n      isHorizontalBound: a,\n      isSnap: !1,\n      offset: l\n    };\n  });\n}\nfunction vl(t, e, n) {\n  const r = fs(t, e, [0, 0], !1).map((f) => ({\n    ...f,\n    multiple: f.multiple.map((d) => B(d) * 2)\n  })), s = bi(t, r, n), o = $n(s, 0), i = $n(s, 1);\n  let a = 0, c = 0;\n  const l = o.isVerticalBound || i.isVerticalBound, u = o.isHorizontalBound || i.isHorizontalBound;\n  return (l || u) && ([a, c] = $c({\n    datas: n,\n    distX: -o.offset[0],\n    distY: -i.offset[1]\n  })), {\n    vertical: {\n      isBound: l,\n      offset: a\n    },\n    horizontal: {\n      isBound: u,\n      offset: c\n    }\n  };\n}\nfunction ml(t, e) {\n  const n = [], r = t[0], s = t[1];\n  return r && s ? n.push(\n    [[0, s * 2], t, [-r, s]],\n    [[r * 2, 0], t, [r, -s]]\n  ) : r ? (n.push(\n    [[r * 2, 0], [r, 1], [r, -1]]\n  ), e && n.push(\n    [[0, -1], [r, -1], [-r, -1]],\n    [[0, 1], [r, 1], [-r, 1]]\n  )) : s ? (n.push(\n    [[0, s * 2], [1, s], [-1, s]]\n  ), e && n.push(\n    [[-1, 0], [-1, s], [-1, -s]],\n    [[1, 0], [1, s], [1, -s]]\n  )) : n.push(\n    [[-1, 0], [-1, -1], [-1, 1]],\n    [[1, 0], [1, -1], [1, 1]],\n    [[0, -1], [-1, -1], [1, -1]],\n    [[0, 1], [-1, 1], [1, 1]]\n  ), n;\n}\nfunction fs(t, e, n, r) {\n  const {\n    allMatrix: s,\n    is3d: o\n  } = t.state, i = Me(s, 100, 100, o ? 4 : 3), a = yt(i, [0, 0]);\n  return ml(n, r).map(([c, l, u]) => {\n    const f = [\n      yt(i, l),\n      yt(i, u)\n    ], d = fl(f), {\n      vertical: p,\n      horizontal: g\n    } = Ci(a, f), h = us(a, f) <= 0;\n    return {\n      multiple: c,\n      centerSign: h,\n      verticalSign: p,\n      horizontalSign: g,\n      lineConstants: d,\n      line: [\n        yt(e, l),\n        yt(e, u)\n      ]\n    };\n  });\n}\nfunction Js(t, e, n, r) {\n  const s = r ? t.map((o) => gn(o, r)) : t;\n  return [\n    [s[0], s[1]],\n    [s[1], s[3]],\n    [s[3], s[2]],\n    [s[2], s[0]]\n  ].some((o) => {\n    const i = us(n, o) <= 0;\n    return !Di(e, o, i);\n  });\n}\nfunction xl([t, e]) {\n  const n = e[0] - t[0], r = e[1] - t[1];\n  if (!n)\n    return B(t[0]);\n  if (!r)\n    return B(t[1]);\n  const s = r / n;\n  return B((-s * t[0] + t[1]) / Math.sqrt(Math.pow(s, 2) + 1));\n}\nfunction Sl([t, e]) {\n  const n = e[0] - t[0], r = e[1] - t[1];\n  if (!n)\n    return [t[0], 0];\n  if (!r)\n    return [0, t[1]];\n  const s = r / n, o = -s * t[0] + t[1];\n  return [\n    -o / (s + 1 / s),\n    o / (s * s + 1)\n  ];\n}\nfunction El(t, e, n, r, s) {\n  const o = t.props.innerBounds, i = s * Math.PI / 180;\n  if (!o)\n    return [];\n  const {\n    left: a,\n    top: c,\n    width: l,\n    height: u\n  } = o, f = a - r[0], d = a + l - r[0], p = c - r[1], g = c + u - r[1], h = [\n    [f, p],\n    [d, p],\n    [f, g],\n    [d, g]\n  ], v = yt(n, [0, 0]);\n  if (!Js(n, h, v, 0))\n    return [];\n  const m = [], S = h.map((x) => [\n    Vt(x),\n    xt([0, 0], x)\n  ]);\n  return [\n    [n[0], n[1]],\n    [n[1], n[3]],\n    [n[3], n[2]],\n    [n[2], n[0]]\n  ].forEach((x) => {\n    const C = xt([0, 0], Sl(x)), E = xl(x);\n    m.push(...S.filter(([D]) => D && E <= D).map(([D, R]) => {\n      const y = Math.acos(D ? E / D : 0), M = R + y, P = R - y;\n      return [\n        i + M - C,\n        i + P - C\n      ];\n    }).reduce((D, R) => (D.push(...R), D), []).filter((D) => !Js(e, h, v, D)).map((D) => tt(D * 180 / Math.PI, Bt)));\n  }), m;\n}\nfunction Cl(t) {\n  const e = t.props.innerBounds, n = Be();\n  if (!e)\n    return {\n      boundMap: n,\n      vertical: [],\n      horizontal: []\n    };\n  const {\n    pos1: r,\n    pos2: s,\n    pos3: o,\n    pos4: i\n  } = t.getRect(), a = [r, s, o, i], c = yt(a, [0, 0]), { left: l, top: u, width: f, height: d } = e, p = [[l, u], [l, u + d]], g = [[l, u], [l + f, u]], h = [[l + f, u], [l + f, u + d]], v = [[l, u + d], [l + f, u + d]], m = fs(t, a, [0, 0], !1), S = [], x = [];\n  return m.forEach((C) => {\n    const { line: E, lineConstants: D } = C, {\n      horizontal: R,\n      vertical: y\n    } = Ci(c, E), M = ie(E, D, g, y, 1, !0), P = ie(E, D, v, y, 1, !0), _ = ie(E, D, p, R, 1, !0), O = ie(E, D, h, R, 1, !0);\n    M.isBound && !n.top && (S.push(u), n.top = !0), P.isBound && !n.bottom && (S.push(u + d), n.bottom = !0), _.isBound && !n.left && (x.push(l), n.left = !0), O.isBound && !n.right && (x.push(l + f), n.right = !0);\n  }), {\n    boundMap: n,\n    horizontal: S,\n    vertical: x\n  };\n}\nfunction Dl(t, e, n, r) {\n  let s = e[0] - t[0], o = e[1] - t[1];\n  if (B(s) < Dt && (s = 0), B(o) < Dt && (o = 0), !s)\n    return r ? [0, 0] : [0, n];\n  if (!o)\n    return r ? [n, 0] : [0, 0];\n  const i = o / s, a = t[1] - i * t[0];\n  if (r) {\n    const c = i * (e[0] + n) + a;\n    return [n, c - e[1]];\n  } else\n    return [(e[1] + n - a) / i - e[0], n];\n}\nfunction _r(t, e, n, r, s) {\n  const o = Dl(t, e, n, r);\n  if (!o)\n    return {\n      isOutside: !1,\n      offset: [0, 0]\n    };\n  const i = te(t, e), a = te(o, t), c = te(o, e), l = a > i || c > i, [u, f] = Qt({\n    datas: s,\n    distX: o[0],\n    distY: o[1]\n  });\n  return {\n    offset: [u, f],\n    isOutside: l\n  };\n}\nfunction Fn(t, e) {\n  return t.isBound ? t.offset : e.isSnap ? Pr(e).offset : 0;\n}\nfunction bl(t, [e, n], [r, s], [o, i], [a, c]) {\n  let l = -a, u = -c;\n  if (t && e && n) {\n    l = 0, u = 0;\n    const f = [];\n    if (r && s ? f.push([0, c], [a, 0]) : r ? f.push([a, 0]) : s ? f.push([0, c]) : o && i ? f.push([0, c], [a, 0]) : o ? f.push([a, 0]) : i && f.push([0, c]), f.length) {\n      f.sort((p, g) => Vt(K([e, n], p)) - Vt(K([e, n], g)));\n      const d = f[0];\n      if (d[0] && B(e) > Dt)\n        l = -d[0], u = n * B(e + l) / B(e) - n;\n      else if (d[1] && B(n) > Dt) {\n        const p = n;\n        u = -d[1], l = e * B(n + u) / B(p) - e;\n      }\n      if (t && s && r)\n        if (B(l) > Dt && B(l) < B(a)) {\n          const p = B(a) / B(l);\n          l *= p, u *= p;\n        } else if (B(u) > Dt && B(u) < B(c)) {\n          const p = B(c) / B(u);\n          l *= p, u *= p;\n        } else\n          l = Ne(-a, l), u = Ne(-c, u);\n    }\n  } else\n    l = e || r ? -a : 0, u = n || s ? -c : 0;\n  return [l, u];\n}\nfunction yl(t, e, n, r, s, o) {\n  if (!Xe(t, \"draggable\"))\n    return [\n      {\n        isSnap: !1,\n        isBound: !1,\n        offset: 0\n      },\n      {\n        isSnap: !1,\n        isBound: !1,\n        offset: 0\n      }\n    ];\n  const i = hs(o.absolutePoses, [e, n]), { left: a, right: c, top: l, bottom: u } = Yt(i), f = {\n    horizontal: i.map((P) => P[1]),\n    vertical: i.map((P) => P[0])\n  }, d = cs(t.props.snapDirections), p = ls(d, {\n    left: a,\n    right: c,\n    top: l,\n    bottom: u,\n    center: (a + c) / 2,\n    middle: (l + u) / 2\n  }), {\n    vertical: g,\n    horizontal: h\n  } = Zn(t, s, p, f), {\n    vertical: v,\n    horizontal: m\n  } = vl(t, i, o), S = g.isSnap, x = h.isSnap, C = g.isBound || v.isBound, E = h.isBound || m.isBound, D = Ne(\n    g.offset,\n    v.offset\n  ), R = Ne(\n    h.offset,\n    m.offset\n  ), [y, M] = bl(\n    r,\n    [e, n],\n    [C, E],\n    [S, x],\n    [D, R]\n  );\n  return [\n    {\n      isBound: C,\n      isSnap: S,\n      offset: y\n    },\n    {\n      isBound: E,\n      isSnap: x,\n      offset: M\n    }\n  ];\n}\nfunction Zn(t, e, n, r = n) {\n  const {\n    horizontal: s,\n    vertical: o\n  } = as(\n    Un(t),\n    r.vertical,\n    r.horizontal\n  ), {\n    horizontal: i,\n    vertical: a\n  } = e ? {\n    horizontal: { isSnap: !1, index: -1 },\n    vertical: { isSnap: !1, index: -1 }\n  } : Kn(\n    t,\n    n.vertical,\n    n.horizontal,\n    void 0,\n    void 0,\n    void 0,\n    void 0\n  ), c = Fn(\n    s[0],\n    i\n  ), l = Fn(\n    o[0],\n    a\n  ), u = B(c), f = B(l);\n  return {\n    horizontal: {\n      isBound: s[0].isBound,\n      isSnap: i.isSnap,\n      snapIndex: i.index,\n      offset: c,\n      dist: u,\n      bounds: s,\n      snap: i\n    },\n    vertical: {\n      isBound: o[0].isBound,\n      isSnap: a.isSnap,\n      snapIndex: a.index,\n      offset: l,\n      dist: f,\n      bounds: o,\n      snap: a\n    }\n  };\n}\nfunction Qs(t, e, n, r, s, o, i = [1, 1]) {\n  const {\n    horizontal: a,\n    vertical: c\n  } = as(e, n, r), {\n    horizontal: l,\n    vertical: u\n  } = Si(\n    t,\n    n,\n    r,\n    [],\n    [],\n    s,\n    o,\n    i\n  ), f = Fn(\n    a[0],\n    l\n  ), d = Fn(\n    c[0],\n    u\n  ), p = B(f), g = B(d);\n  return {\n    horizontal: {\n      isBound: a[0].isBound,\n      isSnap: l.isSnap,\n      snapIndex: l.index,\n      offset: f,\n      dist: p,\n      bounds: a,\n      snap: l\n    },\n    vertical: {\n      isBound: c[0].isBound,\n      isSnap: u.isSnap,\n      snapIndex: u.index,\n      offset: d,\n      dist: g,\n      bounds: c,\n      snap: u\n    }\n  };\n}\nfunction Rl(t, e, n, r) {\n  const s = xt(t, e) / Math.PI * 180, {\n    vertical: {\n      isBound: o,\n      isSnap: i,\n      dist: a\n    },\n    horizontal: {\n      isBound: c,\n      isSnap: l,\n      dist: u\n    }\n  } = n, f = s % 180, d = f < 3 || f > 177, p = f > 87 && f < 93;\n  return u < a && (o || i && !p && (!r || !d)) ? \"vertical\" : c || l && !d && (!r || !p) ? \"horizontal\" : \"\";\n}\nfunction Ml(t, e, n, r, s, o) {\n  return n.map(([i, a]) => {\n    const c = yt(e, i), l = yt(e, a), u = r ? Pl(\n      t,\n      c,\n      l,\n      s\n    ) : Zn(t, s, {\n      vertical: [l[0]],\n      horizontal: [l[1]]\n    }), {\n      horizontal: {\n        // dist: otherHorizontalDist,\n        offset: f,\n        isBound: d,\n        isSnap: p\n      },\n      vertical: {\n        // dist: otherVerticalDist,\n        offset: g,\n        isBound: h,\n        isSnap: v\n      }\n    } = u, m = K(a, i);\n    if (!g && !f)\n      return {\n        isBound: h || d,\n        isSnap: v || p,\n        sign: m,\n        offset: [0, 0]\n      };\n    const S = Rl(\n      c,\n      l,\n      u,\n      r\n    );\n    if (!S)\n      return {\n        sign: m,\n        isBound: !1,\n        isSnap: !1,\n        offset: [0, 0]\n      };\n    const x = S === \"vertical\";\n    let C = [0, 0];\n    return !r && B(a[0]) === 1 && B(a[1]) === 1 && i[0] !== a[0] && i[1] !== a[1] ? C = Qt({\n      datas: o,\n      distX: -g,\n      distY: -f\n    }) : C = _r(\n      c,\n      l,\n      -(x ? g : f),\n      x,\n      o\n    ).offset, C = C.map((E, D) => E * (m[D] ? 2 / m[D] : 0)), {\n      sign: m,\n      isBound: x ? h : d,\n      isSnap: x ? v : p,\n      offset: C\n    };\n  });\n}\nfunction to(t, e) {\n  return t.isBound ? t.offset : e.isSnap ? e.offset : 0;\n}\nfunction Pl(t, e, n, r) {\n  const {\n    horizontal: s,\n    vertical: o\n  } = sl(t, e, n), {\n    horizontal: i,\n    vertical: a\n  } = r ? {\n    horizontal: { isSnap: !1 },\n    vertical: { isSnap: !1 }\n  } : dl(t, e, n), c = to(\n    s,\n    i\n  ), l = to(\n    o,\n    a\n  ), u = B(c), f = B(l);\n  return {\n    horizontal: {\n      isBound: s.isBound,\n      isSnap: i.isSnap,\n      offset: c,\n      dist: u\n    },\n    vertical: {\n      isBound: o.isBound,\n      isSnap: a.isSnap,\n      offset: l,\n      dist: f\n    }\n  };\n}\nfunction _l(t, e, n, r, s) {\n  const o = [-n[0], -n[1]], { width: i, height: a } = t.state, c = t.props.bounds;\n  let l = 1 / 0, u = 1 / 0;\n  if (c) {\n    const f = [\n      [n[0], -n[1]],\n      [-n[0], n[1]]\n    ], {\n      left: d = -1 / 0,\n      top: p = -1 / 0,\n      right: g = 1 / 0,\n      bottom: h = 1 / 0\n    } = c;\n    f.forEach((v) => {\n      const m = v[0] !== o[0], S = v[1] !== o[1], x = yt(e, v), C = xt(r, x) * 360 / Math.PI;\n      if (S) {\n        const E = x.slice();\n        (B(C - 360) < 2 || B(C - 180) < 2) && (E[1] = r[1]);\n        const {\n          offset: [, D],\n          isOutside: R\n        } = _r(\n          r,\n          E,\n          (r[1] < x[1] ? h : p) - x[1],\n          !1,\n          s\n        );\n        isNaN(D) || (u = a + (R ? 1 : -1) * B(D));\n      }\n      if (m) {\n        const E = x.slice();\n        (B(C - 90) < 2 || B(C - 270) < 2) && (E[0] = r[0]);\n        const {\n          offset: [D],\n          isOutside: R\n        } = _r(\n          r,\n          E,\n          (r[0] < x[0] ? g : d) - x[0],\n          !0,\n          s\n        );\n        isNaN(D) || (l = i + (R ? 1 : -1) * B(D));\n      }\n    });\n  }\n  return {\n    maxWidth: l,\n    maxHeight: u\n  };\n}\nconst Ot = {\n  name: \"draggable\",\n  props: [\n    \"draggable\",\n    \"throttleDrag\",\n    \"throttleDragRotate\",\n    \"hideThrottleDragRotateLine\",\n    \"startDragRotate\",\n    \"edgeDraggable\"\n  ],\n  events: [\n    \"dragStart\",\n    \"drag\",\n    \"dragEnd\",\n    \"dragGroupStart\",\n    \"dragGroup\",\n    \"dragGroupEnd\"\n  ],\n  requestStyle() {\n    return [\"left\", \"top\", \"right\", \"bottom\"];\n  },\n  requestChildStyle() {\n    return [\"left\", \"top\", \"right\", \"bottom\"];\n  },\n  render(t, e) {\n    const { hideThrottleDragRotateLine: n, throttleDragRotate: r, zoom: s } = t.props, { dragInfo: o, beforeOrigin: i } = t.getState();\n    if (n || !r || !o)\n      return [];\n    const a = o.dist;\n    if (!a[0] && !a[1])\n      return [];\n    const c = Vt(a), l = xt(a, [0, 0]);\n    return [/* @__PURE__ */ it.jsx(\"div\", { className: U(\n      \"line\",\n      \"horizontal\",\n      \"dragline\",\n      \"dashed\"\n    ), style: {\n      width: `${c}px`,\n      transform: `translate(${i[0]}px, ${i[1]}px) rotate(${l}rad) scaleY(${s})`\n    } }, \"dragRotateGuideline\")];\n  },\n  dragStart(t, e) {\n    const { datas: n, parentEvent: r, parentGesto: s } = e, o = t.state, {\n      gestos: i,\n      style: a\n    } = o;\n    if (i.draggable)\n      return !1;\n    i.draggable = s || t.targetGesto, n.datas = {}, n.left = parseFloat(a.left || \"\") || 0, n.top = parseFloat(a.top || \"\") || 0, n.bottom = parseFloat(a.bottom || \"\") || 0, n.right = parseFloat(a.right || \"\") || 0, n.startValue = [0, 0], Re(t, e), qn(t, e, \"translate\"), nu(t, n), n.prevDist = [0, 0], n.prevBeforeDist = [0, 0], n.isDrag = !1, n.deltaOffset = [0, 0];\n    const c = et(t, e, {\n      set: (u) => {\n        n.startValue = u;\n      },\n      ...Hn(t, e)\n    });\n    return (r || j(t, \"onDragStart\", c)) !== !1 ? (n.isDrag = !0, t.state.dragInfo = {\n      startRect: t.getRect(),\n      dist: [0, 0]\n    }) : (i.draggable = null, n.isPinch = !1), n.isDrag ? c : !1;\n  },\n  drag(t, e) {\n    if (!e)\n      return;\n    jn(t, e, \"translate\");\n    const {\n      datas: n,\n      parentEvent: r,\n      parentFlag: s,\n      isPinch: o,\n      deltaOffset: i,\n      useSnap: a,\n      isRequest: c,\n      isGroup: l,\n      parentThrottleDrag: u\n    } = e;\n    let { distX: f, distY: d } = e;\n    const { isDrag: p, prevDist: g, prevBeforeDist: h, startValue: v } = n;\n    if (!p)\n      return;\n    i && (f += i[0], d += i[1]);\n    const m = t.props, S = m.parentMoveable, x = l ? 0 : m.throttleDrag || u || 0, C = r ? 0 : m.throttleDragRotate || 0;\n    let E = 0, D = !1, R = !1, y = !1, M = !1;\n    if (!r && C > 0 && (f || d)) {\n      const W = m.startDragRotate || 0, J = tt(W + xt([0, 0], [f, d]) * 180 / Math.PI, C) - W, q = d * Math.abs(Math.cos((J - 90) / 180 * Math.PI)), F = f * Math.abs(Math.cos(J / 180 * Math.PI)), H = Vt([F, q]);\n      E = J * Math.PI / 180, f = H * Math.cos(E), d = H * Math.sin(E);\n    }\n    if (!o && !r && !s) {\n      const [W, J] = yl(\n        t,\n        f,\n        d,\n        C,\n        !a && c || i,\n        n\n      );\n      D = W.isSnap, R = W.isBound, y = J.isSnap, M = J.isBound;\n      const q = W.offset, F = J.offset;\n      f += q, d += F;\n    }\n    const P = at(si({ datas: n, distX: f, distY: d }), v), _ = at(kc({ datas: n, distX: f, distY: d }), v);\n    Ws(_, Bt), Ws(P, Bt), C || (!D && !R && (_[0] = tt(_[0], x), P[0] = tt(P[0], x)), !y && !M && (_[1] = tt(_[1], x), P[1] = tt(P[1], x)));\n    const O = K(P, v), T = K(_, v), w = K(T, g), k = K(O, h);\n    n.prevDist = T, n.prevBeforeDist = O, n.passDelta = w, n.passDist = T;\n    const I = n.left + O[0], $ = n.top + O[1], G = n.right - O[0], L = n.bottom - O[1], z = Xn(\n      n,\n      `translate(${_[0]}px, ${_[1]}px)`,\n      `translate(${T[0]}px, ${T[1]}px)`\n    );\n    if (os(e, z), t.state.dragInfo.dist = r ? [0, 0] : T, !r && !S && w.every((W) => !W) && k.some((W) => !W))\n      return;\n    const {\n      width: N,\n      height: Z\n    } = t.state, Y = et(t, e, {\n      transform: z,\n      dist: T,\n      delta: w,\n      translate: _,\n      beforeDist: O,\n      beforeDelta: k,\n      beforeTranslate: P,\n      left: I,\n      top: $,\n      right: G,\n      bottom: L,\n      width: N,\n      height: Z,\n      isPinch: o,\n      ...It({\n        transform: z\n      }, e)\n    });\n    return !r && j(t, \"onDrag\", Y), Y;\n  },\n  dragAfter(t, e) {\n    const n = e.datas, {\n      deltaOffset: r\n    } = n;\n    return r[0] || r[1] ? (n.deltaOffset = [0, 0], this.drag(t, { ...e, deltaOffset: r })) : !1;\n  },\n  dragEnd(t, e) {\n    const { parentEvent: n, datas: r } = e;\n    if (t.state.dragInfo = null, !r.isDrag)\n      return;\n    r.isDrag = !1;\n    const s = $t(t, e, {});\n    return !n && j(t, \"onDragEnd\", s), s;\n  },\n  dragGroupStart(t, e) {\n    var f;\n    const { datas: n, clientX: r, clientY: s } = e, o = this.dragStart(t, e);\n    if (!o)\n      return !1;\n    const {\n      childEvents: i,\n      eventParams: a\n    } = cr(t, this, \"dragStart\", [\n      r || 0,\n      s || 0\n    ], e, !1, \"draggable\"), c = {\n      ...o,\n      targets: t.props.targets,\n      events: a\n    }, l = j(t, \"onDragGroupStart\", c);\n    n.isDrag = l !== !1;\n    const u = ((f = i[0]) == null ? void 0 : f.datas.startValue) ?? [0, 0];\n    return n.throttleOffset = [u[0] % 1, u[1] % 1], n.isDrag ? o : !1;\n  },\n  dragGroup(t, e) {\n    const { datas: n } = e;\n    if (!n.isDrag)\n      return;\n    const r = this.drag(t, {\n      ...e,\n      parentThrottleDrag: t.props.throttleDrag\n    }), { passDelta: s } = e.datas, {\n      eventParams: o\n    } = cr(t, this, \"drag\", s, e, !1, \"draggable\");\n    if (!r)\n      return;\n    const i = {\n      targets: t.props.targets,\n      events: o,\n      ...r\n    };\n    return j(t, \"onDragGroup\", i), i;\n  },\n  dragGroupEnd(t, e) {\n    const { isDrag: n, datas: r } = e;\n    if (!r.isDrag)\n      return;\n    this.dragEnd(t, e);\n    const {\n      eventParams: s\n    } = cr(t, this, \"dragEnd\", [0, 0], e, !1, \"draggable\");\n    return j(t, \"onDragGroupEnd\", $t(t, e, {\n      targets: t.props.targets,\n      events: s\n    })), n;\n  },\n  /**\n       * @method Moveable.Draggable#request\n       * @param {object} [e] - the draggable's request parameter\n       * @param {number} [e.x] - x position\n       * @param {number} [e.y] - y position\n       * @param {number} [e.deltaX] - X number to move\n       * @param {number} [e.deltaY] - Y number to move\n       * @return {Moveable.Requester} Moveable Requester\n       * @example\n  \n       * // Instantly Request (requestStart - request - requestEnd)\n       * // Use Relative Value\n       * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n       * // Use Absolute Value\n       * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n       *\n       * // requestStart\n       * const requester = moveable.request(\"draggable\");\n       *\n       * // request\n       * // Use Relative Value\n       * requester.request({ deltaX: 10, deltaY: 10 });\n       * requester.request({ deltaX: 10, deltaY: 10 });\n       * requester.request({ deltaX: 10, deltaY: 10 });\n       * // Use Absolute Value\n       * moveable.request(\"draggable\", { x: 200, y: 100 });\n       * moveable.request(\"draggable\", { x: 220, y: 100 });\n       * moveable.request(\"draggable\", { x: 240, y: 100 });\n       *\n       * // requestEnd\n       * requester.requestEnd();\n       */\n  request(t) {\n    const e = {}, n = t.getRect();\n    let r = 0, s = 0, o = !1;\n    return {\n      isControl: !1,\n      requestStart(i) {\n        return o = i.useSnap, { datas: e, useSnap: o };\n      },\n      request(i) {\n        return \"x\" in i ? r = i.x - n.left : \"deltaX\" in i && (r += i.deltaX), \"y\" in i ? s = i.y - n.top : \"deltaY\" in i && (s += i.deltaY), { datas: e, distX: r, distY: s, useSnap: o };\n      },\n      requestEnd() {\n        return { datas: e, isDrag: !0, useSnap: o };\n      }\n    };\n  },\n  unset(t) {\n    t.state.gestos.draggable = null, t.state.dragInfo = null;\n  }\n};\nfunction yi(t, e) {\n  return {\n    fixedPosition: yt(t, e),\n    fixedDirection: e,\n    fixedOffset: [0, 0]\n  };\n}\nfunction Tl(t, e) {\n  const {\n    allMatrix: n,\n    is3d: r,\n    width: s,\n    height: o\n  } = t, i = r ? 4 : 3, a = [\n    s / 2 * (1 + e[0]),\n    o / 2 * (1 + e[1])\n  ];\n  return {\n    fixedPosition: ht(n, a, i),\n    fixedDirection: e,\n    fixedOffset: [0, 0]\n  };\n}\nfunction Ri(t, e) {\n  const {\n    allMatrix: n,\n    is3d: r,\n    width: s,\n    height: o\n  } = t, i = r ? 4 : 3, a = jc(e, s, o), c = ht(n, e, i), l = [\n    s ? 0 : e[0],\n    o ? 0 : e[1]\n  ];\n  return {\n    fixedPosition: c,\n    fixedDirection: a,\n    fixedOffset: l\n  };\n}\nconst eo = xs(\"resizable\"), Tr = {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: [\n    \"resizable\",\n    \"throttleResize\",\n    \"renderDirections\",\n    \"displayAroundControls\",\n    \"keepRatio\",\n    \"resizeFormat\",\n    \"keepRatioFinally\",\n    \"edge\",\n    \"checkResizableError\"\n  ],\n  events: [\n    \"resizeStart\",\n    \"beforeResize\",\n    \"resize\",\n    \"resizeEnd\",\n    \"resizeGroupStart\",\n    \"beforeResizeGroup\",\n    \"resizeGroup\",\n    \"resizeGroupEnd\"\n  ],\n  render: di(\"resizable\"),\n  dragControlCondition: eo,\n  viewClassName: ms(\"resizable\"),\n  dragControlStart(t, e) {\n    const {\n      inputEvent: n,\n      isPinch: r,\n      isGroup: s,\n      parentDirection: o,\n      parentGesto: i,\n      datas: a,\n      parentFixedDirection: c,\n      parentEvent: l\n    } = e, u = Li(\n      o,\n      r,\n      n,\n      a\n    ), f = t.state, { target: d, width: p, height: g, gestos: h } = f;\n    if (!u || !d || h.resizable)\n      return !1;\n    h.resizable = i || t.controlGesto, !r && Re(t, e), a.datas = {}, a.direction = u, a.startOffsetWidth = p, a.startOffsetHeight = g, a.prevWidth = 0, a.prevHeight = 0, a.minSize = [0, 0], a.startWidth = f.inlineCSSWidth || f.cssWidth, a.startHeight = f.inlineCSSHeight || f.cssHeight, a.maxSize = [1 / 0, 1 / 0], s || (a.minSize = [f.minOffsetWidth, f.minOffsetHeight], a.maxSize = [f.maxOffsetWidth, f.maxOffsetHeight]);\n    const v = t.props.transformOrigin || \"% %\";\n    a.transformOrigin = v && re(v) ? v.split(\" \") : v, a.startOffsetMatrix = f.offsetMatrix, a.startTransformOrigin = f.transformOrigin, a.isWidth = (e == null ? void 0 : e.parentIsWidth) ?? (!u[0] && !u[1] || u[0] || !u[1]);\n    function m(y) {\n      a.ratio = y && isFinite(y) ? y : 0;\n    }\n    a.startPositions = jt(t.state);\n    function S(y) {\n      const M = yi(\n        a.startPositions,\n        y\n      );\n      a.fixedDirection = M.fixedDirection, a.fixedPosition = M.fixedPosition, a.fixedOffset = M.fixedOffset;\n    }\n    function x(y) {\n      const M = Ri(t.state, y);\n      a.fixedDirection = M.fixedDirection, a.fixedPosition = M.fixedPosition, a.fixedOffset = M.fixedOffset;\n    }\n    function C(y) {\n      a.minSize = [\n        ft(`${y[0]}`, 0) || 0,\n        ft(`${y[1]}`, 0) || 0\n      ];\n    }\n    function E(y) {\n      const M = [y[0] || 1 / 0, y[1] || 1 / 0];\n      (!an(M[0]) || isFinite(M[0])) && (M[0] = ft(`${M[0]}`, 0) || 1 / 0), (!an(M[1]) || isFinite(M[1])) && (M[1] = ft(`${M[1]}`, 0) || 1 / 0), a.maxSize = M;\n    }\n    m(p / g), S(c || [-u[0], -u[1]]), a.setFixedDirection = S, a.setFixedPosition = x, a.setMin = C, a.setMax = E;\n    const D = et(t, e, {\n      direction: u,\n      startRatio: a.ratio,\n      set: ([y, M]) => {\n        a.startWidth = y, a.startHeight = M;\n      },\n      setMin: C,\n      setMax: E,\n      setRatio: m,\n      setFixedDirection: S,\n      setFixedPosition: x,\n      setOrigin: (y) => {\n        a.transformOrigin = y;\n      },\n      dragStart: Ot.dragStart(\n        t,\n        new Fe().dragStart([0, 0], e)\n      )\n    }), R = l || j(t, \"onResizeStart\", D);\n    return a.startFixedDirection = a.fixedDirection, a.startFixedPosition = a.fixedPosition, R !== !1 && (a.isResize = !0, t.state.snapRenderInfo = {\n      request: e.isRequest,\n      direction: u\n    }), a.isResize ? D : !1;\n  },\n  dragControl(t, e) {\n    const {\n      datas: n,\n      parentFlag: r,\n      isPinch: s,\n      parentKeepRatio: o,\n      dragClient: i,\n      parentDist: a,\n      useSnap: c,\n      isRequest: l,\n      isGroup: u,\n      parentEvent: f,\n      resolveMatrix: d\n    } = e, {\n      isResize: p,\n      transformOrigin: g,\n      startWidth: h,\n      startHeight: v,\n      prevWidth: m,\n      prevHeight: S,\n      minSize: x,\n      maxSize: C,\n      ratio: E,\n      startOffsetWidth: D,\n      startOffsetHeight: R,\n      isWidth: y\n    } = n;\n    if (!p)\n      return;\n    if (d) {\n      const { is3d: st } = t.state, { startOffsetMatrix: Ft, startTransformOrigin: Lt } = n, ut = st ? 4 : 3;\n      let St = ln(Gn(e));\n      const Kt = Math.sqrt(St.length);\n      ut !== Kt && (St = Ut(St, Kt, ut));\n      const de = mn(\n        Ft,\n        St,\n        Lt,\n        ut\n      ), Pe = Me(\n        de,\n        D,\n        R,\n        ut\n      );\n      n.startPositions = Pe, n.nextTargetMatrix = St, n.nextAllMatrix = de;\n    }\n    const M = De(t.props, \"resizable\"), {\n      resizeFormat: P,\n      throttleResize: _ = r ? 0 : 1,\n      parentMoveable: O,\n      keepRatioFinally: T\n    } = M, w = n.direction;\n    let k = w, I = 0, $ = 0;\n    !w[0] && !w[1] && (k = [1, 1]);\n    const G = E && (o ?? M.keepRatio) || !1;\n    function L() {\n      const st = n.fixedDirection, Ft = Xi(k, G, n, e);\n      I = Ft.distWidth, $ = Ft.distHeight;\n      let Lt = k[0] - st[0] || G ? Math.max(D + I, Bt) : D, ut = k[1] - st[1] || G ? Math.max(R + $, Bt) : R;\n      return G && D && R && (y ? ut = Lt / E : Lt = ut * E), [Lt, ut];\n    }\n    let [z, N] = L();\n    f || (n.setFixedDirection(n.fixedDirection), j(\n      t,\n      \"onBeforeResize\",\n      et(\n        t,\n        e,\n        {\n          startFixedDirection: n.startFixedDirection,\n          startFixedPosition: n.startFixedPosition,\n          setFixedDirection(st) {\n            return n.setFixedDirection(st), [z, N] = L(), [z, N];\n          },\n          setFixedPosition(st) {\n            return n.setFixedPosition(st), [z, N] = L(), [z, N];\n          },\n          boundingWidth: z,\n          boundingHeight: N,\n          setSize(st) {\n            [z, N] = st;\n          }\n        },\n        !0\n      )\n    ));\n    let Z = i;\n    i || (!r && s ? Z = Uc(t, [0, 0]) : Z = n.fixedPosition);\n    let Y = [0, 0];\n    s || (Y = tu(\n      t,\n      z,\n      N,\n      w,\n      Z,\n      !c && l,\n      n\n    )), a && (!a[0] && (Y[0] = 0), !a[1] && (Y[1] = 0));\n    function W() {\n      P && ([z, N] = P([\n        z,\n        N\n      ])), z = tt(z, _), N = tt(N, _);\n    }\n    if (G) {\n      k[0] && k[1] && Y[0] && Y[1] && (B(Y[0]) > B(Y[1]) ? Y[1] = 0 : Y[0] = 0);\n      const st = !Y[0] && !Y[1];\n      st && W(), k[0] && !k[1] || Y[0] && !Y[1] || st && y ? (z += Y[0], N = z / E) : (!k[0] && k[1] || !Y[0] && Y[1] || st && !y) && (N += Y[1], z = N * E);\n    } else\n      z += Y[0], N += Y[1], z = Math.max(0, z), N = Math.max(0, N);\n    [z, N] = qo(\n      [z, N],\n      x,\n      C,\n      G ? E : !1\n    ), W(), G && (u || T) && (y ? N = z / E : z = N * E), I = z - D, $ = N - R;\n    const J = [I - m, $ - S];\n    n.prevWidth = I, n.prevHeight = $;\n    const q = qc(\n      t,\n      z,\n      N,\n      Z,\n      g,\n      n\n    );\n    if (!O && J.every((st) => !st) && q.every((st) => !st))\n      return;\n    const F = Ot.drag(\n      t,\n      vn(\n        e,\n        t.state,\n        q,\n        !!s,\n        !1,\n        \"draggable\"\n      )\n    ), H = F.transform, nt = h + I, lt = v + $, vt = et(t, e, {\n      width: nt,\n      height: lt,\n      offsetWidth: Math.round(z),\n      offsetHeight: Math.round(N),\n      startRatio: E,\n      boundingWidth: z,\n      boundingHeight: N,\n      direction: w,\n      dist: [I, $],\n      delta: J,\n      isPinch: !!s,\n      drag: F,\n      ...Wi(\n        {\n          style: {\n            width: `${nt}px`,\n            height: `${lt}px`\n          },\n          transform: H\n        },\n        F,\n        e\n      )\n    });\n    return !f && j(t, \"onResize\", vt), vt;\n  },\n  dragControlAfter(t, e) {\n    const n = e.datas, {\n      isResize: r,\n      startOffsetWidth: s,\n      startOffsetHeight: o,\n      prevWidth: i,\n      prevHeight: a\n    } = n;\n    if (!r || t.props.checkResizableError === !1)\n      return;\n    const { width: c, height: l } = t.state, u = c - (s + i), f = l - (o + a), d = B(u) > 3, p = B(f) > 3;\n    if (d && (n.startWidth += u, n.startOffsetWidth += u, n.prevWidth += u), p && (n.startHeight += f, n.startOffsetHeight += f, n.prevHeight += f), d || p)\n      return this.dragControl(t, e);\n  },\n  dragControlEnd(t, e) {\n    const { datas: n, parentEvent: r } = e;\n    if (!n.isResize)\n      return;\n    n.isResize = !1;\n    const s = $t(t, e, {});\n    return !r && j(t, \"onResizeEnd\", s), s;\n  },\n  dragGroupControlCondition: eo,\n  dragGroupControlStart(t, e) {\n    const { datas: n } = e, r = this.dragControlStart(t, { ...e, isGroup: !0 });\n    if (!r)\n      return !1;\n    const s = Ht(t, \"resizable\", e), {\n      startOffsetWidth: o,\n      startOffsetHeight: i\n    } = n;\n    function a() {\n      const p = n.minSize;\n      s.forEach((g) => {\n        const {\n          minSize: h,\n          startOffsetWidth: v,\n          startOffsetHeight: m\n        } = g.datas, S = o * (v ? h[0] / v : 0), x = i * (m ? h[1] / m : 0);\n        p[0] = Math.max(p[0], S), p[1] = Math.max(p[1], x);\n      });\n    }\n    function c() {\n      const p = n.maxSize;\n      s.forEach((g) => {\n        const {\n          maxSize: h,\n          startOffsetWidth: v,\n          startOffsetHeight: m\n        } = g.datas, S = o * (v ? h[0] / v : 0), x = i * (m ? h[1] / m : 0);\n        p[0] = Math.min(p[0], S), p[1] = Math.min(p[1], x);\n      });\n    }\n    const l = ee(\n      t,\n      this,\n      \"dragControlStart\",\n      e,\n      (p, g) => kn(t, p, n, g)\n    );\n    a(), c();\n    const u = (p) => {\n      r.setFixedDirection(p), l.forEach((g, h) => {\n        g.setFixedDirection(p), kn(t, g.moveable, n, s[h]);\n      });\n    };\n    n.setFixedDirection = u;\n    const f = {\n      ...r,\n      targets: t.props.targets,\n      events: l.map((p) => ({\n        ...p,\n        setMin: (g) => {\n          p.setMin(g), a();\n        },\n        setMax: (g) => {\n          p.setMax(g), c();\n        }\n      })),\n      setFixedDirection: u,\n      setMin: (p) => {\n        r.setMin(p), a();\n      },\n      setMax: (p) => {\n        r.setMax(p), c();\n      }\n    }, d = j(t, \"onResizeGroupStart\", f);\n    return n.isResize = d !== !1, n.isResize ? r : !1;\n  },\n  dragGroupControl(t, e) {\n    const { datas: n } = e;\n    if (!n.isResize)\n      return;\n    const r = De(t.props, \"resizable\");\n    Qn(t, \"onBeforeResize\", (p) => {\n      j(\n        t,\n        \"onBeforeResizeGroup\",\n        et(\n          t,\n          e,\n          {\n            ...p,\n            targets: r.targets\n          },\n          !0\n        )\n      );\n    });\n    const s = this.dragControl(t, { ...e, isGroup: !0 });\n    if (!s)\n      return;\n    const { boundingWidth: o, boundingHeight: i, dist: a } = s, c = r.keepRatio, l = [\n      o / (o - a[0]),\n      i / (i - a[1])\n    ], u = n.fixedPosition, f = ee(\n      t,\n      this,\n      \"dragControl\",\n      e,\n      (p, g) => {\n        const [h, v] = _t(\n          hn(t.rotation / 180 * Math.PI, 3),\n          [\n            g.datas.originalX * l[0],\n            g.datas.originalY * l[1],\n            1\n          ],\n          3\n        );\n        return {\n          ...g,\n          parentDist: null,\n          parentScale: l,\n          dragClient: at(u, [h, v]),\n          parentKeepRatio: c\n        };\n      }\n    ), d = {\n      targets: r.targets,\n      events: f,\n      ...s\n    };\n    return j(t, \"onResizeGroup\", d), d;\n  },\n  dragGroupControlEnd(t, e) {\n    const { isDrag: n, datas: r } = e;\n    if (!r.isResize)\n      return;\n    this.dragControlEnd(t, e);\n    const s = ee(t, this, \"dragControlEnd\", e), o = $t(\n      t,\n      e,\n      {\n        targets: t.props.targets,\n        events: s\n      }\n    );\n    return j(t, \"onResizeGroupEnd\", o), n;\n  },\n  /**\n       * @method Moveable.Resizable#request\n       * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter\n       * @return {Moveable.Requester} Moveable Requester\n       * @example\n  \n       * // Instantly Request (requestStart - request - requestEnd)\n       * // Use Relative Value\n       * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n       *\n       * // Use Absolute Value\n       * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n       *\n       * // requestStart\n       * const requester = moveable.request(\"resizable\");\n       *\n       * // request\n       * // Use Relative Value\n       * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n       * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n       * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n       *\n       * // Use Absolute Value\n       * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n       * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n       * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n       *\n       * // requestEnd\n       * requester.requestEnd();\n       */\n  request(t) {\n    const e = {};\n    let n = 0, r = 0, s = !1;\n    const o = t.getRect();\n    return {\n      isControl: !0,\n      requestStart(i) {\n        return s = i.useSnap, {\n          datas: e,\n          parentDirection: i.direction || [1, 1],\n          parentIsWidth: (i == null ? void 0 : i.horizontal) ?? !0,\n          useSnap: s\n        };\n      },\n      request(i) {\n        return \"offsetWidth\" in i ? n = i.offsetWidth - o.offsetWidth : \"deltaWidth\" in i && (n += i.deltaWidth), \"offsetHeight\" in i ? r = i.offsetHeight - o.offsetHeight : \"deltaHeight\" in i && (r += i.deltaHeight), {\n          datas: e,\n          parentDist: [n, r],\n          parentKeepRatio: i.keepRatio,\n          useSnap: s\n        };\n      },\n      requestEnd() {\n        return { datas: e, isDrag: !0, useSnap: s };\n      }\n    };\n  },\n  unset(t) {\n    t.state.gestos.resizable = null;\n  }\n};\nfunction lr(t, e, n, r, s) {\n  const o = t.props.groupable, i = t.state, a = i.is3d ? 4 : 3, c = e.origin, l = ht(\n    t.state.rootMatrix,\n    // TO-DO #710\n    K([c[0], c[1]], o ? [0, 0] : [i.left, i.top]),\n    a\n  ), u = at([s.left, s.top], l);\n  e.startAbsoluteOrigin = u, e.prevDeg = xt(u, [n, r]) / Math.PI * 180, e.defaultDeg = e.prevDeg, e.prevSnapDeg = 0, e.loop = 0, e.startDist = te(u, [n, r]);\n}\nfunction In(t, e, n) {\n  const { defaultDeg: r, prevDeg: s } = n;\n  let o = s % 360, i = Math.floor(s / 360);\n  o < 0 && (o += 360), o > t && o > 270 && t < 90 ? ++i : o < t && o < 90 && t > 270 && --i;\n  const a = e * (i * 360 + t - r);\n  return n.prevDeg = r + a, a;\n}\nfunction ur(t, e, n, r) {\n  return In(\n    xt(r.startAbsoluteOrigin, [t, e]) / Math.PI * 180,\n    n,\n    r\n  );\n}\nfunction fr(t, e, n, r, s, o) {\n  const { throttleRotate: i = 0 } = t.props, a = n.prevSnapDeg;\n  let c = 0, l = !1;\n  if (o) {\n    const f = Ql(\n      t,\n      e,\n      r,\n      s + r\n    );\n    l = f.isSnap, c = s + f.dist;\n  }\n  l || (c = tt(s + r, i));\n  const u = c - s;\n  return n.prevSnapDeg = u, [u - a, u, c];\n}\nfunction Mi(t, [e, n, r, s], o) {\n  if (t === \"none\")\n    return [];\n  if (Rt(t))\n    return t.map(\n      (f) => Mi(f, [e, n, r, s], o)[0]\n    );\n  const [i, a] = (t || \"top\").split(\"-\");\n  let c = [e, n];\n  i === \"left\" ? c = [r, e] : i === \"right\" ? c = [n, s] : i === \"bottom\" && (c = [s, r]);\n  let l = [\n    (c[0][0] + c[1][0]) / 2,\n    (c[0][1] + c[1][1]) / 2\n  ];\n  const u = $i(c, o);\n  if (a) {\n    const f = a === \"top\" || a === \"left\", d = i === \"bottom\" || i === \"left\";\n    l = c[f && !d || !f && d ? 0 : 1];\n  }\n  return [[l, u]];\n}\nfunction Or(t, e) {\n  if (e.isRequest)\n    return e.requestAble === \"rotatable\";\n  const n = e.inputEvent.target;\n  if (bt(n, U(\"rotation-control\")) || t.props.rotateAroundControls && bt(n, U(\"around-control\")) || bt(n, U(\"control\")) && bt(n, U(\"rotatable\")))\n    return !0;\n  const r = t.props.rotationTarget;\n  return r ? Ss(r, !0).some((s) => s ? n === s || n.contains(s) : !1) : !1;\n}\nconst Ol = `.rotation {\nposition: absolute;\nheight: 40px;\nwidth: 1px;\ntransform-origin: 50% 100%;\nheight: calc(40px * var(--zoom));\ntop: auto;\nleft: 0;\nbottom: 100%;\nwill-change: transform;\n}\n.rotation .rotation-line {\ndisplay: block;\nwidth: 100%;\nheight: 100%;\ntransform-origin: 50% 50%;\n}\n.rotation .rotation-control {\nborder-color: #4af;\nborder-color: var(--moveable-color);\nbackground:#fff;\ncursor: alias;\n}\n:global .view-rotation-dragging, .rotatable.direction.control {\ncursor: alias;\n}\n.rotatable.direction.control.move {\ncursor: move;\n}\n`, wl = {\n  name: \"rotatable\",\n  canPinch: !0,\n  props: [\n    \"rotatable\",\n    \"rotationPosition\",\n    \"throttleRotate\",\n    \"renderDirections\",\n    \"rotationTarget\",\n    \"rotateAroundControls\",\n    \"edge\",\n    \"resolveAblesWithRotatable\",\n    \"displayAroundControls\"\n  ],\n  events: [\n    \"rotateStart\",\n    \"beforeRotate\",\n    \"rotate\",\n    \"rotateEnd\",\n    \"rotateGroupStart\",\n    \"beforeRotateGroup\",\n    \"rotateGroup\",\n    \"rotateGroupEnd\"\n  ],\n  css: [Ol],\n  viewClassName(t) {\n    return t.isDragging(\"rotatable\") ? U(\"view-rotation-dragging\") : \"\";\n  },\n  render(t, e) {\n    const {\n      rotatable: n,\n      rotationPosition: r,\n      zoom: s,\n      renderDirections: o,\n      rotateAroundControls: i,\n      resolveAblesWithRotatable: a\n    } = De(t.props, \"rotatable\"), { renderPoses: c, direction: l } = t.getState();\n    if (!n)\n      return null;\n    const u = Mi(\n      r,\n      c,\n      l\n    ), f = [];\n    if (u.forEach(([d, p], g) => {\n      f.push(\n        /* @__PURE__ */ it.jsxs(\n          \"div\",\n          {\n            className: U(\"rotation\"),\n            style: {\n              // tslint:disable-next-line: max-line-length\n              transform: `translate(-50%) translate(${d[0]}px, ${d[1]}px) rotate(${p}rad)`\n            },\n            children: [\n              /* @__PURE__ */ it.jsx(\n                \"div\",\n                {\n                  className: U(\"line rotation-line\"),\n                  style: {\n                    transform: `scaleX(${s})`\n                  }\n                }\n              ),\n              /* @__PURE__ */ it.jsx(\n                \"div\",\n                {\n                  className: U(\"control rotation-control\"),\n                  style: {\n                    transform: `translate(0.5px) scale(${s})`\n                  }\n                }\n              )\n            ]\n          },\n          `rotation${g}`\n        )\n      );\n    }), o) {\n      const d = Ve(a || {}), p = {};\n      d.forEach((h) => {\n        a[h].forEach((v) => {\n          p[v] = h;\n        });\n      });\n      let g = [];\n      Rt(o) && (g = o.map((h) => {\n        const v = p[h];\n        return {\n          data: v ? { resolve: v } : {},\n          classNames: v ? [\"move\"] : [],\n          dir: h\n        };\n      })), f.push(\n        ...li(\n          t,\n          \"rotatable\",\n          g\n        )\n      );\n    }\n    return i && f.push(...gi(t)), f;\n  },\n  dragControlCondition: Or,\n  dragControlStart(t, e) {\n    var k;\n    const {\n      datas: n,\n      clientX: r,\n      clientY: s,\n      parentRotate: o,\n      parentFlag: i,\n      isPinch: a,\n      isRequest: c\n    } = e, l = t.state, {\n      target: u,\n      left: f,\n      top: d,\n      direction: p,\n      beforeDirection: g,\n      targetTransform: h,\n      moveableClientRect: v,\n      offsetMatrix: m,\n      targetMatrix: S,\n      allMatrix: x,\n      width: C,\n      height: E\n    } = l;\n    if (!c && !u)\n      return !1;\n    const D = t.getRect();\n    n.rect = D, n.transform = h, n.left = f, n.top = d;\n    let R = (I) => {\n      const $ = Ri(t.state, I);\n      n.fixedDirection = $.fixedDirection, n.fixedOffset = $.fixedOffset, n.fixedPosition = $.fixedPosition, O && O.setFixedPosition(I);\n    }, y = (I) => {\n      const $ = Tl(\n        t.state,\n        I\n      );\n      n.fixedDirection = $.fixedDirection, n.fixedOffset = $.fixedOffset, n.fixedPosition = $.fixedPosition, O && O.setFixedDirection(I);\n    }, M = r, P = s;\n    if (c || a || i) {\n      const I = o || 0;\n      n.beforeInfo = {\n        origin: D.beforeOrigin,\n        prevDeg: I,\n        defaultDeg: I,\n        prevSnapDeg: 0,\n        startDist: 0\n      }, n.afterInfo = {\n        ...n.beforeInfo,\n        origin: D.origin\n      }, n.absoluteInfo = {\n        ...n.beforeInfo,\n        origin: D.origin,\n        startValue: I\n      };\n    } else {\n      const I = (k = e.inputEvent) == null ? void 0 : k.target;\n      if (I) {\n        const G = I.getAttribute(\"data-direction\") || \"\", L = ac[G];\n        if (L) {\n          n.isControl = !0, n.isAroundControl = bt(\n            I,\n            U(\"around-control\")\n          ), n.controlDirection = L;\n          const z = I.getAttribute(\"data-resolve\");\n          z && (n.resolveAble = z);\n          const N = hu(\n            l.rootMatrix,\n            l.renderPoses,\n            v\n          );\n          [M, P] = yt(\n            N,\n            L\n          );\n        }\n      }\n      n.beforeInfo = { origin: D.beforeOrigin }, n.afterInfo = { origin: D.origin }, n.absoluteInfo = {\n        origin: D.origin,\n        startValue: D.rotation\n      };\n      const $ = R;\n      R = (G) => {\n        const L = l.is3d ? 4 : 3, [z, N] = at(\n          ti(S, L),\n          G\n        ), Z = _t(\n          m,\n          Ee([z, N], L)\n        ), Y = _t(\n          x,\n          Ee([G[0], G[1]], L)\n        );\n        $(G);\n        const W = l.posDelta;\n        n.beforeInfo.origin = K(Z, W), n.afterInfo.origin = K(Y, W), n.absoluteInfo.origin = K(Y, W), lr(\n          t,\n          n.beforeInfo,\n          M,\n          P,\n          v\n        ), lr(\n          t,\n          n.afterInfo,\n          M,\n          P,\n          v\n        ), lr(\n          t,\n          n.absoluteInfo,\n          M,\n          P,\n          v\n        );\n      }, y = (G) => {\n        const L = yt(\n          [\n            [0, 0],\n            [C, 0],\n            [0, E],\n            [C, E]\n          ],\n          G\n        );\n        R(L);\n      };\n    }\n    n.startClientX = M, n.startClientY = P, n.direction = p, n.beforeDirection = g, n.startValue = 0, n.datas = {}, qn(t, e, \"rotate\");\n    let _ = !1, O = !1;\n    n.isControl && n.resolveAble && n.resolveAble === \"resizable\" && (O = Tr.dragControlStart(t, {\n      ...new Fe(\"resizable\").dragStart([0, 0], e),\n      parentPosition: n.controlPosition,\n      parentFixedPosition: n.fixedPosition\n    })), O || (_ = Ot.dragStart(\n      t,\n      new Fe().dragStart([0, 0], e)\n    )), R(vu(t));\n    const T = et(t, e, {\n      set: (I) => {\n        n.startValue = I * Math.PI / 180;\n      },\n      setFixedDirection: y,\n      setFixedPosition: R,\n      ...Hn(t, e),\n      dragStart: _,\n      resizeStart: O\n    }), w = j(t, \"onRotateStart\", T);\n    return n.isRotate = w !== !1, l.snapRenderInfo = {\n      request: e.isRequest\n    }, n.isRotate ? T : !1;\n  },\n  dragControl(t, e) {\n    const {\n      datas: n,\n      clientDistX: r,\n      clientDistY: s,\n      parentRotate: o,\n      parentFlag: i,\n      isPinch: a,\n      groupDelta: c,\n      resolveMatrix: l\n    } = e, {\n      beforeDirection: u,\n      beforeInfo: f,\n      afterInfo: d,\n      absoluteInfo: p,\n      isRotate: g,\n      startValue: h,\n      rect: v,\n      startClientX: m,\n      startClientY: S\n    } = n;\n    if (!g)\n      return;\n    jn(t, e, \"rotate\");\n    const x = Gc(e), C = u * x, { parentMoveable: E } = t.props;\n    let D = 0, R, y, M = 0, P, _, O = 0, T, w;\n    const k = 180 / Math.PI * h, I = p.startValue;\n    let $ = !1;\n    const G = m + r, L = S + s;\n    if (!i && \"parentDist\" in e) {\n      const H = e.parentDist;\n      R = H, P = H, T = H;\n    } else a || i ? (R = In(o, u, f), P = In(o, C, d), T = In(o, C, p)) : (R = ur(\n      G,\n      L,\n      u,\n      f\n    ), P = ur(\n      G,\n      L,\n      C,\n      d\n    ), T = ur(\n      G,\n      L,\n      C,\n      p\n    ), $ = !0);\n    if (y = k + R, _ = k + P, w = I + T, j(\n      t,\n      \"onBeforeRotate\",\n      et(\n        t,\n        e,\n        {\n          beforeRotation: y,\n          rotation: _,\n          absoluteRotation: w,\n          setRotation(H) {\n            P = H - k, R = P, T = P;\n          }\n        },\n        !0\n      )\n    ), [D, R, y] = fr(\n      t,\n      v,\n      f,\n      R,\n      k,\n      $\n    ), [M, P, _] = fr(\n      t,\n      v,\n      d,\n      P,\n      k,\n      $\n    ), [O, T, w] = fr(\n      t,\n      v,\n      p,\n      T,\n      I,\n      $\n    ), !O && !M && !D && !E && !l)\n      return;\n    const z = Xn(\n      n,\n      `rotate(${_}deg)`,\n      `rotate(${P}deg)`\n    );\n    l && (n.fixedPosition = is(\n      t,\n      n.targetAllTransform,\n      n.fixedDirection,\n      n.fixedOffset,\n      n\n    ));\n    const N = Hc(t, P, n), Z = K(\n      at(c || [0, 0], N),\n      n.prevInverseDist || [0, 0]\n    );\n    n.prevInverseDist = N, n.requestValue = null;\n    const Y = ii(\n      t,\n      z,\n      Z,\n      a,\n      e\n    );\n    let W = Y;\n    const J = te([G, L], p.startAbsoluteOrigin) - p.startDist;\n    let q;\n    if (n.resolveAble === \"resizable\") {\n      const H = Tr.dragControl(t, {\n        ...vn(\n          e,\n          t.state,\n          [e.deltaX, e.deltaY],\n          !!a,\n          !1,\n          \"resizable\"\n        ),\n        resolveMatrix: !0,\n        parentDistance: J\n      });\n      H && (q = H, W = Wi(W, H, e));\n    }\n    const F = et(t, e, {\n      delta: M,\n      dist: P,\n      rotate: _,\n      rotation: _,\n      beforeDist: R,\n      beforeDelta: D,\n      beforeRotate: y,\n      beforeRotation: y,\n      absoluteDist: T,\n      absoluteDelta: O,\n      absoluteRotate: w,\n      absoluteRotation: w,\n      isPinch: !!a,\n      resize: q,\n      ...Y,\n      ...W\n    });\n    return j(t, \"onRotate\", F), F;\n  },\n  dragControlEnd(t, e) {\n    const { datas: n } = e;\n    if (!n.isRotate)\n      return;\n    n.isRotate = !1;\n    const r = $t(t, e, {});\n    return j(t, \"onRotateEnd\", r), r;\n  },\n  dragGroupControlCondition: Or,\n  dragGroupControlStart(t, e) {\n    const { datas: n } = e, {\n      left: r,\n      top: s,\n      beforeOrigin: o\n    } = t.state, i = this.dragControlStart(t, e);\n    if (!i)\n      return !1;\n    i.set(n.beforeDirection * t.rotation);\n    const a = ee(\n      t,\n      this,\n      \"dragControlStart\",\n      e,\n      (u, f) => {\n        const { left: d, top: p, beforeOrigin: g } = u.state, h = at(\n          K([d, p], [r, s]),\n          K(g, o)\n        );\n        return f.datas.startGroupClient = h, f.datas.groupClient = h, { ...f, parentRotate: 0 };\n      }\n    ), c = {\n      ...i,\n      targets: t.props.targets,\n      events: a\n    }, l = j(t, \"onRotateGroupStart\", c);\n    return n.isRotate = l !== !1, n.isRotate ? i : !1;\n  },\n  dragGroupControl(t, e) {\n    const { datas: n } = e;\n    if (!n.isRotate)\n      return;\n    Qn(t, \"onBeforeRotate\", (l) => {\n      j(\n        t,\n        \"onBeforeRotateGroup\",\n        et(\n          t,\n          e,\n          {\n            ...l,\n            targets: t.props.targets\n          },\n          !0\n        )\n      );\n    });\n    const r = this.dragControl(t, e);\n    if (!r)\n      return;\n    const s = n.beforeDirection, o = r.beforeDist, i = o / 180 * Math.PI, a = ee(\n      t,\n      this,\n      \"dragControl\",\n      e,\n      (l, u) => {\n        const f = u.datas.startGroupClient, [d, p] = u.datas.groupClient, [g, h] = gn(\n          f,\n          i * s\n        ), v = [g - d, h - p];\n        return u.datas.groupClient = [g, h], { ...u, parentRotate: o, groupDelta: v };\n      }\n    );\n    t.rotation = s * r.beforeRotation;\n    const c = {\n      targets: t.props.targets,\n      events: a,\n      set(l) {\n        t.rotation = l;\n      },\n      setGroupRotation(l) {\n        t.rotation = l;\n      },\n      ...r\n    };\n    return j(t, \"onRotateGroup\", c), c;\n  },\n  dragGroupControlEnd(t, e) {\n    const { isDrag: n, datas: r } = e;\n    if (!r.isRotate)\n      return;\n    this.dragControlEnd(t, e);\n    const s = ee(t, this, \"dragControlEnd\", e), o = $t(t, e, {\n      targets: t.props.targets,\n      events: s\n    });\n    return j(t, \"onRotateGroupEnd\", o), n;\n  },\n  /**\n       * @method Moveable.Rotatable#request\n       * @param {object} [e] - the Resizable's request parameter\n       * @param {number} [e.deltaRotate=0] -  delta number of rotation\n       * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n       * @return {Moveable.Requester} Moveable Requester\n       * @example\n  \n       * // Instantly Request (requestStart - request - requestEnd)\n       * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n       *\n       * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n       *\n       * // requestStart\n       * const requester = moveable.request(\"rotatable\");\n       *\n       * // request\n       * requester.request({ deltaRotate: 10 });\n       * requester.request({ deltaRotate: 10 });\n       * requester.request({ deltaRotate: 10 });\n       *\n       * requester.request({ rotate: 10 });\n       * requester.request({ rotate: 20 });\n       * requester.request({ rotate: 30 });\n       *\n       * // requestEnd\n       * requester.requestEnd();\n       */\n  request(t) {\n    const e = {};\n    let n = 0;\n    const r = t.getRotation();\n    return {\n      isControl: !0,\n      requestStart() {\n        return { datas: e };\n      },\n      request(s) {\n        return \"deltaRotate\" in s ? n += s.deltaRotate : \"rotate\" in s && (n = s.rotate - r), { datas: e, parentDist: n };\n      },\n      requestEnd() {\n        return { datas: e, isDrag: !0 };\n      }\n    };\n  }\n};\nfunction Il(t, e) {\n  const { direction: n, classNames: r, size: s, pos: o, zoom: i, key: a } = t, c = n === \"horizontal\", l = c ? \"Y\" : \"X\";\n  return e.createElement(\"div\", {\n    key: a,\n    className: r.join(\" \"),\n    style: {\n      [c ? \"width\" : \"height\"]: `${s}`,\n      transform: `translate(${o[0]}, ${o[1]}) translate${l}(-50%) scale${l}(${i})`\n    }\n  });\n}\nfunction ds(t, e) {\n  return Il({\n    ...t,\n    classNames: [\n      U(\"line\", \"guideline\", t.direction),\n      ...t.classNames\n    ].filter((n) => n),\n    size: t.size || `${t.sizeValue}px`,\n    pos: t.pos || t.posValue.map((n) => `${tt(n, 0.1)}px`)\n  }, e);\n}\nfunction no(t, e, n, r, s, o, i, a) {\n  const { zoom: c } = t.props;\n  return n.map(({ type: l, pos: u }, f) => {\n    const d = [0, 0];\n    return d[i] = r, d[i ? 0 : 1] = -s + u, ds(\n      {\n        key: `${e}TargetGuideline${f}`,\n        classNames: [U(\"target\", \"bold\", l)],\n        posValue: d,\n        sizeValue: o,\n        zoom: c,\n        direction: e\n      },\n      a\n    );\n  });\n}\nfunction ro(t, e, n, r, s, o) {\n  const { zoom: i, isDisplayInnerSnapDigit: a } = t.props, c = e === \"horizontal\" ? le : ue, l = s[c.start], u = s[c.end];\n  return n.filter(({ hide: f, elementRect: d }) => {\n    if (f)\n      return !1;\n    if (a && d) {\n      const p = d.rect;\n      if (p[c.start] <= l && u <= p[c.end])\n        return !1;\n    }\n    return !0;\n  }).map((f, d) => {\n    const { pos: p, size: g, element: h, className: v } = f, m = [\n      -r[0] + p[0],\n      -r[1] + p[1]\n    ];\n    return ds(\n      {\n        key: `${e}-default-guideline-${d}`,\n        classNames: h ? [U(\"bold\"), v] : [U(\"normal\"), v],\n        direction: e,\n        posValue: m,\n        sizeValue: g,\n        zoom: i\n      },\n      o\n    );\n  });\n}\nfunction Ze(t, e, n, r, s, o, i, a) {\n  const {\n    snapDigit: c = 0,\n    isDisplaySnapDigit: l = !0,\n    snapDistFormat: u = (v, m) => v,\n    zoom: f\n  } = t.props, d = e === \"horizontal\" ? \"X\" : \"Y\", p = e === \"vertical\" ? \"height\" : \"width\", g = Math.abs(s), h = l ? parseFloat(g.toFixed(c)) : 0;\n  return /* @__PURE__ */ it.jsxs(\n    \"div\",\n    {\n      className: U(\"guideline-group\", e),\n      style: {\n        left: `${o[0]}px`,\n        top: `${o[1]}px`,\n        [p]: `${g}px`\n      },\n      children: [\n        ds(\n          {\n            direction: e,\n            classNames: [U(n), i],\n            size: \"100%\",\n            posValue: [0, 0],\n            sizeValue: g,\n            zoom: f\n          },\n          a\n        ),\n        /* @__PURE__ */ it.jsx(\n          \"div\",\n          {\n            className: U(\"size-value\", \"gap\"),\n            style: {\n              transform: `translate${d}(-50%) scale(${f})`\n            },\n            children: h > 0 ? u(h, e) : \"\"\n          }\n        )\n      ]\n    },\n    `${e}-${n}-guideline-${r}`\n  );\n}\nfunction Bl(t, e, n, r) {\n  const s = t === \"vertical\" ? 0 : 1, o = t === \"vertical\" ? 1 : 0, i = s ? le : ue, a = n[i.start], c = n[i.end];\n  return Yi(e, (l) => l.pos[s]).map((l) => {\n    const u = [], f = [], d = [];\n    return l.forEach((p) => {\n      const g = p.element, h = p.elementRect.rect;\n      if (h[i.end] < a)\n        u.push(p);\n      else if (c < h[i.start])\n        f.push(p);\n      else if (h[i.start] <= a && c <= h[i.end] && r) {\n        const v = p.pos, m = { element: g, rect: { ...h, [i.end]: h[i.start] } }, S = { element: g, rect: { ...h, [i.start]: h[i.end] } }, x = [0, 0], C = [0, 0];\n        x[s] = v[s], x[o] = v[o], C[s] = v[s], C[o] = v[o] + p.size, u.push({\n          type: t,\n          pos: x,\n          size: 0,\n          elementRect: m,\n          direction: \"\",\n          elementDirection: \"end\"\n        }), f.push({\n          type: t,\n          pos: C,\n          size: 0,\n          elementRect: S,\n          direction: \"\",\n          elementDirection: \"start\"\n        });\n      }\n    }), u.sort((p, g) => g.pos[o] - p.pos[o]), f.sort((p, g) => p.pos[o] - g.pos[o]), {\n      total: l,\n      start: u,\n      end: f,\n      inner: d\n    };\n  });\n}\nfunction zl(t, e, n, r, s) {\n  const {\n    isDisplayInnerSnapDigit: o\n  } = t.props, i = [];\n  return [\"vertical\", \"horizontal\"].forEach((a) => {\n    const c = e.filter((v) => v.type === a), l = a === \"vertical\" ? 1 : 0, u = l ? 0 : 1, f = Bl(a, c, r, o), d = l ? ue : le, p = l ? le : ue, g = r[d.start], h = r[d.end];\n    f.forEach(({ total: v, start: m, end: S, inner: x }) => {\n      const C = n[u] + v[0].pos[u] - r[p.start];\n      let E = r;\n      m.forEach((D) => {\n        const R = D.elementRect.rect, y = E[d.start] - R[d.end];\n        if (y > 0) {\n          const M = [0, 0];\n          M[l] = n[l] + E[d.start] - g - y, M[u] = C, i.push(Ze(\n            t,\n            a,\n            \"dashed\",\n            i.length,\n            y,\n            M,\n            D.className,\n            s\n          ));\n        }\n        E = R;\n      }), E = r, S.forEach((D) => {\n        const R = D.elementRect.rect, y = R[d.start] - E[d.end];\n        if (y > 0) {\n          const M = [0, 0];\n          M[l] = n[l] + E[d.end] - g, M[u] = C, i.push(Ze(\n            t,\n            a,\n            \"dashed\",\n            i.length,\n            y,\n            M,\n            D.className,\n            s\n          ));\n        }\n        E = R;\n      }), x.forEach((D) => {\n        const R = D.elementRect.rect, y = g - R[d.start], M = R[d.end] - h, P = [0, 0], _ = [0, 0];\n        P[l] = n[l] - y, P[u] = C, _[l] = n[l] + h - g, _[u] = C, i.push(Ze(\n          t,\n          a,\n          \"dashed\",\n          i.length,\n          y,\n          P,\n          D.className,\n          s\n        )), i.push(Ze(\n          t,\n          a,\n          \"dashed\",\n          i.length,\n          M,\n          _,\n          D.className,\n          s\n        ));\n      });\n    });\n  }), i;\n}\nfunction Al(t, e, n, r, s) {\n  const o = [];\n  return [\"horizontal\", \"vertical\"].forEach((i) => {\n    const a = e.filter((v) => v.type === i).slice(0, 1), c = i === \"vertical\" ? 0 : 1, l = c ? 0 : 1, u = c ? ue : le, f = c ? le : ue, d = r[u.start], p = r[u.end], g = r[f.start], h = r[f.end];\n    a.forEach(({ gap: v, gapRects: m }) => {\n      const S = Math.max(\n        g,\n        ...m.map(({ rect: E }) => E[f.start])\n      ), x = Math.min(\n        h,\n        ...m.map(({ rect: E }) => E[f.end])\n      ), C = (S + x) / 2;\n      S === x || C === (g + h) / 2 || m.forEach(({ rect: E, className: D }) => {\n        const R = [n[0], n[1]];\n        if (E[u.end] < d)\n          R[c] += E[u.end] - d;\n        else if (p < E[u.start])\n          R[c] += E[u.start] - d - v;\n        else\n          return;\n        R[l] += C - g, o.push(Ze(\n          t,\n          c ? \"vertical\" : \"horizontal\",\n          \"gap\",\n          o.length,\n          v,\n          R,\n          D,\n          s\n        ));\n      });\n    });\n  }), o;\n}\nvar Gl = /* @__PURE__ */ function() {\n  function t() {\n    this.keys = [], this.values = [];\n  }\n  var e = t.prototype;\n  return e.get = function(n) {\n    return this.values[this.keys.indexOf(n)];\n  }, e.set = function(n, r) {\n    var s = this.keys, o = this.values, i = s.indexOf(n), a = i === -1 ? s.length : i;\n    s[a] = n, o[a] = r;\n  }, t;\n}(), kl = /* @__PURE__ */ function() {\n  function t() {\n    this.object = {};\n  }\n  var e = t.prototype;\n  return e.get = function(n) {\n    return this.object[n];\n  }, e.set = function(n, r) {\n    this.object[n] = r;\n  }, t;\n}(), $l = typeof Map == \"function\", Fl = /* @__PURE__ */ function() {\n  function t() {\n  }\n  var e = t.prototype;\n  return e.connect = function(n, r) {\n    this.prev = n, this.next = r, n && (n.next = this), r && (r.prev = this);\n  }, e.disconnect = function() {\n    var n = this.prev, r = this.next;\n    n && (n.next = r), r && (r.prev = n);\n  }, e.getIndex = function() {\n    for (var n = this, r = -1; n; )\n      n = n.prev, ++r;\n    return r;\n  }, t;\n}();\nfunction Ll(t, e) {\n  var n = [], r = [];\n  return t.forEach(function(s) {\n    var o = s[0], i = s[1], a = new Fl();\n    n[o] = a, r[i] = a;\n  }), n.forEach(function(s, o) {\n    s.connect(n[o - 1]);\n  }), t.filter(function(s, o) {\n    return !e[o];\n  }).map(function(s, o) {\n    var i = s[0], a = s[1];\n    if (i === a)\n      return [0, 0];\n    var c = n[i], l = r[a - 1], u = c.getIndex();\n    c.disconnect(), l ? c.connect(l, l.next) : c.connect(void 0, n[0]);\n    var f = c.getIndex();\n    return [u, f];\n  });\n}\nvar Nl = /* @__PURE__ */ function() {\n  function t(n, r, s, o, i, a, c, l) {\n    this.prevList = n, this.list = r, this.added = s, this.removed = o, this.changed = i, this.maintained = a, this.changedBeforeAdded = c, this.fixed = l;\n  }\n  var e = t.prototype;\n  return Object.defineProperty(e, \"ordered\", {\n    get: function() {\n      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(e, \"pureChanged\", {\n    get: function() {\n      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), e.caculateOrdered = function() {\n    var n = Ll(this.changedBeforeAdded, this.fixed), r = this.changed, s = [];\n    this.cacheOrdered = n.filter(function(o, i) {\n      var a = o[0], c = o[1], l = r[i], u = l[0], f = l[1];\n      if (a !== c)\n        return s.push([u, f]), !0;\n    }), this.cachePureChanged = s;\n  }, t;\n}();\nfunction ps(t, e, n) {\n  var r = $l ? Map : n ? kl : Gl, s = n || function(S) {\n    return S;\n  }, o = [], i = [], a = [], c = t.map(s), l = e.map(s), u = new r(), f = new r(), d = [], p = [], g = {}, h = [], v = 0, m = 0;\n  return c.forEach(function(S, x) {\n    u.set(S, x);\n  }), l.forEach(function(S, x) {\n    f.set(S, x);\n  }), c.forEach(function(S, x) {\n    var C = f.get(S);\n    typeof C > \"u\" ? (++m, i.push(x)) : g[C] = m;\n  }), l.forEach(function(S, x) {\n    var C = u.get(S);\n    typeof C > \"u\" ? (o.push(x), ++v) : (a.push([C, x]), m = g[x] || 0, d.push([C - m, x - v]), p.push(x === C), C !== x && h.push([C, x]));\n  }), i.reverse(), new Nl(t, e, o, i, h, a, d, p);\n}\nvar Wl = /* @__PURE__ */ function() {\n  function t(n, r) {\n    n === void 0 && (n = []), this.findKeyCallback = r, this.list = [].slice.call(n);\n  }\n  var e = t.prototype;\n  return e.update = function(n) {\n    var r = [].slice.call(n), s = ps(this.list, r, this.findKeyCallback);\n    return this.list = r, s;\n  }, t;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar wr = function(t, e) {\n  return wr = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(n, r) {\n    n.__proto__ = r;\n  } || function(n, r) {\n    for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);\n  }, wr(t, e);\n};\nfunction Yl(t, e) {\n  wr(t, e);\n  function n() {\n    this.constructor = t;\n  }\n  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());\n}\nvar Pi = typeof Map == \"function\" ? void 0 : /* @__PURE__ */ function() {\n  var t = 0;\n  return function(e) {\n    return e.__DIFF_KEY__ || (e.__DIFF_KEY__ = ++t);\n  };\n}(), _i = /* @__PURE__ */ function(t) {\n  Yl(e, t);\n  function e(n) {\n    return n === void 0 && (n = []), t.call(this, n, Pi) || this;\n  }\n  return e;\n}(Wl);\nfunction Vl(t, e) {\n  return ps(t, e, Pi);\n}\nfunction Ir(t) {\n  var P;\n  const e = t.state, {\n    containerClientRect: n,\n    hasFixed: r\n  } = e, {\n    overflow: s,\n    scrollHeight: o,\n    scrollWidth: i,\n    clientHeight: a,\n    clientWidth: c,\n    clientLeft: l,\n    clientTop: u\n  } = n, {\n    snapGap: f = !0,\n    verticalGuidelines: d,\n    horizontalGuidelines: p,\n    snapThreshold: g = 5,\n    maxSnapElementGuidelineDistance: h = 1 / 0,\n    isDisplayGridGuidelines: v\n  } = t.props, { top: m, left: S, bottom: x, right: C } = Yt(jt(t.state)), E = { top: m, left: S, bottom: x, right: C, center: (S + C) / 2, middle: (m + x) / 2 };\n  let R = [...ql(t)];\n  const y = (((P = e.snapThresholdInfo) == null ? void 0 : P.multiples) ?? [1, 1]).map((_) => _ * g);\n  f && R.push(...jl(\n    t,\n    E,\n    y\n  ));\n  const M = {\n    ...e.snapOffset || {\n      left: 0,\n      top: 0,\n      bottom: 0,\n      right: 0\n    }\n  };\n  if (R.push(...Hl(\n    t,\n    s ? i : c,\n    s ? o : a,\n    l,\n    u,\n    M,\n    v\n  )), r) {\n    const { left: _, top: O } = n;\n    M.left += _, M.top += O, M.right += _, M.bottom += O;\n  }\n  return R.push(...Oi(\n    p || !1,\n    d || !1,\n    s ? i : c,\n    s ? o : a,\n    l,\n    u,\n    M\n  )), R = R.filter(({ element: _, elementRect: O, type: T }) => {\n    if (!_ || !O)\n      return !0;\n    const w = O.rect;\n    return Ti(E, w, T, h);\n  }), R;\n}\nfunction jl(t, e, n) {\n  const {\n    maxSnapElementGuidelineDistance: r = 1 / 0,\n    maxSnapElementGapDistance: s = 1 / 0\n  } = t.props, o = t.state.elementRects, i = [];\n  return [\n    [\"vertical\", le, ue],\n    [\"horizontal\", ue, le]\n  ].forEach(([a, c, l]) => {\n    const u = e[c.start], f = e[c.end], d = e[c.center], p = e[l.start], g = e[l.end], h = {\n      left: n[0],\n      top: n[1]\n    };\n    function v(x) {\n      const C = x.rect, E = h[c.start];\n      return C[c.end] < u + E ? u - C[c.end] : f - E < C[c.start] ? C[c.start] - f : -1;\n    }\n    const m = o.filter((x) => {\n      const C = x.rect;\n      return C[l.start] > g || C[l.end] < p ? !1 : v(x) > 0;\n    }).sort((x, C) => v(x) - v(C)), S = [];\n    m.forEach((x) => {\n      m.forEach((C) => {\n        if (x === C)\n          return;\n        const { rect: E } = x, { rect: D } = C, R = E[l.start], y = E[l.end], M = D[l.start], P = D[l.end];\n        R > P || M > y || S.push([x, C]);\n      });\n    }), S.forEach(([x, C]) => {\n      const { rect: E } = x, { rect: D } = C, R = E[c.start], y = E[c.end], M = D[c.start], P = D[c.end], _ = h[c.start];\n      let O = 0, T = 0, w = !1, k = !1, I = !1;\n      if (y <= u && f <= M) {\n        if (k = !0, O = (M - y - (f - u)) / 2, T = y + O + (f - u) / 2, B(T - d) > _)\n          return;\n      } else if (y < M && P < u + _) {\n        if (w = !0, O = M - y, T = P + O, B(T - u) > _)\n          return;\n      } else if (y < M && f - _ < R) {\n        if (I = !0, O = M - y, T = R - O, B(T - f) > _)\n          return;\n      } else\n        return;\n      O && Ti(e, D, a, r) && (O > s || i.push({\n        type: a,\n        pos: a === \"vertical\" ? [T, 0] : [0, T],\n        element: C.element,\n        size: 0,\n        className: C.className,\n        isStart: w,\n        isCenter: k,\n        isEnd: I,\n        gap: O,\n        hide: !0,\n        gapRects: [x, C],\n        direction: \"\",\n        elementDirection: \"\"\n      }));\n    });\n  }), i;\n}\nfunction Xl(t, e, n, r) {\n  var d, p;\n  const s = t.props, o = t.state, {\n    snapGridAll: i\n  } = s, {\n    snapGridWidth: a = 0,\n    snapGridHeight: c = 0\n  } = s, {\n    snapRenderInfo: l\n  } = o, u = l && (((d = l.direction) == null ? void 0 : d[0]) || ((p = l.direction) == null ? void 0 : p[1])), f = t.moveables;\n  if (i && f && u && (a || c)) {\n    if (o.snapThresholdInfo)\n      return;\n    o.snapThresholdInfo = {\n      multiples: [1, 1],\n      offset: [0, 0]\n    };\n    const g = t.getRect(), h = g.children, v = l.direction;\n    if (h) {\n      const m = v.map((x, C) => {\n        const {\n          snapSize: E,\n          posName: D,\n          sizeName: R,\n          clientOffset: y\n        } = C === 0 ? {\n          snapSize: a,\n          posName: \"left\",\n          sizeName: \"width\",\n          clientOffset: r.left - e\n        } : {\n          snapSize: c,\n          posName: \"top\",\n          sizeName: \"height\",\n          clientOffset: r.top - n\n        };\n        if (!E)\n          return {\n            dir: x,\n            multiple: 1,\n            snapSize: E,\n            snapOffset: 0\n          };\n        const M = g[R], P = g[D], _ = yc(h.map((G) => [\n          G[D] - P,\n          G[R],\n          M - G[R] - G[D] + P\n        ])).filter((G) => G).sort((G, L) => G - L), O = _[0], T = _.map((G) => tt(G / O, 0.1) * E);\n        let w = 1;\n        const k = tt(M / O, 0.1);\n        for (w = 1; w <= 10 && !T.every((G) => G * w % 1 === 0); ++w)\n          ;\n        const I = (-x + 1) / 2, $ = zn(\n          P - y,\n          P - y + M,\n          I,\n          1 - I\n        );\n        return {\n          multiple: k * w,\n          dir: x,\n          snapSize: E,\n          snapOffset: Math.round($ / E)\n        };\n      }), S = m.map((x) => x.multiple || 1);\n      o.snapThresholdInfo.multiples = S, o.snapThresholdInfo.offset = m.map((x) => x.snapOffset), m.forEach((x, C) => {\n        x.snapSize;\n      });\n    }\n  } else\n    o.snapThresholdInfo = null;\n}\nfunction Hl(t, e, n, r = 0, s = 0, o, i) {\n  const a = t.props, c = t.state;\n  let {\n    snapGridWidth: l = 0,\n    snapGridHeight: u = 0\n  } = a;\n  const f = [], {\n    left: d,\n    top: p\n  } = o;\n  let g = [0, 0];\n  Xl(\n    t,\n    r,\n    s,\n    o\n  );\n  const h = c.snapThresholdInfo, v = l, m = u;\n  if (h && (l *= h.multiples[0] || 1, u *= h.multiples[1] || 1, g = h.offset), u) {\n    const S = (x) => {\n      f.push({\n        type: \"horizontal\",\n        pos: [\n          d,\n          tt(g[1] * m + x - s + p, 0.1)\n        ],\n        className: U(\"grid-guideline\"),\n        size: e,\n        hide: !i,\n        direction: \"\",\n        grid: !0\n      });\n    };\n    for (let x = 0; x <= n * 2; x += u)\n      S(x);\n    for (let x = -u; x >= -n; x -= u)\n      S(x);\n  }\n  if (l) {\n    const S = (x) => {\n      f.push({\n        type: \"vertical\",\n        pos: [\n          tt(g[0] * v + x - r + d, 0.1),\n          p\n        ],\n        className: U(\"grid-guideline\"),\n        size: n,\n        hide: !i,\n        direction: \"\",\n        grid: !0\n      });\n    };\n    for (let x = 0; x <= e * 2; x += l)\n      S(x);\n    for (let x = -l; x >= -e; x -= l)\n      S(x);\n  }\n  return f;\n}\nfunction Ti(t, e, n, r) {\n  return n === \"horizontal\" ? B(t.right - e.left) <= r || B(t.left - e.right) <= r || t.left <= e.right && e.left <= t.right : n === \"vertical\" ? B(t.bottom - e.top) <= r || B(t.top - e.bottom) <= r || t.top <= e.bottom && e.top <= t.bottom : !0;\n}\nfunction ql(t) {\n  const e = t.state, {\n    elementGuidelines: n = []\n  } = t.props;\n  if (!n.length)\n    return e.elementRects = [], [];\n  const r = (e.elementRects || []).filter((u) => !u.refresh), s = n.map((u) => qt(u) && \"element\" in u ? {\n    ...u,\n    element: Zt(u.element, !0)\n  } : {\n    element: Zt(u, !0)\n  }).filter((u) => u.element), {\n    maintained: o,\n    added: i\n  } = Vl(r.map((u) => u.element), s.map((u) => u.element)), a = [];\n  o.forEach(([u, f]) => {\n    a[f] = r[u];\n  }), Ul(t, i.map((u) => s[u])).map((u, f) => {\n    a[i[f]] = u;\n  }), e.elementRects = a;\n  const c = cs(t.props.elementSnapDirections), l = [];\n  return a.forEach((u) => {\n    const {\n      element: f,\n      top: d = c.top,\n      left: p = c.left,\n      right: g = c.right,\n      bottom: h = c.bottom,\n      center: v = c.center,\n      middle: m = c.middle,\n      className: S,\n      rect: x\n    } = u, {\n      horizontal: C,\n      vertical: E,\n      horizontalNames: D,\n      verticalNames: R\n    } = ls({\n      top: d,\n      right: g,\n      left: p,\n      bottom: h,\n      center: v,\n      middle: m\n    }, x), y = x.top, M = x.left, P = x.right - M, _ = x.bottom - y, O = [P, _];\n    E.forEach((T, w) => {\n      l.push({\n        type: \"vertical\",\n        element: f,\n        pos: [\n          tt(T, 0.1),\n          y\n        ],\n        size: _,\n        sizes: O,\n        className: S,\n        elementRect: u,\n        elementDirection: qs[R[w]] || R[w],\n        direction: \"\"\n      });\n    }), C.forEach((T, w) => {\n      l.push({\n        type: \"horizontal\",\n        element: f,\n        pos: [\n          M,\n          tt(T, 0.1)\n        ],\n        size: P,\n        sizes: O,\n        className: S,\n        elementRect: u,\n        elementDirection: qs[D[w]] || D[w],\n        direction: \"\"\n      });\n    });\n  }), l;\n}\nfunction so(t, e) {\n  return t ? t.map((n) => {\n    const r = qt(n) ? n : { pos: n }, s = r.pos;\n    return an(s) ? r : {\n      ...r,\n      pos: ft(s, e)\n    };\n  }) : [];\n}\nfunction Oi(t, e, n, r, s = 0, o = 0, i = { left: 0, top: 0, right: 0, bottom: 0 }) {\n  const a = [], {\n    left: c,\n    top: l,\n    bottom: u,\n    right: f\n  } = i, d = n + f - c, p = r + u - l;\n  return so(t, p).forEach((g) => {\n    a.push({\n      type: \"horizontal\",\n      pos: [\n        c,\n        tt(g.pos - o + l, 0.1)\n      ],\n      size: d,\n      className: g.className,\n      direction: \"\"\n    });\n  }), so(e, d).forEach((g) => {\n    a.push({\n      type: \"vertical\",\n      pos: [\n        tt(g.pos - s + c, 0.1),\n        l\n      ],\n      size: p,\n      className: g.className,\n      direction: \"\"\n    });\n  }), a;\n}\nfunction Ul(t, e) {\n  if (!e.length)\n    return [];\n  const n = t.props.groupable, r = t.state, {\n    containerClientRect: s,\n    // targetClientRect: {\n    //     top: clientTop,\n    //     left: clientLeft,\n    // },\n    rootMatrix: o,\n    is3d: i,\n    offsetDelta: a\n  } = r, c = i ? 4 : 3, [l, u] = ul(o, s, c), f = n ? 0 : a[0], d = n ? 0 : a[1];\n  return e.map((p) => {\n    const g = p.element.getBoundingClientRect(), h = g.left - l - f, v = g.top - u - d, m = v + g.height, S = h + g.width, [x, C] = We(o, [h, v], c), [E, D] = We(o, [S, m], c);\n    return {\n      ...p,\n      rect: {\n        left: x,\n        right: E,\n        top: C,\n        bottom: D,\n        center: (x + E) / 2,\n        middle: (C + D) / 2\n      }\n    };\n  });\n}\nfunction yn(t) {\n  const e = t.state, n = e.container, r = t.props.snapContainer || n;\n  if (e.snapContainer === r && e.guidelines && e.guidelines.length)\n    return !1;\n  const s = e.containerClientRect, o = {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right: 0\n  };\n  if (n !== r) {\n    const i = Zt(r, !0);\n    if (i) {\n      const a = nn(i), c = uo(e, [\n        a.left - s.left,\n        a.top - s.top\n      ]), l = uo(e, [\n        a.right - s.right,\n        a.bottom - s.bottom\n      ]);\n      o.left = tt(c[0], 1e-5), o.top = tt(c[1], 1e-5), o.right = tt(l[0], 1e-5), o.bottom = tt(l[1], 1e-5);\n    }\n  }\n  return e.snapContainer = r, e.snapOffset = o, e.guidelines = Ir(t), e.enableSnap = !0, !0;\n}\nfunction wi(t, e, n, r, s, o) {\n  const i = Me(t, e, n, o ? 4 : 3), a = yt(i, r);\n  return hs(i, K(s, a));\n}\nfunction oo(t) {\n  return t ? t / B(t) : 0;\n}\nfunction Kl(t, e, n, r, s, o) {\n  const { fixedDirection: i } = o, a = gl(n, i, r), c = fs(t, e, n, r), l = [\n    ...Ml(\n      t,\n      e,\n      a,\n      r,\n      s,\n      o\n    ),\n    ...bi(\n      t,\n      c,\n      o\n    )\n  ], u = $n(l, 0), f = $n(l, 1);\n  return {\n    width: {\n      isBound: u.isBound,\n      offset: u.offset[0]\n    },\n    height: {\n      isBound: f.isBound,\n      offset: f.offset[1]\n    }\n  };\n}\nfunction Zl(t, e, n, r, s, o, i, a, c) {\n  const l = yt(e, i), {\n    horizontal: { offset: u },\n    vertical: { offset: f }\n  } = Zn(t, a, {\n    vertical: [l[0]],\n    horizontal: [l[1]]\n  });\n  if (tt(f, Cr) || tt(u, Cr)) {\n    const [d, p] = Qt({\n      datas: c,\n      distX: -f,\n      distY: -u\n    }), g = Math.min(\n      s || 1 / 0,\n      n + i[0] * d\n    ), h = Math.min(\n      o || 1 / 0,\n      r + i[1] * p\n    );\n    return [g - n, h - r];\n  }\n  return [0, 0];\n}\nfunction Ii(t, e, n, r, s, o, i, a) {\n  const c = jt(t.state), l = t.props.keepRatio;\n  let u = 0, f = 0;\n  for (let d = 0; d < 2; ++d) {\n    const p = e(u, f), {\n      width: g,\n      height: h\n    } = Kl(\n      t,\n      p,\n      s,\n      l,\n      i,\n      a\n    ), v = g.isBound, m = h.isBound;\n    let S = g.offset, x = h.offset;\n    if (d === 1 && (v || (S = 0), m || (x = 0)), d === 0 && i && !v && !m)\n      return [0, 0];\n    if (l) {\n      const C = B(S) * (n ? 1 / n : 1), E = B(x) * (r ? 1 / r : 1);\n      (v && m ? C < E : m || !v && C < E) ? S = n * x / r : x = r * S / n;\n    }\n    u += S, f += x;\n  }\n  if (!l && s[0] && s[1]) {\n    const { maxWidth: d, maxHeight: p } = _l(\n      t,\n      c,\n      s,\n      o,\n      a\n    ), [g, h] = Zl(\n      t,\n      e(u, f).map((v) => v.map((m) => tt(m, Cr))),\n      n + u,\n      r + f,\n      d,\n      p,\n      s,\n      i,\n      a\n    );\n    u += g, f += h;\n  }\n  return [u, f];\n}\nfunction tn(t) {\n  return t < 0 && (t = t % 360 + 360), t %= 360, t;\n}\nfunction Jl(t, e) {\n  e = tn(e);\n  const n = Math.floor(t / 360), r = n * 360 + 360 - e, s = n * 360 + e;\n  return B(t - r) < B(t - s) ? r : s;\n}\nfunction dr(t, e) {\n  t = tn(t), e = tn(e);\n  const n = tn(t - e);\n  return Math.min(n, 360 - n);\n}\nfunction Ql(t, e, n, r) {\n  const s = t.props, o = s[hi] ?? 5, i = s[vi];\n  if (Xe(t, \"rotatable\")) {\n    const { pos1: a, pos2: c, pos3: l, pos4: u, origin: f } = e, d = n * Math.PI / 180, p = [a, c, l, u].map((m) => K(m, f)), g = p.map((m) => gn(m, d)), h = [\n      ...il(t, p, g, f, n),\n      ...El(\n        t,\n        p,\n        g,\n        f,\n        n\n      )\n    ];\n    h.sort((m, S) => B(m - n) - B(S - n));\n    const v = h.length > 0;\n    if (v)\n      return {\n        isSnap: v,\n        dist: v ? h[0] : n\n      };\n  }\n  if (i != null && i.length && o) {\n    const c = i.slice().sort((l, u) => dr(l, r) - dr(u, r))[0];\n    if (dr(c, r) <= o)\n      return {\n        isSnap: !0,\n        dist: n + Jl(r, c) - r\n      };\n  }\n  return {\n    isSnap: !1,\n    dist: n\n  };\n}\nfunction tu(t, e, n, r, s, o, i) {\n  if (!Xe(t, \"resizable\"))\n    return [0, 0];\n  const { fixedDirection: a, nextAllMatrix: c } = i, { allMatrix: l, is3d: u } = t.state;\n  return Ii(\n    t,\n    (f, d) => wi(\n      c || l,\n      e + f,\n      n + d,\n      a,\n      s,\n      u\n    ),\n    e,\n    n,\n    r,\n    s,\n    o,\n    i\n  );\n}\nfunction eu(t, e, n, r, s) {\n  if (!Xe(t, \"scalable\"))\n    return [0, 0];\n  const { startOffsetWidth: o, startOffsetHeight: i, fixedPosition: a, fixedDirection: c, is3d: l } = s, u = Ii(\n    t,\n    (f, d) => wi(\n      Yc(\n        s,\n        at(e, [f / o, d / i])\n      ),\n      o,\n      i,\n      c,\n      a,\n      l\n    ),\n    o,\n    i,\n    n,\n    a,\n    r,\n    s\n  );\n  return [u[0] / o, u[1] / i];\n}\nfunction nu(t, e) {\n  e.absolutePoses = jt(t.state);\n}\nfunction io(t) {\n  const e = [];\n  return t.forEach((n) => {\n    n.guidelineInfos.forEach(({ guideline: r }) => {\n      kt(e, (s) => s.guideline === r) || (r.direction = \"\", e.push({ guideline: r, posInfo: n }));\n    });\n  }), e.map(({ guideline: n, posInfo: r }) => ({\n    ...n,\n    direction: r.direction\n  }));\n}\nfunction ao(t, e, n, r, s, o) {\n  const {\n    vertical: i,\n    horizontal: a\n  } = as(\n    Un(t, o),\n    e,\n    n\n  ), c = Be();\n  i.forEach((d) => {\n    d.isBound && (d.direction === \"start\" && (c.left = !0), d.direction === \"end\" && (c.right = !0), r.push({\n      type: \"bounds\",\n      pos: d.pos\n    }));\n  }), a.forEach((d) => {\n    d.isBound && (d.direction === \"start\" && (c.top = !0), d.direction === \"end\" && (c.bottom = !0), s.push({\n      type: \"bounds\",\n      pos: d.pos\n    }));\n  });\n  const {\n    boundMap: l,\n    vertical: u,\n    horizontal: f\n  } = Cl(t);\n  return u.forEach((d) => {\n    ne(\n      r,\n      ({ type: p, pos: g }) => p === \"bounds\" && g === d\n    ) >= 0 || r.push({\n      type: \"bounds\",\n      pos: d\n    });\n  }), f.forEach((d) => {\n    ne(\n      s,\n      ({ type: p, pos: g }) => p === \"bounds\" && g === d\n    ) >= 0 || s.push({\n      type: \"bounds\",\n      pos: d\n    });\n  }), {\n    boundMap: c,\n    innerBoundMap: l\n  };\n}\nconst ru = xs(\"\", [\"resizable\", \"scalable\"]), su = {\n  name: \"snappable\",\n  dragRelation: \"strong\",\n  props: [\n    \"snappable\",\n    \"snapContainer\",\n    \"snapDirections\",\n    \"elementSnapDirections\",\n    \"snapGap\",\n    \"snapGridWidth\",\n    \"snapGridHeight\",\n    \"isDisplaySnapDigit\",\n    \"isDisplayInnerSnapDigit\",\n    \"isDisplayGridGuidelines\",\n    \"snapDigit\",\n    \"snapThreshold\",\n    \"snapRenderThreshold\",\n    \"snapGridAll\",\n    hi,\n    vi,\n    mi,\n    xi,\n    \"horizontalGuidelines\",\n    \"verticalGuidelines\",\n    \"elementGuidelines\",\n    \"bounds\",\n    \"innerBounds\",\n    \"snapDistFormat\",\n    \"maxSnapElementGuidelineDistance\",\n    \"maxSnapElementGapDistance\"\n  ],\n  events: [\"snap\", \"bound\"],\n  css: [\n    `:host {\n--bounds-color: #d66;\n}\n.guideline {\npointer-events: none;\nz-index: 2;\n}\n.guideline.bounds {\nbackground: #d66;\nbackground: var(--bounds-color);\n}\n.guideline-group {\nposition: absolute;\ntop: 0;\nleft: 0;\n}\n.guideline-group .size-value {\nposition: absolute;\ncolor: #f55;\nfont-size: 12px;\nfont-size: calc(12px * var(--zoom));\nfont-weight: bold;\n}\n.guideline-group.horizontal .size-value {\ntransform-origin: 50% 100%;\ntransform: translateX(-50%);\nleft: 50%;\nbottom: 5px;\nbottom: calc(2px + 3px * var(--zoom));\n}\n.guideline-group.vertical .size-value {\ntransform-origin: 0% 50%;\ntop: 50%;\ntransform: translateY(-50%);\nleft: 5px;\nleft: calc(2px + 3px * var(--zoom));\n}\n.guideline.gap {\nbackground: #f55;\n}\n.size-value.gap {\ncolor: #f55;\n}\n`\n  ],\n  render(t, e) {\n    const n = t.state, {\n      top: r,\n      left: s,\n      pos1: o,\n      pos2: i,\n      pos3: a,\n      pos4: c,\n      snapRenderInfo: l\n    } = n, {\n      snapRenderThreshold: u = 1\n    } = t.props;\n    if (!l || !l.render || !Xe(t, \"\"))\n      return Ae(\n        t,\n        \"boundMap\",\n        Be(),\n        (z) => JSON.stringify(z)\n      ), Ae(\n        t,\n        \"innerBoundMap\",\n        Be(),\n        (z) => JSON.stringify(z)\n      ), [];\n    n.guidelines = Ir(t);\n    const f = Math.min(o[0], i[0], a[0], c[0]), d = Math.min(o[1], i[1], a[1], c[1]), p = l.externalPoses || [], g = jt(t.state), h = [], v = [], m = [], S = [], x = [], { width: C, height: E, top: D, left: R, bottom: y, right: M } = Yt(g), P = { left: R, right: M, top: D, bottom: y, center: (R + M) / 2, middle: (D + y) / 2 }, _ = p.length > 0, O = _ ? Yt(p) : {};\n    if (!l.request) {\n      if (l.direction && x.push(\n        pl(\n          t,\n          g,\n          l.direction,\n          u,\n          u\n        )\n      ), l.snap) {\n        const z = Yt(g);\n        l.center && (z.middle = (z.top + z.bottom) / 2, z.center = (z.left + z.right) / 2), x.push(Us(t, z, u, u));\n      }\n      _ && (l.center && (O.middle = (O.top + O.bottom) / 2, O.center = (O.left + O.right) / 2), x.push(Us(t, O, u, u))), x.forEach((z) => {\n        const {\n          vertical: { posInfos: N },\n          horizontal: { posInfos: Z }\n        } = z;\n        h.push(\n          ...N.filter(({ guidelineInfos: Y }) => Y.some(({ guideline: W }) => !W.hide)).map(\n            (Y) => ({\n              type: \"snap\",\n              pos: Y.pos\n            })\n          )\n        ), v.push(\n          ...Z.filter(({ guidelineInfos: Y }) => Y.some(({ guideline: W }) => !W.hide)).map(\n            (Y) => ({\n              type: \"snap\",\n              pos: Y.pos\n            })\n          )\n        ), m.push(...io(N)), S.push(...io(Z));\n      });\n    }\n    const {\n      boundMap: T,\n      innerBoundMap: w\n    } = ao(\n      t,\n      [R, M],\n      [D, y],\n      h,\n      v\n    );\n    _ && ao(\n      t,\n      [O.left, O.right],\n      [O.top, O.bottom],\n      h,\n      v,\n      l.externalBounds\n    );\n    const k = [...m, ...S], I = k.filter((z) => z.element && !z.gapRects), $ = k.filter((z) => z.gapRects).sort((z, N) => z.gap - N.gap);\n    j(\n      t,\n      \"onSnap\",\n      {\n        guidelines: k.filter(({ element: z }) => !z),\n        elements: I,\n        gaps: $\n      },\n      !0\n    );\n    const G = Ae(\n      t,\n      \"boundMap\",\n      T,\n      (z) => JSON.stringify(z),\n      Be()\n    ), L = Ae(\n      t,\n      \"innerBoundMap\",\n      w,\n      (z) => JSON.stringify(z),\n      Be()\n    );\n    return (T === G || w === L) && j(\n      t,\n      \"onBound\",\n      {\n        bounds: T,\n        innerBounds: w\n      },\n      !0\n    ), [\n      ...zl(\n        t,\n        I,\n        [f, d],\n        P,\n        e\n      ),\n      ...Al(\n        t,\n        $,\n        [f, d],\n        P,\n        e\n      ),\n      ...ro(\n        t,\n        \"horizontal\",\n        S,\n        [s, r],\n        P,\n        e\n      ),\n      ...ro(\n        t,\n        \"vertical\",\n        m,\n        [s, r],\n        P,\n        e\n      ),\n      ...no(\n        t,\n        \"horizontal\",\n        v,\n        f,\n        r,\n        C,\n        0,\n        e\n      ),\n      ...no(\n        t,\n        \"vertical\",\n        h,\n        d,\n        s,\n        E,\n        1,\n        e\n      )\n    ];\n  },\n  dragStart(t, e) {\n    t.state.snapRenderInfo = {\n      request: e.isRequest,\n      snap: !0,\n      center: !0\n    }, yn(t);\n  },\n  drag(t) {\n    const e = t.state;\n    yn(t) || (e.guidelines = Ir(t)), e.snapRenderInfo && (e.snapRenderInfo.render = !0);\n  },\n  pinchStart(t) {\n    this.unset(t);\n  },\n  dragEnd(t) {\n    this.unset(t);\n  },\n  dragControlCondition(t, e) {\n    if (ru(t, e) || Or(t, e))\n      return !0;\n    if (!e.isRequest && e.inputEvent)\n      return bt(e.inputEvent.target, U(\"snap-control\"));\n  },\n  dragControlStart(t) {\n    t.state.snapRenderInfo = null, yn(t);\n  },\n  dragControl(t) {\n    this.drag(t);\n  },\n  dragControlEnd(t) {\n    this.unset(t);\n  },\n  dragGroupStart(t, e) {\n    this.dragStart(t, e);\n  },\n  dragGroup(t) {\n    this.drag(t);\n  },\n  dragGroupEnd(t) {\n    this.unset(t);\n  },\n  dragGroupControlStart(t) {\n    t.state.snapRenderInfo = null, yn(t);\n  },\n  dragGroupControl(t) {\n    this.drag(t);\n  },\n  dragGroupControlEnd(t) {\n    this.unset(t);\n  },\n  unset(t) {\n    const e = t.state;\n    e.enableSnap = !1, e.guidelines = [], e.snapRenderInfo = null, e.elementRects = [];\n  }\n};\nfunction ou(t, e) {\n  return [t[0] * e[0], t[1] * e[1]];\n}\nfunction U(...t) {\n  return cc(Hr, ...t);\n}\nfunction Bi(t) {\n  t();\n}\nfunction iu(t) {\n  return !t || t === \"none\" ? [1, 0, 0, 1, 0, 0] : qt(t) ? t : ln(t);\n}\nfunction en(t, e, n) {\n  return An(\n    e,\n    Ce(n, e),\n    t,\n    Ce(\n      n.map((r) => -r),\n      e\n    )\n  );\n}\nfunction au(t, e, n) {\n  return e === \"%\" ? gs(t.ownerSVGElement)[n ? \"width\" : \"height\"] / 100 : 1;\n}\nfunction cu(t) {\n  return lu(vs(t, \":before\")).map((n, r) => {\n    const { value: s, unit: o } = pn(n);\n    return s * au(t, o, r === 0);\n  });\n}\nfunction Ln(t) {\n  return t ? t.split(\" \") : [\"0\", \"0\"];\n}\nfunction lu(t) {\n  return Ln(t.transformOrigin);\n}\nfunction zi(t) {\n  const n = Gt(t)(\"transform\");\n  if (n && n !== \"none\")\n    return n;\n  if (\"transform\" in t) {\n    const s = t.transform.baseVal;\n    if (!s)\n      return \"\";\n    const o = s.length;\n    if (!o)\n      return \"\";\n    const i = [];\n    for (let a = 0; a < o; ++a) {\n      const c = s[a].matrix;\n      i.push(\n        `matrix(${[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"].map((l) => c[l]).join(\", \")})`\n      );\n    }\n    return i.join(\" \");\n  }\n  return \"\";\n}\nfunction fn(t, e, n, r, s) {\n  var h, v;\n  const o = es(t) || fe(t);\n  let i = !1, a, c;\n  if (!t || n)\n    a = t;\n  else {\n    const m = (h = t == null ? void 0 : t.assignedSlot) == null ? void 0 : h.parentElement, S = t.parentElement;\n    m ? (i = !0, c = S, a = m) : a = S;\n  }\n  let l = !1, u = t === e || a === e, f = \"relative\", d = 1;\n  const p = parseFloat(s == null ? void 0 : s(\"zoom\")) || 1, g = s == null ? void 0 : s(\"position\");\n  for (; a && a !== o; ) {\n    e === a && (u = !0);\n    const m = Gt(a), S = a.tagName.toLowerCase(), x = zi(a), C = m(\"willChange\"), E = parseFloat(m(\"zoom\")) || 1;\n    if (f = m(\"position\"), r && E !== 1) {\n      d = E;\n      break;\n    }\n    if (\n      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.\n      !n && r && p !== 1 && g && g !== \"absolute\" || S === \"svg\" || S === \"foreignobject\" || f !== \"static\" || x && x !== \"none\" || C === \"transform\"\n    )\n      break;\n    const D = (v = t == null ? void 0 : t.assignedSlot) == null ? void 0 : v.parentNode, R = a.parentNode;\n    D && (i = !0, c = R);\n    const y = R;\n    if (y && y.nodeType === 11) {\n      a = y.host, l = !0, f = Gt(a)(\"position\");\n      break;\n    }\n    a = y, f = \"relative\";\n  }\n  return {\n    offsetZoom: d,\n    hasSlot: i,\n    parentSlotElement: c,\n    isCustomElement: l,\n    isStatic: f === \"static\",\n    isEnd: u || !a || a === o,\n    offsetParent: a || o\n  };\n}\nfunction uu(t, e) {\n  const n = t.tagName.toLowerCase();\n  let r = t.offsetLeft, s = t.offsetTop;\n  const o = Gt(t), i = Kr(r);\n  let a = !i, c, l;\n  return !a && (n !== \"svg\" || t.ownerSVGElement) ? (c = Fo ? cu(t) : Ln(o(\"transformOrigin\")).map(\n    (u) => parseFloat(u)\n  ), l = c.slice(), a = !0, n === \"svg\" ? (r = 0, s = 0) : [r, s, c[0], c[1]] = pu(\n    t,\n    c,\n    t === e && e.tagName.toLowerCase() === \"g\"\n  )) : (c = Ln(o(\"transformOrigin\")).map(\n    (u) => parseFloat(u)\n  ), l = c.slice()), {\n    tagName: n,\n    isSVG: i,\n    hasOffset: a,\n    offset: [r || 0, s || 0],\n    origin: c,\n    targetOrigin: l\n  };\n}\nfunction Ai(t, e) {\n  const n = Gt(t), r = Gt(fe(t)), s = r(\"position\");\n  if (!e && (!s || s === \"static\"))\n    return [0, 0];\n  let o = parseInt(r(\"marginLeft\"), 10), i = parseInt(r(\"marginTop\"), 10);\n  return n(\"position\") === \"absolute\" && ((n(\"top\") !== \"auto\" || n(\"bottom\") !== \"auto\") && (i = 0), (n(\"left\") !== \"auto\" || n(\"right\") !== \"auto\") && (o = 0)), [o, i];\n}\nfunction Br(t) {\n  t.forEach((e) => {\n    const n = e.matrix;\n    n && (e.matrix = Ut(n, 3, 4));\n  });\n}\nfunction fu(t) {\n  let e = t.parentElement, n = !1;\n  const r = fe(t);\n  for (; e; ) {\n    const s = vs(e).transform;\n    if (s && s !== \"none\") {\n      n = !0;\n      break;\n    }\n    if (e === r)\n      break;\n    e = e.parentElement;\n  }\n  return {\n    fixedContainer: e || r,\n    hasTransform: n\n  };\n}\nfunction Jn(t, e = t.length > 9) {\n  return `${e ? \"matrix3d\" : \"matrix\"}(${ei(t, !e).join(\",\")})`;\n}\nfunction gs(t) {\n  const e = t.clientWidth, n = t.clientHeight;\n  if (!t)\n    return { x: 0, y: 0, width: 0, height: 0, clientWidth: e, clientHeight: n };\n  const r = t.viewBox, s = r && r.baseVal || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  return {\n    x: s.x,\n    y: s.y,\n    width: s.width || e,\n    height: s.height || n,\n    clientWidth: e,\n    clientHeight: n\n  };\n}\nfunction du(t, e) {\n  const {\n    width: n,\n    height: r,\n    clientWidth: s,\n    clientHeight: o\n  } = gs(t), i = s / n, a = o / r, c = t.preserveAspectRatio.baseVal, l = c.align, u = c.meetOrSlice, f = [0, 0], d = [i, a], p = [0, 0];\n  if (l !== 1) {\n    const h = (l - 2) % 3, v = Math.floor((l - 2) / 3);\n    f[0] = n * h / 2, f[1] = r * v / 2;\n    const m = u === 2 ? Math.max(a, i) : Math.min(i, a);\n    d[0] = m, d[1] = m, p[0] = (s - n) / 2 * h, p[1] = (o - r) / 2 * v;\n  }\n  const g = rs(d, e);\n  return [g[e * (e - 1)], g[e * (e - 1) + 1]] = p, en(g, e, f);\n}\nfunction pu(t, e, n) {\n  const r = t.tagName.toLowerCase();\n  if (!t.getBBox || !n && r === \"g\")\n    return [0, 0, 0, 0];\n  const o = Gt(t)(\"transform-box\") === \"fill-box\", i = t.getBBox(), a = gs(t.ownerSVGElement);\n  let c = i.x, l = i.y;\n  r === \"foreignobject\" && !c && !l && (c = parseFloat(t.getAttribute(\"x\")) || 0, l = parseFloat(t.getAttribute(\"y\")) || 0);\n  const u = c - a.x, f = l - a.y, d = o ? e[0] : e[0] - u, p = o ? e[1] : e[1] - f;\n  return [u, f, d, p];\n}\nfunction ht(t, e, n) {\n  return _t(t, Ee(e, n), n);\n}\nfunction Me(t, e, n, r) {\n  return [\n    [0, 0],\n    [e, 0],\n    [0, n],\n    [e, n]\n  ].map((s) => ht(t, s, r));\n}\nfunction Yt(t) {\n  const e = t.map((l) => l[0]), n = t.map((l) => l[1]), r = Math.min(...e), s = Math.min(...n), o = Math.max(...e), i = Math.max(...n), a = o - r, c = i - s;\n  return {\n    left: r,\n    top: s,\n    right: o,\n    bottom: i,\n    width: a,\n    height: c\n  };\n}\nfunction co(t, e, n, r) {\n  const s = Me(t, e, n, r);\n  return Yt(s);\n}\nfunction gu(t, e, n, r, s) {\n  const o = t.target, i = t.origin, a = e.matrix, { offsetWidth: c, offsetHeight: l } = ki(o), u = n.getBoundingClientRect();\n  let f = [0, 0];\n  n === fe(n) && (f = Ai(o, !0));\n  const d = o.getBoundingClientRect(), p = d.left - u.left + n.scrollLeft - (n.clientLeft || 0) + f[0], g = d.top - u.top + n.scrollTop - (n.clientTop || 0) + f[1], h = d.width, v = d.height, m = An(r, s, a), {\n    left: S,\n    top: x,\n    width: C,\n    height: E\n  } = co(m, c, l, r), D = ht(m, i, r), R = K(D, [S, x]), y = [\n    p + R[0] * h / C,\n    g + R[1] * v / E\n  ], M = [0, 0];\n  let P = 0;\n  for (; ++P < 10; ) {\n    const _ = Jt(s, r);\n    [M[0], M[1]] = K(\n      ht(_, y, r),\n      ht(_, D, r)\n    );\n    const O = An(\n      r,\n      s,\n      Ce(M, r),\n      a\n    ), { left: T, top: w } = co(\n      O,\n      c,\n      l,\n      r\n    ), k = T - p, I = w - g;\n    if (B(k) < 2 && B(I) < 2)\n      break;\n    y[0] -= k, y[1] -= I;\n  }\n  return M.map((_) => Math.round(_));\n}\nfunction hu(t, e, n) {\n  const s = t.length === 16 ? 4 : 3, o = e.map((c) => ht(t, c, s)), { left: i, top: a } = n;\n  return o.map((c) => [c[0] + i, c[1] + a]);\n}\nfunction Vt(t) {\n  return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n}\nfunction Gi(t, e) {\n  return Vt([e[0] - t[0], e[1] - t[1]]);\n}\nfunction Je(t, e, n = 1, r = xt(t, e)) {\n  const s = Gi(t, e);\n  return {\n    transform: `translateY(-50%) translate(${t[0]}px, ${t[1]}px) rotate(${r}rad) scaleY(${n})`,\n    width: `${s}px`\n  };\n}\nfunction Nn(t, e, ...n) {\n  const r = n.length, s = n.reduce((i, a) => i + a[0], 0) / r, o = n.reduce((i, a) => i + a[1], 0) / r;\n  return {\n    transform: `translateZ(0px) translate(${s}px, ${o}px) rotate(${t}rad) scale(${e})`\n  };\n}\nfunction De(t, e) {\n  const n = t[e];\n  return qt(n) ? {\n    ...t,\n    ...n\n  } : t;\n}\nfunction ki(t) {\n  const e = t && !Kr(t.offsetWidth);\n  let n = 0, r = 0, s = 0, o = 0, i = 0, a = 0, c = 0, l = 0, u = 0, f = 0, d = 0, p = 0, g = 1 / 0, h = 1 / 0, v = 1 / 0, m = 1 / 0, S = 0, x = 0, C = !1;\n  if (t)\n    if (!e && t.ownerSVGElement) {\n      const E = t.getBBox();\n      C = !0, n = E.width, r = E.height, i = n, a = r, c = n, l = r, s = n, o = r;\n    } else {\n      const E = Gt(t), D = t.style, R = E(\"boxSizing\") === \"border-box\", y = parseFloat(E(\"borderLeftWidth\")) || 0, M = parseFloat(E(\"borderRightWidth\")) || 0, P = parseFloat(E(\"borderTopWidth\")) || 0, _ = parseFloat(E(\"borderBottomWidth\")) || 0, O = parseFloat(E(\"paddingLeft\")) || 0, T = parseFloat(E(\"paddingRight\")) || 0, w = parseFloat(E(\"paddingTop\")) || 0, k = parseFloat(E(\"paddingBottom\")) || 0, I = O + T, $ = w + k, G = y + M, L = P + _, z = I + G, N = $ + L, Z = E(\"position\");\n      let Y = 0, W = 0;\n      if (\"clientLeft\" in t) {\n        let J = null;\n        if (Z === \"absolute\" ? J = fn(t, fe(t)).offsetParent : J = t.parentElement, J) {\n          const q = Gt(J);\n          Y = parseFloat(q(\"width\")), W = parseFloat(q(\"height\"));\n        }\n      }\n      u = Math.max(\n        I,\n        ft(E(\"minWidth\"), Y) || 0\n      ), f = Math.max(\n        $,\n        ft(E(\"minHeight\"), W) || 0\n      ), g = ft(E(\"maxWidth\"), Y), h = ft(E(\"maxHeight\"), W), isNaN(g) && (g = 1 / 0), isNaN(h) && (h = 1 / 0), S = ft(D.width, 0) || 0, x = ft(D.height, 0) || 0, i = parseFloat(E(\"width\")) || 0, a = parseFloat(E(\"height\")) || 0, c = B(i - S) < 1 ? br(u, S || i, g) : i, l = B(a - x) < 1 ? br(f, x || a, h) : a, n = c, r = l, s = c, o = l, R ? (v = g, m = h, d = u, p = f, c = n - z, l = r - N) : (v = g + z, m = h + N, d = u + z, p = f + N, n = c + z, r = l + N), s = c + I, o = l + $;\n    }\n  return {\n    svg: C,\n    offsetWidth: n,\n    offsetHeight: r,\n    clientWidth: s,\n    clientHeight: o,\n    contentWidth: c,\n    contentHeight: l,\n    inlineCSSWidth: S,\n    inlineCSSHeight: x,\n    cssWidth: i,\n    cssHeight: a,\n    minWidth: u,\n    minHeight: f,\n    maxWidth: g,\n    maxHeight: h,\n    minOffsetWidth: d,\n    minOffsetHeight: p,\n    maxOffsetWidth: v,\n    maxOffsetHeight: m\n  };\n}\nfunction $i(t, e) {\n  return xt(\n    e > 0 ? t[0] : t[1],\n    e > 0 ? t[1] : t[0]\n  );\n}\nfunction Rn() {\n  return {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0\n  };\n}\nfunction Fi(t, e) {\n  const n = t === fe(t) || t === es(t), r = {\n    clientLeft: t.clientLeft,\n    clientTop: t.clientTop,\n    clientWidth: t.clientWidth,\n    clientHeight: t.clientHeight,\n    scrollWidth: t.scrollWidth,\n    scrollHeight: t.scrollHeight,\n    overflow: !1\n  };\n  return n && (r.clientHeight = Math.max(e.height, r.clientHeight), r.scrollHeight = Math.max(e.height, r.scrollHeight)), r.overflow = Gt(t)(\"overflow\") !== \"visible\", {\n    ...e,\n    ...r\n  };\n}\nfunction pr(t, e, n, r) {\n  const { left: s, right: o, top: i, bottom: a } = t, c = e.top, l = e.left, u = {\n    left: l + s,\n    top: c + i,\n    right: l + o,\n    bottom: c + a,\n    width: o - s,\n    height: a - i\n  };\n  return n && r ? Fi(n, u) : u;\n}\nfunction nn(t, e) {\n  let n = 0, r = 0, s = 0, o = 0;\n  if (t) {\n    const a = t.getBoundingClientRect();\n    n = a.left, r = a.top, s = a.width, o = a.height;\n  }\n  const i = {\n    left: n,\n    top: r,\n    width: s,\n    height: o,\n    right: n + s,\n    bottom: r + o\n  };\n  return t && e ? Fi(t, i) : i;\n}\nfunction vu(t) {\n  const { groupable: e, svgOrigin: n } = t.props, { offsetWidth: r, offsetHeight: s, svg: o, transformOrigin: i } = t.getState();\n  return !e && o && n ? Es(n, r, s) : i;\n}\nfunction Li(t, e, n, r) {\n  let s;\n  if (t)\n    s = t;\n  else if (e)\n    s = [0, 0];\n  else {\n    const o = n.target;\n    s = Ni(o, r);\n  }\n  return s;\n}\nfunction Ni(t, e) {\n  if (!t)\n    return;\n  const n = t.getAttribute(\"data-rotation\") || \"\", r = t.getAttribute(\"data-direction\");\n  if (e.deg = n, !r)\n    return;\n  const s = [0, 0];\n  return r.indexOf(\"w\") > -1 && (s[0] = -1), r.indexOf(\"e\") > -1 && (s[0] = 1), r.indexOf(\"n\") > -1 && (s[1] = -1), r.indexOf(\"s\") > -1 && (s[1] = 1), s;\n}\nfunction hs(t, e) {\n  return [\n    at(e, t[0]),\n    at(e, t[1]),\n    at(e, t[2]),\n    at(e, t[3])\n  ];\n}\nfunction jt({\n  left: t,\n  top: e,\n  pos1: n,\n  pos2: r,\n  pos3: s,\n  pos4: o\n}) {\n  return hs([n, r, s, o], [t, e]);\n}\nfunction zr(t, e) {\n  t[e ? \"controlAbles\" : \"targetAbles\"].forEach((n) => {\n    n.unset && n.unset(t);\n  });\n}\nfunction ze(t, e) {\n  const n = e ? \"controlGesto\" : \"targetGesto\", r = t[n];\n  (r == null ? void 0 : r.isIdle()) === !1 && zr(t, e), r == null || r.unset(), t[n] = null;\n}\nfunction It(t, e) {\n  if (e) {\n    const n = je(e);\n    n.nextStyle = {\n      ...n.nextStyle,\n      ...t\n    };\n  }\n  return {\n    style: t,\n    cssText: Ve(t).map((n) => `${Sc(n, \"-\")}: ${t[n]};`).join(\"\")\n  };\n}\nfunction Wi(t, e, n) {\n  const r = e.afterTransform || e.transform;\n  return {\n    ...It(\n      {\n        ...t.style,\n        ...e.style,\n        transform: r\n      },\n      n\n    ),\n    afterTransform: r,\n    transform: t.transform\n  };\n}\nfunction et(t, e, n, r) {\n  const s = e.datas;\n  s.datas || (s.datas = {});\n  const o = {\n    ...n,\n    target: t.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: t,\n    moveable: t,\n    datas: s.datas,\n    isRequest: e.isRequest,\n    isRequestChild: e.isRequestChild,\n    isFirstDrag: !!e.isFirstDrag,\n    isTrusted: e.isTrusted !== !1,\n    stopAble() {\n      s.isEventStart = !1;\n    },\n    stopDrag() {\n      var i;\n      (i = e.stop) == null || i.call(e);\n    }\n  };\n  return s.isStartEvent ? r || (s.lastEvent = o) : s.isStartEvent = !0, o;\n}\nfunction $t(t, e, n) {\n  const r = e.datas, s = \"isDrag\" in n ? n.isDrag : e.isDrag;\n  return r.datas || (r.datas = {}), {\n    isDrag: s,\n    ...n,\n    moveable: t,\n    target: t.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: t,\n    lastEvent: r.lastEvent,\n    isDouble: e.isDouble,\n    datas: r.datas,\n    isFirstDrag: !!e.isFirstDrag\n  };\n}\nfunction Qn(t, e, n) {\n  t._emitter.on(e, n);\n}\nfunction j(t, e, n, r, s) {\n  return t.triggerEvent(e, n, r, s);\n}\nfunction vs(t, e) {\n  return ae(t).getComputedStyle(t, e);\n}\nfunction Mn(t, e, n) {\n  const r = {}, s = {};\n  return t.filter((o) => {\n    const i = o.name;\n    if (r[i] || !e.some((a) => o[a]))\n      return !1;\n    if (!n && o.ableGroup) {\n      if (s[o.ableGroup])\n        return !1;\n      s[o.ableGroup] = !0;\n    }\n    return r[i] = !0, !0;\n  });\n}\nfunction Ar(t, e) {\n  return t === e || t == null && e == null;\n}\nfunction lo(...t) {\n  const e = t.length - 1;\n  for (let n = 0; n < e; ++n) {\n    const r = t[n];\n    if (!Kr(r))\n      return r;\n  }\n  return t[e];\n}\nfunction Yi(t, e) {\n  const n = [], r = [];\n  return t.forEach((s, o) => {\n    const i = e(s, o, t), a = r.indexOf(i), c = n[a] || [];\n    a === -1 && (r.push(i), n.push(c)), c.push(s);\n  }), n;\n}\nfunction mu(t, e) {\n  const n = [], r = {};\n  return t.forEach((s, o) => {\n    const i = e(s, o, t);\n    let a = r[i];\n    a || (a = [], r[i] = a, n.push(a)), a.push(s);\n  }), n;\n}\nfunction Vi(t) {\n  return t.reduce((e, n) => e.concat(n), []);\n}\nfunction Ne(...t) {\n  return t.sort((e, n) => B(n) - B(e)), t[0];\n}\nfunction We(t, e, n) {\n  return _t(Jt(t, n), Ee(e, n), n);\n}\nfunction xu(t, e) {\n  const { is3d: n, rootMatrix: r } = t, s = n ? 4 : 3;\n  return [e.distX, e.distY] = We(\n    r,\n    [e.distX, e.distY],\n    s\n  ), e;\n}\nfunction Wt(t, e, n, r) {\n  if (!n[0] && !n[1])\n    return e;\n  const s = ht(t, [oo(n[0] || 1), 0], r), o = ht(t, [0, oo(n[1] || 1)], r), i = ht(\n    t,\n    [n[0] / Vt(s), n[1] / Vt(o)],\n    r\n  );\n  return at(e, i);\n}\nfunction Xt(t, e, n) {\n  return n ? `${t / e * 100}%` : `${t}px`;\n}\nfunction Wn(t) {\n  return B(t) <= Bt ? 0 : t;\n}\nfunction ms(t) {\n  return (e) => {\n    if (!e.isDragging(t))\n      return \"\";\n    const r = Kc(e, t).deg;\n    return r ? U(`view-control-rotation${r}`) : \"\";\n  };\n}\nfunction xs(t, e = [t]) {\n  return (n, r) => {\n    if (r.isRequest)\n      return e.some((o) => r.requestAble === o) ? r.parentDirection : !1;\n    const s = r.inputEvent.target;\n    return bt(s, U(\"direction\")) && (!t || bt(s, U(t)));\n  };\n}\nfunction Su(t, e, n) {\n  const r = $e(t, {\n    \"x%\": (C) => C / 100 * e.offsetWidth,\n    \"y%\": (C) => C / 100 * e.offsetHeight\n  }), s = t.slice(\n    0,\n    n < 0 ? void 0 : n\n  ), o = t.slice(\n    0,\n    n < 0 ? void 0 : n + 1\n  ), i = t[n] || \"\", a = n < 0 ? [] : t.slice(n), c = n < 0 ? [] : t.slice(n + 1), l = r.slice(0, n < 0 ? void 0 : n), u = r.slice(\n    0,\n    n < 0 ? void 0 : n + 1\n  ), f = r[n] ?? $e([\"\"])[0], d = n < 0 ? [] : r.slice(n), p = n < 0 ? [] : r.slice(n + 1), g = f ? [f] : [], h = we(l), v = we(u), m = we(d), S = we(p), x = dt(\n    h,\n    m,\n    4\n  );\n  return {\n    transforms: t,\n    beforeFunctionMatrix: h,\n    beforeFunctionMatrix2: v,\n    targetFunctionMatrix: we(g),\n    afterFunctionMatrix: m,\n    afterFunctionMatrix2: S,\n    allFunctionMatrix: x,\n    beforeFunctions: l,\n    beforeFunctions2: u,\n    targetFunction: g[0],\n    afterFunctions: d,\n    afterFunctions2: p,\n    beforeFunctionTexts: s,\n    beforeFunctionTexts2: o,\n    targetFunctionText: i,\n    afterFunctionTexts: a,\n    afterFunctionTexts2: c\n  };\n}\nfunction Eu(t) {\n  return !t || !qt(t) || ns(t) ? !1 : Rt(t) || \"length\" in t;\n}\nfunction Zt(t, e) {\n  return t ? ns(t) ? t : re(t) ? e ? document.querySelector(t) : t : Zr(t) ? t() : Jo(t) ? t : \"current\" in t ? t.current : t : null;\n}\nfunction Ss(t, e) {\n  return t ? (Eu(t) ? [].slice.call(t) : [t]).reduce((r, s) => re(s) && e ? [\n    ...r,\n    ...[].slice.call(document.querySelectorAll(s))\n  ] : (Rt(s) ? r.push(Ss(s, e)) : r.push(Zt(s, e)), r), []) : [];\n}\nfunction Cu(t, e, n) {\n  let r = xt(t, e) / Math.PI * 180;\n  return r = n >= 0 ? r : 180 - r, r = r >= 0 ? r : 360 + r, r;\n}\nfunction uo(t, e) {\n  const { rootMatrix: n, is3d: r } = t;\n  let o = Jt(n, r ? 4 : 3);\n  return r || (o = Ut(o, 3, 4)), o[12] = 0, o[13] = 0, o[14] = 0, Ac(o, e);\n}\nfunction ji(t, e, n, r, s) {\n  const [o, i] = t;\n  let a = 0, c = 0;\n  if (s && o && i) {\n    const l = xt([0, 0], e), u = xt([0, 0], r), f = Vt(e), d = Math.cos(l - u) * f;\n    if (!r[0])\n      c = d, a = c * n;\n    else if (!r[1])\n      a = d, c = a / n;\n    else {\n      const p = r[0] * o, g = r[1] * i;\n      let h = Math.atan2(\n        p + e[0],\n        g + e[1]\n      ), v = Math.atan2(p, g);\n      h < 0 && (h += Math.PI * 2), v < 0 && (v += Math.PI * 2);\n      let m = 0;\n      B(h - v) < Math.PI / 2 || B(h - v) > Math.PI / 2 * 3 || (v += Math.PI), m = h - v, m > Math.PI * 2 ? m -= Math.PI * 2 : m > Math.PI ? m = 2 * Math.PI - m : m < -Math.PI && (m = -2 * Math.PI - m);\n      const S = Vt([p + e[0], g + e[1]]) * Math.cos(m);\n      a = S * Math.sin(v) - p, c = S * Math.cos(v) - g, r[0] < 0 && (a *= -1), r[1] < 0 && (c *= -1);\n    }\n  } else\n    a = r[0] * e[0], c = r[1] * e[1];\n  return [a, c];\n}\nfunction Xi(t, e, n, r) {\n  const { ratio: s, startOffsetWidth: o, startOffsetHeight: i } = n;\n  let a = 0, c = 0;\n  const { distX: l, distY: u, pinchScale: f, parentDistance: d, parentDist: p, parentScale: g } = r, h = n.fixedDirection, v = [0, 1].map((S) => B(t[S] - h[S])), m = [0, 1].map((S) => {\n    let x = v[S];\n    return x !== 0 && (x = 2 / x), x;\n  });\n  if (p)\n    a = p[0], c = p[1], e && (a ? c || (c = a / s) : a = c * s);\n  else if (an(f))\n    a = (f - 1) * o, c = (f - 1) * i;\n  else if (g)\n    a = (g[0] - 1) * o, c = (g[1] - 1) * i;\n  else if (d) {\n    const S = o * v[0], x = i * v[1], C = Vt([S, x]);\n    a = d / C * S * m[0], c = d / C * x * m[1];\n  } else {\n    let S = Qt({ datas: n, distX: l, distY: u });\n    S = m.map((x, C) => S[C] * x), [a, c] = ji(\n      [o, i],\n      S,\n      s,\n      t,\n      e\n    );\n  }\n  return {\n    // direction,\n    // sizeDirection,\n    distWidth: a,\n    distHeight: c\n  };\n}\nfunction Gr(t, e) {\n  if (e) {\n    if (t === \"left\")\n      return { x: \"0%\", y: \"50%\" };\n    if (t === \"top\")\n      return { x: \"50%\", y: \"50%\" };\n    if (t === \"center\")\n      return { x: \"50%\", y: \"50%\" };\n    if (t === \"right\")\n      return { x: \"100%\", y: \"50%\" };\n    if (t === \"bottom\")\n      return { x: \"50%\", y: \"100%\" };\n    const [n, r] = t.split(\" \"), s = Gr(n || \"\"), o = Gr(r || \"\"), i = {\n      ...s,\n      ...o\n    }, a = {\n      x: \"50%\",\n      y: \"50%\"\n    };\n    return i.x && (a.x = i.x), i.y && (a.y = i.y), i.value && (i.x && !i.y && (a.y = i.value), !i.x && i.y && (a.x = i.value)), a;\n  }\n  return t === \"left\" ? { x: \"0%\" } : t === \"right\" ? { x: \"100%\" } : t === \"top\" ? { y: \"0%\" } : t === \"bottom\" ? { y: \"100%\" } : t ? t === \"center\" ? { value: \"50%\" } : { value: t } : {};\n}\nfunction Es(t, e, n) {\n  const { x: r, y: s } = Gr(t, !0);\n  return [ft(r, e) || 0, ft(s, n) || 0];\n}\nfunction Du(t, e, n) {\n  const r = t.map((o) => K(o, e)), s = r.map((o) => gn(o, n));\n  return {\n    prev: r,\n    next: s,\n    result: s.map((o) => at(o, e))\n  };\n}\nfunction Hi(t, e) {\n  return t.length === e.length && t.every((n, r) => {\n    const s = e[r], o = Rt(n), i = Rt(s);\n    return o && i ? Hi(n, s) : !o && !i ? n === s : !1;\n  });\n}\nfunction Ae(t, e, n, r, s) {\n  const o = t._store;\n  let i = o[e];\n  if (!(e in o))\n    if (s != null)\n      o[e] = s, i = s;\n    else\n      return o[e] = n, n;\n  return i === n || r(i) === r(n) ? i : (o[e] = n, n);\n}\nfunction wt(t) {\n  return t >= 0 ? 1 : -1;\n}\nfunction B(t) {\n  return Math.abs(t);\n}\nfunction gr(t, e) {\n  return bc(t).map((n) => e(n));\n}\nfunction qi(t) {\n  return an(t) ? {\n    top: t,\n    left: t,\n    right: t,\n    bottom: t\n  } : {\n    left: t.left || 0,\n    top: t.top || 0,\n    right: t.right || 0,\n    bottom: t.bottom || 0\n  };\n}\nconst bu = dn(\"pinchable\", {\n  props: [\n    \"pinchable\"\n  ],\n  events: [\n    \"pinchStart\",\n    \"pinch\",\n    \"pinchEnd\",\n    \"pinchGroupStart\",\n    \"pinchGroup\",\n    \"pinchGroupEnd\"\n  ],\n  dragStart() {\n    return !0;\n  },\n  pinchStart(t, e) {\n    const { datas: n, targets: r, angle: s, originalDatas: o } = e, { pinchable: i, ables: a } = t.props;\n    if (!i)\n      return !1;\n    const c = `onPinch${r ? \"Group\" : \"\"}Start`, l = `drag${r ? \"Group\" : \"\"}ControlStart`, u = (i === !0 ? t.controlAbles : a.filter((g) => i.indexOf(g.name) > -1)).filter((g) => g.canPinch && g[l]), f = et(t, e, {});\n    r && (f.targets = r);\n    const d = j(t, c, f);\n    n.isPinch = d !== !1, n.ables = u;\n    const p = n.isPinch;\n    return p ? (u.forEach((g) => {\n      if (o[g.name] = o[g.name] || {}, !g[l])\n        return;\n      const h = {\n        ...e,\n        datas: o[g.name],\n        parentRotate: s,\n        isPinch: !0\n      };\n      g[l](t, h);\n    }), t.state.snapRenderInfo = {\n      request: e.isRequest,\n      direction: [0, 0]\n    }, p) : !1;\n  },\n  pinch(t, e) {\n    const {\n      datas: n,\n      scale: r,\n      distance: s,\n      originalDatas: o,\n      inputEvent: i,\n      targets: a,\n      angle: c\n    } = e;\n    if (!n.isPinch)\n      return;\n    const l = s * (1 - 1 / r), u = et(t, e, {});\n    a && (u.targets = a), j(t, `onPinch${a ? \"Group\" : \"\"}`, u);\n    const d = n.ables, p = `drag${a ? \"Group\" : \"\"}Control`;\n    return d.forEach((g) => {\n      g[p] && g[p](t, {\n        ...e,\n        datas: o[g.name],\n        inputEvent: i,\n        resolveMatrix: !0,\n        pinchScale: r,\n        parentDistance: l,\n        parentRotate: c,\n        isPinch: !0\n      });\n    }), u;\n  },\n  pinchEnd(t, e) {\n    const { datas: n, isPinch: r, inputEvent: s, targets: o, originalDatas: i } = e;\n    if (!n.isPinch)\n      return;\n    const a = `onPinch${o ? \"Group\" : \"\"}End`, c = $t(t, e, { isDrag: r });\n    o && (c.targets = o), j(t, a, c);\n    const l = n.ables, u = `drag${o ? \"Group\" : \"\"}ControlEnd`;\n    return l.forEach((f) => {\n      f[u] && f[u](t, {\n        ...e,\n        isDrag: r,\n        datas: i[f.name],\n        inputEvent: s,\n        isPinch: !0\n      });\n    }), r;\n  },\n  pinchGroupStart(t, e) {\n    return this.pinchStart(t, { ...e, targets: t.props.targets });\n  },\n  pinchGroup(t, e) {\n    return this.pinch(t, { ...e, targets: t.props.targets });\n  },\n  pinchGroupEnd(t, e) {\n    return this.pinchEnd(t, { ...e, targets: t.props.targets });\n  }\n}), fo = xs(\"scalable\"), yu = {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: [\n    \"scalable\",\n    \"throttleScale\",\n    \"renderDirections\",\n    \"keepRatio\",\n    \"edge\",\n    \"displayAroundControls\"\n  ],\n  events: [\n    \"scaleStart\",\n    \"beforeScale\",\n    \"scale\",\n    \"scaleEnd\",\n    \"scaleGroupStart\",\n    \"beforeScaleGroup\",\n    \"scaleGroup\",\n    \"scaleGroupEnd\"\n  ],\n  render: di(\"scalable\"),\n  dragControlCondition: fo,\n  viewClassName: ms(\"scalable\"),\n  dragControlStart(t, e) {\n    const { datas: n, isPinch: r, inputEvent: s, parentDirection: o } = e, i = Li(\n      o,\n      r,\n      s,\n      n\n    ), { width: a, height: c, targetTransform: l, target: u, pos1: f, pos2: d, pos4: p } = t.state;\n    if (!i || !u)\n      return !1;\n    r || Re(t, e), n.datas = {}, n.transform = l, n.prevDist = [1, 1], n.direction = i, n.startOffsetWidth = a, n.startOffsetHeight = c, n.startValue = [1, 1];\n    const g = !i[0] && !i[1] || i[0] || !i[1];\n    qn(t, e, \"scale\"), n.isWidth = g;\n    function h(E) {\n      n.ratio = E && isFinite(E) ? E : 0;\n    }\n    n.startPositions = jt(t.state);\n    function v(E) {\n      const D = yi(\n        n.startPositions,\n        E\n      );\n      n.fixedDirection = D.fixedDirection, n.fixedPosition = D.fixedPosition, n.fixedOffset = D.fixedOffset;\n    }\n    n.setFixedDirection = v, h(te(f, d) / te(d, p)), v([-i[0], -i[1]]);\n    const m = (E) => {\n      n.minScaleSize = E;\n    }, S = (E) => {\n      n.maxScaleSize = E;\n    };\n    m([-1 / 0, -1 / 0]), S([1 / 0, 1 / 0]);\n    const x = et(t, e, {\n      direction: i,\n      set: (E) => {\n        n.startValue = E;\n      },\n      setRatio: h,\n      setFixedDirection: v,\n      setMinScaleSize: m,\n      setMaxScaleSize: S,\n      ...Hn(t, e),\n      dragStart: Ot.dragStart(\n        t,\n        new Fe().dragStart([0, 0], e)\n      )\n    }), C = j(t, \"onScaleStart\", x);\n    return n.startFixedDirection = n.fixedDirection, C !== !1 && (n.isScale = !0, t.state.snapRenderInfo = {\n      request: e.isRequest,\n      direction: i\n    }), n.isScale ? x : !1;\n  },\n  dragControl(t, e) {\n    jn(t, e, \"scale\");\n    const {\n      datas: n,\n      parentKeepRatio: r,\n      parentFlag: s,\n      isPinch: o,\n      dragClient: i,\n      isRequest: a,\n      useSnap: c,\n      resolveMatrix: l\n    } = e, {\n      prevDist: u,\n      direction: f,\n      startOffsetWidth: d,\n      startOffsetHeight: p,\n      isScale: g,\n      startValue: h,\n      isWidth: v,\n      ratio: m\n    } = n;\n    if (!g)\n      return !1;\n    const S = t.props, { throttleScale: x, parentMoveable: C } = S;\n    let E = f;\n    !f[0] && !f[1] && (E = [1, 1]);\n    const D = m && (r ?? S.keepRatio) || !1, R = t.state, y = [h[0], h[1]];\n    function M() {\n      const { distWidth: q, distHeight: F } = Xi(\n        E,\n        D,\n        n,\n        e\n      ), H = d ? (d + q) / d : 1, nt = p ? (p + F) / p : 1;\n      h[0] || (y[0] = q / d), h[1] || (y[1] = F / p);\n      let lt = (E[0] || D ? H : 1) * y[0], vt = (E[1] || D ? nt : 1) * y[1];\n      return lt === 0 && (lt = wt(u[0]) * Sn), vt === 0 && (vt = wt(u[1]) * Sn), [lt, vt];\n    }\n    let P = M();\n    if (!o && t.props.groupable) {\n      const F = (R.snapRenderInfo || {}).direction;\n      Rt(F) && (F[0] || F[1]) && (R.snapRenderInfo = { direction: f, request: e.isRequest });\n    }\n    j(\n      t,\n      \"onBeforeScale\",\n      et(\n        t,\n        e,\n        {\n          scale: P,\n          setFixedDirection(q) {\n            return n.setFixedDirection(q), P = M(), P;\n          },\n          startFixedDirection: n.startFixedDirection,\n          setScale(q) {\n            P = q;\n          }\n        },\n        !0\n      )\n    );\n    let _ = [P[0] / y[0], P[1] / y[1]], O = i, T = [0, 0];\n    const w = wt(_[0] * _[1]), k = !i && !s && o;\n    if (k || l ? O = is(\n      t,\n      n.targetAllTransform,\n      [0, 0],\n      [0, 0],\n      n\n    ) : i || (O = n.fixedPosition), o || (T = eu(\n      t,\n      _,\n      f,\n      !c && a,\n      n\n    )), D) {\n      E[0] && E[1] && T[0] && T[1] && (Math.abs(T[0] * d) > Math.abs(T[1] * p) ? T[1] = 0 : T[0] = 0);\n      const q = !T[0] && !T[1];\n      if (q && (v ? _[0] = tt(_[0] * y[0], x) / y[0] : _[1] = tt(_[1] * y[1], x) / y[1]), E[0] && !E[1] || T[0] && !T[1] || q && v) {\n        _[0] += T[0];\n        const F = d * _[0] * y[0] / m;\n        _[1] = wt(w * _[0]) * B(F / p / y[1]);\n      } else if (!E[0] && E[1] || !T[0] && T[1] || q && !v) {\n        _[1] += T[1];\n        const F = p * _[1] * y[1] * m;\n        _[0] = wt(w * _[1]) * B(F / d / y[0]);\n      }\n    } else\n      _[0] += T[0], _[1] += T[1], T[0] || (_[0] = tt(_[0] * y[0], x) / y[0]), T[1] || (_[1] = tt(_[1] * y[1], x) / y[1]);\n    _[0] === 0 && (_[0] = wt(u[0]) * Sn), _[1] === 0 && (_[1] = wt(u[1]) * Sn), P = ou(_, [y[0], y[1]]);\n    const I = [d, p];\n    let $ = [d * P[0], p * P[1]];\n    $ = qo(\n      $,\n      n.minScaleSize,\n      n.maxScaleSize,\n      D ? m : !1\n    ), P = gr(2, (q) => I[q] ? $[q] / I[q] : $[q]), _ = gr(2, (q) => P[q] / y[q]);\n    const G = gr(\n      2,\n      (q) => u[q] ? _[q] / u[q] : _[q]\n    ), L = `scale(${_.join(\", \")})`, z = `scale(${P.join(\", \")})`, N = Xn(n, z, L), Z = !h[0] || !h[1], Y = Vc(\n      t,\n      Z ? z : L,\n      n.fixedDirection,\n      O,\n      n.fixedOffset,\n      n,\n      Z\n    ), W = k ? Y : K(Y, n.prevInverseDist || [0, 0]);\n    if (n.prevDist = _, n.prevInverseDist = Y, P[0] === u[0] && P[1] === u[1] && W.every((q) => !q) && !C && !k)\n      return !1;\n    const J = et(t, e, {\n      offsetWidth: d,\n      offsetHeight: p,\n      direction: f,\n      scale: P,\n      dist: _,\n      delta: G,\n      isPinch: !!o,\n      ...ii(t, N, W, o, e)\n    });\n    return j(t, \"onScale\", J), J;\n  },\n  dragControlEnd(t, e) {\n    const { datas: n } = e;\n    if (!n.isScale)\n      return !1;\n    n.isScale = !1;\n    const r = $t(t, e, {});\n    return j(t, \"onScaleEnd\", r), r;\n  },\n  dragGroupControlCondition: fo,\n  dragGroupControlStart(t, e) {\n    const { datas: n } = e, r = this.dragControlStart(t, e);\n    if (!r)\n      return !1;\n    const s = Ht(t, \"resizable\", e);\n    n.moveableScale = t.scale;\n    const o = ee(\n      t,\n      this,\n      \"dragControlStart\",\n      e,\n      (l, u) => kn(t, l, n, u)\n    ), i = (l) => {\n      r.setFixedDirection(l), o.forEach((u, f) => {\n        u.setFixedDirection(l), kn(t, u.moveable, n, s[f]);\n      });\n    };\n    n.setFixedDirection = i;\n    const a = {\n      ...r,\n      targets: t.props.targets,\n      events: o,\n      setFixedDirection: i\n    }, c = j(t, \"onScaleGroupStart\", a);\n    return n.isScale = c !== !1, n.isScale ? a : !1;\n  },\n  dragGroupControl(t, e) {\n    const { datas: n } = e;\n    if (!n.isScale)\n      return;\n    Qn(t, \"onBeforeScale\", (u) => {\n      j(\n        t,\n        \"onBeforeScaleGroup\",\n        et(\n          t,\n          e,\n          {\n            ...u,\n            targets: t.props.targets\n          },\n          !0\n        )\n      );\n    });\n    const r = this.dragControl(t, e);\n    if (!r)\n      return;\n    const { dist: s } = r, o = n.moveableScale;\n    t.scale = [s[0] * o[0], s[1] * o[1]];\n    const i = t.props.keepRatio, a = n.fixedPosition, c = ee(\n      t,\n      this,\n      \"dragControl\",\n      e,\n      (u, f) => {\n        const [d, p] = _t(\n          hn(t.rotation / 180 * Math.PI, 3),\n          [f.datas.originalX * s[0], f.datas.originalY * s[1], 1],\n          3\n        );\n        return {\n          ...f,\n          parentDist: null,\n          parentScale: s,\n          parentKeepRatio: i,\n          // recalculate child fixed position for parent group's dragging.\n          dragClient: at(a, [d, p])\n        };\n      }\n    ), l = {\n      targets: t.props.targets,\n      events: c,\n      ...r\n    };\n    return j(t, \"onScaleGroup\", l), l;\n  },\n  dragGroupControlEnd(t, e) {\n    const { isDrag: n, datas: r } = e;\n    if (!r.isScale)\n      return;\n    this.dragControlEnd(t, e);\n    const s = ee(t, this, \"dragControlEnd\", e), o = $t(t, e, {\n      targets: t.props.targets,\n      events: s\n    });\n    return j(t, \"onScaleGroupEnd\", o), n;\n  },\n  /**\n       * @method Moveable.Scalable#request\n       * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter\n       * @return {Moveable.Requester} Moveable Requester\n       * @example\n  \n       * // Instantly Request (requestStart - request - requestEnd)\n       * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n       *\n       * // requestStart\n       * const requester = moveable.request(\"scalable\");\n       *\n       * // request\n       * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n       * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n       * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n       *\n       * // requestEnd\n       * requester.requestEnd();\n       */\n  request() {\n    const t = {};\n    let e = 0, n = 0, r = !1;\n    return {\n      isControl: !0,\n      requestStart(s) {\n        return r = s.useSnap, {\n          datas: t,\n          parentDirection: s.direction || [1, 1],\n          useSnap: r\n        };\n      },\n      request(s) {\n        return e += s.deltaWidth, n += s.deltaHeight, {\n          datas: t,\n          parentDist: [e, n],\n          parentKeepRatio: s.keepRatio,\n          useSnap: r\n        };\n      },\n      requestEnd() {\n        return { datas: t, isDrag: !0, useSnap: r };\n      }\n    };\n  }\n};\nfunction se(t, e) {\n  return t.map((n, r) => zn(n, e[r], 1, 2));\n}\nfunction po(t, e, n) {\n  const r = xt(t, e), o = xt(t, n) - r;\n  return o >= 0 ? o : o + 2 * Math.PI;\n}\nfunction Ru(t, e) {\n  const n = po(t[0], t[1], t[2]), r = po(e[0], e[1], e[2]), s = Math.PI;\n  return !(n >= s && r <= s || n <= s && r >= s);\n}\nconst Mu = {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: [\n    \"warpable\",\n    \"renderDirections\",\n    \"edge\",\n    \"displayAroundControls\"\n  ],\n  events: [\"warpStart\", \"warp\", \"warpEnd\"],\n  viewClassName: ms(\"warpable\"),\n  render(t, e) {\n    const { resizable: n, scalable: r, warpable: s, zoom: o } = t.props;\n    if (n || r || !s)\n      return [];\n    const { pos1: i, pos2: a, pos3: c, pos4: l } = t.state, u = se(i, a), f = se(a, i), d = se(i, c), p = se(c, i), g = se(c, l), h = se(l, c), v = se(a, l), m = se(l, a);\n    return [\n      /* @__PURE__ */ it.jsx(\n        \"div\",\n        {\n          className: U(\"line\"),\n          style: Je(u, g, o)\n        },\n        \"middeLine1\"\n      ),\n      /* @__PURE__ */ it.jsx(\n        \"div\",\n        {\n          className: U(\"line\"),\n          style: Je(f, h, o)\n        },\n        \"middeLine2\"\n      ),\n      /* @__PURE__ */ it.jsx(\n        \"div\",\n        {\n          className: U(\"line\"),\n          style: Je(d, v, o)\n        },\n        \"middeLine3\"\n      ),\n      /* @__PURE__ */ it.jsx(\n        \"div\",\n        {\n          className: U(\"line\"),\n          style: Je(p, m, o)\n        },\n        \"middeLine4\"\n      ),\n      ...pi(t, \"warpable\", e)\n    ];\n  },\n  dragControlCondition(t, e) {\n    if (e.isRequest)\n      return !1;\n    const n = e.inputEvent.target;\n    return bt(n, U(\"direction\")) && bt(n, U(\"warpable\"));\n  },\n  dragControlStart(t, e) {\n    const { datas: n, inputEvent: r } = e, { target: s } = t.props, { target: o } = r, i = Ni(o, n);\n    if (!i || !s)\n      return !1;\n    const a = t.state, {\n      transformOrigin: c,\n      is3d: l,\n      targetTransform: u,\n      targetMatrix: f,\n      width: d,\n      height: p,\n      left: g,\n      top: h\n    } = a;\n    n.datas = {}, n.targetTransform = u, n.warpTargetMatrix = l ? f : Ut(f, 3, 4), n.targetInverseMatrix = Qo(\n      Jt(n.warpTargetMatrix, 4),\n      3,\n      4\n    ), n.direction = i, n.left = g, n.top = h, n.poses = [\n      [0, 0],\n      [d, 0],\n      [0, p],\n      [d, p]\n    ].map((S) => K(S, c)), n.nextPoses = n.poses.map(\n      ([S, x]) => _t(n.warpTargetMatrix, [S, x, 0, 1], 4)\n    ), n.startValue = gt(4), n.prevMatrix = gt(4), n.absolutePoses = jt(a), n.posIndexes = oi(i), Re(t, e), qn(t, e, \"matrix3d\"), a.snapRenderInfo = {\n      request: e.isRequest,\n      direction: i\n    };\n    const v = et(t, e, {\n      set: (S) => {\n        n.startValue = S;\n      },\n      ...Hn(t, e)\n    });\n    return j(t, \"onWarpStart\", v) !== !1 && (n.isWarp = !0), n.isWarp;\n  },\n  dragControl(t, e) {\n    const { datas: n, isRequest: r } = e;\n    let { distX: s, distY: o } = e;\n    const {\n      targetInverseMatrix: i,\n      prevMatrix: a,\n      isWarp: c,\n      startValue: l,\n      poses: u,\n      posIndexes: f,\n      absolutePoses: d\n    } = n;\n    if (!c)\n      return !1;\n    if (jn(t, e, \"matrix3d\"), Xe(t, \"warpable\")) {\n      const E = f.map(\n        (y) => d[y]\n      );\n      E.length > 1 && E.push([\n        (E[0][0] + E[1][0]) / 2,\n        (E[0][1] + E[1][1]) / 2\n      ]);\n      const { horizontal: D, vertical: R } = Zn(t, r, {\n        horizontal: E.map((y) => y[1] + o),\n        vertical: E.map((y) => y[0] + s)\n      });\n      o -= D.offset, s -= R.offset;\n    }\n    const p = Qt({ datas: n, distX: s, distY: o }, !0), g = n.nextPoses.slice();\n    if (f.forEach((E) => {\n      g[E] = at(g[E], p);\n    }), !ic.every(\n      (E) => Ru(\n        E.map((D) => u[D]),\n        E.map((D) => g[D])\n      )\n    ))\n      return !1;\n    const h = ss(\n      u[0],\n      u[2],\n      u[1],\n      u[3],\n      g[0],\n      g[2],\n      g[1],\n      g[3]\n    );\n    if (!h.length)\n      return !1;\n    const v = dt(i, h, 4), m = ri(n, v, !0), S = dt(Jt(a, 4), m, 4);\n    n.prevMatrix = m;\n    const x = dt(l, m, 4), C = Xn(\n      n,\n      `matrix3d(${x.join(\", \")})`,\n      `matrix3d(${m.join(\", \")})`\n    );\n    return os(e, C), j(\n      t,\n      \"onWarp\",\n      et(t, e, {\n        delta: S,\n        matrix: x,\n        dist: m,\n        multiply: dt,\n        transform: C,\n        ...It(\n          {\n            transform: C\n          },\n          e\n        )\n      })\n    ), !0;\n  },\n  dragControlEnd(t, e) {\n    const { datas: n, isDrag: r } = e;\n    return n.isWarp ? (n.isWarp = !1, j(\n      t,\n      \"onWarpEnd\",\n      $t(t, e, {})\n    ), r) : !1;\n  }\n}, Pu = /* @__PURE__ */ U(\"area-pieces\"), Pn = /* @__PURE__ */ U(\"area-piece\"), Ui = /* @__PURE__ */ U(\"avoid\"), _u = U(\"view-dragging\");\nfunction hr(t) {\n  const e = t.areaElement;\n  if (!e)\n    return;\n  const { width: n, height: r } = t.state;\n  Zo(e, Ui), e.style.cssText += `left: 0px; top: 0px; width: ${n}px; height: ${r}px`;\n}\nfunction go(t) {\n  return /* @__PURE__ */ it.jsxs(\"div\", { className: Pu, children: [\n    /* @__PURE__ */ it.jsx(\"div\", { className: Pn }),\n    /* @__PURE__ */ it.jsx(\"div\", { className: Pn }),\n    /* @__PURE__ */ it.jsx(\"div\", { className: Pn }),\n    /* @__PURE__ */ it.jsx(\"div\", { className: Pn })\n  ] }, \"area_pieces\");\n}\nconst Ki = {\n  name: \"dragArea\",\n  props: [\"dragArea\", \"passDragArea\"],\n  events: [\"click\", \"clickGroup\"],\n  render(t, e) {\n    const { target: n, dragArea: r, groupable: s, passDragArea: o } = t.props, { width: i, height: a, renderPoses: c } = t.getState(), l = o ? U(\"area\", \"pass\") : U(\"area\");\n    if (s)\n      return [\n        /* @__PURE__ */ it.jsx(\n          \"div\",\n          {\n            ref: Se(t, \"areaElement\"),\n            className: l\n          },\n          \"area\"\n        ),\n        go()\n      ];\n    if (!n || !r)\n      return [];\n    const u = ss(\n      [0, 0],\n      [i, 0],\n      [0, a],\n      [i, a],\n      c[0],\n      c[1],\n      c[2],\n      c[3]\n    ), f = u.length ? Jn(u, !0) : \"none\";\n    return [\n      /* @__PURE__ */ it.jsx(\n        \"div\",\n        {\n          ref: Se(t, \"areaElement\"),\n          className: l,\n          style: {\n            top: \"0px\",\n            left: \"0px\",\n            width: `${i}px`,\n            height: `${a}px`,\n            transformOrigin: \"0 0\",\n            transform: f\n          }\n        },\n        \"area\"\n      ),\n      go()\n    ];\n  },\n  dragStart(t, { datas: e, clientX: n, clientY: r, inputEvent: s }) {\n    if (!s)\n      return !1;\n    e.isDragArea = !1;\n    const o = t.areaElement, i = t.state, { moveableClientRect: a, renderPoses: c, rootMatrix: l, is3d: u } = i, { left: f, top: d } = a, {\n      left: p,\n      top: g,\n      width: h,\n      height: v\n    } = Yt(c), m = u ? 4 : 3;\n    let [S, x] = We(\n      l,\n      [n - f, r - d],\n      m\n    );\n    S -= p, x -= g;\n    const C = [\n      { left: p, top: g, width: h, height: x - 10 },\n      { left: p, top: g, width: S - 10, height: v },\n      {\n        left: p,\n        top: g + x + 10,\n        width: h,\n        height: v - x - 10\n      },\n      {\n        left: p + S + 10,\n        top: g,\n        width: h - S - 10,\n        height: v\n      }\n    ], E = [].slice.call(\n      o.nextElementSibling.children\n    );\n    C.forEach((D, R) => {\n      E[R].style.cssText = `left: ${D.left}px;top: ${D.top}px; width: ${D.width}px; height: ${D.height}px;`;\n    }), Ko(o, Ui), i.disableNativeEvent = !0;\n  },\n  drag(t, { datas: e, inputEvent: n }) {\n    if (this.enableNativeEvent(t), !n)\n      return !1;\n    e.isDragArea || (e.isDragArea = !0, hr(t));\n  },\n  dragEnd(t, e) {\n    this.enableNativeEvent(t);\n    const { inputEvent: n, datas: r } = e;\n    if (!n)\n      return !1;\n    r.isDragArea || hr(t);\n  },\n  dragGroupStart(t, e) {\n    return this.dragStart(t, e);\n  },\n  dragGroup(t, e) {\n    return this.drag(t, e);\n  },\n  dragGroupEnd(t, e) {\n    return this.dragEnd(t, e);\n  },\n  unset(t) {\n    hr(t), t.state.disableNativeEvent = !1;\n  },\n  enableNativeEvent(t) {\n    const e = t.state;\n    e.disableNativeEvent && Ho(() => {\n      e.disableNativeEvent = !1;\n    });\n  }\n}, Tu = dn(\"origin\", {\n  props: [\"origin\", \"svgOrigin\"],\n  render(t, e) {\n    const { zoom: n, svgOrigin: r, groupable: s } = t.props, {\n      beforeOrigin: o,\n      rotation: i,\n      svg: a,\n      allMatrix: c,\n      is3d: l,\n      left: u,\n      top: f,\n      offsetWidth: d,\n      offsetHeight: p\n    } = t.getState();\n    let g;\n    if (!s && a && r) {\n      const [h, v] = Es(r, d, p), S = ht(\n        c,\n        [h, v],\n        l ? 4 : 3\n      );\n      g = Nn(i, n, K(S, [u, f]));\n    } else\n      g = Nn(i, n, o);\n    return [\n      /* @__PURE__ */ it.jsx(\"div\", { className: U(\"control\", \"origin\"), style: g }, \"beforeOrigin\")\n    ];\n  }\n});\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar kr = function() {\n  return kr = Object.assign || function(e) {\n    for (var n, r = 1, s = arguments.length; r < s; r++) {\n      n = arguments[r];\n      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);\n    }\n    return e;\n  }, kr.apply(this, arguments);\n};\nfunction Ou() {\n  for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;\n  for (var r = Array(t), s = 0, e = 0; e < n; e++) for (var o = arguments[e], i = 0, a = o.length; i < a; i++, s++) r[s] = o[i];\n  return r;\n}\nvar Cs = /* @__PURE__ */ function() {\n  function t() {\n    this._events = {};\n  }\n  var e = t.prototype;\n  return e.on = function(n, r) {\n    if (qt(n))\n      for (var s in n)\n        this.on(s, n[s]);\n    else\n      this._addEvent(n, r, {});\n    return this;\n  }, e.off = function(n, r) {\n    if (!n)\n      this._events = {};\n    else if (qt(n))\n      for (var s in n)\n        this.off(s);\n    else if (!r)\n      this._events[n] = [];\n    else {\n      var o = this._events[n];\n      if (o) {\n        var i = ne(o, function(a) {\n          return a.listener === r;\n        });\n        i > -1 && o.splice(i, 1);\n      }\n    }\n    return this;\n  }, e.once = function(n, r) {\n    var s = this;\n    return r && this._addEvent(n, r, {\n      once: !0\n    }), new Promise(function(o) {\n      s._addEvent(n, o, {\n        once: !0\n      });\n    });\n  }, e.emit = function(n, r) {\n    var s = this;\n    r === void 0 && (r = {});\n    var o = this._events[n];\n    if (!n || !o)\n      return !0;\n    var i = !1;\n    return r.eventType = n, r.stop = function() {\n      i = !0;\n    }, r.currentTarget = this, Ou(o).forEach(function(a) {\n      a.listener(r), a.once && s.off(n, a.listener);\n    }), !i;\n  }, e.trigger = function(n, r) {\n    return r === void 0 && (r = {}), this.emit(n, r);\n  }, e._addEvent = function(n, r, s) {\n    var o = this._events;\n    o[n] = o[n] || [];\n    var i = o[n];\n    i.push(kr({\n      listener: r\n    }, s));\n  }, t;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar $r = function(t, e) {\n  return $r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(n, r) {\n    n.__proto__ = r;\n  } || function(n, r) {\n    for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);\n  }, $r(t, e);\n};\nfunction wu(t, e) {\n  $r(t, e);\n  function n() {\n    this.constructor = t;\n  }\n  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());\n}\nvar Ge = function() {\n  return Ge = Object.assign || function(e) {\n    for (var n, r = 1, s = arguments.length; r < s; r++) {\n      n = arguments[r];\n      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);\n    }\n    return e;\n  }, Ge.apply(this, arguments);\n};\nfunction Iu(t) {\n  var e = t.container;\n  return e === document.body ? [e.scrollLeft || document.documentElement.scrollLeft, e.scrollTop || document.documentElement.scrollTop] : [e.scrollLeft, e.scrollTop];\n}\nfunction ho(t, e) {\n  return t.addEventListener(\"scroll\", e), function() {\n    t.removeEventListener(\"scroll\", e);\n  };\n}\nfunction _n(t) {\n  if (t) {\n    if (re(t))\n      return document.querySelector(t);\n  } else return null;\n  if (Zr(t))\n    return t();\n  if (t instanceof Element)\n    return t;\n  if (\"current\" in t)\n    return t.current;\n  if (\"value\" in t)\n    return t.value;\n}\nvar Bu = /* @__PURE__ */ function(t) {\n  wu(e, t);\n  function e() {\n    var r = t !== null && t.apply(this, arguments) || this;\n    return r._startRect = null, r._startPos = [], r._prevTime = 0, r._timer = 0, r._prevScrollPos = [0, 0], r._isWait = !1, r._flag = !1, r._currentOptions = null, r._lock = !1, r._unregister = null, r._onScroll = function() {\n      var s = r._currentOptions;\n      r._lock || !s || r.emit(\"scrollDrag\", {\n        next: function(o) {\n          r.checkScroll({\n            container: s.container,\n            inputEvent: o\n          });\n        }\n      });\n    }, r;\n  }\n  var n = e.prototype;\n  return n.dragStart = function(r, s) {\n    var o = _n(s.container);\n    if (!o) {\n      this._flag = !1;\n      return;\n    }\n    var i = 0, a = 0, c = 0, l = 0;\n    if (o === document.body)\n      c = window.innerWidth, l = window.innerHeight;\n    else {\n      var u = o.getBoundingClientRect();\n      i = u.top, a = u.left, c = u.width, l = u.height;\n    }\n    this._flag = !0, this._startPos = [r.clientX, r.clientY], this._startRect = {\n      top: i,\n      left: a,\n      width: c,\n      height: l\n    }, this._prevScrollPos = this._getScrollPosition([0, 0], s), this._currentOptions = s, this._registerScrollEvent(s);\n  }, n.drag = function(r, s) {\n    if (clearTimeout(this._timer), !!this._flag) {\n      var o = r.clientX, i = r.clientY, a = s.threshold, c = a === void 0 ? 0 : a, l = this, u = l._startRect, f = l._startPos;\n      this._currentOptions = s;\n      var d = [0, 0];\n      return u.top > i - c ? (f[1] > u.top || i < f[1]) && (d[1] = -1) : u.top + u.height < i + c && (f[1] < u.top + u.height || i > f[1]) && (d[1] = 1), u.left > o - c ? (f[0] > u.left || o < f[0]) && (d[0] = -1) : u.left + u.width < o + c && (f[0] < u.left + u.width || o > f[0]) && (d[0] = 1), !d[0] && !d[1] ? !1 : this._continueDrag(Ge(Ge({}, s), {\n        direction: d,\n        inputEvent: r,\n        isDrag: !0\n      }));\n    }\n  }, n.checkScroll = function(r) {\n    var s = this;\n    if (this._isWait)\n      return !1;\n    var o = r.prevScrollPos, i = o === void 0 ? this._prevScrollPos : o, a = r.direction, c = r.throttleTime, l = c === void 0 ? 0 : c, u = r.inputEvent, f = r.isDrag, d = this._getScrollPosition(a || [0, 0], r), p = d[0] - i[0], g = d[1] - i[1], h = a || [p ? Math.abs(p) / p : 0, g ? Math.abs(g) / g : 0];\n    return this._prevScrollPos = d, this._lock = !1, !p && !g ? !1 : (this.emit(\"move\", {\n      offsetX: h[0] ? p : 0,\n      offsetY: h[1] ? g : 0,\n      inputEvent: u\n    }), l && f && (clearTimeout(this._timer), this._timer = window.setTimeout(function() {\n      s._continueDrag(r);\n    }, l)), !0);\n  }, n.dragEnd = function() {\n    this._flag = !1, this._lock = !1, clearTimeout(this._timer), this._unregisterScrollEvent();\n  }, n._getScrollPosition = function(r, s) {\n    var o = s.container, i = s.getScrollPosition, a = i === void 0 ? Iu : i;\n    return a({\n      container: _n(o),\n      direction: r\n    });\n  }, n._continueDrag = function(r) {\n    var s = this, o, i = r.container, a = r.direction, c = r.throttleTime, l = r.useScroll, u = r.isDrag, f = r.inputEvent;\n    if (!(!this._flag || u && this._isWait)) {\n      var d = cn(), p = Math.max(c + this._prevTime - d, 0);\n      if (p > 0)\n        return clearTimeout(this._timer), this._timer = window.setTimeout(function() {\n          s._continueDrag(r);\n        }, p), !1;\n      this._prevTime = d;\n      var g = this._getScrollPosition(a, r);\n      this._prevScrollPos = g, u && (this._isWait = !0), l || (this._lock = !0);\n      var h = {\n        container: _n(i),\n        direction: a,\n        inputEvent: f\n      };\n      return (o = r.requestScroll) === null || o === void 0 || o.call(r, h), this.emit(\"scroll\", h), this._isWait = !1, l || this.checkScroll(Ge(Ge({}, r), {\n        prevScrollPos: g,\n        direction: a,\n        inputEvent: f\n      }));\n    }\n  }, n._registerScrollEvent = function(r) {\n    this._unregisterScrollEvent();\n    var s = r.checkScrollEvent;\n    if (s) {\n      var o = s === !0 ? ho : s, i = _n(r.container);\n      s === !0 && (i === document.body || i === document.documentElement) ? this._unregister = ho(window, this._onScroll) : this._unregister = o(i, this._onScroll);\n    }\n  }, n._unregisterScrollEvent = function() {\n    var r;\n    (r = this._unregister) === null || r === void 0 || r.call(this), this._unregister = null;\n  }, e;\n}(Cs);\nfunction zu(t) {\n  const e = t.scrollContainer;\n  return [\n    e.scrollLeft,\n    e.scrollTop\n  ];\n}\nconst Au = {\n  name: \"scrollable\",\n  canPinch: !0,\n  props: [\n    \"scrollable\",\n    \"scrollContainer\",\n    \"scrollThreshold\",\n    \"scrollThrottleTime\",\n    \"getScrollPosition\",\n    \"scrollOptions\"\n  ],\n  events: [\n    \"scroll\",\n    \"scrollGroup\"\n  ],\n  dragRelation: \"strong\",\n  dragStart(t, e) {\n    const n = t.props, {\n      scrollContainer: r = t.getContainer(),\n      scrollOptions: s\n    } = n, o = new Bu(), i = Zt(r, !0);\n    e.datas.dragScroll = o, t.state.dragScroll = o;\n    const a = e.isControl ? \"controlGesto\" : \"targetGesto\", c = e.targets;\n    o.on(\"scroll\", ({ container: l, direction: u }) => {\n      const f = et(t, e, {\n        scrollContainer: l,\n        direction: u\n      }), d = c ? \"onScrollGroup\" : \"onScroll\";\n      c && (f.targets = c), j(t, d, f);\n    }).on(\"move\", ({ offsetX: l, offsetY: u, inputEvent: f }) => {\n      t[a].scrollBy(l, u, f.inputEvent, !1);\n    }).on(\"scrollDrag\", ({ next: l }) => {\n      l(t[a].getCurrentEvent());\n    }), o.dragStart(e, {\n      container: i,\n      ...s\n    });\n  },\n  checkScroll(t, e) {\n    const n = e.datas.dragScroll;\n    if (!n)\n      return;\n    const {\n      scrollContainer: r = t.getContainer(),\n      scrollThreshold: s = 0,\n      scrollThrottleTime: o = 0,\n      getScrollPosition: i = zu,\n      scrollOptions: a\n    } = t.props;\n    return n.drag(e, {\n      container: r,\n      threshold: s,\n      throttleTime: o,\n      getScrollPosition: (c) => i({ scrollContainer: c.container, direction: c.direction }),\n      ...a\n    }), !0;\n  },\n  drag(t, e) {\n    return this.checkScroll(t, e);\n  },\n  dragEnd(t, e) {\n    e.datas.dragScroll.dragEnd(), e.datas.dragScroll = null;\n  },\n  dragControlStart(t, e) {\n    return this.dragStart(t, { ...e, isControl: !0 });\n  },\n  dragControl(t, e) {\n    return this.drag(t, e);\n  },\n  dragControlEnd(t, e) {\n    return this.dragEnd(t, e);\n  },\n  dragGroupStart(t, e) {\n    return this.dragStart(t, { ...e, targets: t.props.targets });\n  },\n  dragGroup(t, e) {\n    return this.drag(t, { ...e, targets: t.props.targets });\n  },\n  dragGroupEnd(t, e) {\n    return this.dragEnd(t, { ...e, targets: t.props.targets });\n  },\n  dragGroupControlStart(t, e) {\n    return this.dragStart(t, { ...e, targets: t.props.targets, isControl: !0 });\n  },\n  dragGroupControl(t, e) {\n    return this.drag(t, { ...e, targets: t.props.targets });\n  },\n  dragGroupControEnd(t, e) {\n    return this.dragEnd(t, { ...e, targets: t.props.targets });\n  },\n  unset(t) {\n    var n;\n    const e = t.state;\n    (n = e.dragScroll) == null || n.dragEnd(), e.dragScroll = null;\n  }\n}, Zi = {\n  name: \"\",\n  props: [\n    \"target\",\n    \"dragTargetSelf\",\n    \"dragTarget\",\n    \"dragContainer\",\n    \"container\",\n    \"warpSelf\",\n    \"rootContainer\",\n    \"useResizeObserver\",\n    \"useMutationObserver\",\n    \"zoom\",\n    \"dragFocusedInput\",\n    \"transformOrigin\",\n    \"ables\",\n    \"className\",\n    \"pinchThreshold\",\n    \"pinchOutside\",\n    \"triggerAblesSimultaneously\",\n    \"checkInput\",\n    \"cspNonce\",\n    \"translateZ\",\n    \"hideDefaultLines\",\n    \"props\",\n    \"flushSync\",\n    \"stopPropagation\",\n    \"preventClickEventOnDrag\",\n    \"preventClickDefault\",\n    \"viewContainer\",\n    \"persistData\",\n    \"useAccuratePosition\",\n    \"firstRenderState\",\n    \"linePadding\",\n    \"controlPadding\",\n    \"preventDefault\",\n    \"preventRightClick\",\n    \"preventWheelClick\",\n    \"requestStyles\"\n  ],\n  events: [\n    \"changeTargets\"\n  ]\n}, Gu = dn(\"padding\", {\n  props: [\"padding\"],\n  render(t, e) {\n    const n = t.props;\n    if (n.dragArea)\n      return [];\n    const {\n      left: r,\n      top: s,\n      right: o,\n      bottom: i\n    } = qi(n.padding || {}), {\n      renderPoses: a,\n      pos1: c,\n      pos2: l,\n      pos3: u,\n      pos4: f\n    } = t.getState(), d = [c, l, u, f], p = [];\n    return r > 0 && p.push([0, 2]), s > 0 && p.push([0, 1]), o > 0 && p.push([1, 3]), i > 0 && p.push([2, 3]), p.map(([g, h], v) => {\n      const m = d[g], S = d[h], x = a[g], C = a[h], E = ss(\n        [0, 0],\n        [100, 0],\n        [0, 100],\n        [100, 100],\n        m,\n        S,\n        x,\n        C\n      );\n      if (E.length)\n        return /* @__PURE__ */ it.jsx(\"div\", { className: U(\"padding\"), style: {\n          transform: Jn(E, !0)\n        } }, `padding${v}`);\n    });\n  }\n}), vo = [\"nw\", \"ne\", \"se\", \"sw\"];\nfunction Tn(t, e) {\n  const n = t[0] + t[1], r = n > e ? e / n : 1;\n  return t[0] *= r, t[1] = e - t[1] * r, t;\n}\nconst ku = [1, 2, 5, 6], $u = [0, 3, 4, 7], ve = [1, -1, -1, 1], me = [1, 1, -1, -1];\nfunction Ds(t, e, n, r, s = 0, o = 0, i = n, a = r) {\n  const c = [];\n  let l = !1;\n  const u = t.filter((d) => !d.virtual), f = u.map((d) => {\n    const { horizontal: p, vertical: g, pos: h } = d;\n    if (g && !l && (l = !0, c.push(\"/\")), l) {\n      const v = Math.max(0, g === 1 ? h[1] - o : a - h[1]);\n      return c.push(Xt(v, r, e)), v;\n    } else {\n      const v = Math.max(0, p === 1 ? h[0] - s : i - h[0]);\n      return c.push(Xt(v, n, e)), v;\n    }\n  });\n  return {\n    radiusPoses: u,\n    styles: c,\n    raws: f\n  };\n}\nfunction Ji(t) {\n  const e = [0, 0], n = [0, 0], r = t.length;\n  for (let s = 0; s < r; ++s) {\n    const o = t[s];\n    o.sub && (o.horizontal && (e[1] === 0 && (e[0] = s), e[1] = s - e[0] + 1, n[0] = s + 1), o.vertical && (n[1] === 0 && (n[0] = s), n[1] = s - n[0] + 1));\n  }\n  return {\n    horizontalRange: e,\n    verticalRange: n\n  };\n}\nfunction Fu(t, e, n, r, s, o = [0, 0], i = !1) {\n  const a = t.indexOf(\"/\"), c = (a > -1 ? t.slice(0, a) : t).length, l = t.slice(0, c), u = t.slice(c + 1), f = l.length, d = u.length, p = d > 0, [\n    g = \"0px\",\n    h = g,\n    v = g,\n    m = h\n  ] = l, [\n    S = g,\n    x = p ? S : h,\n    C = p ? S : v,\n    E = p ? x : m\n  ] = u, D = [g, h, v, m].map((O) => ft(O, e)), R = [S, x, C, E].map((O) => ft(O, n)), y = D.slice(), M = R.slice();\n  [y[0], y[1]] = Tn(\n    [y[0], y[1]],\n    e\n  ), [y[3], y[2]] = Tn(\n    [y[3], y[2]],\n    e\n  ), [M[0], M[3]] = Tn(\n    [M[0], M[3]],\n    n\n  ), [M[1], M[2]] = Tn(\n    [M[1], M[2]],\n    n\n  );\n  const P = i ? y : y.slice(0, Math.max(o[0], f)), _ = i ? M : M.slice(0, Math.max(o[1], d));\n  return [\n    ...P.map((O, T) => {\n      const w = vo[T];\n      return {\n        virtual: T >= f,\n        horizontal: ve[T],\n        vertical: 0,\n        pos: [r + O, s + (me[T] === -1 ? n : 0)],\n        sub: !0,\n        raw: D[T],\n        direction: w\n      };\n    }),\n    ..._.map((O, T) => {\n      const w = vo[T];\n      return {\n        virtual: T >= d,\n        horizontal: 0,\n        vertical: me[T],\n        pos: [r + (ve[T] === -1 ? e : 0), s + O],\n        sub: !0,\n        raw: R[T],\n        direction: w\n      };\n    })\n  ];\n}\nfunction Lu(t, e, n, r, s = e.length) {\n  const {\n    horizontalRange: o,\n    verticalRange: i\n  } = Ji(t.slice(r)), a = n - r;\n  let c = 0;\n  if (a === 0)\n    c = s;\n  else if (a > 0 && a < o[1])\n    c = o[1] - a;\n  else if (a >= i[0])\n    c = i[0] + i[1] - a;\n  else\n    return;\n  t.splice(n, c), e.splice(n, c);\n}\nfunction Nu(t, e, n, r, s, o, i, a, c, l = 0, u = 0) {\n  const {\n    horizontalRange: f,\n    verticalRange: d\n  } = Ji(t.slice(n));\n  if (r > -1) {\n    const p = ve[r] === 1 ? o - l : a - o;\n    for (let g = f[1]; g <= r; ++g) {\n      const h = me[g] === 1 ? u : c;\n      let v = 0;\n      if (r === g ? v = o : g === 0 ? v = l + p : ve[g] === -1 && (v = a - (e[n][0] - l)), t.splice(n + g, 0, {\n        horizontal: ve[g],\n        vertical: 0,\n        pos: [v, h]\n      }), e.splice(n + g, 0, [v, h]), g === 0)\n        break;\n    }\n  } else if (s > -1) {\n    const p = me[s] === 1 ? i - u : c - i;\n    if (f[1] === 0 && d[1] === 0) {\n      const h = [\n        l + p,\n        u\n      ];\n      t.push({\n        horizontal: ve[0],\n        vertical: 0,\n        pos: h\n      }), e.push(h);\n    }\n    const g = d[0];\n    for (let h = d[1]; h <= s; ++h) {\n      const v = ve[h] === 1 ? l : a;\n      let m = 0;\n      if (s === h ? m = i : h === 0 ? m = u + p : me[h] === 1 ? m = e[n + g][1] : me[h] === -1 && (m = c - (e[n + g][1] - u)), t.push({\n        horizontal: 0,\n        vertical: me[h],\n        pos: [v, m]\n      }), e.push([v, m]), h === 0)\n        break;\n    }\n  }\n}\nfunction Wu(t, e = t.map((n) => n.raw)) {\n  const n = t.map((s, o) => s.horizontal ? e[o] : null).filter((s) => s != null), r = t.map((s, o) => s.vertical ? e[o] : null).filter((s) => s != null);\n  return {\n    horizontals: n,\n    verticals: r\n  };\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction Yu() {\n  for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;\n  for (var r = Array(t), s = 0, e = 0; e < n; e++) for (var o = arguments[e], i = 0, a = o.length; i < a; i++, s++) r[s] = o[i];\n  return r;\n}\nfunction At(t) {\n  return tt(t, Dt);\n}\nfunction Vu(t, e) {\n  return t.every(function(n, r) {\n    return At(n - e[r]) === 0;\n  });\n}\nfunction ju(t, e) {\n  return !At(t[0] - e[0]) && !At(t[1] - e[1]);\n}\nfunction Qi(t) {\n  return t.length < 3 ? 0 : Math.abs(Cc(t.map(function(e, n) {\n    var r = t[n + 1] || t[0];\n    return e[0] * r[1] - r[0] * e[1];\n  }))) / 2;\n}\nfunction mo(t, e) {\n  var n = e.width, r = e.height, s = e.left, o = e.top, i = be(t), a = i.minX, c = i.minY, l = i.maxX, u = i.maxY, f = n / (l - a), d = r / (u - c);\n  return t.map(function(p) {\n    return [s + (p[0] - a) * f, o + (p[1] - c) * d];\n  });\n}\nfunction be(t) {\n  var e = t.map(function(r) {\n    return r[0];\n  }), n = t.map(function(r) {\n    return r[1];\n  });\n  return {\n    minX: Math.min.apply(Math, e),\n    minY: Math.min.apply(Math, n),\n    maxX: Math.max.apply(Math, e),\n    maxY: Math.max.apply(Math, n)\n  };\n}\nfunction Fr(t, e, n) {\n  var r = t[0], s = t[1], o = be(e), i = o.minX, a = o.maxX, c = [[i, s], [a, s]], l = Yn(c[0], c[1]), u = Lr(e), f = [];\n  if (u.forEach(function(g) {\n    var h = Yn(g[0], g[1]), v = g[0];\n    if (Vu(l, h))\n      f.push({\n        pos: t,\n        line: g,\n        type: \"line\"\n      });\n    else {\n      var m = ta(bs(l, h), [c, g]);\n      m.forEach(function(S) {\n        g.some(function(x) {\n          return ju(x, S);\n        }) ? f.push({\n          pos: S,\n          line: g,\n          type: \"point\"\n        }) : At(v[1] - s) !== 0 && f.push({\n          pos: S,\n          line: g,\n          type: \"intersection\"\n        });\n      });\n    }\n  }), kt(f, function(g) {\n    return g[0] === r;\n  }))\n    return !0;\n  var d = 0, p = {};\n  return f.forEach(function(g) {\n    var h = g.pos, v = g.type, m = g.line;\n    if (!(h[0] > r))\n      if (v === \"intersection\")\n        ++d;\n      else {\n        if (v === \"line\")\n          return;\n        if (v === \"point\") {\n          var S = kt(m, function(E) {\n            return E[1] !== s;\n          }), x = p[h[0]], C = S[1] > s ? 1 : -1;\n          x ? x !== C && ++d : p[h[0]] = C;\n        }\n      }\n  }), d % 2 === 1;\n}\nfunction Yn(t, e) {\n  var n = t[0], r = t[1], s = e[0], o = e[1], i = s - n, a = o - r;\n  Math.abs(i) < Dt && (i = 0), Math.abs(a) < Dt && (a = 0);\n  var c = 0, l = 0, u = 0;\n  return i ? a ? (c = -a / i, l = 1, u = -c * n - r) : (l = 1, u = -r) : a && (c = -1, u = n), [c, l, u];\n}\nfunction bs(t, e) {\n  var n = t[0], r = t[1], s = t[2], o = e[0], i = e[1], a = e[2], c = n === 0 && o === 0, l = r === 0 && i === 0, u = [];\n  if (c && l)\n    return [];\n  if (c) {\n    var f = -s / r, d = -a / i;\n    return f !== d ? [] : [[-1 / 0, f], [1 / 0, f]];\n  } else if (l) {\n    var p = -s / n, g = -a / o;\n    return p !== g ? [] : [[p, -1 / 0], [p, 1 / 0]];\n  } else if (n === 0) {\n    var h = -s / r, v = -(i * h + a) / o;\n    u = [[v, h]];\n  } else if (o === 0) {\n    var h = -a / i, v = -(r * h + s) / n;\n    u = [[v, h]];\n  } else if (r === 0) {\n    var v = -s / n, h = -(o * v + a) / i;\n    u = [[v, h]];\n  } else if (i === 0) {\n    var v = -a / o, h = -(n * v + s) / r;\n    u = [[v, h]];\n  } else {\n    var v = (r * a - i * s) / (i * n - r * o), h = -(n * v + s) / r;\n    u = [[v, h]];\n  }\n  return u.map(function(m) {\n    return [m[0], m[1]];\n  });\n}\nfunction ta(t, e) {\n  var n = e.map(function(f) {\n    return [0, 1].map(function(d) {\n      return [Math.min(f[0][d], f[1][d]), Math.max(f[0][d], f[1][d])];\n    });\n  }), r = [];\n  if (t.length === 2) {\n    var s = t[0], o = s[0], i = s[1];\n    if (At(o - t[1][0])) {\n      if (!At(i - t[1][1])) {\n        var l = Math.max.apply(Math, n.map(function(f) {\n          return f[0][0];\n        })), u = Math.min.apply(Math, n.map(function(f) {\n          return f[0][1];\n        }));\n        if (At(l - u) > 0)\n          return [];\n        r = [[l, i], [u, i]];\n      }\n    } else {\n      var a = Math.max.apply(Math, n.map(function(f) {\n        return f[1][0];\n      })), c = Math.min.apply(Math, n.map(function(f) {\n        return f[1][1];\n      }));\n      if (At(a - c) > 0)\n        return [];\n      r = [[o, a], [o, c]];\n    }\n  }\n  return r.length || (r = t.filter(function(f) {\n    var d = f[0], p = f[1];\n    return n.every(function(g) {\n      return 0 <= At(d - g[0][0]) && 0 <= At(g[0][1] - d) && 0 <= At(p - g[1][0]) && 0 <= At(g[1][1] - p);\n    });\n  })), r.map(function(f) {\n    return [At(f[0]), At(f[1])];\n  });\n}\nfunction Lr(t) {\n  return Yu(t.slice(1), [t[0]]).map(function(e, n) {\n    return [t[n], e];\n  });\n}\nfunction Xu(t, e) {\n  var n = t.slice(), r = e.slice();\n  Ns(n) === -1 && n.reverse(), Ns(r) === -1 && r.reverse();\n  var s = Lr(n), o = Lr(r), i = s.map(function(u) {\n    return Yn(u[0], u[1]);\n  }), a = o.map(function(u) {\n    return Yn(u[0], u[1]);\n  }), c = [];\n  i.forEach(function(u, f) {\n    var d = s[f], p = [];\n    a.forEach(function(g, h) {\n      var v = bs(u, g), m = ta(v, [d, o[h]]);\n      p.push.apply(p, m.map(function(S) {\n        return {\n          index1: f,\n          index2: h,\n          pos: S,\n          type: \"intersection\"\n        };\n      }));\n    }), p.sort(function(g, h) {\n      return te(d[0], g.pos) - te(d[0], h.pos);\n    }), c.push.apply(c, p), Fr(d[1], r) && c.push({\n      index1: f,\n      index2: -1,\n      pos: d[1],\n      type: \"inside\"\n    });\n  }), o.forEach(function(u, f) {\n    if (Fr(u[1], n)) {\n      var d = !1, p = ne(c, function(g) {\n        var h = g.index2;\n        return h === f ? (d = !0, !1) : !!d;\n      });\n      p === -1 && (d = !1, p = ne(c, function(g) {\n        var h = g.index1, v = g.index2;\n        return h === -1 && v + 1 === f ? (d = !0, !1) : !!d;\n      })), p === -1 ? c.push({\n        index1: -1,\n        index2: f,\n        pos: u[1],\n        type: \"inside\"\n      }) : c.splice(p, 0, {\n        index1: -1,\n        index2: f,\n        pos: u[1],\n        type: \"inside\"\n      });\n    }\n  });\n  var l = {};\n  return c.filter(function(u) {\n    var f = u.pos, d = f[0] + \"x\" + f[1];\n    return l[d] ? !1 : (l[d] = !0, !0);\n  });\n}\nfunction Hu(t, e) {\n  var n = Xu(t, e);\n  return n.map(function(r) {\n    var s = r.pos;\n    return s;\n  });\n}\nfunction qu(t, e) {\n  var n = Hu(t, e);\n  return Qi(n);\n}\nconst Uu = [\n  [0, -1, \"n\"],\n  [1, 0, \"e\"]\n], Ku = [\n  [-1, -1, \"nw\"],\n  [0, -1, \"n\"],\n  [1, -1, \"ne\"],\n  [1, 0, \"e\"],\n  [1, 1, \"se\"],\n  [0, 1, \"s\"],\n  [-1, 1, \"sw\"],\n  [-1, 0, \"w\"]\n];\nfunction ys(t, e, n) {\n  const { clipRelative: r } = t.props, { width: s, height: o } = t.state, { type: i, poses: a } = e, c = i === \"rect\", l = i === \"circle\";\n  if (i === \"polygon\")\n    return n.map(\n      (u) => `${Xt(u[0], s, r)} ${Xt(u[1], o, r)}`\n    );\n  if (c || i === \"inset\") {\n    const u = n[1][1], f = n[3][0], d = n[7][0], p = n[5][1];\n    if (c)\n      return [u, f, p, d].map((h) => `${h}px`);\n    const g = [u, s - f, o - p, d].map(\n      (h, v) => Xt(h, v % 2 ? s : o, r)\n    );\n    if (n.length > 8) {\n      const [h, v] = K(n[4], n[0]);\n      g.push(\n        \"round\",\n        ...Ds(\n          a.slice(8).map((m, S) => ({\n            ...m,\n            pos: n[S]\n          })),\n          r,\n          h,\n          v,\n          d,\n          u,\n          f,\n          p\n        ).styles\n      );\n    }\n    return g;\n  } else if (l || i === \"ellipse\") {\n    const u = n[0], f = Xt(\n      B(n[1][1] - u[1]),\n      l ? Math.sqrt((s * s + o * o) / 2) : o,\n      r\n    ), d = l ? [f] : [Xt(B(n[2][0] - u[0]), s, r), f];\n    return d.push(\n      \"at\",\n      Xt(u[0], s, r),\n      Xt(u[1], o, r)\n    ), d;\n  }\n}\nfunction Vn(t, e, n, r) {\n  const s = [r, (r + e) / 2, e], o = [t, (t + n) / 2, n];\n  return Ku.map(([i, a, c]) => {\n    const l = s[i + 1], u = o[a + 1];\n    return {\n      vertical: B(a),\n      horizontal: B(i),\n      direction: c,\n      pos: [l, u]\n    };\n  });\n}\nfunction ea(t) {\n  const e = [1 / 0, -1 / 0], n = [1 / 0, -1 / 0];\n  return t.forEach(({ pos: r }) => {\n    e[0] = Math.min(e[0], r[0]), e[1] = Math.max(e[1], r[0]), n[0] = Math.min(n[0], r[1]), n[1] = Math.max(n[1], r[1]);\n  }), [B(e[1] - e[0]), B(n[1] - n[0])];\n}\nfunction xo(t, e, n, r, s) {\n  if (!t)\n    return;\n  let o = s;\n  if (!o) {\n    const u = Gt(t), f = u(\"clipPath\");\n    o = f !== \"none\" ? f : u(\"clip\");\n  }\n  if ((!o || o === \"none\" || o === \"auto\") && (o = r, !o))\n    return;\n  const { prefix: i = o, value: a = \"\" } = Xo(o), c = i === \"circle\";\n  let l = \" \";\n  if (i === \"polygon\") {\n    const u = xe(a || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\n    l = \",\";\n    const f = u.map((p) => {\n      const [g, h] = p.split(\" \");\n      return {\n        vertical: 1,\n        horizontal: 1,\n        pos: [ft(g, e), ft(h, n)]\n      };\n    }), d = be(f.map((p) => p.pos));\n    return {\n      type: i,\n      clipText: o,\n      poses: f,\n      splitter: l,\n      left: d.minX,\n      right: d.maxX,\n      top: d.minY,\n      bottom: d.maxY\n    };\n  } else if (c || i === \"ellipse\") {\n    let u = \"\", f = \"\", d = 0, p = 0;\n    const g = ce(a);\n    if (c) {\n      let m = \"\";\n      [m = \"50%\", , u = \"50%\", f = \"50%\"] = g, d = ft(\n        m,\n        Math.sqrt((e * e + n * n) / 2)\n      ), p = d;\n    } else {\n      let m = \"\", S = \"\";\n      [m = \"50%\", S = \"50%\", , u = \"50%\", f = \"50%\"] = g, d = ft(m, e), p = ft(S, n);\n    }\n    const h = [\n      ft(u, e),\n      ft(f, n)\n    ], v = [\n      {\n        vertical: 1,\n        horizontal: 1,\n        pos: h,\n        direction: \"nesw\"\n      },\n      ...Uu.slice(0, c ? 1 : 2).map((m) => ({\n        vertical: B(m[1]),\n        horizontal: m[0],\n        direction: m[2],\n        sub: !0,\n        pos: [h[0] + m[0] * d, h[1] + m[1] * p]\n      }))\n    ];\n    return {\n      type: i,\n      clipText: o,\n      radiusX: d,\n      radiusY: p,\n      left: h[0] - d,\n      top: h[1] - p,\n      right: h[0] + d,\n      bottom: h[1] + p,\n      poses: v,\n      splitter: l\n    };\n  } else if (i === \"inset\") {\n    const u = ce(a || \"0 0 0 0 round 0px\"), f = u.indexOf(\"round\"), d = (f > -1 ? u.slice(0, f) : u).length, p = u.slice(d + 1), [\n      g,\n      h = g,\n      v = g,\n      m = h\n    ] = u.slice(0, d), [S, x] = [g, v].map(\n      (M) => ft(M, n)\n    ), [C, E] = [m, h].map(\n      (M) => ft(M, e)\n    ), D = e - E, R = n - x, y = [\n      ...Vn(S, D, R, C)\n    ];\n    return {\n      type: \"inset\",\n      clipText: o,\n      poses: y,\n      top: S,\n      left: C,\n      right: D,\n      bottom: R,\n      radius: p,\n      splitter: l\n    };\n  } else if (i === \"rect\") {\n    const u = xe(a || `0px, ${e}px, ${n}px, 0px`);\n    l = \",\";\n    const [f, d, p, g] = u.map((v) => {\n      const { value: m } = pn(v);\n      return m;\n    }), h = Vn(f, d, p, g);\n    return {\n      type: \"rect\",\n      clipText: o,\n      poses: h,\n      top: f,\n      right: d,\n      bottom: p,\n      left: g,\n      values: u,\n      splitter: l\n    };\n  }\n}\nfunction Zu(t, e, n, r, s) {\n  const { direction: o, sub: i } = t[e], a = t.map(() => [0, 0]), c = o ? o.split(\"\") : [];\n  if (r && e < 8) {\n    const l = c.filter(\n      (v) => v === \"w\" || v === \"e\"\n    ), u = c.filter(\n      (v) => v === \"n\" || v === \"s\"\n    ), f = l[0], d = u[0];\n    a[e] = n;\n    const [p, g] = ea(t), h = p && g ? p / g : 0;\n    if (h && s) {\n      const v = (e + 4) % 8, m = t[v].pos, S = [0, 0];\n      o.indexOf(\"w\") > -1 ? S[0] = -1 : o.indexOf(\"e\") > -1 && (S[0] = 1), o.indexOf(\"n\") > -1 ? S[1] = -1 : o.indexOf(\"s\") > -1 && (S[1] = 1);\n      const x = ji(\n        [p, g],\n        n,\n        h,\n        S,\n        !0\n      ), C = p + x[0], E = g + x[1];\n      let D = m[1], R = m[1], y = m[0], M = m[0];\n      S[0] === -1 ? y = M - C : S[0] === 1 ? M = y + C : (y = y - C / 2, M = M + C / 2), S[1] === -1 ? D = R - E : (S[1] === 1 || (D = R - E / 2), R = D + E);\n      const P = Vn(D, M, R, y);\n      t.forEach((_, O) => {\n        a[O][0] = P[O].pos[0] - _.pos[0], a[O][1] = P[O].pos[1] - _.pos[1];\n      });\n    } else\n      t.forEach((v, m) => {\n        const { direction: S } = v;\n        S && (S.indexOf(f) > -1 && (a[m][0] = n[0]), S.indexOf(d) > -1 && (a[m][1] = n[1]));\n      }), f && (a[1][0] = n[0] / 2, a[5][0] = n[0] / 2), d && (a[3][1] = n[1] / 2, a[7][1] = n[1] / 2);\n  } else o && !i ? c.forEach((l) => {\n    const u = l === \"n\" || l === \"s\";\n    t.forEach((f, d) => {\n      const {\n        direction: p,\n        horizontal: g,\n        vertical: h\n      } = f;\n      !p || p.indexOf(l) === -1 || (a[d] = [\n        u || !g ? 0 : n[0],\n        !u || !h ? 0 : n[1]\n      ]);\n    });\n  }) : a[e] = n;\n  return a;\n}\nfunction Ju(t, e) {\n  const [n, r] = ni(t, e), { clipPath: s, clipIndex: o } = e.datas, {\n    type: i,\n    poses: a,\n    splitter: c\n  } = s, l = a.map((d) => d.pos);\n  if (i === \"polygon\")\n    l.splice(o, 0, [n, r]);\n  else if (i === \"inset\") {\n    const d = ku.indexOf(o), p = $u.indexOf(o), g = a.length;\n    if (Nu(\n      a,\n      l,\n      8,\n      d,\n      p,\n      n,\n      r,\n      l[4][0],\n      l[4][1],\n      l[0][0],\n      l[0][1]\n    ), g === a.length)\n      return;\n  } else\n    return;\n  const u = ys(t, s, l), f = `${i}(${u.join(c)})`;\n  j(\n    t,\n    \"onClip\",\n    et(t, e, {\n      clipEventType: \"added\",\n      clipType: i,\n      poses: l,\n      clipStyles: u,\n      clipStyle: f,\n      distX: 0,\n      distY: 0,\n      ...It(\n        {\n          clipPath: f\n        },\n        e\n      )\n    })\n  );\n}\nfunction Qu(t, e) {\n  const { clipPath: n, clipIndex: r } = e.datas, {\n    type: s,\n    poses: o,\n    splitter: i\n  } = n, a = o.map((f) => f.pos), c = a.length;\n  if (s === \"polygon\")\n    o.splice(r, 1), a.splice(r, 1);\n  else if (s === \"inset\") {\n    if (r < 8 || (Lu(o, a, r, 8, c), c === o.length))\n      return;\n  } else\n    return;\n  const l = ys(t, n, a), u = `${s}(${l.join(i)})`;\n  j(\n    t,\n    \"onClip\",\n    et(t, e, {\n      clipEventType: \"removed\",\n      clipType: s,\n      poses: a,\n      clipStyles: l,\n      clipStyle: u,\n      distX: 0,\n      distY: 0,\n      ...It(\n        {\n          clipPath: u\n        },\n        e\n      )\n    })\n  );\n}\nconst tf = {\n  name: \"clippable\",\n  props: [\n    \"clippable\",\n    \"defaultClipPath\",\n    \"customClipPath\",\n    \"keepRatio\",\n    \"clipRelative\",\n    \"clipArea\",\n    \"dragWithClip\",\n    \"clipTargetBounds\",\n    \"clipVerticalGuidelines\",\n    \"clipHorizontalGuidelines\",\n    \"clipSnapThreshold\"\n  ],\n  events: [\"clipStart\", \"clip\", \"clipEnd\"],\n  css: [\n    `.control.clip-control {\nbackground: red;\ncursor: pointer;\n}\n.control.clip-control.clip-radius {\nbackground: #d66;\n}\n.line.clip-line {\nbackground: #6e6;\ncursor: move;\nz-index: 1;\n}\n.clip-area {\nposition: absolute;\ntop: 0;\nleft: 0;\n}\n.clip-ellipse {\nposition: absolute;\ncursor: move;\nborder: 1px solid #6d6;\nborder: var(--zoompx) solid #6d6;\nborder-radius: 50%;\ntransform-origin: 0px 0px;\n}`,\n    `:host {\n--bounds-color: #d66;\n}`,\n    `.guideline {\npointer-events: none;\nz-index: 2;\n}`,\n    `.line.guideline.bounds {\nbackground: #d66;\nbackground: var(--bounds-color);\n}`\n  ],\n  render(t, e) {\n    const { customClipPath: n, defaultClipPath: r, clipArea: s, zoom: o, groupable: i } = t.props, {\n      target: a,\n      width: c,\n      height: l,\n      allMatrix: u,\n      is3d: f,\n      left: d,\n      top: p,\n      pos1: g,\n      pos2: h,\n      pos3: v,\n      pos4: m,\n      clipPathState: S,\n      snapBoundInfos: x,\n      rotation: C\n    } = t.getState();\n    if (!a || i)\n      return [];\n    const E = xo(\n      a,\n      c,\n      l,\n      r || \"inset\",\n      S || n\n    );\n    if (!E)\n      return [];\n    const D = f ? 4 : 3, R = E.type, M = E.poses.map((I) => {\n      const $ = ht(u, I.pos, D);\n      return [$[0] - d, $[1] - p];\n    });\n    let P = [], _ = [];\n    const O = R === \"rect\", T = R === \"inset\", w = R === \"polygon\";\n    if (O || T || w) {\n      const I = T ? M.slice(0, 8) : M;\n      _ = I.map(($, G) => {\n        const L = G === 0 ? I[I.length - 1] : I[G - 1], z = xt(L, $), N = Gi(L, $);\n        return /* @__PURE__ */ it.jsx(\n          \"div\",\n          {\n            className: U(\"line\", \"clip-line\", \"snap-control\"),\n            \"data-clip-index\": G,\n            style: {\n              width: `${N}px`,\n              transform: `translate(${L[0]}px, ${L[1]}px) rotate(${z}rad) scaleY(${o})`\n            }\n          },\n          `clipLine${G}`\n        );\n      });\n    }\n    const k = [\"nw\", \"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\"];\n    if (P = M.map((I, $) => {\n      const G = k[$];\n      return /* @__PURE__ */ it.jsx(\n        \"div\",\n        {\n          className: U(\n            \"control\",\n            \"clip-control\",\n            \"snap-control\",\n            `clip-${G}`\n          ),\n          \"data-clip-index\": $,\n          style: {\n            transform: `translate(${I[0]}px, ${I[1]}px) rotate(${C}rad) scale(${o})`,\n            backgroundColor: \"green\"\n          }\n        },\n        `clipControl${$}`\n      );\n    }), T && P.push(\n      ...M.slice(8).map((I, $) => /* @__PURE__ */ it.jsx(\n        \"div\",\n        {\n          className: U(\n            \"control\",\n            \"clip-control\",\n            \"clip-radius\",\n            \"snap-control\"\n          ),\n          \"data-clip-index\": 8 + $,\n          style: {\n            transform: `translate(${I[0]}px, ${I[1]}px) rotate(${C}rad) scale(${o})`\n          }\n        },\n        `clipRadiusControl${$}`\n      ))\n    ), R === \"circle\" || R === \"ellipse\") {\n      const { left: I, top: $, radiusX: G, radiusY: L } = E, [z, N] = K(\n        ht(u, [I, $], D),\n        ht(u, [0, 0], D)\n      );\n      let Z = \"none\";\n      if (!s) {\n        const Y = Math.max(10, G / 5, L / 5), W = [];\n        for (let J = 0; J <= Y; ++J) {\n          const q = Math.PI * 2 / Y * J;\n          W.push([\n            G + (G - o) * Math.cos(q),\n            L + (L - o) * Math.sin(q)\n          ]);\n        }\n        W.push([G, -2]), W.push([-2, -2]), W.push([-2, L * 2 + 2]), W.push([G * 2 + 2, L * 2 + 2]), W.push([G * 2 + 2, -2]), W.push([G, -2]), Z = `polygon(${W.map((J) => `${J[0]}px ${J[1]}px`).join(\", \")})`;\n      }\n      P.push(\n        /* @__PURE__ */ it.jsx(\n          \"div\",\n          {\n            className: U(\"clip-ellipse\", \"snap-control\"),\n            style: {\n              width: `${G * 2}px`,\n              height: `${L * 2}px`,\n              clipPath: Z,\n              transform: `translate(${-d + z}px, ${-p + N}px) ${Jn(u)}`\n            }\n          },\n          \"clipEllipse\"\n        )\n      );\n    }\n    if (s) {\n      const {\n        width: I,\n        height: $,\n        left: G,\n        top: L\n      } = Yt([g, h, v, m, ...M]);\n      if (w || O || T) {\n        const z = T ? M.slice(0, 8) : M;\n        P.push(\n          /* @__PURE__ */ it.jsx(\n            \"div\",\n            {\n              className: U(\"clip-area\", \"snap-control\"),\n              style: {\n                width: `${I}px`,\n                height: `${$}px`,\n                transform: `translate(${G}px, ${L}px)`,\n                clipPath: `polygon(${z.map((N) => `${N[0] - G}px ${N[1] - L}px`).join(\", \")})`\n              }\n            },\n            \"clipArea\"\n          )\n        );\n      }\n    }\n    return x && [\"vertical\", \"horizontal\"].forEach((I) => {\n      const $ = x[I], G = I === \"horizontal\";\n      $.isSnap && _.push(\n        ...$.snap.posInfos.map(({ pos: L }, z) => {\n          const N = K(\n            ht(\n              u,\n              G ? [0, L] : [L, 0],\n              D\n            ),\n            [d, p]\n          ), Z = K(\n            ht(\n              u,\n              G ? [c, L] : [L, l],\n              D\n            ),\n            [d, p]\n          );\n          return un(\n            e,\n            \"\",\n            N,\n            Z,\n            o,\n            `clip${I}snap${z}`,\n            \"guideline\"\n          );\n        })\n      ), $.isBound && _.push(\n        ...$.bounds.map(({ pos: L }, z) => {\n          const N = K(\n            ht(\n              u,\n              G ? [0, L] : [L, 0],\n              D\n            ),\n            [d, p]\n          ), Z = K(\n            ht(\n              u,\n              G ? [c, L] : [L, l],\n              D\n            ),\n            [d, p]\n          );\n          return un(\n            e,\n            \"\",\n            N,\n            Z,\n            o,\n            `clip${I}bounds${z}`,\n            \"guideline\",\n            \"bounds\",\n            \"bold\"\n          );\n        })\n      );\n    }), [...P, ..._];\n  },\n  dragControlCondition(t, e) {\n    return e.inputEvent && (e.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n  },\n  dragStart(t, e) {\n    const n = t.props, { dragWithClip: r = !0 } = n;\n    return r ? !1 : this.dragControlStart(t, e);\n  },\n  drag(t, e) {\n    return this.dragControl(t, { ...e, isDragTarget: !0 });\n  },\n  dragEnd(t, e) {\n    return this.dragControlEnd(t, e);\n  },\n  dragControlStart(t, e) {\n    const n = t.state, { defaultClipPath: r, customClipPath: s } = t.props, { target: o, width: i, height: a } = n, c = e.inputEvent ? e.inputEvent.target : null, l = c && c.getAttribute(\"class\") || \"\", u = e.datas, f = xo(\n      o,\n      i,\n      a,\n      r || \"inset\",\n      s\n    );\n    if (!f)\n      return !1;\n    const { clipText: d, type: p, poses: g } = f;\n    return j(\n      t,\n      \"onClipStart\",\n      et(t, e, {\n        clipType: p,\n        clipStyle: d,\n        poses: g.map((v) => v.pos)\n      })\n    ) === !1 ? (u.isClipStart = !1, !1) : (u.isControl = l && l.indexOf(\"clip-control\") > -1, u.isLine = l.indexOf(\"clip-line\") > -1, u.isArea = l.indexOf(\"clip-area\") > -1 || l.indexOf(\"clip-ellipse\") > -1, u.clipIndex = c ? parseInt(c.getAttribute(\"data-clip-index\"), 10) : -1, u.clipPath = f, u.isClipStart = !0, n.clipPathState = d, Re(t, e), !0);\n  },\n  dragControl(t, e) {\n    const { datas: n, originalDatas: r, isDragTarget: s } = e;\n    if (!n.isClipStart)\n      return !1;\n    const { isControl: o, isLine: i, isArea: a, clipIndex: c, clipPath: l } = n;\n    if (!l)\n      return !1;\n    const u = De(t.props, \"clippable\"), { keepRatio: f } = u;\n    let d = 0, p = 0;\n    const g = r.draggable, h = Qt(e);\n    s && g ? [d, p] = g.prevBeforeDist : [d, p] = h;\n    const v = [d, p], m = t.state, { width: S, height: x } = m, C = !a && !o && !i, { type: E, poses: D, splitter: R } = l, y = D.map((F) => F.pos);\n    C && (d = -d, p = -p);\n    const M = !o || D[c].direction === \"nesw\", P = E === \"inset\" || E === \"rect\";\n    let _ = D.map(() => [0, 0]), O = u.defaultClipPath === \"inset\" ? !1 : f;\n    if (o && !M) {\n      const { horizontal: F, vertical: H } = D[c], nt = [d * B(F), p * B(H)];\n      _ = Zu(\n        D,\n        c,\n        nt,\n        P,\n        O\n      );\n    } else M && (_ = y.map(() => [d, p]));\n    const T = y.map((F, H) => at(F, _[H])), w = [...T];\n    m.snapBoundInfos = null;\n    const k = l.type === \"circle\", I = l.type === \"ellipse\";\n    if (k || I) {\n      const F = Yt(T), H = B(F.bottom - F.top), nt = B(I ? F.right - F.left : H), lt = T[0][1] + H, vt = T[0][0] - nt, st = T[0][0] + nt;\n      k && (w.push([st, F.bottom]), _.push([1, 0])), w.push([F.left, lt]), _.push([0, 1]), w.push([vt, F.bottom]), _.push([1, 0]);\n    }\n    const $ = Oi(\n      (u.clipHorizontalGuidelines || []).map(\n        (F) => ft(`${F}`, x)\n      ),\n      (u.clipVerticalGuidelines || []).map(\n        (F) => ft(`${F}`, S)\n      ),\n      S,\n      x\n    );\n    let G = [], L = [];\n    if (k || I)\n      G = [w[4][0], w[2][0]], L = [w[1][1], w[3][1]];\n    else if (P) {\n      const F = [\n        w[0],\n        w[2],\n        w[4],\n        w[6]\n      ], H = [_[0], _[2], _[4], _[6]];\n      G = F.filter((nt, lt) => H[lt][0]).map((nt) => nt[0]), L = F.filter((nt, lt) => H[lt][1]).map((nt) => nt[1]);\n    } else\n      G = w.filter((F, H) => _[H][0]).map((F) => F[0]), L = w.filter((F, H) => _[H][1]).map((F) => F[1]);\n    const z = [0, 0], { horizontal: N, vertical: Z } = Qs(\n      $,\n      u.clipTargetBounds && {\n        left: 0,\n        top: 0,\n        right: S,\n        bottom: x\n      },\n      G,\n      L,\n      5,\n      5\n    );\n    let Y = N.offset, W = Z.offset;\n    if (N.isBound && (z[1] += Y), Z.isBound && (z[0] += W), (I || k) && _[0][0] === 0 && _[0][1] === 0) {\n      const F = Yt(T);\n      let H = F.bottom - F.top, nt = I ? F.right - F.left : H;\n      const lt = Z.isBound ? B(W) : Z.snapIndex === 0 ? -W : W, vt = N.isBound ? B(Y) : N.snapIndex === 0 ? -Y : Y;\n      nt -= lt, H -= vt, k && (H = Ei(Z, N) > 0 ? H : nt, nt = H);\n      const st = w[0];\n      w[1][1] = st[1] - H, w[2][0] = st[0] + nt, w[3][1] = st[1] + H, w[4][0] = st[0] - nt;\n    } else if (P && O && o) {\n      const [F, H] = ea(D), nt = F && H ? F / H : 0, vt = D[c].direction || \"\";\n      let st = w[1][1], Ft = w[5][1], Lt = w[7][0], ut = w[3][0];\n      B(Y) <= B(W) ? Y = wt(Y) * B(W) / nt : W = wt(W) * B(Y) * nt, vt.indexOf(\"w\") > -1 ? Lt -= W : vt.indexOf(\"e\") > -1 ? ut -= W : (Lt += W / 2, ut -= W / 2), vt.indexOf(\"n\") > -1 ? st -= Y : vt.indexOf(\"s\") > -1 ? Ft -= Y : (st += Y / 2, Ft -= Y / 2);\n      const St = Vn(st, ut, Ft, Lt);\n      w.forEach((Kt, de) => {\n        [Kt[0], Kt[1]] = St[de].pos;\n      });\n    } else\n      w.forEach((F, H) => {\n        const nt = _[H];\n        nt[0] && (F[0] -= W), nt[1] && (F[1] -= Y);\n      });\n    const J = ys(t, l, T), q = `${E}(${J.join(R)} ${l.radius.length ? \"round \" + l.radius.join(\" \") : \"\"})`;\n    if (m.clipPathState = q, k || I)\n      G = [w[4][0], w[2][0]], L = [w[1][1], w[3][1]];\n    else if (P) {\n      const F = [\n        w[0],\n        w[2],\n        w[4],\n        w[6]\n      ];\n      G = F.map((H) => H[0]), L = F.map((H) => H[1]);\n    } else\n      G = w.map((F) => F[0]), L = w.map((F) => F[1]);\n    if (m.snapBoundInfos = Qs(\n      $,\n      u.clipTargetBounds && {\n        left: 0,\n        top: 0,\n        right: S,\n        bottom: x\n      },\n      G,\n      L,\n      1,\n      1\n    ), g) {\n      const { is3d: F, allMatrix: H } = m, nt = F ? 4 : 3;\n      let lt = z;\n      s && (lt = [\n        v[0] + z[0] - h[0],\n        v[1] + z[1] - h[1]\n      ]), g.deltaOffset = dt(\n        H,\n        [lt[0], lt[1], 0, 0],\n        nt\n      );\n    }\n    return j(\n      t,\n      \"onClip\",\n      et(t, e, {\n        clipEventType: \"changed\",\n        clipType: E,\n        poses: T,\n        clipStyle: q,\n        clipStyles: J,\n        distX: d,\n        distY: p,\n        ...It(\n          {\n            [E === \"rect\" ? \"clip\" : \"clipPath\"]: q\n          },\n          e\n        )\n      })\n    ), !0;\n  },\n  dragControlEnd(t, e) {\n    this.unset(t);\n    const { isDrag: n, datas: r, isDouble: s } = e, { isLine: o, isClipStart: i, isControl: a } = r;\n    return i ? (j(\n      t,\n      \"onClipEnd\",\n      $t(t, e, {})\n    ), s && (a ? (console.log(\"removeClipPath\"), Qu(t, e)) : o && (console.log(\"addClipPath\"), Ju(t, e))), s || n) : !1;\n  },\n  unset(t) {\n    t.state.clipPathState = \"\", t.state.snapBoundInfos = null;\n  }\n}, ef = {\n  name: \"originDraggable\",\n  props: [\n    \"originDraggable\",\n    \"originRelative\"\n  ],\n  events: [\n    \"dragOriginStart\",\n    \"dragOrigin\",\n    \"dragOriginEnd\"\n  ],\n  css: [\n    `:host[data-able-origindraggable] .control.origin {\npointer-events: auto;\n}`\n  ],\n  dragControlCondition(t, e) {\n    return e.isRequest ? e.requestAble === \"originDraggable\" : bt(e.inputEvent.target, U(\"origin\"));\n  },\n  dragControlStart(t, e) {\n    const { datas: n } = e;\n    Re(t, e);\n    const r = et(t, e, {\n      dragStart: Ot.dragStart(\n        t,\n        new Fe().dragStart([0, 0], e)\n      )\n    }), s = j(t, \"onDragOriginStart\", r);\n    return n.startOrigin = t.state.transformOrigin, n.startTargetOrigin = t.state.targetOrigin, n.prevOrigin = [0, 0], n.isDragOrigin = !0, s === !1 ? (n.isDragOrigin = !1, !1) : r;\n  },\n  dragControl(t, e) {\n    const { datas: n, isPinch: r, isRequest: s } = e;\n    if (!n.isDragOrigin)\n      return !1;\n    const [o, i] = Qt(e), a = t.state, {\n      width: c,\n      height: l,\n      offsetMatrix: u,\n      targetMatrix: f,\n      is3d: d\n    } = a, {\n      originRelative: p = !0\n    } = t.props, g = d ? 4 : 3;\n    let h = [o, i];\n    if (s) {\n      const P = e.distOrigin;\n      (P[0] || P[1]) && (h = P);\n    }\n    const v = at(n.startOrigin, h), m = at(n.startTargetOrigin, h), S = K(h, n.prevOrigin), x = mn(\n      u,\n      f,\n      v,\n      g\n    ), C = t.getRect(), E = Yt(Me(x, c, l, g)), D = [\n      C.left - E.left,\n      C.top - E.top\n    ];\n    n.prevOrigin = h;\n    const R = [\n      Xt(m[0], c, p),\n      Xt(m[1], l, p)\n    ].join(\" \"), y = Ot.drag(\n      t,\n      vn(e, t.state, D, !!r)\n    ), M = et(t, e, {\n      width: c,\n      height: l,\n      origin: v,\n      dist: h,\n      delta: S,\n      transformOrigin: R,\n      drag: y,\n      ...It({\n        transformOrigin: R,\n        transform: y.transform\n      }, e),\n      afterTransform: y.transform\n    });\n    return j(t, \"onDragOrigin\", M), M;\n  },\n  dragControlEnd(t, e) {\n    const { datas: n } = e;\n    return n.isDragOrigin ? (j(\n      t,\n      \"onDragOriginEnd\",\n      $t(t, e, {})\n    ), !0) : !1;\n  },\n  dragGroupControlCondition(t, e) {\n    return this.dragControlCondition(t, e);\n  },\n  dragGroupControlStart(t, e) {\n    return !!this.dragControlStart(t, e);\n  },\n  dragGroupControl(t, e) {\n    const n = this.dragControl(t, e);\n    return n ? (t.transformOrigin = n.transformOrigin, !0) : !1;\n  },\n  /**\n      * @method Moveable.OriginDraggable#request\n      * @param {object} e - the OriginDraggable's request parameter\n      * @param {number} [e.x] - x position\n      * @param {number} [e.y] - y position\n      * @param {number} [e.deltaX] - x number to move\n      * @param {number} [e.deltaY] - y number to move\n      * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n      * @param {array} [e.origin] - transform-origin position\n      * @param {number} [e.isInstant] - Whether to execute the request instantly\n      * @return {Moveable.Requester} Moveable Requester\n      * @example\n  \n      * // Instantly Request (requestStart - request - requestEnd)\n      * // Use Relative Value\n      * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n      * // Use Absolute Value\n      * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n      * // Use Transform Value\n      * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n      * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n      * // requestStart\n      * const requester = moveable.request(\"originDraggable\");\n      *\n      * // request\n      * // Use Relative Value\n      * requester.request({ deltaX: 10, deltaY: 10 });\n      * requester.request({ deltaX: 10, deltaY: 10 });\n      * requester.request({ deltaX: 10, deltaY: 10 });\n      * // Use Absolute Value\n      * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n      * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n      * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n      *\n      * // requestEnd\n      * requester.requestEnd();\n      */\n  request(t) {\n    const e = {}, n = t.getRect();\n    let r = 0, s = 0;\n    const o = n.transformOrigin, i = [0, 0];\n    return {\n      isControl: !0,\n      requestStart() {\n        return { datas: e };\n      },\n      request(a) {\n        return \"deltaOrigin\" in a ? (i[0] += a.deltaOrigin[0], i[1] += a.deltaOrigin[1]) : \"origin\" in a ? (i[0] = a.origin[0] - o[0], i[1] = a.origin[1] - o[1]) : (\"x\" in a ? r = a.x - n.left : \"deltaX\" in a && (r += a.deltaX), \"y\" in a ? s = a.y - n.top : \"deltaY\" in a && (s += a.deltaY)), { datas: e, distX: r, distY: s, distOrigin: i };\n      },\n      requestEnd() {\n        return { datas: e, isDrag: !0 };\n      }\n    };\n  }\n};\nfunction nf(t, e, n, r) {\n  const s = t.filter(({ virtual: c, horizontal: l }) => l && !c).length, o = t.filter(({ virtual: c, vertical: l }) => l && !c).length;\n  let i = -1;\n  if (e === 0 && (s === 0 ? i = 0 : s === 1 && (i = 1)), e === 2 && (s <= 2 ? i = 2 : s <= 3 && (i = 3)), e === 3 && (o === 0 ? i = 4 : o < 4 && (i = 7)), e === 1 && (o <= 1 ? i = 5 : o <= 2 && (i = 6)), i === -1 || !t[i].virtual)\n    return;\n  const a = t[i];\n  rf(t, i), i < 4 ? a.pos[0] = n : a.pos[1] = r;\n}\nfunction rf(t, e) {\n  e < 4 ? t.slice(0, e + 1).forEach((n) => {\n    n.virtual = !1;\n  }) : (t[0].virtual && (t[0].virtual = !1), t.slice(4, e + 1).forEach((n) => {\n    n.virtual = !1;\n  }));\n}\nfunction sf(t, e) {\n  e < 4 ? t.slice(e, 4).forEach((n) => {\n    n.virtual = !0;\n  }) : t.slice(e).forEach((n) => {\n    n.virtual = !0;\n  });\n}\nfunction So(t, e, n, r = [0, 0], s) {\n  let o = [];\n  return !t || t === \"0px\" ? o = [] : o = ce(t), Fu(o, e, n, 0, 0, r, s);\n}\nfunction Eo(t, e, n, r, s) {\n  const o = t.state, {\n    width: i,\n    height: a\n  } = o, {\n    raws: c,\n    styles: l,\n    radiusPoses: u\n  } = Ds(\n    s,\n    t.props.roundRelative,\n    i,\n    a\n  ), {\n    horizontals: f,\n    verticals: d\n  } = Wu(u, c), p = l.join(\" \");\n  o.borderRadiusState = p;\n  const g = et(t, e, {\n    horizontals: f,\n    verticals: d,\n    borderRadius: p,\n    width: i,\n    height: a,\n    delta: r,\n    dist: n,\n    ...It({\n      borderRadius: p\n    }, e)\n  });\n  return j(t, \"onRound\", g), g;\n}\nfunction Co(t) {\n  var r;\n  const {\n    style: e\n  } = t.getState();\n  let n = e.borderRadius || \"\";\n  if (!n && t.props.groupable) {\n    const s = t.moveables[0], o = t.getTargets()[0];\n    o && ((s == null ? void 0 : s.props.target) === o ? (n = ((r = t.moveables[0]) == null ? void 0 : r.state.style.borderRadius) ?? \"\", e.borderRadius = n) : (n = vs(o).borderRadius, e.borderRadius = n));\n  }\n  return n;\n}\nconst of = {\n  name: \"roundable\",\n  props: [\n    \"roundable\",\n    \"roundRelative\",\n    \"minRoundControls\",\n    \"maxRoundControls\",\n    \"roundClickable\",\n    \"roundPadding\",\n    \"isDisplayShadowRoundControls\"\n  ],\n  events: [\n    \"roundStart\",\n    \"round\",\n    \"roundEnd\",\n    \"roundGroupStart\",\n    \"roundGroup\",\n    \"roundGroupEnd\"\n  ],\n  css: [\n    `.control.border-radius {\nbackground: #d66;\ncursor: pointer;\nz-index: 3;\n}`,\n    `.control.border-radius.vertical {\nbackground: #d6d;\nz-index: 2;\n}`,\n    `.control.border-radius.virtual {\nopacity: 0.5;\nz-index: 1;\n}`,\n    `:host.round-line-clickable .line.direction {\ncursor: pointer;\n}`\n  ],\n  className(t) {\n    const e = t.props.roundClickable;\n    return e === !0 || e === \"line\" ? U(\"round-line-clickable\") : \"\";\n  },\n  requestStyle() {\n    return [\"borderRadius\"];\n  },\n  requestChildStyle() {\n    return [\"borderRadius\"];\n  },\n  render(t, e) {\n    const {\n      target: n,\n      width: r,\n      height: s,\n      allMatrix: o,\n      is3d: i,\n      left: a,\n      top: c,\n      borderRadiusState: l\n    } = t.getState(), {\n      minRoundControls: u = [0, 0],\n      maxRoundControls: f = [4, 4],\n      zoom: d,\n      roundPadding: p = 0,\n      isDisplayShadowRoundControls: g,\n      groupable: h\n    } = t.props;\n    if (!n)\n      return null;\n    const v = l || Co(t), m = i ? 4 : 3, S = So(\n      v,\n      r,\n      s,\n      u,\n      !0\n    );\n    if (!S)\n      return null;\n    let x = 0, C = 0;\n    const E = h ? [0, 0] : [a, c];\n    return S.map((D, R) => {\n      const y = D.horizontal, M = D.vertical, P = D.direction || \"\", _ = [...D.pos];\n      C += Math.abs(y), x += Math.abs(M), y && P.indexOf(\"n\") > -1 && (_[1] -= p), M && P.indexOf(\"w\") > -1 && (_[0] -= p), y && P.indexOf(\"s\") > -1 && (_[1] += p), M && P.indexOf(\"e\") > -1 && (_[0] += p);\n      const O = K(ht(o, _, m), E), T = g && g !== \"horizontal\", w = D.vertical ? x <= f[1] && (T || !D.virtual) : C <= f[0] && (g || !D.virtual);\n      return /* @__PURE__ */ it.jsx(\n        \"div\",\n        {\n          className: U(\n            \"control\",\n            \"border-radius\",\n            D.vertical ? \"vertical\" : \"\",\n            D.virtual ? \"virtual\" : \"\"\n          ),\n          \"data-radius-index\": R,\n          style: {\n            display: w ? \"block\" : \"none\",\n            transform: `translate(${O[0]}px, ${O[1]}px) scale(${d})`\n          }\n        },\n        `borderRadiusControl${R}`\n      );\n    });\n  },\n  dragControlCondition(t, e) {\n    if (!e.inputEvent || e.isRequest)\n      return !1;\n    const n = e.inputEvent.target.getAttribute(\"class\") || \"\";\n    return n.indexOf(\"border-radius\") > -1 || n.indexOf(\"moveable-line\") > -1 && n.indexOf(\"moveable-direction\") > -1;\n  },\n  dragGroupControlCondition(t, e) {\n    return this.dragControlCondition(t, e);\n  },\n  dragControlStart(t, e) {\n    const { inputEvent: n, datas: r } = e, s = n.target, o = s.getAttribute(\"class\") || \"\", i = o.indexOf(\"border-radius\") > -1, a = o.indexOf(\"moveable-line\") > -1 && o.indexOf(\"moveable-direction\") > -1, c = i ? parseInt(s.getAttribute(\"data-radius-index\"), 10) : -1;\n    let l = -1;\n    if (a) {\n      const x = s.getAttribute(\"data-line-key\") || \"\";\n      x && (l = parseInt(x.replace(/render-line-/g, \"\"), 10), isNaN(l) && (l = -1));\n    }\n    if (!i && !a)\n      return !1;\n    const u = et(t, e, {});\n    if (j(\n      t,\n      \"onRoundStart\",\n      u\n    ) === !1)\n      return !1;\n    r.lineIndex = l, r.controlIndex = c, r.isControl = i, r.isLine = a, Re(t, e);\n    const {\n      roundRelative: d,\n      minRoundControls: p = [0, 0]\n    } = t.props, g = t.state, {\n      width: h,\n      height: v\n    } = g;\n    r.isRound = !0, r.prevDist = [0, 0];\n    const m = Co(t), S = So(\n      m || \"\",\n      h,\n      v,\n      p,\n      !0\n    ) || [];\n    return r.controlPoses = S, g.borderRadiusState = Ds(\n      S,\n      d,\n      h,\n      v\n    ).styles.join(\" \"), u;\n  },\n  dragControl(t, e) {\n    const { datas: n } = e, r = n.controlPoses;\n    if (!n.isRound || !n.isControl || !r.length)\n      return !1;\n    const s = n.controlIndex, [o, i] = Qt(e), a = [o, i], c = K(a, n.prevDist), {\n      maxRoundControls: l = [4, 4]\n    } = t.props, { width: u, height: f } = t.state, d = r[s], p = d.vertical, g = d.horizontal, h = r.map((m) => {\n      const { horizontal: S, vertical: x } = m, C = [\n        S * g * a[0],\n        x * p * a[1]\n      ];\n      if (S) {\n        if (l[0] === 1)\n          return C;\n        if (l[0] < 4 && S !== g)\n          return C;\n      } else {\n        if (l[1] === 0)\n          return C[1] = x * g * a[0] / u * f, C;\n        if (p) {\n          if (l[1] === 1)\n            return C;\n          if (l[1] < 4 && x !== p)\n            return C;\n        }\n      }\n      return [0, 0];\n    });\n    h[s] = a;\n    const v = r.map((m, S) => ({\n      ...m,\n      pos: at(m.pos, h[S])\n    }));\n    return s < 4 ? v.slice(0, s + 1).forEach((m) => {\n      m.virtual = !1;\n    }) : v.slice(4, s + 1).forEach((m) => {\n      m.virtual = !1;\n    }), n.prevDist = [o, i], Eo(\n      t,\n      e,\n      a,\n      c,\n      v\n    );\n  },\n  dragControlEnd(t, e) {\n    const n = t.state;\n    n.borderRadiusState = \"\";\n    const { datas: r, isDouble: s } = e;\n    if (!r.isRound)\n      return !1;\n    const {\n      isControl: o,\n      controlIndex: i,\n      isLine: a,\n      lineIndex: c\n    } = r, l = r.controlPoses, u = l.filter(({ virtual: p }) => p).length, {\n      roundClickable: f = !0\n    } = t.props;\n    if (s && f) {\n      if (o && (f === !0 || f === \"control\"))\n        sf(l, i);\n      else if (a && (f === !0 || f === \"line\")) {\n        const [p, g] = ni(t, e);\n        nf(l, c, p, g);\n      }\n      u !== l.filter(({ virtual: p }) => p).length && Eo(\n        t,\n        e,\n        [0, 0],\n        [0, 0],\n        l\n      );\n    }\n    const d = $t(t, e, {});\n    return j(t, \"onRoundEnd\", d), n.borderRadiusState = \"\", d;\n  },\n  dragGroupControlStart(t, e) {\n    const n = this.dragControlStart(t, e);\n    if (!n)\n      return !1;\n    const r = t.moveables, s = t.props.targets, o = Ht(t, \"roundable\", e), i = {\n      targets: t.props.targets,\n      events: o.map((a, c) => ({\n        ...a,\n        target: s[c],\n        moveable: r[c],\n        currentTarget: r[c]\n      })),\n      ...n\n    };\n    return j(t, \"onRoundGroupStart\", i), n;\n  },\n  dragGroupControl(t, e) {\n    const n = this.dragControl(t, e);\n    if (!n)\n      return !1;\n    const r = t.moveables, s = t.props.targets, o = Ht(t, \"roundable\", e), i = {\n      targets: t.props.targets,\n      events: o.map((a, c) => ({\n        ...a,\n        target: s[c],\n        moveable: r[c],\n        currentTarget: r[c],\n        ...It({\n          borderRadius: n.borderRadius\n        }, a)\n      })),\n      ...n\n    };\n    return j(t, \"onRoundGroup\", i), i;\n  },\n  dragGroupControlEnd(t, e) {\n    const n = t.moveables, r = t.props.targets, s = Ht(t, \"roundable\", e);\n    Qn(t, \"onRound\", (a) => {\n      const c = {\n        targets: t.props.targets,\n        events: s.map((l, u) => ({\n          ...l,\n          target: r[u],\n          moveable: n[u],\n          currentTarget: n[u],\n          ...It({\n            borderRadius: a.borderRadius\n          }, l)\n        })),\n        ...a\n      };\n      j(t, \"onRoundGroup\", c);\n    });\n    const o = this.dragControlEnd(t, e);\n    if (!o)\n      return !1;\n    const i = {\n      targets: t.props.targets,\n      events: s.map((a, c) => {\n        var l;\n        return {\n          ...a,\n          target: r[c],\n          moveable: n[c],\n          currentTarget: n[c],\n          lastEvent: (l = a.datas) == null ? void 0 : l.lastEvent\n        };\n      }),\n      ...o\n    };\n    return j(t, \"onRoundGroupEnd\", i), i;\n  },\n  unset(t) {\n    t.state.borderRadiusState = \"\";\n  }\n};\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Nr = function(t, e) {\n  return Nr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {\n    n.__proto__ = r;\n  } || function(n, r) {\n    for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);\n  }, Nr(t, e);\n};\nfunction af(t, e) {\n  Nr(t, e);\n  function n() {\n    this.constructor = t;\n  }\n  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());\n}\nvar Ct = function() {\n  return Ct = Object.assign || function(e) {\n    for (var n, r = 1, s = arguments.length; r < s; r++) {\n      n = arguments[r];\n      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);\n    }\n    return e;\n  }, Ct.apply(this, arguments);\n};\nfunction cf(t, e) {\n  var n = e[0] - t[0], r = e[1] - t[1], s = Math.atan2(r, n);\n  return s >= 0 ? s : s + Math.PI * 2;\n}\nfunction vr(t) {\n  return cf([\n    t[0].clientX,\n    t[0].clientY\n  ], [\n    t[1].clientX,\n    t[1].clientY\n  ]) / Math.PI * 180;\n}\nfunction lf(t) {\n  return t.touches && t.touches.length >= 2;\n}\nfunction On(t) {\n  return t ? t.touches ? ff(t.touches) : [na(t)] : [];\n}\nfunction uf(t) {\n  return t && (t.type.indexOf(\"mouse\") > -1 || \"button\" in t);\n}\nfunction Do(t, e, n) {\n  var r = n.length, s = rn(t, r), o = s.clientX, i = s.clientY, a = s.originalClientX, c = s.originalClientY, l = rn(e, r), u = l.clientX, f = l.clientY, d = rn(n, r), p = d.clientX, g = d.clientY, h = o - u, v = i - f, m = o - p, S = i - g;\n  return {\n    clientX: a,\n    clientY: c,\n    deltaX: h,\n    deltaY: v,\n    distX: m,\n    distY: S\n  };\n}\nfunction mr(t) {\n  return Math.sqrt(Math.pow(t[0].clientX - t[1].clientX, 2) + Math.pow(t[0].clientY - t[1].clientY, 2));\n}\nfunction ff(t) {\n  for (var e = Math.min(t.length, 2), n = [], r = 0; r < e; ++r)\n    n.push(na(t[r]));\n  return n;\n}\nfunction na(t) {\n  return {\n    clientX: t.clientX,\n    clientY: t.clientY\n  };\n}\nfunction rn(t, e) {\n  e === void 0 && (e = t.length);\n  for (var n = {\n    clientX: 0,\n    clientY: 0,\n    originalClientX: 0,\n    originalClientY: 0\n  }, r = Math.min(t.length, e), s = 0; s < r; ++s) {\n    var o = t[s];\n    n.originalClientX += \"originalClientX\" in o ? o.originalClientX : o.clientX, n.originalClientY += \"originalClientY\" in o ? o.originalClientY : o.clientY, n.clientX += o.clientX, n.clientY += o.clientY;\n  }\n  return e ? {\n    clientX: n.clientX / e,\n    clientY: n.clientY / e,\n    originalClientX: n.originalClientX / e,\n    originalClientY: n.originalClientY / e\n  } : n;\n}\nvar xr = /* @__PURE__ */ function() {\n  function t(e) {\n    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = e, this.prevClients = e, this.length = e.length;\n  }\n  return t.prototype.getAngle = function(e) {\n    return e === void 0 && (e = this.prevClients), vr(e);\n  }, t.prototype.getRotation = function(e) {\n    return e === void 0 && (e = this.prevClients), vr(e) - vr(this.startClients);\n  }, t.prototype.getPosition = function(e, n) {\n    e === void 0 && (e = this.prevClients);\n    var r = Do(e || this.prevClients, this.prevClients, this.startClients), s = r.deltaX, o = r.deltaY;\n    return this.movement += Math.sqrt(s * s + o * o), this.prevClients = e, r;\n  }, t.prototype.getPositions = function(e) {\n    e === void 0 && (e = this.prevClients);\n    for (var n = this.prevClients, r = this.startClients, s = Math.min(this.length, n.length), o = [], i = 0; i < s; ++i)\n      o[i] = Do([e[i]], [n[i]], [r[i]]);\n    return o;\n  }, t.prototype.getMovement = function(e) {\n    var n = this.movement;\n    if (!e)\n      return n;\n    var r = rn(e, this.length), s = rn(this.prevClients, this.length), o = r.clientX - s.clientX, i = r.clientY - s.clientY;\n    return Math.sqrt(o * o + i * i) + n;\n  }, t.prototype.getDistance = function(e) {\n    return e === void 0 && (e = this.prevClients), mr(e);\n  }, t.prototype.getScale = function(e) {\n    return e === void 0 && (e = this.prevClients), mr(e) / mr(this.startClients);\n  }, t.prototype.move = function(e, n) {\n    this.startClients.forEach(function(r) {\n      r.clientX -= e, r.clientY -= n;\n    }), this.prevClients.forEach(function(r) {\n      r.clientX -= e, r.clientY -= n;\n    });\n  }, t;\n}(), bo = [\"textarea\", \"input\"], df = /* @__PURE__ */ function(t) {\n  af(e, t);\n  function e(n, r) {\n    r === void 0 && (r = {});\n    var s = t.call(this) || this;\n    s.options = {}, s.flag = !1, s.pinchFlag = !1, s.data = {}, s.isDrag = !1, s.isPinch = !1, s.clientStores = [], s.targets = [], s.prevTime = 0, s.doubleFlag = !1, s._useMouse = !1, s._useTouch = !1, s._useDrag = !1, s._dragFlag = !1, s._isTrusted = !1, s._isMouseEvent = !1, s._isSecondaryButton = !1, s._preventMouseEvent = !1, s._prevInputEvent = null, s._isDragAPI = !1, s._isIdle = !0, s._preventMouseEventId = 0, s._window = window, s.onDragStart = function(d, p) {\n      if (p === void 0 && (p = !0), !(!s.flag && d.cancelable === !1)) {\n        var g = d.type.indexOf(\"drag\") >= -1;\n        if (!(s.flag && g)) {\n          s._isDragAPI = !0;\n          var h = s.options, v = h.container, m = h.pinchOutside, S = h.preventWheelClick, x = h.preventRightClick, C = h.preventDefault, E = h.checkInput, D = h.dragFocusedInput, R = h.preventClickEventOnDragStart, y = h.preventClickEventOnDrag, M = h.preventClickEventByCondition, P = s._useTouch, _ = !s.flag;\n          if (s._isSecondaryButton = d.which === 3 || d.button === 2, S && (d.which === 2 || d.button === 1) || x && (d.which === 3 || d.button === 2))\n            return s.stop(), !1;\n          if (_) {\n            var O = s._window.document.activeElement, T = d.target;\n            if (T) {\n              var w = T.tagName.toLowerCase(), k = bo.indexOf(w) > -1, I = T.isContentEditable;\n              if (k || I) {\n                if (E || !D && O === T)\n                  return !1;\n                if (O && (O === T || I && O.isContentEditable && O.contains(T)))\n                  if (D)\n                    T.blur();\n                  else\n                    return !1;\n              } else if ((C || d.type === \"touchstart\") && O) {\n                var $ = O.tagName.toLowerCase();\n                (O.isContentEditable || bo.indexOf($) > -1) && O.blur();\n              }\n              (R || y || M) && Pt(s._window, \"click\", s._onClick, !0);\n            }\n            s.clientStores = [new xr(On(d))], s._isIdle = !1, s.flag = !0, s.isDrag = !1, s._isTrusted = p, s._dragFlag = !0, s._prevInputEvent = d, s.data = {}, s.doubleFlag = cn() - s.prevTime < 200, s._isMouseEvent = uf(d), !s._isMouseEvent && s._preventMouseEvent && s._allowMouseEvent();\n            var G = s._preventMouseEvent || s.emit(\"dragStart\", Ct(Ct({ data: s.data, datas: s.data, inputEvent: d, isMouseEvent: s._isMouseEvent, isSecondaryButton: s._isSecondaryButton, isTrusted: p, isDouble: s.doubleFlag }, s.getCurrentStore().getPosition()), { preventDefault: function() {\n              d.preventDefault();\n            }, preventDrag: function() {\n              s._dragFlag = !1;\n            } }));\n            G === !1 && s.stop(), s._isMouseEvent && s.flag && C && d.preventDefault();\n          }\n          if (!s.flag)\n            return !1;\n          var L = 0;\n          if (_ ? (s._attchDragEvent(), P && m && (L = setTimeout(function() {\n            Pt(v, \"touchstart\", s.onDragStart, {\n              passive: !1\n            });\n          }))) : P && m && Mt(v, \"touchstart\", s.onDragStart), s.flag && lf(d)) {\n            if (clearTimeout(L), _ && d.touches.length !== d.changedTouches.length)\n              return;\n            s.pinchFlag || s.onPinchStart(d);\n          }\n        }\n      }\n    }, s.onDrag = function(d, p) {\n      if (s.flag) {\n        var g = s.options.preventDefault;\n        !s._isMouseEvent && g && d.preventDefault(), s._prevInputEvent = d;\n        var h = On(d), v = s.moveClients(h, d, !1);\n        if (s._dragFlag) {\n          if (s.pinchFlag || v.deltaX || v.deltaY) {\n            var m = s._preventMouseEvent || s.emit(\"drag\", Ct(Ct({}, v), { isScroll: !!p, inputEvent: d }));\n            if (m === !1) {\n              s.stop();\n              return;\n            }\n          }\n          s.pinchFlag && s.onPinch(d, h);\n        }\n        s.getCurrentStore().getPosition(h, !0);\n      }\n    }, s.onDragEnd = function(d) {\n      if (s.flag) {\n        var p = s.options, g = p.pinchOutside, h = p.container, v = p.preventClickEventOnDrag, m = p.preventClickEventOnDragStart, S = p.preventClickEventByCondition, x = s.isDrag;\n        (v || m || S) && requestAnimationFrame(function() {\n          s._allowClickEvent();\n        }), !S && !m && v && !x && s._allowClickEvent(), s._useTouch && g && Mt(h, \"touchstart\", s.onDragStart), s.pinchFlag && s.onPinchEnd(d);\n        var C = d != null && d.touches ? On(d) : [], E = C.length;\n        E === 0 || !s.options.keepDragging ? s.flag = !1 : s._addStore(new xr(C));\n        var D = s._getPosition(), R = cn(), y = !x && s.doubleFlag;\n        s._prevInputEvent = null, s.prevTime = x || y ? 0 : R, s.flag || (s._dettachDragEvent(), s._preventMouseEvent || s.emit(\"dragEnd\", Ct({ data: s.data, datas: s.data, isDouble: y, isDrag: x, isClick: !x, isMouseEvent: s._isMouseEvent, isSecondaryButton: s._isSecondaryButton, inputEvent: d, isTrusted: s._isTrusted }, D)), s.clientStores = [], s._isMouseEvent || (s._preventMouseEvent = !0, clearTimeout(s._preventMouseEventId), s._preventMouseEventId = setTimeout(function() {\n          s._preventMouseEvent = !1;\n        }, 200)), s._isIdle = !0);\n      }\n    }, s.onBlur = function() {\n      s.onDragEnd();\n    }, s._allowClickEvent = function() {\n      Mt(s._window, \"click\", s._onClick, !0);\n    }, s._onClick = function(d) {\n      s._allowClickEvent(), s._allowMouseEvent();\n      var p = s.options.preventClickEventByCondition;\n      p != null && p(d) || (d.stopPropagation(), d.preventDefault());\n    }, s._onContextMenu = function(d) {\n      var p = s.options;\n      p.preventRightClick ? s.onDragEnd(d) : d.preventDefault();\n    }, s._passCallback = function() {\n    };\n    var o = [].concat(n), i = o[0];\n    s._window = Jo(i) ? i : ae(i), s.options = Ct({ checkInput: !1, container: i && !(\"document\" in i) ? ae(i) : i, preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: [\"touch\", \"mouse\"] }, r);\n    var a = s.options, c = a.container, l = a.events, u = a.checkWindowBlur;\n    if (s._useDrag = l.indexOf(\"drag\") > -1, s._useTouch = l.indexOf(\"touch\") > -1, s._useMouse = l.indexOf(\"mouse\") > -1, s.targets = o, s._useDrag && o.forEach(function(d) {\n      Pt(d, \"dragstart\", s.onDragStart);\n    }), s._useMouse && (o.forEach(function(d) {\n      Pt(d, \"mousedown\", s.onDragStart), Pt(d, \"mousemove\", s._passCallback);\n    }), Pt(c, \"contextmenu\", s._onContextMenu)), u && Pt(ae(), \"blur\", s.onBlur), s._useTouch) {\n      var f = {\n        passive: !1\n      };\n      o.forEach(function(d) {\n        Pt(d, \"touchstart\", s.onDragStart, f), Pt(d, \"touchmove\", s._passCallback, f);\n      });\n    }\n    return s;\n  }\n  return e.prototype.stop = function() {\n    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._isIdle = !0, this._allowClickEvent(), this._dettachDragEvent(), this._isDragAPI = !1;\n  }, e.prototype.getMovement = function(n) {\n    return this.getCurrentStore().getMovement(n) + this.clientStores.slice(1).reduce(function(r, s) {\n      return r + s.movement;\n    }, 0);\n  }, e.prototype.isDragging = function() {\n    return this.isDrag;\n  }, e.prototype.isIdle = function() {\n    return this._isIdle;\n  }, e.prototype.isFlag = function() {\n    return this.flag;\n  }, e.prototype.isPinchFlag = function() {\n    return this.pinchFlag;\n  }, e.prototype.isDoubleFlag = function() {\n    return this.doubleFlag;\n  }, e.prototype.isPinching = function() {\n    return this.isPinch;\n  }, e.prototype.scrollBy = function(n, r, s, o) {\n    o === void 0 && (o = !0), this.flag && (this.clientStores[0].move(n, r), o && this.onDrag(s, !0));\n  }, e.prototype.move = function(n, r) {\n    var s = n[0], o = n[1], i = this.getCurrentStore(), a = i.prevClients;\n    return this.moveClients(a.map(function(c) {\n      var l = c.clientX, u = c.clientY;\n      return {\n        clientX: l + s,\n        clientY: u + o,\n        originalClientX: l,\n        originalClientY: u\n      };\n    }), r, !0);\n  }, e.prototype.triggerDragStart = function(n) {\n    this.onDragStart(n, !1);\n  }, e.prototype.setEventData = function(n) {\n    var r = this.data;\n    for (var s in n)\n      r[s] = n[s];\n    return this;\n  }, e.prototype.setEventDatas = function(n) {\n    return this.setEventData(n);\n  }, e.prototype.getCurrentEvent = function(n) {\n    return n === void 0 && (n = this._prevInputEvent), Ct(Ct({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: n });\n  }, e.prototype.getEventData = function() {\n    return this.data;\n  }, e.prototype.getEventDatas = function() {\n    return this.data;\n  }, e.prototype.unset = function() {\n    var n = this, r = this.targets, s = this.options.container;\n    this.off(), Mt(this._window, \"blur\", this.onBlur), this._useDrag && r.forEach(function(o) {\n      Mt(o, \"dragstart\", n.onDragStart);\n    }), this._useMouse && (r.forEach(function(o) {\n      Mt(o, \"mousedown\", n.onDragStart);\n    }), Mt(s, \"contextmenu\", this._onContextMenu)), this._useTouch && (r.forEach(function(o) {\n      Mt(o, \"touchstart\", n.onDragStart);\n    }), Mt(s, \"touchstart\", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();\n  }, e.prototype.onPinchStart = function(n) {\n    var r = this, s = this.options.pinchThreshold;\n    if (!(this.isDrag && this.getMovement() > s)) {\n      var o = new xr(On(n));\n      this.pinchFlag = !0, this._addStore(o);\n      var i = this.emit(\"pinchStart\", Ct(Ct({ data: this.data, datas: this.data, angle: o.getAngle(), touches: this.getCurrentStore().getPositions() }, o.getPosition()), { inputEvent: n, isTrusted: this._isTrusted, preventDefault: function() {\n        n.preventDefault();\n      }, preventDrag: function() {\n        r._dragFlag = !1;\n      } }));\n      i === !1 && (this.pinchFlag = !1);\n    }\n  }, e.prototype.onPinch = function(n, r) {\n    if (!(!this.flag || !this.pinchFlag || r.length < 2)) {\n      var s = this.getCurrentStore();\n      this.isPinch = !0, this.emit(\"pinch\", Ct(Ct({ data: this.data, datas: this.data, movement: this.getMovement(r), angle: s.getAngle(r), rotation: s.getRotation(r), touches: s.getPositions(r), scale: s.getScale(r), distance: s.getDistance(r) }, s.getPosition(r)), { inputEvent: n, isTrusted: this._isTrusted }));\n    }\n  }, e.prototype.onPinchEnd = function(n) {\n    if (this.pinchFlag) {\n      var r = this.isPinch;\n      this.isPinch = !1, this.pinchFlag = !1;\n      var s = this.getCurrentStore();\n      this.emit(\"pinchEnd\", Ct(Ct({ data: this.data, datas: this.data, isPinch: r, touches: s.getPositions() }, s.getPosition()), { inputEvent: n }));\n    }\n  }, e.prototype.getCurrentStore = function() {\n    return this.clientStores[0];\n  }, e.prototype.moveClients = function(n, r, s) {\n    var o = this._getPosition(n, s), i = this.isDrag;\n    (o.deltaX || o.deltaY) && (this.isDrag = !0);\n    var a = !1;\n    return !i && this.isDrag && (a = !0), Ct(Ct({ data: this.data, datas: this.data }, o), { movement: this.getMovement(n), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: r, isTrusted: this._isTrusted, isFirstDrag: a });\n  }, e.prototype._addStore = function(n) {\n    this.clientStores.splice(0, 0, n);\n  }, e.prototype._getPosition = function(n, r) {\n    var s = this.getCurrentStore(), o = s.getPosition(n, r), i = this.clientStores.slice(1).reduce(function(l, u) {\n      var f = u.getPosition();\n      return l.distX += f.distX, l.distY += f.distY, l;\n    }, o), a = i.distX, c = i.distY;\n    return Ct(Ct({}, o), { distX: a, distY: c });\n  }, e.prototype._attchDragEvent = function() {\n    var n = this._window, r = this.options.container, s = {\n      passive: !1\n    };\n    this._isDragAPI && (Pt(r, \"dragover\", this.onDrag, s), Pt(n, \"dragend\", this.onDragEnd)), this._useMouse && (Pt(r, \"mousemove\", this.onDrag), Pt(n, \"mouseup\", this.onDragEnd)), this._useTouch && (Pt(r, \"touchmove\", this.onDrag, s), Pt(n, \"touchend\", this.onDragEnd, s), Pt(n, \"touchcancel\", this.onDragEnd, s));\n  }, e.prototype._dettachDragEvent = function() {\n    var n = this._window, r = this.options.container;\n    this._isDragAPI && (Mt(r, \"dragover\", this.onDrag), Mt(n, \"dragend\", this.onDragEnd)), this._useMouse && (Mt(r, \"mousemove\", this.onDrag), Mt(n, \"mouseup\", this.onDragEnd)), this._useTouch && (Mt(r, \"touchstart\", this.onDragStart), Mt(r, \"touchmove\", this.onDrag), Mt(n, \"touchend\", this.onDragEnd), Mt(n, \"touchcancel\", this.onDragEnd));\n  }, e.prototype._allowMouseEvent = function() {\n    this._preventMouseEvent = !1, clearTimeout(this._preventMouseEventId);\n  }, e;\n}(Cs);\nfunction pf(t, e) {\n  const r = gt(e ? 4 : 3), s = `matrix${e ? \"3d\" : \"\"}(${r.join(\",\")})`;\n  return t === s || t === \"matrix(1,0,0,1,0,0)\";\n}\nconst ra = {\n  isPinch: !0,\n  name: \"beforeRenderable\",\n  props: [],\n  events: [\n    \"beforeRenderStart\",\n    \"beforeRender\",\n    \"beforeRenderEnd\",\n    \"beforeRenderGroupStart\",\n    \"beforeRenderGroup\",\n    \"beforeRenderGroupEnd\"\n  ],\n  dragRelation: \"weak\",\n  setTransform(t, e) {\n    const {\n      is3d: n,\n      targetMatrix: r,\n      inlineTransform: s\n    } = t.state, o = n ? `matrix3d(${r.join(\",\")})` : `matrix(${ei(r, !0)})`, i = !s || s === \"none\" ? o : s;\n    e.datas.startTransforms = pf(i, n) ? [] : ce(i);\n  },\n  resetStyle(t) {\n    const e = t.datas;\n    e.nextStyle = {}, e.nextTransforms = t.datas.startTransforms, e.nextTransformAppendedIndexes = [];\n  },\n  fillDragStartParams(t, e) {\n    return et(t, e, {\n      setTransform: (n) => {\n        e.datas.startTransforms = Rt(n) ? n : ce(n);\n      },\n      isPinch: !!e.isPinch\n    });\n  },\n  fillDragParams(t, e) {\n    return et(t, e, {\n      isPinch: !!e.isPinch\n    });\n  },\n  dragStart(t, e) {\n    this.setTransform(t, e), this.resetStyle(e), j(t, \"onBeforeRenderStart\", this.fillDragStartParams(t, e));\n  },\n  drag(t, e) {\n    e.datas.startTransforms || this.setTransform(t, e), this.resetStyle(e), j(t, \"onBeforeRender\", et(t, e, {\n      isPinch: !!e.isPinch\n    }));\n  },\n  dragEnd(t, e) {\n    e.datas.startTransforms || (this.setTransform(t, e), this.resetStyle(e)), j(t, \"onBeforeRenderEnd\", et(t, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag\n    }));\n  },\n  dragGroupStart(t, e) {\n    this.dragStart(t, e);\n    const n = Ht(t, \"beforeRenderable\", e), r = t.moveables, s = n.map((o, i) => {\n      const a = r[i];\n      return this.setTransform(a, o), this.resetStyle(o), this.fillDragStartParams(a, o);\n    });\n    j(t, \"onBeforeRenderGroupStart\", et(t, e, {\n      isPinch: !!e.isPinch,\n      targets: t.props.targets,\n      setTransform() {\n      },\n      events: s\n    }));\n  },\n  dragGroup(t, e) {\n    this.drag(t, e);\n    const n = Ht(t, \"beforeRenderable\", e), r = t.moveables, s = n.map((o, i) => {\n      const a = r[i];\n      return this.resetStyle(o), this.fillDragParams(a, o);\n    });\n    j(t, \"onBeforeRenderGroup\", et(t, e, {\n      isPinch: !!e.isPinch,\n      targets: t.props.targets,\n      events: s\n    }));\n  },\n  dragGroupEnd(t, e) {\n    this.dragEnd(t, e), j(t, \"onBeforeRenderGroupEnd\", et(t, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag,\n      targets: t.props.targets\n    }));\n  },\n  dragControlStart(t, e) {\n    return this.dragStart(t, e);\n  },\n  dragControl(t, e) {\n    return this.drag(t, e);\n  },\n  dragControlEnd(t, e) {\n    return this.dragEnd(t, e);\n  },\n  dragGroupControlStart(t, e) {\n    return this.dragGroupStart(t, e);\n  },\n  dragGroupControl(t, e) {\n    return this.dragGroup(t, e);\n  },\n  dragGroupControlEnd(t, e) {\n    return this.dragGroupEnd(t, e);\n  }\n}, sa = {\n  name: \"renderable\",\n  props: [],\n  events: [\n    \"renderStart\",\n    \"render\",\n    \"renderEnd\",\n    \"renderGroupStart\",\n    \"renderGroup\",\n    \"renderGroupEnd\"\n  ],\n  dragRelation: \"weak\",\n  dragStart(t, e) {\n    j(t, \"onRenderStart\", et(t, e, {\n      isPinch: !!e.isPinch\n    }));\n  },\n  drag(t, e) {\n    j(t, \"onRender\", this.fillDragParams(t, e));\n  },\n  dragAfter(t, e) {\n    return this.drag(t, e);\n  },\n  dragEnd(t, e) {\n    j(t, \"onRenderEnd\", this.fillDragEndParams(t, e));\n  },\n  dragGroupStart(t, e) {\n    j(t, \"onRenderGroupStart\", et(t, e, {\n      isPinch: !!e.isPinch,\n      targets: t.props.targets\n    }));\n  },\n  dragGroup(t, e) {\n    const n = Ht(t, \"beforeRenderable\", e), r = t.moveables, s = n.map((o, i) => {\n      const a = r[i];\n      return this.fillDragParams(a, o);\n    });\n    j(t, \"onRenderGroup\", et(t, e, {\n      isPinch: !!e.isPinch,\n      targets: t.props.targets,\n      transform: Dn(e),\n      transformObject: {},\n      ...It(bn(e)),\n      events: s\n    }));\n  },\n  dragGroupEnd(t, e) {\n    const n = Ht(t, \"beforeRenderable\", e), r = t.moveables, s = n.map((o, i) => {\n      const a = r[i];\n      return this.fillDragEndParams(a, o);\n    });\n    j(t, \"onRenderGroupEnd\", et(t, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag,\n      targets: t.props.targets,\n      events: s,\n      transformObject: {},\n      transform: Dn(e),\n      ...It(bn(e))\n    }));\n  },\n  dragControlStart(t, e) {\n    return this.dragStart(t, e);\n  },\n  dragControl(t, e) {\n    return this.drag(t, e);\n  },\n  dragControlAfter(t, e) {\n    return this.dragAfter(t, e);\n  },\n  dragControlEnd(t, e) {\n    return this.dragEnd(t, e);\n  },\n  dragGroupControlStart(t, e) {\n    return this.dragGroupStart(t, e);\n  },\n  dragGroupControl(t, e) {\n    return this.dragGroup(t, e);\n  },\n  dragGroupControlEnd(t, e) {\n    return this.dragGroupEnd(t, e);\n  },\n  fillDragParams(t, e) {\n    const n = {};\n    return $e(Gn(e) || []).forEach((r) => {\n      n[r.name] = r.functionValue;\n    }), et(t, e, {\n      isPinch: !!e.isPinch,\n      transformObject: n,\n      transform: Dn(e),\n      ...It(bn(e))\n    });\n  },\n  fillDragEndParams(t, e) {\n    const n = {};\n    return $e(Gn(e) || []).forEach((r) => {\n      n[r.name] = r.functionValue;\n    }), et(t, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag,\n      transformObject: n,\n      transform: Dn(e),\n      ...It(bn(e))\n    });\n  }\n};\nfunction sn(t, e, n, r, s, o, i) {\n  o.clientDistX = o.distX, o.clientDistY = o.distY;\n  const a = s === \"Start\", c = s === \"End\", l = s === \"After\", u = t.state.target, f = o.isRequest, d = r.indexOf(\"Control\") > -1;\n  if (!u || a && d && !f && t.areaElement === o.inputEvent.target)\n    return !1;\n  const p = [...e];\n  if (f) {\n    const P = o.requestAble;\n    p.some((_) => _.name === P) || p.push(...t.props.ables.filter((_) => _.name === P));\n  }\n  if (!p.length || p.every((P) => P.dragRelation))\n    return !1;\n  const g = o.inputEvent;\n  let h;\n  c && g && (h = document.elementFromPoint(o.clientX, o.clientY) || g.target);\n  let v = !1;\n  const m = () => {\n    var P;\n    v = !0, (P = o.stop) == null || P.call(o);\n  }, S = a && (!t.targetGesto || !t.controlGesto || !t.targetGesto.isFlag() || !t.controlGesto.isFlag());\n  S && t.updateRect(s, !0, !1);\n  const x = o.datas, C = d ? \"controlGesto\" : \"targetGesto\", E = t[C], D = (P, _, O) => {\n    if (!(_ in P) || E !== t[C])\n      return !1;\n    const T = P.name, w = x[T] || (x[T] = {});\n    if (a && (w.isEventStart = !O || !P[O] || P[O](t, o)), !w.isEventStart)\n      return !1;\n    const k = P[_](t, {\n      ...o,\n      stop: m,\n      datas: w,\n      originalDatas: x,\n      inputTarget: h\n    });\n    return t._emitter.off(), a && k === !1 && (w.isEventStart = !1), k;\n  };\n  S && p.forEach((P) => {\n    P.unset && P.unset(t);\n  }), D(ra, `drag${r}${s}`);\n  let R = 0, y = 0;\n  n.forEach((P) => {\n    if (v)\n      return !1;\n    const _ = `${P}${r}${s}`, O = `${P}${r}Condition`;\n    s === \"\" && !f && xu(t.state, o);\n    let T = p.filter((I) => I[_]);\n    T = T.filter((I, $) => I.name && T.indexOf(I) === $);\n    const k = T.filter((I) => D(I, _, O)).length;\n    v && ++R, k && ++y, !v && a && T.length && !k && (R += T.filter((I) => {\n      const $ = I.name;\n      return x[$].isEventStart ? I.dragRelation !== \"strong\" : !1;\n    }).length ? 1 : 0);\n  }), (!l || y) && D(sa, `drag${r}${s}`);\n  const M = E !== t[C] || R === n.length;\n  return (c || v || M) && (t.state.gestos = {}, t.moveables && t.moveables.forEach((P) => {\n    P.state.gestos = {};\n  }), p.forEach((P) => {\n    P.unset && P.unset(t);\n  })), a && !M && !f && y && t.props.preventDefault && (o == null || o.preventDefault()), t.isUnmounted || M ? !1 : ((!a && y && !i || c) && (t.props.flushSync || Bi)(() => {\n    t.updateRect(c ? s : \"\", !0, !1), t.forceUpdate();\n  }), !a && !c && !l && y && !i && sn(t, e, n, r, s + \"After\", o), !0);\n}\nfunction Rs(t, e) {\n  return (n, r = n.inputEvent.target) => {\n    var a;\n    const s = r, o = t.areaElement, i = t._dragTarget;\n    return !i || !e && ((a = t.controlGesto) != null && a.isFlag()) ? !1 : s === i || i.contains(s) || s === o || !t.isMoveableElement(s) && !t.controlBox.contains(s) || bt(s, \"moveable-area\") || bt(s, \"moveable-padding\") || bt(s, \"moveable-edgeDraggable\");\n  };\n}\nfunction oa(t, e, n) {\n  const r = t.controlBox, s = [], o = t.props, i = o.dragArea, a = t.state.target, c = o.dragTarget;\n  s.push(r), (!i || c) && s.push(e), !i && c && a && e !== a && o.dragTargetSelf && s.push(a);\n  const l = Rs(t);\n  return aa(t, s, \"targetAbles\", n, {\n    dragStart: l,\n    pinchStart: l\n  });\n}\nfunction ia(t, e) {\n  const n = t.controlBox, r = [];\n  r.push(n);\n  const s = Rs(t, !0), o = (i, a = i.inputEvent.target) => a === n ? !0 : !s(i, a);\n  return aa(t, r, \"controlAbles\", e, {\n    dragStart: o,\n    pinchStart: o\n  });\n}\nfunction aa(t, e, n, r, s = {}) {\n  const o = n === \"targetAbles\", {\n    pinchOutside: i,\n    pinchThreshold: a,\n    preventClickEventOnDrag: c,\n    preventClickDefault: l,\n    checkInput: u,\n    dragFocusedInput: f,\n    preventDefault: d = !0,\n    preventRightClick: p = !0,\n    preventWheelClick: g = !0,\n    dragContainer: h\n  } = t.props, v = Zt(h, !0), m = {\n    preventDefault: d,\n    preventRightClick: p,\n    preventWheelClick: g,\n    container: v || ae(t.getControlBoxElement()),\n    pinchThreshold: a,\n    pinchOutside: i,\n    preventClickEventOnDrag: o ? c : !1,\n    preventClickEventOnDragStart: o ? l : !1,\n    preventClickEventByCondition: o ? null : (C) => t.controlBox.contains(C.target),\n    checkInput: o ? u : !1,\n    dragFocusedInput: f\n  }, S = new df(e, m), x = r === \"Control\";\n  return [\"drag\", \"pinch\"].forEach((C) => {\n    [\"Start\", \"\", \"End\"].forEach((E) => {\n      S.on(`${C}${E}`, (D) => {\n        var O;\n        const R = D.eventType, y = C === \"drag\" && D.isPinch;\n        if (s[R] && !s[R](D)) {\n          D.stop();\n          return;\n        }\n        if (y)\n          return;\n        const M = C === \"drag\" ? [C] : [\"drag\", C], P = [...t[n]];\n        sn(t, P, M, r, E, D) ? (t.props.stopPropagation || E === \"Start\" && x) && ((O = D == null ? void 0 : D.inputEvent) == null || O.stopPropagation()) : D.stop();\n      });\n    });\n  }), S;\n}\nclass gf {\n  constructor(e, n, r) {\n    X(this, \"ables\", []);\n    X(this, \"_onEvent\", (e) => {\n      const n = this.eventName, r = this.moveable;\n      r.state.disableNativeEvent || this.ables.forEach((s) => {\n        s[n](r, {\n          inputEvent: e\n        });\n      });\n    });\n    this.target = e, this.moveable = n, this.eventName = r, e.addEventListener(r.toLowerCase(), this._onEvent);\n  }\n  setAbles(e) {\n    this.ables = e;\n  }\n  destroy() {\n    this.target.removeEventListener(\n      this.eventName.toLowerCase(),\n      this._onEvent\n    ), this.target = null, this.moveable = null;\n  }\n}\nfunction hf(t) {\n  for (var e = 5381, n = t.length; n; )\n    e = e * 33 ^ t.charCodeAt(--n);\n  return e >>> 0;\n}\nvar vf = hf;\nfunction mf(t) {\n  return vf(t).toString(36);\n}\nfunction xf(t) {\n  if (t && t.getRootNode) {\n    var e = t.getRootNode();\n    if (e.nodeType === 11)\n      return e;\n  }\n}\nfunction Sf(t, e, n) {\n  return n.original ? e : e.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, function(r, s) {\n    var o = s.trim();\n    return (o ? xe(o) : [\"\"]).map(function(i) {\n      var a = i.trim();\n      return a.indexOf(\"@\") === 0 ? a : a.indexOf(\":global\") > -1 ? a.replace(/\\:global/g, \"\") : a.indexOf(\":host\") > -1 ? \"\".concat(a.replace(/\\:host/g, \".\".concat(t))) : a ? \".\".concat(t, \" \").concat(a) : \".\".concat(t);\n    }).join(\", \") + \" {\";\n  });\n}\nfunction Ef(t, e, n, r, s) {\n  var o = ts(r), i = o.createElement(\"style\");\n  return i.setAttribute(\"type\", \"text/css\"), i.setAttribute(\"data-styled-id\", t), i.setAttribute(\"data-styled-count\", \"1\"), n.nonce && i.setAttribute(\"nonce\", n.nonce), i.innerHTML = Sf(t, e, n), (s || o.head || o.body).appendChild(i), i;\n}\nfunction Cf(t) {\n  var e = \"rCS\" + mf(t);\n  return {\n    className: e,\n    inject: function(n, r) {\n      r === void 0 && (r = {});\n      var s = xf(n), o = (s || n.ownerDocument || document).querySelector('style[data-styled-id=\"'.concat(e, '\"]'));\n      if (!o)\n        o = Ef(e, t, r, n, s);\n      else {\n        var i = parseFloat(o.getAttribute(\"data-styled-count\")) || 0;\n        o.setAttribute(\"data-styled-count\", \"\".concat(i + 1));\n      }\n      return {\n        destroy: function() {\n          var a, c = parseFloat(o.getAttribute(\"data-styled-count\")) || 0;\n          c <= 1 ? (o.remove ? o.remove() : (a = o.parentNode) === null || a === void 0 || a.removeChild(o), o = null) : o.setAttribute(\"data-styled-count\", \"\".concat(c - 1));\n        }\n      };\n    }\n  };\n}\nvar Wr = function() {\n  return Wr = Object.assign || function(e) {\n    for (var n, r = 1, s = arguments.length; r < s; r++) {\n      n = arguments[r];\n      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);\n    }\n    return e;\n  }, Wr.apply(this, arguments);\n};\nfunction Df(t, e) {\n  var n = {};\n  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);\n  if (t != null && typeof Object.getOwnPropertySymbols == \"function\") for (var s = 0, r = Object.getOwnPropertySymbols(t); s < r.length; s++)\n    e.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[s]) && (n[r[s]] = t[r[s]]);\n  return n;\n}\nfunction ca(t, e) {\n  var n = Cf(e), r = n.className;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(s, o) {\n    var i = s.className, a = i === void 0 ? \"\" : i;\n    s.cspNonce;\n    var c = Df(s, [\"className\", \"cspNonce\"]), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(o, function() {\n      return l.current;\n    }, []), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n      var u = n.inject(l.current, {\n        nonce: s.cspNonce\n      });\n      return function() {\n        u.destroy();\n      };\n    }, []), (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(t, Wr({\n      ref: l,\n      \"data-styled-id\": r,\n      className: \"\".concat(a, \" \").concat(r)\n    }, c));\n  });\n}\nfunction bf(t, e, n = e, r) {\n  var I;\n  const {\n    matrixes: s,\n    is3d: o,\n    targetMatrix: i,\n    transformOrigin: a,\n    targetOrigin: c,\n    offsetContainer: l,\n    hasFixed: u,\n    zoom: f\n  } = ci(t, e), {\n    matrixes: d,\n    is3d: p,\n    offsetContainer: g,\n    zoom: h\n  } = tl(l, n), v = r, m = 4, S = t.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in t;\n  let x = i, C = gt(m), E = gt(m), D = gt(m), R = gt(m);\n  const y = s.length, M = d.map(($) => ({\n    ...$,\n    matrix: $.matrix ? [...$.matrix] : void 0\n  })).reverse();\n  s.reverse(), !o && v && (x = Ut(x, 3, 4), Br(s)), !p && v && Br(M), M.forEach(($) => {\n    E = dt(E, $.matrix, m);\n  });\n  const P = n || fe(t), _ = ((I = M[0]) == null ? void 0 : I.target) || fn(P, P, !0).offsetParent, O = M.slice(1).reduce(($, G) => dt($, G.matrix, m), gt(m));\n  s.forEach(($, G) => {\n    if (y - 2 === G && (D = C.slice()), y - 1 === G && (R = C.slice()), !$.matrix) {\n      const L = s[G + 1], z = gu(\n        $,\n        L,\n        _,\n        m,\n        dt(O, C, m)\n      );\n      $.matrix = Ce(z, m);\n    }\n    C = dt(C, $.matrix, m);\n  });\n  const T = !S && o;\n  x || (x = gt(T ? 4 : 3));\n  const w = Jn(\n    S && x.length === 16 ? Ut(x, 4, 3) : x,\n    T\n  ), k = E;\n  return E = Qo(E, m, m), {\n    hasZoom: f !== 1 || h !== 1,\n    hasFixed: u,\n    matrixes: s,\n    rootMatrix: E,\n    originalRootMatrix: k,\n    beforeMatrix: D,\n    offsetMatrix: R,\n    allMatrix: C,\n    targetMatrix: x,\n    targetTransform: w,\n    inlineTransform: t.style.transform,\n    transformOrigin: a,\n    targetOrigin: c,\n    is3d: v,\n    offsetContainer: l,\n    offsetRootContainer: g\n  };\n}\nfunction la(t, e, n = e, r) {\n  let s = 0, o = 0, i = 0, a = {};\n  const c = ki(t);\n  if (t && (s = c.offsetWidth, o = c.offsetHeight), t) {\n    const u = bf(\n      t,\n      e,\n      n,\n      r\n      // prevMatrix, prevRootMatrix, prevN,\n    ), f = ke(\n      u.allMatrix,\n      u.transformOrigin,\n      s,\n      o\n    );\n    a = {\n      ...u,\n      ...f\n    };\n    const d = ke(\n      u.allMatrix,\n      [50, 50],\n      100,\n      100\n    );\n    i = $i([d.pos1, d.pos2], d.direction);\n  }\n  const l = 4;\n  return {\n    hasZoom: !1,\n    width: s,\n    height: o,\n    rotation: i,\n    ...c,\n    originalRootMatrix: gt(l),\n    rootMatrix: gt(l),\n    beforeMatrix: gt(l),\n    offsetMatrix: gt(l),\n    allMatrix: gt(l),\n    targetMatrix: gt(l),\n    targetTransform: \"\",\n    inlineTransform: \"\",\n    transformOrigin: [0, 0],\n    targetOrigin: [0, 0],\n    is3d: !!r,\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    origin: [0, 0],\n    pos1: [0, 0],\n    pos2: [0, 0],\n    pos3: [0, 0],\n    pos4: [0, 0],\n    direction: 1,\n    hasFixed: !1,\n    offsetContainer: null,\n    offsetRootContainer: null,\n    matrixes: [],\n    ...a\n  };\n}\nfunction If(t, e, n = e) {\n  return la(t, e, n, !0);\n}\nfunction Yr(t, e, n, r, s, o = []) {\n  let i = 1, a = [0, 0], c = Rn(), l = Rn(), u = Rn(), f = Rn(), d = [0, 0];\n  const p = {}, g = la(\n    e,\n    n,\n    s,\n    !0\n  );\n  if (e) {\n    const h = Gt(e);\n    o.forEach((x) => {\n      p[x] = h(x);\n    });\n    const v = g.is3d ? 4 : 3, m = ke(\n      g.offsetMatrix,\n      at(g.transformOrigin, ti(g.targetMatrix, v)),\n      g.width,\n      g.height\n    );\n    i = m.direction, a = at(\n      m.origin,\n      [m.left - g.left, m.top - g.top]\n    ), f = nn(g.offsetRootContainer);\n    const S = fn(r, r, !0).offsetParent || g.offsetRootContainer;\n    if (g.hasZoom) {\n      const x = ke(\n        dt(g.originalRootMatrix, g.allMatrix),\n        g.transformOrigin,\n        g.width,\n        g.height\n      ), C = ke(\n        g.originalRootMatrix,\n        Ln(Gt(S)(\"transformOrigin\")).map((E) => parseFloat(E)),\n        S.offsetWidth,\n        S.offsetHeight\n      );\n      if (c = pr(x, f), u = pr(\n        C,\n        f,\n        S,\n        !0\n      ), t) {\n        const E = x.left, D = x.top;\n        l = pr({\n          left: E,\n          top: D,\n          bottom: D,\n          right: D\n        }, f);\n      }\n    } else {\n      c = nn(e), u = Qc(S), t && (l = nn(t));\n      const {\n        left: x,\n        top: C,\n        clientLeft: E,\n        clientTop: D\n      } = u, R = [\n        c.left - x,\n        c.top - C\n      ];\n      d = K(\n        We(g.rootMatrix, R, 4),\n        [E + g.left, D + g.top]\n      );\n    }\n  }\n  return {\n    targetClientRect: c,\n    containerClientRect: u,\n    moveableClientRect: l,\n    rootContainerClientRect: f,\n    beforeDirection: i,\n    beforeOrigin: a,\n    originalBeforeOrigin: a,\n    target: e,\n    style: p,\n    offsetDelta: d,\n    ...g\n  };\n}\nfunction yo(t) {\n  let {\n    pos1: e,\n    pos2: n,\n    pos3: r,\n    pos4: s\n  } = t;\n  if (!e || !n || !r || !s)\n    return null;\n  const o = be([e, n, r, s]), i = [o.minX, o.minY], a = K(t.origin, i);\n  return e = K(e, i), n = K(n, i), r = K(r, i), s = K(s, i), {\n    ...t,\n    left: t.left,\n    top: t.top,\n    posDelta: i,\n    pos1: e,\n    pos2: n,\n    pos3: r,\n    pos4: s,\n    origin: a,\n    beforeOrigin: a,\n    // originalBeforeOrigin: origin,\n    isPersisted: !0\n  };\n}\nclass ye extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n  constructor() {\n    super(...arguments);\n    X(this, \"state\", {\n      container: null,\n      gestos: {},\n      renderLines: [\n        [\n          [0, 0],\n          [0, 0]\n        ],\n        [\n          [0, 0],\n          [0, 0]\n        ],\n        [\n          [0, 0],\n          [0, 0]\n        ],\n        [\n          [0, 0],\n          [0, 0]\n        ]\n      ],\n      renderPoses: [\n        [0, 0],\n        [0, 0],\n        [0, 0],\n        [0, 0]\n      ],\n      disableNativeEvent: !1,\n      posDelta: [0, 0],\n      ...Yr(null)\n    });\n    X(this, \"renderState\", {});\n    X(this, \"enabledAbles\", []);\n    X(this, \"targetAbles\", []);\n    X(this, \"controlAbles\", []);\n    X(this, \"controlBox\");\n    X(this, \"areaElement\");\n    X(this, \"targetGesto\");\n    X(this, \"controlGesto\");\n    X(this, \"rotation\", 0);\n    X(this, \"scale\", [1, 1]);\n    X(this, \"isMoveableMounted\", !1);\n    X(this, \"isUnmounted\", !1);\n    X(this, \"events\", {\n      mouseEnter: null,\n      mouseLeave: null\n    });\n    X(this, \"_emitter\", new Cs());\n    X(this, \"_prevOriginalDragTarget\", null);\n    X(this, \"_originalDragTarget\", null);\n    X(this, \"_prevDragTarget\", null);\n    X(this, \"_dragTarget\", null);\n    X(this, \"_prevPropTarget\", null);\n    X(this, \"_propTarget\", null);\n    X(this, \"_prevDragArea\", !1);\n    X(this, \"_isPropTargetChanged\", !1);\n    X(this, \"_hasFirstTarget\", !1);\n    X(this, \"_reiszeObserver\", null);\n    X(this, \"_observerId\", 0);\n    X(this, \"_mutationObserver\", null);\n    X(this, \"_rootContainer\", null);\n    X(this, \"_viewContainer\", null);\n    X(this, \"_viewClassNames\", []);\n    X(this, \"_store\", {});\n    X(this, \"checkUpdateRect\", () => {\n      if (this.isDragging())\n        return;\n      const n = this.props.parentMoveable;\n      if (n) {\n        n.checkUpdateRect();\n        return;\n      }\n      Ec(this._observerId), this._observerId = Ho(() => {\n        this.isDragging() || this.updateRect();\n      });\n    });\n    X(this, \"_onPreventClick\", (n) => {\n      n.stopPropagation(), n.preventDefault();\n    });\n  }\n  render() {\n    const n = this.props, r = this.getState(), {\n      parentPosition: s,\n      className: o,\n      target: i,\n      zoom: a,\n      cspNonce: c,\n      translateZ: l,\n      cssStyled: u,\n      groupable: f,\n      linePadding: d,\n      controlPadding: p\n    } = n;\n    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();\n    const [g, h] = s || [0, 0], {\n      left: v,\n      top: m,\n      target: S,\n      direction: x,\n      hasFixed: C,\n      offsetDelta: E\n    } = r, D = n.targets, R = this.isDragging(), y = {};\n    this.getEnabledAbles().forEach((w) => {\n      y[`data-able-${w.name.toLowerCase()}`] = !0;\n    });\n    const M = this._getAbleClassName(), P = D && D.length && (S || f) || i || !this._hasFirstTarget && this.state.isPersisted, _ = this.controlBox || this.props.firstRenderState || this.props.persistData, O = [v - g, m - h];\n    !f && n.useAccuratePosition && (O[0] += E[0], O[1] += E[1]);\n    const T = {\n      position: C ? \"fixed\" : \"absolute\",\n      display: P ? \"block\" : \"none\",\n      visibility: _ ? \"visible\" : \"hidden\",\n      transform: `translate3d(${O[0]}px, ${O[1]}px, ${l})`,\n      \"--zoom\": a,\n      \"--zoompx\": `${a}px`\n    };\n    return d && (T[\"--moveable-line-padding\"] = d), p && (T[\"--moveable-control-padding\"] = p), /* @__PURE__ */ it.jsxs(\n      u,\n      {\n        cspNonce: c,\n        ref: Se(this, \"controlBox\"),\n        className: `${U(\"control-box\", x === -1 ? \"reverse\" : \"\", R ? \"dragging\" : \"\")} ${M} ${o}`,\n        ...y,\n        onClick: this._onPreventClick,\n        style: T,\n        children: [\n          this.renderAbles(),\n          this._renderLines()\n        ]\n      }\n    );\n  }\n  componentDidMount() {\n    this.isMoveableMounted = !0, this.isUnmounted = !1;\n    const n = this.props, { parentMoveable: r, container: s } = n;\n    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !s && !r && !this.state.isPersisted && (this.updateRect(\"\", !1, !1), this.forceUpdate());\n  }\n  componentDidUpdate(n) {\n    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateTargets(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(n);\n  }\n  componentWillUnmount() {\n    var s, o;\n    this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off(), (s = this._reiszeObserver) == null || s.disconnect(), (o = this._mutationObserver) == null || o.disconnect(), this._viewContainer && this._changeAbleViewClassNames([]), ze(this, !1), ze(this, !0);\n    const r = this.events;\n    for (const i in r) {\n      const a = r[i];\n      a && a.destroy();\n    }\n  }\n  getTargets() {\n    const n = this.props.target;\n    return n ? [n] : [];\n  }\n  /**\n   * Get the able used in MoveableManager.\n   * @method Moveable#getAble\n   * @param - able name\n   */\n  getAble(n) {\n    const r = this.props.ables || [];\n    return kt(r, (s) => s.name === n);\n  }\n  getContainer() {\n    const { parentMoveable: n, wrapperMoveable: r, container: s } = this.props;\n    return s || r && r.getContainer() || n && n.getContainer() || this.controlBox.parentElement;\n  }\n  /**\n   * Returns the element of the control box.\n   * @method Moveable#getControlBoxElement\n   */\n  getControlBoxElement() {\n    return this.controlBox;\n  }\n  /**\n   * Target element to be dragged in moveable\n   * @method Moveable#getDragElement\n   */\n  getDragElement() {\n    return this._dragTarget;\n  }\n  /**\n   * Check if the target is an element included in the moveable.\n   * @method Moveable#isMoveableElement\n   * @param - the target\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"click\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *         moveable.target = e.target;\n   *     }\n   * });\n   */\n  isMoveableElement(n) {\n    var r;\n    return n && (((r = n.getAttribute) == null ? void 0 : r.call(n, \"class\")) || \"\").indexOf(Hr) > -1;\n  }\n  /**\n   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n   * @method Moveable#dragStart\n   * @param - external `MouseEvent`or `TouchEvent`\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *          moveable.dragStart(e);\n   *     }\n   * });\n   */\n  dragStart(n, r = n.target) {\n    const s = this.targetGesto, o = this.controlGesto;\n    return s && Rs(this)({ inputEvent: n }, r) ? s.isFlag() || s.triggerDragStart(n) : o && this.isMoveableElement(r) && (o.isFlag() || o.triggerDragStart(n)), this;\n  }\n  /**\n   * Hit test an element or rect on a moveable target.\n   * (100% = 100)\n   * @method Moveable#hitTest\n   * @param - element or rect to test\n   * @return - Get hit test rate (rate > 0 is hitted)\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.hitTest(e.target) > 0) {\n   *          console.log(\"hiited\");\n   *     }\n   * });\n   */\n  hitTest(n) {\n    const { target: r, pos1: s, pos2: o, pos3: i, pos4: a, targetClientRect: c } = this.state;\n    if (!r)\n      return 0;\n    let l;\n    if (ns(n)) {\n      const m = n.getBoundingClientRect();\n      l = {\n        left: m.left,\n        top: m.top,\n        width: m.width,\n        height: m.height\n      };\n    } else\n      l = { width: 0, height: 0, ...n };\n    const {\n      left: u,\n      top: f,\n      width: d,\n      height: p\n    } = l, g = mo([s, o, a, i], c), h = qu(g, [\n      [u, f],\n      [u + d, f],\n      [u + d, f + p],\n      [u, f + p]\n    ]), v = Qi(g);\n    return !h || !v ? 0 : Math.min(100, h / v * 100);\n  }\n  /**\n   * Whether the coordinates are inside Moveable\n   * @method Moveable#isInside\n   * @param - x coordinate\n   * @param - y coordinate\n   * @return - True if the coordinate is in moveable or false\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.isInside(e.clientX, e.clientY)) {\n   *          console.log(\"inside\");\n   *     }\n   * });\n   */\n  isInside(n, r) {\n    const { target: s, pos1: o, pos2: i, pos3: a, pos4: c, targetClientRect: l } = this.state;\n    return s ? Fr(\n      [n, r],\n      mo([o, i, c, a], l)\n    ) : !1;\n  }\n  /**\n   * If the width, height, left, and top of all elements change, update the shape of the moveable.\n   * @method Moveable#updateRect\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"resize\", e => {\n   *     moveable.updateRect();\n   * });\n   */\n  updateRect(n, r, s = !0) {\n    const o = this.props, i = !o.parentPosition && !o.wrapperMoveable;\n    i && Le(!0);\n    const a = o.parentMoveable, l = this.state.target || o.target, u = this.getContainer(), f = a ? a._rootContainer : this._rootContainer, d = Yr(\n      this.controlBox,\n      l,\n      u,\n      u,\n      f || u,\n      this._getRequestStyles()\n    );\n    if (!l && this._hasFirstTarget && o.persistData) {\n      const p = yo(o.persistData);\n      for (const g in p)\n        d[g] = p[g];\n    }\n    i && Le(), this.updateState(d, a ? !1 : s);\n  }\n  /**\n   * Check if the moveable state is being dragged.\n   * @method Moveable#isDragging\n   * @param - If you want to check if able is dragging, specify ableName.\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // false\n   * console.log(moveable.isDragging());\n   *\n   * moveable.on(\"drag\", () => {\n   *   // true\n   *   console.log(moveable.isDragging());\n   * });\n   */\n  isDragging(n) {\n    var o, i;\n    const r = this.targetGesto, s = this.controlGesto;\n    return r != null && r.isFlag() ? n ? !!((o = r.getEventData()[n]) != null && o.isEventStart) : !0 : s != null && s.isFlag() ? n ? !!((i = s.getEventData()[n]) != null && i.isEventStart) : !0 : !1;\n  }\n  /**\n   * If the width, height, left, and top of the only target change, update the shape of the moveable.\n   * Use `.updateRect()` method\n   * @method Moveable#updateTarget\n   * @deprecated\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.updateTarget();\n   */\n  updateTarget(n) {\n    this.updateRect(n, !0);\n  }\n  /**\n   * You can get the vertex information, position and offset size information of the target based on the container.\n   * @method Moveable#getRect\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * const rectInfo = moveable.getRect();\n   */\n  getRect() {\n    const n = this.state, r = jt(this.state), [s, o, i, a] = r, c = Yt(r), { width: l, height: u } = n, { width: f, height: d, left: p, top: g } = c, h = [n.left, n.top], v = at(h, n.origin), m = at(h, n.beforeOrigin), S = n.transformOrigin;\n    return {\n      width: f,\n      height: d,\n      left: p,\n      top: g,\n      pos1: s,\n      pos2: o,\n      pos3: i,\n      pos4: a,\n      offsetWidth: l,\n      offsetHeight: u,\n      beforeOrigin: m,\n      origin: v,\n      transformOrigin: S,\n      rotation: this.getRotation()\n    };\n  }\n  /**\n   * Get a manager that manages the moveable's state and props.\n   * @method Moveable#getManager\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * const manager = moveable.getManager(); // real moveable class instance\n   */\n  getManager() {\n    return this;\n  }\n  /**\n   * You can stop the dragging currently in progress through a method from outside.\n   * @method Moveable#stopDrag\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.stopDrag();\n   */\n  stopDrag(n) {\n    if (!n || n === \"target\") {\n      const r = this.targetGesto;\n      (r == null ? void 0 : r.isIdle()) === !1 && zr(this, !1), r == null || r.stop();\n    }\n    if (!n || n === \"control\") {\n      const r = this.controlGesto;\n      (r == null ? void 0 : r.isIdle()) === !1 && zr(this, !0), r == null || r.stop();\n    }\n  }\n  getRotation() {\n    const { pos1: n, pos2: r, direction: s } = this.state;\n    return Cu(n, r, s);\n  }\n  /**\n   * Request able through a method rather than an event.\n   * At the moment of execution, requestStart is executed,\n   * and then request and requestEnd can be executed through Requester.\n   * @method Moveable#request\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n   * @param - ableName\n   * @param - request to be able params.\n   * @param - If isInstant is true, request and requestEnd are executed immediately.\n   * @return - Able Requester. If there is no request in able, nothing will work.\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n   *\n   * // Start move\n   * const requester = moveable.request(\"draggable\");\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.requestEnd();\n   */\n  request(n, r = {}, s) {\n    const o = this, i = o.props, a = i.parentMoveable || i.wrapperMoveable || o, c = a.props.ables, l = i.groupable, u = kt(c, (m) => m.name === n);\n    if (this.isDragging() || !u || !u.request)\n      return {\n        request() {\n          return this;\n        },\n        requestEnd() {\n          return this;\n        }\n      };\n    const f = u.request(o), d = s || r.isInstant, p = f.isControl ? \"controlAbles\" : \"targetAbles\", g = `${l ? \"Group\" : \"\"}${f.isControl ? \"Control\" : \"\"}`, h = [...a[p]], v = {\n      request(m) {\n        return sn(\n          o,\n          h,\n          [\"drag\"],\n          g,\n          \"\",\n          {\n            ...f.request(m),\n            requestAble: n,\n            isRequest: !0\n          },\n          d\n        ), v;\n      },\n      requestEnd() {\n        return sn(\n          o,\n          h,\n          [\"drag\"],\n          g,\n          \"End\",\n          {\n            ...f.requestEnd(),\n            requestAble: n,\n            isRequest: !0\n          },\n          d\n        ), v;\n      }\n    };\n    return sn(\n      o,\n      h,\n      [\"drag\"],\n      g,\n      \"Start\",\n      {\n        ...f.requestStart(r),\n        requestAble: n,\n        isRequest: !0\n      },\n      d\n    ), d ? v.request(r).requestEnd() : v;\n  }\n  /**\n   * moveable is the top level that manages targets\n   * `Single`: MoveableManager instance\n   * `Group`: MoveableGroup instance\n   * `IndividualGroup`: MoveableIndividaulGroup instance\n   * Returns leaf target MoveableManagers.\n   */\n  getMoveables() {\n    return [this];\n  }\n  /**\n   * Remove the Moveable object and the events.\n   * @method Moveable#destroy\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.destroy();\n   */\n  destroy() {\n    this.componentWillUnmount();\n  }\n  updateRenderPoses() {\n    const n = this.getState(), r = this.props, s = r.padding, {\n      originalBeforeOrigin: o,\n      transformOrigin: i,\n      allMatrix: a,\n      is3d: c,\n      pos1: l,\n      pos2: u,\n      pos3: f,\n      pos4: d,\n      left: p,\n      top: g,\n      isPersisted: h\n    } = n, v = r.zoom || 1;\n    if (!s && v <= 1) {\n      n.renderPoses = [l, u, f, d], n.renderLines = [\n        [l, u],\n        [u, d],\n        [d, f],\n        [f, l]\n      ];\n      return;\n    }\n    const { left: m, top: S, bottom: x, right: C } = qi(s || {}), E = c ? 4 : 3;\n    let D = [];\n    h ? D = i : this.controlBox && r.groupable ? D = o : D = at(o, [p, g]);\n    const R = An(\n      E,\n      Ce(\n        D.map((O) => -O),\n        E\n      ),\n      a,\n      Ce(i, E)\n    ), y = Wt(R, l, [-m, -S], E), M = Wt(R, u, [C, -S], E), P = Wt(R, f, [-m, x], E), _ = Wt(R, d, [C, x], E);\n    if (n.renderPoses = [y, M, P, _], n.renderLines = [\n      [y, M],\n      [M, _],\n      [_, P],\n      [P, y]\n    ], v) {\n      const O = v / 2;\n      n.renderLines = [\n        [\n          Wt(R, l, [-m - O, -S], E),\n          Wt(R, u, [C + O, -S], E)\n        ],\n        [\n          Wt(R, u, [C, -S - O], E),\n          Wt(R, d, [C, x + O], E)\n        ],\n        [\n          Wt(R, d, [C + O, x], E),\n          Wt(R, f, [-m - O, x], E)\n        ],\n        [\n          Wt(R, f, [-m, x + O], E),\n          Wt(R, l, [-m, -S - O], E)\n        ]\n      ];\n    }\n  }\n  checkUpdate() {\n    this._isPropTargetChanged = !1;\n    const { target: n, container: r, parentMoveable: s } = this.props, { target: o, container: i } = this.state;\n    if (!o && !n)\n      return;\n    this.updateAbles();\n    const a = !Ar(o, n);\n    if (!(a || !Ar(i, r)))\n      return;\n    const l = r || this.controlBox;\n    l && this.unsetAbles(), this.updateState({ target: n, container: r }), !s && l && this.updateRect(\"End\", !1, !1), this._isPropTargetChanged = a;\n  }\n  waitToChangeTarget() {\n    return new Promise(() => {\n    });\n  }\n  triggerEvent(n, r) {\n    const s = this.props;\n    if (this._emitter.trigger(n, r), s.parentMoveable && r.isRequest && !r.isRequestChild)\n      return s.parentMoveable.triggerEvent(n, r, !0);\n    const o = s[n];\n    return o && o(r);\n  }\n  useCSS(n, r) {\n    const s = this.props.customStyledMap, o = n + r;\n    return s[o] || (s[o] = ca(n, r)), s[o];\n  }\n  getState() {\n    var i;\n    const n = this.props;\n    (n.target || (i = n.targets) != null && i.length) && (this._hasFirstTarget = !0);\n    const r = this.controlBox, s = n.persistData, o = n.firstRenderState;\n    if (o && !r)\n      return o;\n    if (!this._hasFirstTarget && s) {\n      const a = yo(s);\n      if (a)\n        return this.updateState(a, !1), this.state;\n    }\n    return this.state.isPersisted = !1, this.state;\n  }\n  updateSelectors() {\n  }\n  unsetAbles() {\n    this.targetAbles.forEach((n) => {\n      n.unset && n.unset(this);\n    });\n  }\n  updateAbles(n = this.props.ables, r = \"\") {\n    const o = this.props.triggerAblesSimultaneously, i = this.getEnabledAbles(n), a = `drag${r}Start`, c = `pinch${r}Start`, l = `drag${r}ControlStart`, u = Mn(\n      i,\n      [a, c],\n      o\n    ), f = Mn(\n      i,\n      [l],\n      o\n    );\n    this.enabledAbles = i, this.targetAbles = u, this.controlAbles = f;\n  }\n  updateState(n, r) {\n    if (r) {\n      if (this.isUnmounted)\n        return;\n      this.setState(n);\n    } else {\n      const s = this.state;\n      for (const o in n)\n        s[o] = n[o];\n    }\n  }\n  getEnabledAbles(n = this.props.ables) {\n    const r = this.props;\n    return n.filter(\n      (s) => s && (s.always && r[s.name] !== !1 || r[s.name])\n    );\n  }\n  renderAbles() {\n    const r = this.props.triggerAblesSimultaneously, s = {\n      createElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement\n    };\n    return this.renderState = {}, mu(\n      Vi(\n        Mn(\n          this.getEnabledAbles(),\n          [\"render\"],\n          r\n        ).map(({ render: o }) => o(this, s) || [])\n      ).filter((o) => o),\n      ({ key: o }) => o\n    ).map((o) => o[0]);\n  }\n  updateCheckInput() {\n    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n  }\n  _getRequestStyles() {\n    return this.getEnabledAbles().reduce(\n      (r, s) => {\n        var i;\n        const o = ((i = s.requestStyle) == null ? void 0 : i.call(s)) ?? [];\n        return [...r, ...o];\n      },\n      [...this.props.requestStyles || []]\n    );\n  }\n  _updateObserver(n) {\n    this._updateResizeObserver(n), this._updateMutationObserver(n);\n  }\n  _updateEvents() {\n    const n = this.targetAbles.length, r = this.controlAbles.length, s = this._dragTarget;\n    (!n && this.targetGesto || this._isTargetChanged(!0)) && (ze(this, !1), this.updateState({ gestos: {} })), r || ze(this, !0), s && n && !this.targetGesto && (this.targetGesto = oa(this, s, \"\")), !this.controlGesto && r && (this.controlGesto = ia(this, \"Control\"));\n  }\n  _updateTargets() {\n    const n = this.props;\n    this._prevPropTarget = this._propTarget, this._prevDragTarget = this._dragTarget, this._prevOriginalDragTarget = this._originalDragTarget, this._prevDragArea = n.dragArea, this._propTarget = n.target, this._originalDragTarget = n.dragTarget || n.target, this._dragTarget = Zt(this._originalDragTarget, !0);\n  }\n  _renderLines() {\n    const n = this.props, {\n      zoom: r,\n      hideDefaultLines: s,\n      hideChildMoveableDefaultLines: o,\n      parentMoveable: i\n    } = n;\n    if (s || i && o)\n      return [];\n    const a = this.getState(), c = {\n      createElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement\n    };\n    return a.renderLines.map((l, u) => un(\n      c,\n      \"\",\n      l[0],\n      l[1],\n      r,\n      `render-line-${u}`\n    ));\n  }\n  _isTargetChanged(n) {\n    const r = this.props, s = r.dragTarget || r.target, o = this._prevOriginalDragTarget, i = this._prevDragArea, a = r.dragArea;\n    return !a && o !== s || (n || a) && i !== a || this._prevPropTarget != this._propTarget;\n  }\n  _updateNativeEvents() {\n    const r = this.props.dragArea ? this.areaElement : this.state.target, s = this.events, o = Ve(s);\n    if (this._isTargetChanged())\n      for (const a in s) {\n        const c = s[a];\n        c && c.destroy(), s[a] = null;\n      }\n    if (!r)\n      return;\n    const i = this.enabledAbles;\n    o.forEach((a) => {\n      const c = Mn(i, [a]), l = c.length > 0;\n      let u = s[a];\n      if (!l) {\n        u && (u.destroy(), s[a] = null);\n        return;\n      }\n      u || (u = new gf(r, this, a), s[a] = u), u.setAbles(c);\n    });\n  }\n  _checkUpdateRootContainer() {\n    const n = this.props.rootContainer;\n    !this._rootContainer && n && (this._rootContainer = Zt(n, !0));\n  }\n  _checkUpdateViewContainer() {\n    const n = this.props.viewContainer;\n    !this._viewContainer && n && (this._viewContainer = Zt(n, !0)), this._viewContainer && this._changeAbleViewClassNames([\n      ...this._getAbleViewClassNames(),\n      this.isDragging() ? _u : \"\"\n    ]);\n  }\n  _changeAbleViewClassNames(n) {\n    const r = this._viewContainer, s = Yi(n.filter(Boolean), (c) => c).map(\n      ([c]) => c\n    ), o = this._viewClassNames, { removed: i, added: a } = ps(o, s);\n    i.forEach((c) => {\n      Zo(r, o[c]);\n    }), a.forEach((c) => {\n      Ko(r, s[c]);\n    }), this._viewClassNames = s;\n  }\n  _getAbleViewClassNames() {\n    return (this.getEnabledAbles().map((n) => {\n      var r;\n      return ((r = n.viewClassName) == null ? void 0 : r.call(n, this)) || \"\";\n    }).join(\" \") + ` ${this._getAbleClassName(\"-view\")}`).split(/\\s+/g);\n  }\n  _getAbleClassName(n = \"\") {\n    const r = this.getEnabledAbles(), s = this.targetGesto, o = this.controlGesto, i = s != null && s.isFlag() ? s.getEventData() : {}, a = o != null && o.isFlag() ? o.getEventData() : {};\n    return r.map((c) => {\n      var f, d, p;\n      const l = c.name;\n      let u = ((f = c.className) == null ? void 0 : f.call(c, this)) || \"\";\n      return ((d = i[l]) != null && d.isEventStart || (p = a[l]) != null && p.isEventStart) && (u += ` ${U(`${l}${n}-dragging`)}`), u.trim();\n    }).filter(Boolean).join(\" \");\n  }\n  _updateResizeObserver(n) {\n    var a;\n    const r = this.props, s = r.target, o = ae(this.getControlBoxElement());\n    if (!o.ResizeObserver || !s || !r.useResizeObserver) {\n      (a = this._reiszeObserver) == null || a.disconnect();\n      return;\n    }\n    if (n.target === s && this._reiszeObserver)\n      return;\n    const i = new o.ResizeObserver(this.checkUpdateRect);\n    i.observe(s, {\n      box: \"border-box\"\n    }), this._reiszeObserver = i;\n  }\n  _updateMutationObserver(n) {\n    var a;\n    const r = this.props, s = r.target, o = ae(this.getControlBoxElement());\n    if (!o.MutationObserver || !s || !r.useMutationObserver) {\n      (a = this._mutationObserver) == null || a.disconnect();\n      return;\n    }\n    if (n.target === s && this._mutationObserver)\n      return;\n    const i = new o.MutationObserver((c) => {\n      for (const l of c)\n        l.type === \"attributes\" && l.attributeName === \"style\" && this.checkUpdateRect();\n    });\n    i.observe(s, {\n      attributes: !0\n    }), this._mutationObserver = i;\n  }\n}\nX(ye, \"defaultProps\", {\n  dragTargetSelf: !1,\n  target: null,\n  dragTarget: null,\n  container: null,\n  rootContainer: null,\n  origin: !0,\n  parentMoveable: null,\n  wrapperMoveable: null,\n  isWrapperMounted: !1,\n  parentPosition: null,\n  warpSelf: !1,\n  svgOrigin: \"\",\n  dragContainer: null,\n  useResizeObserver: !1,\n  useMutationObserver: !1,\n  preventDefault: !0,\n  preventRightClick: !0,\n  preventWheelClick: !0,\n  linePadding: 0,\n  controlPadding: 0,\n  ables: [],\n  pinchThreshold: 20,\n  dragArea: !1,\n  passDragArea: !1,\n  transformOrigin: \"\",\n  className: \"\",\n  zoom: 1,\n  triggerAblesSimultaneously: !1,\n  padding: {},\n  pinchOutside: !0,\n  checkInput: !1,\n  dragFocusedInput: !1,\n  groupable: !1,\n  hideDefaultLines: !1,\n  cspNonce: \"\",\n  translateZ: 0,\n  cssStyled: null,\n  customStyledMap: {},\n  props: {},\n  stopPropagation: !1,\n  preventClickDefault: !1,\n  preventClickEventOnDrag: !0,\n  flushSync: Bi,\n  firstRenderState: null,\n  persistData: null,\n  viewContainer: null,\n  requestStyles: [],\n  useAccuratePosition: !1\n});\nconst Ms = {\n  name: \"groupable\",\n  props: [\n    \"defaultGroupRotate\",\n    \"useDefaultGroupRotate\",\n    \"defaultGroupOrigin\",\n    \"groupable\",\n    \"groupableProps\",\n    \"targetGroups\",\n    \"hideChildMoveableDefaultLines\"\n  ],\n  events: [],\n  render(t, e) {\n    var d;\n    const n = t.props;\n    let r = n.targets || [];\n    const { left: s, top: o, isPersisted: i } = t.getState(), a = n.zoom || 1, c = t.renderGroupRects;\n    let l = ((d = n.persistData) == null ? void 0 : d.children) || [];\n    i ? r = l.map(() => null) : l = [];\n    const u = Ae(\n      t,\n      \"parentPosition\",\n      [s, o],\n      (p) => p.join(\",\")\n    ), f = Ae(\n      t,\n      \"requestStyles\",\n      t.getRequestChildStyles(),\n      (p) => p.join(\",\")\n    );\n    return t.moveables = t.moveables.slice(0, r.length), [\n      ...r.map((p, g) => /* @__PURE__ */ it.jsx(\n        ye,\n        {\n          ref: Yo(t, \"moveables\", g),\n          target: p,\n          origin: !1,\n          requestStyles: f,\n          cssStyled: n.cssStyled,\n          customStyledMap: n.customStyledMap,\n          useResizeObserver: n.useResizeObserver,\n          useMutationObserver: n.useMutationObserver,\n          hideChildMoveableDefaultLines: n.hideChildMoveableDefaultLines,\n          parentMoveable: t,\n          parentPosition: [s, o],\n          persistData: l[g],\n          zoom: a\n        },\n        \"moveable\" + g\n      )),\n      ...Vi(\n        c.map(({ pos1: p, pos2: g, pos3: h, pos4: v }, m) => {\n          const S = [p, g, h, v];\n          return [\n            [0, 1],\n            [1, 3],\n            [3, 2],\n            [2, 0]\n          ].map(([x, C], E) => un(\n            e,\n            \"\",\n            K(S[x], u),\n            K(S[C], u),\n            a,\n            `group-rect-${m}-${E}`\n          ));\n        })\n      )\n    ];\n  }\n}, yf = dn(\"clickable\", {\n  props: [\n    \"clickable\"\n  ],\n  events: [\n    \"click\",\n    \"clickGroup\"\n  ],\n  always: !0,\n  dragRelation: \"weak\",\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  dragStart() {\n  },\n  dragControlStart() {\n  },\n  dragGroupStart(t, e) {\n    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\n  },\n  dragEnd(t, e) {\n    const n = t.props.target, r = e.inputEvent, s = e.inputTarget, i = !t.isMoveableElement(s) && t.controlBox.contains(s);\n    if (!r || !s || e.isDrag || t.isMoveableElement(s) || i)\n      return;\n    const a = n.contains(s);\n    j(t, \"onClick\", et(t, e, {\n      isDouble: e.isDouble,\n      inputTarget: s,\n      isTarget: n === s,\n      moveableTarget: t.props.target,\n      containsTarget: a\n    }));\n  },\n  dragGroupEnd(t, e) {\n    const n = e.inputEvent, r = e.inputTarget;\n    if (!n || !r || e.isDrag || t.isMoveableElement(r) || e.datas.inputTarget === r)\n      return;\n    const s = t.props.targets;\n    let o = s.indexOf(r);\n    const i = o > -1;\n    let a = !1;\n    o === -1 && (o = ne(s, (c) => c.contains(r)), a = o > -1), j(t, \"onClickGroup\", et(t, e, {\n      isDouble: e.isDouble,\n      targets: s,\n      inputTarget: r,\n      targetIndex: o,\n      isTarget: i,\n      containsTarget: a,\n      moveableTarget: s[o]\n    }));\n  },\n  dragControlEnd(t, e) {\n    this.dragEnd(t, e);\n  },\n  dragGroupControlEnd(t, e) {\n    this.dragEnd(t, e);\n  }\n});\nfunction Oe(t) {\n  let e = t.originalDatas.draggable;\n  return e || (t.originalDatas.draggable = {}, e = t.originalDatas.draggable), { ...t, datas: e };\n}\nconst Rf = dn(\"edgeDraggable\", {\n  css: [\n    `.edge.edgeDraggable.line {\ncursor: move;\n}`\n  ],\n  render(t, e) {\n    const n = t.props, r = n.edgeDraggable;\n    return r ? fi(\n      e,\n      \"edgeDraggable\",\n      r,\n      t.getState().renderPoses,\n      n.zoom\n    ) : [];\n  },\n  dragCondition(t, e) {\n    var s;\n    const n = t.props, r = (s = e.inputEvent) == null ? void 0 : s.target;\n    return !n.edgeDraggable || !r ? !1 : !n.draggable && bt(r, U(\"direction\")) && bt(r, U(\"edge\")) && bt(r, U(\"edgeDraggable\"));\n  },\n  dragStart(t, e) {\n    return Ot.dragStart(t, Oe(e));\n  },\n  drag(t, e) {\n    return Ot.drag(t, Oe(e));\n  },\n  dragEnd(t, e) {\n    return Ot.dragEnd(t, Oe(e));\n  },\n  dragGroupCondition(t, e) {\n    var s;\n    const n = t.props, r = (s = e.inputEvent) == null ? void 0 : s.target;\n    return !n.edgeDraggable || !r ? !1 : !n.draggable && bt(r, U(\"direction\")) && bt(r, U(\"line\"));\n  },\n  dragGroupStart(t, e) {\n    return Ot.dragGroupStart(t, Oe(e));\n  },\n  dragGroup(t, e) {\n    return Ot.dragGroup(t, Oe(e));\n  },\n  dragGroupEnd(t, e) {\n    return Ot.dragGroupEnd(t, Oe(e));\n  },\n  unset(t) {\n    return Ot.unset(t);\n  }\n}), ua = {\n  name: \"individualGroupable\",\n  props: [\n    \"individualGroupable\",\n    \"individualGroupableProps\"\n  ],\n  events: []\n}, Ps = [\n  ra,\n  Zi,\n  su,\n  bu,\n  Ot,\n  Rf,\n  Tr,\n  yu,\n  Mu,\n  wl,\n  Au,\n  Gu,\n  Tu,\n  ef,\n  tf,\n  of,\n  Ms,\n  ua,\n  yf,\n  Ki,\n  sa\n], Bf = /* @__PURE__ */ Ps.reduce((t, e) => ((e.events || []).forEach((n) => {\n  Uo(t, n);\n}), t), []), zf = /* @__PURE__ */ Ps.reduce((t, e) => ((e.props || []).forEach((n) => {\n  Uo(t, n);\n}), t), []);\nfunction Ro([t, e, n], r) {\n  return (t * r[0] + e * r[1] + n) / Math.sqrt(t * t + e * e);\n}\nfunction wn([t, e], n) {\n  return -t * n[0] - e * n[1];\n}\nfunction Mo(t, e) {\n  return Math.max(\n    ...t.map(([n, r, s, o]) => Math.max(n[e], r[e], s[e], o[e]))\n  );\n}\nfunction Po(t, e) {\n  return Math.min(\n    ...t.map(([n, r, s, o]) => Math.min(n[e], r[e], s[e], o[e]))\n  );\n}\nfunction Mf(t, e) {\n  let n = [0, 0], r = [0, 0], s = [0, 0], o = [0, 0], i = 0, a = 0;\n  if (!t.length)\n    return {\n      pos1: n,\n      pos2: r,\n      pos3: s,\n      pos4: o,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: i,\n      height: a,\n      rotation: e\n    };\n  const c = tt(e, Bt);\n  if (c % 90) {\n    const p = c / 180 * Math.PI, g = Math.tan(p), h = -1 / g, v = [Dr, Fs], m = [\n      [0, 0],\n      [0, 0]\n    ], S = [Dr, Fs], x = [\n      [0, 0],\n      [0, 0]\n    ];\n    t.forEach((O) => {\n      O.forEach((T) => {\n        const w = Ro([-g, 1, 0], T), k = Ro([-h, 1, 0], T);\n        v[0] > w && (m[0] = T, v[0] = w), v[1] < w && (m[1] = T, v[1] = w), S[0] > k && (x[0] = T, S[0] = k), S[1] < k && (x[1] = T, S[1] = k);\n      });\n    });\n    const [C, E] = m, [D, R] = x, y = [-g, 1, wn([-g, 1], C)], M = [-g, 1, wn([-g, 1], E)], P = [-h, 1, wn([-h, 1], D)], _ = [-h, 1, wn([-h, 1], R)];\n    [n, r, s, o] = [\n      [y, P],\n      [y, _],\n      [M, P],\n      [M, _]\n    ].map(\n      ([O, T]) => bs(O, T)[0]\n    ), i = S[1] - S[0], a = v[1] - v[0];\n  } else {\n    const p = Po(t, 0), g = Po(t, 1), h = Mo(t, 0), v = Mo(t, 1);\n    n = [p, g], r = [h, g], s = [p, v], o = [h, v], i = h - p, a = v - g, c % 180 && ([n, r, s, o] = [s, n, o, r], i = v - g, a = h - p);\n  }\n  c % 360 > 180 && ([n, r, s, o] = [o, s, r, n]);\n  const { minX: l, minY: u, maxX: f, maxY: d } = be([n, r, s, o]);\n  return {\n    pos1: n,\n    pos2: r,\n    pos3: s,\n    pos4: o,\n    width: i,\n    height: a,\n    minX: l,\n    minY: u,\n    maxX: f,\n    maxY: d,\n    rotation: e\n  };\n}\nfunction fa(t, e) {\n  const n = e.map((r) => {\n    if (Rt(r)) {\n      const s = fa(t, r), o = s.length;\n      return o > 1 ? s : o === 1 ? s[0] : null;\n    } else {\n      const s = kt(\n        t,\n        ({ manager: o }) => o.props.target === r\n      );\n      return s ? (s.finded = !0, s.manager) : null;\n    }\n  }).filter(Boolean);\n  return n.length === 1 && Rt(n[0]) ? n[0] : n;\n}\nclass da extends ye {\n  constructor() {\n    super(...arguments);\n    X(this, \"differ\", new _i());\n    X(this, \"moveables\", []);\n    X(this, \"transformOrigin\", \"50% 50%\");\n    X(this, \"renderGroupRects\", []);\n    X(this, \"_targetGroups\", []);\n    X(this, \"_hasFirstTargets\", !1);\n  }\n  componentDidMount() {\n    super.componentDidMount();\n  }\n  checkUpdate() {\n    this._isPropTargetChanged = !1, this.updateAbles();\n  }\n  getTargets() {\n    return this.props.targets;\n  }\n  updateRect(n, r, s = !0) {\n    var W;\n    const o = this.state;\n    if (!this.controlBox || o.isPersisted)\n      return;\n    Le(!0), this.moveables.forEach((J) => {\n      J.updateRect(n, !1, !1);\n    });\n    const i = this.props, a = this.moveables, c = o.target || i.target, l = a.map((J) => ({\n      finded: !1,\n      manager: J\n    })), u = this.props.targetGroups || [], f = fa(l, u), d = i.useDefaultGroupRotate;\n    f.push(\n      ...l.filter(({ finded: J }) => !J).map(({ manager: J }) => J)\n    );\n    const p = [], g = !r || n !== \"\" && i.updateGroup;\n    let h = i.defaultGroupRotate || 0;\n    if (!this._hasFirstTargets) {\n      const J = (W = i.persistData) == null ? void 0 : W.rotation;\n      J != null && (h = J);\n    }\n    function v(J, q, F) {\n      const H = J.map((ut) => {\n        if (Rt(ut)) {\n          const St = v(ut, q), Kt = [St.pos1, St.pos2, St.pos3, St.pos4];\n          return p.push(St), { poses: Kt, rotation: St.rotation };\n        } else\n          return {\n            poses: jt(ut.state),\n            rotation: ut.getRotation()\n          };\n      }), nt = H.map(({ rotation: ut }) => ut);\n      let lt = 0;\n      const vt = nt[0], st = nt.every((ut) => Math.abs(vt - ut) < 0.1);\n      g ? lt = !d && st ? vt : h : lt = !d && !F && st ? vt : q;\n      const Ft = H.map(({ poses: ut }) => ut);\n      return Mf(Ft, lt);\n    }\n    const m = v(\n      f,\n      this.rotation,\n      !0\n    );\n    g && (this.rotation = m.rotation, this.transformOrigin = i.defaultGroupOrigin || \"50% 50%\", this.scale = [1, 1]), this._targetGroups = u, this.renderGroupRects = p;\n    const S = this.transformOrigin, x = this.rotation, C = this.scale, { width: E, height: D, minX: R, minY: y } = m, M = Du(\n      [\n        [0, 0],\n        [E, 0],\n        [0, D],\n        [E, D]\n      ],\n      Es(S, E, D),\n      this.rotation / 180 * Math.PI\n    ), { minX: P, minY: _ } = be(M.result), O = ` rotate(${x}deg) scale(${wt(C[0])}, ${wt(C[1])})`, T = `translate(${-P}px, ${-_}px)${O}`;\n    this.controlBox.style.transform = `translate3d(${R}px, ${y}px, ${this.props.translateZ || 0})`, c.style.cssText += `left:0px;top:0px;transform-origin:${S};width:${E}px;height:${D}px;transform: ${T}`, o.width = E, o.height = D;\n    const w = this.getContainer(), k = Yr(\n      this.controlBox,\n      c,\n      this.controlBox,\n      this.getContainer(),\n      this._rootContainer || w,\n      []\n    ), I = [k.left, k.top], [$, G, L, z] = jt(k), N = be([$, G, L, z]), Z = [N.minX, N.minY], Y = wt(C[0] * C[1]);\n    k.pos1 = K($, Z), k.pos2 = K(G, Z), k.pos3 = K(L, Z), k.pos4 = K(z, Z), k.left = R - k.left + Z[0], k.top = y - k.top + Z[1], k.origin = K(at(I, k.origin), Z), k.beforeOrigin = K(at(I, k.beforeOrigin), Z), k.originalBeforeOrigin = at(I, k.originalBeforeOrigin), k.transformOrigin = K(at(I, k.transformOrigin), Z), c.style.transform = `translate(${-P - Z[0]}px, ${-_ - Z[1]}px)` + O, Le(), this.updateState(\n      {\n        ...k,\n        posDelta: Z,\n        direction: Y,\n        beforeDirection: Y\n      },\n      s\n    );\n  }\n  getRect() {\n    return {\n      ...super.getRect(),\n      children: this.moveables.map((n) => n.getRect())\n    };\n  }\n  triggerEvent(n, r, s) {\n    if (s || n.indexOf(\"Group\") > -1)\n      return super.triggerEvent(n, r);\n    this._emitter.trigger(n, r);\n  }\n  getRequestChildStyles() {\n    return this.getEnabledAbles().reduce(\n      (r, s) => {\n        var i;\n        const o = ((i = s.requestChildStyle) == null ? void 0 : i.call(s)) ?? [];\n        return [...r, ...o];\n      },\n      []\n    );\n  }\n  getMoveables() {\n    return [...this.moveables];\n  }\n  updateAbles() {\n    super.updateAbles([...this.props.ables, Ms], \"Group\");\n  }\n  _updateTargets() {\n    super._updateTargets(), this._originalDragTarget = this.props.dragTarget || this.areaElement, this._dragTarget = Zt(this._originalDragTarget, !0);\n  }\n  _updateEvents() {\n    const n = this.state, r = this.props, s = this._prevDragTarget, o = r.dragTarget || this.areaElement, i = r.targets, { added: a, changed: c, removed: l } = this.differ.update(i), u = a.length || l.length;\n    (u || this._prevOriginalDragTarget !== this._originalDragTarget) && (ze(this, !1), ze(this, !0), this.updateState({ gestos: {} })), s !== o && (n.target = null), n.target || (n.target = this.areaElement, this.controlBox.style.display = \"block\"), n.target && (this.targetGesto || (this.targetGesto = oa(this, this._dragTarget, \"Group\")), this.controlGesto || (this.controlGesto = ia(this, \"GroupControl\")));\n    const f = !Ar(n.container, r.container);\n    f && (n.container = r.container), (f || u || this.transformOrigin !== (r.defaultGroupOrigin || \"50% 50%\") || c.length || i.length && !Hi(this._targetGroups, r.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!u;\n  }\n  _updateObserver() {\n  }\n}\nX(da, \"defaultProps\", {\n  ...ye.defaultProps,\n  transformOrigin: [\"50%\", \"50%\"],\n  groupable: !0,\n  dragArea: !0,\n  keepRatio: !0,\n  targets: [],\n  defaultGroupRotate: 0,\n  defaultGroupOrigin: \"50% 50%\"\n});\nclass Pf extends ye {\n  constructor() {\n    super(...arguments);\n    X(this, \"moveables\", []);\n  }\n  render() {\n    const n = this.props, { cspNonce: r, cssStyled: s, persistData: o } = n;\n    let i = n.targets || [];\n    const a = i.length, c = this.isUnmounted || !a;\n    let l = (o == null ? void 0 : o.children) ?? [];\n    return c && !a && l.length ? i = l.map(() => null) : c || (l = []), /* @__PURE__ */ it.jsx(\n      s,\n      {\n        cspNonce: r,\n        ref: Se(this, \"controlBox\"),\n        className: U(\"control-box\"),\n        children: i.map((u, f) => {\n          var p;\n          const d = ((p = n.individualGroupableProps) == null ? void 0 : p.call(n, u, f)) ?? {};\n          return /* @__PURE__ */ it.jsx(\n            ye,\n            {\n              ref: Yo(this, \"moveables\", f),\n              ...n,\n              ...d,\n              target: u,\n              wrapperMoveable: this,\n              isWrapperMounted: this.isMoveableMounted,\n              persistData: l[f]\n            },\n            \"moveable\" + f\n          );\n        })\n      }\n    );\n  }\n  componentDidMount() {\n  }\n  componentDidUpdate() {\n  }\n  getTargets() {\n    return this.props.targets;\n  }\n  updateRect(n, r, s = !0) {\n    Le(!0), this.moveables.forEach((o) => {\n      o.updateRect(n, r, s);\n    }), Le();\n  }\n  getRect() {\n    return {\n      ...super.getRect(),\n      children: this.moveables.map((n) => n.getRect())\n    };\n  }\n  request(n, r = {}, s) {\n    const o = this.moveables.map(\n      (c) => c.request(n, { ...r, isInstant: !1 }, !1)\n    ), i = s || r.isInstant, a = {\n      request(c) {\n        return o.forEach((l) => l.request(c)), this;\n      },\n      requestEnd() {\n        return o.forEach((c) => c.requestEnd()), this;\n      }\n    };\n    return i ? a.request(r).requestEnd() : a;\n  }\n  dragStart(n, r = n.target) {\n    const s = r, o = kt(this.moveables, (i) => {\n      const a = i.getTargets()[0], c = i.getControlBoxElement(), l = i.getDragElement();\n      return !a || !l ? !1 : l === s || l.contains(s) || l !== a && a === s || a.contains(s) || c === s || c.contains(s);\n    });\n    return o && o.dragStart(n, r), this;\n  }\n  hitTest() {\n    return 0;\n  }\n  isInside() {\n    return !1;\n  }\n  isDragging() {\n    return !1;\n  }\n  getDragElement() {\n    return null;\n  }\n  getMoveables() {\n    return [...this.moveables];\n  }\n  updateRenderPoses() {\n  }\n  checkUpdate() {\n  }\n  triggerEvent() {\n  }\n  updateAbles() {\n  }\n  _updateEvents() {\n  }\n  _updateObserver() {\n  }\n}\nfunction pa(t, e) {\n  const n = [];\n  return t.forEach((r) => {\n    if (r) {\n      if (re(r)) {\n        e[r] && n.push(...e[r]);\n        return;\n      }\n      Rt(r) ? n.push(...pa(r, e)) : n.push(r);\n    }\n  }), n;\n}\nfunction ga(t, e) {\n  const n = [];\n  return t.forEach((r) => {\n    if (r) {\n      if (re(r)) {\n        e[r] && n.push(...e[r]);\n        return;\n      }\n      Rt(r) ? n.push(ga(r, e)) : n.push(r);\n    }\n  }), n;\n}\nfunction ha(t, e) {\n  return t.length !== e.length || t.some((n, r) => {\n    const s = e[r];\n    return !n && !s ? !1 : n != s ? Rt(n) && Rt(s) ? ha(n, s) : !0 : !1;\n  });\n}\nclass on extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n  constructor() {\n    super(...arguments);\n    // @withMethods(MOVEABLE_METHODS)\n    X(this, \"moveable\");\n    X(this, \"refTargets\", []);\n    X(this, \"selectorMap\", {});\n    X(this, \"_differ\", new _i());\n    X(this, \"_elementTargets\", []);\n    X(this, \"_tmpRefTargets\", []);\n    X(this, \"_tmpSelectorMap\", {});\n    X(this, \"_onChangeTargets\", null);\n  }\n  static makeStyled() {\n    const n = {};\n    this.getTotalAbles().forEach(({ css: o }) => {\n      o && o.forEach((i) => {\n        n[i] = !0;\n      });\n    });\n    const s = Ve(n).join(`\n`);\n    this.defaultStyled = ca(\"div\", lc(Hr, oc + s));\n  }\n  static getTotalAbles() {\n    return [\n      Zi,\n      Ms,\n      ua,\n      Ki,\n      ...this.defaultAbles\n    ];\n  }\n  render() {\n    const n = this.constructor;\n    n.defaultStyled || n.makeStyled();\n    const { ables: r, props: s, ...o } = this.props, [i, a] = this._updateRefs(!0), c = pa(i, a);\n    let l = c.length > 1;\n    const f = [...n.getTotalAbles(), ...r || []], d = {\n      ...o,\n      ...s || {},\n      ables: f,\n      cssStyled: n.defaultStyled,\n      customStyledMap: n.customStyledMap\n    };\n    this._elementTargets = c;\n    let p = null;\n    const g = this.moveable, h = o.persistData;\n    if (h != null && h.children && (l = !0), o.individualGroupable)\n      return /* @__PURE__ */ it.jsx(\n        Pf,\n        {\n          ref: Se(this, \"moveable\"),\n          ...d,\n          target: null,\n          targets: c\n        },\n        \"individual-group\"\n      );\n    if (l) {\n      const v = ga(i, a);\n      if (g && !g.props.groupable && !g.props.individualGroupable) {\n        const m = g.props.target;\n        m && c.indexOf(m) > -1 && (p = { ...g.state });\n      }\n      return /* @__PURE__ */ it.jsx(\n        da,\n        {\n          ref: Se(this, \"moveable\"),\n          ...d,\n          ...o.groupableProps ?? {},\n          target: null,\n          targets: c,\n          targetGroups: v,\n          firstRenderState: p\n        },\n        \"group\"\n      );\n    } else {\n      const v = c[0];\n      if (g && (g.props.groupable || g.props.individualGroupable)) {\n        const m = g.moveables || [], S = kt(\n          m,\n          (x) => x.props.target === v\n        );\n        S && (p = { ...S.state });\n      }\n      return /* @__PURE__ */ it.jsx(\n        ye,\n        {\n          ref: Se(this, \"moveable\"),\n          ...d,\n          target: v,\n          firstRenderState: p\n        },\n        \"single\"\n      );\n    }\n  }\n  componentDidMount() {\n    this._checkChangeTargets();\n  }\n  componentDidUpdate() {\n    this._checkChangeTargets();\n  }\n  componentWillUnmount() {\n    this.selectorMap = {}, this.refTargets = [];\n  }\n  /**\n   * Get targets set in moveable through target or targets of props.\n   * @method Moveable#getTargets\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body, {\n   *    target: [targetRef, \".target\", document.querySelectorAll(\".target\")],\n   * });\n   *\n   * console.log(moveable.getTargets());\n   */\n  getTargets() {\n    var n;\n    return ((n = this.moveable) == null ? void 0 : n.getTargets()) ?? [];\n  }\n  /**\n   * If the element list corresponding to the selector among the targets is changed, it is updated.\n   * @method Moveable#updateSelectors\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body, {\n   *    target: \".target\",\n   * });\n   *\n   * moveable.updateSelectors();\n   */\n  updateSelectors() {\n    this.selectorMap = {}, this._updateRefs(), this.forceUpdate();\n  }\n  /**\n   * User changes target and waits for target to change.\n   * @method Moveable#waitToChangeTarget\n   * @story combination-with-other-components--components-selecto\n   * @example\n   * document.querySelector(\".target\").addEventListener(\"mousedown\", e => {\n   *   moveable.waitToChangeTarget().then(() => {\n   *      moveable.dragStart(e, e.currentTarget);\n   *   });\n   *   moveable.target = e.currentTarget;\n   * });\n   */\n  waitToChangeTarget() {\n    let n;\n    return this._onChangeTargets = () => {\n      this._onChangeTargets = null, n();\n    }, new Promise((r) => {\n      n = r;\n    });\n  }\n  waitToChangeTargets() {\n    return this.waitToChangeTarget();\n  }\n  getManager() {\n    return this.moveable;\n  }\n  getMoveables() {\n    return this.moveable.getMoveables();\n  }\n  getDragElement() {\n    return this.moveable.getDragElement();\n  }\n  _updateRefs(n) {\n    const r = this.refTargets, s = Ss(\n      this.props.target || this.props.targets\n    ), o = typeof document < \"u\";\n    let i = ha(r, s);\n    const a = this.selectorMap, c = {};\n    return this.refTargets.forEach(function l(u) {\n      re(u) ? a[u] ? c[u] = a[u] : o && (i = !0, c[u] = [].slice.call(\n        document.querySelectorAll(u)\n      )) : Rt(u) && u.forEach(l);\n    }), this._tmpRefTargets = s, this._tmpSelectorMap = c, [s, c, !n && i];\n  }\n  _checkChangeTargets() {\n    var c, l, u;\n    this.refTargets = this._tmpRefTargets, this.selectorMap = this._tmpSelectorMap;\n    const { added: n, removed: r } = this._differ.update(this._elementTargets);\n    (n.length || r.length) && ((l = (c = this.props).onChangeTargets) == null || l.call(c, {\n      moveable: this.moveable,\n      targets: this._elementTargets\n    }), (u = this._onChangeTargets) == null || u.call(this));\n    const [o, i, a] = this._updateRefs();\n    this.refTargets = o, this.selectorMap = i, a && this.forceUpdate();\n  }\n}\nX(on, \"defaultAbles\", []), X(on, \"customStyledMap\", {}), X(on, \"defaultStyled\", null);\nclass _f extends on {\n}\nX(_f, \"defaultAbles\", Ps);\nfunction Gf(t) {\n  var e;\n  return e = class extends on {\n  }, X(e, \"defaultAbles\", t), e;\n}\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGludGVyYWN0aWZ5L21vdmVhYmxlL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUM0QjtBQUNnRztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCxxREFBcUQ7QUFDckQ7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFzRCxPQUFPLGNBQWMsT0FBTyxxT0FBcU8sRUFBRSxLQUFLO0FBQzNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILEdBQUcsZUFBZSxFQUFFLFlBQVksR0FBRztBQUNwSjtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsNkNBQTZDLEdBQUcsd0RBQXdELG9EQUFvRCxHQUFHLHdEQUF3RCxvREFBb0QsRUFBRTtBQUM3USxVQUFVLEVBQUUsRUFBRTtBQUNkLDRCQUE0QixHQUFHLEVBQUU7QUFDakMsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRiw0QkFBNEIsRUFBRSxvQ0FBb0M7QUFDbEUsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRSxFQUFFLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUksa0JBQWtCLGlCQUFpQixpQkFBaUIsRUFBRSxNQUFNO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RCx1Q0FBdUMsT0FBTyxxREFBcUQsT0FBTztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUcsWUFBWSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ1AsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksU0FBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdDQUF3QztBQUM1QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4RUFBOEU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFzRCx1Q0FBdUM7QUFDakc7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUNBQXVDO0FBQ2xGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtCQUFrQix1QkFBdUI7QUFDekMsZ0JBQWdCO0FBQ2hCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCLFlBQVk7QUFDOUIsZ0JBQWdCO0FBQ2hCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNw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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4QkFBOEIsK0JBQStCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLE1BQU0sS0FBSyxhQUFhLEVBQUU7QUFDckYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxxQkFBcUIsRUFBRTtBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWEsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCLGtCQUFrQixrQkFBa0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixFQUFFO0FBQ2xCLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUNBQXVDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QixhQUFhLDhEQUE4RDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsSUFBSSxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMFZBQTBWO0FBQzFWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSkFBc0o7QUFDdEo7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQiw0QkFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxv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LENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQkFBZ0IsRUFBRSxFQUFFLEVBQUU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyw2QkFBNkIsRUFBRSxFQUFFLEVBQUU7QUFDdEM7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLEVBQUUsRUFBRSxFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsR0FBRztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsR0FBRyxNQUFNLFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGtCQUFrQjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkgsY0FBYztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpREFBRTtBQUNYO0FBQ0E7QUFDQSxrREFBa0QsNkNBQUU7QUFDcEQsV0FBVywwREFBRTtBQUNiO0FBQ0EsS0FBSyxPQUFPLGdEQUFFO0FBQ2Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLLE9BQU8sb0RBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0RBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQUssTUFBTSxLQUFLLE1BQU0sRUFBRTtBQUN4RDtBQUNBLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrRUFBa0UsRUFBRSxHQUFHLEVBQUUsRUFBRTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBc0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVkscUVBQXFFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVkscUVBQXFFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxrQkFBa0IsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQSxzSUFBc0k7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxZQUFZO0FBQ2hJLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFD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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZW1vdGlvbi1jYXB0aW9ucy8uL25vZGVfbW9kdWxlcy9AaW50ZXJhY3RpZnkvbW92ZWFibGUvZGlzdC9pbmRleC5lcy5qcz85NGI1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciAkYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBGYSA9ICh0LCBlLCBuKSA9PiBlIGluIHQgPyAkYSh0LCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBuIH0pIDogdFtlXSA9IG47XG52YXIgWCA9ICh0LCBlLCBuKSA9PiBGYSh0LCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCBuKTtcbmltcG9ydCAqIGFzIF9vIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFRvLCB7IGNyZWF0ZUVsZW1lbnQgYXMgQm4sIGZvcndhcmRSZWYgYXMgTGEsIHVzZVJlZiBhcyBOYSwgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyBXYSwgdXNlRWZmZWN0IGFzIFlhIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBkbih0LCBlKSB7XG4gIHJldHVybiB7XG4gICAgZXZlbnRzOiBbXSxcbiAgICBwcm9wczogW10sXG4gICAgbmFtZTogdCxcbiAgICAuLi5lXG4gIH07XG59XG5mdW5jdGlvbiBWcih0LCBlKSB7XG4gIGZvciAodmFyIG4gPSB0Lmxlbmd0aCwgciA9IDA7IHIgPCBuOyArK3IpXG4gICAgaWYgKGUodFtyXSwgcikpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIE9vKHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IHQubGVuZ3RoLCByID0gMDsgciA8IG47ICsrcilcbiAgICBpZiAoZSh0W3JdLCByKSlcbiAgICAgIHJldHVybiB0W3JdO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHdvKHQpIHtcbiAgdmFyIGUgPSB0O1xuICBpZiAodHlwZW9mIGUgPiBcInVcIikge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID4gXCJ1XCIgfHwgIW5hdmlnYXRvcilcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGUgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCI7XG4gIH1cbiAgcmV0dXJuIGUudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGpyKHQsIGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCh0LCBcImdcIikuZXhlYyhlKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIFZhKCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA+IFwidVwiIHx8ICFuYXZpZ2F0b3IgfHwgIW5hdmlnYXRvci51c2VyQWdlbnREYXRhKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIHQgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YSwgZSA9IHQuYnJhbmRzIHx8IHQudWFMaXN0O1xuICByZXR1cm4gISEoZSAmJiBlLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBqYSh0LCBlKSB7XG4gIHZhciBuID0ganIoXCIoXCIgKyB0ICsgXCIpKCg/OlxcXFwvfFxcXFxzfDopKFswLTl8XFxcXC58X10rKSlcIiwgZSk7XG4gIHJldHVybiBuID8gblszXSA6IFwiXCI7XG59XG5mdW5jdGlvbiBTcih0KSB7XG4gIHJldHVybiB0LnJlcGxhY2UoL18vZywgXCIuXCIpO1xufVxuZnVuY3Rpb24gS2UodCwgZSkge1xuICB2YXIgbiA9IG51bGwsIHIgPSBcIi0xXCI7XG4gIHJldHVybiBWcih0LCBmdW5jdGlvbihzKSB7XG4gICAgdmFyIG8gPSBqcihcIihcIiArIHMudGVzdCArIFwiKSgoPzpcXFxcL3xcXFxcc3w6KShbMC05fFxcXFwufF9dKykpP1wiLCBlKTtcbiAgICByZXR1cm4gIW8gfHwgcy5icmFuZCA/ICExIDogKG4gPSBzLCByID0gb1szXSB8fCBcIi0xXCIsIHMudmVyc2lvbkFsaWFzID8gciA9IHMudmVyc2lvbkFsaWFzIDogcy52ZXJzaW9uVGVzdCAmJiAociA9IGphKHMudmVyc2lvblRlc3QudG9Mb3dlckNhc2UoKSwgZSkgfHwgciksIHIgPSBTcihyKSwgITApO1xuICB9KSwge1xuICAgIHByZXNldDogbixcbiAgICB2ZXJzaW9uOiByXG4gIH07XG59XG5mdW5jdGlvbiB4bih0LCBlKSB7XG4gIHZhciBuID0ge1xuICAgIGJyYW5kOiBcIlwiLFxuICAgIHZlcnNpb246IFwiLTFcIlxuICB9O1xuICByZXR1cm4gVnIodCwgZnVuY3Rpb24ocikge1xuICAgIHZhciBzID0gSW8oZSwgcik7XG4gICAgcmV0dXJuIHMgPyAobi5icmFuZCA9IHIuaWQsIG4udmVyc2lvbiA9IHIudmVyc2lvbkFsaWFzIHx8IHMudmVyc2lvbiwgbi52ZXJzaW9uICE9PSBcIi0xXCIpIDogITE7XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gSW8odCwgZSkge1xuICByZXR1cm4gT28odCwgZnVuY3Rpb24obikge1xuICAgIHZhciByID0gbi5icmFuZDtcbiAgICByZXR1cm4ganIoXCJcIiArIGUudGVzdCwgci50b0xvd2VyQ2FzZSgpKTtcbiAgfSk7XG59XG52YXIgQm8gPSBbe1xuICB0ZXN0OiBcInBoYW50b21qc1wiLFxuICBpZDogXCJwaGFudG9tanNcIlxufSwge1xuICB0ZXN0OiBcIndoYWxlXCIsXG4gIGlkOiBcIndoYWxlXCJcbn0sIHtcbiAgdGVzdDogXCJlZGdpb3N8ZWRnZXxlZGdcIixcbiAgaWQ6IFwiZWRnZVwiXG59LCB7XG4gIHRlc3Q6IFwibXNpZXx0cmlkZW50fHdpbmRvd3MgcGhvbmVcIixcbiAgaWQ6IFwiaWVcIixcbiAgdmVyc2lvblRlc3Q6IFwiaWVtb2JpbGV8bXNpZXxydlwiXG59LCB7XG4gIHRlc3Q6IFwibWl1aWJyb3dzZXJcIixcbiAgaWQ6IFwibWl1aSBicm93c2VyXCJcbn0sIHtcbiAgdGVzdDogXCJzYW1zdW5nYnJvd3NlclwiLFxuICBpZDogXCJzYW1zdW5nIGludGVybmV0XCJcbn0sIHtcbiAgdGVzdDogXCJzYW1zdW5nXCIsXG4gIGlkOiBcInNhbXN1bmcgaW50ZXJuZXRcIixcbiAgdmVyc2lvblRlc3Q6IFwidmVyc2lvblwiXG59LCB7XG4gIHRlc3Q6IFwiY2hyb21lfGNyaW9zXCIsXG4gIGlkOiBcImNocm9tZVwiXG59LCB7XG4gIHRlc3Q6IFwiZmlyZWZveHxmeGlvc1wiLFxuICBpZDogXCJmaXJlZm94XCJcbn0sIHtcbiAgdGVzdDogXCJhbmRyb2lkXCIsXG4gIGlkOiBcImFuZHJvaWQgYnJvd3NlclwiLFxuICB2ZXJzaW9uVGVzdDogXCJ2ZXJzaW9uXCJcbn0sIHtcbiAgdGVzdDogXCJzYWZhcml8aXBob25lfGlwYWR8aXBvZFwiLFxuICBpZDogXCJzYWZhcmlcIixcbiAgdmVyc2lvblRlc3Q6IFwidmVyc2lvblwiXG59XSwgem8gPSBbe1xuICB0ZXN0OiBcIig/PS4qYXBwbGV3ZWJraXQvKDUzWzAtN118NVswLTJdfFswLTRdKSkoPz0uKlxcXFxzY2hyb21lKVwiLFxuICBpZDogXCJjaHJvbWVcIixcbiAgdmVyc2lvblRlc3Q6IFwiY2hyb21lXCJcbn0sIHtcbiAgdGVzdDogXCJjaHJvbWl1bVwiLFxuICBpZDogXCJjaHJvbWVcIlxufSwge1xuICB0ZXN0OiBcIndoYWxlXCIsXG4gIGlkOiBcImNocm9tZVwiLFxuICB2ZXJzaW9uQWxpYXM6IFwiLTFcIixcbiAgYnJhbmQ6ICEwXG59XSwgRXIgPSBbe1xuICB0ZXN0OiBcImFwcGxld2Via2l0XCIsXG4gIGlkOiBcIndlYmtpdFwiLFxuICB2ZXJzaW9uVGVzdDogXCJhcHBsZXdlYmtpdHxzYWZhcmlcIlxufV0sIEFvID0gW3tcbiAgdGVzdDogXCIoPz0oaXBob25lfGlwYWQpKSg/ISguKnZlcnNpb24pKVwiLFxuICBpZDogXCJ3ZWJ2aWV3XCJcbn0sIHtcbiAgdGVzdDogXCIoPz0oYW5kcm9pZHxpcGhvbmV8aXBhZCkpKD89LioobmF2ZXJ8ZGF1bXw7IHd2KSlcIixcbiAgaWQ6IFwid2Vidmlld1wiXG59LCB7XG4gIC8vIHRlc3Qgd2Vidmlld1xuICB0ZXN0OiBcIndlYnZpZXdcIixcbiAgaWQ6IFwid2Vidmlld1wiXG59XSwgR28gPSBbe1xuICB0ZXN0OiBcIndpbmRvd3MgcGhvbmVcIixcbiAgaWQ6IFwid2luZG93cyBwaG9uZVwiXG59LCB7XG4gIHRlc3Q6IFwid2luZG93cyAyMDAwXCIsXG4gIGlkOiBcIndpbmRvd1wiLFxuICB2ZXJzaW9uQWxpYXM6IFwiNS4wXCJcbn0sIHtcbiAgdGVzdDogXCJ3aW5kb3dzIG50XCIsXG4gIGlkOiBcIndpbmRvd1wiXG59LCB7XG4gIHRlc3Q6IFwid2luMzJ8d2luZG93c1wiLFxuICBpZDogXCJ3aW5kb3dcIlxufSwge1xuICB0ZXN0OiBcImlwaG9uZXxpcGFkfGlwb2RcIixcbiAgaWQ6IFwiaW9zXCIsXG4gIHZlcnNpb25UZXN0OiBcImlwaG9uZSBvc3xjcHUgb3NcIlxufSwge1xuICB0ZXN0OiBcIm1hY29zfG1hY2ludGVsfG1hYyBvcyB4XCIsXG4gIGlkOiBcIm1hY1wiXG59LCB7XG4gIHRlc3Q6IFwiYW5kcm9pZHxsaW51eCBhcm12ODFcIixcbiAgaWQ6IFwiYW5kcm9pZFwiXG59LCB7XG4gIHRlc3Q6IFwidGl6ZW5cIixcbiAgaWQ6IFwidGl6ZW5cIlxufSwge1xuICB0ZXN0OiBcIndlYm9zfHdlYjBzXCIsXG4gIGlkOiBcIndlYm9zXCJcbn1dO1xuZnVuY3Rpb24ga28odCkge1xuICByZXR1cm4gISFLZShBbywgdCkucHJlc2V0O1xufVxuZnVuY3Rpb24gWGEodCkge1xuICB2YXIgZSA9IHdvKHQpLCBuID0gISEvbW9iaS9nLmV4ZWMoZSksIHIgPSB7XG4gICAgbmFtZTogXCJ1bmtub3duXCIsXG4gICAgdmVyc2lvbjogXCItMVwiLFxuICAgIG1ham9yVmVyc2lvbjogLTEsXG4gICAgd2Vidmlldzoga28oZSksXG4gICAgY2hyb21pdW06ICExLFxuICAgIGNocm9taXVtVmVyc2lvbjogXCItMVwiLFxuICAgIHdlYmtpdDogITEsXG4gICAgd2Via2l0VmVyc2lvbjogXCItMVwiXG4gIH0sIHMgPSB7XG4gICAgbmFtZTogXCJ1bmtub3duXCIsXG4gICAgdmVyc2lvbjogXCItMVwiLFxuICAgIG1ham9yVmVyc2lvbjogLTFcbiAgfSwgbyA9IEtlKEJvLCBlKSwgaSA9IG8ucHJlc2V0LCBhID0gby52ZXJzaW9uLCBjID0gS2UoR28sIGUpLCBsID0gYy5wcmVzZXQsIHUgPSBjLnZlcnNpb24sIGYgPSBLZSh6bywgZSk7XG4gIGlmIChyLmNocm9taXVtID0gISFmLnByZXNldCwgci5jaHJvbWl1bVZlcnNpb24gPSBmLnZlcnNpb24sICFyLmNocm9taXVtKSB7XG4gICAgdmFyIGQgPSBLZShFciwgZSk7XG4gICAgci53ZWJraXQgPSAhIWQucHJlc2V0LCByLndlYmtpdFZlcnNpb24gPSBkLnZlcnNpb247XG4gIH1cbiAgcmV0dXJuIGwgJiYgKHMubmFtZSA9IGwuaWQsIHMudmVyc2lvbiA9IHUsIHMubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQodSwgMTApKSwgaSAmJiAoci5uYW1lID0gaS5pZCwgci52ZXJzaW9uID0gYSwgci53ZWJ2aWV3ICYmIHMubmFtZSA9PT0gXCJpb3NcIiAmJiByLm5hbWUgIT09IFwic2FmYXJpXCIgJiYgKHIud2VidmlldyA9ICExKSksIHIubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQoci52ZXJzaW9uLCAxMCksIHtcbiAgICBicm93c2VyOiByLFxuICAgIG9zOiBzLFxuICAgIGlzTW9iaWxlOiBuLFxuICAgIGlzSGludHM6ICExXG4gIH07XG59XG5mdW5jdGlvbiBIYSh0KSB7XG4gIHZhciBlID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEsIG4gPSAoZS51YUxpc3QgfHwgZS5icmFuZHMpLnNsaWNlKCksIHIgPSBlLm1vYmlsZSB8fCAhMSwgcyA9IG5bMF0sIG8gPSAoZS5wbGF0Zm9ybSB8fCBuYXZpZ2F0b3IucGxhdGZvcm0pLnRvTG93ZXJDYXNlKCksIGkgPSB7XG4gICAgbmFtZTogcy5icmFuZCxcbiAgICB2ZXJzaW9uOiBzLnZlcnNpb24sXG4gICAgbWFqb3JWZXJzaW9uOiAtMSxcbiAgICB3ZWJraXQ6ICExLFxuICAgIHdlYmtpdFZlcnNpb246IFwiLTFcIixcbiAgICBjaHJvbWl1bTogITEsXG4gICAgY2hyb21pdW1WZXJzaW9uOiBcIi0xXCIsXG4gICAgd2VidmlldzogISF4bihBbywgbikuYnJhbmQgfHwga28od28oKSlcbiAgfSwgYSA9IHtcbiAgICBuYW1lOiBcInVua25vd25cIixcbiAgICB2ZXJzaW9uOiBcIi0xXCIsXG4gICAgbWFqb3JWZXJzaW9uOiAtMVxuICB9O1xuICBpLndlYmtpdCA9ICFpLmNocm9taXVtICYmIFZyKEVyLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIElvKG4sIGQpO1xuICB9KTtcbiAgdmFyIGMgPSB4bih6bywgbik7XG4gIGlmIChpLmNocm9taXVtID0gISFjLmJyYW5kLCBpLmNocm9taXVtVmVyc2lvbiA9IGMudmVyc2lvbiwgIWkuY2hyb21pdW0pIHtcbiAgICB2YXIgbCA9IHhuKEVyLCBuKTtcbiAgICBpLndlYmtpdCA9ICEhbC5icmFuZCwgaS53ZWJraXRWZXJzaW9uID0gbC52ZXJzaW9uO1xuICB9XG4gIHZhciB1ID0gT28oR28sIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIlwiICsgZC50ZXN0LCBcImdcIikuZXhlYyhvKTtcbiAgfSk7XG4gIGEubmFtZSA9IHUgPyB1LmlkIDogXCJcIjtcbiAge1xuICAgIHZhciBmID0geG4oQm8sIG4pO1xuICAgIGkubmFtZSA9IGYuYnJhbmQgfHwgaS5uYW1lLCBpLnZlcnNpb24gPSBmLmJyYW5kICYmIHQgPyB0LnVhRnVsbFZlcnNpb24gOiBmLnZlcnNpb247XG4gIH1cbiAgcmV0dXJuIGkud2Via2l0ICYmIChhLm5hbWUgPSByID8gXCJpb3NcIiA6IFwibWFjXCIpLCBhLm5hbWUgPT09IFwiaW9zXCIgJiYgaS53ZWJ2aWV3ICYmIChpLnZlcnNpb24gPSBcIi0xXCIpLCBhLnZlcnNpb24gPSBTcihhLnZlcnNpb24pLCBpLnZlcnNpb24gPSBTcihpLnZlcnNpb24pLCBhLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KGEudmVyc2lvbiwgMTApLCBpLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KGkudmVyc2lvbiwgMTApLCB7XG4gICAgYnJvd3NlcjogaSxcbiAgICBvczogYSxcbiAgICBpc01vYmlsZTogcixcbiAgICBpc0hpbnRzOiAhMFxuICB9O1xufVxuZnVuY3Rpb24gcWEodCkge1xuICByZXR1cm4gVmEoKSA/IEhhKCkgOiBYYSh0KTtcbn1cbmNvbnN0IFVhID0gW1wiblwiLCBcIndcIiwgXCJzXCIsIFwiZVwiXSwgWHIgPSBbXCJuXCIsIFwid1wiLCBcInNcIiwgXCJlXCIsIFwibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl07XG5mdW5jdGlvbiBLYSh0LCBlKSB7XG4gIHJldHVybiBgZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIkezMyICogdH1weFwiIGhlaWdodD1cIiR7MzIgKiB0fXB4XCIgdmlld0JveD1cIjAgMCAzMiAzMlwiID48cGF0aCBkPVwiTSAxNiw1IEwgMTIsMTAgTCAxNC41LDEwIEwgMTQuNSwyMiBMIDEyLDIyIEwgMTYsMjcgTCAyMCwyMiBMIDE3LjUsMjIgTCAxNy41LDEwIEwgMjAsIDEwIEwgMTYsNSBaXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIxLjJcIiBmaWxsPVwiYmxhY2tcIiBzdHJva2U9XCJ3aGl0ZVwiIHN0eWxlPVwidHJhbnNmb3JtOnJvdGF0ZSgke2V9ZGVnKTt0cmFuc2Zvcm0tb3JpZ2luOiAxNnB4IDE2cHhcIj48L3BhdGg+PC9zdmc+YDtcbn1cbmZ1bmN0aW9uIFphKHQpIHtcbiAgY29uc3QgZSA9IEthKDEsIHQpLCBuID0gTWF0aC5yb3VuZCh0IC8gNDUpICogNDUgJSAxODA7XG4gIGxldCByID0gXCJucy1yZXNpemVcIjtcbiAgcmV0dXJuIG4gPT09IDEzNSA/IHIgPSBcIm53c2UtcmVzaXplXCIgOiBuID09PSA0NSA/IHIgPSBcIm5lc3ctcmVzaXplXCIgOiBuID09PSA5MCAmJiAociA9IFwiZXctcmVzaXplXCIpLCBgY3Vyc29yOiR7cn07Y3Vyc29yOiB1cmwoJyR7ZX0nKSAxNiAxNiwgJHtyfTtgO1xufVxuY29uc3QgWWUgPSBxYSgpLCAkbyA9IFllLmJyb3dzZXIud2Via2l0LCBGbyA9ICRvICYmICgoKSA9PiB7XG4gIGNvbnN0IHQgPSB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgPyB7IHVzZXJBZ2VudDogXCJcIiB9IDogd2luZG93Lm5hdmlnYXRvciwgZSA9IC9hcHBsZXdlYmtpdFxcLyhbXlxcc10rKS9nLmV4ZWModC51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG4gIHJldHVybiBlID8gcGFyc2VGbG9hdChlWzFdKSA8IDYwNSA6ICExO1xufSkoKSwgTG8gPSBZZS5icm93c2VyLm5hbWUsIE5vID0gcGFyc2VJbnQoWWUuYnJvd3Nlci52ZXJzaW9uLCAxMCksIEphID0gTG8gPT09IFwiY2hyb21lXCIsIFFhID0gWWUuYnJvd3Nlci5jaHJvbWl1bSwgdGMgPSBwYXJzZUludChZZS5icm93c2VyLmNocm9taXVtVmVyc2lvbiwgMTApIHx8IDAsIGVjID0gSmEgJiYgTm8gPj0gMTA5IHx8IFFhICYmIHRjID49IDEwOSwgbmMgPSBMbyA9PT0gXCJmaXJlZm94XCIsIHJjID0gcGFyc2VJbnQoWWUuYnJvd3Nlci53ZWJraXRWZXJzaW9uLCAxMCkgPj0gNjEyIHx8IE5vID49IDE1LCBIciA9IFwibW92ZWFibGUtXCIsIHNjID0gWHIubWFwKCh0KSA9PiB7XG4gIGxldCBlID0gXCJcIiwgbiA9IFwiXCIsIHIgPSBcImNlbnRlclwiLCBzID0gXCJjZW50ZXJcIjtcbiAgY29uc3QgbyA9IFwiY2FsYyh2YXIoLS1tb3ZlYWJsZS1jb250cm9sLXBhZGRpbmcsIDIwKSAqIC0xcHgpXCI7XG4gIHJldHVybiB0LmluZGV4T2YoXCJuXCIpID4gLTEgJiYgKGUgPSBgdG9wOiAke299O2AsIHMgPSBcImJvdHRvbVwiKSwgdC5pbmRleE9mKFwic1wiKSA+IC0xICYmIChlID0gXCJ0b3A6IDBweDtcIiwgcyA9IFwidG9wXCIpLCB0LmluZGV4T2YoXCJ3XCIpID4gLTEgJiYgKG4gPSBgbGVmdDogJHtvfTtgLCByID0gXCJyaWdodFwiKSwgdC5pbmRleE9mKFwiZVwiKSA+IC0xICYmIChuID0gXCJsZWZ0OiAwcHg7XCIsIHIgPSBcImxlZnRcIiksIGAuYXJvdW5kLWNvbnRyb2xbZGF0YS1kaXJlY3Rpb24qPVwiJHt0fVwiXSB7XG4gICAgICAgICR7bn0ke2V9XG4gICAgICAgIHRyYW5zZm9ybS1vcmlnaW46ICR7cn0gJHtzfTtcbiAgICB9YDtcbn0pLmpvaW4oYFxuYCksIG9jID0gYFxue1xucG9zaXRpb246IGFic29sdXRlO1xud2lkdGg6IDFweDtcbmhlaWdodDogMXB4O1xubGVmdDogMDtcbnRvcDogMDtcbnotaW5kZXg6IDMwMDA7XG4tLW1vdmVhYmxlLWNvbG9yOiAjNGFmO1xuLS16b29tOiAxO1xuLS16b29tcHg6IDFweDtcbi0tbW92ZWFibGUtbGluZS1wYWRkaW5nOiAwO1xuLS1tb3ZlYWJsZS1jb250cm9sLXBhZGRpbmc6IDA7XG53aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xub3V0bGluZTogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xufVxuLmNvbnRyb2wtYm94IHtcbnotaW5kZXg6IDA7XG59XG4ubGluZSwgLmNvbnRyb2wge1xucG9zaXRpb246IGFic29sdXRlO1xubGVmdDogMDtcbnRvcDogMDtcbndpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG59XG4uY29udHJvbCB7XG53aWR0aDogMTRweDtcbmhlaWdodDogMTRweDtcbmJvcmRlci1yYWRpdXM6IDUwJTtcbmJvcmRlcjogMnB4IHNvbGlkICNmZmY7XG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xuYmFja2dyb3VuZDogIzRhZjtcbmJhY2tncm91bmQ6IHZhcigtLW1vdmVhYmxlLWNvbG9yKTtcbm1hcmdpbi10b3A6IC03cHg7XG5tYXJnaW4tbGVmdDogLTdweDtcbmJvcmRlcjogMnB4IHNvbGlkICNmZmY7XG56LWluZGV4OiAxMDtcbn1cbi5hcm91bmQtY29udHJvbCB7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG53aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xud2lkdGg6IGNhbGModmFyKC0tbW92ZWFibGUtY29udHJvbC1wYWRkaW5nLCAyMCkgKiAxcHgpO1xuaGVpZ2h0OiBjYWxjKHZhcigtLW1vdmVhYmxlLWNvbnRyb2wtcGFkZGluZywgMjApICogMXB4KTtcbmxlZnQ6IGNhbGModmFyKC0tbW92ZWFibGUtY29udHJvbC1wYWRkaW5nLCAyMCkgKiAtMC41cHgpO1xudG9wOiBjYWxjKHZhcigtLW1vdmVhYmxlLWNvbnRyb2wtcGFkZGluZywgMjApICogLTAuNXB4KTtcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5iYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbnotaW5kZXg6IDg7XG5jdXJzb3I6IGFsaWFzO1xudHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcbn1cbiR7c2N9XG4ucGFkZGluZyB7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG50b3A6IDBweDtcbmxlZnQ6IDBweDtcbndpZHRoOiAxMDBweDtcbmhlaWdodDogMTAwcHg7XG50cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XG59XG4ubGluZSB7XG53aWR0aDogMXB4O1xuaGVpZ2h0OiAxcHg7XG5iYWNrZ3JvdW5kOiAjNGFmO1xuYmFja2dyb3VuZDogdmFyKC0tbW92ZWFibGUtY29sb3IpO1xudHJhbnNmb3JtLW9yaWdpbjogMHB4IDUwJTtcbn1cbi5saW5lLmVkZ2Uge1xuei1pbmRleDogMTtcbmJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuLmxpbmUuZGFzaGVkIHtcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5iYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cbi5saW5lLmRhc2hlZC5ob3Jpem9udGFsIHtcbmJvcmRlci10b3A6IDFweCBkYXNoZWQgIzRhZjtcbmJvcmRlci10b3AtY29sb3I6ICM0YWY7XG5ib3JkZXItdG9wLWNvbG9yOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XG59XG4ubGluZS5kYXNoZWQudmVydGljYWwge1xuYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzRhZjtcbmJvcmRlci1sZWZ0LWNvbG9yOiAjNGFmO1xuYm9yZGVyLWxlZnQtY29sb3I6IHZhcigtLW1vdmVhYmxlLWNvbG9yKTtcbn1cbi5saW5lLnZlcnRpY2FsIHtcbnRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbn1cbi5saW5lLmhvcml6b250YWwge1xudHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xufVxuLmxpbmUudmVydGljYWwuYm9sZCB7XG53aWR0aDogMnB4O1xufVxuLmxpbmUuaG9yaXpvbnRhbC5ib2xkIHtcbmhlaWdodDogMnB4O1xufVxuXG4uY29udHJvbC5vcmlnaW4ge1xuYm9yZGVyLWNvbG9yOiAjZjU1O1xuYmFja2dyb3VuZDogI2ZmZjtcbndpZHRoOiAxMnB4O1xuaGVpZ2h0OiAxMnB4O1xubWFyZ2luLXRvcDogLTZweDtcbm1hcmdpbi1sZWZ0OiAtNnB4O1xucG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG4ke1swLCAxNSwgMzAsIDQ1LCA2MCwgNzUsIDkwLCAxMDUsIDEyMCwgMTM1LCAxNTAsIDE2NV0ubWFwKCh0KSA9PiBgXG4uZGlyZWN0aW9uW2RhdGEtcm90YXRpb249XCIke3R9XCJdLCA6Z2xvYmFsIC52aWV3LWNvbnRyb2wtcm90YXRpb24ke3R9IHtcbiR7WmEodCl9XG59XG5gKS5qb2luKGBcbmApfVxuXG4ubGluZS5kaXJlY3Rpb246YmVmb3JlIHtcbmNvbnRlbnQ6IFwiXCI7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG53aWR0aDogMTAwJTtcbmhlaWdodDogY2FsYyh2YXIoLS1tb3ZlYWJsZS1saW5lLXBhZGRpbmcsIDApICogMXB4KTtcbmJvdHRvbTogMDtcbmxlZnQ6IDA7XG59XG4uZ3JvdXAge1xuei1pbmRleDogLTE7XG59XG4uYXJlYSB7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG59XG4uYXJlYS1waWVjZXMge1xucG9zaXRpb246IGFic29sdXRlO1xudG9wOiAwO1xubGVmdDogMDtcbmRpc3BsYXk6IG5vbmU7XG59XG4uYXJlYS5hdm9pZCwgLmFyZWEucGFzcyB7XG5wb2ludGVyLWV2ZW50czogbm9uZTtcbn1cbi5hcmVhLmF2b2lkKy5hcmVhLXBpZWNlcyB7XG5kaXNwbGF5OiBibG9jaztcbn1cbi5hcmVhLXBpZWNlIHtcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcbn1cblxuJHtGbyA/IGA6Z2xvYmFsIHN2ZyAqOmJlZm9yZSB7XG5jb250ZW50OlwiXCI7XG50cmFuc2Zvcm0tb3JpZ2luOiBpbmhlcml0O1xufWAgOiBcIlwifVxuYCwgaWMgPSBbXG4gIFswLCAxLCAyXSxcbiAgWzEsIDAsIDNdLFxuICBbMiwgMCwgM10sXG4gIFszLCAxLCAyXVxuXSwgQ3IgPSAxZS00LCBCdCA9IDFlLTcsIFNuID0gMWUtOSwgRHIgPSBNYXRoLnBvdygxMCwgMTApLCBGcyA9IC1EciwgYWMgPSB7XG4gIG46IFswLCAtMV0sXG4gIGU6IFsxLCAwXSxcbiAgczogWzAsIDFdLFxuICB3OiBbLTEsIDBdLFxuICBudzogWy0xLCAtMV0sXG4gIG5lOiBbMSwgLTFdLFxuICBzdzogWy0xLCAxXSxcbiAgc2U6IFsxLCAxXVxufSwgcXIgPSB7XG4gIG46IFswLCAxXSxcbiAgZTogWzEsIDNdLFxuICBzOiBbMywgMl0sXG4gIHc6IFsyLCAwXSxcbiAgbnc6IFswXSxcbiAgbmU6IFsxXSxcbiAgc3c6IFsyXSxcbiAgc2U6IFszXVxufSwgV28gPSB7XG4gIG46IDAsXG4gIHM6IDE4MCxcbiAgdzogMjcwLFxuICBlOiA5MCxcbiAgbnc6IDMxNSxcbiAgbmU6IDQ1LFxuICBzdzogMjI1LFxuICBzZTogMTM1XG59LCB3ZiA9IFtcbiAgXCJpc01vdmVhYmxlRWxlbWVudFwiLFxuICBcInVwZGF0ZVJlY3RcIixcbiAgXCJ1cGRhdGVUYXJnZXRcIixcbiAgXCJkZXN0cm95XCIsXG4gIFwiZHJhZ1N0YXJ0XCIsXG4gIFwiaXNJbnNpZGVcIixcbiAgXCJoaXRUZXN0XCIsXG4gIFwic2V0U3RhdGVcIixcbiAgXCJnZXRSZWN0XCIsXG4gIFwicmVxdWVzdFwiLFxuICBcImlzRHJhZ2dpbmdcIixcbiAgXCJnZXRNYW5hZ2VyXCIsXG4gIFwiZm9yY2VVcGRhdGVcIixcbiAgXCJ3YWl0VG9DaGFuZ2VUYXJnZXRcIixcbiAgXCJ1cGRhdGVTZWxlY3RvcnNcIixcbiAgXCJnZXRUYXJnZXRzXCIsXG4gIFwic3RvcERyYWdcIixcbiAgXCJnZXRDb250cm9sQm94RWxlbWVudFwiLFxuICBcImdldE1vdmVhYmxlc1wiLFxuICBcImdldERyYWdFbGVtZW50XCJcbl07XG5mdW5jdGlvbiBjYyh0LCAuLi5lKSB7XG4gIHJldHVybiBlLm1hcChcbiAgICAobikgPT4gbi5zcGxpdChcIiBcIikubWFwKChyKSA9PiByID8gYCR7dH0ke3J9YCA6IFwiXCIpLmpvaW4oXCIgXCIpXG4gICkuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiBsYyh0LCBlKSB7XG4gIHJldHVybiBlLnJlcGxhY2UoLyhbXn17XSopey9nbSwgKG4sIHIpID0+IGAke3IucmVwbGFjZSgvXFwuKFteeyxcXHNcXGQuXSspL2csIGAuJHt0fSQxYCl9e2ApO1xufVxuZnVuY3Rpb24gU2UodCwgZSkge1xuICByZXR1cm4gKG4pID0+IHtcbiAgICBuICYmICh0W2VdID0gbik7XG4gIH07XG59XG5mdW5jdGlvbiBZbyh0LCBlLCBuKSB7XG4gIHJldHVybiAocikgPT4ge1xuICAgIHIgJiYgKHRbZV1bbl0gPSByKTtcbiAgfTtcbn1cbnZhciB1YyA9IFwiZnVuY3Rpb25cIiwgZmMgPSBcIm9iamVjdFwiLCBkYyA9IFwic3RyaW5nXCIsIHBjID0gXCJudW1iZXJcIiwgVXIgPSBcInVuZGVmaW5lZFwiLCBWbyA9IHR5cGVvZiB3aW5kb3cgIT09IFVyLCBnYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gVXIgJiYgZG9jdW1lbnQsIGhjID0gW3tcbiAgb3BlbjogXCIoXCIsXG4gIGNsb3NlOiBcIilcIlxufSwge1xuICBvcGVuOiAnXCInLFxuICBjbG9zZTogJ1wiJ1xufSwge1xuICBvcGVuOiBcIidcIixcbiAgY2xvc2U6IFwiJ1wiXG59LCB7XG4gIG9wZW46ICdcXFxcXCInLFxuICBjbG9zZTogJ1xcXFxcIidcbn0sIHtcbiAgb3BlbjogXCJcXFxcJ1wiLFxuICBjbG9zZTogXCJcXFxcJ1wiXG59XSwgRHQgPSAxZS03LCBFbiA9IHtcbiAgY206IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAqIDk2IC8gMi41NDtcbiAgfSxcbiAgbW06IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAqIDk2IC8gMjU0O1xuICB9LFxuICBpbjogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0ICogOTY7XG4gIH0sXG4gIHB0OiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgKiA5NiAvIDcyO1xuICB9LFxuICBwYzogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0ICogOTYgLyA2O1xuICB9LFxuICBcIiVcIjogZnVuY3Rpb24odCwgZSkge1xuICAgIHJldHVybiB0ICogZSAvIDEwMDtcbiAgfSxcbiAgdnc6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gd2luZG93LmlubmVyV2lkdGgpLCB0IC8gMTAwICogZTtcbiAgfSxcbiAgdmg6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gd2luZG93LmlubmVySGVpZ2h0KSwgdCAvIDEwMCAqIGU7XG4gIH0sXG4gIHZtYXg6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gTWF0aC5tYXgod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCkpLCB0IC8gMTAwICogZTtcbiAgfSxcbiAgdm1pbjogZnVuY3Rpb24odCwgZSkge1xuICAgIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSksIHQgLyAxMDAgKiBlO1xuICB9XG59O1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5mdW5jdGlvbiB2YygpIHtcbiAgZm9yICh2YXIgdCA9IDAsIGUgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgZSA8IG47IGUrKykgdCArPSBhcmd1bWVudHNbZV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkodCksIHMgPSAwLCBlID0gMDsgZSA8IG47IGUrKykgZm9yICh2YXIgbyA9IGFyZ3VtZW50c1tlXSwgaSA9IDAsIGEgPSBvLmxlbmd0aDsgaSA8IGE7IGkrKywgcysrKSByW3NdID0gb1tpXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiB6bih0LCBlLCBuLCByKSB7XG4gIHJldHVybiAodCAqIHIgKyBlICogbikgLyAobiArIHIpO1xufVxuZnVuY3Rpb24gS3IodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT09IFVyO1xufVxuZnVuY3Rpb24gcXQodCkge1xuICByZXR1cm4gdCAmJiB0eXBlb2YgdCA9PT0gZmM7XG59XG5mdW5jdGlvbiBSdCh0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHQpO1xufVxuZnVuY3Rpb24gcmUodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT09IGRjO1xufVxuZnVuY3Rpb24gYW4odCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT09IHBjO1xufVxuZnVuY3Rpb24gWnIodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT09IHVjO1xufVxuZnVuY3Rpb24gbWModCwgZSkge1xuICB2YXIgbiA9IHQgPT09IFwiXCIgfHwgdCA9PSBcIiBcIiwgciA9IGUgPT09IFwiXCIgfHwgZSA9PSBcIiBcIjtcbiAgcmV0dXJuIHIgJiYgbiB8fCB0ID09PSBlO1xufVxuZnVuY3Rpb24gam8odCwgZSwgbiwgciwgcykge1xuICB2YXIgbyA9IEpyKHQsIGUsIG4pO1xuICByZXR1cm4gbyA/IG4gOiB4Yyh0LCBlLCBuICsgMSwgciwgcyk7XG59XG5mdW5jdGlvbiBKcih0LCBlLCBuKSB7XG4gIGlmICghdC5pZ25vcmUpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciByID0gZS5zbGljZShNYXRoLm1heChuIC0gMywgMCksIG4gKyAzKS5qb2luKFwiXCIpO1xuICByZXR1cm4gbmV3IFJlZ0V4cCh0Lmlnbm9yZSkuZXhlYyhyKTtcbn1cbmZ1bmN0aW9uIHhjKHQsIGUsIG4sIHIsIHMpIHtcbiAgZm9yICh2YXIgbyA9IGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgdSA9IGVbbF0udHJpbSgpO1xuICAgIGlmICh1ID09PSB0LmNsb3NlICYmICFKcih0LCBlLCBsKSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBsXG4gICAgICB9O1xuICAgIHZhciBmID0gbCwgZCA9IGt0KHMsIGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBnID0gcC5vcGVuO1xuICAgICAgcmV0dXJuIGcgPT09IHU7XG4gICAgfSk7XG4gICAgaWYgKGQgJiYgKGYgPSBqbyhkLCBlLCBsLCByLCBzKSksIGYgPT09IC0xKVxuICAgICAgcmV0dXJuIGkgPSBsLCBcImJyZWFrXCI7XG4gICAgbCA9IGYsIGkgPSBsO1xuICB9LCBpLCBhID0gbjsgYSA8IHI7ICsrYSkge1xuICAgIHZhciBjID0gbyhhKTtcbiAgICBpZiAoYSA9IGksIHR5cGVvZiBjID09IFwib2JqZWN0XCIpIHJldHVybiBjLnZhbHVlO1xuICAgIGlmIChjID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIFFyKHQsIGUpIHtcbiAgdmFyIG4gPSByZShlKSA/IHtcbiAgICBzZXBhcmF0b3I6IGVcbiAgfSA6IGUsIHIgPSBuLnNlcGFyYXRvciwgcyA9IHIgPT09IHZvaWQgMCA/IFwiLFwiIDogciwgbyA9IG4uaXNTZXBhcmF0ZUZpcnN0LCBpID0gbi5pc1NlcGFyYXRlT25seU9wZW5DbG9zZSwgYSA9IG4uaXNTZXBhcmF0ZU9wZW5DbG9zZSwgYyA9IGEgPT09IHZvaWQgMCA/IGkgOiBhLCBsID0gbi5vcGVuQ2xvc2VDaGFyYWN0ZXJzLCB1ID0gbCA9PT0gdm9pZCAwID8gaGMgOiBsLCBmID0gdS5tYXAoZnVuY3Rpb24oUikge1xuICAgIHZhciB5ID0gUi5vcGVuLCBNID0gUi5jbG9zZTtcbiAgICByZXR1cm4geSA9PT0gTSA/IHkgOiB5ICsgXCJ8XCIgKyBNO1xuICB9KS5qb2luKFwifFwiKSwgZCA9IFwiKFxcXFxzKlwiICsgcyArIFwiXFxcXHMqfFwiICsgZiArIFwifFxcXFxzKylcIiwgcCA9IG5ldyBSZWdFeHAoZCwgXCJnXCIpLCBnID0gdC5zcGxpdChwKS5maWx0ZXIoZnVuY3Rpb24oUikge1xuICAgIHJldHVybiBSICYmIFIgIT09IFwidW5kZWZpbmVkXCI7XG4gIH0pLCBoID0gZy5sZW5ndGgsIHYgPSBbXSwgbSA9IFtdO1xuICBmdW5jdGlvbiBTKCkge1xuICAgIHJldHVybiBtLmxlbmd0aCA/ICh2LnB1c2gobS5qb2luKFwiXCIpKSwgbSA9IFtdLCAhMCkgOiAhMTtcbiAgfVxuICBmb3IgKHZhciB4ID0gZnVuY3Rpb24oUikge1xuICAgIHZhciB5ID0gZ1tSXS50cmltKCksIE0gPSBSLCBQID0ga3QodSwgZnVuY3Rpb24oVCkge1xuICAgICAgdmFyIHcgPSBULm9wZW47XG4gICAgICByZXR1cm4gdyA9PT0geTtcbiAgICB9KSwgXyA9IGt0KHUsIGZ1bmN0aW9uKFQpIHtcbiAgICAgIHZhciB3ID0gVC5jbG9zZTtcbiAgICAgIHJldHVybiB3ID09PSB5O1xuICAgIH0pO1xuICAgIGlmIChQKSB7XG4gICAgICBpZiAoTSA9IGpvKFAsIGcsIFIsIGgsIHUpLCBNICE9PSAtMSAmJiBjKVxuICAgICAgICByZXR1cm4gUygpICYmIG8gfHwgKHYucHVzaChnLnNsaWNlKFIsIE0gKyAxKS5qb2luKFwiXCIpKSwgUiA9IE0sIG8pID8gKEMgPSBSLCBcImJyZWFrXCIpIDogKEMgPSBSLCBcImNvbnRpbnVlXCIpO1xuICAgIH0gZWxzZSBpZiAoXyAmJiAhSnIoXywgZywgUikpIHtcbiAgICAgIHZhciBPID0gdmModSk7XG4gICAgICByZXR1cm4gTy5zcGxpY2UodS5pbmRleE9mKF8pLCAxKSwge1xuICAgICAgICB2YWx1ZTogUXIodCwge1xuICAgICAgICAgIHNlcGFyYXRvcjogcyxcbiAgICAgICAgICBpc1NlcGFyYXRlRmlyc3Q6IG8sXG4gICAgICAgICAgaXNTZXBhcmF0ZU9ubHlPcGVuQ2xvc2U6IGksXG4gICAgICAgICAgaXNTZXBhcmF0ZU9wZW5DbG9zZTogYyxcbiAgICAgICAgICBvcGVuQ2xvc2VDaGFyYWN0ZXJzOiBPXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobWMoeSwgcykgJiYgIWkpXG4gICAgICByZXR1cm4gUygpLCBvID8gKEMgPSBSLCBcImJyZWFrXCIpIDogKEMgPSBSLCBcImNvbnRpbnVlXCIpO1xuICAgIE0gPT09IC0xICYmIChNID0gaCAtIDEpLCBtLnB1c2goZy5zbGljZShSLCBNICsgMSkuam9pbihcIlwiKSksIFIgPSBNLCBDID0gUjtcbiAgfSwgQywgRSA9IDA7IEUgPCBoOyArK0UpIHtcbiAgICB2YXIgRCA9IHgoRSk7XG4gICAgaWYgKEUgPSBDLCB0eXBlb2YgRCA9PSBcIm9iamVjdFwiKSByZXR1cm4gRC52YWx1ZTtcbiAgICBpZiAoRCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgfVxuICByZXR1cm4gbS5sZW5ndGggJiYgdi5wdXNoKG0uam9pbihcIlwiKSksIHY7XG59XG5mdW5jdGlvbiBjZSh0KSB7XG4gIHJldHVybiBRcih0LCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHhlKHQpIHtcbiAgcmV0dXJuIFFyKHQsIFwiLFwiKTtcbn1cbmZ1bmN0aW9uIFhvKHQpIHtcbiAgdmFyIGUgPSAvKFteKF0qKVxcKChbXFxzXFxTXSopXFwpKFtcXHNcXFNdKikvZy5leGVjKHQpO1xuICByZXR1cm4gIWUgfHwgZS5sZW5ndGggPCA0ID8ge30gOiB7XG4gICAgcHJlZml4OiBlWzFdLFxuICAgIHZhbHVlOiBlWzJdLFxuICAgIHN1ZmZpeDogZVszXVxuICB9O1xufVxuZnVuY3Rpb24gcG4odCkge1xuICB2YXIgZSA9IC9eKFteXFxkfGV8XFwtfFxcK10qKSgoPzpcXGR8XFwufC18ZS18ZVxcKykrKShcXFMqKSQvZy5leGVjKHQpO1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeDogXCJcIixcbiAgICAgIHVuaXQ6IFwiXCIsXG4gICAgICB2YWx1ZTogTmFOXG4gICAgfTtcbiAgdmFyIG4gPSBlWzFdLCByID0gZVsyXSwgcyA9IGVbM107XG4gIHJldHVybiB7XG4gICAgcHJlZml4OiBuLFxuICAgIHVuaXQ6IHMsXG4gICAgdmFsdWU6IHBhcnNlRmxvYXQocilcbiAgfTtcbn1cbmZ1bmN0aW9uIFNjKHQsIGUpIHtcbiAgcmV0dXJuIHQucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgZnVuY3Rpb24obiwgciwgcykge1xuICAgIHJldHVybiBcIlwiICsgciArIGUgKyBzLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY24oKSB7XG4gIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIG5lKHQsIGUsIG4pIHtcbiAgbiA9PT0gdm9pZCAwICYmIChuID0gLTEpO1xuICBmb3IgKHZhciByID0gdC5sZW5ndGgsIHMgPSAwOyBzIDwgcjsgKytzKVxuICAgIGlmIChlKHRbc10sIHMsIHQpKVxuICAgICAgcmV0dXJuIHM7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24ga3QodCwgZSwgbikge1xuICB2YXIgciA9IG5lKHQsIGUpO1xuICByZXR1cm4gciA+IC0xID8gdFtyXSA6IG47XG59XG52YXIgSG8gPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gY24oKSwgZSA9IFZvICYmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpO1xuICByZXR1cm4gZSA/IGUuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24obikge1xuICAgIHZhciByID0gY24oKSwgcyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBuKHIgLSB0KTtcbiAgICB9LCAxZTMgLyA2MCk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59KCksIEVjID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IFZvICYmICh3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZSk7XG4gIHJldHVybiB0ID8gdC5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbihlKSB7XG4gICAgY2xlYXJUaW1lb3V0KGUpO1xuICB9O1xufSgpO1xuZnVuY3Rpb24gVmUodCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModCk7XG59XG5mdW5jdGlvbiBmdCh0LCBlKSB7XG4gIHZhciBuID0gcG4odCksIHIgPSBuLnZhbHVlLCBzID0gbi51bml0O1xuICBpZiAocXQoZSkpIHtcbiAgICB2YXIgbyA9IGVbc107XG4gICAgaWYgKG8pIHtcbiAgICAgIGlmIChacihvKSlcbiAgICAgICAgcmV0dXJuIG8ocik7XG4gICAgICBpZiAoRW5bc10pXG4gICAgICAgIHJldHVybiBFbltzXShyLCBvKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocyA9PT0gXCIlXCIpXG4gICAgcmV0dXJuIHIgKiBlIC8gMTAwO1xuICByZXR1cm4gRW5bc10gPyBFbltzXShyKSA6IHI7XG59XG5mdW5jdGlvbiBicih0LCBlLCBuKSB7XG4gIHJldHVybiBNYXRoLm1heChlLCBNYXRoLm1pbih0LCBuKSk7XG59XG5mdW5jdGlvbiBMcyh0LCBlLCBuLCByKSB7XG4gIHJldHVybiByID09PSB2b2lkIDAgJiYgKHIgPSB0WzBdIC8gdFsxXSksIFtbdHQoZVswXSwgRHQpLCB0dChlWzBdIC8gciwgRHQpXSwgW3R0KGVbMV0gKiByLCBEdCksIHR0KGVbMV0sIER0KV1dLmZpbHRlcihmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIHMuZXZlcnkoZnVuY3Rpb24obywgaSkge1xuICAgICAgdmFyIGEgPSBlW2ldLCBjID0gdHQoYSwgRHQpO1xuICAgICAgcmV0dXJuIG4gPyBvIDw9IGEgfHwgbyA8PSBjIDogbyA+PSBhIHx8IG8gPj0gYztcbiAgICB9KTtcbiAgfSlbMF0gfHwgdDtcbn1cbmZ1bmN0aW9uIHFvKHQsIGUsIG4sIHIpIHtcbiAgaWYgKCFyKVxuICAgIHJldHVybiB0Lm1hcChmdW5jdGlvbihwLCBnKSB7XG4gICAgICByZXR1cm4gYnIocCwgZVtnXSwgbltnXSk7XG4gICAgfSk7XG4gIHZhciBzID0gdFswXSwgbyA9IHRbMV0sIGkgPSByID09PSAhMCA/IHMgLyBvIDogciwgYSA9IExzKHQsIGUsICExLCBpKSwgYyA9IGFbMF0sIGwgPSBhWzFdLCB1ID0gTHModCwgbiwgITAsIGkpLCBmID0gdVswXSwgZCA9IHVbMV07XG4gIHJldHVybiBzIDwgYyB8fCBvIDwgbCA/IChzID0gYywgbyA9IGwpIDogKHMgPiBmIHx8IG8gPiBkKSAmJiAocyA9IGYsIG8gPSBkKSwgW3MsIG9dO1xufVxuZnVuY3Rpb24gQ2ModCkge1xuICBmb3IgKHZhciBlID0gdC5sZW5ndGgsIG4gPSAwLCByID0gZSAtIDE7IHIgPj0gMDsgLS1yKVxuICAgIG4gKz0gdFtyXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB5cih0KSB7XG4gIGZvciAodmFyIGUgPSB0Lmxlbmd0aCwgbiA9IDAsIHIgPSBlIC0gMTsgciA+PSAwOyAtLXIpXG4gICAgbiArPSB0W3JdO1xuICByZXR1cm4gZSA/IG4gLyBlIDogMDtcbn1cbmZ1bmN0aW9uIHh0KHQsIGUpIHtcbiAgdmFyIG4gPSBlWzBdIC0gdFswXSwgciA9IGVbMV0gLSB0WzFdLCBzID0gTWF0aC5hdGFuMihyLCBuKTtcbiAgcmV0dXJuIHMgPj0gMCA/IHMgOiBzICsgTWF0aC5QSSAqIDI7XG59XG5mdW5jdGlvbiBEYyh0KSB7XG4gIHJldHVybiBbMCwgMV0ubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4geXIodC5tYXAoZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIG5bZV07XG4gICAgfSkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIE5zKHQpIHtcbiAgdmFyIGUgPSBEYyh0KSwgbiA9IHh0KGUsIHRbMF0pLCByID0geHQoZSwgdFsxXSk7XG4gIHJldHVybiBuIDwgciAmJiByIC0gbiA8IE1hdGguUEkgfHwgbiA+IHIgJiYgciAtIG4gPCAtTWF0aC5QSSA/IDEgOiAtMTtcbn1cbmZ1bmN0aW9uIHRlKHQsIGUpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdygoZSA/IGVbMF0gOiAwKSAtIHRbMF0sIDIpICsgTWF0aC5wb3coKGUgPyBlWzFdIDogMCkgLSB0WzFdLCAyKSk7XG59XG5mdW5jdGlvbiB0dCh0LCBlKSB7XG4gIGlmICghZSlcbiAgICByZXR1cm4gdDtcbiAgdmFyIG4gPSAxIC8gZTtcbiAgcmV0dXJuIE1hdGgucm91bmQodCAvIGUpIC8gbjtcbn1cbmZ1bmN0aW9uIFdzKHQsIGUpIHtcbiAgcmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbihuLCByKSB7XG4gICAgdFtyXSA9IHR0KHRbcl0sIGUpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIGJjKHQpIHtcbiAgZm9yICh2YXIgZSA9IFtdLCBuID0gMDsgbiA8IHQ7ICsrbilcbiAgICBlLnB1c2gobik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24geWModCkge1xuICByZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24oZSwgbikge1xuICAgIHJldHVybiBlLmNvbmNhdChuKTtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gVW8odCwgZSkge1xuICB0LmluZGV4T2YoZSkgPT09IC0xICYmIHQucHVzaChlKTtcbn1cbmZ1bmN0aW9uIGJ0KHQsIGUpIHtcbiAgcmV0dXJuIHQuY2xhc3NMaXN0ID8gdC5jbGFzc0xpc3QuY29udGFpbnMoZSkgOiAhIXQuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoXCIoXFxcXHN8XilcIiArIGUgKyBcIihcXFxcc3wkKVwiKSk7XG59XG5mdW5jdGlvbiBLbyh0LCBlKSB7XG4gIHQuY2xhc3NMaXN0ID8gdC5jbGFzc0xpc3QuYWRkKGUpIDogdC5jbGFzc05hbWUgKz0gXCIgXCIgKyBlO1xufVxuZnVuY3Rpb24gWm8odCwgZSkge1xuICBpZiAodC5jbGFzc0xpc3QpXG4gICAgdC5jbGFzc0xpc3QucmVtb3ZlKGUpO1xuICBlbHNlIHtcbiAgICB2YXIgbiA9IG5ldyBSZWdFeHAoXCIoXFxcXHN8XilcIiArIGUgKyBcIihcXFxcc3wkKVwiKTtcbiAgICB0LmNsYXNzTmFtZSA9IHQuY2xhc3NOYW1lLnJlcGxhY2UobiwgXCIgXCIpO1xuICB9XG59XG5mdW5jdGlvbiBQdCh0LCBlLCBuLCByKSB7XG4gIHQuYWRkRXZlbnRMaXN0ZW5lcihlLCBuLCByKTtcbn1cbmZ1bmN0aW9uIE10KHQsIGUsIG4sIHIpIHtcbiAgdC5yZW1vdmVFdmVudExpc3RlbmVyKGUsIG4sIHIpO1xufVxuZnVuY3Rpb24gdHModCkge1xuICByZXR1cm4gKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub3duZXJEb2N1bWVudCkgfHwgZ2M7XG59XG5mdW5jdGlvbiBlcyh0KSB7XG4gIHJldHVybiB0cyh0KS5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBmZSh0KSB7XG4gIHJldHVybiB0cyh0KS5ib2R5O1xufVxuZnVuY3Rpb24gYWUodCkge1xuICB2YXIgZTtcbiAgcmV0dXJuICgoZSA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuZnVuY3Rpb24gSm8odCkge1xuICByZXR1cm4gdCAmJiBcInBvc3RNZXNzYWdlXCIgaW4gdCAmJiBcImJsdXJcIiBpbiB0ICYmIFwic2VsZlwiIGluIHQ7XG59XG5mdW5jdGlvbiBucyh0KSB7XG4gIHJldHVybiBxdCh0KSAmJiB0Lm5vZGVOYW1lICYmIHQubm9kZVR5cGUgJiYgXCJvd25lckRvY3VtZW50XCIgaW4gdDtcbn1cbmZ1bmN0aW9uIFJjKHQsIGUsIG4sIHIsIHMsIG8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICB2YXIgYSA9IG4gKyBpICogcywgYyA9IHIgKyBpICogcztcbiAgICB0W2FdICs9IHRbY10gKiBvLCBlW2FdICs9IGVbY10gKiBvO1xuICB9XG59XG5mdW5jdGlvbiBNYyh0LCBlLCBuLCByLCBzKSB7XG4gIGZvciAodmFyIG8gPSAwOyBvIDwgczsgKytvKSB7XG4gICAgdmFyIGkgPSBuICsgbyAqIHMsIGEgPSByICsgbyAqIHMsIGMgPSB0W2ldLCBsID0gZVtpXTtcbiAgICB0W2ldID0gdFthXSwgdFthXSA9IGMsIGVbaV0gPSBlW2FdLCBlW2FdID0gbDtcbiAgfVxufVxuZnVuY3Rpb24gUGModCwgZSwgbiwgciwgcykge1xuICBmb3IgKHZhciBvID0gMDsgbyA8IHI7ICsrbykge1xuICAgIHZhciBpID0gbiArIG8gKiByO1xuICAgIHRbaV0gLz0gcywgZVtpXSAvPSBzO1xuICB9XG59XG5mdW5jdGlvbiBRbyh0LCBlLCBuKSB7XG4gIGZvciAodmFyIHIgPSB0LnNsaWNlKCksIHMgPSAwOyBzIDwgbjsgKytzKVxuICAgIHJbcyAqIG4gKyBlIC0gMV0gPSAwLCByWyhlIC0gMSkgKiBuICsgc10gPSAwO1xuICByZXR1cm4gclsoZSAtIDEpICogKG4gKyAxKV0gPSAxLCByO1xufVxuZnVuY3Rpb24gSnQodCwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSBNYXRoLnNxcnQodC5sZW5ndGgpKTtcbiAgZm9yICh2YXIgbiA9IHQuc2xpY2UoKSwgciA9IGd0KGUpLCBzID0gMDsgcyA8IGU7ICsrcykge1xuICAgIHZhciBvID0gZSAqIHMgKyBzO1xuICAgIGlmICghdHQobltvXSwgRHQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gcyArIDE7IGkgPCBlOyArK2kpXG4gICAgICAgIGlmIChuW2UgKiBzICsgaV0pIHtcbiAgICAgICAgICBNYyhuLCByLCBzLCBpLCBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR0KG5bb10sIER0KSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBQYyhuLCByLCBzLCBlLCBuW29dKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGU7ICsraSkge1xuICAgICAgdmFyIGEgPSBpLCBjID0gaSArIHMgKiBlLCBsID0gbltjXTtcbiAgICAgICF0dChsLCBEdCkgfHwgcyA9PT0gaSB8fCBSYyhuLCByLCBhLCBzLCBlLCAtbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gX2ModCwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSBNYXRoLnNxcnQodC5sZW5ndGgpKTtcbiAgZm9yICh2YXIgbiA9IFtdLCByID0gMDsgciA8IGU7ICsrcilcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IGU7ICsrcylcbiAgICAgIG5bcyAqIGUgKyByXSA9IHRbZSAqIHIgKyBzXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB0aSh0LCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IE1hdGguc3FydCh0Lmxlbmd0aCkpO1xuICBmb3IgKHZhciBuID0gW10sIHIgPSB0W2UgKiBlIC0gMV0sIHMgPSAwOyBzIDwgZSAtIDE7ICsrcylcbiAgICBuW3NdID0gdFtlICogKGUgLSAxKSArIHNdIC8gcjtcbiAgcmV0dXJuIG5bZSAtIDFdID0gMCwgbjtcbn1cbmZ1bmN0aW9uIFRjKHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IGd0KGUpLCByID0gMDsgciA8IGUgLSAxOyArK3IpXG4gICAgbltlICogKGUgLSAxKSArIHJdID0gdFtyXSB8fCAwO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIEVlKHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IHQuc2xpY2UoKSwgciA9IHQubGVuZ3RoOyByIDwgZSAtIDE7ICsrcilcbiAgICBuW3JdID0gMDtcbiAgcmV0dXJuIG5bZSAtIDFdID0gMSwgbjtcbn1cbmZ1bmN0aW9uIFV0KHQsIGUsIG4pIHtcbiAgaWYgKGUgPT09IHZvaWQgMCAmJiAoZSA9IE1hdGguc3FydCh0Lmxlbmd0aCkpLCBlID09PSBuKVxuICAgIHJldHVybiB0O1xuICBmb3IgKHZhciByID0gZ3QobiksIHMgPSBNYXRoLm1pbihlLCBuKSwgbyA9IDA7IG8gPCBzIC0gMTsgKytvKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzIC0gMTsgKytpKVxuICAgICAgcltvICogbiArIGldID0gdFtvICogZSArIGldO1xuICAgIHJbKG8gKyAxKSAqIG4gLSAxXSA9IHRbKG8gKyAxKSAqIGUgLSAxXSwgclsobiAtIDEpICogbiArIG9dID0gdFsoZSAtIDEpICogZSArIG9dO1xuICB9XG4gIHJldHVybiByW24gKiBuIC0gMV0gPSB0W2UgKiBlIC0gMV0sIHI7XG59XG5mdW5jdGlvbiBBbih0KSB7XG4gIGZvciAodmFyIGUgPSBbXSwgbiA9IDE7IG4gPCBhcmd1bWVudHMubGVuZ3RoOyBuKyspXG4gICAgZVtuIC0gMV0gPSBhcmd1bWVudHNbbl07XG4gIHZhciByID0gZ3QodCk7XG4gIHJldHVybiBlLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHIgPSBkdChyLCBzLCB0KTtcbiAgfSksIHI7XG59XG5mdW5jdGlvbiBkdCh0LCBlLCBuKSB7XG4gIG4gPT09IHZvaWQgMCAmJiAobiA9IE1hdGguc3FydCh0Lmxlbmd0aCkpO1xuICB2YXIgciA9IFtdLCBzID0gdC5sZW5ndGggLyBuLCBvID0gZS5sZW5ndGggLyBzO1xuICBpZiAocykge1xuICAgIGlmICghbylcbiAgICAgIHJldHVybiB0O1xuICB9IGVsc2UgcmV0dXJuIGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbzsgKythKSB7XG4gICAgICByW2EgKiBuICsgaV0gPSAwO1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzOyArK2MpXG4gICAgICAgIHJbYSAqIG4gKyBpXSArPSB0W2MgKiBuICsgaV0gKiBlW2EgKiBzICsgY107XG4gICAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGF0KHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IE1hdGgubWluKHQubGVuZ3RoLCBlLmxlbmd0aCksIHIgPSB0LnNsaWNlKCksIHMgPSAwOyBzIDwgbjsgKytzKVxuICAgIHJbc10gPSByW3NdICsgZVtzXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBLKHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IE1hdGgubWluKHQubGVuZ3RoLCBlLmxlbmd0aCksIHIgPSB0LnNsaWNlKCksIHMgPSAwOyBzIDwgbjsgKytzKVxuICAgIHJbc10gPSByW3NdIC0gZVtzXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBPYyh0LCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSB0Lmxlbmd0aCA9PT0gNiksIGUgPyBbdFswXSwgdFsxXSwgMCwgdFsyXSwgdFszXSwgMCwgdFs0XSwgdFs1XSwgMV0gOiB0O1xufVxuZnVuY3Rpb24gZWkodCwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gdC5sZW5ndGggPT09IDkpLCBlID8gW3RbMF0sIHRbMV0sIHRbM10sIHRbNF0sIHRbNl0sIHRbN11dIDogdDtcbn1cbmZ1bmN0aW9uIF90KHQsIGUsIG4pIHtcbiAgbiA9PT0gdm9pZCAwICYmIChuID0gZS5sZW5ndGgpO1xuICB2YXIgciA9IGR0KHQsIGUsIG4pLCBzID0gcltuIC0gMV07XG4gIHJldHVybiByLm1hcChmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIG8gLyBzO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHdjKHQsIGUpIHtcbiAgcmV0dXJuIGR0KHQsIFsxLCAwLCAwLCAwLCAwLCBNYXRoLmNvcyhlKSwgTWF0aC5zaW4oZSksIDAsIDAsIC1NYXRoLnNpbihlKSwgTWF0aC5jb3MoZSksIDAsIDAsIDAsIDAsIDFdLCA0KTtcbn1cbmZ1bmN0aW9uIEljKHQsIGUpIHtcbiAgcmV0dXJuIGR0KHQsIFtNYXRoLmNvcyhlKSwgMCwgLU1hdGguc2luKGUpLCAwLCAwLCAxLCAwLCAwLCBNYXRoLnNpbihlKSwgMCwgTWF0aC5jb3MoZSksIDAsIDAsIDAsIDAsIDFdLCA0KTtcbn1cbmZ1bmN0aW9uIEJjKHQsIGUpIHtcbiAgcmV0dXJuIGR0KHQsIGhuKGUsIDQpKTtcbn1cbmZ1bmN0aW9uIENuKHQsIGUpIHtcbiAgdmFyIG4gPSBlWzBdLCByID0gbiA9PT0gdm9pZCAwID8gMSA6IG4sIHMgPSBlWzFdLCBvID0gcyA9PT0gdm9pZCAwID8gMSA6IHMsIGkgPSBlWzJdLCBhID0gaSA9PT0gdm9pZCAwID8gMSA6IGk7XG4gIHJldHVybiBkdCh0LCBbciwgMCwgMCwgMCwgMCwgbywgMCwgMCwgMCwgMCwgYSwgMCwgMCwgMCwgMCwgMV0sIDQpO1xufVxuZnVuY3Rpb24gZ24odCwgZSkge1xuICByZXR1cm4gX3QoaG4oZSwgMyksIEVlKHQsIDMpKTtcbn1cbmZ1bmN0aW9uIGlyKHQsIGUpIHtcbiAgdmFyIG4gPSBlWzBdLCByID0gbiA9PT0gdm9pZCAwID8gMCA6IG4sIHMgPSBlWzFdLCBvID0gcyA9PT0gdm9pZCAwID8gMCA6IHMsIGkgPSBlWzJdLCBhID0gaSA9PT0gdm9pZCAwID8gMCA6IGk7XG4gIHJldHVybiBkdCh0LCBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgciwgbywgYSwgMV0sIDQpO1xufVxuZnVuY3Rpb24gWXModCwgZSkge1xuICByZXR1cm4gZHQodCwgZSwgNCk7XG59XG5mdW5jdGlvbiBobih0LCBlKSB7XG4gIHZhciBuID0gTWF0aC5jb3ModCksIHIgPSBNYXRoLnNpbih0KSwgcyA9IGd0KGUpO1xuICByZXR1cm4gc1swXSA9IG4sIHNbMV0gPSByLCBzW2VdID0gLXIsIHNbZSArIDFdID0gbiwgcztcbn1cbmZ1bmN0aW9uIGd0KHQpIHtcbiAgZm9yICh2YXIgZSA9IHQgKiB0LCBuID0gW10sIHIgPSAwOyByIDwgZTsgKytyKVxuICAgIG5bcl0gPSByICUgKHQgKyAxKSA/IDAgOiAxO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHJzKHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IGd0KGUpLCByID0gTWF0aC5taW4odC5sZW5ndGgsIGUgLSAxKSwgcyA9IDA7IHMgPCByOyArK3MpXG4gICAgblsoZSArIDEpICogc10gPSB0W3NdO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIENlKHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IGd0KGUpLCByID0gTWF0aC5taW4odC5sZW5ndGgsIGUgLSAxKSwgcyA9IDA7IHMgPCByOyArK3MpXG4gICAgbltlICogKGUgLSAxKSArIHNdID0gdFtzXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBzcyh0LCBlLCBuLCByLCBzLCBvLCBpLCBhKSB7XG4gIHZhciBjID0gdFswXSwgbCA9IHRbMV0sIHUgPSBlWzBdLCBmID0gZVsxXSwgZCA9IG5bMF0sIHAgPSBuWzFdLCBnID0gclswXSwgaCA9IHJbMV0sIHYgPSBzWzBdLCBtID0gc1sxXSwgUyA9IG9bMF0sIHggPSBvWzFdLCBDID0gaVswXSwgRSA9IGlbMV0sIEQgPSBhWzBdLCBSID0gYVsxXSwgeSA9IFtjLCAwLCB1LCAwLCBkLCAwLCBnLCAwLCBsLCAwLCBmLCAwLCBwLCAwLCBoLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAwLCBjLCAwLCB1LCAwLCBkLCAwLCBnLCAwLCBsLCAwLCBmLCAwLCBwLCAwLCBoLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAtdiAqIGMsIC1tICogYywgLVMgKiB1LCAteCAqIHUsIC1DICogZCwgLUUgKiBkLCAtRCAqIGcsIC1SICogZywgLXYgKiBsLCAtbSAqIGwsIC1TICogZiwgLXggKiBmLCAtQyAqIHAsIC1FICogcCwgLUQgKiBoLCAtUiAqIGhdLCBNID0gSnQoeSwgOCk7XG4gIGlmICghTS5sZW5ndGgpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgUCA9IGR0KE0sIFt2LCBtLCBTLCB4LCBDLCBFLCBELCBSXSwgOCk7XG4gIHJldHVybiBQWzhdID0gMSwgVXQoX2MoUCksIDMsIDQpO1xufVxudmFyIFFlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBRZSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIG4sIHIgPSAxLCBzID0gYXJndW1lbnRzLmxlbmd0aDsgciA8IHM7IHIrKykge1xuICAgICAgbiA9IGFyZ3VtZW50c1tyXTtcbiAgICAgIGZvciAodmFyIG8gaW4gbikgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIG8pICYmIChlW29dID0gbltvXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBRZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIHpjKCkge1xuICByZXR1cm4gW1xuICAgIDEsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMSxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDFcbiAgXTtcbn1cbmZ1bmN0aW9uIGxuKHQsIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApLCB3ZSgkZSh0LCBlKSk7XG59XG5mdW5jdGlvbiBBYyh0LCBlKSB7XG4gIHZhciBuID0gX3QodCwgW2VbMF0sIGVbMV0gfHwgMCwgZVsyXSB8fCAwLCAxXSwgNCksIHIgPSBuWzNdIHx8IDE7XG4gIHJldHVybiBbXG4gICAgblswXSAvIHIsXG4gICAgblsxXSAvIHIsXG4gICAgblsyXSAvIHJcbiAgXTtcbn1cbmZ1bmN0aW9uIHdlKHQpIHtcbiAgdmFyIGUgPSB6YygpO1xuICByZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgciA9IG4ubWF0cml4RnVuY3Rpb24sIHMgPSBuLmZ1bmN0aW9uVmFsdWU7XG4gICAgciAmJiAoZSA9IHIoZSwgcykpO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uICRlKHQsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gMCk7XG4gIHZhciBuID0gUnQodCkgPyB0IDogY2UodCk7XG4gIHJldHVybiBuLm1hcChmdW5jdGlvbihyKSB7XG4gICAgdmFyIHMgPSBYbyhyKSwgbyA9IHMucHJlZml4LCBpID0gcy52YWx1ZSwgYSA9IG51bGwsIGMgPSBvLCBsID0gXCJcIjtcbiAgICBpZiAobyA9PT0gXCJ0cmFuc2xhdGVcIiB8fCBvID09PSBcInRyYW5zbGF0ZVhcIiB8fCBvID09PSBcInRyYW5zbGF0ZTNkXCIpIHtcbiAgICAgIHZhciB1ID0gcXQoZSkgPyBRZShRZSh7fSwgZSksIHsgXCJvJVwiOiBlW1wiJVwiXSB9KSA6IHtcbiAgICAgICAgXCIlXCI6IGUsXG4gICAgICAgIFwibyVcIjogZVxuICAgICAgfSwgZiA9IHhlKGkpLm1hcChmdW5jdGlvbihULCB3KSB7XG4gICAgICAgIHJldHVybiB3ID09PSAwICYmIFwieCVcIiBpbiB1ID8gdVtcIiVcIl0gPSBlW1wieCVcIl0gOiB3ID09PSAxICYmIFwieSVcIiBpbiB1ID8gdVtcIiVcIl0gPSBlW1wieSVcIl0gOiB1W1wiJVwiXSA9IGVbXCJvJVwiXSwgZnQoVCwgdSk7XG4gICAgICB9KSwgZCA9IGZbMF0sIHAgPSBmWzFdLCBnID0gcCA9PT0gdm9pZCAwID8gMCA6IHAsIGggPSBmWzJdLCB2ID0gaCA9PT0gdm9pZCAwID8gMCA6IGg7XG4gICAgICBhID0gaXIsIGwgPSBbZCwgZywgdl07XG4gICAgfSBlbHNlIGlmIChvID09PSBcInRyYW5zbGF0ZVlcIikge1xuICAgICAgdmFyIG0gPSBxdChlKSA/IFFlKHsgXCIlXCI6IGVbXCJ5JVwiXSB9LCBlKSA6IHtcbiAgICAgICAgXCIlXCI6IGVcbiAgICAgIH0sIGcgPSBmdChpLCBtKTtcbiAgICAgIGEgPSBpciwgbCA9IFswLCBnLCAwXTtcbiAgICB9IGVsc2UgaWYgKG8gPT09IFwidHJhbnNsYXRlWlwiKSB7XG4gICAgICB2YXIgdiA9IHBhcnNlRmxvYXQoaSk7XG4gICAgICBhID0gaXIsIGwgPSBbMCwgMCwgdl07XG4gICAgfSBlbHNlIGlmIChvID09PSBcInNjYWxlXCIgfHwgbyA9PT0gXCJzY2FsZTNkXCIpIHtcbiAgICAgIHZhciBTID0geGUoaSkubWFwKGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoVCk7XG4gICAgICB9KSwgeCA9IFNbMF0sIEMgPSBTWzFdLCBFID0gQyA9PT0gdm9pZCAwID8geCA6IEMsIEQgPSBTWzJdLCBSID0gRCA9PT0gdm9pZCAwID8gMSA6IEQ7XG4gICAgICBhID0gQ24sIGwgPSBbeCwgRSwgUl07XG4gICAgfSBlbHNlIGlmIChvID09PSBcInNjYWxlWFwiKSB7XG4gICAgICB2YXIgeCA9IHBhcnNlRmxvYXQoaSk7XG4gICAgICBhID0gQ24sIGwgPSBbeCwgMSwgMV07XG4gICAgfSBlbHNlIGlmIChvID09PSBcInNjYWxlWVwiKSB7XG4gICAgICB2YXIgRSA9IHBhcnNlRmxvYXQoaSk7XG4gICAgICBhID0gQ24sIGwgPSBbMSwgRSwgMV07XG4gICAgfSBlbHNlIGlmIChvID09PSBcInNjYWxlWlwiKSB7XG4gICAgICB2YXIgUiA9IHBhcnNlRmxvYXQoaSk7XG4gICAgICBhID0gQ24sIGwgPSBbMSwgMSwgUl07XG4gICAgfSBlbHNlIGlmIChvID09PSBcInJvdGF0ZVwiIHx8IG8gPT09IFwicm90YXRlWlwiIHx8IG8gPT09IFwicm90YXRlWFwiIHx8IG8gPT09IFwicm90YXRlWVwiKSB7XG4gICAgICB2YXIgeSA9IHBuKGkpLCBNID0geS51bml0LCBQID0geS52YWx1ZSwgXyA9IE0gPT09IFwicmFkXCIgPyBQIDogUCAqIE1hdGguUEkgLyAxODA7XG4gICAgICBvID09PSBcInJvdGF0ZVwiIHx8IG8gPT09IFwicm90YXRlWlwiID8gKGMgPSBcInJvdGF0ZVpcIiwgYSA9IEJjKSA6IG8gPT09IFwicm90YXRlWFwiID8gYSA9IHdjIDogbyA9PT0gXCJyb3RhdGVZXCIgJiYgKGEgPSBJYyksIGwgPSBfO1xuICAgIH0gZWxzZSBpZiAobyA9PT0gXCJtYXRyaXgzZFwiKVxuICAgICAgYSA9IFlzLCBsID0geGUoaSkubWFwKGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoVCk7XG4gICAgICB9KTtcbiAgICBlbHNlIGlmIChvID09PSBcIm1hdHJpeFwiKSB7XG4gICAgICB2YXIgTyA9IHhlKGkpLm1hcChmdW5jdGlvbihUKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KFQpO1xuICAgICAgfSk7XG4gICAgICBhID0gWXMsIGwgPSBbXG4gICAgICAgIE9bMF0sXG4gICAgICAgIE9bMV0sXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIE9bMl0sXG4gICAgICAgIE9bM10sXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIE9bNF0sXG4gICAgICAgIE9bNV0sXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgfSBlbHNlXG4gICAgICBjID0gXCJcIjtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbyxcbiAgICAgIGZ1bmN0aW9uTmFtZTogYyxcbiAgICAgIHZhbHVlOiBpLFxuICAgICAgbWF0cml4RnVuY3Rpb246IGEsXG4gICAgICBmdW5jdGlvblZhbHVlOiBsXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiB2bih0LCBlLCBuLCByLCBzLCBvID0gXCJkcmFnZ2FibGVcIikge1xuICB2YXIgbDtcbiAgY29uc3QgaSA9ICgobCA9IGUuZ2VzdG9zW29dKSA9PSBudWxsID8gdm9pZCAwIDogbC5tb3ZlKG4sIHQuaW5wdXRFdmVudCkpID8/IHt9LCBhID0gaS5vcmlnaW5hbERhdGFzIHx8IGkuZGF0YXMsIGMgPSBhW29dIHx8IChhW29dID0ge30pO1xuICByZXR1cm4ge1xuICAgIC4uLmksXG4gICAgaXNQaW5jaDogISFyLFxuICAgIHBhcmVudEV2ZW50OiAhMCxcbiAgICBkYXRhczogYyxcbiAgICBvcmlnaW5hbERhdGFzOiB0Lm9yaWdpbmFsRGF0YXNcbiAgfTtcbn1cbmNsYXNzIEZlIHtcbiAgY29uc3RydWN0b3IoZSA9IFwiZHJhZ2dhYmxlXCIpIHtcbiAgICBYKHRoaXMsIFwicHJldlhcIiwgMCk7XG4gICAgWCh0aGlzLCBcInByZXZZXCIsIDApO1xuICAgIFgodGhpcywgXCJzdGFydFhcIiwgMCk7XG4gICAgWCh0aGlzLCBcInN0YXJ0WVwiLCAwKTtcbiAgICBYKHRoaXMsIFwiaXNEcmFnXCIsICExKTtcbiAgICBYKHRoaXMsIFwiaXNGbGFnXCIsICExKTtcbiAgICBYKHRoaXMsIFwiZGF0YXNcIiwge1xuICAgICAgZHJhZ2dhYmxlOiB7fVxuICAgIH0pO1xuICAgIHRoaXMuYWJsZU5hbWUgPSBlLCB0aGlzLmRhdGFzID0ge1xuICAgICAgW2VdOiB7fVxuICAgIH07XG4gIH1cbiAgZHJhZ1N0YXJ0KGUsIG4pIHtcbiAgICB0aGlzLmlzRHJhZyA9ICExLCB0aGlzLmlzRmxhZyA9ICExO1xuICAgIGNvbnN0IHIgPSBuLm9yaWdpbmFsRGF0YXM7XG4gICAgcmV0dXJuIHRoaXMuZGF0YXMgPSByLCByW3RoaXMuYWJsZU5hbWVdIHx8IChyW3RoaXMuYWJsZU5hbWVdID0ge30pLCB7XG4gICAgICAuLi50aGlzLm1vdmUoZSwgbi5pbnB1dEV2ZW50KSxcbiAgICAgIHR5cGU6IFwiZHJhZ3N0YXJ0XCJcbiAgICB9O1xuICB9XG4gIGRyYWcoZSwgbikge1xuICAgIHJldHVybiB0aGlzLm1vdmUoW1xuICAgICAgZVswXSAtIHRoaXMucHJldlgsXG4gICAgICBlWzFdIC0gdGhpcy5wcmV2WVxuICAgIF0sIG4pO1xuICB9XG4gIG1vdmUoZSwgbikge1xuICAgIGxldCByLCBzLCBvID0gITE7XG4gICAgaWYgKCF0aGlzLmlzRmxhZylcbiAgICAgIHRoaXMucHJldlggPSBlWzBdLCB0aGlzLnByZXZZID0gZVsxXSwgdGhpcy5zdGFydFggPSBlWzBdLCB0aGlzLnN0YXJ0WSA9IGVbMV0sIHIgPSBlWzBdLCBzID0gZVsxXSwgdGhpcy5pc0ZsYWcgPSAhMDtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmlzRHJhZztcbiAgICAgIHIgPSB0aGlzLnByZXZYICsgZVswXSwgcyA9IHRoaXMucHJldlkgKyBlWzFdLCAoZVswXSB8fCBlWzFdKSAmJiAodGhpcy5pc0RyYWcgPSAhMCksICFpICYmIHRoaXMuaXNEcmFnICYmIChvID0gITApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmV2WCA9IHIsIHRoaXMucHJldlkgPSBzLCB7XG4gICAgICB0eXBlOiBcImRyYWdcIixcbiAgICAgIGNsaWVudFg6IHIsXG4gICAgICBjbGllbnRZOiBzLFxuICAgICAgaW5wdXRFdmVudDogbixcbiAgICAgIGlzRmlyc3REcmFnOiBvLFxuICAgICAgaXNEcmFnOiB0aGlzLmlzRHJhZyxcbiAgICAgIGRpc3RYOiByIC0gdGhpcy5zdGFydFgsXG4gICAgICBkaXN0WTogcyAtIHRoaXMuc3RhcnRZLFxuICAgICAgZGVsdGFYOiBlWzBdLFxuICAgICAgZGVsdGFZOiBlWzFdLFxuICAgICAgZGF0YXM6IHRoaXMuZGF0YXNbdGhpcy5hYmxlTmFtZV0sXG4gICAgICBvcmlnaW5hbERhdGFzOiB0aGlzLmRhdGFzLFxuICAgICAgcGFyZW50RXZlbnQ6ICEwLFxuICAgICAgcGFyZW50R2VzdG86IHRoaXNcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBrZSh0LCBlLCBuLCByKSB7XG4gIGNvbnN0IG8gPSB0Lmxlbmd0aCA9PT0gMTYgPyA0IDogMywgaSA9IE1lKHQsIG4sIHIsIG8pO1xuICBsZXQgW1thLCBjXSwgW2wsIHVdLCBbZiwgZF0sIFtwLCBnXV0gPSBpLCBbaCwgdl0gPSBodCh0LCBlLCBvKTtcbiAgY29uc3QgbSA9IE1hdGgubWluKGEsIGwsIGYsIHApLCBTID0gTWF0aC5taW4oYywgdSwgZCwgZyksIHggPSBNYXRoLm1heChhLCBsLCBmLCBwKSwgQyA9IE1hdGgubWF4KGMsIHUsIGQsIGcpO1xuICBhID0gYSAtIG0gfHwgMCwgbCA9IGwgLSBtIHx8IDAsIGYgPSBmIC0gbSB8fCAwLCBwID0gcCAtIG0gfHwgMCwgYyA9IGMgLSBTIHx8IDAsIHUgPSB1IC0gUyB8fCAwLCBkID0gZCAtIFMgfHwgMCwgZyA9IGcgLSBTIHx8IDAsIGggPSBoIC0gbSB8fCAwLCB2ID0gdiAtIFMgfHwgMDtcbiAgY29uc3QgRSA9IHRbMF0sIEQgPSB0W28gKyAxXSwgUiA9IHd0KEUgKiBEKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBtLFxuICAgIHRvcDogUyxcbiAgICByaWdodDogeCxcbiAgICBib3R0b206IEMsXG4gICAgb3JpZ2luOiBbaCwgdl0sXG4gICAgcG9zMTogW2EsIGNdLFxuICAgIHBvczI6IFtsLCB1XSxcbiAgICBwb3MzOiBbZiwgZF0sXG4gICAgcG9zNDogW3AsIGddLFxuICAgIGRpcmVjdGlvbjogUlxuICB9O1xufVxuZnVuY3Rpb24gbmkodCwgZSkge1xuICBjb25zdCB7IGNsaWVudFg6IG4sIGNsaWVudFk6IHIsIGRhdGFzOiBzIH0gPSBlLCB7XG4gICAgbW92ZWFibGVDbGllbnRSZWN0OiBvLFxuICAgIHJvb3RNYXRyaXg6IGksXG4gICAgaXMzZDogYSxcbiAgICBwb3MxOiBjXG4gIH0gPSB0LnN0YXRlLCB7IGxlZnQ6IGwsIHRvcDogdSB9ID0gbywgZiA9IGEgPyA0IDogMywgW2QsIHBdID0gSyhXZShpLCBbbiAtIGwsIHIgLSB1XSwgZiksIGMpLCBbZywgaF0gPSBRdCh7IGRhdGFzOiBzLCBkaXN0WDogZCwgZGlzdFk6IHAgfSk7XG4gIHJldHVybiBbZywgaF07XG59XG5mdW5jdGlvbiBSZSh0LCB7IGRhdGFzOiBlIH0pIHtcbiAgY29uc3Qge1xuICAgIGFsbE1hdHJpeDogbixcbiAgICBiZWZvcmVNYXRyaXg6IHIsXG4gICAgaXMzZDogcyxcbiAgICBsZWZ0OiBvLFxuICAgIHRvcDogaSxcbiAgICBvcmlnaW46IGEsXG4gICAgb2Zmc2V0TWF0cml4OiBjLFxuICAgIHRhcmdldE1hdHJpeDogbCxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IHVcbiAgfSA9IHQuc3RhdGUsIGYgPSBzID8gNCA6IDM7XG4gIGUuaXMzZCA9IHMsIGUubWF0cml4ID0gbiwgZS50YXJnZXRNYXRyaXggPSBsLCBlLmJlZm9yZU1hdHJpeCA9IHIsIGUub2Zmc2V0TWF0cml4ID0gYywgZS50cmFuc2Zvcm1PcmlnaW4gPSB1LCBlLmludmVyc2VNYXRyaXggPSBKdChuLCBmKSwgZS5pbnZlcnNlQmVmb3JlTWF0cml4ID0gSnQociwgZiksIGUuYWJzb2x1dGVPcmlnaW4gPSBFZShhdChbbywgaV0sIGEpLCBmKSwgZS5zdGFydERyYWdCZWZvcmVEaXN0ID0gX3QoZS5pbnZlcnNlQmVmb3JlTWF0cml4LCBlLmFic29sdXRlT3JpZ2luLCBmKSwgZS5zdGFydERyYWdEaXN0ID0gX3QoZS5pbnZlcnNlTWF0cml4LCBlLmFic29sdXRlT3JpZ2luLCBmKTtcbn1cbmZ1bmN0aW9uIEdjKHQpIHtcbiAgcmV0dXJuIGtlKHQuZGF0YXMuYmVmb3JlVHJhbnNmb3JtLCBbNTAsIDUwXSwgMTAwLCAxMDApLmRpcmVjdGlvbjtcbn1cbmZ1bmN0aW9uIGpuKHQsIGUsIG4pIHtcbiAgY29uc3Qge1xuICAgIGRhdGFzOiByLFxuICAgIG9yaWdpbmFsRGF0YXM6IHtcbiAgICAgIGJlZm9yZVJlbmRlcmFibGU6IHNcbiAgICB9XG4gIH0gPSBlLCBvID0gci50cmFuc2Zvcm1JbmRleCwgaSA9IHMubmV4dFRyYW5zZm9ybXMsIGEgPSBpLmxlbmd0aCwgYyA9IHMubmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcztcbiAgbGV0IGwgPSAtMTtcbiAgbyA9PT0gLTEgPyAobiA9PT0gXCJ0cmFuc2xhdGVcIiA/IGwgPSAwIDogbiA9PT0gXCJyb3RhdGVcIiAmJiAobCA9IG5lKGksIChwKSA9PiBwLm1hdGNoKC9zY2FsZVxcKC9nKSkpLCBsID09PSAtMSAmJiAobCA9IGkubGVuZ3RoKSwgci50cmFuc2Zvcm1JbmRleCA9IGwpIDoga3QoYywgKHApID0+IHAuaW5kZXggPT09IG8gJiYgcC5mdW5jdGlvbk5hbWUgPT09IG4pID8gbCA9IG8gOiBsID0gbyArIGMuZmlsdGVyKChwKSA9PiBwLmluZGV4IDwgbykubGVuZ3RoO1xuICBjb25zdCB1ID0gU3UoaSwgdC5zdGF0ZSwgbCksIGYgPSB1LnRhcmdldEZ1bmN0aW9uLCBkID0gbiA9PT0gXCJyb3RhdGVcIiA/IFwicm90YXRlWlwiIDogbjtcbiAgci5iZWZvcmVGdW5jdGlvblRleHRzID0gdS5iZWZvcmVGdW5jdGlvblRleHRzLCByLmFmdGVyRnVuY3Rpb25UZXh0cyA9IHUuYWZ0ZXJGdW5jdGlvblRleHRzLCByLmJlZm9yZVRyYW5zZm9ybSA9IHUuYmVmb3JlRnVuY3Rpb25NYXRyaXgsIHIuYmVmb3JlVHJhbnNmb3JtMiA9IHUuYmVmb3JlRnVuY3Rpb25NYXRyaXgyLCByLnRhcmdldFRhbnNmb3JtID0gdS50YXJnZXRGdW5jdGlvbk1hdHJpeCwgci5hZnRlclRyYW5zZm9ybSA9IHUuYWZ0ZXJGdW5jdGlvbk1hdHJpeCwgci5hZnRlclRyYW5zZm9ybTIgPSB1LmFmdGVyRnVuY3Rpb25NYXRyaXgyLCByLnRhcmdldEFsbFRyYW5zZm9ybSA9IHUuYWxsRnVuY3Rpb25NYXRyaXgsIGYuZnVuY3Rpb25OYW1lID09PSBkID8gKHIuYWZ0ZXJGdW5jdGlvblRleHRzLnNwbGljZSgwLCAxKSwgci5pc0FwcGVuZFRyYW5zZm9ybSA9ICExKSA6IGEgPiBsICYmIChyLmlzQXBwZW5kVHJhbnNmb3JtID0gITAsIHMubmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcyA9IFsuLi5jLCB7XG4gICAgZnVuY3Rpb25OYW1lOiBuLFxuICAgIGluZGV4OiBsLFxuICAgIGlzQXBwZW5kOiAhMFxuICB9XSk7XG59XG5mdW5jdGlvbiBYbih0LCBlLCBuKSB7XG4gIHJldHVybiBgJHt0LmJlZm9yZUZ1bmN0aW9uVGV4dHMuam9pbihcIiBcIil9ICR7dC5pc0FwcGVuZFRyYW5zZm9ybSA/IG4gOiBlfSAke3QuYWZ0ZXJGdW5jdGlvblRleHRzLmpvaW4oXCIgXCIpfWA7XG59XG5mdW5jdGlvbiBrYyh7IGRhdGFzOiB0LCBkaXN0WDogZSwgZGlzdFk6IG4gfSkge1xuICBjb25zdCBbciwgc10gPSBzaSh7IGRhdGFzOiB0LCBkaXN0WDogZSwgZGlzdFk6IG4gfSksIG8gPSByaSh0LCBUYyhbciwgc10sIDQpKTtcbiAgcmV0dXJuIF90KG8sIEVlKFswLCAwLCAwXSwgNCksIDQpO1xufVxuZnVuY3Rpb24gcmkodCwgZSwgbikge1xuICBjb25zdCB7XG4gICAgYmVmb3JlVHJhbnNmb3JtOiByLFxuICAgIGFmdGVyVHJhbnNmb3JtOiBzLFxuICAgIGJlZm9yZVRyYW5zZm9ybTI6IG8sXG4gICAgYWZ0ZXJUcmFuc2Zvcm0yOiBpLFxuICAgIHRhcmdldEFsbFRyYW5zZm9ybTogYVxuICB9ID0gdCwgYyA9IG4gPyBkdChhLCBlLCA0KSA6IGR0KGUsIGEsIDQpLCBsID0gZHQoSnQobiA/IG8gOiByLCA0KSwgYywgNCk7XG4gIHJldHVybiBkdChsLCBKdChuID8gaSA6IHMsIDQpLCA0KTtcbn1cbmZ1bmN0aW9uIHNpKHsgZGF0YXM6IHQsIGRpc3RYOiBlLCBkaXN0WTogbiB9KSB7XG4gIGNvbnN0IHtcbiAgICBpbnZlcnNlQmVmb3JlTWF0cml4OiByLFxuICAgIGlzM2Q6IHMsXG4gICAgc3RhcnREcmFnQmVmb3JlRGlzdDogbyxcbiAgICBhYnNvbHV0ZU9yaWdpbjogaVxuICB9ID0gdCwgYSA9IHMgPyA0IDogMztcbiAgcmV0dXJuIEsoXG4gICAgX3QoXG4gICAgICByLFxuICAgICAgYXQoaSwgW2UsIG5dKSxcbiAgICAgIGFcbiAgICApLFxuICAgIG9cbiAgKTtcbn1cbmZ1bmN0aW9uIFF0KHsgZGF0YXM6IHQsIGRpc3RYOiBlLCBkaXN0WTogbiB9LCByKSB7XG4gIGNvbnN0IHtcbiAgICBpbnZlcnNlQmVmb3JlTWF0cml4OiBzLFxuICAgIGludmVyc2VNYXRyaXg6IG8sXG4gICAgaXMzZDogaSxcbiAgICBzdGFydERyYWdCZWZvcmVEaXN0OiBhLFxuICAgIHN0YXJ0RHJhZ0Rpc3Q6IGMsXG4gICAgYWJzb2x1dGVPcmlnaW46IGxcbiAgfSA9IHQsIHUgPSBpID8gNCA6IDM7XG4gIHJldHVybiBLKFxuICAgIF90KFxuICAgICAgciA/IHMgOiBvLFxuICAgICAgYXQobCwgW2UsIG5dKSxcbiAgICAgIHVcbiAgICApLFxuICAgIHIgPyBhIDogY1xuICApO1xufVxuZnVuY3Rpb24gJGMoeyBkYXRhczogdCwgZGlzdFg6IGUsIGRpc3RZOiBuIH0sIHIpIHtcbiAgY29uc3Qge1xuICAgIGJlZm9yZU1hdHJpeDogcyxcbiAgICBtYXRyaXg6IG8sXG4gICAgaXMzZDogaSxcbiAgICBzdGFydERyYWdCZWZvcmVEaXN0OiBhLFxuICAgIHN0YXJ0RHJhZ0Rpc3Q6IGMsXG4gICAgYWJzb2x1dGVPcmlnaW46IGxcbiAgfSA9IHQsIHUgPSBpID8gNCA6IDM7XG4gIHJldHVybiBLKFxuICAgIF90KFxuICAgICAgbyxcbiAgICAgIGF0KGMsIFtlLCBuXSksXG4gICAgICB1XG4gICAgKSxcbiAgICBsXG4gICk7XG59XG5mdW5jdGlvbiBGYyh0LCBlLCBuLCByID0gZSwgcyA9IG4sIG8gPSBbMCwgMF0pIHtcbiAgcmV0dXJuIHQgPyB0Lm1hcCgoaSwgYSkgPT4ge1xuICAgIGNvbnN0IHsgdmFsdWU6IGMsIHVuaXQ6IGwgfSA9IHBuKGkpLCB1ID0gYSA/IHMgOiByLCBmID0gYSA/IG4gOiBlO1xuICAgIGlmIChpID09PSBcIiVcIiB8fCBpc05hTihjKSkge1xuICAgICAgY29uc3QgZCA9IHUgPyBvW2FdIC8gdSA6IDA7XG4gICAgICByZXR1cm4gZiAqIGQ7XG4gICAgfSBlbHNlIGlmIChsICE9PSBcIiVcIilcbiAgICAgIHJldHVybiBjO1xuICAgIHJldHVybiBmICogYyAvIDEwMDtcbiAgfSkgOiBvO1xufVxuZnVuY3Rpb24gb2kodCkge1xuICBjb25zdCBlID0gW107XG4gIHJldHVybiB0WzFdID49IDAgJiYgKHRbMF0gPj0gMCAmJiBlLnB1c2goMyksIHRbMF0gPD0gMCAmJiBlLnB1c2goMikpLCB0WzFdIDw9IDAgJiYgKHRbMF0gPj0gMCAmJiBlLnB1c2goMSksIHRbMF0gPD0gMCAmJiBlLnB1c2goMCkpLCBlO1xufVxuZnVuY3Rpb24gTGModCwgZSkge1xuICByZXR1cm4gb2koZSkubWFwKChuKSA9PiB0W25dKTtcbn1cbmZ1bmN0aW9uIGFyKHQsIGUpIHtcbiAgY29uc3QgbiA9IChlICsgMSkgLyAyO1xuICByZXR1cm4gW1xuICAgIHpuKHRbMF1bMF0sIHRbMV1bMF0sIG4sIDEgLSBuKSxcbiAgICB6bih0WzBdWzFdLCB0WzFdWzFdLCBuLCAxIC0gbilcbiAgXTtcbn1cbmZ1bmN0aW9uIHl0KHQsIGUpIHtcbiAgY29uc3QgbiA9IGFyKFt0WzBdLCB0WzFdXSwgZVswXSksIHIgPSBhcihbdFsyXSwgdFszXV0sIGVbMF0pO1xuICByZXR1cm4gYXIoW24sIHJdLCBlWzFdKTtcbn1cbmZ1bmN0aW9uIE5jKHQsIGUsIG4sIHIsIHMsIG8pIHtcbiAgY29uc3QgaSA9IE1lKGUsIG4sIHIsIHMpLCBhID0geXQoaSwgbyksIGMgPSB0WzBdIC0gYVswXSwgbCA9IHRbMV0gLSBhWzFdO1xuICByZXR1cm4gW2MsIGxdO1xufVxuZnVuY3Rpb24gbW4odCwgZSwgbiwgcikge1xuICByZXR1cm4gZHQoXG4gICAgdCxcbiAgICBlbihlLCByLCBuKSxcbiAgICByXG4gICk7XG59XG5mdW5jdGlvbiBXYyh0LCBlLCBuLCByKSB7XG4gIGNvbnN0IHtcbiAgICB0cmFuc2Zvcm1PcmlnaW46IHMsXG4gICAgb2Zmc2V0TWF0cml4OiBvLFxuICAgIGlzM2Q6IGlcbiAgfSA9IHQsIGEgPSBpID8gNCA6IDM7XG4gIGxldCBjO1xuICBpZiAocmUobikpIHtcbiAgICBjb25zdCB7XG4gICAgICBiZWZvcmVUcmFuc2Zvcm06IGwsXG4gICAgICBhZnRlclRyYW5zZm9ybTogdVxuICAgIH0gPSBlO1xuICAgIHIgPyBjID0gVXQobG4obiksIDQsIGEpIDogYyA9IFV0KFxuICAgICAgZHQoZHQobCwgbG4oW25dKSwgNCksIHUsIDQpLFxuICAgICAgNCxcbiAgICAgIGFcbiAgICApO1xuICB9IGVsc2VcbiAgICBjID0gbjtcbiAgcmV0dXJuIG1uKFxuICAgIG8sXG4gICAgYyxcbiAgICBzLFxuICAgIGFcbiAgKTtcbn1cbmZ1bmN0aW9uIFljKHQsIGUpIHtcbiAgY29uc3Qge1xuICAgIHRyYW5zZm9ybU9yaWdpbjogbixcbiAgICBvZmZzZXRNYXRyaXg6IHIsXG4gICAgaXMzZDogcyxcbiAgICB0YXJnZXRNYXRyaXg6IG8sXG4gICAgdGFyZ2V0QWxsVHJhbnNmb3JtOiBpXG4gIH0gPSB0LCBhID0gcyA/IDQgOiAzO1xuICByZXR1cm4gbW4oXG4gICAgcixcbiAgICBkdChpIHx8IG8sIHJzKGUsIGEpLCBhKSxcbiAgICBuLFxuICAgIGFcbiAgKTtcbn1cbmZ1bmN0aW9uIEhuKHQsIGUpIHtcbiAgY29uc3QgbiA9IGplKGUpO1xuICByZXR1cm4ge1xuICAgIHNldFRyYW5zZm9ybTogKHIsIHMgPSAtMSkgPT4ge1xuICAgICAgbi5zdGFydFRyYW5zZm9ybXMgPSBSdChyKSA/IHIgOiBjZShyKSwgUnIodCwgZSwgcyk7XG4gICAgfSxcbiAgICBzZXRUcmFuc2Zvcm1JbmRleDogKHIpID0+IHtcbiAgICAgIFJyKHQsIGUsIHIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHFuKHQsIGUsIG4pIHtcbiAgY29uc3QgcyA9IGplKGUpLnN0YXJ0VHJhbnNmb3JtcztcbiAgUnIodCwgZSwgbmUocywgKG8pID0+IG8uaW5kZXhPZihgJHtufShgKSA9PT0gMCkpO1xufVxuZnVuY3Rpb24gUnIodCwgZSwgbikge1xuICBjb25zdCByID0gamUoZSksIHMgPSBlLmRhdGFzO1xuICBpZiAocy50cmFuc2Zvcm1JbmRleCA9IG4sIG4gPT09IC0xKVxuICAgIHJldHVybjtcbiAgY29uc3QgbyA9IHIuc3RhcnRUcmFuc2Zvcm1zW25dO1xuICBpZiAoIW8pXG4gICAgcmV0dXJuO1xuICBjb25zdCBpID0gdC5zdGF0ZSwgYSA9ICRlKFtvXSwge1xuICAgIFwieCVcIjogKGMpID0+IGMgLyAxMDAgKiBpLm9mZnNldFdpZHRoLFxuICAgIFwieSVcIjogKGMpID0+IGMgLyAxMDAgKiBpLm9mZnNldEhlaWdodFxuICB9KTtcbiAgcy5zdGFydFZhbHVlID0gYVswXS5mdW5jdGlvblZhbHVlO1xufVxuZnVuY3Rpb24gb3ModCwgZSkge1xuICBjb25zdCBuID0gamUodCk7XG4gIG4ubmV4dFRyYW5zZm9ybXMgPSBjZShlKTtcbn1cbmZ1bmN0aW9uIGplKHQpIHtcbiAgcmV0dXJuIHQub3JpZ2luYWxEYXRhcy5iZWZvcmVSZW5kZXJhYmxlO1xufVxuZnVuY3Rpb24gR24odCkge1xuICBjb25zdCB7XG4gICAgb3JpZ2luYWxEYXRhczoge1xuICAgICAgYmVmb3JlUmVuZGVyYWJsZTogZVxuICAgIH1cbiAgfSA9IHQ7XG4gIHJldHVybiBlLm5leHRUcmFuc2Zvcm1zO1xufVxuZnVuY3Rpb24gRG4odCkge1xuICByZXR1cm4gKEduKHQpIHx8IFtdKS5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIGJuKHQpIHtcbiAgcmV0dXJuIGplKHQpLm5leHRTdHlsZTtcbn1cbmZ1bmN0aW9uIGlpKHQsIGUsIG4sIHIsIHMpIHtcbiAgb3MocywgZSk7XG4gIGNvbnN0IG8gPSBPdC5kcmFnKFxuICAgIHQsXG4gICAgdm4ocywgdC5zdGF0ZSwgbiwgcilcbiAgKSwgaSA9IG8gPyBvLnRyYW5zZm9ybSA6IGU7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBlLFxuICAgIGRyYWc6IG8sXG4gICAgLi4uSXQoe1xuICAgICAgdHJhbnNmb3JtOiBpXG4gICAgfSwgcyksXG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzKHQsIGUsIG4sIHIsIHMsIG8pIHtcbiAgY29uc3QgaSA9IFdjKHQuc3RhdGUsIHMsIGUsIG8pO1xuICByZXR1cm4gWGMoXG4gICAgdCxcbiAgICBuLFxuICAgIHIsXG4gICAgaVxuICApO1xufVxuZnVuY3Rpb24gYWkodCwgZSwgbiwgciwgcywgbywgaSkge1xuICBjb25zdCBhID0gaXMoXG4gICAgdCxcbiAgICBlLFxuICAgIG4sXG4gICAgcyxcbiAgICBvLFxuICAgIGlcbiAgKSwgYyA9IHQuc3RhdGUsIHtcbiAgICBsZWZ0OiBsLFxuICAgIHRvcDogdVxuICB9ID0gYywgZiA9IHQucHJvcHMuZ3JvdXBhYmxlLCBkID0gZiA/IGwgOiAwLCBwID0gZiA/IHUgOiAwLCBnID0gSyhyLCBhKTtcbiAgcmV0dXJuIEsoZywgW2QsIHBdKTtcbn1cbmZ1bmN0aW9uIFZjKHQsIGUsIG4sIHIsIHMsIG8sIGkpIHtcbiAgcmV0dXJuIGFpKFxuICAgIHQsXG4gICAgZSxcbiAgICBuLFxuICAgIHIsXG4gICAgcyxcbiAgICBvLFxuICAgIGlcbiAgKTtcbn1cbmZ1bmN0aW9uIGpjKHQsIGUsIG4pIHtcbiAgcmV0dXJuIFtcbiAgICBlID8gLTEgKyB0WzBdIC8gKGUgLyAyKSA6IDAsXG4gICAgbiA/IC0xICsgdFsxXSAvIChuIC8gMikgOiAwXG4gIF07XG59XG5mdW5jdGlvbiBYYyh0LCBlLCBuLCByID0gdC5zdGF0ZS5hbGxNYXRyaXgpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoOiBzLFxuICAgIGhlaWdodDogbyxcbiAgICBpczNkOiBpXG4gIH0gPSB0LnN0YXRlLCBhID0gaSA/IDQgOiAzLCBjID0gW1xuICAgIHMgLyAyICogKDEgKyBlWzBdKSArIG5bMF0sXG4gICAgbyAvIDIgKiAoMSArIGVbMV0pICsgblsxXVxuICBdO1xuICByZXR1cm4gaHQociwgYywgYSk7XG59XG5mdW5jdGlvbiBIYyh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSBuLmZpeGVkRGlyZWN0aW9uLCBzID0gbi5maXhlZFBvc2l0aW9uLCBvID0gbi5maXhlZE9mZnNldDtcbiAgcmV0dXJuIGFpKFxuICAgIHQsXG4gICAgYHJvdGF0ZSgke2V9ZGVnKWAsXG4gICAgcixcbiAgICBzLFxuICAgIG8sXG4gICAgblxuICApO1xufVxuZnVuY3Rpb24gcWModCwgZSwgbiwgciwgcywgbykge1xuICBjb25zdCB7XG4gICAgZ3JvdXBhYmxlOiBpXG4gIH0gPSB0LnByb3BzLCBhID0gdC5zdGF0ZSwge1xuICAgIHRyYW5zZm9ybU9yaWdpbjogYyxcbiAgICBvZmZzZXRNYXRyaXg6IGwsXG4gICAgaXMzZDogdSxcbiAgICB3aWR0aDogZixcbiAgICBoZWlnaHQ6IGQsXG4gICAgbGVmdDogcCxcbiAgICB0b3A6IGdcbiAgfSA9IGEsIGggPSBvLmZpeGVkRGlyZWN0aW9uLCB2ID0gby5uZXh0VGFyZ2V0TWF0cml4IHx8IGEudGFyZ2V0TWF0cml4LCBtID0gdSA/IDQgOiAzLCBTID0gRmMoXG4gICAgcyxcbiAgICBlLFxuICAgIG4sXG4gICAgZixcbiAgICBkLFxuICAgIGNcbiAgKSwgeCA9IGkgPyBwIDogMCwgQyA9IGkgPyBnIDogMCwgRSA9IG1uKGwsIHYsIFMsIG0pLCBEID0gTmMociwgRSwgZSwgbiwgbSwgaCk7XG4gIHJldHVybiBLKEQsIFt4LCBDXSk7XG59XG5mdW5jdGlvbiBVYyh0LCBlKSB7XG4gIHJldHVybiB5dChqdCh0LnN0YXRlKSwgZSk7XG59XG5mdW5jdGlvbiBLYyh0LCBlKSB7XG4gIGNvbnN0IG4gPSB0LnRhcmdldEdlc3RvLCByID0gdC5jb250cm9sR2VzdG87XG4gIGxldCBzO1xuICByZXR1cm4gbiAhPSBudWxsICYmIG4uaXNGbGFnKCkgJiYgKHMgPSBuLmdldEV2ZW50RGF0YSgpW2VdKSwgIXMgJiYgKHIgIT0gbnVsbCAmJiByLmlzRmxhZygpKSAmJiAocyA9IHIuZ2V0RXZlbnREYXRhKClbZV0pLCBzIHx8IHt9O1xufVxuZnVuY3Rpb24gWmModCkge1xuICBpZiAodCAmJiB0LmdldFJvb3ROb2RlKSB7XG4gICAgY29uc3QgZSA9IHQuZ2V0Um9vdE5vZGUoKTtcbiAgICBpZiAoZS5ub2RlVHlwZSA9PT0gMTEpXG4gICAgICByZXR1cm4gZTtcbiAgfVxufVxuZnVuY3Rpb24gSmModCkge1xuICBjb25zdCBlID0gdChcInNjYWxlXCIpLCBuID0gdChcInJvdGF0ZVwiKSwgciA9IHQoXCJ0cmFuc2xhdGVcIiksIHMgPSBbXTtcbiAgcmV0dXJuIHIgJiYgciAhPT0gXCIwcHhcIiAmJiByICE9PSBcIm5vbmVcIiAmJiBzLnB1c2goYHRyYW5zbGF0ZSgke3Iuc3BsaXQoL1xccysvKS5qb2luKFwiLFwiKX0pYCksIG4gJiYgbiAhPT0gXCIxXCIgJiYgbiAhPT0gXCJub25lXCIgJiYgcy5wdXNoKGByb3RhdGUoJHtufSlgKSwgZSAmJiBlICE9PSBcIjFcIiAmJiBlICE9PSBcIm5vbmVcIiAmJiBzLnB1c2goYHNjYWxlKCR7ZS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIsXCIpfSlgKSwgcztcbn1cbmZ1bmN0aW9uIGNpKHQsIGUsIG4pIHtcbiAgbGV0IHIgPSB0O1xuICBjb25zdCBzID0gW10sIG8gPSBlcyh0KSB8fCBmZSh0KTtcbiAgbGV0IGkgPSAhbiAmJiB0ID09PSBlIHx8IHQgPT09IG8sIGEgPSBpLCBjID0gITEsIGwgPSAzLCB1LCBmLCBkLCBwID0gITEsIGcgPSBmbihlLCBlLCAhMCkub2Zmc2V0UGFyZW50LCBoID0gMTtcbiAgZm9yICg7IHIgJiYgIWE7ICkge1xuICAgIGEgPSBpO1xuICAgIGNvbnN0IHYgPSBHdChyKSwgbSA9IHYoXCJwb3NpdGlvblwiKSwgUyA9IHppKHIpLCB4ID0gbSA9PT0gXCJmaXhlZFwiLCBDID0gSmModik7XG4gICAgbGV0IEUgPSBPYyhpdShTKSksIEQsIFIgPSAhMSwgeSA9ICExLCBNID0gMCwgUCA9IDAsIF8gPSAwLCBPID0gMCwgVCA9IHtcbiAgICAgIGhhc1RyYW5zZm9ybTogITEsXG4gICAgICBmaXhlZENvbnRhaW5lcjogbnVsbFxuICAgIH07XG4gICAgeCAmJiAocCA9ICEwLCBUID0gZnUociksIGcgPSBULmZpeGVkQ29udGFpbmVyKTtcbiAgICBjb25zdCB3ID0gRS5sZW5ndGg7XG4gICAgIWMgJiYgKHcgPT09IDE2IHx8IEMubGVuZ3RoKSAmJiAoYyA9ICEwLCBsID0gNCwgQnIocyksIGQgJiYgKGQgPSBVdChkLCAzLCA0KSkpLCBjICYmIHcgPT09IDkgJiYgKEUgPSBVdChFLCAzLCA0KSk7XG4gICAgY29uc3Qge1xuICAgICAgdGFnTmFtZTogayxcbiAgICAgIGhhc09mZnNldDogSSxcbiAgICAgIGlzU1ZHOiAkLFxuICAgICAgb3JpZ2luOiBHLFxuICAgICAgdGFyZ2V0T3JpZ2luOiBMLFxuICAgICAgb2Zmc2V0OiB6XG4gICAgfSA9IHV1KHIsIHQpO1xuICAgIGxldCBbXG4gICAgICBOLFxuICAgICAgWlxuICAgIF0gPSB6O1xuICAgIGsgPT09IFwic3ZnXCIgJiYgIXIub3duZXJTVkdFbGVtZW50ICYmIGQgJiYgKHMucHVzaCh7XG4gICAgICB0eXBlOiBcInRhcmdldFwiLFxuICAgICAgdGFyZ2V0OiByLFxuICAgICAgbWF0cml4OiBkdShyLCBsKVxuICAgIH0pLCBzLnB1c2goe1xuICAgICAgdHlwZTogXCJvZmZzZXRcIixcbiAgICAgIHRhcmdldDogcixcbiAgICAgIG1hdHJpeDogZ3QobClcbiAgICB9KSk7XG4gICAgY29uc3QgWSA9IHBhcnNlRmxvYXQodihcInpvb21cIikpIHx8IDE7XG4gICAgaWYgKHgpXG4gICAgICBEID0gVC5maXhlZENvbnRhaW5lciwgUiA9ICEwO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgVyA9IGZuKHIsIGUsICExLCAhMCwgdiksIEogPSBXLm9mZnNldFpvb207XG4gICAgICBpZiAoRCA9IFcub2Zmc2V0UGFyZW50LCBSID0gVy5pc0VuZCwgeSA9IFcuaXNTdGF0aWMsIGggKj0gSiwgKFcuaXNDdXN0b21FbGVtZW50IHx8IEogIT09IDEpICYmIHkpXG4gICAgICAgIE4gLT0gRC5vZmZzZXRMZWZ0LCBaIC09IEQub2Zmc2V0VG9wO1xuICAgICAgZWxzZSBpZiAoKG5jIHx8IGVjKSAmJiBXLnBhcmVudFNsb3RFbGVtZW50KSB7XG4gICAgICAgIGxldCBGID0gRCwgSCA9IDAsIG50ID0gMDtcbiAgICAgICAgZm9yICg7IEYgJiYgWmMoRik7IClcbiAgICAgICAgICBIICs9IEYub2Zmc2V0TGVmdCwgbnQgKz0gRi5vZmZzZXRUb3AsIEYgPSBGLm9mZnNldFBhcmVudDtcbiAgICAgICAgTiAtPSBILCBaIC09IG50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJG8gJiYgIXJjICYmIEkgJiYgISQgJiYgeSAmJiAobSA9PT0gXCJyZWxhdGl2ZVwiIHx8IG0gPT09IFwic3RhdGljXCIpICYmIChOIC09IEQub2Zmc2V0TGVmdCwgWiAtPSBELm9mZnNldFRvcCwgaSA9IGkgfHwgUiksIHgpXG4gICAgICBJICYmIFQuaGFzVHJhbnNmb3JtICYmIChfID0gRC5jbGllbnRMZWZ0LCBPID0gRC5jbGllbnRUb3ApO1xuICAgIGVsc2UgaWYgKEkgJiYgZyAhPT0gRCAmJiAoTSA9IEQuY2xpZW50TGVmdCwgUCA9IEQuY2xpZW50VG9wKSwgSSAmJiBEID09PSBvKSB7XG4gICAgICBjb25zdCBXID0gQWkociwgITEpO1xuICAgICAgTiArPSBXWzBdLCBaICs9IFdbMV07XG4gICAgfVxuICAgIGlmIChzLnB1c2goe1xuICAgICAgdHlwZTogXCJ0YXJnZXRcIixcbiAgICAgIHRhcmdldDogcixcbiAgICAgIG1hdHJpeDogZW4oRSwgbCwgRylcbiAgICB9KSwgQy5sZW5ndGggJiYgKHMucHVzaCh7XG4gICAgICB0eXBlOiBcIm9mZnNldFwiLFxuICAgICAgdGFyZ2V0OiByLFxuICAgICAgbWF0cml4OiBndChsKVxuICAgIH0pLCBzLnB1c2goe1xuICAgICAgdHlwZTogXCJ0YXJnZXRcIixcbiAgICAgIHRhcmdldDogcixcbiAgICAgIG1hdHJpeDogZW4obG4oQyksIGwsIEcpXG4gICAgfSkpLCBJKSB7XG4gICAgICBjb25zdCBXID0gciA9PT0gdCwgSiA9IFcgPyAwIDogci5zY3JvbGxMZWZ0LCBxID0gVyA/IDAgOiByLnNjcm9sbFRvcDtcbiAgICAgIHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwib2Zmc2V0XCIsXG4gICAgICAgIHRhcmdldDogcixcbiAgICAgICAgbWF0cml4OiBDZShbXG4gICAgICAgICAgTiAtIEogKyBNIC0gXyxcbiAgICAgICAgICBaIC0gcSArIFAgLSBPXG4gICAgICAgIF0sIGwpXG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICAgIHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwib2Zmc2V0XCIsXG4gICAgICAgIHRhcmdldDogcixcbiAgICAgICAgb3JpZ2luOiBHXG4gICAgICB9KTtcbiAgICBpZiAoWSAhPT0gMSAmJiBzLnB1c2goe1xuICAgICAgdHlwZTogXCJ6b29tXCIsXG4gICAgICB0YXJnZXQ6IHIsXG4gICAgICBtYXRyaXg6IGVuKHJzKFtZLCBZXSwgbCksIGwsIFswLCAwXSlcbiAgICB9KSwgZCB8fCAoZCA9IEUpLCB1IHx8ICh1ID0gRyksIGYgfHwgKGYgPSBMKSwgYSB8fCB4KVxuICAgICAgYnJlYWs7XG4gICAgciA9IEQsIGkgPSBSLCAoIW4gfHwgciA9PT0gbykgJiYgKGEgPSBpKTtcbiAgfVxuICByZXR1cm4gZCB8fCAoZCA9IGd0KGwpKSwgdSB8fCAodSA9IFswLCAwXSksIGYgfHwgKGYgPSBbMCwgMF0pLCB7XG4gICAgem9vbTogaCxcbiAgICBvZmZzZXRDb250YWluZXI6IGcsXG4gICAgbWF0cml4ZXM6IHMsXG4gICAgdGFyZ2V0TWF0cml4OiBkLFxuICAgIHRyYW5zZm9ybU9yaWdpbjogdSxcbiAgICB0YXJnZXRPcmlnaW46IGYsXG4gICAgaXMzZDogYyxcbiAgICBoYXNGaXhlZDogcFxuICB9O1xufVxubGV0IGdlID0gbnVsbCwgaGUgPSBudWxsLCBJZSA9IG51bGw7XG5mdW5jdGlvbiBMZSh0KSB7XG4gIHQgPyAod2luZG93Lk1hcCAmJiAoZ2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLCBJZSA9IFtdKSA6IChnZSA9IG51bGwsIEllID0gbnVsbCwgaGUgPSBudWxsKTtcbn1cbmZ1bmN0aW9uIFFjKHQpIHtcbiAgY29uc3QgZSA9IGhlID09IG51bGwgPyB2b2lkIDAgOiBoZS5nZXQodCk7XG4gIGlmIChlKVxuICAgIHJldHVybiBlO1xuICBjb25zdCBuID0gbm4odCwgITApO1xuICByZXR1cm4gaGUgJiYgaGUuc2V0KHQsIG4pLCBuO1xufVxuZnVuY3Rpb24gdGwodCwgZSkge1xuICBpZiAoSWUpIHtcbiAgICBjb25zdCByID0ga3QoSWUsIChzKSA9PiBzWzBdWzBdID09IHQgJiYgc1swXVsxXSA9PSBlKTtcbiAgICBpZiAocilcbiAgICAgIHJldHVybiByWzFdO1xuICB9XG4gIGNvbnN0IG4gPSBjaSh0LCBlLCAhMCk7XG4gIHJldHVybiBJZSAmJiBJZS5wdXNoKFtbdCwgZV0sIG5dKSwgbjtcbn1cbmZ1bmN0aW9uIEd0KHQpIHtcbiAgbGV0IGUgPSBnZSA9PSBudWxsID8gdm9pZCAwIDogZ2UuZ2V0KHQpO1xuICBpZiAoIWUpIHtcbiAgICBjb25zdCBzID0gYWUodCkuZ2V0Q29tcHV0ZWRTdHlsZSh0KTtcbiAgICBpZiAoIWdlKVxuICAgICAgcmV0dXJuIChvKSA9PiBzW29dO1xuICAgIGUgPSB7XG4gICAgICBzdHlsZTogcyxcbiAgICAgIGNhY2hlZDoge31cbiAgICB9LCBnZS5zZXQodCwgZSk7XG4gIH1cbiAgY29uc3QgbiA9IGUuY2FjaGVkLCByID0gZS5zdHlsZTtcbiAgcmV0dXJuIChzKSA9PiAocyBpbiBuIHx8IChuW3NdID0gcltzXSksIG5bc10pO1xufVxudmFyIE1yID0geyBleHBvcnRzOiB7fSB9LCBxZSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIFZzO1xuZnVuY3Rpb24gZWwoKSB7XG4gIGlmIChWcykgcmV0dXJuIHFlO1xuICBWcyA9IDE7XG4gIHZhciB0ID0gVG8sIGUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIHMgPSB0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCBvID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24gaShhLCBjLCBsKSB7XG4gICAgdmFyIHUsIGYgPSB7fSwgZCA9IG51bGwsIHAgPSBudWxsO1xuICAgIGwgIT09IHZvaWQgMCAmJiAoZCA9IFwiXCIgKyBsKSwgYy5rZXkgIT09IHZvaWQgMCAmJiAoZCA9IFwiXCIgKyBjLmtleSksIGMucmVmICE9PSB2b2lkIDAgJiYgKHAgPSBjLnJlZik7XG4gICAgZm9yICh1IGluIGMpIHIuY2FsbChjLCB1KSAmJiAhby5oYXNPd25Qcm9wZXJ0eSh1KSAmJiAoZlt1XSA9IGNbdV0pO1xuICAgIGlmIChhICYmIGEuZGVmYXVsdFByb3BzKSBmb3IgKHUgaW4gYyA9IGEuZGVmYXVsdFByb3BzLCBjKSBmW3VdID09PSB2b2lkIDAgJiYgKGZbdV0gPSBjW3VdKTtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogZSwgdHlwZTogYSwga2V5OiBkLCByZWY6IHAsIHByb3BzOiBmLCBfb3duZXI6IHMuY3VycmVudCB9O1xuICB9XG4gIHJldHVybiBxZS5GcmFnbWVudCA9IG4sIHFlLmpzeCA9IGksIHFlLmpzeHMgPSBpLCBxZTtcbn1cbnZhciBVZSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGpzO1xuZnVuY3Rpb24gbmwoKSB7XG4gIHJldHVybiBqcyB8fCAoanMgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBUbywgZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBuID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgcyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgbyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgYSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBjID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCB1ID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIGYgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgZCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCBwID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgZyA9IFN5bWJvbC5pdGVyYXRvciwgaCA9IFwiQEBpdGVyYXRvclwiO1xuICAgIGZ1bmN0aW9uIHYoYikge1xuICAgICAgaWYgKGIgPT09IG51bGwgfHwgdHlwZW9mIGIgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgQSA9IGcgJiYgYltnXSB8fCBiW2hdO1xuICAgICAgcmV0dXJuIHR5cGVvZiBBID09IFwiZnVuY3Rpb25cIiA/IEEgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgbSA9IHQuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gICAgZnVuY3Rpb24gUyhiKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIEEgPSBhcmd1bWVudHMubGVuZ3RoLCBWID0gbmV3IEFycmF5KEEgPiAxID8gQSAtIDEgOiAwKSwgUSA9IDE7IFEgPCBBOyBRKyspXG4gICAgICAgICAgVltRIC0gMV0gPSBhcmd1bWVudHNbUV07XG4gICAgICAgIHgoXCJlcnJvclwiLCBiLCBWKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24geChiLCBBLCBWKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBRID0gbS5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCBjdCA9IFEuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgICBjdCAhPT0gXCJcIiAmJiAoQSArPSBcIiVzXCIsIFYgPSBWLmNvbmNhdChbY3RdKSk7XG4gICAgICAgIHZhciBwdCA9IFYubWFwKGZ1bmN0aW9uKG90KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhvdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwdC51bnNoaWZ0KFwiV2FybmluZzogXCIgKyBBKSwgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtiXSwgY29uc29sZSwgcHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgQyA9ICExLCBFID0gITEsIEQgPSAhMSwgUiA9ICExLCB5ID0gITEsIE07XG4gICAgTSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICAgIGZ1bmN0aW9uIFAoYikge1xuICAgICAgcmV0dXJuICEhKHR5cGVvZiBiID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiIHx8IGIgPT09IHIgfHwgYiA9PT0gbyB8fCB5IHx8IGIgPT09IHMgfHwgYiA9PT0gbCB8fCBiID09PSB1IHx8IFIgfHwgYiA9PT0gcCB8fCBDIHx8IEUgfHwgRCB8fCB0eXBlb2YgYiA9PSBcIm9iamVjdFwiICYmIGIgIT09IG51bGwgJiYgKGIuJCR0eXBlb2YgPT09IGQgfHwgYi4kJHR5cGVvZiA9PT0gZiB8fCBiLiQkdHlwZW9mID09PSBpIHx8IGIuJCR0eXBlb2YgPT09IGEgfHwgYi4kJHR5cGVvZiA9PT0gYyB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAgIC8vIHdpdGguXG4gICAgICBiLiQkdHlwZW9mID09PSBNIHx8IGIuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfKGIsIEEsIFYpIHtcbiAgICAgIHZhciBRID0gYi5kaXNwbGF5TmFtZTtcbiAgICAgIGlmIChRKVxuICAgICAgICByZXR1cm4gUTtcbiAgICAgIHZhciBjdCA9IEEuZGlzcGxheU5hbWUgfHwgQS5uYW1lIHx8IFwiXCI7XG4gICAgICByZXR1cm4gY3QgIT09IFwiXCIgPyBWICsgXCIoXCIgKyBjdCArIFwiKVwiIDogVjtcbiAgICB9XG4gICAgZnVuY3Rpb24gTyhiKSB7XG4gICAgICByZXR1cm4gYi5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVChiKSB7XG4gICAgICBpZiAoYiA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgYi50YWcgPT0gXCJudW1iZXJcIiAmJiBTKFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiksIHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGIuZGlzcGxheU5hbWUgfHwgYi5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgY2FzZSByOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgbjpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBvOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgczpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgbDpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChiLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBhOlxuICAgICAgICAgICAgdmFyIEEgPSBiO1xuICAgICAgICAgICAgcmV0dXJuIE8oQSkgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgIHZhciBWID0gYjtcbiAgICAgICAgICAgIHJldHVybiBPKFYuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICByZXR1cm4gXyhiLCBiLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICAgIGNhc2UgZjpcbiAgICAgICAgICAgIHZhciBRID0gYi5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIFEgIT09IG51bGwgPyBRIDogVChiLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2UgZDoge1xuICAgICAgICAgICAgdmFyIGN0ID0gYiwgcHQgPSBjdC5fcGF5bG9hZCwgb3QgPSBjdC5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBUKG90KHB0KSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHcgPSBPYmplY3QuYXNzaWduLCBrID0gMCwgSSwgJCwgRywgTCwgeiwgTiwgWjtcbiAgICBmdW5jdGlvbiBZKCkge1xuICAgIH1cbiAgICBZLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIGZ1bmN0aW9uIFcoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgSSA9IGNvbnNvbGUubG9nLCAkID0gY29uc29sZS5pbmZvLCBHID0gY29uc29sZS53YXJuLCBMID0gY29uc29sZS5lcnJvciwgeiA9IGNvbnNvbGUuZ3JvdXAsIE4gPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLCBaID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICB2YXIgYiA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHZhbHVlOiBZLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBpbmZvOiBiLFxuICAgICAgICAgICAgbG9nOiBiLFxuICAgICAgICAgICAgd2FybjogYixcbiAgICAgICAgICAgIGVycm9yOiBiLFxuICAgICAgICAgICAgZ3JvdXA6IGIsXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogYixcbiAgICAgICAgICAgIGdyb3VwRW5kOiBiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaysrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBKKCkge1xuICAgICAge1xuICAgICAgICBpZiAoay0tLCBrID09PSAwKSB7XG4gICAgICAgICAgdmFyIGIgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGxvZzogdyh7fSwgYiwge1xuICAgICAgICAgICAgICB2YWx1ZTogSVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiB3KHt9LCBiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiAkXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm46IHcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IEdcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IHcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IExcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXA6IHcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHpcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IE5cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IHcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFpcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgayA8IDAgJiYgUyhcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBxID0gbS5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBGO1xuICAgIGZ1bmN0aW9uIEgoYiwgQSwgVikge1xuICAgICAge1xuICAgICAgICBpZiAoRiA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGN0KSB7XG4gICAgICAgICAgICB2YXIgUSA9IGN0LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgRiA9IFEgJiYgUVsxXSB8fCBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBcbmAgKyBGICsgYjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG50ID0gITEsIGx0O1xuICAgIHtcbiAgICAgIHZhciB2dCA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBsdCA9IG5ldyB2dCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdChiLCBBKSB7XG4gICAgICBpZiAoIWIgfHwgbnQpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgViA9IGx0LmdldChiKTtcbiAgICAgICAgaWYgKFYgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gVjtcbiAgICAgIH1cbiAgICAgIHZhciBRO1xuICAgICAgbnQgPSAhMDtcbiAgICAgIHZhciBjdCA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHQ7XG4gICAgICBwdCA9IHEuY3VycmVudCwgcS5jdXJyZW50ID0gbnVsbCwgVygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKEEpIHtcbiAgICAgICAgICB2YXIgb3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KG90LnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChvdCwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoenQpIHtcbiAgICAgICAgICAgICAgUSA9IHp0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoYiwgW10sIG90KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgb3QuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoenQpIHtcbiAgICAgICAgICAgICAgUSA9IHp0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5jYWxsKG90LnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHp0KSB7XG4gICAgICAgICAgICBRID0genQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGIoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoenQpIHtcbiAgICAgICAgaWYgKHp0ICYmIFEgJiYgdHlwZW9mIHp0LnN0YWNrID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBydCA9IHp0LnN0YWNrLnNwbGl0KGBcbmApLCBUdCA9IFEuc3RhY2suc3BsaXQoYFxuYCksIG10ID0gcnQubGVuZ3RoIC0gMSwgRXQgPSBUdC5sZW5ndGggLSAxOyBtdCA+PSAxICYmIEV0ID49IDAgJiYgcnRbbXRdICE9PSBUdFtFdF07IClcbiAgICAgICAgICAgIEV0LS07XG4gICAgICAgICAgZm9yICg7IG10ID49IDEgJiYgRXQgPj0gMDsgbXQtLSwgRXQtLSlcbiAgICAgICAgICAgIGlmIChydFttdF0gIT09IFR0W0V0XSkge1xuICAgICAgICAgICAgICBpZiAobXQgIT09IDEgfHwgRXQgIT09IDEpXG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChtdC0tLCBFdC0tLCBFdCA8IDAgfHwgcnRbbXRdICE9PSBUdFtFdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIE50ID0gYFxuYCArIHJ0W210XS5yZXBsYWNlKFwiIGF0IG5ldyBcIiwgXCIgYXQgXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5kaXNwbGF5TmFtZSAmJiBOdC5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChOdCA9IE50LnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBiLmRpc3BsYXlOYW1lKSksIHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIiAmJiBsdC5zZXQoYiwgTnQpLCBOdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAobXQgPj0gMSAmJiBFdCA+PSAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG50ID0gITEsIHEuY3VycmVudCA9IHB0LCBKKCksIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gY3Q7XG4gICAgICB9XG4gICAgICB2YXIgVGUgPSBiID8gYi5kaXNwbGF5TmFtZSB8fCBiLm5hbWUgOiBcIlwiLCBwZSA9IFRlID8gSChUZSkgOiBcIlwiO1xuICAgICAgcmV0dXJuIHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIiAmJiBsdC5zZXQoYiwgcGUpLCBwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRnQoYiwgQSwgVikge1xuICAgICAgcmV0dXJuIHN0KGIsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTHQoYikge1xuICAgICAgdmFyIEEgPSBiLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhIShBICYmIEEuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0KGIsIEEsIFYpIHtcbiAgICAgIGlmIChiID09IG51bGwpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHN0KGIsIEx0KGIpKTtcbiAgICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gSChiKTtcbiAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgcmV0dXJuIEgoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSB1OlxuICAgICAgICAgIHJldHVybiBIKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAoYi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgYzpcbiAgICAgICAgICAgIHJldHVybiBGdChiLnJlbmRlcik7XG4gICAgICAgICAgY2FzZSBmOlxuICAgICAgICAgICAgcmV0dXJuIHV0KGIudHlwZSwgQSwgVik7XG4gICAgICAgICAgY2FzZSBkOiB7XG4gICAgICAgICAgICB2YXIgUSA9IGIsIGN0ID0gUS5fcGF5bG9hZCwgcHQgPSBRLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHV0KHB0KGN0KSwgQSwgVik7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgU3QgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBLdCA9IHt9LCBkZSA9IG0uUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBQZShiKSB7XG4gICAgICBpZiAoYikge1xuICAgICAgICB2YXIgQSA9IGIuX293bmVyLCBWID0gdXQoYi50eXBlLCBiLl9zb3VyY2UsIEEgPyBBLnR5cGUgOiBudWxsKTtcbiAgICAgICAgZGUuc2V0RXh0cmFTdGFja0ZyYW1lKFYpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGRlLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmEoYiwgQSwgViwgUSwgY3QpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHB0ID0gRnVuY3Rpb24uY2FsbC5iaW5kKFN0KTtcbiAgICAgICAgZm9yICh2YXIgb3QgaW4gYilcbiAgICAgICAgICBpZiAocHQoYiwgb3QpKSB7XG4gICAgICAgICAgICB2YXIgcnQgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGJbb3RdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBUdCA9IEVycm9yKChRIHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogXCIgKyBWICsgXCIgdHlwZSBgXCIgKyBvdCArIFwiYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgXCIgKyB0eXBlb2YgYltvdF0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IFR0Lm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgVHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnQgPSBiW290XShBLCBvdCwgUSwgViwgbnVsbCwgXCJTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKG10KSB7XG4gICAgICAgICAgICAgIHJ0ID0gbXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydCAmJiAhKHJ0IGluc3RhbmNlb2YgRXJyb3IpICYmIChQZShjdCksIFMoXCIlczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCIsIFEgfHwgXCJSZWFjdCBjbGFzc1wiLCBWLCBvdCwgdHlwZW9mIHJ0KSwgUGUobnVsbCkpLCBydCBpbnN0YW5jZW9mIEVycm9yICYmICEocnQubWVzc2FnZSBpbiBLdCkgJiYgKEt0W3J0Lm1lc3NhZ2VdID0gITAsIFBlKGN0KSwgUyhcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCBWLCBydC5tZXNzYWdlKSwgUGUobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1hID0gQXJyYXkuaXNBcnJheTtcbiAgICBmdW5jdGlvbiB0cihiKSB7XG4gICAgICByZXR1cm4gbWEoYik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHhhKGIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIEEgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIFYgPSBBICYmIGJbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBiLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIFY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNhKGIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBfcyhiKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfcyhiKSB7XG4gICAgICByZXR1cm4gXCJcIiArIGI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRzKGIpIHtcbiAgICAgIGlmIChTYShiKSlcbiAgICAgICAgcmV0dXJuIFMoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgeGEoYikpLCBfcyhiKTtcbiAgICB9XG4gICAgdmFyIEhlID0gbS5SZWFjdEN1cnJlbnRPd25lciwgRWEgPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBPcywgd3MsIGVyO1xuICAgIGVyID0ge307XG4gICAgZnVuY3Rpb24gQ2EoYikge1xuICAgICAgaWYgKFN0LmNhbGwoYiwgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIEEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKEEgJiYgQS5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYi5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gRGEoYikge1xuICAgICAgaWYgKFN0LmNhbGwoYiwgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIEEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKEEgJiYgQS5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYi5rZXkgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmEoYiwgQSkge1xuICAgICAgaWYgKHR5cGVvZiBiLnJlZiA9PSBcInN0cmluZ1wiICYmIEhlLmN1cnJlbnQgJiYgQSAmJiBIZS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gQSkge1xuICAgICAgICB2YXIgViA9IFQoSGUuY3VycmVudC50eXBlKTtcbiAgICAgICAgZXJbVl0gfHwgKFMoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBUKEhlLmN1cnJlbnQudHlwZSksIGIucmVmKSwgZXJbVl0gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHlhKGIsIEEpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBPcyB8fCAoT3MgPSAhMCwgUyhcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIEEpKTtcbiAgICAgICAgfTtcbiAgICAgICAgVi5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYiwgXCJrZXlcIiwge1xuICAgICAgICAgIGdldDogVixcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSYShiLCBBKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBWID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd3MgfHwgKHdzID0gITAsIFMoXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBBKSk7XG4gICAgICAgIH07XG4gICAgICAgIFYuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsIFwicmVmXCIsIHtcbiAgICAgICAgICBnZXQ6IFYsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIE1hID0gZnVuY3Rpb24oYiwgQSwgViwgUSwgY3QsIHB0LCBvdCkge1xuICAgICAgdmFyIHJ0ID0ge1xuICAgICAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAgICAgJCR0eXBlb2Y6IGUsXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogYixcbiAgICAgICAga2V5OiBBLFxuICAgICAgICByZWY6IFYsXG4gICAgICAgIHByb3BzOiBvdCxcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgX293bmVyOiBwdFxuICAgICAgfTtcbiAgICAgIHJldHVybiBydC5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJ0Ll9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogITFcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkocnQsIFwiX3NlbGZcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogUVxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShydCwgXCJfc291cmNlXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IGN0XG4gICAgICB9KSwgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZShydC5wcm9wcyksIE9iamVjdC5mcmVlemUocnQpKSwgcnQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBQYShiLCBBLCBWLCBRLCBjdCkge1xuICAgICAge1xuICAgICAgICB2YXIgcHQsIG90ID0ge30sIHJ0ID0gbnVsbCwgVHQgPSBudWxsO1xuICAgICAgICBWICE9PSB2b2lkIDAgJiYgKFRzKFYpLCBydCA9IFwiXCIgKyBWKSwgRGEoQSkgJiYgKFRzKEEua2V5KSwgcnQgPSBcIlwiICsgQS5rZXkpLCBDYShBKSAmJiAoVHQgPSBBLnJlZiwgYmEoQSwgY3QpKTtcbiAgICAgICAgZm9yIChwdCBpbiBBKVxuICAgICAgICAgIFN0LmNhbGwoQSwgcHQpICYmICFFYS5oYXNPd25Qcm9wZXJ0eShwdCkgJiYgKG90W3B0XSA9IEFbcHRdKTtcbiAgICAgICAgaWYgKGIgJiYgYi5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgbXQgPSBiLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBmb3IgKHB0IGluIG10KVxuICAgICAgICAgICAgb3RbcHRdID09PSB2b2lkIDAgJiYgKG90W3B0XSA9IG10W3B0XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ0IHx8IFR0KSB7XG4gICAgICAgICAgdmFyIEV0ID0gdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiID8gYi5kaXNwbGF5TmFtZSB8fCBiLm5hbWUgfHwgXCJVbmtub3duXCIgOiBiO1xuICAgICAgICAgIHJ0ICYmIHlhKG90LCBFdCksIFR0ICYmIFJhKG90LCBFdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hKGIsIHJ0LCBUdCwgY3QsIFEsIEhlLmN1cnJlbnQsIG90KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5yID0gbS5SZWFjdEN1cnJlbnRPd25lciwgSXMgPSBtLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gX2UoYikge1xuICAgICAgaWYgKGIpIHtcbiAgICAgICAgdmFyIEEgPSBiLl9vd25lciwgViA9IHV0KGIudHlwZSwgYi5fc291cmNlLCBBID8gQS50eXBlIDogbnVsbCk7XG4gICAgICAgIElzLnNldEV4dHJhU3RhY2tGcmFtZShWKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBJcy5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIHZhciBycjtcbiAgICByciA9ICExO1xuICAgIGZ1bmN0aW9uIHNyKGIpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiICYmIGIgIT09IG51bGwgJiYgYi4kJHR5cGVvZiA9PT0gZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQnMoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIGIgPSBUKG5yLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBcXGBgICsgYiArIFwiYC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2EoYikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciB6cyA9IHt9O1xuICAgIGZ1bmN0aW9uIFRhKGIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIEEgPSBCcygpO1xuICAgICAgICBpZiAoIUEpIHtcbiAgICAgICAgICB2YXIgViA9IHR5cGVvZiBiID09IFwic3RyaW5nXCIgPyBiIDogYi5kaXNwbGF5TmFtZSB8fCBiLm5hbWU7XG4gICAgICAgICAgViAmJiAoQSA9IGBcblxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8YCArIFYgKyBcIj4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBBcyhiLCBBKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghYi5fc3RvcmUgfHwgYi5fc3RvcmUudmFsaWRhdGVkIHx8IGIua2V5ICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBiLl9zdG9yZS52YWxpZGF0ZWQgPSAhMDtcbiAgICAgICAgdmFyIFYgPSBUYShBKTtcbiAgICAgICAgaWYgKHpzW1ZdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgenNbVl0gPSAhMDtcbiAgICAgICAgdmFyIFEgPSBcIlwiO1xuICAgICAgICBiICYmIGIuX293bmVyICYmIGIuX293bmVyICE9PSBuci5jdXJyZW50ICYmIChRID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBUKGIuX293bmVyLnR5cGUpICsgXCIuXCIpLCBfZShiKSwgUygnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgViwgUSksIF9lKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBHcyhiLCBBKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRyKGIpKVxuICAgICAgICAgIGZvciAodmFyIFYgPSAwOyBWIDwgYi5sZW5ndGg7IFYrKykge1xuICAgICAgICAgICAgdmFyIFEgPSBiW1ZdO1xuICAgICAgICAgICAgc3IoUSkgJiYgQXMoUSwgQSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcihiKSlcbiAgICAgICAgICBiLl9zdG9yZSAmJiAoYi5fc3RvcmUudmFsaWRhdGVkID0gITApO1xuICAgICAgICBlbHNlIGlmIChiKSB7XG4gICAgICAgICAgdmFyIGN0ID0gdihiKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGN0ID09IFwiZnVuY3Rpb25cIiAmJiBjdCAhPT0gYi5lbnRyaWVzKVxuICAgICAgICAgICAgZm9yICh2YXIgcHQgPSBjdC5jYWxsKGIpLCBvdDsgIShvdCA9IHB0Lm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICBzcihvdC52YWx1ZSkgJiYgQXMob3QudmFsdWUsIEEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9hKGIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIEEgPSBiLnR5cGU7XG4gICAgICAgIGlmIChBID09IG51bGwgfHwgdHlwZW9mIEEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBWO1xuICAgICAgICBpZiAodHlwZW9mIEEgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIFYgPSBBLnByb3BUeXBlcztcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIEEgPT0gXCJvYmplY3RcIiAmJiAoQS4kJHR5cGVvZiA9PT0gYyB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgICAgICBBLiQkdHlwZW9mID09PSBmKSlcbiAgICAgICAgICBWID0gQS5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChWKSB7XG4gICAgICAgICAgdmFyIFEgPSBUKEEpO1xuICAgICAgICAgIHZhKFYsIGIucHJvcHMsIFwicHJvcFwiLCBRLCBiKTtcbiAgICAgICAgfSBlbHNlIGlmIChBLlByb3BUeXBlcyAhPT0gdm9pZCAwICYmICFycikge1xuICAgICAgICAgIHJyID0gITA7XG4gICAgICAgICAgdmFyIGN0ID0gVChBKTtcbiAgICAgICAgICBTKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIGN0IHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlb2YgQS5nZXREZWZhdWx0UHJvcHMgPT0gXCJmdW5jdGlvblwiICYmICFBLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiBTKFwiZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzIGRlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhKGIpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgQSA9IE9iamVjdC5rZXlzKGIucHJvcHMpLCBWID0gMDsgViA8IEEubGVuZ3RoOyBWKyspIHtcbiAgICAgICAgICB2YXIgUSA9IEFbVl07XG4gICAgICAgICAgaWYgKFEgIT09IFwiY2hpbGRyZW5cIiAmJiBRICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICBfZShiKSwgUyhcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIFEpLCBfZShudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiLnJlZiAhPT0gbnVsbCAmJiAoX2UoYiksIFMoXCJJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLlwiKSwgX2UobnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIga3MgPSB7fTtcbiAgICBmdW5jdGlvbiAkcyhiLCBBLCBWLCBRLCBjdCwgcHQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIG90ID0gUChiKTtcbiAgICAgICAgaWYgKCFvdCkge1xuICAgICAgICAgIHZhciBydCA9IFwiXCI7XG4gICAgICAgICAgKGIgPT09IHZvaWQgMCB8fCB0eXBlb2YgYiA9PSBcIm9iamVjdFwiICYmIGIgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoYikubGVuZ3RoID09PSAwKSAmJiAocnQgKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKTtcbiAgICAgICAgICB2YXIgVHQgPSBfYSgpO1xuICAgICAgICAgIFR0ID8gcnQgKz0gVHQgOiBydCArPSBCcygpO1xuICAgICAgICAgIHZhciBtdDtcbiAgICAgICAgICBiID09PSBudWxsID8gbXQgPSBcIm51bGxcIiA6IHRyKGIpID8gbXQgPSBcImFycmF5XCIgOiBiICE9PSB2b2lkIDAgJiYgYi4kJHR5cGVvZiA9PT0gZSA/IChtdCA9IFwiPFwiICsgKFQoYi50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCBydCA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogbXQgPSB0eXBlb2YgYiwgUyhcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLCBtdCwgcnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBFdCA9IFBhKGIsIEEsIFYsIGN0LCBwdCk7XG4gICAgICAgIGlmIChFdCA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiBFdDtcbiAgICAgICAgaWYgKG90KSB7XG4gICAgICAgICAgdmFyIE50ID0gQS5jaGlsZHJlbjtcbiAgICAgICAgICBpZiAoTnQgIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmIChRKVxuICAgICAgICAgICAgICBpZiAodHIoTnQpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgVGUgPSAwOyBUZSA8IE50Lmxlbmd0aDsgVGUrKylcbiAgICAgICAgICAgICAgICAgIEdzKE50W1RlXSwgYik7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKE50KTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgUyhcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIEdzKE50LCBiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3QuY2FsbChBLCBcImtleVwiKSkge1xuICAgICAgICAgIHZhciBwZSA9IFQoYiksIHp0ID0gT2JqZWN0LmtleXMoQSkuZmlsdGVyKGZ1bmN0aW9uKGthKSB7XG4gICAgICAgICAgICByZXR1cm4ga2EgIT09IFwia2V5XCI7XG4gICAgICAgICAgfSksIG9yID0genQubGVuZ3RoID4gMCA/IFwie2tleTogc29tZUtleSwgXCIgKyB6dC5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgICAgaWYgKCFrc1twZSArIG9yXSkge1xuICAgICAgICAgICAgdmFyIEdhID0genQubGVuZ3RoID4gMCA/IFwie1wiICsgenQuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiO1xuICAgICAgICAgICAgUyhgQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XG4gIGxldCBwcm9wcyA9ICVzO1xuICA8JXMgey4uLnByb3BzfSAvPlxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XG4gIGxldCBwcm9wcyA9ICVzO1xuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+YCwgb3IsIHBlLCBHYSwgcGUpLCBrc1twZSArIG9yXSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYiA9PT0gciA/IHdhKEV0KSA6IE9hKEV0KSwgRXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIElhKGIsIEEsIFYpIHtcbiAgICAgIHJldHVybiAkcyhiLCBBLCBWLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJhKGIsIEEsIFYpIHtcbiAgICAgIHJldHVybiAkcyhiLCBBLCBWLCAhMSk7XG4gICAgfVxuICAgIHZhciB6YSA9IEJhLCBBYSA9IElhO1xuICAgIFVlLkZyYWdtZW50ID0gciwgVWUuanN4ID0gemEsIFVlLmpzeHMgPSBBYTtcbiAgfSgpKSwgVWU7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBNci5leHBvcnRzID0gZWwoKSA6IE1yLmV4cG9ydHMgPSBubCgpO1xudmFyIGl0ID0gTXIuZXhwb3J0cztcbmZ1bmN0aW9uIEh0KHQsIGUsIG4pIHtcbiAgY29uc3QgciA9IG4ub3JpZ2luYWxEYXRhcztcbiAgci5ncm91cGFibGUgPSByLmdyb3VwYWJsZSB8fCB7fTtcbiAgY29uc3QgcyA9IHIuZ3JvdXBhYmxlO1xuICBzLmNoaWxkRGF0YXMgPSBzLmNoaWxkRGF0YXMgfHwgW107XG4gIGNvbnN0IG8gPSBzLmNoaWxkRGF0YXM7XG4gIHJldHVybiB0Lm1vdmVhYmxlcy5tYXAoKGksIGEpID0+IChvW2FdID0gb1thXSB8fCB7fSwgb1thXVtlXSA9IG9bYV1bZV0gfHwge30sIHtcbiAgICAuLi5uLFxuICAgIGlzUmVxdWVzdENoaWxkOiAhMCxcbiAgICBkYXRhczogb1thXVtlXSxcbiAgICBvcmlnaW5hbERhdGFzOiBvW2FdXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGNyKHQsIGUsIG4sIHIsIHMsIG8sIGkpIHtcbiAgY29uc3QgYSA9ICEhbi5tYXRjaCgvU3RhcnQkL2cpLCBjID0gISFuLm1hdGNoKC9FbmQkL2cpLCBsID0gcy5pc1BpbmNoLCB1ID0gcy5kYXRhcywgZiA9IEh0KHQsIGUubmFtZSwgcyksIGQgPSB0Lm1vdmVhYmxlcywgcCA9IFtdLCBnID0gZi5tYXAoKGgsIHYpID0+IHtcbiAgICBjb25zdCBtID0gZFt2XSwgUyA9IG0uc3RhdGUsIHggPSBTLmdlc3RvcztcbiAgICBsZXQgQyA9IGg7XG4gICAgaWYgKGEpXG4gICAgICBDID0gbmV3IEZlKGkpLmRyYWdTdGFydChyLCBoKSwgcC5wdXNoKEMpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHhbaV0gfHwgKHhbaV0gPSB1LmNoaWxkR2VzdG9zW3ZdKSwgIXhbaV0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIEMgPSB2bihoLCBTLCByLCBsLCBvLCBpKSwgcC5wdXNoKEMpO1xuICAgIH1cbiAgICBjb25zdCBFID0gZVtuXShtLCB7IC4uLkMsIHBhcmVudEZsYWc6ICEwIH0pO1xuICAgIHJldHVybiBjICYmICh4W2ldID0gbnVsbCksIEU7XG4gIH0pO1xuICByZXR1cm4gYSAmJiAodS5jaGlsZEdlc3RvcyA9IGQubWFwKChoKSA9PiBoLnN0YXRlLmdlc3Rvc1tpXSkpLCB7XG4gICAgZXZlbnRQYXJhbXM6IGcsXG4gICAgY2hpbGRFdmVudHM6IHBcbiAgfTtcbn1cbmZ1bmN0aW9uIGVlKHQsIGUsIG4sIHIsIHMgPSAoaSwgYSkgPT4gYSwgbykge1xuICBjb25zdCBpID0gISFuLm1hdGNoKC9FbmQkL2cpLCBhID0gSHQodCwgZS5uYW1lLCByKSwgYyA9IHQubW92ZWFibGVzO1xuICByZXR1cm4gYS5tYXAoKHUsIGYpID0+IHtcbiAgICBjb25zdCBkID0gY1tmXTtcbiAgICBsZXQgcCA9IHU7XG4gICAgcCA9IHMoZCwgdSk7XG4gICAgY29uc3QgZyA9IGVbbl0oZCwgeyAuLi5wLCBwYXJlbnRGbGFnOiAhMCB9KTtcbiAgICByZXR1cm4gZyAmJiBvICYmIG8oZCwgdSwgZywgZiksIGkgJiYgKGQuc3RhdGUuZ2VzdG9zID0ge30pLCBnO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGtuKHQsIGUsIG4sIHIpIHtcbiAgY29uc3QgcyA9IG4uZml4ZWREaXJlY3Rpb24sIG8gPSBuLmZpeGVkUG9zaXRpb24sIGkgPSByLmRhdGFzLnN0YXJ0UG9zaXRpb25zIHx8IGp0KGUuc3RhdGUpLCBhID0geXQoaSwgcyksIFtjLCBsXSA9IF90KFxuICAgIGhuKC10LnJvdGF0aW9uIC8gMTgwICogTWF0aC5QSSwgMyksXG4gICAgW2FbMF0gLSBvWzBdLCBhWzFdIC0gb1sxXSwgMV0sXG4gICAgM1xuICApO1xuICByZXR1cm4gci5kYXRhcy5vcmlnaW5hbFggPSBjLCByLmRhdGFzLm9yaWdpbmFsWSA9IGwsIHI7XG59XG5mdW5jdGlvbiBsaSh0LCBlLCBuLCByKSB7XG4gIGNvbnN0IHsgcmVuZGVyUG9zZXM6IHMsIHJvdGF0aW9uOiBvLCBkaXJlY3Rpb246IGkgfSA9IHQuZ2V0U3RhdGUoKSwgeyB6b29tOiBhIH0gPSBEZSh0LnByb3BzLCBlKSwgYyA9IHRuKG8gLyBNYXRoLlBJICogMTgwKSwgbCA9IHt9LCB1ID0gdC5yZW5kZXJTdGF0ZTtcbiAgdS5yZW5kZXJEaXJlY3Rpb25NYXAgfHwgKHUucmVuZGVyRGlyZWN0aW9uTWFwID0ge30pO1xuICBjb25zdCBmID0gdS5yZW5kZXJEaXJlY3Rpb25NYXA7XG4gIG4uZm9yRWFjaCgoeyBkaXI6IHAgfSkgPT4ge1xuICAgIGxbcF0gPSAhMDtcbiAgfSk7XG4gIGNvbnN0IGQgPSB3dChpKTtcbiAgcmV0dXJuIG4ubWFwKCh7IGRhdGE6IHAsIGNsYXNzTmFtZXM6IGcsIGRpcjogaCB9KSA9PiB7XG4gICAgY29uc3QgdiA9IHFyW2hdO1xuICAgIGlmICghdiB8fCAhbFtoXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGZbaF0gPSAhMDtcbiAgICBjb25zdCBtID0gKHR0KGMsIDE1KSArIGQgKiBXb1toXSArIDcyMCkgJSAxODAsIFMgPSB7fTtcbiAgICByZXR1cm4gVmUocCkuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgU1tgZGF0YS0ke3h9YF0gPSBwW3hdO1xuICAgIH0pLCAvKiBAX19QVVJFX18gKi8gQm4oXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFUoXCJjb250cm9sXCIsIFwiZGlyZWN0aW9uXCIsIGgsIGUsIC4uLmcpLFxuICAgICAgICBcImRhdGEtcm90YXRpb25cIjogbSxcbiAgICAgICAgXCJkYXRhLWRpcmVjdGlvblwiOiBoLFxuICAgICAgICAuLi5TLFxuICAgICAgICBrZXk6IGBkaXJlY3Rpb24tJHtofWAsXG4gICAgICAgIHN0eWxlOiBObihcbiAgICAgICAgICBvLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgLi4udi5tYXAoKHgpID0+IHNbeF0pXG4gICAgICAgIClcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVpKHQsIGUsIG4sIHIpIHtcbiAgY29uc3Qge1xuICAgIHJlbmRlckRpcmVjdGlvbnM6IHMgPSBlLFxuICAgIGRpc3BsYXlBcm91bmRDb250cm9sczogb1xuICB9ID0gRGUodC5wcm9wcywgbik7XG4gIGlmICghcylcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGkgPSBzID09PSAhMCA/IFhyIDogcztcbiAgcmV0dXJuIFtcbiAgICAuLi5vID8gZ2kodCwgciwgbiwgaSkgOiBbXSxcbiAgICAuLi5saShcbiAgICAgIHQsXG4gICAgICBuLFxuICAgICAgaS5tYXAoKGEpID0+ICh7XG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICBjbGFzc05hbWVzOiBbXSxcbiAgICAgICAgZGlyOiBhXG4gICAgICB9KSlcbiAgICApXG4gIF07XG59XG5mdW5jdGlvbiB1bih0LCBlLCBuLCByLCBzLCBvLCAuLi5pKSB7XG4gIGNvbnN0IGEgPSB4dChuLCByKSwgYyA9IGUgPyB0dChhIC8gTWF0aC5QSSAqIDE4MCwgMTUpICUgMTgwIDogLTE7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaXQuanN4KFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBVKFxuICAgICAgICBcImxpbmVcIixcbiAgICAgICAgXCJkaXJlY3Rpb25cIixcbiAgICAgICAgZSA/IFwiZWRnZVwiIDogXCJcIixcbiAgICAgICAgZSxcbiAgICAgICAgLi4uaVxuICAgICAgKSxcbiAgICAgIFwiZGF0YS1yb3RhdGlvblwiOiBjLFxuICAgICAgXCJkYXRhLWxpbmUta2V5XCI6IG8sXG4gICAgICBcImRhdGEtZGlyZWN0aW9uXCI6IGUsXG4gICAgICBzdHlsZTogSmUobiwgciwgcywgYSlcbiAgICB9LFxuICAgIGBsaW5lLSR7b31gXG4gICk7XG59XG5mdW5jdGlvbiBmaSh0LCBlLCBuLCByLCBzKSB7XG4gIHJldHVybiAobiA9PT0gITAgPyBVYSA6IG4pLm1hcCgoaSwgYSkgPT4ge1xuICAgIGNvbnN0IFtjLCBsXSA9IHFyW2ldO1xuICAgIGlmIChsICE9IG51bGwpXG4gICAgICByZXR1cm4gdW4oXG4gICAgICAgIHQsXG4gICAgICAgIGksXG4gICAgICAgIHJbY10sXG4gICAgICAgIHJbbF0sXG4gICAgICAgIHMsXG4gICAgICAgIGAke2V9RWRnZSR7YX1gLFxuICAgICAgICBlXG4gICAgICApO1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG59XG5mdW5jdGlvbiBkaSh0KSB7XG4gIHJldHVybiAoZSwgbikgPT4ge1xuICAgIGNvbnN0IHIgPSBEZShlLnByb3BzLCB0KS5lZGdlO1xuICAgIHJldHVybiByICYmIChyID09PSAhMCB8fCByLmxlbmd0aCkgPyBbXG4gICAgICAuLi5maShcbiAgICAgICAgbixcbiAgICAgICAgdCxcbiAgICAgICAgcixcbiAgICAgICAgZS5nZXRTdGF0ZSgpLnJlbmRlclBvc2VzLFxuICAgICAgICBlLnByb3BzLnpvb21cbiAgICAgICksXG4gICAgICAuLi5ybChlLCB0LCBuKVxuICAgIF0gOiBwaShlLCB0LCBuKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHBpKHQsIGUsIG4pIHtcbiAgcmV0dXJuIHVpKHQsIFhyLCBlLCBuKTtcbn1cbmZ1bmN0aW9uIHJsKHQsIGUsIG4pIHtcbiAgcmV0dXJuIHVpKFxuICAgIHQsXG4gICAgW1wibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl0sXG4gICAgZSxcbiAgICBuXG4gICk7XG59XG5mdW5jdGlvbiBnaSh0LCBlLCBuLCByKSB7XG4gIGNvbnN0IHMgPSB0LnJlbmRlclN0YXRlO1xuICBzLnJlbmRlckRpcmVjdGlvbk1hcCB8fCAocy5yZW5kZXJEaXJlY3Rpb25NYXAgPSB7fSk7XG4gIGNvbnN0IHsgcmVuZGVyUG9zZXM6IG8sIHJvdGF0aW9uOiBpLCBkaXJlY3Rpb246IGEgfSA9IHQuZ2V0U3RhdGUoKSwgYyA9IHMucmVuZGVyRGlyZWN0aW9uTWFwLCB7IHpvb206IGwgfSA9IHQucHJvcHMsIHUgPSB3dChhKSwgZiA9IGkgLyBNYXRoLlBJICogMTgwO1xuICByZXR1cm4gKHIgfHwgVmUoYykpLm1hcCgoZCkgPT4ge1xuICAgIGNvbnN0IHAgPSBxcltkXTtcbiAgICBpZiAoIXApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBnID0gKHR0KGYsIDE1KSArIHUgKiBXb1tkXSArIDcyMCkgJSAxODAsIGggPSBbXCJhcm91bmQtY29udHJvbFwiXTtcbiAgICByZXR1cm4gbiAmJiBoLnB1c2goXCJkaXJlY3Rpb25cIiwgbiksIC8qIEBfX1BVUkVfXyAqLyBpdC5qc3goXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFUoLi4uaCksXG4gICAgICAgIFwiZGF0YS1yb3RhdGlvblwiOiBnLFxuICAgICAgICBcImRhdGEtZGlyZWN0aW9uXCI6IGQsXG4gICAgICAgIHN0eWxlOiBObihcbiAgICAgICAgICBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgLi4ucC5tYXAoKHYpID0+IG9bdl0pXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBgZGlyZWN0aW9uLWFyb3VuZC0ke2R9YFxuICAgICk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYXModCwgZSwgbikge1xuICBjb25zdCB7XG4gICAgcG9zaXRpb246IHIgPSBcImNsaWVudFwiLFxuICAgIGxlZnQ6IHMgPSAtMSAvIDAsXG4gICAgdG9wOiBvID0gLTEgLyAwLFxuICAgIHJpZ2h0OiBpID0gMSAvIDAsXG4gICAgYm90dG9tOiBhID0gMSAvIDBcbiAgfSA9IHQgfHwge30sIGMgPSB7XG4gICAgcG9zaXRpb246IHIsXG4gICAgbGVmdDogcyxcbiAgICB0b3A6IG8sXG4gICAgcmlnaHQ6IGksXG4gICAgYm90dG9tOiBhXG4gIH07XG4gIHJldHVybiB7XG4gICAgdmVydGljYWw6IFhzKGMsIGUsICEwKSxcbiAgICBob3Jpem9udGFsOiBYcyhjLCBuLCAhMSlcbiAgfTtcbn1cbmZ1bmN0aW9uIFVuKHQsIGUpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRhaW5lckNsaWVudFJlY3Q6IHtcbiAgICAgIGNsaWVudEhlaWdodDogbixcbiAgICAgIGNsaWVudFdpZHRoOiByLFxuICAgICAgY2xpZW50TGVmdDogcyxcbiAgICAgIGNsaWVudFRvcDogb1xuICAgIH0sXG4gICAgc25hcE9mZnNldDoge1xuICAgICAgbGVmdDogaSxcbiAgICAgIHRvcDogYSxcbiAgICAgIHJpZ2h0OiBjLFxuICAgICAgYm90dG9tOiBsXG4gICAgfVxuICB9ID0gdC5zdGF0ZSwgdSA9IGUgfHwgdC5wcm9wcy5ib3VuZHMgfHwge30sIGQgPSAodS5wb3NpdGlvbiB8fCBcImNsaWVudFwiKSA9PT0gXCJjc3NcIiwge1xuICAgIGxlZnQ6IHAgPSAtMSAvIDAsXG4gICAgdG9wOiBnID0gLTEgLyAwXG4gIH0gPSB1O1xuICBsZXQge1xuICAgIHJpZ2h0OiBoID0gZCA/IC0xIC8gMCA6IDEgLyAwLFxuICAgIGJvdHRvbTogdiA9IGQgPyAtMSAvIDAgOiAxIC8gMFxuICB9ID0gdTtcbiAgcmV0dXJuIGQgJiYgKGggPSByICsgYyAtIGkgLSBoLCB2ID0gbiArIGwgLSBhIC0gdiksIHtcbiAgICBsZWZ0OiBwICsgaSAtIHMsXG4gICAgcmlnaHQ6IGggKyBpIC0gcyxcbiAgICB0b3A6IGcgKyBhIC0gbyxcbiAgICBib3R0b206IHYgKyBhIC0gb1xuICB9O1xufVxuZnVuY3Rpb24gc2wodCwgZSwgbikge1xuICBjb25zdCB7XG4gICAgbGVmdDogcixcbiAgICB0b3A6IHMsXG4gICAgcmlnaHQ6IG8sXG4gICAgYm90dG9tOiBpXG4gIH0gPSBVbih0KSwgW2EsIGNdID0gbjtcbiAgbGV0IFtsLCB1XSA9IEsobiwgZSk7XG4gIEIobCkgPCBCdCAmJiAobCA9IDApLCBCKHUpIDwgQnQgJiYgKHUgPSAwKTtcbiAgY29uc3QgZiA9IHUgPiAwLCBkID0gbCA+IDAsIHAgPSB7XG4gICAgaXNCb3VuZDogITEsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHBvczogMFxuICB9LCBnID0ge1xuICAgIGlzQm91bmQ6ICExLFxuICAgIG9mZnNldDogMCxcbiAgICBwb3M6IDBcbiAgfTtcbiAgaWYgKGwgPT09IDAgJiYgdSA9PT0gMClcbiAgICByZXR1cm4ge1xuICAgICAgdmVydGljYWw6IHAsXG4gICAgICBob3Jpem9udGFsOiBnXG4gICAgfTtcbiAgaWYgKGwgPT09IDApXG4gICAgZiA/IGkgPCBjICYmIChnLnBvcyA9IGksIGcub2Zmc2V0ID0gYyAtIGkpIDogcyA+IGMgJiYgKGcucG9zID0gcywgZy5vZmZzZXQgPSBjIC0gcyk7XG4gIGVsc2UgaWYgKHUgPT09IDApXG4gICAgZCA/IG8gPCBhICYmIChwLnBvcyA9IG8sIHAub2Zmc2V0ID0gYSAtIG8pIDogciA+IGEgJiYgKHAucG9zID0gciwgcC5vZmZzZXQgPSBhIC0gcik7XG4gIGVsc2Uge1xuICAgIGNvbnN0IGggPSB1IC8gbCwgdiA9IG5bMV0gLSBoICogYTtcbiAgICBsZXQgbSA9IDAsIFMgPSAwLCB4ID0gITE7XG4gICAgZCAmJiBvIDw9IGEgPyAobSA9IGggKiBvICsgdiwgUyA9IG8sIHggPSAhMCkgOiAhZCAmJiBhIDw9IHIgJiYgKG0gPSBoICogciArIHYsIFMgPSByLCB4ID0gITApLCB4ICYmIChtIDwgcyB8fCBtID4gaSkgJiYgKHggPSAhMSksIHggfHwgKGYgJiYgaSA8PSBjID8gKG0gPSBpLCBTID0gKG0gLSB2KSAvIGgsIHggPSAhMCkgOiAhZiAmJiBjIDw9IHMgJiYgKG0gPSBzLCBTID0gKG0gLSB2KSAvIGgsIHggPSAhMCkpLCB4ICYmIChwLmlzQm91bmQgPSAhMCwgcC5wb3MgPSBTLCBwLm9mZnNldCA9IGEgLSBTLCBnLmlzQm91bmQgPSAhMCwgZy5wb3MgPSBtLCBnLm9mZnNldCA9IGMgLSBtKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZlcnRpY2FsOiBwLFxuICAgIGhvcml6b250YWw6IGdcbiAgfTtcbn1cbmZ1bmN0aW9uIFhzKHQsIGUsIG4pIHtcbiAgY29uc3QgciA9IHRbbiA/IFwibGVmdFwiIDogXCJ0b3BcIl0sIHMgPSB0W24gPyBcInJpZ2h0XCIgOiBcImJvdHRvbVwiXSwgbyA9IE1hdGgubWluKC4uLmUpLCBpID0gTWF0aC5tYXgoLi4uZSksIGEgPSBbXTtcbiAgcmV0dXJuIHIgKyAxID4gbyAmJiBhLnB1c2goe1xuICAgIGRpcmVjdGlvbjogXCJzdGFydFwiLFxuICAgIGlzQm91bmQ6ICEwLFxuICAgIG9mZnNldDogbyAtIHIsXG4gICAgcG9zOiByXG4gIH0pLCBzIC0gMSA8IGkgJiYgYS5wdXNoKHtcbiAgICBkaXJlY3Rpb246IFwiZW5kXCIsXG4gICAgaXNCb3VuZDogITAsXG4gICAgb2Zmc2V0OiBpIC0gcyxcbiAgICBwb3M6IHNcbiAgfSksIGEubGVuZ3RoIHx8IGEucHVzaCh7XG4gICAgaXNCb3VuZDogITEsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHBvczogMFxuICB9KSwgYS5zb3J0KChjLCBsKSA9PiBCKGwub2Zmc2V0KSAtIEIoYy5vZmZzZXQpKTtcbn1cbmZ1bmN0aW9uIEhzKHQsIGUsIG4pIHtcbiAgcmV0dXJuIChuID8gdC5tYXAoKHMpID0+IGduKHMsIG4pKSA6IHQpLnNvbWUoKHMpID0+IHNbMF0gPCBlLmxlZnQgJiYgQihzWzBdIC0gZS5sZWZ0KSA+IDAuMSB8fCBzWzBdID4gZS5yaWdodCAmJiBCKHNbMF0gLSBlLnJpZ2h0KSA+IDAuMSB8fCBzWzFdIDwgZS50b3AgJiYgQihzWzFdIC0gZS50b3ApID4gMC4xIHx8IHNbMV0gPiBlLmJvdHRvbSAmJiBCKHNbMV0gLSBlLmJvdHRvbSkgPiAwLjEpO1xufVxuZnVuY3Rpb24gb2wodCwgZSwgbikge1xuICBjb25zdCByID0gVnQodCksIHMgPSBNYXRoLnNxcnQociAqIHIgLSBlICogZSkgfHwgMDtcbiAgcmV0dXJuIFtzLCAtc10uc29ydCgobywgaSkgPT4gQihvIC0gdFtuID8gMCA6IDFdKSAtIEIoaSAtIHRbbiA/IDAgOiAxXSkpLm1hcCgobykgPT4geHQoWzAsIDBdLCBuID8gW28sIGVdIDogW2UsIG9dKSk7XG59XG5mdW5jdGlvbiBpbCh0LCBlLCBuLCByLCBzKSB7XG4gIGlmICghdC5wcm9wcy5ib3VuZHMpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBvID0gcyAqIE1hdGguUEkgLyAxODAsIHtcbiAgICBsZWZ0OiBpLFxuICAgIHRvcDogYSxcbiAgICByaWdodDogYyxcbiAgICBib3R0b206IGxcbiAgfSA9IFVuKHQpLCB1ID0gaSAtIHJbMF0sIGYgPSBjIC0gclswXSwgZCA9IGEgLSByWzFdLCBwID0gbCAtIHJbMV0sIGcgPSB7XG4gICAgbGVmdDogdSxcbiAgICB0b3A6IGQsXG4gICAgcmlnaHQ6IGYsXG4gICAgYm90dG9tOiBwXG4gIH07XG4gIGlmICghSHMobiwgZywgMCkpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBoID0gW107XG4gIHJldHVybiBbXG4gICAgW3UsIDBdLFxuICAgIFtmLCAwXSxcbiAgICBbZCwgMV0sXG4gICAgW3AsIDFdXG4gIF0uZm9yRWFjaCgoW3YsIG1dKSA9PiB7XG4gICAgbi5mb3JFYWNoKChTKSA9PiB7XG4gICAgICBjb25zdCB4ID0geHQoWzAsIDBdLCBTKTtcbiAgICAgIGgucHVzaCguLi5vbChTLCB2LCBtKS5tYXAoKEMpID0+IG8gKyBDIC0geCkuZmlsdGVyKChDKSA9PiAhSHMoZSwgZywgQykpLm1hcCgoQykgPT4gdHQoQyAqIDE4MCAvIE1hdGguUEksIEJ0KSkpO1xuICAgIH0pO1xuICB9KSwgaDtcbn1cbmNvbnN0IGFsID0gW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2VudGVyXCJdLCBjbCA9IFtcInRvcFwiLCBcImJvdHRvbVwiLCBcIm1pZGRsZVwiXSwgcXMgPSB7XG4gIGxlZnQ6IFwic3RhcnRcIixcbiAgcmlnaHQ6IFwiZW5kXCIsXG4gIGNlbnRlcjogXCJjZW50ZXJcIixcbiAgdG9wOiBcInN0YXJ0XCIsXG4gIGJvdHRvbTogXCJlbmRcIixcbiAgbWlkZGxlOiBcImNlbnRlclwiXG59LCBsZSA9IHtcbiAgc3RhcnQ6IFwibGVmdFwiLFxuICBlbmQ6IFwicmlnaHRcIixcbiAgY2VudGVyOiBcImNlbnRlclwiXG59LCB1ZSA9IHtcbiAgc3RhcnQ6IFwidG9wXCIsXG4gIGVuZDogXCJib3R0b21cIixcbiAgY2VudGVyOiBcIm1pZGRsZVwiXG59O1xuZnVuY3Rpb24gQmUoKSB7XG4gIHJldHVybiB7XG4gICAgbGVmdDogITEsXG4gICAgdG9wOiAhMSxcbiAgICByaWdodDogITEsXG4gICAgYm90dG9tOiAhMVxuICB9O1xufVxuZnVuY3Rpb24gWGUodCwgZSkge1xuICBjb25zdCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHNuYXBwYWJsZTogbixcbiAgICAgIGJvdW5kczogcixcbiAgICAgIGlubmVyQm91bmRzOiBzLFxuICAgICAgdmVydGljYWxHdWlkZWxpbmVzOiBvLFxuICAgICAgaG9yaXpvbnRhbEd1aWRlbGluZXM6IGksXG4gICAgICBzbmFwR3JpZFdpZHRoOiBhLFxuICAgICAgc25hcEdyaWRIZWlnaHQ6IGNcbiAgICB9LFxuICAgIHN0YXRlOiB7IGd1aWRlbGluZXM6IGwsIGVuYWJsZVNuYXA6IHUgfVxuICB9ID0gdDtcbiAgcmV0dXJuICFuIHx8ICF1IHx8IGUgJiYgbiAhPT0gITAgJiYgbi5pbmRleE9mKGUpIDwgMCA/ICExIDogISEoYSB8fCBjIHx8IHIgfHwgcyB8fCBsICYmIGwubGVuZ3RoIHx8IG8gJiYgby5sZW5ndGggfHwgaSAmJiBpLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBjcyh0KSB7XG4gIHJldHVybiB0ID09PSAhMSA/IHt9IDogdCA9PT0gITAgfHwgIXQgPyB7IGxlZnQ6ICEwLCByaWdodDogITAsIHRvcDogITAsIGJvdHRvbTogITAgfSA6IHQ7XG59XG5mdW5jdGlvbiBsbCh0LCBlKSB7XG4gIGNvbnN0IG4gPSBjcyh0KSwgciA9IHt9O1xuICBmb3IgKGNvbnN0IHMgaW4gbilcbiAgICBzIGluIGUgJiYgbltzXSAmJiAocltzXSA9IGVbc10pO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGxzKHQsIGUpIHtcbiAgY29uc3QgbiA9IGxsKHQsIGUpLCByID0gY2wuZmlsdGVyKChvKSA9PiBvIGluIG4pLCBzID0gYWwuZmlsdGVyKChvKSA9PiBvIGluIG4pO1xuICByZXR1cm4ge1xuICAgIGhvcml6b250YWxOYW1lczogcixcbiAgICB2ZXJ0aWNhbE5hbWVzOiBzLFxuICAgIGhvcml6b250YWw6IHIubWFwKChvKSA9PiBuW29dKSxcbiAgICB2ZXJ0aWNhbDogcy5tYXAoKG8pID0+IG5bb10pXG4gIH07XG59XG5mdW5jdGlvbiB1bCh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSBodChcbiAgICB0LFxuICAgIFtlLmNsaWVudExlZnQsIGUuY2xpZW50VG9wXSxcbiAgICBuXG4gICk7XG4gIHJldHVybiBbXG4gICAgZS5sZWZ0ICsgclswXSxcbiAgICBlLnRvcCArIHJbMV1cbiAgXTtcbn1cbmZ1bmN0aW9uIGZsKFt0LCBlXSkge1xuICBsZXQgbiA9IGVbMF0gLSB0WzBdLCByID0gZVsxXSAtIHRbMV07XG4gIE1hdGguYWJzKG4pIDwgRHQgJiYgKG4gPSAwKSwgTWF0aC5hYnMocikgPCBEdCAmJiAociA9IDApO1xuICBsZXQgcyA9IDAsIG8gPSAwLCBpID0gMDtcbiAgcmV0dXJuIG4gPyByID8gKHMgPSAtciAvIG4sIG8gPSAxLCBpID0gcyAqIHRbMF0gLSB0WzFdKSA6IChvID0gMSwgaSA9IC10WzFdKSA6IChzID0gLTEsIGkgPSB0WzBdKSwgW3MsIG8sIGldLm1hcCgoYSkgPT4gdHQoYSwgRHQpKTtcbn1cbmNvbnN0IGhpID0gXCJzbmFwUm90YXRpb25UaHJlc2hvbGRcIiwgdmkgPSBcInNuYXBSb3RhdGlvbkRlZ3JlZXNcIiwgbWkgPSBcInNuYXBIb3Jpem9udGFsVGhyZXNob2xkXCIsIHhpID0gXCJzbmFwVmVydGljYWxUaHJlc2hvbGRcIjtcbmZ1bmN0aW9uIEtuKHQsIGUsIG4sIHIgPSBbXSwgcyA9IFtdLCBvLCBpKSB7XG4gIHZhciBmO1xuICBjb25zdCBhID0gdC5wcm9wcywgYyA9ICgoZiA9IHQuc3RhdGUuc25hcFRocmVzaG9sZEluZm8pID09IG51bGwgPyB2b2lkIDAgOiBmLm11bHRpcGxlcykgfHwgWzEsIDFdLCBsID0gbG8oXG4gICAgaSxcbiAgICBhW21pXSxcbiAgICA1XG4gICksIHUgPSBsbyhcbiAgICBvLFxuICAgIGFbeGldLFxuICAgIDVcbiAgKTtcbiAgcmV0dXJuIFNpKFxuICAgIHQuc3RhdGUuZ3VpZGVsaW5lcyxcbiAgICBlLFxuICAgIG4sXG4gICAgcixcbiAgICBzLFxuICAgIGwsXG4gICAgdSxcbiAgICBjXG4gICk7XG59XG5mdW5jdGlvbiBTaSh0LCBlLCBuLCByLCBzLCBvLCBpLCBhKSB7XG4gIHJldHVybiB7XG4gICAgdmVydGljYWw6IEtzKHQsIFwidmVydGljYWxcIiwgZSwgaSAqIGFbMF0sIHIpLFxuICAgIGhvcml6b250YWw6IEtzKHQsIFwiaG9yaXpvbnRhbFwiLCBuLCBvICogYVsxXSwgcylcbiAgfTtcbn1cbmZ1bmN0aW9uIGRsKHQsIGUsIG4pIHtcbiAgY29uc3QgW3IsIHNdID0gbiwgW28sIGldID0gZTtcbiAgbGV0IFthLCBjXSA9IEsobiwgZSk7XG4gIGNvbnN0IGwgPSBjID4gMCwgdSA9IGEgPiAwO1xuICBhID0gV24oYSksIGMgPSBXbihjKTtcbiAgY29uc3QgZiA9IHtcbiAgICBpc1NuYXA6ICExLFxuICAgIG9mZnNldDogMCxcbiAgICBwb3M6IDBcbiAgfSwgZCA9IHtcbiAgICBpc1NuYXA6ICExLFxuICAgIG9mZnNldDogMCxcbiAgICBwb3M6IDBcbiAgfTtcbiAgaWYgKGEgPT09IDAgJiYgYyA9PT0gMClcbiAgICByZXR1cm4ge1xuICAgICAgdmVydGljYWw6IGYsXG4gICAgICBob3Jpem9udGFsOiBkXG4gICAgfTtcbiAgY29uc3Qge1xuICAgIHZlcnRpY2FsOiBwLFxuICAgIGhvcml6b250YWw6IGdcbiAgfSA9IEtuKFxuICAgIHQsXG4gICAgYSA/IFtyXSA6IFtdLFxuICAgIGMgPyBbc10gOiBbXSxcbiAgICBbXSxcbiAgICBbXSxcbiAgICB2b2lkIDAsXG4gICAgdm9pZCAwXG4gICk7XG4gIHAucG9zSW5mb3MuZmlsdGVyKCh7IHBvczogRSB9KSA9PiB1ID8gRSA+PSBvIDogRSA8PSBvKSwgZy5wb3NJbmZvcy5maWx0ZXIoKHsgcG9zOiBFIH0pID0+IGwgPyBFID49IGkgOiBFIDw9IGkpLCBwLmlzU25hcCA9IHAucG9zSW5mb3MubGVuZ3RoID4gMCwgZy5pc1NuYXAgPSBnLnBvc0luZm9zLmxlbmd0aCA+IDA7XG4gIGNvbnN0IHtcbiAgICBpc1NuYXA6IGgsXG4gICAgZ3VpZGVsaW5lOiB2XG4gIH0gPSBQcihwKSwge1xuICAgIGlzU25hcDogbSxcbiAgICBndWlkZWxpbmU6IFNcbiAgfSA9IFByKGcpLCB4ID0gbSA/IFMucG9zWzFdIDogMCwgQyA9IGggPyB2LnBvc1swXSA6IDA7XG4gIGlmIChhID09PSAwKVxuICAgIG0gJiYgKGQuaXNTbmFwID0gITAsIGQucG9zID0gUy5wb3NbMV0sIGQub2Zmc2V0ID0gcyAtIGQucG9zKTtcbiAgZWxzZSBpZiAoYyA9PT0gMClcbiAgICBoICYmIChmLmlzU25hcCA9ICEwLCBmLnBvcyA9IEMsIGYub2Zmc2V0ID0gciAtIEMpO1xuICBlbHNlIHtcbiAgICBjb25zdCBFID0gYyAvIGEsIEQgPSBuWzFdIC0gRSAqIHI7XG4gICAgbGV0IFIgPSAwLCB5ID0gMCwgTSA9ICExO1xuICAgIGggPyAoeSA9IEMsIFIgPSBFICogeSArIEQsIE0gPSAhMCkgOiBtICYmIChSID0geCwgeSA9IChSIC0gRCkgLyBFLCBNID0gITApLCBNICYmIChmLmlzU25hcCA9ICEwLCBmLnBvcyA9IHksIGYub2Zmc2V0ID0gciAtIHksIGQuaXNTbmFwID0gITAsIGQucG9zID0gUiwgZC5vZmZzZXQgPSBzIC0gUik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbDogZixcbiAgICBob3Jpem9udGFsOiBkXG4gIH07XG59XG5mdW5jdGlvbiBvZSh0KSB7XG4gIGxldCBlID0gXCJcIjtcbiAgcmV0dXJuIHQgPT09IC0xIHx8IHQgPT09IFwidG9wXCIgfHwgdCA9PT0gXCJsZWZ0XCIgPyBlID0gXCJzdGFydFwiIDogdCA9PT0gMCB8fCB0ID09PSBcImNlbnRlclwiIHx8IHQgPT09IFwibWlkZGxlXCIgPyBlID0gXCJjZW50ZXJcIiA6ICh0ID09PSAxIHx8IHQgPT09IFwicmlnaHRcIiB8fCB0ID09PSBcImJvdHRvbVwiKSAmJiAoZSA9IFwiZW5kXCIpLCBlO1xufVxuZnVuY3Rpb24gVXModCwgZSwgbiwgcikge1xuICBjb25zdCBzID0gbHModC5wcm9wcy5zbmFwRGlyZWN0aW9ucywgZSksIG8gPSBLbihcbiAgICB0LFxuICAgIHMudmVydGljYWwsXG4gICAgcy5ob3Jpem9udGFsLFxuICAgIHMudmVydGljYWxOYW1lcy5tYXAoKGMpID0+IG9lKGMpKSxcbiAgICBzLmhvcml6b250YWxOYW1lcy5tYXAoKGMpID0+IG9lKGMpKSxcbiAgICBuLFxuICAgIHJcbiAgKSwgaSA9IG9lKHMuaG9yaXpvbnRhbE5hbWVzW28uaG9yaXpvbnRhbC5pbmRleF0pLCBhID0gb2Uocy52ZXJ0aWNhbE5hbWVzW28udmVydGljYWwuaW5kZXhdKTtcbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgLi4uby52ZXJ0aWNhbCxcbiAgICAgIGRpcmVjdGlvbjogYVxuICAgIH0sXG4gICAgaG9yaXpvbnRhbDoge1xuICAgICAgLi4uby5ob3Jpem9udGFsLFxuICAgICAgZGlyZWN0aW9uOiBpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gUHIodCkge1xuICBjb25zdCBlID0gdC5pc1NuYXA7XG4gIGlmICghZSlcbiAgICByZXR1cm4ge1xuICAgICAgaXNTbmFwOiAhMSxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGRpc3Q6IC0xLFxuICAgICAgcG9zOiAwLFxuICAgICAgZ3VpZGVsaW5lOiBudWxsXG4gICAgfTtcbiAgY29uc3QgbiA9IHQucG9zSW5mb3NbMF0sIHIgPSBuLmd1aWRlbGluZUluZm9zWzBdLCBzID0gci5vZmZzZXQsIG8gPSByLmRpc3QsIGkgPSByLmd1aWRlbGluZTtcbiAgcmV0dXJuIHtcbiAgICBpc1NuYXA6IGUsXG4gICAgb2Zmc2V0OiBzLFxuICAgIGRpc3Q6IG8sXG4gICAgcG9zOiBuLnBvcyxcbiAgICBndWlkZWxpbmU6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIEtzKHQsIGUsIG4sIHIsIHMgPSBbXSkge1xuICB2YXIgbDtcbiAgaWYgKCF0IHx8ICF0Lmxlbmd0aClcbiAgICByZXR1cm4ge1xuICAgICAgaXNTbmFwOiAhMSxcbiAgICAgIGluZGV4OiAtMSxcbiAgICAgIGRpcmVjdGlvbjogXCJcIixcbiAgICAgIHBvc0luZm9zOiBbXVxuICAgIH07XG4gIGNvbnN0IGkgPSBlID09PSBcInZlcnRpY2FsXCIgPyAwIDogMSwgYSA9IG4ubWFwKCh1LCBmKSA9PiB7XG4gICAgY29uc3QgZCA9IHNbZl0gfHwgXCJcIiwgcCA9IHQubWFwKChnKSA9PiB7XG4gICAgICBjb25zdCB7IHBvczogaCB9ID0gZywgdiA9IHUgLSBoW2ldO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiB2LFxuICAgICAgICBkaXN0OiBCKHYpLFxuICAgICAgICBndWlkZWxpbmU6IGcsXG4gICAgICAgIGRpcmVjdGlvbjogZFxuICAgICAgfTtcbiAgICB9KS5maWx0ZXIoKHsgZ3VpZGVsaW5lOiBnLCBkaXN0OiBoIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgdHlwZTogdiB9ID0gZztcbiAgICAgIHJldHVybiAhKHYgIT09IGUgfHwgaCA+IHIpO1xuICAgIH0pLnNvcnQoXG4gICAgICAoZywgaCkgPT4gZy5kaXN0IC0gaC5kaXN0XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zOiB1LFxuICAgICAgaW5kZXg6IGYsXG4gICAgICBndWlkZWxpbmVJbmZvczogcCxcbiAgICAgIGRpcmVjdGlvbjogZFxuICAgIH07XG4gIH0pLmZpbHRlcigodSkgPT4gdS5ndWlkZWxpbmVJbmZvcy5sZW5ndGggPiAwKS5zb3J0KCh1LCBmKSA9PiB1Lmd1aWRlbGluZUluZm9zWzBdLmRpc3QgLSBmLmd1aWRlbGluZUluZm9zWzBdLmRpc3QpLCBjID0gYS5sZW5ndGggPiAwO1xuICByZXR1cm4ge1xuICAgIGlzU25hcDogYyxcbiAgICBpbmRleDogYyA/IGFbMF0uaW5kZXggOiAtMSxcbiAgICBkaXJlY3Rpb246ICgobCA9IGFbMF0pID09IG51bGwgPyB2b2lkIDAgOiBsLmRpcmVjdGlvbikgPz8gXCJcIixcbiAgICBwb3NJbmZvczogYVxuICB9O1xufVxuZnVuY3Rpb24gcGwodCwgZSwgbiwgciwgcykge1xuICBsZXQgbyA9IFtdO1xuICBuWzBdICYmIG5bMV0gPyBvID0gW1xuICAgIG4sXG4gICAgWy1uWzBdLCBuWzFdXSxcbiAgICBbblswXSwgLW5bMV1dXG4gIF0gOiAhblswXSAmJiAhblsxXSA/IFtcbiAgICBbLTEsIC0xXSxcbiAgICBbMSwgLTFdLFxuICAgIFsxLCAxXSxcbiAgICBbLTEsIDFdXG4gIF0uZm9yRWFjaCgoZCwgcCwgZykgPT4ge1xuICAgIGNvbnN0IGggPSBnW3AgKyAxXSB8fCBnWzBdO1xuICAgIG8ucHVzaChkKSwgby5wdXNoKFtcbiAgICAgIChkWzBdICsgaFswXSkgLyAyLFxuICAgICAgKGRbMV0gKyBoWzFdKSAvIDJcbiAgICBdKTtcbiAgfSkgOiB0LnByb3BzLmtlZXBSYXRpbyA/IG8ucHVzaChcbiAgICBbLTEsIC0xXSxcbiAgICBbLTEsIDFdLFxuICAgIFsxLCAtMV0sXG4gICAgWzEsIDFdLFxuICAgIG5cbiAgKSA6IChvLnB1c2goLi4uTGMoW1xuICAgIFstMSwgLTFdLFxuICAgIFsxLCAtMV0sXG4gICAgWy0xLCAtMV0sXG4gICAgWzEsIDFdXG4gIF0sIG4pKSwgby5sZW5ndGggPiAxICYmIG8ucHVzaChbXG4gICAgKG9bMF1bMF0gKyBvWzFdWzBdKSAvIDIsXG4gICAgKG9bMF1bMV0gKyBvWzFdWzFdKSAvIDJcbiAgXSkpO1xuICBjb25zdCBpID0gby5tYXAoKGQpID0+IHl0KGUsIGQpKSwgYSA9IGkubWFwKChkKSA9PiBkWzBdKSwgYyA9IGkubWFwKChkKSA9PiBkWzFdKSwgbCA9IEtuKFxuICAgIHQsXG4gICAgYSxcbiAgICBjLFxuICAgIG8ubWFwKChkKSA9PiBvZShkWzBdKSksXG4gICAgby5tYXAoKGQpID0+IG9lKGRbMV0pKSxcbiAgICByLFxuICAgIHNcbiAgKSwgdSA9IG9lKG8ubWFwKChkKSA9PiBkWzBdKVtsLnZlcnRpY2FsLmluZGV4XSksIGYgPSBvZShvLm1hcCgoZCkgPT4gZFsxXSlbbC5ob3Jpem9udGFsLmluZGV4XSk7XG4gIHJldHVybiB7XG4gICAgdmVydGljYWw6IHtcbiAgICAgIC4uLmwudmVydGljYWwsXG4gICAgICBkaXJlY3Rpb246IHVcbiAgICB9LFxuICAgIGhvcml6b250YWw6IHtcbiAgICAgIC4uLmwuaG9yaXpvbnRhbCxcbiAgICAgIGRpcmVjdGlvbjogZlxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIEVpKHQsIGUpIHtcbiAgY29uc3QgbiA9IEIodC5vZmZzZXQpLCByID0gQihlLm9mZnNldCk7XG4gIHJldHVybiB0LmlzQm91bmQgJiYgZS5pc0JvdW5kID8gciAtIG4gOiB0LmlzQm91bmQgPyAtMSA6IGUuaXNCb3VuZCA/IDEgOiB0LmlzU25hcCAmJiBlLmlzU25hcCA/IHIgLSBuIDogdC5pc1NuYXAgPyAtMSA6IGUuaXNTbmFwIHx8IG4gPCBCdCA/IDEgOiByIDwgQnQgPyAtMSA6IG4gLSByO1xufVxuZnVuY3Rpb24gJG4odCwgZSkge1xuICByZXR1cm4gdC5zbGljZSgpLnNvcnQoKG4sIHIpID0+IHtcbiAgICBjb25zdCBzID0gbi5zaWduW2VdLCBvID0gci5zaWduW2VdLCBpID0gbi5vZmZzZXRbZV0sIGEgPSByLm9mZnNldFtlXTtcbiAgICBpZiAocykge1xuICAgICAgaWYgKCFvKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHJldHVybiAxO1xuICAgIHJldHVybiBFaShcbiAgICAgIHsgaXNCb3VuZDogbi5pc0JvdW5kLCBpc1NuYXA6IG4uaXNTbmFwLCBvZmZzZXQ6IGkgfSxcbiAgICAgIHsgaXNCb3VuZDogci5pc0JvdW5kLCBpc1NuYXA6IHIuaXNTbmFwLCBvZmZzZXQ6IGEgfVxuICAgICk7XG4gIH0pWzBdO1xufVxuZnVuY3Rpb24gZ2wodCwgZSwgbikge1xuICBjb25zdCByID0gW107XG4gIGlmIChuKVxuICAgIEIoZVswXSkgIT09IDEgfHwgQihlWzFdKSAhPT0gMSA/IHIucHVzaChcbiAgICAgIFtlLCBbLTEsIC0xXV0sXG4gICAgICBbZSwgWy0xLCAxXV0sXG4gICAgICBbZSwgWzEsIC0xXV0sXG4gICAgICBbZSwgWzEsIDFdXVxuICAgICkgOiByLnB1c2goXG4gICAgICBbZSwgW3RbMF0sIC10WzFdXV0sXG4gICAgICBbZSwgWy10WzBdLCB0WzFdXV1cbiAgICApLCByLnB1c2goW2UsIHRdKTtcbiAgZWxzZSBpZiAodFswXSAmJiB0WzFdIHx8ICF0WzBdICYmICF0WzFdKSB7XG4gICAgY29uc3QgcyA9IHRbMF0gPyB0IDogWzEsIDFdO1xuICAgIFsxLCAtMV0uZm9yRWFjaCgobykgPT4ge1xuICAgICAgWzEsIC0xXS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIGNvbnN0IGEgPSBbbyAqIHNbMF0sIGkgKiBzWzFdXTtcbiAgICAgICAgZVswXSA9PT0gYVswXSAmJiBlWzFdID09PSBhWzFdIHx8IHIucHVzaChbZSwgYV0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB0WzBdID8gKEIoZVswXSkgPT09IDEgPyBbMV0gOiBbMSwgLTFdKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgci5wdXNoKFxuICAgICAgW1xuICAgICAgICBbZVswXSwgLTFdLFxuICAgICAgICBbbyAqIHRbMF0sIC0xXVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgW2VbMF0sIDBdLFxuICAgICAgICBbbyAqIHRbMF0sIDBdXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBbZVswXSwgMV0sXG4gICAgICAgIFtvICogdFswXSwgMV1cbiAgICAgIF1cbiAgICApO1xuICB9KSA6IHRbMV0gJiYgKEIoZVsxXSkgPT09IDEgPyBbMV0gOiBbMSwgLTFdKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgci5wdXNoKFxuICAgICAgW1xuICAgICAgICBbLTEsIGVbMV1dLFxuICAgICAgICBbLTEsIG8gKiB0WzFdXVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgWzAsIGVbMV1dLFxuICAgICAgICBbMCwgbyAqIHRbMV1dXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBbMSwgZVsxXV0sXG4gICAgICAgIFsxLCBvICogdFsxXV1cbiAgICAgIF1cbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDaSh0LCBlKSB7XG4gIGNvbnN0IG4gPSB5cihbZVswXVswXSwgZVsxXVswXV0pLCByID0geXIoW2VbMF1bMV0sIGVbMV1bMV1dKTtcbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbDogbiA8PSB0WzBdLFxuICAgIGhvcml6b250YWw6IHIgPD0gdFsxXVxuICB9O1xufVxuZnVuY3Rpb24gdXModCwgW2UsIG5dKSB7XG4gIGxldCByID0gblswXSAtIGVbMF0sIHMgPSBuWzFdIC0gZVsxXTtcbiAgQihyKSA8IEJ0ICYmIChyID0gMCksIEIocykgPCBCdCAmJiAocyA9IDApO1xuICBsZXQgbywgaTtcbiAgcmV0dXJuIHIgPyBzID8gKG8gPSBzIC8gciAqICh0WzBdIC0gZVswXSkgKyBlWzFdLCBpID0gdFsxXSkgOiAobyA9IGVbMV0sIGkgPSB0WzFdKSA6IChvID0gZVswXSwgaSA9IHRbMF0pLCBvIC0gaTtcbn1cbmZ1bmN0aW9uIERpKHQsIGUsIG4sIHIgPSBCdCkge1xuICByZXR1cm4gdC5ldmVyeSgocykgPT4ge1xuICAgIGNvbnN0IG8gPSB1cyhzLCBlKTtcbiAgICByZXR1cm4gbyA8PSAwID09PSBuIHx8IEIobykgPD0gcjtcbiAgfSk7XG59XG5mdW5jdGlvbiBacyh0LCBlLCBuLCByLCBzID0gMCkge1xuICByZXR1cm4gciAmJiBlIC0gcyA8PSB0IHx8ICFyICYmIHQgPD0gbiArIHMgPyB7XG4gICAgaXNCb3VuZDogITAsXG4gICAgb2Zmc2V0OiByID8gZSAtIHQgOiBuIC0gdFxuICB9IDoge1xuICAgIGlzQm91bmQ6ICExLFxuICAgIG9mZnNldDogMFxuICB9O1xufVxuZnVuY3Rpb24gaGwodCwgeyBsaW5lOiBlLCBjZW50ZXJTaWduOiBuLCB2ZXJ0aWNhbFNpZ246IHIsIGhvcml6b250YWxTaWduOiBzLCBsaW5lQ29uc3RhbnRzOiBvIH0pIHtcbiAgY29uc3QgaSA9IHQucHJvcHMuaW5uZXJCb3VuZHM7XG4gIGlmICghaSlcbiAgICByZXR1cm4ge1xuICAgICAgaXNBbGxCb3VuZDogITEsXG4gICAgICBpc0JvdW5kOiAhMSxcbiAgICAgIGlzVmVydGljYWxCb3VuZDogITEsXG4gICAgICBpc0hvcml6b250YWxCb3VuZDogITEsXG4gICAgICBvZmZzZXQ6IFswLCAwXVxuICAgIH07XG4gIGNvbnN0IHsgbGVmdDogYSwgdG9wOiBjLCB3aWR0aDogbCwgaGVpZ2h0OiB1IH0gPSBpLCBmID0gW1thLCBjXSwgW2EsIGMgKyB1XV0sIGQgPSBbW2EsIGNdLCBbYSArIGwsIGNdXSwgcCA9IFtbYSArIGwsIGNdLCBbYSArIGwsIGMgKyB1XV0sIGcgPSBbW2EsIGMgKyB1XSwgW2EgKyBsLCBjICsgdV1dO1xuICBpZiAoRGkoW1xuICAgIFthLCBjXSxcbiAgICBbYSArIGwsIGNdLFxuICAgIFthLCBjICsgdV0sXG4gICAgW2EgKyBsLCBjICsgdV1cbiAgXSwgZSwgbikpXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWxsQm91bmQ6ICExLFxuICAgICAgaXNCb3VuZDogITEsXG4gICAgICBpc1ZlcnRpY2FsQm91bmQ6ICExLFxuICAgICAgaXNIb3Jpem9udGFsQm91bmQ6ICExLFxuICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICB9O1xuICBjb25zdCBoID0gaWUoZSwgbywgZCwgciksIHYgPSBpZShlLCBvLCBnLCByKSwgbSA9IGllKGUsIG8sIGYsIHMpLCBTID0gaWUoZSwgbywgcCwgcyksIHggPSBoLmlzQm91bmQgJiYgdi5pc0JvdW5kLCBDID0gaC5pc0JvdW5kIHx8IHYuaXNCb3VuZCwgRSA9IG0uaXNCb3VuZCAmJiBTLmlzQm91bmQsIEQgPSBtLmlzQm91bmQgfHwgUy5pc0JvdW5kLCBSID0gTmUoaC5vZmZzZXQsIHYub2Zmc2V0KSwgeSA9IE5lKG0ub2Zmc2V0LCBTLm9mZnNldCk7XG4gIGxldCBNID0gWzAsIDBdLCBQID0gITEsIF8gPSAhMTtcbiAgcmV0dXJuIEIoeSkgPCBCKFIpID8gKE0gPSBbUiwgMF0sIFAgPSBDLCBfID0geCkgOiAoTSA9IFswLCB5XSwgUCA9IEQsIF8gPSBFKSwge1xuICAgIGlzQWxsQm91bmQ6IF8sXG4gICAgaXNWZXJ0aWNhbEJvdW5kOiBDLFxuICAgIGlzSG9yaXpvbnRhbEJvdW5kOiBELFxuICAgIGlzQm91bmQ6IFAsXG4gICAgb2Zmc2V0OiBNXG4gIH07XG59XG5mdW5jdGlvbiBpZSh0LCBbZSwgbl0sIHIsIHMsIG8sIGkpIHtcbiAgY29uc3QgYSA9IHRbMF0sIGMgPSByWzBdLCBsID0gclsxXSwgdSA9IFduKGxbMV0gLSBjWzFdKSwgZiA9IFduKGxbMF0gLSBjWzBdKSwgZCA9IG4sIHAgPSBlLCBnID0gLWUgLyBuO1xuICBpZiAoZikge1xuICAgIGlmICghdSkge1xuICAgICAgaWYgKGkgJiYgIWQpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNCb3VuZDogITEsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH07XG4gICAgICBpZiAocCkge1xuICAgICAgICBjb25zdCBoID0gKGNbMV0gLSBhWzFdKSAvIGcgKyBhWzBdO1xuICAgICAgICByZXR1cm4gWnMoaCwgY1swXSwgbFswXSwgcywgbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBoID0gY1sxXSAtIGFbMV0sIHYgPSBCKGgpIDw9IChvIHx8IDApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzQm91bmQ6IHYsXG4gICAgICAgICAgb2Zmc2V0OiB2ID8gaCA6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGkgJiYgIXApXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0JvdW5kOiAhMSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgIGlmIChkKSB7XG4gICAgICBjb25zdCBoID0gZyAqIChjWzBdIC0gYVswXSkgKyBhWzFdO1xuICAgICAgcmV0dXJuIFpzKGgsIGNbMV0sIGxbMV0sIHMsIG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoID0gY1swXSAtIGFbMF0sIHYgPSBCKGgpIDw9IChvIHx8IDApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNCb3VuZDogdixcbiAgICAgICAgb2Zmc2V0OiB2ID8gaCA6IDBcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgaXNCb3VuZDogITEsXG4gICAgb2Zmc2V0OiAwXG4gIH07XG59XG5mdW5jdGlvbiBiaSh0LCBlLCBuKSB7XG4gIHJldHVybiBlLm1hcCgocikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzQm91bmQ6IHMsXG4gICAgICBvZmZzZXQ6IG8sXG4gICAgICBpc1ZlcnRpY2FsQm91bmQ6IGksXG4gICAgICBpc0hvcml6b250YWxCb3VuZDogYVxuICAgIH0gPSBobCh0LCByKSwgYyA9IHIubXVsdGlwbGUsIGwgPSBRdCh7XG4gICAgICBkYXRhczogbixcbiAgICAgIGRpc3RYOiBvWzBdLFxuICAgICAgZGlzdFk6IG9bMV1cbiAgICB9KS5tYXAoKHUsIGYpID0+IHUgKiAoY1tmXSA/IDIgLyBjW2ZdIDogMCkpO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduOiBjLFxuICAgICAgaXNCb3VuZDogcyxcbiAgICAgIGlzVmVydGljYWxCb3VuZDogaSxcbiAgICAgIGlzSG9yaXpvbnRhbEJvdW5kOiBhLFxuICAgICAgaXNTbmFwOiAhMSxcbiAgICAgIG9mZnNldDogbFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gdmwodCwgZSwgbikge1xuICBjb25zdCByID0gZnModCwgZSwgWzAsIDBdLCAhMSkubWFwKChmKSA9PiAoe1xuICAgIC4uLmYsXG4gICAgbXVsdGlwbGU6IGYubXVsdGlwbGUubWFwKChkKSA9PiBCKGQpICogMilcbiAgfSkpLCBzID0gYmkodCwgciwgbiksIG8gPSAkbihzLCAwKSwgaSA9ICRuKHMsIDEpO1xuICBsZXQgYSA9IDAsIGMgPSAwO1xuICBjb25zdCBsID0gby5pc1ZlcnRpY2FsQm91bmQgfHwgaS5pc1ZlcnRpY2FsQm91bmQsIHUgPSBvLmlzSG9yaXpvbnRhbEJvdW5kIHx8IGkuaXNIb3Jpem9udGFsQm91bmQ7XG4gIHJldHVybiAobCB8fCB1KSAmJiAoW2EsIGNdID0gJGMoe1xuICAgIGRhdGFzOiBuLFxuICAgIGRpc3RYOiAtby5vZmZzZXRbMF0sXG4gICAgZGlzdFk6IC1pLm9mZnNldFsxXVxuICB9KSksIHtcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgaXNCb3VuZDogbCxcbiAgICAgIG9mZnNldDogYVxuICAgIH0sXG4gICAgaG9yaXpvbnRhbDoge1xuICAgICAgaXNCb3VuZDogdSxcbiAgICAgIG9mZnNldDogY1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1sKHQsIGUpIHtcbiAgY29uc3QgbiA9IFtdLCByID0gdFswXSwgcyA9IHRbMV07XG4gIHJldHVybiByICYmIHMgPyBuLnB1c2goXG4gICAgW1swLCBzICogMl0sIHQsIFstciwgc11dLFxuICAgIFtbciAqIDIsIDBdLCB0LCBbciwgLXNdXVxuICApIDogciA/IChuLnB1c2goXG4gICAgW1tyICogMiwgMF0sIFtyLCAxXSwgW3IsIC0xXV1cbiAgKSwgZSAmJiBuLnB1c2goXG4gICAgW1swLCAtMV0sIFtyLCAtMV0sIFstciwgLTFdXSxcbiAgICBbWzAsIDFdLCBbciwgMV0sIFstciwgMV1dXG4gICkpIDogcyA/IChuLnB1c2goXG4gICAgW1swLCBzICogMl0sIFsxLCBzXSwgWy0xLCBzXV1cbiAgKSwgZSAmJiBuLnB1c2goXG4gICAgW1stMSwgMF0sIFstMSwgc10sIFstMSwgLXNdXSxcbiAgICBbWzEsIDBdLCBbMSwgc10sIFsxLCAtc11dXG4gICkpIDogbi5wdXNoKFxuICAgIFtbLTEsIDBdLCBbLTEsIC0xXSwgWy0xLCAxXV0sXG4gICAgW1sxLCAwXSwgWzEsIC0xXSwgWzEsIDFdXSxcbiAgICBbWzAsIC0xXSwgWy0xLCAtMV0sIFsxLCAtMV1dLFxuICAgIFtbMCwgMV0sIFstMSwgMV0sIFsxLCAxXV1cbiAgKSwgbjtcbn1cbmZ1bmN0aW9uIGZzKHQsIGUsIG4sIHIpIHtcbiAgY29uc3Qge1xuICAgIGFsbE1hdHJpeDogcyxcbiAgICBpczNkOiBvXG4gIH0gPSB0LnN0YXRlLCBpID0gTWUocywgMTAwLCAxMDAsIG8gPyA0IDogMyksIGEgPSB5dChpLCBbMCwgMF0pO1xuICByZXR1cm4gbWwobiwgcikubWFwKChbYywgbCwgdV0pID0+IHtcbiAgICBjb25zdCBmID0gW1xuICAgICAgeXQoaSwgbCksXG4gICAgICB5dChpLCB1KVxuICAgIF0sIGQgPSBmbChmKSwge1xuICAgICAgdmVydGljYWw6IHAsXG4gICAgICBob3Jpem9udGFsOiBnXG4gICAgfSA9IENpKGEsIGYpLCBoID0gdXMoYSwgZikgPD0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgbXVsdGlwbGU6IGMsXG4gICAgICBjZW50ZXJTaWduOiBoLFxuICAgICAgdmVydGljYWxTaWduOiBwLFxuICAgICAgaG9yaXpvbnRhbFNpZ246IGcsXG4gICAgICBsaW5lQ29uc3RhbnRzOiBkLFxuICAgICAgbGluZTogW1xuICAgICAgICB5dChlLCBsKSxcbiAgICAgICAgeXQoZSwgdSlcbiAgICAgIF1cbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIEpzKHQsIGUsIG4sIHIpIHtcbiAgY29uc3QgcyA9IHIgPyB0Lm1hcCgobykgPT4gZ24obywgcikpIDogdDtcbiAgcmV0dXJuIFtcbiAgICBbc1swXSwgc1sxXV0sXG4gICAgW3NbMV0sIHNbM11dLFxuICAgIFtzWzNdLCBzWzJdXSxcbiAgICBbc1syXSwgc1swXV1cbiAgXS5zb21lKChvKSA9PiB7XG4gICAgY29uc3QgaSA9IHVzKG4sIG8pIDw9IDA7XG4gICAgcmV0dXJuICFEaShlLCBvLCBpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB4bChbdCwgZV0pIHtcbiAgY29uc3QgbiA9IGVbMF0gLSB0WzBdLCByID0gZVsxXSAtIHRbMV07XG4gIGlmICghbilcbiAgICByZXR1cm4gQih0WzBdKTtcbiAgaWYgKCFyKVxuICAgIHJldHVybiBCKHRbMV0pO1xuICBjb25zdCBzID0gciAvIG47XG4gIHJldHVybiBCKCgtcyAqIHRbMF0gKyB0WzFdKSAvIE1hdGguc3FydChNYXRoLnBvdyhzLCAyKSArIDEpKTtcbn1cbmZ1bmN0aW9uIFNsKFt0LCBlXSkge1xuICBjb25zdCBuID0gZVswXSAtIHRbMF0sIHIgPSBlWzFdIC0gdFsxXTtcbiAgaWYgKCFuKVxuICAgIHJldHVybiBbdFswXSwgMF07XG4gIGlmICghcilcbiAgICByZXR1cm4gWzAsIHRbMV1dO1xuICBjb25zdCBzID0gciAvIG4sIG8gPSAtcyAqIHRbMF0gKyB0WzFdO1xuICByZXR1cm4gW1xuICAgIC1vIC8gKHMgKyAxIC8gcyksXG4gICAgbyAvIChzICogcyArIDEpXG4gIF07XG59XG5mdW5jdGlvbiBFbCh0LCBlLCBuLCByLCBzKSB7XG4gIGNvbnN0IG8gPSB0LnByb3BzLmlubmVyQm91bmRzLCBpID0gcyAqIE1hdGguUEkgLyAxODA7XG4gIGlmICghbylcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHtcbiAgICBsZWZ0OiBhLFxuICAgIHRvcDogYyxcbiAgICB3aWR0aDogbCxcbiAgICBoZWlnaHQ6IHVcbiAgfSA9IG8sIGYgPSBhIC0gclswXSwgZCA9IGEgKyBsIC0gclswXSwgcCA9IGMgLSByWzFdLCBnID0gYyArIHUgLSByWzFdLCBoID0gW1xuICAgIFtmLCBwXSxcbiAgICBbZCwgcF0sXG4gICAgW2YsIGddLFxuICAgIFtkLCBnXVxuICBdLCB2ID0geXQobiwgWzAsIDBdKTtcbiAgaWYgKCFKcyhuLCBoLCB2LCAwKSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IG0gPSBbXSwgUyA9IGgubWFwKCh4KSA9PiBbXG4gICAgVnQoeCksXG4gICAgeHQoWzAsIDBdLCB4KVxuICBdKTtcbiAgcmV0dXJuIFtcbiAgICBbblswXSwgblsxXV0sXG4gICAgW25bMV0sIG5bM11dLFxuICAgIFtuWzNdLCBuWzJdXSxcbiAgICBbblsyXSwgblswXV1cbiAgXS5mb3JFYWNoKCh4KSA9PiB7XG4gICAgY29uc3QgQyA9IHh0KFswLCAwXSwgU2woeCkpLCBFID0geGwoeCk7XG4gICAgbS5wdXNoKC4uLlMuZmlsdGVyKChbRF0pID0+IEQgJiYgRSA8PSBEKS5tYXAoKFtELCBSXSkgPT4ge1xuICAgICAgY29uc3QgeSA9IE1hdGguYWNvcyhEID8gRSAvIEQgOiAwKSwgTSA9IFIgKyB5LCBQID0gUiAtIHk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBpICsgTSAtIEMsXG4gICAgICAgIGkgKyBQIC0gQ1xuICAgICAgXTtcbiAgICB9KS5yZWR1Y2UoKEQsIFIpID0+IChELnB1c2goLi4uUiksIEQpLCBbXSkuZmlsdGVyKChEKSA9PiAhSnMoZSwgaCwgdiwgRCkpLm1hcCgoRCkgPT4gdHQoRCAqIDE4MCAvIE1hdGguUEksIEJ0KSkpO1xuICB9KSwgbTtcbn1cbmZ1bmN0aW9uIENsKHQpIHtcbiAgY29uc3QgZSA9IHQucHJvcHMuaW5uZXJCb3VuZHMsIG4gPSBCZSgpO1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIHtcbiAgICAgIGJvdW5kTWFwOiBuLFxuICAgICAgdmVydGljYWw6IFtdLFxuICAgICAgaG9yaXpvbnRhbDogW11cbiAgICB9O1xuICBjb25zdCB7XG4gICAgcG9zMTogcixcbiAgICBwb3MyOiBzLFxuICAgIHBvczM6IG8sXG4gICAgcG9zNDogaVxuICB9ID0gdC5nZXRSZWN0KCksIGEgPSBbciwgcywgbywgaV0sIGMgPSB5dChhLCBbMCwgMF0pLCB7IGxlZnQ6IGwsIHRvcDogdSwgd2lkdGg6IGYsIGhlaWdodDogZCB9ID0gZSwgcCA9IFtbbCwgdV0sIFtsLCB1ICsgZF1dLCBnID0gW1tsLCB1XSwgW2wgKyBmLCB1XV0sIGggPSBbW2wgKyBmLCB1XSwgW2wgKyBmLCB1ICsgZF1dLCB2ID0gW1tsLCB1ICsgZF0sIFtsICsgZiwgdSArIGRdXSwgbSA9IGZzKHQsIGEsIFswLCAwXSwgITEpLCBTID0gW10sIHggPSBbXTtcbiAgcmV0dXJuIG0uZm9yRWFjaCgoQykgPT4ge1xuICAgIGNvbnN0IHsgbGluZTogRSwgbGluZUNvbnN0YW50czogRCB9ID0gQywge1xuICAgICAgaG9yaXpvbnRhbDogUixcbiAgICAgIHZlcnRpY2FsOiB5XG4gICAgfSA9IENpKGMsIEUpLCBNID0gaWUoRSwgRCwgZywgeSwgMSwgITApLCBQID0gaWUoRSwgRCwgdiwgeSwgMSwgITApLCBfID0gaWUoRSwgRCwgcCwgUiwgMSwgITApLCBPID0gaWUoRSwgRCwgaCwgUiwgMSwgITApO1xuICAgIE0uaXNCb3VuZCAmJiAhbi50b3AgJiYgKFMucHVzaCh1KSwgbi50b3AgPSAhMCksIFAuaXNCb3VuZCAmJiAhbi5ib3R0b20gJiYgKFMucHVzaCh1ICsgZCksIG4uYm90dG9tID0gITApLCBfLmlzQm91bmQgJiYgIW4ubGVmdCAmJiAoeC5wdXNoKGwpLCBuLmxlZnQgPSAhMCksIE8uaXNCb3VuZCAmJiAhbi5yaWdodCAmJiAoeC5wdXNoKGwgKyBmKSwgbi5yaWdodCA9ICEwKTtcbiAgfSksIHtcbiAgICBib3VuZE1hcDogbixcbiAgICBob3Jpem9udGFsOiBTLFxuICAgIHZlcnRpY2FsOiB4XG4gIH07XG59XG5mdW5jdGlvbiBEbCh0LCBlLCBuLCByKSB7XG4gIGxldCBzID0gZVswXSAtIHRbMF0sIG8gPSBlWzFdIC0gdFsxXTtcbiAgaWYgKEIocykgPCBEdCAmJiAocyA9IDApLCBCKG8pIDwgRHQgJiYgKG8gPSAwKSwgIXMpXG4gICAgcmV0dXJuIHIgPyBbMCwgMF0gOiBbMCwgbl07XG4gIGlmICghbylcbiAgICByZXR1cm4gciA/IFtuLCAwXSA6IFswLCAwXTtcbiAgY29uc3QgaSA9IG8gLyBzLCBhID0gdFsxXSAtIGkgKiB0WzBdO1xuICBpZiAocikge1xuICAgIGNvbnN0IGMgPSBpICogKGVbMF0gKyBuKSArIGE7XG4gICAgcmV0dXJuIFtuLCBjIC0gZVsxXV07XG4gIH0gZWxzZVxuICAgIHJldHVybiBbKGVbMV0gKyBuIC0gYSkgLyBpIC0gZVswXSwgbl07XG59XG5mdW5jdGlvbiBfcih0LCBlLCBuLCByLCBzKSB7XG4gIGNvbnN0IG8gPSBEbCh0LCBlLCBuLCByKTtcbiAgaWYgKCFvKVxuICAgIHJldHVybiB7XG4gICAgICBpc091dHNpZGU6ICExLFxuICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICB9O1xuICBjb25zdCBpID0gdGUodCwgZSksIGEgPSB0ZShvLCB0KSwgYyA9IHRlKG8sIGUpLCBsID0gYSA+IGkgfHwgYyA+IGksIFt1LCBmXSA9IFF0KHtcbiAgICBkYXRhczogcyxcbiAgICBkaXN0WDogb1swXSxcbiAgICBkaXN0WTogb1sxXVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvZmZzZXQ6IFt1LCBmXSxcbiAgICBpc091dHNpZGU6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIEZuKHQsIGUpIHtcbiAgcmV0dXJuIHQuaXNCb3VuZCA/IHQub2Zmc2V0IDogZS5pc1NuYXAgPyBQcihlKS5vZmZzZXQgOiAwO1xufVxuZnVuY3Rpb24gYmwodCwgW2UsIG5dLCBbciwgc10sIFtvLCBpXSwgW2EsIGNdKSB7XG4gIGxldCBsID0gLWEsIHUgPSAtYztcbiAgaWYgKHQgJiYgZSAmJiBuKSB7XG4gICAgbCA9IDAsIHUgPSAwO1xuICAgIGNvbnN0IGYgPSBbXTtcbiAgICBpZiAociAmJiBzID8gZi5wdXNoKFswLCBjXSwgW2EsIDBdKSA6IHIgPyBmLnB1c2goW2EsIDBdKSA6IHMgPyBmLnB1c2goWzAsIGNdKSA6IG8gJiYgaSA/IGYucHVzaChbMCwgY10sIFthLCAwXSkgOiBvID8gZi5wdXNoKFthLCAwXSkgOiBpICYmIGYucHVzaChbMCwgY10pLCBmLmxlbmd0aCkge1xuICAgICAgZi5zb3J0KChwLCBnKSA9PiBWdChLKFtlLCBuXSwgcCkpIC0gVnQoSyhbZSwgbl0sIGcpKSk7XG4gICAgICBjb25zdCBkID0gZlswXTtcbiAgICAgIGlmIChkWzBdICYmIEIoZSkgPiBEdClcbiAgICAgICAgbCA9IC1kWzBdLCB1ID0gbiAqIEIoZSArIGwpIC8gQihlKSAtIG47XG4gICAgICBlbHNlIGlmIChkWzFdICYmIEIobikgPiBEdCkge1xuICAgICAgICBjb25zdCBwID0gbjtcbiAgICAgICAgdSA9IC1kWzFdLCBsID0gZSAqIEIobiArIHUpIC8gQihwKSAtIGU7XG4gICAgICB9XG4gICAgICBpZiAodCAmJiBzICYmIHIpXG4gICAgICAgIGlmIChCKGwpID4gRHQgJiYgQihsKSA8IEIoYSkpIHtcbiAgICAgICAgICBjb25zdCBwID0gQihhKSAvIEIobCk7XG4gICAgICAgICAgbCAqPSBwLCB1ICo9IHA7XG4gICAgICAgIH0gZWxzZSBpZiAoQih1KSA+IER0ICYmIEIodSkgPCBCKGMpKSB7XG4gICAgICAgICAgY29uc3QgcCA9IEIoYykgLyBCKHUpO1xuICAgICAgICAgIGwgKj0gcCwgdSAqPSBwO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBsID0gTmUoLWEsIGwpLCB1ID0gTmUoLWMsIHUpO1xuICAgIH1cbiAgfSBlbHNlXG4gICAgbCA9IGUgfHwgciA/IC1hIDogMCwgdSA9IG4gfHwgcyA/IC1jIDogMDtcbiAgcmV0dXJuIFtsLCB1XTtcbn1cbmZ1bmN0aW9uIHlsKHQsIGUsIG4sIHIsIHMsIG8pIHtcbiAgaWYgKCFYZSh0LCBcImRyYWdnYWJsZVwiKSlcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBpc1NuYXA6ICExLFxuICAgICAgICBpc0JvdW5kOiAhMSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpc1NuYXA6ICExLFxuICAgICAgICBpc0JvdW5kOiAhMSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgXTtcbiAgY29uc3QgaSA9IGhzKG8uYWJzb2x1dGVQb3NlcywgW2UsIG5dKSwgeyBsZWZ0OiBhLCByaWdodDogYywgdG9wOiBsLCBib3R0b206IHUgfSA9IFl0KGkpLCBmID0ge1xuICAgIGhvcml6b250YWw6IGkubWFwKChQKSA9PiBQWzFdKSxcbiAgICB2ZXJ0aWNhbDogaS5tYXAoKFApID0+IFBbMF0pXG4gIH0sIGQgPSBjcyh0LnByb3BzLnNuYXBEaXJlY3Rpb25zKSwgcCA9IGxzKGQsIHtcbiAgICBsZWZ0OiBhLFxuICAgIHJpZ2h0OiBjLFxuICAgIHRvcDogbCxcbiAgICBib3R0b206IHUsXG4gICAgY2VudGVyOiAoYSArIGMpIC8gMixcbiAgICBtaWRkbGU6IChsICsgdSkgLyAyXG4gIH0pLCB7XG4gICAgdmVydGljYWw6IGcsXG4gICAgaG9yaXpvbnRhbDogaFxuICB9ID0gWm4odCwgcywgcCwgZiksIHtcbiAgICB2ZXJ0aWNhbDogdixcbiAgICBob3Jpem9udGFsOiBtXG4gIH0gPSB2bCh0LCBpLCBvKSwgUyA9IGcuaXNTbmFwLCB4ID0gaC5pc1NuYXAsIEMgPSBnLmlzQm91bmQgfHwgdi5pc0JvdW5kLCBFID0gaC5pc0JvdW5kIHx8IG0uaXNCb3VuZCwgRCA9IE5lKFxuICAgIGcub2Zmc2V0LFxuICAgIHYub2Zmc2V0XG4gICksIFIgPSBOZShcbiAgICBoLm9mZnNldCxcbiAgICBtLm9mZnNldFxuICApLCBbeSwgTV0gPSBibChcbiAgICByLFxuICAgIFtlLCBuXSxcbiAgICBbQywgRV0sXG4gICAgW1MsIHhdLFxuICAgIFtELCBSXVxuICApO1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGlzQm91bmQ6IEMsXG4gICAgICBpc1NuYXA6IFMsXG4gICAgICBvZmZzZXQ6IHlcbiAgICB9LFxuICAgIHtcbiAgICAgIGlzQm91bmQ6IEUsXG4gICAgICBpc1NuYXA6IHgsXG4gICAgICBvZmZzZXQ6IE1cbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBabih0LCBlLCBuLCByID0gbikge1xuICBjb25zdCB7XG4gICAgaG9yaXpvbnRhbDogcyxcbiAgICB2ZXJ0aWNhbDogb1xuICB9ID0gYXMoXG4gICAgVW4odCksXG4gICAgci52ZXJ0aWNhbCxcbiAgICByLmhvcml6b250YWxcbiAgKSwge1xuICAgIGhvcml6b250YWw6IGksXG4gICAgdmVydGljYWw6IGFcbiAgfSA9IGUgPyB7XG4gICAgaG9yaXpvbnRhbDogeyBpc1NuYXA6ICExLCBpbmRleDogLTEgfSxcbiAgICB2ZXJ0aWNhbDogeyBpc1NuYXA6ICExLCBpbmRleDogLTEgfVxuICB9IDogS24oXG4gICAgdCxcbiAgICBuLnZlcnRpY2FsLFxuICAgIG4uaG9yaXpvbnRhbCxcbiAgICB2b2lkIDAsXG4gICAgdm9pZCAwLFxuICAgIHZvaWQgMCxcbiAgICB2b2lkIDBcbiAgKSwgYyA9IEZuKFxuICAgIHNbMF0sXG4gICAgaVxuICApLCBsID0gRm4oXG4gICAgb1swXSxcbiAgICBhXG4gICksIHUgPSBCKGMpLCBmID0gQihsKTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc0JvdW5kOiBzWzBdLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IGkuaXNTbmFwLFxuICAgICAgc25hcEluZGV4OiBpLmluZGV4LFxuICAgICAgb2Zmc2V0OiBjLFxuICAgICAgZGlzdDogdSxcbiAgICAgIGJvdW5kczogcyxcbiAgICAgIHNuYXA6IGlcbiAgICB9LFxuICAgIHZlcnRpY2FsOiB7XG4gICAgICBpc0JvdW5kOiBvWzBdLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IGEuaXNTbmFwLFxuICAgICAgc25hcEluZGV4OiBhLmluZGV4LFxuICAgICAgb2Zmc2V0OiBsLFxuICAgICAgZGlzdDogZixcbiAgICAgIGJvdW5kczogbyxcbiAgICAgIHNuYXA6IGFcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBRcyh0LCBlLCBuLCByLCBzLCBvLCBpID0gWzEsIDFdKSB7XG4gIGNvbnN0IHtcbiAgICBob3Jpem9udGFsOiBhLFxuICAgIHZlcnRpY2FsOiBjXG4gIH0gPSBhcyhlLCBuLCByKSwge1xuICAgIGhvcml6b250YWw6IGwsXG4gICAgdmVydGljYWw6IHVcbiAgfSA9IFNpKFxuICAgIHQsXG4gICAgbixcbiAgICByLFxuICAgIFtdLFxuICAgIFtdLFxuICAgIHMsXG4gICAgbyxcbiAgICBpXG4gICksIGYgPSBGbihcbiAgICBhWzBdLFxuICAgIGxcbiAgKSwgZCA9IEZuKFxuICAgIGNbMF0sXG4gICAgdVxuICApLCBwID0gQihmKSwgZyA9IEIoZCk7XG4gIHJldHVybiB7XG4gICAgaG9yaXpvbnRhbDoge1xuICAgICAgaXNCb3VuZDogYVswXS5pc0JvdW5kLFxuICAgICAgaXNTbmFwOiBsLmlzU25hcCxcbiAgICAgIHNuYXBJbmRleDogbC5pbmRleCxcbiAgICAgIG9mZnNldDogZixcbiAgICAgIGRpc3Q6IHAsXG4gICAgICBib3VuZHM6IGEsXG4gICAgICBzbmFwOiBsXG4gICAgfSxcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgaXNCb3VuZDogY1swXS5pc0JvdW5kLFxuICAgICAgaXNTbmFwOiB1LmlzU25hcCxcbiAgICAgIHNuYXBJbmRleDogdS5pbmRleCxcbiAgICAgIG9mZnNldDogZCxcbiAgICAgIGRpc3Q6IGcsXG4gICAgICBib3VuZHM6IGMsXG4gICAgICBzbmFwOiB1XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gUmwodCwgZSwgbiwgcikge1xuICBjb25zdCBzID0geHQodCwgZSkgLyBNYXRoLlBJICogMTgwLCB7XG4gICAgdmVydGljYWw6IHtcbiAgICAgIGlzQm91bmQ6IG8sXG4gICAgICBpc1NuYXA6IGksXG4gICAgICBkaXN0OiBhXG4gICAgfSxcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc0JvdW5kOiBjLFxuICAgICAgaXNTbmFwOiBsLFxuICAgICAgZGlzdDogdVxuICAgIH1cbiAgfSA9IG4sIGYgPSBzICUgMTgwLCBkID0gZiA8IDMgfHwgZiA+IDE3NywgcCA9IGYgPiA4NyAmJiBmIDwgOTM7XG4gIHJldHVybiB1IDwgYSAmJiAobyB8fCBpICYmICFwICYmICghciB8fCAhZCkpID8gXCJ2ZXJ0aWNhbFwiIDogYyB8fCBsICYmICFkICYmICghciB8fCAhcCkgPyBcImhvcml6b250YWxcIiA6IFwiXCI7XG59XG5mdW5jdGlvbiBNbCh0LCBlLCBuLCByLCBzLCBvKSB7XG4gIHJldHVybiBuLm1hcCgoW2ksIGFdKSA9PiB7XG4gICAgY29uc3QgYyA9IHl0KGUsIGkpLCBsID0geXQoZSwgYSksIHUgPSByID8gUGwoXG4gICAgICB0LFxuICAgICAgYyxcbiAgICAgIGwsXG4gICAgICBzXG4gICAgKSA6IFpuKHQsIHMsIHtcbiAgICAgIHZlcnRpY2FsOiBbbFswXV0sXG4gICAgICBob3Jpem9udGFsOiBbbFsxXV1cbiAgICB9KSwge1xuICAgICAgaG9yaXpvbnRhbDoge1xuICAgICAgICAvLyBkaXN0OiBvdGhlckhvcml6b250YWxEaXN0LFxuICAgICAgICBvZmZzZXQ6IGYsXG4gICAgICAgIGlzQm91bmQ6IGQsXG4gICAgICAgIGlzU25hcDogcFxuICAgICAgfSxcbiAgICAgIHZlcnRpY2FsOiB7XG4gICAgICAgIC8vIGRpc3Q6IG90aGVyVmVydGljYWxEaXN0LFxuICAgICAgICBvZmZzZXQ6IGcsXG4gICAgICAgIGlzQm91bmQ6IGgsXG4gICAgICAgIGlzU25hcDogdlxuICAgICAgfVxuICAgIH0gPSB1LCBtID0gSyhhLCBpKTtcbiAgICBpZiAoIWcgJiYgIWYpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0JvdW5kOiBoIHx8IGQsXG4gICAgICAgIGlzU25hcDogdiB8fCBwLFxuICAgICAgICBzaWduOiBtLFxuICAgICAgICBvZmZzZXQ6IFswLCAwXVxuICAgICAgfTtcbiAgICBjb25zdCBTID0gUmwoXG4gICAgICBjLFxuICAgICAgbCxcbiAgICAgIHUsXG4gICAgICByXG4gICAgKTtcbiAgICBpZiAoIVMpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaWduOiBtLFxuICAgICAgICBpc0JvdW5kOiAhMSxcbiAgICAgICAgaXNTbmFwOiAhMSxcbiAgICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICAgIH07XG4gICAgY29uc3QgeCA9IFMgPT09IFwidmVydGljYWxcIjtcbiAgICBsZXQgQyA9IFswLCAwXTtcbiAgICByZXR1cm4gIXIgJiYgQihhWzBdKSA9PT0gMSAmJiBCKGFbMV0pID09PSAxICYmIGlbMF0gIT09IGFbMF0gJiYgaVsxXSAhPT0gYVsxXSA/IEMgPSBRdCh7XG4gICAgICBkYXRhczogbyxcbiAgICAgIGRpc3RYOiAtZyxcbiAgICAgIGRpc3RZOiAtZlxuICAgIH0pIDogQyA9IF9yKFxuICAgICAgYyxcbiAgICAgIGwsXG4gICAgICAtKHggPyBnIDogZiksXG4gICAgICB4LFxuICAgICAgb1xuICAgICkub2Zmc2V0LCBDID0gQy5tYXAoKEUsIEQpID0+IEUgKiAobVtEXSA/IDIgLyBtW0RdIDogMCkpLCB7XG4gICAgICBzaWduOiBtLFxuICAgICAgaXNCb3VuZDogeCA/IGggOiBkLFxuICAgICAgaXNTbmFwOiB4ID8gdiA6IHAsXG4gICAgICBvZmZzZXQ6IENcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRvKHQsIGUpIHtcbiAgcmV0dXJuIHQuaXNCb3VuZCA/IHQub2Zmc2V0IDogZS5pc1NuYXAgPyBlLm9mZnNldCA6IDA7XG59XG5mdW5jdGlvbiBQbCh0LCBlLCBuLCByKSB7XG4gIGNvbnN0IHtcbiAgICBob3Jpem9udGFsOiBzLFxuICAgIHZlcnRpY2FsOiBvXG4gIH0gPSBzbCh0LCBlLCBuKSwge1xuICAgIGhvcml6b250YWw6IGksXG4gICAgdmVydGljYWw6IGFcbiAgfSA9IHIgPyB7XG4gICAgaG9yaXpvbnRhbDogeyBpc1NuYXA6ICExIH0sXG4gICAgdmVydGljYWw6IHsgaXNTbmFwOiAhMSB9XG4gIH0gOiBkbCh0LCBlLCBuKSwgYyA9IHRvKFxuICAgIHMsXG4gICAgaVxuICApLCBsID0gdG8oXG4gICAgbyxcbiAgICBhXG4gICksIHUgPSBCKGMpLCBmID0gQihsKTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc0JvdW5kOiBzLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IGkuaXNTbmFwLFxuICAgICAgb2Zmc2V0OiBjLFxuICAgICAgZGlzdDogdVxuICAgIH0sXG4gICAgdmVydGljYWw6IHtcbiAgICAgIGlzQm91bmQ6IG8uaXNCb3VuZCxcbiAgICAgIGlzU25hcDogYS5pc1NuYXAsXG4gICAgICBvZmZzZXQ6IGwsXG4gICAgICBkaXN0OiBmXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gX2wodCwgZSwgbiwgciwgcykge1xuICBjb25zdCBvID0gWy1uWzBdLCAtblsxXV0sIHsgd2lkdGg6IGksIGhlaWdodDogYSB9ID0gdC5zdGF0ZSwgYyA9IHQucHJvcHMuYm91bmRzO1xuICBsZXQgbCA9IDEgLyAwLCB1ID0gMSAvIDA7XG4gIGlmIChjKSB7XG4gICAgY29uc3QgZiA9IFtcbiAgICAgIFtuWzBdLCAtblsxXV0sXG4gICAgICBbLW5bMF0sIG5bMV1dXG4gICAgXSwge1xuICAgICAgbGVmdDogZCA9IC0xIC8gMCxcbiAgICAgIHRvcDogcCA9IC0xIC8gMCxcbiAgICAgIHJpZ2h0OiBnID0gMSAvIDAsXG4gICAgICBib3R0b206IGggPSAxIC8gMFxuICAgIH0gPSBjO1xuICAgIGYuZm9yRWFjaCgodikgPT4ge1xuICAgICAgY29uc3QgbSA9IHZbMF0gIT09IG9bMF0sIFMgPSB2WzFdICE9PSBvWzFdLCB4ID0geXQoZSwgdiksIEMgPSB4dChyLCB4KSAqIDM2MCAvIE1hdGguUEk7XG4gICAgICBpZiAoUykge1xuICAgICAgICBjb25zdCBFID0geC5zbGljZSgpO1xuICAgICAgICAoQihDIC0gMzYwKSA8IDIgfHwgQihDIC0gMTgwKSA8IDIpICYmIChFWzFdID0gclsxXSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvZmZzZXQ6IFssIERdLFxuICAgICAgICAgIGlzT3V0c2lkZTogUlxuICAgICAgICB9ID0gX3IoXG4gICAgICAgICAgcixcbiAgICAgICAgICBFLFxuICAgICAgICAgIChyWzFdIDwgeFsxXSA/IGggOiBwKSAtIHhbMV0sXG4gICAgICAgICAgITEsXG4gICAgICAgICAgc1xuICAgICAgICApO1xuICAgICAgICBpc05hTihEKSB8fCAodSA9IGEgKyAoUiA/IDEgOiAtMSkgKiBCKEQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChtKSB7XG4gICAgICAgIGNvbnN0IEUgPSB4LnNsaWNlKCk7XG4gICAgICAgIChCKEMgLSA5MCkgPCAyIHx8IEIoQyAtIDI3MCkgPCAyKSAmJiAoRVswXSA9IHJbMF0pO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgb2Zmc2V0OiBbRF0sXG4gICAgICAgICAgaXNPdXRzaWRlOiBSXG4gICAgICAgIH0gPSBfcihcbiAgICAgICAgICByLFxuICAgICAgICAgIEUsXG4gICAgICAgICAgKHJbMF0gPCB4WzBdID8gZyA6IGQpIC0geFswXSxcbiAgICAgICAgICAhMCxcbiAgICAgICAgICBzXG4gICAgICAgICk7XG4gICAgICAgIGlzTmFOKEQpIHx8IChsID0gaSArIChSID8gMSA6IC0xKSAqIEIoRCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWF4V2lkdGg6IGwsXG4gICAgbWF4SGVpZ2h0OiB1XG4gIH07XG59XG5jb25zdCBPdCA9IHtcbiAgbmFtZTogXCJkcmFnZ2FibGVcIixcbiAgcHJvcHM6IFtcbiAgICBcImRyYWdnYWJsZVwiLFxuICAgIFwidGhyb3R0bGVEcmFnXCIsXG4gICAgXCJ0aHJvdHRsZURyYWdSb3RhdGVcIixcbiAgICBcImhpZGVUaHJvdHRsZURyYWdSb3RhdGVMaW5lXCIsXG4gICAgXCJzdGFydERyYWdSb3RhdGVcIixcbiAgICBcImVkZ2VEcmFnZ2FibGVcIlxuICBdLFxuICBldmVudHM6IFtcbiAgICBcImRyYWdTdGFydFwiLFxuICAgIFwiZHJhZ1wiLFxuICAgIFwiZHJhZ0VuZFwiLFxuICAgIFwiZHJhZ0dyb3VwU3RhcnRcIixcbiAgICBcImRyYWdHcm91cFwiLFxuICAgIFwiZHJhZ0dyb3VwRW5kXCJcbiAgXSxcbiAgcmVxdWVzdFN0eWxlKCkge1xuICAgIHJldHVybiBbXCJsZWZ0XCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIl07XG4gIH0sXG4gIHJlcXVlc3RDaGlsZFN0eWxlKCkge1xuICAgIHJldHVybiBbXCJsZWZ0XCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIl07XG4gIH0sXG4gIHJlbmRlcih0LCBlKSB7XG4gICAgY29uc3QgeyBoaWRlVGhyb3R0bGVEcmFnUm90YXRlTGluZTogbiwgdGhyb3R0bGVEcmFnUm90YXRlOiByLCB6b29tOiBzIH0gPSB0LnByb3BzLCB7IGRyYWdJbmZvOiBvLCBiZWZvcmVPcmlnaW46IGkgfSA9IHQuZ2V0U3RhdGUoKTtcbiAgICBpZiAobiB8fCAhciB8fCAhbylcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBhID0gby5kaXN0O1xuICAgIGlmICghYVswXSAmJiAhYVsxXSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBjID0gVnQoYSksIGwgPSB4dChhLCBbMCwgMF0pO1xuICAgIHJldHVybiBbLyogQF9fUFVSRV9fICovIGl0LmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogVShcbiAgICAgIFwibGluZVwiLFxuICAgICAgXCJob3Jpem9udGFsXCIsXG4gICAgICBcImRyYWdsaW5lXCIsXG4gICAgICBcImRhc2hlZFwiXG4gICAgKSwgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiBgJHtjfXB4YCxcbiAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke2lbMF19cHgsICR7aVsxXX1weCkgcm90YXRlKCR7bH1yYWQpIHNjYWxlWSgke3N9KWBcbiAgICB9IH0sIFwiZHJhZ1JvdGF0ZUd1aWRlbGluZVwiKV07XG4gIH0sXG4gIGRyYWdTdGFydCh0LCBlKSB7XG4gICAgY29uc3QgeyBkYXRhczogbiwgcGFyZW50RXZlbnQ6IHIsIHBhcmVudEdlc3RvOiBzIH0gPSBlLCBvID0gdC5zdGF0ZSwge1xuICAgICAgZ2VzdG9zOiBpLFxuICAgICAgc3R5bGU6IGFcbiAgICB9ID0gbztcbiAgICBpZiAoaS5kcmFnZ2FibGUpXG4gICAgICByZXR1cm4gITE7XG4gICAgaS5kcmFnZ2FibGUgPSBzIHx8IHQudGFyZ2V0R2VzdG8sIG4uZGF0YXMgPSB7fSwgbi5sZWZ0ID0gcGFyc2VGbG9hdChhLmxlZnQgfHwgXCJcIikgfHwgMCwgbi50b3AgPSBwYXJzZUZsb2F0KGEudG9wIHx8IFwiXCIpIHx8IDAsIG4uYm90dG9tID0gcGFyc2VGbG9hdChhLmJvdHRvbSB8fCBcIlwiKSB8fCAwLCBuLnJpZ2h0ID0gcGFyc2VGbG9hdChhLnJpZ2h0IHx8IFwiXCIpIHx8IDAsIG4uc3RhcnRWYWx1ZSA9IFswLCAwXSwgUmUodCwgZSksIHFuKHQsIGUsIFwidHJhbnNsYXRlXCIpLCBudSh0LCBuKSwgbi5wcmV2RGlzdCA9IFswLCAwXSwgbi5wcmV2QmVmb3JlRGlzdCA9IFswLCAwXSwgbi5pc0RyYWcgPSAhMSwgbi5kZWx0YU9mZnNldCA9IFswLCAwXTtcbiAgICBjb25zdCBjID0gZXQodCwgZSwge1xuICAgICAgc2V0OiAodSkgPT4ge1xuICAgICAgICBuLnN0YXJ0VmFsdWUgPSB1O1xuICAgICAgfSxcbiAgICAgIC4uLkhuKHQsIGUpXG4gICAgfSk7XG4gICAgcmV0dXJuIChyIHx8IGoodCwgXCJvbkRyYWdTdGFydFwiLCBjKSkgIT09ICExID8gKG4uaXNEcmFnID0gITAsIHQuc3RhdGUuZHJhZ0luZm8gPSB7XG4gICAgICBzdGFydFJlY3Q6IHQuZ2V0UmVjdCgpLFxuICAgICAgZGlzdDogWzAsIDBdXG4gICAgfSkgOiAoaS5kcmFnZ2FibGUgPSBudWxsLCBuLmlzUGluY2ggPSAhMSksIG4uaXNEcmFnID8gYyA6ICExO1xuICB9LFxuICBkcmFnKHQsIGUpIHtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm47XG4gICAgam4odCwgZSwgXCJ0cmFuc2xhdGVcIik7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YXM6IG4sXG4gICAgICBwYXJlbnRFdmVudDogcixcbiAgICAgIHBhcmVudEZsYWc6IHMsXG4gICAgICBpc1BpbmNoOiBvLFxuICAgICAgZGVsdGFPZmZzZXQ6IGksXG4gICAgICB1c2VTbmFwOiBhLFxuICAgICAgaXNSZXF1ZXN0OiBjLFxuICAgICAgaXNHcm91cDogbCxcbiAgICAgIHBhcmVudFRocm90dGxlRHJhZzogdVxuICAgIH0gPSBlO1xuICAgIGxldCB7IGRpc3RYOiBmLCBkaXN0WTogZCB9ID0gZTtcbiAgICBjb25zdCB7IGlzRHJhZzogcCwgcHJldkRpc3Q6IGcsIHByZXZCZWZvcmVEaXN0OiBoLCBzdGFydFZhbHVlOiB2IH0gPSBuO1xuICAgIGlmICghcClcbiAgICAgIHJldHVybjtcbiAgICBpICYmIChmICs9IGlbMF0sIGQgKz0gaVsxXSk7XG4gICAgY29uc3QgbSA9IHQucHJvcHMsIFMgPSBtLnBhcmVudE1vdmVhYmxlLCB4ID0gbCA/IDAgOiBtLnRocm90dGxlRHJhZyB8fCB1IHx8IDAsIEMgPSByID8gMCA6IG0udGhyb3R0bGVEcmFnUm90YXRlIHx8IDA7XG4gICAgbGV0IEUgPSAwLCBEID0gITEsIFIgPSAhMSwgeSA9ICExLCBNID0gITE7XG4gICAgaWYgKCFyICYmIEMgPiAwICYmIChmIHx8IGQpKSB7XG4gICAgICBjb25zdCBXID0gbS5zdGFydERyYWdSb3RhdGUgfHwgMCwgSiA9IHR0KFcgKyB4dChbMCwgMF0sIFtmLCBkXSkgKiAxODAgLyBNYXRoLlBJLCBDKSAtIFcsIHEgPSBkICogTWF0aC5hYnMoTWF0aC5jb3MoKEogLSA5MCkgLyAxODAgKiBNYXRoLlBJKSksIEYgPSBmICogTWF0aC5hYnMoTWF0aC5jb3MoSiAvIDE4MCAqIE1hdGguUEkpKSwgSCA9IFZ0KFtGLCBxXSk7XG4gICAgICBFID0gSiAqIE1hdGguUEkgLyAxODAsIGYgPSBIICogTWF0aC5jb3MoRSksIGQgPSBIICogTWF0aC5zaW4oRSk7XG4gICAgfVxuICAgIGlmICghbyAmJiAhciAmJiAhcykge1xuICAgICAgY29uc3QgW1csIEpdID0geWwoXG4gICAgICAgIHQsXG4gICAgICAgIGYsXG4gICAgICAgIGQsXG4gICAgICAgIEMsXG4gICAgICAgICFhICYmIGMgfHwgaSxcbiAgICAgICAgblxuICAgICAgKTtcbiAgICAgIEQgPSBXLmlzU25hcCwgUiA9IFcuaXNCb3VuZCwgeSA9IEouaXNTbmFwLCBNID0gSi5pc0JvdW5kO1xuICAgICAgY29uc3QgcSA9IFcub2Zmc2V0LCBGID0gSi5vZmZzZXQ7XG4gICAgICBmICs9IHEsIGQgKz0gRjtcbiAgICB9XG4gICAgY29uc3QgUCA9IGF0KHNpKHsgZGF0YXM6IG4sIGRpc3RYOiBmLCBkaXN0WTogZCB9KSwgdiksIF8gPSBhdChrYyh7IGRhdGFzOiBuLCBkaXN0WDogZiwgZGlzdFk6IGQgfSksIHYpO1xuICAgIFdzKF8sIEJ0KSwgV3MoUCwgQnQpLCBDIHx8ICghRCAmJiAhUiAmJiAoX1swXSA9IHR0KF9bMF0sIHgpLCBQWzBdID0gdHQoUFswXSwgeCkpLCAheSAmJiAhTSAmJiAoX1sxXSA9IHR0KF9bMV0sIHgpLCBQWzFdID0gdHQoUFsxXSwgeCkpKTtcbiAgICBjb25zdCBPID0gSyhQLCB2KSwgVCA9IEsoXywgdiksIHcgPSBLKFQsIGcpLCBrID0gSyhPLCBoKTtcbiAgICBuLnByZXZEaXN0ID0gVCwgbi5wcmV2QmVmb3JlRGlzdCA9IE8sIG4ucGFzc0RlbHRhID0gdywgbi5wYXNzRGlzdCA9IFQ7XG4gICAgY29uc3QgSSA9IG4ubGVmdCArIE9bMF0sICQgPSBuLnRvcCArIE9bMV0sIEcgPSBuLnJpZ2h0IC0gT1swXSwgTCA9IG4uYm90dG9tIC0gT1sxXSwgeiA9IFhuKFxuICAgICAgbixcbiAgICAgIGB0cmFuc2xhdGUoJHtfWzBdfXB4LCAke19bMV19cHgpYCxcbiAgICAgIGB0cmFuc2xhdGUoJHtUWzBdfXB4LCAke1RbMV19cHgpYFxuICAgICk7XG4gICAgaWYgKG9zKGUsIHopLCB0LnN0YXRlLmRyYWdJbmZvLmRpc3QgPSByID8gWzAsIDBdIDogVCwgIXIgJiYgIVMgJiYgdy5ldmVyeSgoVykgPT4gIVcpICYmIGsuc29tZSgoVykgPT4gIVcpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBOLFxuICAgICAgaGVpZ2h0OiBaXG4gICAgfSA9IHQuc3RhdGUsIFkgPSBldCh0LCBlLCB7XG4gICAgICB0cmFuc2Zvcm06IHosXG4gICAgICBkaXN0OiBULFxuICAgICAgZGVsdGE6IHcsXG4gICAgICB0cmFuc2xhdGU6IF8sXG4gICAgICBiZWZvcmVEaXN0OiBPLFxuICAgICAgYmVmb3JlRGVsdGE6IGssXG4gICAgICBiZWZvcmVUcmFuc2xhdGU6IFAsXG4gICAgICBsZWZ0OiBJLFxuICAgICAgdG9wOiAkLFxuICAgICAgcmlnaHQ6IEcsXG4gICAgICBib3R0b206IEwsXG4gICAgICB3aWR0aDogTixcbiAgICAgIGhlaWdodDogWixcbiAgICAgIGlzUGluY2g6IG8sXG4gICAgICAuLi5JdCh7XG4gICAgICAgIHRyYW5zZm9ybTogelxuICAgICAgfSwgZSlcbiAgICB9KTtcbiAgICByZXR1cm4gIXIgJiYgaih0LCBcIm9uRHJhZ1wiLCBZKSwgWTtcbiAgfSxcbiAgZHJhZ0FmdGVyKHQsIGUpIHtcbiAgICBjb25zdCBuID0gZS5kYXRhcywge1xuICAgICAgZGVsdGFPZmZzZXQ6IHJcbiAgICB9ID0gbjtcbiAgICByZXR1cm4gclswXSB8fCByWzFdID8gKG4uZGVsdGFPZmZzZXQgPSBbMCwgMF0sIHRoaXMuZHJhZyh0LCB7IC4uLmUsIGRlbHRhT2Zmc2V0OiByIH0pKSA6ICExO1xuICB9LFxuICBkcmFnRW5kKHQsIGUpIHtcbiAgICBjb25zdCB7IHBhcmVudEV2ZW50OiBuLCBkYXRhczogciB9ID0gZTtcbiAgICBpZiAodC5zdGF0ZS5kcmFnSW5mbyA9IG51bGwsICFyLmlzRHJhZylcbiAgICAgIHJldHVybjtcbiAgICByLmlzRHJhZyA9ICExO1xuICAgIGNvbnN0IHMgPSAkdCh0LCBlLCB7fSk7XG4gICAgcmV0dXJuICFuICYmIGoodCwgXCJvbkRyYWdFbmRcIiwgcyksIHM7XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0KHQsIGUpIHtcbiAgICB2YXIgZjtcbiAgICBjb25zdCB7IGRhdGFzOiBuLCBjbGllbnRYOiByLCBjbGllbnRZOiBzIH0gPSBlLCBvID0gdGhpcy5kcmFnU3RhcnQodCwgZSk7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkRXZlbnRzOiBpLFxuICAgICAgZXZlbnRQYXJhbXM6IGFcbiAgICB9ID0gY3IodCwgdGhpcywgXCJkcmFnU3RhcnRcIiwgW1xuICAgICAgciB8fCAwLFxuICAgICAgcyB8fCAwXG4gICAgXSwgZSwgITEsIFwiZHJhZ2dhYmxlXCIpLCBjID0ge1xuICAgICAgLi4ubyxcbiAgICAgIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogYVxuICAgIH0sIGwgPSBqKHQsIFwib25EcmFnR3JvdXBTdGFydFwiLCBjKTtcbiAgICBuLmlzRHJhZyA9IGwgIT09ICExO1xuICAgIGNvbnN0IHUgPSAoKGYgPSBpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogZi5kYXRhcy5zdGFydFZhbHVlKSA/PyBbMCwgMF07XG4gICAgcmV0dXJuIG4udGhyb3R0bGVPZmZzZXQgPSBbdVswXSAlIDEsIHVbMV0gJSAxXSwgbi5pc0RyYWcgPyBvIDogITE7XG4gIH0sXG4gIGRyYWdHcm91cCh0LCBlKSB7XG4gICAgY29uc3QgeyBkYXRhczogbiB9ID0gZTtcbiAgICBpZiAoIW4uaXNEcmFnKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0aGlzLmRyYWcodCwge1xuICAgICAgLi4uZSxcbiAgICAgIHBhcmVudFRocm90dGxlRHJhZzogdC5wcm9wcy50aHJvdHRsZURyYWdcbiAgICB9KSwgeyBwYXNzRGVsdGE6IHMgfSA9IGUuZGF0YXMsIHtcbiAgICAgIGV2ZW50UGFyYW1zOiBvXG4gICAgfSA9IGNyKHQsIHRoaXMsIFwiZHJhZ1wiLCBzLCBlLCAhMSwgXCJkcmFnZ2FibGVcIik7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB7XG4gICAgICB0YXJnZXRzOiB0LnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IG8sXG4gICAgICAuLi5yXG4gICAgfTtcbiAgICByZXR1cm4gaih0LCBcIm9uRHJhZ0dyb3VwXCIsIGkpLCBpO1xuICB9LFxuICBkcmFnR3JvdXBFbmQodCwgZSkge1xuICAgIGNvbnN0IHsgaXNEcmFnOiBuLCBkYXRhczogciB9ID0gZTtcbiAgICBpZiAoIXIuaXNEcmFnKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZHJhZ0VuZCh0LCBlKTtcbiAgICBjb25zdCB7XG4gICAgICBldmVudFBhcmFtczogc1xuICAgIH0gPSBjcih0LCB0aGlzLCBcImRyYWdFbmRcIiwgWzAsIDBdLCBlLCAhMSwgXCJkcmFnZ2FibGVcIik7XG4gICAgcmV0dXJuIGoodCwgXCJvbkRyYWdHcm91cEVuZFwiLCAkdCh0LCBlLCB7XG4gICAgICB0YXJnZXRzOiB0LnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IHNcbiAgICB9KSksIG47XG4gIH0sXG4gIC8qKlxuICAgICAgICogQG1ldGhvZCBNb3ZlYWJsZS5EcmFnZ2FibGUjcmVxdWVzdFxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtlXSAtIHRoZSBkcmFnZ2FibGUncyByZXF1ZXN0IHBhcmFtZXRlclxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLnhdIC0geCBwb3NpdGlvblxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLnldIC0geSBwb3NpdGlvblxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhWF0gLSBYIG51bWJlciB0byBtb3ZlXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2UuZGVsdGFZXSAtIFkgbnVtYmVyIHRvIG1vdmVcbiAgICAgICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICAgICAgKiBAZXhhbXBsZVxuICBcbiAgICAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcbiAgICAgICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxuICAgICAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSwgdHJ1ZSk7XG4gICAgICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcbiAgICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9LCB0cnVlKTtcbiAgICAgICAqXG4gICAgICAgKiAvLyByZXF1ZXN0U3RhcnRcbiAgICAgICAqIGNvbnN0IHJlcXVlc3RlciA9IG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgKlxuICAgICAgICogLy8gcmVxdWVzdFxuICAgICAgICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXG4gICAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAgICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcbiAgICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9KTtcbiAgICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyMjAsIHk6IDEwMCB9KTtcbiAgICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyNDAsIHk6IDEwMCB9KTtcbiAgICAgICAqXG4gICAgICAgKiAvLyByZXF1ZXN0RW5kXG4gICAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdEVuZCgpO1xuICAgICAgICovXG4gIHJlcXVlc3QodCkge1xuICAgIGNvbnN0IGUgPSB7fSwgbiA9IHQuZ2V0UmVjdCgpO1xuICAgIGxldCByID0gMCwgcyA9IDAsIG8gPSAhMTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb250cm9sOiAhMSxcbiAgICAgIHJlcXVlc3RTdGFydChpKSB7XG4gICAgICAgIHJldHVybiBvID0gaS51c2VTbmFwLCB7IGRhdGFzOiBlLCB1c2VTbmFwOiBvIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdChpKSB7XG4gICAgICAgIHJldHVybiBcInhcIiBpbiBpID8gciA9IGkueCAtIG4ubGVmdCA6IFwiZGVsdGFYXCIgaW4gaSAmJiAociArPSBpLmRlbHRhWCksIFwieVwiIGluIGkgPyBzID0gaS55IC0gbi50b3AgOiBcImRlbHRhWVwiIGluIGkgJiYgKHMgKz0gaS5kZWx0YVkpLCB7IGRhdGFzOiBlLCBkaXN0WDogciwgZGlzdFk6IHMsIHVzZVNuYXA6IG8gfTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0RW5kKCkge1xuICAgICAgICByZXR1cm4geyBkYXRhczogZSwgaXNEcmFnOiAhMCwgdXNlU25hcDogbyB9O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHVuc2V0KHQpIHtcbiAgICB0LnN0YXRlLmdlc3Rvcy5kcmFnZ2FibGUgPSBudWxsLCB0LnN0YXRlLmRyYWdJbmZvID0gbnVsbDtcbiAgfVxufTtcbmZ1bmN0aW9uIHlpKHQsIGUpIHtcbiAgcmV0dXJuIHtcbiAgICBmaXhlZFBvc2l0aW9uOiB5dCh0LCBlKSxcbiAgICBmaXhlZERpcmVjdGlvbjogZSxcbiAgICBmaXhlZE9mZnNldDogWzAsIDBdXG4gIH07XG59XG5mdW5jdGlvbiBUbCh0LCBlKSB7XG4gIGNvbnN0IHtcbiAgICBhbGxNYXRyaXg6IG4sXG4gICAgaXMzZDogcixcbiAgICB3aWR0aDogcyxcbiAgICBoZWlnaHQ6IG9cbiAgfSA9IHQsIGkgPSByID8gNCA6IDMsIGEgPSBbXG4gICAgcyAvIDIgKiAoMSArIGVbMF0pLFxuICAgIG8gLyAyICogKDEgKyBlWzFdKVxuICBdO1xuICByZXR1cm4ge1xuICAgIGZpeGVkUG9zaXRpb246IGh0KG4sIGEsIGkpLFxuICAgIGZpeGVkRGlyZWN0aW9uOiBlLFxuICAgIGZpeGVkT2Zmc2V0OiBbMCwgMF1cbiAgfTtcbn1cbmZ1bmN0aW9uIFJpKHQsIGUpIHtcbiAgY29uc3Qge1xuICAgIGFsbE1hdHJpeDogbixcbiAgICBpczNkOiByLFxuICAgIHdpZHRoOiBzLFxuICAgIGhlaWdodDogb1xuICB9ID0gdCwgaSA9IHIgPyA0IDogMywgYSA9IGpjKGUsIHMsIG8pLCBjID0gaHQobiwgZSwgaSksIGwgPSBbXG4gICAgcyA/IDAgOiBlWzBdLFxuICAgIG8gPyAwIDogZVsxXVxuICBdO1xuICByZXR1cm4ge1xuICAgIGZpeGVkUG9zaXRpb246IGMsXG4gICAgZml4ZWREaXJlY3Rpb246IGEsXG4gICAgZml4ZWRPZmZzZXQ6IGxcbiAgfTtcbn1cbmNvbnN0IGVvID0geHMoXCJyZXNpemFibGVcIiksIFRyID0ge1xuICBuYW1lOiBcInJlc2l6YWJsZVwiLFxuICBhYmxlR3JvdXA6IFwic2l6ZVwiLFxuICBjYW5QaW5jaDogITAsXG4gIHByb3BzOiBbXG4gICAgXCJyZXNpemFibGVcIixcbiAgICBcInRocm90dGxlUmVzaXplXCIsXG4gICAgXCJyZW5kZXJEaXJlY3Rpb25zXCIsXG4gICAgXCJkaXNwbGF5QXJvdW5kQ29udHJvbHNcIixcbiAgICBcImtlZXBSYXRpb1wiLFxuICAgIFwicmVzaXplRm9ybWF0XCIsXG4gICAgXCJrZWVwUmF0aW9GaW5hbGx5XCIsXG4gICAgXCJlZGdlXCIsXG4gICAgXCJjaGVja1Jlc2l6YWJsZUVycm9yXCJcbiAgXSxcbiAgZXZlbnRzOiBbXG4gICAgXCJyZXNpemVTdGFydFwiLFxuICAgIFwiYmVmb3JlUmVzaXplXCIsXG4gICAgXCJyZXNpemVcIixcbiAgICBcInJlc2l6ZUVuZFwiLFxuICAgIFwicmVzaXplR3JvdXBTdGFydFwiLFxuICAgIFwiYmVmb3JlUmVzaXplR3JvdXBcIixcbiAgICBcInJlc2l6ZUdyb3VwXCIsXG4gICAgXCJyZXNpemVHcm91cEVuZFwiXG4gIF0sXG4gIHJlbmRlcjogZGkoXCJyZXNpemFibGVcIiksXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBlbyxcbiAgdmlld0NsYXNzTmFtZTogbXMoXCJyZXNpemFibGVcIiksXG4gIGRyYWdDb250cm9sU3RhcnQodCwgZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlucHV0RXZlbnQ6IG4sXG4gICAgICBpc1BpbmNoOiByLFxuICAgICAgaXNHcm91cDogcyxcbiAgICAgIHBhcmVudERpcmVjdGlvbjogbyxcbiAgICAgIHBhcmVudEdlc3RvOiBpLFxuICAgICAgZGF0YXM6IGEsXG4gICAgICBwYXJlbnRGaXhlZERpcmVjdGlvbjogYyxcbiAgICAgIHBhcmVudEV2ZW50OiBsXG4gICAgfSA9IGUsIHUgPSBMaShcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgbixcbiAgICAgIGFcbiAgICApLCBmID0gdC5zdGF0ZSwgeyB0YXJnZXQ6IGQsIHdpZHRoOiBwLCBoZWlnaHQ6IGcsIGdlc3RvczogaCB9ID0gZjtcbiAgICBpZiAoIXUgfHwgIWQgfHwgaC5yZXNpemFibGUpXG4gICAgICByZXR1cm4gITE7XG4gICAgaC5yZXNpemFibGUgPSBpIHx8IHQuY29udHJvbEdlc3RvLCAhciAmJiBSZSh0LCBlKSwgYS5kYXRhcyA9IHt9LCBhLmRpcmVjdGlvbiA9IHUsIGEuc3RhcnRPZmZzZXRXaWR0aCA9IHAsIGEuc3RhcnRPZmZzZXRIZWlnaHQgPSBnLCBhLnByZXZXaWR0aCA9IDAsIGEucHJldkhlaWdodCA9IDAsIGEubWluU2l6ZSA9IFswLCAwXSwgYS5zdGFydFdpZHRoID0gZi5pbmxpbmVDU1NXaWR0aCB8fCBmLmNzc1dpZHRoLCBhLnN0YXJ0SGVpZ2h0ID0gZi5pbmxpbmVDU1NIZWlnaHQgfHwgZi5jc3NIZWlnaHQsIGEubWF4U2l6ZSA9IFsxIC8gMCwgMSAvIDBdLCBzIHx8IChhLm1pblNpemUgPSBbZi5taW5PZmZzZXRXaWR0aCwgZi5taW5PZmZzZXRIZWlnaHRdLCBhLm1heFNpemUgPSBbZi5tYXhPZmZzZXRXaWR0aCwgZi5tYXhPZmZzZXRIZWlnaHRdKTtcbiAgICBjb25zdCB2ID0gdC5wcm9wcy50cmFuc2Zvcm1PcmlnaW4gfHwgXCIlICVcIjtcbiAgICBhLnRyYW5zZm9ybU9yaWdpbiA9IHYgJiYgcmUodikgPyB2LnNwbGl0KFwiIFwiKSA6IHYsIGEuc3RhcnRPZmZzZXRNYXRyaXggPSBmLm9mZnNldE1hdHJpeCwgYS5zdGFydFRyYW5zZm9ybU9yaWdpbiA9IGYudHJhbnNmb3JtT3JpZ2luLCBhLmlzV2lkdGggPSAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5wYXJlbnRJc1dpZHRoKSA/PyAoIXVbMF0gJiYgIXVbMV0gfHwgdVswXSB8fCAhdVsxXSk7XG4gICAgZnVuY3Rpb24gbSh5KSB7XG4gICAgICBhLnJhdGlvID0geSAmJiBpc0Zpbml0ZSh5KSA/IHkgOiAwO1xuICAgIH1cbiAgICBhLnN0YXJ0UG9zaXRpb25zID0ganQodC5zdGF0ZSk7XG4gICAgZnVuY3Rpb24gUyh5KSB7XG4gICAgICBjb25zdCBNID0geWkoXG4gICAgICAgIGEuc3RhcnRQb3NpdGlvbnMsXG4gICAgICAgIHlcbiAgICAgICk7XG4gICAgICBhLmZpeGVkRGlyZWN0aW9uID0gTS5maXhlZERpcmVjdGlvbiwgYS5maXhlZFBvc2l0aW9uID0gTS5maXhlZFBvc2l0aW9uLCBhLmZpeGVkT2Zmc2V0ID0gTS5maXhlZE9mZnNldDtcbiAgICB9XG4gICAgZnVuY3Rpb24geCh5KSB7XG4gICAgICBjb25zdCBNID0gUmkodC5zdGF0ZSwgeSk7XG4gICAgICBhLmZpeGVkRGlyZWN0aW9uID0gTS5maXhlZERpcmVjdGlvbiwgYS5maXhlZFBvc2l0aW9uID0gTS5maXhlZFBvc2l0aW9uLCBhLmZpeGVkT2Zmc2V0ID0gTS5maXhlZE9mZnNldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gQyh5KSB7XG4gICAgICBhLm1pblNpemUgPSBbXG4gICAgICAgIGZ0KGAke3lbMF19YCwgMCkgfHwgMCxcbiAgICAgICAgZnQoYCR7eVsxXX1gLCAwKSB8fCAwXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFKHkpIHtcbiAgICAgIGNvbnN0IE0gPSBbeVswXSB8fCAxIC8gMCwgeVsxXSB8fCAxIC8gMF07XG4gICAgICAoIWFuKE1bMF0pIHx8IGlzRmluaXRlKE1bMF0pKSAmJiAoTVswXSA9IGZ0KGAke01bMF19YCwgMCkgfHwgMSAvIDApLCAoIWFuKE1bMV0pIHx8IGlzRmluaXRlKE1bMV0pKSAmJiAoTVsxXSA9IGZ0KGAke01bMV19YCwgMCkgfHwgMSAvIDApLCBhLm1heFNpemUgPSBNO1xuICAgIH1cbiAgICBtKHAgLyBnKSwgUyhjIHx8IFstdVswXSwgLXVbMV1dKSwgYS5zZXRGaXhlZERpcmVjdGlvbiA9IFMsIGEuc2V0Rml4ZWRQb3NpdGlvbiA9IHgsIGEuc2V0TWluID0gQywgYS5zZXRNYXggPSBFO1xuICAgIGNvbnN0IEQgPSBldCh0LCBlLCB7XG4gICAgICBkaXJlY3Rpb246IHUsXG4gICAgICBzdGFydFJhdGlvOiBhLnJhdGlvLFxuICAgICAgc2V0OiAoW3ksIE1dKSA9PiB7XG4gICAgICAgIGEuc3RhcnRXaWR0aCA9IHksIGEuc3RhcnRIZWlnaHQgPSBNO1xuICAgICAgfSxcbiAgICAgIHNldE1pbjogQyxcbiAgICAgIHNldE1heDogRSxcbiAgICAgIHNldFJhdGlvOiBtLFxuICAgICAgc2V0Rml4ZWREaXJlY3Rpb246IFMsXG4gICAgICBzZXRGaXhlZFBvc2l0aW9uOiB4LFxuICAgICAgc2V0T3JpZ2luOiAoeSkgPT4ge1xuICAgICAgICBhLnRyYW5zZm9ybU9yaWdpbiA9IHk7XG4gICAgICB9LFxuICAgICAgZHJhZ1N0YXJ0OiBPdC5kcmFnU3RhcnQoXG4gICAgICAgIHQsXG4gICAgICAgIG5ldyBGZSgpLmRyYWdTdGFydChbMCwgMF0sIGUpXG4gICAgICApXG4gICAgfSksIFIgPSBsIHx8IGoodCwgXCJvblJlc2l6ZVN0YXJ0XCIsIEQpO1xuICAgIHJldHVybiBhLnN0YXJ0Rml4ZWREaXJlY3Rpb24gPSBhLmZpeGVkRGlyZWN0aW9uLCBhLnN0YXJ0Rml4ZWRQb3NpdGlvbiA9IGEuZml4ZWRQb3NpdGlvbiwgUiAhPT0gITEgJiYgKGEuaXNSZXNpemUgPSAhMCwgdC5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxuICAgICAgZGlyZWN0aW9uOiB1XG4gICAgfSksIGEuaXNSZXNpemUgPyBEIDogITE7XG4gIH0sXG4gIGRyYWdDb250cm9sKHQsIGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhczogbixcbiAgICAgIHBhcmVudEZsYWc6IHIsXG4gICAgICBpc1BpbmNoOiBzLFxuICAgICAgcGFyZW50S2VlcFJhdGlvOiBvLFxuICAgICAgZHJhZ0NsaWVudDogaSxcbiAgICAgIHBhcmVudERpc3Q6IGEsXG4gICAgICB1c2VTbmFwOiBjLFxuICAgICAgaXNSZXF1ZXN0OiBsLFxuICAgICAgaXNHcm91cDogdSxcbiAgICAgIHBhcmVudEV2ZW50OiBmLFxuICAgICAgcmVzb2x2ZU1hdHJpeDogZFxuICAgIH0gPSBlLCB7XG4gICAgICBpc1Jlc2l6ZTogcCxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogZyxcbiAgICAgIHN0YXJ0V2lkdGg6IGgsXG4gICAgICBzdGFydEhlaWdodDogdixcbiAgICAgIHByZXZXaWR0aDogbSxcbiAgICAgIHByZXZIZWlnaHQ6IFMsXG4gICAgICBtaW5TaXplOiB4LFxuICAgICAgbWF4U2l6ZTogQyxcbiAgICAgIHJhdGlvOiBFLFxuICAgICAgc3RhcnRPZmZzZXRXaWR0aDogRCxcbiAgICAgIHN0YXJ0T2Zmc2V0SGVpZ2h0OiBSLFxuICAgICAgaXNXaWR0aDogeVxuICAgIH0gPSBuO1xuICAgIGlmICghcClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZCkge1xuICAgICAgY29uc3QgeyBpczNkOiBzdCB9ID0gdC5zdGF0ZSwgeyBzdGFydE9mZnNldE1hdHJpeDogRnQsIHN0YXJ0VHJhbnNmb3JtT3JpZ2luOiBMdCB9ID0gbiwgdXQgPSBzdCA/IDQgOiAzO1xuICAgICAgbGV0IFN0ID0gbG4oR24oZSkpO1xuICAgICAgY29uc3QgS3QgPSBNYXRoLnNxcnQoU3QubGVuZ3RoKTtcbiAgICAgIHV0ICE9PSBLdCAmJiAoU3QgPSBVdChTdCwgS3QsIHV0KSk7XG4gICAgICBjb25zdCBkZSA9IG1uKFxuICAgICAgICBGdCxcbiAgICAgICAgU3QsXG4gICAgICAgIEx0LFxuICAgICAgICB1dFxuICAgICAgKSwgUGUgPSBNZShcbiAgICAgICAgZGUsXG4gICAgICAgIEQsXG4gICAgICAgIFIsXG4gICAgICAgIHV0XG4gICAgICApO1xuICAgICAgbi5zdGFydFBvc2l0aW9ucyA9IFBlLCBuLm5leHRUYXJnZXRNYXRyaXggPSBTdCwgbi5uZXh0QWxsTWF0cml4ID0gZGU7XG4gICAgfVxuICAgIGNvbnN0IE0gPSBEZSh0LnByb3BzLCBcInJlc2l6YWJsZVwiKSwge1xuICAgICAgcmVzaXplRm9ybWF0OiBQLFxuICAgICAgdGhyb3R0bGVSZXNpemU6IF8gPSByID8gMCA6IDEsXG4gICAgICBwYXJlbnRNb3ZlYWJsZTogTyxcbiAgICAgIGtlZXBSYXRpb0ZpbmFsbHk6IFRcbiAgICB9ID0gTSwgdyA9IG4uZGlyZWN0aW9uO1xuICAgIGxldCBrID0gdywgSSA9IDAsICQgPSAwO1xuICAgICF3WzBdICYmICF3WzFdICYmIChrID0gWzEsIDFdKTtcbiAgICBjb25zdCBHID0gRSAmJiAobyA/PyBNLmtlZXBSYXRpbykgfHwgITE7XG4gICAgZnVuY3Rpb24gTCgpIHtcbiAgICAgIGNvbnN0IHN0ID0gbi5maXhlZERpcmVjdGlvbiwgRnQgPSBYaShrLCBHLCBuLCBlKTtcbiAgICAgIEkgPSBGdC5kaXN0V2lkdGgsICQgPSBGdC5kaXN0SGVpZ2h0O1xuICAgICAgbGV0IEx0ID0ga1swXSAtIHN0WzBdIHx8IEcgPyBNYXRoLm1heChEICsgSSwgQnQpIDogRCwgdXQgPSBrWzFdIC0gc3RbMV0gfHwgRyA/IE1hdGgubWF4KFIgKyAkLCBCdCkgOiBSO1xuICAgICAgcmV0dXJuIEcgJiYgRCAmJiBSICYmICh5ID8gdXQgPSBMdCAvIEUgOiBMdCA9IHV0ICogRSksIFtMdCwgdXRdO1xuICAgIH1cbiAgICBsZXQgW3osIE5dID0gTCgpO1xuICAgIGYgfHwgKG4uc2V0Rml4ZWREaXJlY3Rpb24obi5maXhlZERpcmVjdGlvbiksIGooXG4gICAgICB0LFxuICAgICAgXCJvbkJlZm9yZVJlc2l6ZVwiLFxuICAgICAgZXQoXG4gICAgICAgIHQsXG4gICAgICAgIGUsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGFydEZpeGVkRGlyZWN0aW9uOiBuLnN0YXJ0Rml4ZWREaXJlY3Rpb24sXG4gICAgICAgICAgc3RhcnRGaXhlZFBvc2l0aW9uOiBuLnN0YXJ0Rml4ZWRQb3NpdGlvbixcbiAgICAgICAgICBzZXRGaXhlZERpcmVjdGlvbihzdCkge1xuICAgICAgICAgICAgcmV0dXJuIG4uc2V0Rml4ZWREaXJlY3Rpb24oc3QpLCBbeiwgTl0gPSBMKCksIFt6LCBOXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldEZpeGVkUG9zaXRpb24oc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuLnNldEZpeGVkUG9zaXRpb24oc3QpLCBbeiwgTl0gPSBMKCksIFt6LCBOXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvdW5kaW5nV2lkdGg6IHosXG4gICAgICAgICAgYm91bmRpbmdIZWlnaHQ6IE4sXG4gICAgICAgICAgc2V0U2l6ZShzdCkge1xuICAgICAgICAgICAgW3osIE5dID0gc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAhMFxuICAgICAgKVxuICAgICkpO1xuICAgIGxldCBaID0gaTtcbiAgICBpIHx8ICghciAmJiBzID8gWiA9IFVjKHQsIFswLCAwXSkgOiBaID0gbi5maXhlZFBvc2l0aW9uKTtcbiAgICBsZXQgWSA9IFswLCAwXTtcbiAgICBzIHx8IChZID0gdHUoXG4gICAgICB0LFxuICAgICAgeixcbiAgICAgIE4sXG4gICAgICB3LFxuICAgICAgWixcbiAgICAgICFjICYmIGwsXG4gICAgICBuXG4gICAgKSksIGEgJiYgKCFhWzBdICYmIChZWzBdID0gMCksICFhWzFdICYmIChZWzFdID0gMCkpO1xuICAgIGZ1bmN0aW9uIFcoKSB7XG4gICAgICBQICYmIChbeiwgTl0gPSBQKFtcbiAgICAgICAgeixcbiAgICAgICAgTlxuICAgICAgXSkpLCB6ID0gdHQoeiwgXyksIE4gPSB0dChOLCBfKTtcbiAgICB9XG4gICAgaWYgKEcpIHtcbiAgICAgIGtbMF0gJiYga1sxXSAmJiBZWzBdICYmIFlbMV0gJiYgKEIoWVswXSkgPiBCKFlbMV0pID8gWVsxXSA9IDAgOiBZWzBdID0gMCk7XG4gICAgICBjb25zdCBzdCA9ICFZWzBdICYmICFZWzFdO1xuICAgICAgc3QgJiYgVygpLCBrWzBdICYmICFrWzFdIHx8IFlbMF0gJiYgIVlbMV0gfHwgc3QgJiYgeSA/ICh6ICs9IFlbMF0sIE4gPSB6IC8gRSkgOiAoIWtbMF0gJiYga1sxXSB8fCAhWVswXSAmJiBZWzFdIHx8IHN0ICYmICF5KSAmJiAoTiArPSBZWzFdLCB6ID0gTiAqIEUpO1xuICAgIH0gZWxzZVxuICAgICAgeiArPSBZWzBdLCBOICs9IFlbMV0sIHogPSBNYXRoLm1heCgwLCB6KSwgTiA9IE1hdGgubWF4KDAsIE4pO1xuICAgIFt6LCBOXSA9IHFvKFxuICAgICAgW3osIE5dLFxuICAgICAgeCxcbiAgICAgIEMsXG4gICAgICBHID8gRSA6ICExXG4gICAgKSwgVygpLCBHICYmICh1IHx8IFQpICYmICh5ID8gTiA9IHogLyBFIDogeiA9IE4gKiBFKSwgSSA9IHogLSBELCAkID0gTiAtIFI7XG4gICAgY29uc3QgSiA9IFtJIC0gbSwgJCAtIFNdO1xuICAgIG4ucHJldldpZHRoID0gSSwgbi5wcmV2SGVpZ2h0ID0gJDtcbiAgICBjb25zdCBxID0gcWMoXG4gICAgICB0LFxuICAgICAgeixcbiAgICAgIE4sXG4gICAgICBaLFxuICAgICAgZyxcbiAgICAgIG5cbiAgICApO1xuICAgIGlmICghTyAmJiBKLmV2ZXJ5KChzdCkgPT4gIXN0KSAmJiBxLmV2ZXJ5KChzdCkgPT4gIXN0KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBGID0gT3QuZHJhZyhcbiAgICAgIHQsXG4gICAgICB2bihcbiAgICAgICAgZSxcbiAgICAgICAgdC5zdGF0ZSxcbiAgICAgICAgcSxcbiAgICAgICAgISFzLFxuICAgICAgICAhMSxcbiAgICAgICAgXCJkcmFnZ2FibGVcIlxuICAgICAgKVxuICAgICksIEggPSBGLnRyYW5zZm9ybSwgbnQgPSBoICsgSSwgbHQgPSB2ICsgJCwgdnQgPSBldCh0LCBlLCB7XG4gICAgICB3aWR0aDogbnQsXG4gICAgICBoZWlnaHQ6IGx0LFxuICAgICAgb2Zmc2V0V2lkdGg6IE1hdGgucm91bmQoeiksXG4gICAgICBvZmZzZXRIZWlnaHQ6IE1hdGgucm91bmQoTiksXG4gICAgICBzdGFydFJhdGlvOiBFLFxuICAgICAgYm91bmRpbmdXaWR0aDogeixcbiAgICAgIGJvdW5kaW5nSGVpZ2h0OiBOLFxuICAgICAgZGlyZWN0aW9uOiB3LFxuICAgICAgZGlzdDogW0ksICRdLFxuICAgICAgZGVsdGE6IEosXG4gICAgICBpc1BpbmNoOiAhIXMsXG4gICAgICBkcmFnOiBGLFxuICAgICAgLi4uV2koXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IGAke250fXB4YCxcbiAgICAgICAgICAgIGhlaWdodDogYCR7bHR9cHhgXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2Zvcm06IEhcbiAgICAgICAgfSxcbiAgICAgICAgRixcbiAgICAgICAgZVxuICAgICAgKVxuICAgIH0pO1xuICAgIHJldHVybiAhZiAmJiBqKHQsIFwib25SZXNpemVcIiwgdnQpLCB2dDtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xBZnRlcih0LCBlKSB7XG4gICAgY29uc3QgbiA9IGUuZGF0YXMsIHtcbiAgICAgIGlzUmVzaXplOiByLFxuICAgICAgc3RhcnRPZmZzZXRXaWR0aDogcyxcbiAgICAgIHN0YXJ0T2Zmc2V0SGVpZ2h0OiBvLFxuICAgICAgcHJldldpZHRoOiBpLFxuICAgICAgcHJldkhlaWdodDogYVxuICAgIH0gPSBuO1xuICAgIGlmICghciB8fCB0LnByb3BzLmNoZWNrUmVzaXphYmxlRXJyb3IgPT09ICExKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgd2lkdGg6IGMsIGhlaWdodDogbCB9ID0gdC5zdGF0ZSwgdSA9IGMgLSAocyArIGkpLCBmID0gbCAtIChvICsgYSksIGQgPSBCKHUpID4gMywgcCA9IEIoZikgPiAzO1xuICAgIGlmIChkICYmIChuLnN0YXJ0V2lkdGggKz0gdSwgbi5zdGFydE9mZnNldFdpZHRoICs9IHUsIG4ucHJldldpZHRoICs9IHUpLCBwICYmIChuLnN0YXJ0SGVpZ2h0ICs9IGYsIG4uc3RhcnRPZmZzZXRIZWlnaHQgKz0gZiwgbi5wcmV2SGVpZ2h0ICs9IGYpLCBkIHx8IHApXG4gICAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbCh0LCBlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQodCwgZSkge1xuICAgIGNvbnN0IHsgZGF0YXM6IG4sIHBhcmVudEV2ZW50OiByIH0gPSBlO1xuICAgIGlmICghbi5pc1Jlc2l6ZSlcbiAgICAgIHJldHVybjtcbiAgICBuLmlzUmVzaXplID0gITE7XG4gICAgY29uc3QgcyA9ICR0KHQsIGUsIHt9KTtcbiAgICByZXR1cm4gIXIgJiYgaih0LCBcIm9uUmVzaXplRW5kXCIsIHMpLCBzO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sQ29uZGl0aW9uOiBlbyxcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0KHQsIGUpIHtcbiAgICBjb25zdCB7IGRhdGFzOiBuIH0gPSBlLCByID0gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KHQsIHsgLi4uZSwgaXNHcm91cDogITAgfSk7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHMgPSBIdCh0LCBcInJlc2l6YWJsZVwiLCBlKSwge1xuICAgICAgc3RhcnRPZmZzZXRXaWR0aDogbyxcbiAgICAgIHN0YXJ0T2Zmc2V0SGVpZ2h0OiBpXG4gICAgfSA9IG47XG4gICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgIGNvbnN0IHAgPSBuLm1pblNpemU7XG4gICAgICBzLmZvckVhY2goKGcpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1pblNpemU6IGgsXG4gICAgICAgICAgc3RhcnRPZmZzZXRXaWR0aDogdixcbiAgICAgICAgICBzdGFydE9mZnNldEhlaWdodDogbVxuICAgICAgICB9ID0gZy5kYXRhcywgUyA9IG8gKiAodiA/IGhbMF0gLyB2IDogMCksIHggPSBpICogKG0gPyBoWzFdIC8gbSA6IDApO1xuICAgICAgICBwWzBdID0gTWF0aC5tYXgocFswXSwgUyksIHBbMV0gPSBNYXRoLm1heChwWzFdLCB4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjKCkge1xuICAgICAgY29uc3QgcCA9IG4ubWF4U2l6ZTtcbiAgICAgIHMuZm9yRWFjaCgoZykgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWF4U2l6ZTogaCxcbiAgICAgICAgICBzdGFydE9mZnNldFdpZHRoOiB2LFxuICAgICAgICAgIHN0YXJ0T2Zmc2V0SGVpZ2h0OiBtXG4gICAgICAgIH0gPSBnLmRhdGFzLCBTID0gbyAqICh2ID8gaFswXSAvIHYgOiAwKSwgeCA9IGkgKiAobSA/IGhbMV0gLyBtIDogMCk7XG4gICAgICAgIHBbMF0gPSBNYXRoLm1pbihwWzBdLCBTKSwgcFsxXSA9IE1hdGgubWluKHBbMV0sIHgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGwgPSBlZShcbiAgICAgIHQsXG4gICAgICB0aGlzLFxuICAgICAgXCJkcmFnQ29udHJvbFN0YXJ0XCIsXG4gICAgICBlLFxuICAgICAgKHAsIGcpID0+IGtuKHQsIHAsIG4sIGcpXG4gICAgKTtcbiAgICBhKCksIGMoKTtcbiAgICBjb25zdCB1ID0gKHApID0+IHtcbiAgICAgIHIuc2V0Rml4ZWREaXJlY3Rpb24ocCksIGwuZm9yRWFjaCgoZywgaCkgPT4ge1xuICAgICAgICBnLnNldEZpeGVkRGlyZWN0aW9uKHApLCBrbih0LCBnLm1vdmVhYmxlLCBuLCBzW2hdKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgbi5zZXRGaXhlZERpcmVjdGlvbiA9IHU7XG4gICAgY29uc3QgZiA9IHtcbiAgICAgIC4uLnIsXG4gICAgICB0YXJnZXRzOiB0LnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGwubWFwKChwKSA9PiAoe1xuICAgICAgICAuLi5wLFxuICAgICAgICBzZXRNaW46IChnKSA9PiB7XG4gICAgICAgICAgcC5zZXRNaW4oZyksIGEoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWF4OiAoZykgPT4ge1xuICAgICAgICAgIHAuc2V0TWF4KGcpLCBjKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKSxcbiAgICAgIHNldEZpeGVkRGlyZWN0aW9uOiB1LFxuICAgICAgc2V0TWluOiAocCkgPT4ge1xuICAgICAgICByLnNldE1pbihwKSwgYSgpO1xuICAgICAgfSxcbiAgICAgIHNldE1heDogKHApID0+IHtcbiAgICAgICAgci5zZXRNYXgocCksIGMoKTtcbiAgICAgIH1cbiAgICB9LCBkID0gaih0LCBcIm9uUmVzaXplR3JvdXBTdGFydFwiLCBmKTtcbiAgICByZXR1cm4gbi5pc1Jlc2l6ZSA9IGQgIT09ICExLCBuLmlzUmVzaXplID8gciA6ICExO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sKHQsIGUpIHtcbiAgICBjb25zdCB7IGRhdGFzOiBuIH0gPSBlO1xuICAgIGlmICghbi5pc1Jlc2l6ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gRGUodC5wcm9wcywgXCJyZXNpemFibGVcIik7XG4gICAgUW4odCwgXCJvbkJlZm9yZVJlc2l6ZVwiLCAocCkgPT4ge1xuICAgICAgaihcbiAgICAgICAgdCxcbiAgICAgICAgXCJvbkJlZm9yZVJlc2l6ZUdyb3VwXCIsXG4gICAgICAgIGV0KFxuICAgICAgICAgIHQsXG4gICAgICAgICAgZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgdGFyZ2V0czogci50YXJnZXRzXG4gICAgICAgICAgfSxcbiAgICAgICAgICAhMFxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICAgIGNvbnN0IHMgPSB0aGlzLmRyYWdDb250cm9sKHQsIHsgLi4uZSwgaXNHcm91cDogITAgfSk7XG4gICAgaWYgKCFzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgYm91bmRpbmdXaWR0aDogbywgYm91bmRpbmdIZWlnaHQ6IGksIGRpc3Q6IGEgfSA9IHMsIGMgPSByLmtlZXBSYXRpbywgbCA9IFtcbiAgICAgIG8gLyAobyAtIGFbMF0pLFxuICAgICAgaSAvIChpIC0gYVsxXSlcbiAgICBdLCB1ID0gbi5maXhlZFBvc2l0aW9uLCBmID0gZWUoXG4gICAgICB0LFxuICAgICAgdGhpcyxcbiAgICAgIFwiZHJhZ0NvbnRyb2xcIixcbiAgICAgIGUsXG4gICAgICAocCwgZykgPT4ge1xuICAgICAgICBjb25zdCBbaCwgdl0gPSBfdChcbiAgICAgICAgICBobih0LnJvdGF0aW9uIC8gMTgwICogTWF0aC5QSSwgMyksXG4gICAgICAgICAgW1xuICAgICAgICAgICAgZy5kYXRhcy5vcmlnaW5hbFggKiBsWzBdLFxuICAgICAgICAgICAgZy5kYXRhcy5vcmlnaW5hbFkgKiBsWzFdLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIF0sXG4gICAgICAgICAgM1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmcsXG4gICAgICAgICAgcGFyZW50RGlzdDogbnVsbCxcbiAgICAgICAgICBwYXJlbnRTY2FsZTogbCxcbiAgICAgICAgICBkcmFnQ2xpZW50OiBhdCh1LCBbaCwgdl0pLFxuICAgICAgICAgIHBhcmVudEtlZXBSYXRpbzogY1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICksIGQgPSB7XG4gICAgICB0YXJnZXRzOiByLnRhcmdldHMsXG4gICAgICBldmVudHM6IGYsXG4gICAgICAuLi5zXG4gICAgfTtcbiAgICByZXR1cm4gaih0LCBcIm9uUmVzaXplR3JvdXBcIiwgZCksIGQ7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xFbmQodCwgZSkge1xuICAgIGNvbnN0IHsgaXNEcmFnOiBuLCBkYXRhczogciB9ID0gZTtcbiAgICBpZiAoIXIuaXNSZXNpemUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kcmFnQ29udHJvbEVuZCh0LCBlKTtcbiAgICBjb25zdCBzID0gZWUodCwgdGhpcywgXCJkcmFnQ29udHJvbEVuZFwiLCBlKSwgbyA9ICR0KFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICB7XG4gICAgICAgIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyxcbiAgICAgICAgZXZlbnRzOiBzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gaih0LCBcIm9uUmVzaXplR3JvdXBFbmRcIiwgbyksIG47XG4gIH0sXG4gIC8qKlxuICAgICAgICogQG1ldGhvZCBNb3ZlYWJsZS5SZXNpemFibGUjcmVxdWVzdFxuICAgICAgICogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUuUmVzaXphYmxlUmVxdWVzdFBhcmFtfSBlIC0gdGhlIFJlc2l6YWJsZSdzIHJlcXVlc3QgcGFyYW1ldGVyXG4gICAgICAgKiBAcmV0dXJuIHtNb3ZlYWJsZS5SZXF1ZXN0ZXJ9IE1vdmVhYmxlIFJlcXVlc3RlclxuICAgICAgICogQGV4YW1wbGVcbiAgXG4gICAgICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXG4gICAgICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcbiAgICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0sIHRydWUpO1xuICAgICAgICpcbiAgICAgICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxuICAgICAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IG9mZnNldFdpZHRoOiAxMDAsIG9mZnNldEhlaWdodDogMTAwIH0sIHRydWUpO1xuICAgICAgICpcbiAgICAgICAqIC8vIHJlcXVlc3RTdGFydFxuICAgICAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiKTtcbiAgICAgICAqXG4gICAgICAgKiAvLyByZXF1ZXN0XG4gICAgICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcbiAgICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcbiAgICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcbiAgICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcbiAgICAgICAqXG4gICAgICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcbiAgICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBvZmZzZXRXaWR0aDogMTAwLCBvZmZzZXRIZWlnaHQ6IDEwMCB9KTtcbiAgICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBvZmZzZXRXaWR0aDogMTEwLCBvZmZzZXRIZWlnaHQ6IDEwMCB9KTtcbiAgICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBvZmZzZXRXaWR0aDogMTIwLCBvZmZzZXRIZWlnaHQ6IDEwMCB9KTtcbiAgICAgICAqXG4gICAgICAgKiAvLyByZXF1ZXN0RW5kXG4gICAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdEVuZCgpO1xuICAgICAgICovXG4gIHJlcXVlc3QodCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICBsZXQgbiA9IDAsIHIgPSAwLCBzID0gITE7XG4gICAgY29uc3QgbyA9IHQuZ2V0UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICBpc0NvbnRyb2w6ICEwLFxuICAgICAgcmVxdWVzdFN0YXJ0KGkpIHtcbiAgICAgICAgcmV0dXJuIHMgPSBpLnVzZVNuYXAsIHtcbiAgICAgICAgICBkYXRhczogZSxcbiAgICAgICAgICBwYXJlbnREaXJlY3Rpb246IGkuZGlyZWN0aW9uIHx8IFsxLCAxXSxcbiAgICAgICAgICBwYXJlbnRJc1dpZHRoOiAoaSA9PSBudWxsID8gdm9pZCAwIDogaS5ob3Jpem9udGFsKSA/PyAhMCxcbiAgICAgICAgICB1c2VTbmFwOiBzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdChpKSB7XG4gICAgICAgIHJldHVybiBcIm9mZnNldFdpZHRoXCIgaW4gaSA/IG4gPSBpLm9mZnNldFdpZHRoIC0gby5vZmZzZXRXaWR0aCA6IFwiZGVsdGFXaWR0aFwiIGluIGkgJiYgKG4gKz0gaS5kZWx0YVdpZHRoKSwgXCJvZmZzZXRIZWlnaHRcIiBpbiBpID8gciA9IGkub2Zmc2V0SGVpZ2h0IC0gby5vZmZzZXRIZWlnaHQgOiBcImRlbHRhSGVpZ2h0XCIgaW4gaSAmJiAociArPSBpLmRlbHRhSGVpZ2h0KSwge1xuICAgICAgICAgIGRhdGFzOiBlLFxuICAgICAgICAgIHBhcmVudERpc3Q6IFtuLCByXSxcbiAgICAgICAgICBwYXJlbnRLZWVwUmF0aW86IGkua2VlcFJhdGlvLFxuICAgICAgICAgIHVzZVNuYXA6IHNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0RW5kKCkge1xuICAgICAgICByZXR1cm4geyBkYXRhczogZSwgaXNEcmFnOiAhMCwgdXNlU25hcDogcyB9O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHVuc2V0KHQpIHtcbiAgICB0LnN0YXRlLmdlc3Rvcy5yZXNpemFibGUgPSBudWxsO1xuICB9XG59O1xuZnVuY3Rpb24gbHIodCwgZSwgbiwgciwgcykge1xuICBjb25zdCBvID0gdC5wcm9wcy5ncm91cGFibGUsIGkgPSB0LnN0YXRlLCBhID0gaS5pczNkID8gNCA6IDMsIGMgPSBlLm9yaWdpbiwgbCA9IGh0KFxuICAgIHQuc3RhdGUucm9vdE1hdHJpeCxcbiAgICAvLyBUTy1ETyAjNzEwXG4gICAgSyhbY1swXSwgY1sxXV0sIG8gPyBbMCwgMF0gOiBbaS5sZWZ0LCBpLnRvcF0pLFxuICAgIGFcbiAgKSwgdSA9IGF0KFtzLmxlZnQsIHMudG9wXSwgbCk7XG4gIGUuc3RhcnRBYnNvbHV0ZU9yaWdpbiA9IHUsIGUucHJldkRlZyA9IHh0KHUsIFtuLCByXSkgLyBNYXRoLlBJICogMTgwLCBlLmRlZmF1bHREZWcgPSBlLnByZXZEZWcsIGUucHJldlNuYXBEZWcgPSAwLCBlLmxvb3AgPSAwLCBlLnN0YXJ0RGlzdCA9IHRlKHUsIFtuLCByXSk7XG59XG5mdW5jdGlvbiBJbih0LCBlLCBuKSB7XG4gIGNvbnN0IHsgZGVmYXVsdERlZzogciwgcHJldkRlZzogcyB9ID0gbjtcbiAgbGV0IG8gPSBzICUgMzYwLCBpID0gTWF0aC5mbG9vcihzIC8gMzYwKTtcbiAgbyA8IDAgJiYgKG8gKz0gMzYwKSwgbyA+IHQgJiYgbyA+IDI3MCAmJiB0IDwgOTAgPyArK2kgOiBvIDwgdCAmJiBvIDwgOTAgJiYgdCA+IDI3MCAmJiAtLWk7XG4gIGNvbnN0IGEgPSBlICogKGkgKiAzNjAgKyB0IC0gcik7XG4gIHJldHVybiBuLnByZXZEZWcgPSByICsgYSwgYTtcbn1cbmZ1bmN0aW9uIHVyKHQsIGUsIG4sIHIpIHtcbiAgcmV0dXJuIEluKFxuICAgIHh0KHIuc3RhcnRBYnNvbHV0ZU9yaWdpbiwgW3QsIGVdKSAvIE1hdGguUEkgKiAxODAsXG4gICAgbixcbiAgICByXG4gICk7XG59XG5mdW5jdGlvbiBmcih0LCBlLCBuLCByLCBzLCBvKSB7XG4gIGNvbnN0IHsgdGhyb3R0bGVSb3RhdGU6IGkgPSAwIH0gPSB0LnByb3BzLCBhID0gbi5wcmV2U25hcERlZztcbiAgbGV0IGMgPSAwLCBsID0gITE7XG4gIGlmIChvKSB7XG4gICAgY29uc3QgZiA9IFFsKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICByLFxuICAgICAgcyArIHJcbiAgICApO1xuICAgIGwgPSBmLmlzU25hcCwgYyA9IHMgKyBmLmRpc3Q7XG4gIH1cbiAgbCB8fCAoYyA9IHR0KHMgKyByLCBpKSk7XG4gIGNvbnN0IHUgPSBjIC0gcztcbiAgcmV0dXJuIG4ucHJldlNuYXBEZWcgPSB1LCBbdSAtIGEsIHUsIGNdO1xufVxuZnVuY3Rpb24gTWkodCwgW2UsIG4sIHIsIHNdLCBvKSB7XG4gIGlmICh0ID09PSBcIm5vbmVcIilcbiAgICByZXR1cm4gW107XG4gIGlmIChSdCh0KSlcbiAgICByZXR1cm4gdC5tYXAoXG4gICAgICAoZikgPT4gTWkoZiwgW2UsIG4sIHIsIHNdLCBvKVswXVxuICAgICk7XG4gIGNvbnN0IFtpLCBhXSA9ICh0IHx8IFwidG9wXCIpLnNwbGl0KFwiLVwiKTtcbiAgbGV0IGMgPSBbZSwgbl07XG4gIGkgPT09IFwibGVmdFwiID8gYyA9IFtyLCBlXSA6IGkgPT09IFwicmlnaHRcIiA/IGMgPSBbbiwgc10gOiBpID09PSBcImJvdHRvbVwiICYmIChjID0gW3MsIHJdKTtcbiAgbGV0IGwgPSBbXG4gICAgKGNbMF1bMF0gKyBjWzFdWzBdKSAvIDIsXG4gICAgKGNbMF1bMV0gKyBjWzFdWzFdKSAvIDJcbiAgXTtcbiAgY29uc3QgdSA9ICRpKGMsIG8pO1xuICBpZiAoYSkge1xuICAgIGNvbnN0IGYgPSBhID09PSBcInRvcFwiIHx8IGEgPT09IFwibGVmdFwiLCBkID0gaSA9PT0gXCJib3R0b21cIiB8fCBpID09PSBcImxlZnRcIjtcbiAgICBsID0gY1tmICYmICFkIHx8ICFmICYmIGQgPyAwIDogMV07XG4gIH1cbiAgcmV0dXJuIFtbbCwgdV1dO1xufVxuZnVuY3Rpb24gT3IodCwgZSkge1xuICBpZiAoZS5pc1JlcXVlc3QpXG4gICAgcmV0dXJuIGUucmVxdWVzdEFibGUgPT09IFwicm90YXRhYmxlXCI7XG4gIGNvbnN0IG4gPSBlLmlucHV0RXZlbnQudGFyZ2V0O1xuICBpZiAoYnQobiwgVShcInJvdGF0aW9uLWNvbnRyb2xcIikpIHx8IHQucHJvcHMucm90YXRlQXJvdW5kQ29udHJvbHMgJiYgYnQobiwgVShcImFyb3VuZC1jb250cm9sXCIpKSB8fCBidChuLCBVKFwiY29udHJvbFwiKSkgJiYgYnQobiwgVShcInJvdGF0YWJsZVwiKSkpXG4gICAgcmV0dXJuICEwO1xuICBjb25zdCByID0gdC5wcm9wcy5yb3RhdGlvblRhcmdldDtcbiAgcmV0dXJuIHIgPyBTcyhyLCAhMCkuc29tZSgocykgPT4gcyA/IG4gPT09IHMgfHwgbi5jb250YWlucyhzKSA6ICExKSA6ICExO1xufVxuY29uc3QgT2wgPSBgLnJvdGF0aW9uIHtcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcbmhlaWdodDogNDBweDtcbndpZHRoOiAxcHg7XG50cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMTAwJTtcbmhlaWdodDogY2FsYyg0MHB4ICogdmFyKC0tem9vbSkpO1xudG9wOiBhdXRvO1xubGVmdDogMDtcbmJvdHRvbTogMTAwJTtcbndpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG59XG4ucm90YXRpb24gLnJvdGF0aW9uLWxpbmUge1xuZGlzcGxheTogYmxvY2s7XG53aWR0aDogMTAwJTtcbmhlaWdodDogMTAwJTtcbnRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XG59XG4ucm90YXRpb24gLnJvdGF0aW9uLWNvbnRyb2wge1xuYm9yZGVyLWNvbG9yOiAjNGFmO1xuYm9yZGVyLWNvbG9yOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XG5iYWNrZ3JvdW5kOiNmZmY7XG5jdXJzb3I6IGFsaWFzO1xufVxuOmdsb2JhbCAudmlldy1yb3RhdGlvbi1kcmFnZ2luZywgLnJvdGF0YWJsZS5kaXJlY3Rpb24uY29udHJvbCB7XG5jdXJzb3I6IGFsaWFzO1xufVxuLnJvdGF0YWJsZS5kaXJlY3Rpb24uY29udHJvbC5tb3ZlIHtcbmN1cnNvcjogbW92ZTtcbn1cbmAsIHdsID0ge1xuICBuYW1lOiBcInJvdGF0YWJsZVwiLFxuICBjYW5QaW5jaDogITAsXG4gIHByb3BzOiBbXG4gICAgXCJyb3RhdGFibGVcIixcbiAgICBcInJvdGF0aW9uUG9zaXRpb25cIixcbiAgICBcInRocm90dGxlUm90YXRlXCIsXG4gICAgXCJyZW5kZXJEaXJlY3Rpb25zXCIsXG4gICAgXCJyb3RhdGlvblRhcmdldFwiLFxuICAgIFwicm90YXRlQXJvdW5kQ29udHJvbHNcIixcbiAgICBcImVkZ2VcIixcbiAgICBcInJlc29sdmVBYmxlc1dpdGhSb3RhdGFibGVcIixcbiAgICBcImRpc3BsYXlBcm91bmRDb250cm9sc1wiXG4gIF0sXG4gIGV2ZW50czogW1xuICAgIFwicm90YXRlU3RhcnRcIixcbiAgICBcImJlZm9yZVJvdGF0ZVwiLFxuICAgIFwicm90YXRlXCIsXG4gICAgXCJyb3RhdGVFbmRcIixcbiAgICBcInJvdGF0ZUdyb3VwU3RhcnRcIixcbiAgICBcImJlZm9yZVJvdGF0ZUdyb3VwXCIsXG4gICAgXCJyb3RhdGVHcm91cFwiLFxuICAgIFwicm90YXRlR3JvdXBFbmRcIlxuICBdLFxuICBjc3M6IFtPbF0sXG4gIHZpZXdDbGFzc05hbWUodCkge1xuICAgIHJldHVybiB0LmlzRHJhZ2dpbmcoXCJyb3RhdGFibGVcIikgPyBVKFwidmlldy1yb3RhdGlvbi1kcmFnZ2luZ1wiKSA6IFwiXCI7XG4gIH0sXG4gIHJlbmRlcih0LCBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRhYmxlOiBuLFxuICAgICAgcm90YXRpb25Qb3NpdGlvbjogcixcbiAgICAgIHpvb206IHMsXG4gICAgICByZW5kZXJEaXJlY3Rpb25zOiBvLFxuICAgICAgcm90YXRlQXJvdW5kQ29udHJvbHM6IGksXG4gICAgICByZXNvbHZlQWJsZXNXaXRoUm90YXRhYmxlOiBhXG4gICAgfSA9IERlKHQucHJvcHMsIFwicm90YXRhYmxlXCIpLCB7IHJlbmRlclBvc2VzOiBjLCBkaXJlY3Rpb246IGwgfSA9IHQuZ2V0U3RhdGUoKTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB1ID0gTWkoXG4gICAgICByLFxuICAgICAgYyxcbiAgICAgIGxcbiAgICApLCBmID0gW107XG4gICAgaWYgKHUuZm9yRWFjaCgoW2QsIHBdLCBnKSA9PiB7XG4gICAgICBmLnB1c2goXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpdC5qc3hzKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBVKFwicm90YXRpb25cIiksXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG1heC1saW5lLWxlbmd0aFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoLTUwJSkgdHJhbnNsYXRlKCR7ZFswXX1weCwgJHtkWzFdfXB4KSByb3RhdGUoJHtwfXJhZClgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogVShcImxpbmUgcm90YXRpb24tbGluZVwiKSxcbiAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHNjYWxlWCgke3N9KWBcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpdC5qc3goXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFUoXCJjb250cm9sIHJvdGF0aW9uLWNvbnRyb2xcIiksXG4gICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoMC41cHgpIHNjYWxlKCR7c30pYFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYHJvdGF0aW9uJHtnfWBcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KSwgbykge1xuICAgICAgY29uc3QgZCA9IFZlKGEgfHwge30pLCBwID0ge307XG4gICAgICBkLmZvckVhY2goKGgpID0+IHtcbiAgICAgICAgYVtoXS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgcFt2XSA9IGg7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBsZXQgZyA9IFtdO1xuICAgICAgUnQobykgJiYgKGcgPSBvLm1hcCgoaCkgPT4ge1xuICAgICAgICBjb25zdCB2ID0gcFtoXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB2ID8geyByZXNvbHZlOiB2IH0gOiB7fSxcbiAgICAgICAgICBjbGFzc05hbWVzOiB2ID8gW1wibW92ZVwiXSA6IFtdLFxuICAgICAgICAgIGRpcjogaFxuICAgICAgICB9O1xuICAgICAgfSkpLCBmLnB1c2goXG4gICAgICAgIC4uLmxpKFxuICAgICAgICAgIHQsXG4gICAgICAgICAgXCJyb3RhdGFibGVcIixcbiAgICAgICAgICBnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBpICYmIGYucHVzaCguLi5naSh0KSksIGY7XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBPcixcbiAgZHJhZ0NvbnRyb2xTdGFydCh0LCBlKSB7XG4gICAgdmFyIGs7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YXM6IG4sXG4gICAgICBjbGllbnRYOiByLFxuICAgICAgY2xpZW50WTogcyxcbiAgICAgIHBhcmVudFJvdGF0ZTogbyxcbiAgICAgIHBhcmVudEZsYWc6IGksXG4gICAgICBpc1BpbmNoOiBhLFxuICAgICAgaXNSZXF1ZXN0OiBjXG4gICAgfSA9IGUsIGwgPSB0LnN0YXRlLCB7XG4gICAgICB0YXJnZXQ6IHUsXG4gICAgICBsZWZ0OiBmLFxuICAgICAgdG9wOiBkLFxuICAgICAgZGlyZWN0aW9uOiBwLFxuICAgICAgYmVmb3JlRGlyZWN0aW9uOiBnLFxuICAgICAgdGFyZ2V0VHJhbnNmb3JtOiBoLFxuICAgICAgbW92ZWFibGVDbGllbnRSZWN0OiB2LFxuICAgICAgb2Zmc2V0TWF0cml4OiBtLFxuICAgICAgdGFyZ2V0TWF0cml4OiBTLFxuICAgICAgYWxsTWF0cml4OiB4LFxuICAgICAgd2lkdGg6IEMsXG4gICAgICBoZWlnaHQ6IEVcbiAgICB9ID0gbDtcbiAgICBpZiAoIWMgJiYgIXUpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgRCA9IHQuZ2V0UmVjdCgpO1xuICAgIG4ucmVjdCA9IEQsIG4udHJhbnNmb3JtID0gaCwgbi5sZWZ0ID0gZiwgbi50b3AgPSBkO1xuICAgIGxldCBSID0gKEkpID0+IHtcbiAgICAgIGNvbnN0ICQgPSBSaSh0LnN0YXRlLCBJKTtcbiAgICAgIG4uZml4ZWREaXJlY3Rpb24gPSAkLmZpeGVkRGlyZWN0aW9uLCBuLmZpeGVkT2Zmc2V0ID0gJC5maXhlZE9mZnNldCwgbi5maXhlZFBvc2l0aW9uID0gJC5maXhlZFBvc2l0aW9uLCBPICYmIE8uc2V0Rml4ZWRQb3NpdGlvbihJKTtcbiAgICB9LCB5ID0gKEkpID0+IHtcbiAgICAgIGNvbnN0ICQgPSBUbChcbiAgICAgICAgdC5zdGF0ZSxcbiAgICAgICAgSVxuICAgICAgKTtcbiAgICAgIG4uZml4ZWREaXJlY3Rpb24gPSAkLmZpeGVkRGlyZWN0aW9uLCBuLmZpeGVkT2Zmc2V0ID0gJC5maXhlZE9mZnNldCwgbi5maXhlZFBvc2l0aW9uID0gJC5maXhlZFBvc2l0aW9uLCBPICYmIE8uc2V0Rml4ZWREaXJlY3Rpb24oSSk7XG4gICAgfSwgTSA9IHIsIFAgPSBzO1xuICAgIGlmIChjIHx8IGEgfHwgaSkge1xuICAgICAgY29uc3QgSSA9IG8gfHwgMDtcbiAgICAgIG4uYmVmb3JlSW5mbyA9IHtcbiAgICAgICAgb3JpZ2luOiBELmJlZm9yZU9yaWdpbixcbiAgICAgICAgcHJldkRlZzogSSxcbiAgICAgICAgZGVmYXVsdERlZzogSSxcbiAgICAgICAgcHJldlNuYXBEZWc6IDAsXG4gICAgICAgIHN0YXJ0RGlzdDogMFxuICAgICAgfSwgbi5hZnRlckluZm8gPSB7XG4gICAgICAgIC4uLm4uYmVmb3JlSW5mbyxcbiAgICAgICAgb3JpZ2luOiBELm9yaWdpblxuICAgICAgfSwgbi5hYnNvbHV0ZUluZm8gPSB7XG4gICAgICAgIC4uLm4uYmVmb3JlSW5mbyxcbiAgICAgICAgb3JpZ2luOiBELm9yaWdpbixcbiAgICAgICAgc3RhcnRWYWx1ZTogSVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgSSA9IChrID0gZS5pbnB1dEV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogay50YXJnZXQ7XG4gICAgICBpZiAoSSkge1xuICAgICAgICBjb25zdCBHID0gSS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRpcmVjdGlvblwiKSB8fCBcIlwiLCBMID0gYWNbR107XG4gICAgICAgIGlmIChMKSB7XG4gICAgICAgICAgbi5pc0NvbnRyb2wgPSAhMCwgbi5pc0Fyb3VuZENvbnRyb2wgPSBidChcbiAgICAgICAgICAgIEksXG4gICAgICAgICAgICBVKFwiYXJvdW5kLWNvbnRyb2xcIilcbiAgICAgICAgICApLCBuLmNvbnRyb2xEaXJlY3Rpb24gPSBMO1xuICAgICAgICAgIGNvbnN0IHogPSBJLmdldEF0dHJpYnV0ZShcImRhdGEtcmVzb2x2ZVwiKTtcbiAgICAgICAgICB6ICYmIChuLnJlc29sdmVBYmxlID0geik7XG4gICAgICAgICAgY29uc3QgTiA9IGh1KFxuICAgICAgICAgICAgbC5yb290TWF0cml4LFxuICAgICAgICAgICAgbC5yZW5kZXJQb3NlcyxcbiAgICAgICAgICAgIHZcbiAgICAgICAgICApO1xuICAgICAgICAgIFtNLCBQXSA9IHl0KFxuICAgICAgICAgICAgTixcbiAgICAgICAgICAgIExcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuLmJlZm9yZUluZm8gPSB7IG9yaWdpbjogRC5iZWZvcmVPcmlnaW4gfSwgbi5hZnRlckluZm8gPSB7IG9yaWdpbjogRC5vcmlnaW4gfSwgbi5hYnNvbHV0ZUluZm8gPSB7XG4gICAgICAgIG9yaWdpbjogRC5vcmlnaW4sXG4gICAgICAgIHN0YXJ0VmFsdWU6IEQucm90YXRpb25cbiAgICAgIH07XG4gICAgICBjb25zdCAkID0gUjtcbiAgICAgIFIgPSAoRykgPT4ge1xuICAgICAgICBjb25zdCBMID0gbC5pczNkID8gNCA6IDMsIFt6LCBOXSA9IGF0KFxuICAgICAgICAgIHRpKFMsIEwpLFxuICAgICAgICAgIEdcbiAgICAgICAgKSwgWiA9IF90KFxuICAgICAgICAgIG0sXG4gICAgICAgICAgRWUoW3osIE5dLCBMKVxuICAgICAgICApLCBZID0gX3QoXG4gICAgICAgICAgeCxcbiAgICAgICAgICBFZShbR1swXSwgR1sxXV0sIEwpXG4gICAgICAgICk7XG4gICAgICAgICQoRyk7XG4gICAgICAgIGNvbnN0IFcgPSBsLnBvc0RlbHRhO1xuICAgICAgICBuLmJlZm9yZUluZm8ub3JpZ2luID0gSyhaLCBXKSwgbi5hZnRlckluZm8ub3JpZ2luID0gSyhZLCBXKSwgbi5hYnNvbHV0ZUluZm8ub3JpZ2luID0gSyhZLCBXKSwgbHIoXG4gICAgICAgICAgdCxcbiAgICAgICAgICBuLmJlZm9yZUluZm8sXG4gICAgICAgICAgTSxcbiAgICAgICAgICBQLFxuICAgICAgICAgIHZcbiAgICAgICAgKSwgbHIoXG4gICAgICAgICAgdCxcbiAgICAgICAgICBuLmFmdGVySW5mbyxcbiAgICAgICAgICBNLFxuICAgICAgICAgIFAsXG4gICAgICAgICAgdlxuICAgICAgICApLCBscihcbiAgICAgICAgICB0LFxuICAgICAgICAgIG4uYWJzb2x1dGVJbmZvLFxuICAgICAgICAgIE0sXG4gICAgICAgICAgUCxcbiAgICAgICAgICB2XG4gICAgICAgICk7XG4gICAgICB9LCB5ID0gKEcpID0+IHtcbiAgICAgICAgY29uc3QgTCA9IHl0KFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICAgIFtDLCAwXSxcbiAgICAgICAgICAgIFswLCBFXSxcbiAgICAgICAgICAgIFtDLCBFXVxuICAgICAgICAgIF0sXG4gICAgICAgICAgR1xuICAgICAgICApO1xuICAgICAgICBSKEwpO1xuICAgICAgfTtcbiAgICB9XG4gICAgbi5zdGFydENsaWVudFggPSBNLCBuLnN0YXJ0Q2xpZW50WSA9IFAsIG4uZGlyZWN0aW9uID0gcCwgbi5iZWZvcmVEaXJlY3Rpb24gPSBnLCBuLnN0YXJ0VmFsdWUgPSAwLCBuLmRhdGFzID0ge30sIHFuKHQsIGUsIFwicm90YXRlXCIpO1xuICAgIGxldCBfID0gITEsIE8gPSAhMTtcbiAgICBuLmlzQ29udHJvbCAmJiBuLnJlc29sdmVBYmxlICYmIG4ucmVzb2x2ZUFibGUgPT09IFwicmVzaXphYmxlXCIgJiYgKE8gPSBUci5kcmFnQ29udHJvbFN0YXJ0KHQsIHtcbiAgICAgIC4uLm5ldyBGZShcInJlc2l6YWJsZVwiKS5kcmFnU3RhcnQoWzAsIDBdLCBlKSxcbiAgICAgIHBhcmVudFBvc2l0aW9uOiBuLmNvbnRyb2xQb3NpdGlvbixcbiAgICAgIHBhcmVudEZpeGVkUG9zaXRpb246IG4uZml4ZWRQb3NpdGlvblxuICAgIH0pKSwgTyB8fCAoXyA9IE90LmRyYWdTdGFydChcbiAgICAgIHQsXG4gICAgICBuZXcgRmUoKS5kcmFnU3RhcnQoWzAsIDBdLCBlKVxuICAgICkpLCBSKHZ1KHQpKTtcbiAgICBjb25zdCBUID0gZXQodCwgZSwge1xuICAgICAgc2V0OiAoSSkgPT4ge1xuICAgICAgICBuLnN0YXJ0VmFsdWUgPSBJICogTWF0aC5QSSAvIDE4MDtcbiAgICAgIH0sXG4gICAgICBzZXRGaXhlZERpcmVjdGlvbjogeSxcbiAgICAgIHNldEZpeGVkUG9zaXRpb246IFIsXG4gICAgICAuLi5Ibih0LCBlKSxcbiAgICAgIGRyYWdTdGFydDogXyxcbiAgICAgIHJlc2l6ZVN0YXJ0OiBPXG4gICAgfSksIHcgPSBqKHQsIFwib25Sb3RhdGVTdGFydFwiLCBUKTtcbiAgICByZXR1cm4gbi5pc1JvdGF0ZSA9IHcgIT09ICExLCBsLnNuYXBSZW5kZXJJbmZvID0ge1xuICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3RcbiAgICB9LCBuLmlzUm90YXRlID8gVCA6ICExO1xuICB9LFxuICBkcmFnQ29udHJvbCh0LCBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YXM6IG4sXG4gICAgICBjbGllbnREaXN0WDogcixcbiAgICAgIGNsaWVudERpc3RZOiBzLFxuICAgICAgcGFyZW50Um90YXRlOiBvLFxuICAgICAgcGFyZW50RmxhZzogaSxcbiAgICAgIGlzUGluY2g6IGEsXG4gICAgICBncm91cERlbHRhOiBjLFxuICAgICAgcmVzb2x2ZU1hdHJpeDogbFxuICAgIH0gPSBlLCB7XG4gICAgICBiZWZvcmVEaXJlY3Rpb246IHUsXG4gICAgICBiZWZvcmVJbmZvOiBmLFxuICAgICAgYWZ0ZXJJbmZvOiBkLFxuICAgICAgYWJzb2x1dGVJbmZvOiBwLFxuICAgICAgaXNSb3RhdGU6IGcsXG4gICAgICBzdGFydFZhbHVlOiBoLFxuICAgICAgcmVjdDogdixcbiAgICAgIHN0YXJ0Q2xpZW50WDogbSxcbiAgICAgIHN0YXJ0Q2xpZW50WTogU1xuICAgIH0gPSBuO1xuICAgIGlmICghZylcbiAgICAgIHJldHVybjtcbiAgICBqbih0LCBlLCBcInJvdGF0ZVwiKTtcbiAgICBjb25zdCB4ID0gR2MoZSksIEMgPSB1ICogeCwgeyBwYXJlbnRNb3ZlYWJsZTogRSB9ID0gdC5wcm9wcztcbiAgICBsZXQgRCA9IDAsIFIsIHksIE0gPSAwLCBQLCBfLCBPID0gMCwgVCwgdztcbiAgICBjb25zdCBrID0gMTgwIC8gTWF0aC5QSSAqIGgsIEkgPSBwLnN0YXJ0VmFsdWU7XG4gICAgbGV0ICQgPSAhMTtcbiAgICBjb25zdCBHID0gbSArIHIsIEwgPSBTICsgcztcbiAgICBpZiAoIWkgJiYgXCJwYXJlbnREaXN0XCIgaW4gZSkge1xuICAgICAgY29uc3QgSCA9IGUucGFyZW50RGlzdDtcbiAgICAgIFIgPSBILCBQID0gSCwgVCA9IEg7XG4gICAgfSBlbHNlIGEgfHwgaSA/IChSID0gSW4obywgdSwgZiksIFAgPSBJbihvLCBDLCBkKSwgVCA9IEluKG8sIEMsIHApKSA6IChSID0gdXIoXG4gICAgICBHLFxuICAgICAgTCxcbiAgICAgIHUsXG4gICAgICBmXG4gICAgKSwgUCA9IHVyKFxuICAgICAgRyxcbiAgICAgIEwsXG4gICAgICBDLFxuICAgICAgZFxuICAgICksIFQgPSB1cihcbiAgICAgIEcsXG4gICAgICBMLFxuICAgICAgQyxcbiAgICAgIHBcbiAgICApLCAkID0gITApO1xuICAgIGlmICh5ID0gayArIFIsIF8gPSBrICsgUCwgdyA9IEkgKyBULCBqKFxuICAgICAgdCxcbiAgICAgIFwib25CZWZvcmVSb3RhdGVcIixcbiAgICAgIGV0KFxuICAgICAgICB0LFxuICAgICAgICBlLFxuICAgICAgICB7XG4gICAgICAgICAgYmVmb3JlUm90YXRpb246IHksXG4gICAgICAgICAgcm90YXRpb246IF8sXG4gICAgICAgICAgYWJzb2x1dGVSb3RhdGlvbjogdyxcbiAgICAgICAgICBzZXRSb3RhdGlvbihIKSB7XG4gICAgICAgICAgICBQID0gSCAtIGssIFIgPSBQLCBUID0gUDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICEwXG4gICAgICApXG4gICAgKSwgW0QsIFIsIHldID0gZnIoXG4gICAgICB0LFxuICAgICAgdixcbiAgICAgIGYsXG4gICAgICBSLFxuICAgICAgayxcbiAgICAgICRcbiAgICApLCBbTSwgUCwgX10gPSBmcihcbiAgICAgIHQsXG4gICAgICB2LFxuICAgICAgZCxcbiAgICAgIFAsXG4gICAgICBrLFxuICAgICAgJFxuICAgICksIFtPLCBULCB3XSA9IGZyKFxuICAgICAgdCxcbiAgICAgIHYsXG4gICAgICBwLFxuICAgICAgVCxcbiAgICAgIEksXG4gICAgICAkXG4gICAgKSwgIU8gJiYgIU0gJiYgIUQgJiYgIUUgJiYgIWwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeiA9IFhuKFxuICAgICAgbixcbiAgICAgIGByb3RhdGUoJHtffWRlZylgLFxuICAgICAgYHJvdGF0ZSgke1B9ZGVnKWBcbiAgICApO1xuICAgIGwgJiYgKG4uZml4ZWRQb3NpdGlvbiA9IGlzKFxuICAgICAgdCxcbiAgICAgIG4udGFyZ2V0QWxsVHJhbnNmb3JtLFxuICAgICAgbi5maXhlZERpcmVjdGlvbixcbiAgICAgIG4uZml4ZWRPZmZzZXQsXG4gICAgICBuXG4gICAgKSk7XG4gICAgY29uc3QgTiA9IEhjKHQsIFAsIG4pLCBaID0gSyhcbiAgICAgIGF0KGMgfHwgWzAsIDBdLCBOKSxcbiAgICAgIG4ucHJldkludmVyc2VEaXN0IHx8IFswLCAwXVxuICAgICk7XG4gICAgbi5wcmV2SW52ZXJzZURpc3QgPSBOLCBuLnJlcXVlc3RWYWx1ZSA9IG51bGw7XG4gICAgY29uc3QgWSA9IGlpKFxuICAgICAgdCxcbiAgICAgIHosXG4gICAgICBaLFxuICAgICAgYSxcbiAgICAgIGVcbiAgICApO1xuICAgIGxldCBXID0gWTtcbiAgICBjb25zdCBKID0gdGUoW0csIExdLCBwLnN0YXJ0QWJzb2x1dGVPcmlnaW4pIC0gcC5zdGFydERpc3Q7XG4gICAgbGV0IHE7XG4gICAgaWYgKG4ucmVzb2x2ZUFibGUgPT09IFwicmVzaXphYmxlXCIpIHtcbiAgICAgIGNvbnN0IEggPSBUci5kcmFnQ29udHJvbCh0LCB7XG4gICAgICAgIC4uLnZuKFxuICAgICAgICAgIGUsXG4gICAgICAgICAgdC5zdGF0ZSxcbiAgICAgICAgICBbZS5kZWx0YVgsIGUuZGVsdGFZXSxcbiAgICAgICAgICAhIWEsXG4gICAgICAgICAgITEsXG4gICAgICAgICAgXCJyZXNpemFibGVcIlxuICAgICAgICApLFxuICAgICAgICByZXNvbHZlTWF0cml4OiAhMCxcbiAgICAgICAgcGFyZW50RGlzdGFuY2U6IEpcbiAgICAgIH0pO1xuICAgICAgSCAmJiAocSA9IEgsIFcgPSBXaShXLCBILCBlKSk7XG4gICAgfVxuICAgIGNvbnN0IEYgPSBldCh0LCBlLCB7XG4gICAgICBkZWx0YTogTSxcbiAgICAgIGRpc3Q6IFAsXG4gICAgICByb3RhdGU6IF8sXG4gICAgICByb3RhdGlvbjogXyxcbiAgICAgIGJlZm9yZURpc3Q6IFIsXG4gICAgICBiZWZvcmVEZWx0YTogRCxcbiAgICAgIGJlZm9yZVJvdGF0ZTogeSxcbiAgICAgIGJlZm9yZVJvdGF0aW9uOiB5LFxuICAgICAgYWJzb2x1dGVEaXN0OiBULFxuICAgICAgYWJzb2x1dGVEZWx0YTogTyxcbiAgICAgIGFic29sdXRlUm90YXRlOiB3LFxuICAgICAgYWJzb2x1dGVSb3RhdGlvbjogdyxcbiAgICAgIGlzUGluY2g6ICEhYSxcbiAgICAgIHJlc2l6ZTogcSxcbiAgICAgIC4uLlksXG4gICAgICAuLi5XXG4gICAgfSk7XG4gICAgcmV0dXJuIGoodCwgXCJvblJvdGF0ZVwiLCBGKSwgRjtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQodCwgZSkge1xuICAgIGNvbnN0IHsgZGF0YXM6IG4gfSA9IGU7XG4gICAgaWYgKCFuLmlzUm90YXRlKVxuICAgICAgcmV0dXJuO1xuICAgIG4uaXNSb3RhdGUgPSAhMTtcbiAgICBjb25zdCByID0gJHQodCwgZSwge30pO1xuICAgIHJldHVybiBqKHQsIFwib25Sb3RhdGVFbmRcIiwgciksIHI7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IE9yLFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQodCwgZSkge1xuICAgIGNvbnN0IHsgZGF0YXM6IG4gfSA9IGUsIHtcbiAgICAgIGxlZnQ6IHIsXG4gICAgICB0b3A6IHMsXG4gICAgICBiZWZvcmVPcmlnaW46IG9cbiAgICB9ID0gdC5zdGF0ZSwgaSA9IHRoaXMuZHJhZ0NvbnRyb2xTdGFydCh0LCBlKTtcbiAgICBpZiAoIWkpXG4gICAgICByZXR1cm4gITE7XG4gICAgaS5zZXQobi5iZWZvcmVEaXJlY3Rpb24gKiB0LnJvdGF0aW9uKTtcbiAgICBjb25zdCBhID0gZWUoXG4gICAgICB0LFxuICAgICAgdGhpcyxcbiAgICAgIFwiZHJhZ0NvbnRyb2xTdGFydFwiLFxuICAgICAgZSxcbiAgICAgICh1LCBmKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbGVmdDogZCwgdG9wOiBwLCBiZWZvcmVPcmlnaW46IGcgfSA9IHUuc3RhdGUsIGggPSBhdChcbiAgICAgICAgICBLKFtkLCBwXSwgW3IsIHNdKSxcbiAgICAgICAgICBLKGcsIG8pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBmLmRhdGFzLnN0YXJ0R3JvdXBDbGllbnQgPSBoLCBmLmRhdGFzLmdyb3VwQ2xpZW50ID0gaCwgeyAuLi5mLCBwYXJlbnRSb3RhdGU6IDAgfTtcbiAgICAgIH1cbiAgICApLCBjID0ge1xuICAgICAgLi4uaSxcbiAgICAgIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogYVxuICAgIH0sIGwgPSBqKHQsIFwib25Sb3RhdGVHcm91cFN0YXJ0XCIsIGMpO1xuICAgIHJldHVybiBuLmlzUm90YXRlID0gbCAhPT0gITEsIG4uaXNSb3RhdGUgPyBpIDogITE7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2wodCwgZSkge1xuICAgIGNvbnN0IHsgZGF0YXM6IG4gfSA9IGU7XG4gICAgaWYgKCFuLmlzUm90YXRlKVxuICAgICAgcmV0dXJuO1xuICAgIFFuKHQsIFwib25CZWZvcmVSb3RhdGVcIiwgKGwpID0+IHtcbiAgICAgIGooXG4gICAgICAgIHQsXG4gICAgICAgIFwib25CZWZvcmVSb3RhdGVHcm91cFwiLFxuICAgICAgICBldChcbiAgICAgICAgICB0LFxuICAgICAgICAgIGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4ubCxcbiAgICAgICAgICAgIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgITBcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb25zdCByID0gdGhpcy5kcmFnQ29udHJvbCh0LCBlKTtcbiAgICBpZiAoIXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IG4uYmVmb3JlRGlyZWN0aW9uLCBvID0gci5iZWZvcmVEaXN0LCBpID0gbyAvIDE4MCAqIE1hdGguUEksIGEgPSBlZShcbiAgICAgIHQsXG4gICAgICB0aGlzLFxuICAgICAgXCJkcmFnQ29udHJvbFwiLFxuICAgICAgZSxcbiAgICAgIChsLCB1KSA9PiB7XG4gICAgICAgIGNvbnN0IGYgPSB1LmRhdGFzLnN0YXJ0R3JvdXBDbGllbnQsIFtkLCBwXSA9IHUuZGF0YXMuZ3JvdXBDbGllbnQsIFtnLCBoXSA9IGduKFxuICAgICAgICAgIGYsXG4gICAgICAgICAgaSAqIHNcbiAgICAgICAgKSwgdiA9IFtnIC0gZCwgaCAtIHBdO1xuICAgICAgICByZXR1cm4gdS5kYXRhcy5ncm91cENsaWVudCA9IFtnLCBoXSwgeyAuLi51LCBwYXJlbnRSb3RhdGU6IG8sIGdyb3VwRGVsdGE6IHYgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIHQucm90YXRpb24gPSBzICogci5iZWZvcmVSb3RhdGlvbjtcbiAgICBjb25zdCBjID0ge1xuICAgICAgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBhLFxuICAgICAgc2V0KGwpIHtcbiAgICAgICAgdC5yb3RhdGlvbiA9IGw7XG4gICAgICB9LFxuICAgICAgc2V0R3JvdXBSb3RhdGlvbihsKSB7XG4gICAgICAgIHQucm90YXRpb24gPSBsO1xuICAgICAgfSxcbiAgICAgIC4uLnJcbiAgICB9O1xuICAgIHJldHVybiBqKHQsIFwib25Sb3RhdGVHcm91cFwiLCBjKSwgYztcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZCh0LCBlKSB7XG4gICAgY29uc3QgeyBpc0RyYWc6IG4sIGRhdGFzOiByIH0gPSBlO1xuICAgIGlmICghci5pc1JvdGF0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRyYWdDb250cm9sRW5kKHQsIGUpO1xuICAgIGNvbnN0IHMgPSBlZSh0LCB0aGlzLCBcImRyYWdDb250cm9sRW5kXCIsIGUpLCBvID0gJHQodCwgZSwge1xuICAgICAgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBzXG4gICAgfSk7XG4gICAgcmV0dXJuIGoodCwgXCJvblJvdGF0ZUdyb3VwRW5kXCIsIG8pLCBuO1xuICB9LFxuICAvKipcbiAgICAgICAqIEBtZXRob2QgTW92ZWFibGUuUm90YXRhYmxlI3JlcXVlc3RcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZV0gLSB0aGUgUmVzaXphYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVJvdGF0ZT0wXSAtICBkZWx0YSBudW1iZXIgb2Ygcm90YXRpb25cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5yb3RhdGU9MF0gLSBhYnNvbHV0ZSBudW1iZXIgb2YgbW92ZWFibGUncyByb3RhdGlvblxuICAgICAgICogQHJldHVybiB7TW92ZWFibGUuUmVxdWVzdGVyfSBNb3ZlYWJsZSBSZXF1ZXN0ZXJcbiAgICAgICAqIEBleGFtcGxlXG4gIFxuICAgICAgICogLy8gSW5zdGFudGx5IFJlcXVlc3QgKHJlcXVlc3RTdGFydCAtIHJlcXVlc3QgLSByZXF1ZXN0RW5kKVxuICAgICAgICogbW92ZWFibGUucmVxdWVzdChcInJvdGF0YWJsZVwiLCB7IGRlbHRhUm90YXRlOiAxMCB9LCB0cnVlKTtcbiAgICAgICAqXG4gICAgICAgKiAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyb3RhdGFibGVcIiwgeyByb3RhdGU6IDEwIH0sIHRydWUpO1xuICAgICAgICpcbiAgICAgICAqIC8vIHJlcXVlc3RTdGFydFxuICAgICAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcInJvdGF0YWJsZVwiKTtcbiAgICAgICAqXG4gICAgICAgKiAvLyByZXF1ZXN0XG4gICAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhUm90YXRlOiAxMCB9KTtcbiAgICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFSb3RhdGU6IDEwIH0pO1xuICAgICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVJvdGF0ZTogMTAgfSk7XG4gICAgICAgKlxuICAgICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyByb3RhdGU6IDEwIH0pO1xuICAgICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyByb3RhdGU6IDIwIH0pO1xuICAgICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyByb3RhdGU6IDMwIH0pO1xuICAgICAgICpcbiAgICAgICAqIC8vIHJlcXVlc3RFbmRcbiAgICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0RW5kKCk7XG4gICAgICAgKi9cbiAgcmVxdWVzdCh0KSB7XG4gICAgY29uc3QgZSA9IHt9O1xuICAgIGxldCBuID0gMDtcbiAgICBjb25zdCByID0gdC5nZXRSb3RhdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBpc0NvbnRyb2w6ICEwLFxuICAgICAgcmVxdWVzdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4geyBkYXRhczogZSB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3Qocykge1xuICAgICAgICByZXR1cm4gXCJkZWx0YVJvdGF0ZVwiIGluIHMgPyBuICs9IHMuZGVsdGFSb3RhdGUgOiBcInJvdGF0ZVwiIGluIHMgJiYgKG4gPSBzLnJvdGF0ZSAtIHIpLCB7IGRhdGFzOiBlLCBwYXJlbnREaXN0OiBuIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YXM6IGUsIGlzRHJhZzogITAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gSWwodCwgZSkge1xuICBjb25zdCB7IGRpcmVjdGlvbjogbiwgY2xhc3NOYW1lczogciwgc2l6ZTogcywgcG9zOiBvLCB6b29tOiBpLCBrZXk6IGEgfSA9IHQsIGMgPSBuID09PSBcImhvcml6b250YWxcIiwgbCA9IGMgPyBcIllcIiA6IFwiWFwiO1xuICByZXR1cm4gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IGEsXG4gICAgY2xhc3NOYW1lOiByLmpvaW4oXCIgXCIpLFxuICAgIHN0eWxlOiB7XG4gICAgICBbYyA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdOiBgJHtzfWAsXG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtvWzBdfSwgJHtvWzFdfSkgdHJhbnNsYXRlJHtsfSgtNTAlKSBzY2FsZSR7bH0oJHtpfSlgXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGRzKHQsIGUpIHtcbiAgcmV0dXJuIElsKHtcbiAgICAuLi50LFxuICAgIGNsYXNzTmFtZXM6IFtcbiAgICAgIFUoXCJsaW5lXCIsIFwiZ3VpZGVsaW5lXCIsIHQuZGlyZWN0aW9uKSxcbiAgICAgIC4uLnQuY2xhc3NOYW1lc1xuICAgIF0uZmlsdGVyKChuKSA9PiBuKSxcbiAgICBzaXplOiB0LnNpemUgfHwgYCR7dC5zaXplVmFsdWV9cHhgLFxuICAgIHBvczogdC5wb3MgfHwgdC5wb3NWYWx1ZS5tYXAoKG4pID0+IGAke3R0KG4sIDAuMSl9cHhgKVxuICB9LCBlKTtcbn1cbmZ1bmN0aW9uIG5vKHQsIGUsIG4sIHIsIHMsIG8sIGksIGEpIHtcbiAgY29uc3QgeyB6b29tOiBjIH0gPSB0LnByb3BzO1xuICByZXR1cm4gbi5tYXAoKHsgdHlwZTogbCwgcG9zOiB1IH0sIGYpID0+IHtcbiAgICBjb25zdCBkID0gWzAsIDBdO1xuICAgIHJldHVybiBkW2ldID0gciwgZFtpID8gMCA6IDFdID0gLXMgKyB1LCBkcyhcbiAgICAgIHtcbiAgICAgICAga2V5OiBgJHtlfVRhcmdldEd1aWRlbGluZSR7Zn1gLFxuICAgICAgICBjbGFzc05hbWVzOiBbVShcInRhcmdldFwiLCBcImJvbGRcIiwgbCldLFxuICAgICAgICBwb3NWYWx1ZTogZCxcbiAgICAgICAgc2l6ZVZhbHVlOiBvLFxuICAgICAgICB6b29tOiBjLFxuICAgICAgICBkaXJlY3Rpb246IGVcbiAgICAgIH0sXG4gICAgICBhXG4gICAgKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBybyh0LCBlLCBuLCByLCBzLCBvKSB7XG4gIGNvbnN0IHsgem9vbTogaSwgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQ6IGEgfSA9IHQucHJvcHMsIGMgPSBlID09PSBcImhvcml6b250YWxcIiA/IGxlIDogdWUsIGwgPSBzW2Muc3RhcnRdLCB1ID0gc1tjLmVuZF07XG4gIHJldHVybiBuLmZpbHRlcigoeyBoaWRlOiBmLCBlbGVtZW50UmVjdDogZCB9KSA9PiB7XG4gICAgaWYgKGYpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKGEgJiYgZCkge1xuICAgICAgY29uc3QgcCA9IGQucmVjdDtcbiAgICAgIGlmIChwW2Muc3RhcnRdIDw9IGwgJiYgdSA8PSBwW2MuZW5kXSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH0pLm1hcCgoZiwgZCkgPT4ge1xuICAgIGNvbnN0IHsgcG9zOiBwLCBzaXplOiBnLCBlbGVtZW50OiBoLCBjbGFzc05hbWU6IHYgfSA9IGYsIG0gPSBbXG4gICAgICAtclswXSArIHBbMF0sXG4gICAgICAtclsxXSArIHBbMV1cbiAgICBdO1xuICAgIHJldHVybiBkcyhcbiAgICAgIHtcbiAgICAgICAga2V5OiBgJHtlfS1kZWZhdWx0LWd1aWRlbGluZS0ke2R9YCxcbiAgICAgICAgY2xhc3NOYW1lczogaCA/IFtVKFwiYm9sZFwiKSwgdl0gOiBbVShcIm5vcm1hbFwiKSwgdl0sXG4gICAgICAgIGRpcmVjdGlvbjogZSxcbiAgICAgICAgcG9zVmFsdWU6IG0sXG4gICAgICAgIHNpemVWYWx1ZTogZyxcbiAgICAgICAgem9vbTogaVxuICAgICAgfSxcbiAgICAgIG9cbiAgICApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFplKHQsIGUsIG4sIHIsIHMsIG8sIGksIGEpIHtcbiAgY29uc3Qge1xuICAgIHNuYXBEaWdpdDogYyA9IDAsXG4gICAgaXNEaXNwbGF5U25hcERpZ2l0OiBsID0gITAsXG4gICAgc25hcERpc3RGb3JtYXQ6IHUgPSAodiwgbSkgPT4gdixcbiAgICB6b29tOiBmXG4gIH0gPSB0LnByb3BzLCBkID0gZSA9PT0gXCJob3Jpem9udGFsXCIgPyBcIlhcIiA6IFwiWVwiLCBwID0gZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgZyA9IE1hdGguYWJzKHMpLCBoID0gbCA/IHBhcnNlRmxvYXQoZy50b0ZpeGVkKGMpKSA6IDA7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaXQuanN4cyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogVShcImd1aWRlbGluZS1ncm91cFwiLCBlKSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGxlZnQ6IGAke29bMF19cHhgLFxuICAgICAgICB0b3A6IGAke29bMV19cHhgLFxuICAgICAgICBbcF06IGAke2d9cHhgXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgZHMoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBlLFxuICAgICAgICAgICAgY2xhc3NOYW1lczogW1UobiksIGldLFxuICAgICAgICAgICAgc2l6ZTogXCIxMDAlXCIsXG4gICAgICAgICAgICBwb3NWYWx1ZTogWzAsIDBdLFxuICAgICAgICAgICAgc2l6ZVZhbHVlOiBnLFxuICAgICAgICAgICAgem9vbTogZlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gaXQuanN4KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBVKFwic2l6ZS12YWx1ZVwiLCBcImdhcFwiKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSR7ZH0oLTUwJSkgc2NhbGUoJHtmfSlgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IGggPiAwID8gdShoLCBlKSA6IFwiXCJcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIF1cbiAgICB9LFxuICAgIGAke2V9LSR7bn0tZ3VpZGVsaW5lLSR7cn1gXG4gICk7XG59XG5mdW5jdGlvbiBCbCh0LCBlLCBuLCByKSB7XG4gIGNvbnN0IHMgPSB0ID09PSBcInZlcnRpY2FsXCIgPyAwIDogMSwgbyA9IHQgPT09IFwidmVydGljYWxcIiA/IDEgOiAwLCBpID0gcyA/IGxlIDogdWUsIGEgPSBuW2kuc3RhcnRdLCBjID0gbltpLmVuZF07XG4gIHJldHVybiBZaShlLCAobCkgPT4gbC5wb3Nbc10pLm1hcCgobCkgPT4ge1xuICAgIGNvbnN0IHUgPSBbXSwgZiA9IFtdLCBkID0gW107XG4gICAgcmV0dXJuIGwuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgY29uc3QgZyA9IHAuZWxlbWVudCwgaCA9IHAuZWxlbWVudFJlY3QucmVjdDtcbiAgICAgIGlmIChoW2kuZW5kXSA8IGEpXG4gICAgICAgIHUucHVzaChwKTtcbiAgICAgIGVsc2UgaWYgKGMgPCBoW2kuc3RhcnRdKVxuICAgICAgICBmLnB1c2gocCk7XG4gICAgICBlbHNlIGlmIChoW2kuc3RhcnRdIDw9IGEgJiYgYyA8PSBoW2kuZW5kXSAmJiByKSB7XG4gICAgICAgIGNvbnN0IHYgPSBwLnBvcywgbSA9IHsgZWxlbWVudDogZywgcmVjdDogeyAuLi5oLCBbaS5lbmRdOiBoW2kuc3RhcnRdIH0gfSwgUyA9IHsgZWxlbWVudDogZywgcmVjdDogeyAuLi5oLCBbaS5zdGFydF06IGhbaS5lbmRdIH0gfSwgeCA9IFswLCAwXSwgQyA9IFswLCAwXTtcbiAgICAgICAgeFtzXSA9IHZbc10sIHhbb10gPSB2W29dLCBDW3NdID0gdltzXSwgQ1tvXSA9IHZbb10gKyBwLnNpemUsIHUucHVzaCh7XG4gICAgICAgICAgdHlwZTogdCxcbiAgICAgICAgICBwb3M6IHgsXG4gICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICBlbGVtZW50UmVjdDogbSxcbiAgICAgICAgICBkaXJlY3Rpb246IFwiXCIsXG4gICAgICAgICAgZWxlbWVudERpcmVjdGlvbjogXCJlbmRcIlxuICAgICAgICB9KSwgZi5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0LFxuICAgICAgICAgIHBvczogQyxcbiAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgIGVsZW1lbnRSZWN0OiBTLFxuICAgICAgICAgIGRpcmVjdGlvbjogXCJcIixcbiAgICAgICAgICBlbGVtZW50RGlyZWN0aW9uOiBcInN0YXJ0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSksIHUuc29ydCgocCwgZykgPT4gZy5wb3Nbb10gLSBwLnBvc1tvXSksIGYuc29ydCgocCwgZykgPT4gcC5wb3Nbb10gLSBnLnBvc1tvXSksIHtcbiAgICAgIHRvdGFsOiBsLFxuICAgICAgc3RhcnQ6IHUsXG4gICAgICBlbmQ6IGYsXG4gICAgICBpbm5lcjogZFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gemwodCwgZSwgbiwgciwgcykge1xuICBjb25zdCB7XG4gICAgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQ6IG9cbiAgfSA9IHQucHJvcHMsIGkgPSBbXTtcbiAgcmV0dXJuIFtcInZlcnRpY2FsXCIsIFwiaG9yaXpvbnRhbFwiXS5mb3JFYWNoKChhKSA9PiB7XG4gICAgY29uc3QgYyA9IGUuZmlsdGVyKCh2KSA9PiB2LnR5cGUgPT09IGEpLCBsID0gYSA9PT0gXCJ2ZXJ0aWNhbFwiID8gMSA6IDAsIHUgPSBsID8gMCA6IDEsIGYgPSBCbChhLCBjLCByLCBvKSwgZCA9IGwgPyB1ZSA6IGxlLCBwID0gbCA/IGxlIDogdWUsIGcgPSByW2Quc3RhcnRdLCBoID0gcltkLmVuZF07XG4gICAgZi5mb3JFYWNoKCh7IHRvdGFsOiB2LCBzdGFydDogbSwgZW5kOiBTLCBpbm5lcjogeCB9KSA9PiB7XG4gICAgICBjb25zdCBDID0gblt1XSArIHZbMF0ucG9zW3VdIC0gcltwLnN0YXJ0XTtcbiAgICAgIGxldCBFID0gcjtcbiAgICAgIG0uZm9yRWFjaCgoRCkgPT4ge1xuICAgICAgICBjb25zdCBSID0gRC5lbGVtZW50UmVjdC5yZWN0LCB5ID0gRVtkLnN0YXJ0XSAtIFJbZC5lbmRdO1xuICAgICAgICBpZiAoeSA+IDApIHtcbiAgICAgICAgICBjb25zdCBNID0gWzAsIDBdO1xuICAgICAgICAgIE1bbF0gPSBuW2xdICsgRVtkLnN0YXJ0XSAtIGcgLSB5LCBNW3VdID0gQywgaS5wdXNoKFplKFxuICAgICAgICAgICAgdCxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBcImRhc2hlZFwiLFxuICAgICAgICAgICAgaS5sZW5ndGgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgTSxcbiAgICAgICAgICAgIEQuY2xhc3NOYW1lLFxuICAgICAgICAgICAgc1xuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIEUgPSBSO1xuICAgICAgfSksIEUgPSByLCBTLmZvckVhY2goKEQpID0+IHtcbiAgICAgICAgY29uc3QgUiA9IEQuZWxlbWVudFJlY3QucmVjdCwgeSA9IFJbZC5zdGFydF0gLSBFW2QuZW5kXTtcbiAgICAgICAgaWYgKHkgPiAwKSB7XG4gICAgICAgICAgY29uc3QgTSA9IFswLCAwXTtcbiAgICAgICAgICBNW2xdID0gbltsXSArIEVbZC5lbmRdIC0gZywgTVt1XSA9IEMsIGkucHVzaChaZShcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgXCJkYXNoZWRcIixcbiAgICAgICAgICAgIGkubGVuZ3RoLFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIE0sXG4gICAgICAgICAgICBELmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHNcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICBFID0gUjtcbiAgICAgIH0pLCB4LmZvckVhY2goKEQpID0+IHtcbiAgICAgICAgY29uc3QgUiA9IEQuZWxlbWVudFJlY3QucmVjdCwgeSA9IGcgLSBSW2Quc3RhcnRdLCBNID0gUltkLmVuZF0gLSBoLCBQID0gWzAsIDBdLCBfID0gWzAsIDBdO1xuICAgICAgICBQW2xdID0gbltsXSAtIHksIFBbdV0gPSBDLCBfW2xdID0gbltsXSArIGggLSBnLCBfW3VdID0gQywgaS5wdXNoKFplKFxuICAgICAgICAgIHQsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBcImRhc2hlZFwiLFxuICAgICAgICAgIGkubGVuZ3RoLFxuICAgICAgICAgIHksXG4gICAgICAgICAgUCxcbiAgICAgICAgICBELmNsYXNzTmFtZSxcbiAgICAgICAgICBzXG4gICAgICAgICkpLCBpLnB1c2goWmUoXG4gICAgICAgICAgdCxcbiAgICAgICAgICBhLFxuICAgICAgICAgIFwiZGFzaGVkXCIsXG4gICAgICAgICAgaS5sZW5ndGgsXG4gICAgICAgICAgTSxcbiAgICAgICAgICBfLFxuICAgICAgICAgIEQuY2xhc3NOYW1lLFxuICAgICAgICAgIHNcbiAgICAgICAgKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBBbCh0LCBlLCBuLCByLCBzKSB7XG4gIGNvbnN0IG8gPSBbXTtcbiAgcmV0dXJuIFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiXS5mb3JFYWNoKChpKSA9PiB7XG4gICAgY29uc3QgYSA9IGUuZmlsdGVyKCh2KSA9PiB2LnR5cGUgPT09IGkpLnNsaWNlKDAsIDEpLCBjID0gaSA9PT0gXCJ2ZXJ0aWNhbFwiID8gMCA6IDEsIGwgPSBjID8gMCA6IDEsIHUgPSBjID8gdWUgOiBsZSwgZiA9IGMgPyBsZSA6IHVlLCBkID0gclt1LnN0YXJ0XSwgcCA9IHJbdS5lbmRdLCBnID0gcltmLnN0YXJ0XSwgaCA9IHJbZi5lbmRdO1xuICAgIGEuZm9yRWFjaCgoeyBnYXA6IHYsIGdhcFJlY3RzOiBtIH0pID0+IHtcbiAgICAgIGNvbnN0IFMgPSBNYXRoLm1heChcbiAgICAgICAgZyxcbiAgICAgICAgLi4ubS5tYXAoKHsgcmVjdDogRSB9KSA9PiBFW2Yuc3RhcnRdKVxuICAgICAgKSwgeCA9IE1hdGgubWluKFxuICAgICAgICBoLFxuICAgICAgICAuLi5tLm1hcCgoeyByZWN0OiBFIH0pID0+IEVbZi5lbmRdKVxuICAgICAgKSwgQyA9IChTICsgeCkgLyAyO1xuICAgICAgUyA9PT0geCB8fCBDID09PSAoZyArIGgpIC8gMiB8fCBtLmZvckVhY2goKHsgcmVjdDogRSwgY2xhc3NOYW1lOiBEIH0pID0+IHtcbiAgICAgICAgY29uc3QgUiA9IFtuWzBdLCBuWzFdXTtcbiAgICAgICAgaWYgKEVbdS5lbmRdIDwgZClcbiAgICAgICAgICBSW2NdICs9IEVbdS5lbmRdIC0gZDtcbiAgICAgICAgZWxzZSBpZiAocCA8IEVbdS5zdGFydF0pXG4gICAgICAgICAgUltjXSArPSBFW3Uuc3RhcnRdIC0gZCAtIHY7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIFJbbF0gKz0gQyAtIGcsIG8ucHVzaChaZShcbiAgICAgICAgICB0LFxuICAgICAgICAgIGMgPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIixcbiAgICAgICAgICBcImdhcFwiLFxuICAgICAgICAgIG8ubGVuZ3RoLFxuICAgICAgICAgIHYsXG4gICAgICAgICAgUixcbiAgICAgICAgICBELFxuICAgICAgICAgIHNcbiAgICAgICAgKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSksIG87XG59XG52YXIgR2wgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgdGhpcy5rZXlzID0gW10sIHRoaXMudmFsdWVzID0gW107XG4gIH1cbiAgdmFyIGUgPSB0LnByb3RvdHlwZTtcbiAgcmV0dXJuIGUuZ2V0ID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1t0aGlzLmtleXMuaW5kZXhPZihuKV07XG4gIH0sIGUuc2V0ID0gZnVuY3Rpb24obiwgcikge1xuICAgIHZhciBzID0gdGhpcy5rZXlzLCBvID0gdGhpcy52YWx1ZXMsIGkgPSBzLmluZGV4T2YobiksIGEgPSBpID09PSAtMSA/IHMubGVuZ3RoIDogaTtcbiAgICBzW2FdID0gbiwgb1thXSA9IHI7XG4gIH0sIHQ7XG59KCksIGtsID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiB0KCkge1xuICAgIHRoaXMub2JqZWN0ID0ge307XG4gIH1cbiAgdmFyIGUgPSB0LnByb3RvdHlwZTtcbiAgcmV0dXJuIGUuZ2V0ID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFtuXTtcbiAgfSwgZS5zZXQgPSBmdW5jdGlvbihuLCByKSB7XG4gICAgdGhpcy5vYmplY3Rbbl0gPSByO1xuICB9LCB0O1xufSgpLCAkbCA9IHR5cGVvZiBNYXAgPT0gXCJmdW5jdGlvblwiLCBGbCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gdCgpIHtcbiAgfVxuICB2YXIgZSA9IHQucHJvdG90eXBlO1xuICByZXR1cm4gZS5jb25uZWN0ID0gZnVuY3Rpb24obiwgcikge1xuICAgIHRoaXMucHJldiA9IG4sIHRoaXMubmV4dCA9IHIsIG4gJiYgKG4ubmV4dCA9IHRoaXMpLCByICYmIChyLnByZXYgPSB0aGlzKTtcbiAgfSwgZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSB0aGlzLnByZXYsIHIgPSB0aGlzLm5leHQ7XG4gICAgbiAmJiAobi5uZXh0ID0gciksIHIgJiYgKHIucHJldiA9IG4pO1xuICB9LCBlLmdldEluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgbiA9IHRoaXMsIHIgPSAtMTsgbjsgKVxuICAgICAgbiA9IG4ucHJldiwgKytyO1xuICAgIHJldHVybiByO1xuICB9LCB0O1xufSgpO1xuZnVuY3Rpb24gTGwodCwgZSkge1xuICB2YXIgbiA9IFtdLCByID0gW107XG4gIHJldHVybiB0LmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBvID0gc1swXSwgaSA9IHNbMV0sIGEgPSBuZXcgRmwoKTtcbiAgICBuW29dID0gYSwgcltpXSA9IGE7XG4gIH0pLCBuLmZvckVhY2goZnVuY3Rpb24ocywgbykge1xuICAgIHMuY29ubmVjdChuW28gLSAxXSk7XG4gIH0pLCB0LmZpbHRlcihmdW5jdGlvbihzLCBvKSB7XG4gICAgcmV0dXJuICFlW29dO1xuICB9KS5tYXAoZnVuY3Rpb24ocywgbykge1xuICAgIHZhciBpID0gc1swXSwgYSA9IHNbMV07XG4gICAgaWYgKGkgPT09IGEpXG4gICAgICByZXR1cm4gWzAsIDBdO1xuICAgIHZhciBjID0gbltpXSwgbCA9IHJbYSAtIDFdLCB1ID0gYy5nZXRJbmRleCgpO1xuICAgIGMuZGlzY29ubmVjdCgpLCBsID8gYy5jb25uZWN0KGwsIGwubmV4dCkgOiBjLmNvbm5lY3Qodm9pZCAwLCBuWzBdKTtcbiAgICB2YXIgZiA9IGMuZ2V0SW5kZXgoKTtcbiAgICByZXR1cm4gW3UsIGZdO1xuICB9KTtcbn1cbnZhciBObCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gdChuLCByLCBzLCBvLCBpLCBhLCBjLCBsKSB7XG4gICAgdGhpcy5wcmV2TGlzdCA9IG4sIHRoaXMubGlzdCA9IHIsIHRoaXMuYWRkZWQgPSBzLCB0aGlzLnJlbW92ZWQgPSBvLCB0aGlzLmNoYW5nZWQgPSBpLCB0aGlzLm1haW50YWluZWQgPSBhLCB0aGlzLmNoYW5nZWRCZWZvcmVBZGRlZCA9IGMsIHRoaXMuZml4ZWQgPSBsO1xuICB9XG4gIHZhciBlID0gdC5wcm90b3R5cGU7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJvcmRlcmVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVPcmRlcmVkIHx8IHRoaXMuY2FjdWxhdGVPcmRlcmVkKCksIHRoaXMuY2FjaGVPcmRlcmVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMFxuICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHVyZUNoYW5nZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVB1cmVDaGFuZ2VkIHx8IHRoaXMuY2FjdWxhdGVPcmRlcmVkKCksIHRoaXMuY2FjaGVQdXJlQ2hhbmdlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgfSksIGUuY2FjdWxhdGVPcmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBMbCh0aGlzLmNoYW5nZWRCZWZvcmVBZGRlZCwgdGhpcy5maXhlZCksIHIgPSB0aGlzLmNoYW5nZWQsIHMgPSBbXTtcbiAgICB0aGlzLmNhY2hlT3JkZXJlZCA9IG4uZmlsdGVyKGZ1bmN0aW9uKG8sIGkpIHtcbiAgICAgIHZhciBhID0gb1swXSwgYyA9IG9bMV0sIGwgPSByW2ldLCB1ID0gbFswXSwgZiA9IGxbMV07XG4gICAgICBpZiAoYSAhPT0gYylcbiAgICAgICAgcmV0dXJuIHMucHVzaChbdSwgZl0pLCAhMDtcbiAgICB9KSwgdGhpcy5jYWNoZVB1cmVDaGFuZ2VkID0gcztcbiAgfSwgdDtcbn0oKTtcbmZ1bmN0aW9uIHBzKHQsIGUsIG4pIHtcbiAgdmFyIHIgPSAkbCA/IE1hcCA6IG4gPyBrbCA6IEdsLCBzID0gbiB8fCBmdW5jdGlvbihTKSB7XG4gICAgcmV0dXJuIFM7XG4gIH0sIG8gPSBbXSwgaSA9IFtdLCBhID0gW10sIGMgPSB0Lm1hcChzKSwgbCA9IGUubWFwKHMpLCB1ID0gbmV3IHIoKSwgZiA9IG5ldyByKCksIGQgPSBbXSwgcCA9IFtdLCBnID0ge30sIGggPSBbXSwgdiA9IDAsIG0gPSAwO1xuICByZXR1cm4gYy5mb3JFYWNoKGZ1bmN0aW9uKFMsIHgpIHtcbiAgICB1LnNldChTLCB4KTtcbiAgfSksIGwuZm9yRWFjaChmdW5jdGlvbihTLCB4KSB7XG4gICAgZi5zZXQoUywgeCk7XG4gIH0pLCBjLmZvckVhY2goZnVuY3Rpb24oUywgeCkge1xuICAgIHZhciBDID0gZi5nZXQoUyk7XG4gICAgdHlwZW9mIEMgPiBcInVcIiA/ICgrK20sIGkucHVzaCh4KSkgOiBnW0NdID0gbTtcbiAgfSksIGwuZm9yRWFjaChmdW5jdGlvbihTLCB4KSB7XG4gICAgdmFyIEMgPSB1LmdldChTKTtcbiAgICB0eXBlb2YgQyA+IFwidVwiID8gKG8ucHVzaCh4KSwgKyt2KSA6IChhLnB1c2goW0MsIHhdKSwgbSA9IGdbeF0gfHwgMCwgZC5wdXNoKFtDIC0gbSwgeCAtIHZdKSwgcC5wdXNoKHggPT09IEMpLCBDICE9PSB4ICYmIGgucHVzaChbQywgeF0pKTtcbiAgfSksIGkucmV2ZXJzZSgpLCBuZXcgTmwodCwgZSwgbywgaSwgaCwgYSwgZCwgcCk7XG59XG52YXIgV2wgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHQobiwgcikge1xuICAgIG4gPT09IHZvaWQgMCAmJiAobiA9IFtdKSwgdGhpcy5maW5kS2V5Q2FsbGJhY2sgPSByLCB0aGlzLmxpc3QgPSBbXS5zbGljZS5jYWxsKG4pO1xuICB9XG4gIHZhciBlID0gdC5wcm90b3R5cGU7XG4gIHJldHVybiBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgciA9IFtdLnNsaWNlLmNhbGwobiksIHMgPSBwcyh0aGlzLmxpc3QsIHIsIHRoaXMuZmluZEtleUNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ID0gciwgcztcbiAgfSwgdDtcbn0oKTtcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cblxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xudmFyIHdyID0gZnVuY3Rpb24odCwgZSkge1xuICByZXR1cm4gd3IgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICBuLl9fcHJvdG9fXyA9IHI7XG4gIH0gfHwgZnVuY3Rpb24obiwgcikge1xuICAgIGZvciAodmFyIHMgaW4gcikgci5oYXNPd25Qcm9wZXJ0eShzKSAmJiAobltzXSA9IHJbc10pO1xuICB9LCB3cih0LCBlKTtcbn07XG5mdW5jdGlvbiBZbCh0LCBlKSB7XG4gIHdyKHQsIGUpO1xuICBmdW5jdGlvbiBuKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSB0O1xuICB9XG4gIHQucHJvdG90eXBlID0gZSA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoZSkgOiAobi5wcm90b3R5cGUgPSBlLnByb3RvdHlwZSwgbmV3IG4oKSk7XG59XG52YXIgUGkgPSB0eXBlb2YgTWFwID09IFwiZnVuY3Rpb25cIiA/IHZvaWQgMCA6IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlLl9fRElGRl9LRVlfXyB8fCAoZS5fX0RJRkZfS0VZX18gPSArK3QpO1xuICB9O1xufSgpLCBfaSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbih0KSB7XG4gIFlsKGUsIHQpO1xuICBmdW5jdGlvbiBlKG4pIHtcbiAgICByZXR1cm4gbiA9PT0gdm9pZCAwICYmIChuID0gW10pLCB0LmNhbGwodGhpcywgbiwgUGkpIHx8IHRoaXM7XG4gIH1cbiAgcmV0dXJuIGU7XG59KFdsKTtcbmZ1bmN0aW9uIFZsKHQsIGUpIHtcbiAgcmV0dXJuIHBzKHQsIGUsIFBpKTtcbn1cbmZ1bmN0aW9uIElyKHQpIHtcbiAgdmFyIFA7XG4gIGNvbnN0IGUgPSB0LnN0YXRlLCB7XG4gICAgY29udGFpbmVyQ2xpZW50UmVjdDogbixcbiAgICBoYXNGaXhlZDogclxuICB9ID0gZSwge1xuICAgIG92ZXJmbG93OiBzLFxuICAgIHNjcm9sbEhlaWdodDogbyxcbiAgICBzY3JvbGxXaWR0aDogaSxcbiAgICBjbGllbnRIZWlnaHQ6IGEsXG4gICAgY2xpZW50V2lkdGg6IGMsXG4gICAgY2xpZW50TGVmdDogbCxcbiAgICBjbGllbnRUb3A6IHVcbiAgfSA9IG4sIHtcbiAgICBzbmFwR2FwOiBmID0gITAsXG4gICAgdmVydGljYWxHdWlkZWxpbmVzOiBkLFxuICAgIGhvcml6b250YWxHdWlkZWxpbmVzOiBwLFxuICAgIHNuYXBUaHJlc2hvbGQ6IGcgPSA1LFxuICAgIG1heFNuYXBFbGVtZW50R3VpZGVsaW5lRGlzdGFuY2U6IGggPSAxIC8gMCxcbiAgICBpc0Rpc3BsYXlHcmlkR3VpZGVsaW5lczogdlxuICB9ID0gdC5wcm9wcywgeyB0b3A6IG0sIGxlZnQ6IFMsIGJvdHRvbTogeCwgcmlnaHQ6IEMgfSA9IFl0KGp0KHQuc3RhdGUpKSwgRSA9IHsgdG9wOiBtLCBsZWZ0OiBTLCBib3R0b206IHgsIHJpZ2h0OiBDLCBjZW50ZXI6IChTICsgQykgLyAyLCBtaWRkbGU6IChtICsgeCkgLyAyIH07XG4gIGxldCBSID0gWy4uLnFsKHQpXTtcbiAgY29uc3QgeSA9ICgoKFAgPSBlLnNuYXBUaHJlc2hvbGRJbmZvKSA9PSBudWxsID8gdm9pZCAwIDogUC5tdWx0aXBsZXMpID8/IFsxLCAxXSkubWFwKChfKSA9PiBfICogZyk7XG4gIGYgJiYgUi5wdXNoKC4uLmpsKFxuICAgIHQsXG4gICAgRSxcbiAgICB5XG4gICkpO1xuICBjb25zdCBNID0ge1xuICAgIC4uLmUuc25hcE9mZnNldCB8fCB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgcmlnaHQ6IDBcbiAgICB9XG4gIH07XG4gIGlmIChSLnB1c2goLi4uSGwoXG4gICAgdCxcbiAgICBzID8gaSA6IGMsXG4gICAgcyA/IG8gOiBhLFxuICAgIGwsXG4gICAgdSxcbiAgICBNLFxuICAgIHZcbiAgKSksIHIpIHtcbiAgICBjb25zdCB7IGxlZnQ6IF8sIHRvcDogTyB9ID0gbjtcbiAgICBNLmxlZnQgKz0gXywgTS50b3AgKz0gTywgTS5yaWdodCArPSBfLCBNLmJvdHRvbSArPSBPO1xuICB9XG4gIHJldHVybiBSLnB1c2goLi4uT2koXG4gICAgcCB8fCAhMSxcbiAgICBkIHx8ICExLFxuICAgIHMgPyBpIDogYyxcbiAgICBzID8gbyA6IGEsXG4gICAgbCxcbiAgICB1LFxuICAgIE1cbiAgKSksIFIgPSBSLmZpbHRlcigoeyBlbGVtZW50OiBfLCBlbGVtZW50UmVjdDogTywgdHlwZTogVCB9KSA9PiB7XG4gICAgaWYgKCFfIHx8ICFPKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGNvbnN0IHcgPSBPLnJlY3Q7XG4gICAgcmV0dXJuIFRpKEUsIHcsIFQsIGgpO1xuICB9KSwgUjtcbn1cbmZ1bmN0aW9uIGpsKHQsIGUsIG4pIHtcbiAgY29uc3Qge1xuICAgIG1heFNuYXBFbGVtZW50R3VpZGVsaW5lRGlzdGFuY2U6IHIgPSAxIC8gMCxcbiAgICBtYXhTbmFwRWxlbWVudEdhcERpc3RhbmNlOiBzID0gMSAvIDBcbiAgfSA9IHQucHJvcHMsIG8gPSB0LnN0YXRlLmVsZW1lbnRSZWN0cywgaSA9IFtdO1xuICByZXR1cm4gW1xuICAgIFtcInZlcnRpY2FsXCIsIGxlLCB1ZV0sXG4gICAgW1wiaG9yaXpvbnRhbFwiLCB1ZSwgbGVdXG4gIF0uZm9yRWFjaCgoW2EsIGMsIGxdKSA9PiB7XG4gICAgY29uc3QgdSA9IGVbYy5zdGFydF0sIGYgPSBlW2MuZW5kXSwgZCA9IGVbYy5jZW50ZXJdLCBwID0gZVtsLnN0YXJ0XSwgZyA9IGVbbC5lbmRdLCBoID0ge1xuICAgICAgbGVmdDogblswXSxcbiAgICAgIHRvcDogblsxXVxuICAgIH07XG4gICAgZnVuY3Rpb24gdih4KSB7XG4gICAgICBjb25zdCBDID0geC5yZWN0LCBFID0gaFtjLnN0YXJ0XTtcbiAgICAgIHJldHVybiBDW2MuZW5kXSA8IHUgKyBFID8gdSAtIENbYy5lbmRdIDogZiAtIEUgPCBDW2Muc3RhcnRdID8gQ1tjLnN0YXJ0XSAtIGYgOiAtMTtcbiAgICB9XG4gICAgY29uc3QgbSA9IG8uZmlsdGVyKCh4KSA9PiB7XG4gICAgICBjb25zdCBDID0geC5yZWN0O1xuICAgICAgcmV0dXJuIENbbC5zdGFydF0gPiBnIHx8IENbbC5lbmRdIDwgcCA/ICExIDogdih4KSA+IDA7XG4gICAgfSkuc29ydCgoeCwgQykgPT4gdih4KSAtIHYoQykpLCBTID0gW107XG4gICAgbS5mb3JFYWNoKCh4KSA9PiB7XG4gICAgICBtLmZvckVhY2goKEMpID0+IHtcbiAgICAgICAgaWYgKHggPT09IEMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHJlY3Q6IEUgfSA9IHgsIHsgcmVjdDogRCB9ID0gQywgUiA9IEVbbC5zdGFydF0sIHkgPSBFW2wuZW5kXSwgTSA9IERbbC5zdGFydF0sIFAgPSBEW2wuZW5kXTtcbiAgICAgICAgUiA+IFAgfHwgTSA+IHkgfHwgUy5wdXNoKFt4LCBDXSk7XG4gICAgICB9KTtcbiAgICB9KSwgUy5mb3JFYWNoKChbeCwgQ10pID0+IHtcbiAgICAgIGNvbnN0IHsgcmVjdDogRSB9ID0geCwgeyByZWN0OiBEIH0gPSBDLCBSID0gRVtjLnN0YXJ0XSwgeSA9IEVbYy5lbmRdLCBNID0gRFtjLnN0YXJ0XSwgUCA9IERbYy5lbmRdLCBfID0gaFtjLnN0YXJ0XTtcbiAgICAgIGxldCBPID0gMCwgVCA9IDAsIHcgPSAhMSwgayA9ICExLCBJID0gITE7XG4gICAgICBpZiAoeSA8PSB1ICYmIGYgPD0gTSkge1xuICAgICAgICBpZiAoayA9ICEwLCBPID0gKE0gLSB5IC0gKGYgLSB1KSkgLyAyLCBUID0geSArIE8gKyAoZiAtIHUpIC8gMiwgQihUIC0gZCkgPiBfKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoeSA8IE0gJiYgUCA8IHUgKyBfKSB7XG4gICAgICAgIGlmICh3ID0gITAsIE8gPSBNIC0geSwgVCA9IFAgKyBPLCBCKFQgLSB1KSA+IF8pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh5IDwgTSAmJiBmIC0gXyA8IFIpIHtcbiAgICAgICAgaWYgKEkgPSAhMCwgTyA9IE0gLSB5LCBUID0gUiAtIE8sIEIoVCAtIGYpID4gXylcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuO1xuICAgICAgTyAmJiBUaShlLCBELCBhLCByKSAmJiAoTyA+IHMgfHwgaS5wdXNoKHtcbiAgICAgICAgdHlwZTogYSxcbiAgICAgICAgcG9zOiBhID09PSBcInZlcnRpY2FsXCIgPyBbVCwgMF0gOiBbMCwgVF0sXG4gICAgICAgIGVsZW1lbnQ6IEMuZWxlbWVudCxcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgY2xhc3NOYW1lOiBDLmNsYXNzTmFtZSxcbiAgICAgICAgaXNTdGFydDogdyxcbiAgICAgICAgaXNDZW50ZXI6IGssXG4gICAgICAgIGlzRW5kOiBJLFxuICAgICAgICBnYXA6IE8sXG4gICAgICAgIGhpZGU6ICEwLFxuICAgICAgICBnYXBSZWN0czogW3gsIENdLFxuICAgICAgICBkaXJlY3Rpb246IFwiXCIsXG4gICAgICAgIGVsZW1lbnREaXJlY3Rpb246IFwiXCJcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBYbCh0LCBlLCBuLCByKSB7XG4gIHZhciBkLCBwO1xuICBjb25zdCBzID0gdC5wcm9wcywgbyA9IHQuc3RhdGUsIHtcbiAgICBzbmFwR3JpZEFsbDogaVxuICB9ID0gcywge1xuICAgIHNuYXBHcmlkV2lkdGg6IGEgPSAwLFxuICAgIHNuYXBHcmlkSGVpZ2h0OiBjID0gMFxuICB9ID0gcywge1xuICAgIHNuYXBSZW5kZXJJbmZvOiBsXG4gIH0gPSBvLCB1ID0gbCAmJiAoKChkID0gbC5kaXJlY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBkWzBdKSB8fCAoKHAgPSBsLmRpcmVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IHBbMV0pKSwgZiA9IHQubW92ZWFibGVzO1xuICBpZiAoaSAmJiBmICYmIHUgJiYgKGEgfHwgYykpIHtcbiAgICBpZiAoby5zbmFwVGhyZXNob2xkSW5mbylcbiAgICAgIHJldHVybjtcbiAgICBvLnNuYXBUaHJlc2hvbGRJbmZvID0ge1xuICAgICAgbXVsdGlwbGVzOiBbMSwgMV0sXG4gICAgICBvZmZzZXQ6IFswLCAwXVxuICAgIH07XG4gICAgY29uc3QgZyA9IHQuZ2V0UmVjdCgpLCBoID0gZy5jaGlsZHJlbiwgdiA9IGwuZGlyZWN0aW9uO1xuICAgIGlmIChoKSB7XG4gICAgICBjb25zdCBtID0gdi5tYXAoKHgsIEMpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNuYXBTaXplOiBFLFxuICAgICAgICAgIHBvc05hbWU6IEQsXG4gICAgICAgICAgc2l6ZU5hbWU6IFIsXG4gICAgICAgICAgY2xpZW50T2Zmc2V0OiB5XG4gICAgICAgIH0gPSBDID09PSAwID8ge1xuICAgICAgICAgIHNuYXBTaXplOiBhLFxuICAgICAgICAgIHBvc05hbWU6IFwibGVmdFwiLFxuICAgICAgICAgIHNpemVOYW1lOiBcIndpZHRoXCIsXG4gICAgICAgICAgY2xpZW50T2Zmc2V0OiByLmxlZnQgLSBlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgc25hcFNpemU6IGMsXG4gICAgICAgICAgcG9zTmFtZTogXCJ0b3BcIixcbiAgICAgICAgICBzaXplTmFtZTogXCJoZWlnaHRcIixcbiAgICAgICAgICBjbGllbnRPZmZzZXQ6IHIudG9wIC0gblxuICAgICAgICB9O1xuICAgICAgICBpZiAoIUUpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcjogeCxcbiAgICAgICAgICAgIG11bHRpcGxlOiAxLFxuICAgICAgICAgICAgc25hcFNpemU6IEUsXG4gICAgICAgICAgICBzbmFwT2Zmc2V0OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgTSA9IGdbUl0sIFAgPSBnW0RdLCBfID0geWMoaC5tYXAoKEcpID0+IFtcbiAgICAgICAgICBHW0RdIC0gUCxcbiAgICAgICAgICBHW1JdLFxuICAgICAgICAgIE0gLSBHW1JdIC0gR1tEXSArIFBcbiAgICAgICAgXSkpLmZpbHRlcigoRykgPT4gRykuc29ydCgoRywgTCkgPT4gRyAtIEwpLCBPID0gX1swXSwgVCA9IF8ubWFwKChHKSA9PiB0dChHIC8gTywgMC4xKSAqIEUpO1xuICAgICAgICBsZXQgdyA9IDE7XG4gICAgICAgIGNvbnN0IGsgPSB0dChNIC8gTywgMC4xKTtcbiAgICAgICAgZm9yICh3ID0gMTsgdyA8PSAxMCAmJiAhVC5ldmVyeSgoRykgPT4gRyAqIHcgJSAxID09PSAwKTsgKyt3KVxuICAgICAgICAgIDtcbiAgICAgICAgY29uc3QgSSA9ICgteCArIDEpIC8gMiwgJCA9IHpuKFxuICAgICAgICAgIFAgLSB5LFxuICAgICAgICAgIFAgLSB5ICsgTSxcbiAgICAgICAgICBJLFxuICAgICAgICAgIDEgLSBJXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbXVsdGlwbGU6IGsgKiB3LFxuICAgICAgICAgIGRpcjogeCxcbiAgICAgICAgICBzbmFwU2l6ZTogRSxcbiAgICAgICAgICBzbmFwT2Zmc2V0OiBNYXRoLnJvdW5kKCQgLyBFKVxuICAgICAgICB9O1xuICAgICAgfSksIFMgPSBtLm1hcCgoeCkgPT4geC5tdWx0aXBsZSB8fCAxKTtcbiAgICAgIG8uc25hcFRocmVzaG9sZEluZm8ubXVsdGlwbGVzID0gUywgby5zbmFwVGhyZXNob2xkSW5mby5vZmZzZXQgPSBtLm1hcCgoeCkgPT4geC5zbmFwT2Zmc2V0KSwgbS5mb3JFYWNoKCh4LCBDKSA9PiB7XG4gICAgICAgIHguc25hcFNpemU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZVxuICAgIG8uc25hcFRocmVzaG9sZEluZm8gPSBudWxsO1xufVxuZnVuY3Rpb24gSGwodCwgZSwgbiwgciA9IDAsIHMgPSAwLCBvLCBpKSB7XG4gIGNvbnN0IGEgPSB0LnByb3BzLCBjID0gdC5zdGF0ZTtcbiAgbGV0IHtcbiAgICBzbmFwR3JpZFdpZHRoOiBsID0gMCxcbiAgICBzbmFwR3JpZEhlaWdodDogdSA9IDBcbiAgfSA9IGE7XG4gIGNvbnN0IGYgPSBbXSwge1xuICAgIGxlZnQ6IGQsXG4gICAgdG9wOiBwXG4gIH0gPSBvO1xuICBsZXQgZyA9IFswLCAwXTtcbiAgWGwoXG4gICAgdCxcbiAgICByLFxuICAgIHMsXG4gICAgb1xuICApO1xuICBjb25zdCBoID0gYy5zbmFwVGhyZXNob2xkSW5mbywgdiA9IGwsIG0gPSB1O1xuICBpZiAoaCAmJiAobCAqPSBoLm11bHRpcGxlc1swXSB8fCAxLCB1ICo9IGgubXVsdGlwbGVzWzFdIHx8IDEsIGcgPSBoLm9mZnNldCksIHUpIHtcbiAgICBjb25zdCBTID0gKHgpID0+IHtcbiAgICAgIGYucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBwb3M6IFtcbiAgICAgICAgICBkLFxuICAgICAgICAgIHR0KGdbMV0gKiBtICsgeCAtIHMgKyBwLCAwLjEpXG4gICAgICAgIF0sXG4gICAgICAgIGNsYXNzTmFtZTogVShcImdyaWQtZ3VpZGVsaW5lXCIpLFxuICAgICAgICBzaXplOiBlLFxuICAgICAgICBoaWRlOiAhaSxcbiAgICAgICAgZGlyZWN0aW9uOiBcIlwiLFxuICAgICAgICBncmlkOiAhMFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSBuICogMjsgeCArPSB1KVxuICAgICAgUyh4KTtcbiAgICBmb3IgKGxldCB4ID0gLXU7IHggPj0gLW47IHggLT0gdSlcbiAgICAgIFMoeCk7XG4gIH1cbiAgaWYgKGwpIHtcbiAgICBjb25zdCBTID0gKHgpID0+IHtcbiAgICAgIGYucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidmVydGljYWxcIixcbiAgICAgICAgcG9zOiBbXG4gICAgICAgICAgdHQoZ1swXSAqIHYgKyB4IC0gciArIGQsIDAuMSksXG4gICAgICAgICAgcFxuICAgICAgICBdLFxuICAgICAgICBjbGFzc05hbWU6IFUoXCJncmlkLWd1aWRlbGluZVwiKSxcbiAgICAgICAgc2l6ZTogbixcbiAgICAgICAgaGlkZTogIWksXG4gICAgICAgIGRpcmVjdGlvbjogXCJcIixcbiAgICAgICAgZ3JpZDogITBcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPD0gZSAqIDI7IHggKz0gbClcbiAgICAgIFMoeCk7XG4gICAgZm9yIChsZXQgeCA9IC1sOyB4ID49IC1lOyB4IC09IGwpXG4gICAgICBTKHgpO1xuICB9XG4gIHJldHVybiBmO1xufVxuZnVuY3Rpb24gVGkodCwgZSwgbiwgcikge1xuICByZXR1cm4gbiA9PT0gXCJob3Jpem9udGFsXCIgPyBCKHQucmlnaHQgLSBlLmxlZnQpIDw9IHIgfHwgQih0LmxlZnQgLSBlLnJpZ2h0KSA8PSByIHx8IHQubGVmdCA8PSBlLnJpZ2h0ICYmIGUubGVmdCA8PSB0LnJpZ2h0IDogbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gQih0LmJvdHRvbSAtIGUudG9wKSA8PSByIHx8IEIodC50b3AgLSBlLmJvdHRvbSkgPD0gciB8fCB0LnRvcCA8PSBlLmJvdHRvbSAmJiBlLnRvcCA8PSB0LmJvdHRvbSA6ICEwO1xufVxuZnVuY3Rpb24gcWwodCkge1xuICBjb25zdCBlID0gdC5zdGF0ZSwge1xuICAgIGVsZW1lbnRHdWlkZWxpbmVzOiBuID0gW11cbiAgfSA9IHQucHJvcHM7XG4gIGlmICghbi5sZW5ndGgpXG4gICAgcmV0dXJuIGUuZWxlbWVudFJlY3RzID0gW10sIFtdO1xuICBjb25zdCByID0gKGUuZWxlbWVudFJlY3RzIHx8IFtdKS5maWx0ZXIoKHUpID0+ICF1LnJlZnJlc2gpLCBzID0gbi5tYXAoKHUpID0+IHF0KHUpICYmIFwiZWxlbWVudFwiIGluIHUgPyB7XG4gICAgLi4udSxcbiAgICBlbGVtZW50OiBadCh1LmVsZW1lbnQsICEwKVxuICB9IDoge1xuICAgIGVsZW1lbnQ6IFp0KHUsICEwKVxuICB9KS5maWx0ZXIoKHUpID0+IHUuZWxlbWVudCksIHtcbiAgICBtYWludGFpbmVkOiBvLFxuICAgIGFkZGVkOiBpXG4gIH0gPSBWbChyLm1hcCgodSkgPT4gdS5lbGVtZW50KSwgcy5tYXAoKHUpID0+IHUuZWxlbWVudCkpLCBhID0gW107XG4gIG8uZm9yRWFjaCgoW3UsIGZdKSA9PiB7XG4gICAgYVtmXSA9IHJbdV07XG4gIH0pLCBVbCh0LCBpLm1hcCgodSkgPT4gc1t1XSkpLm1hcCgodSwgZikgPT4ge1xuICAgIGFbaVtmXV0gPSB1O1xuICB9KSwgZS5lbGVtZW50UmVjdHMgPSBhO1xuICBjb25zdCBjID0gY3ModC5wcm9wcy5lbGVtZW50U25hcERpcmVjdGlvbnMpLCBsID0gW107XG4gIHJldHVybiBhLmZvckVhY2goKHUpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50OiBmLFxuICAgICAgdG9wOiBkID0gYy50b3AsXG4gICAgICBsZWZ0OiBwID0gYy5sZWZ0LFxuICAgICAgcmlnaHQ6IGcgPSBjLnJpZ2h0LFxuICAgICAgYm90dG9tOiBoID0gYy5ib3R0b20sXG4gICAgICBjZW50ZXI6IHYgPSBjLmNlbnRlcixcbiAgICAgIG1pZGRsZTogbSA9IGMubWlkZGxlLFxuICAgICAgY2xhc3NOYW1lOiBTLFxuICAgICAgcmVjdDogeFxuICAgIH0gPSB1LCB7XG4gICAgICBob3Jpem9udGFsOiBDLFxuICAgICAgdmVydGljYWw6IEUsXG4gICAgICBob3Jpem9udGFsTmFtZXM6IEQsXG4gICAgICB2ZXJ0aWNhbE5hbWVzOiBSXG4gICAgfSA9IGxzKHtcbiAgICAgIHRvcDogZCxcbiAgICAgIHJpZ2h0OiBnLFxuICAgICAgbGVmdDogcCxcbiAgICAgIGJvdHRvbTogaCxcbiAgICAgIGNlbnRlcjogdixcbiAgICAgIG1pZGRsZTogbVxuICAgIH0sIHgpLCB5ID0geC50b3AsIE0gPSB4LmxlZnQsIFAgPSB4LnJpZ2h0IC0gTSwgXyA9IHguYm90dG9tIC0geSwgTyA9IFtQLCBfXTtcbiAgICBFLmZvckVhY2goKFQsIHcpID0+IHtcbiAgICAgIGwucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidmVydGljYWxcIixcbiAgICAgICAgZWxlbWVudDogZixcbiAgICAgICAgcG9zOiBbXG4gICAgICAgICAgdHQoVCwgMC4xKSxcbiAgICAgICAgICB5XG4gICAgICAgIF0sXG4gICAgICAgIHNpemU6IF8sXG4gICAgICAgIHNpemVzOiBPLFxuICAgICAgICBjbGFzc05hbWU6IFMsXG4gICAgICAgIGVsZW1lbnRSZWN0OiB1LFxuICAgICAgICBlbGVtZW50RGlyZWN0aW9uOiBxc1tSW3ddXSB8fCBSW3ddLFxuICAgICAgICBkaXJlY3Rpb246IFwiXCJcbiAgICAgIH0pO1xuICAgIH0pLCBDLmZvckVhY2goKFQsIHcpID0+IHtcbiAgICAgIGwucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBlbGVtZW50OiBmLFxuICAgICAgICBwb3M6IFtcbiAgICAgICAgICBNLFxuICAgICAgICAgIHR0KFQsIDAuMSlcbiAgICAgICAgXSxcbiAgICAgICAgc2l6ZTogUCxcbiAgICAgICAgc2l6ZXM6IE8sXG4gICAgICAgIGNsYXNzTmFtZTogUyxcbiAgICAgICAgZWxlbWVudFJlY3Q6IHUsXG4gICAgICAgIGVsZW1lbnREaXJlY3Rpb246IHFzW0Rbd11dIHx8IERbd10sXG4gICAgICAgIGRpcmVjdGlvbjogXCJcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pLCBsO1xufVxuZnVuY3Rpb24gc28odCwgZSkge1xuICByZXR1cm4gdCA/IHQubWFwKChuKSA9PiB7XG4gICAgY29uc3QgciA9IHF0KG4pID8gbiA6IHsgcG9zOiBuIH0sIHMgPSByLnBvcztcbiAgICByZXR1cm4gYW4ocykgPyByIDoge1xuICAgICAgLi4ucixcbiAgICAgIHBvczogZnQocywgZSlcbiAgICB9O1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gT2kodCwgZSwgbiwgciwgcyA9IDAsIG8gPSAwLCBpID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfSkge1xuICBjb25zdCBhID0gW10sIHtcbiAgICBsZWZ0OiBjLFxuICAgIHRvcDogbCxcbiAgICBib3R0b206IHUsXG4gICAgcmlnaHQ6IGZcbiAgfSA9IGksIGQgPSBuICsgZiAtIGMsIHAgPSByICsgdSAtIGw7XG4gIHJldHVybiBzbyh0LCBwKS5mb3JFYWNoKChnKSA9PiB7XG4gICAgYS5wdXNoKHtcbiAgICAgIHR5cGU6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgcG9zOiBbXG4gICAgICAgIGMsXG4gICAgICAgIHR0KGcucG9zIC0gbyArIGwsIDAuMSlcbiAgICAgIF0sXG4gICAgICBzaXplOiBkLFxuICAgICAgY2xhc3NOYW1lOiBnLmNsYXNzTmFtZSxcbiAgICAgIGRpcmVjdGlvbjogXCJcIlxuICAgIH0pO1xuICB9KSwgc28oZSwgZCkuZm9yRWFjaCgoZykgPT4ge1xuICAgIGEucHVzaCh7XG4gICAgICB0eXBlOiBcInZlcnRpY2FsXCIsXG4gICAgICBwb3M6IFtcbiAgICAgICAgdHQoZy5wb3MgLSBzICsgYywgMC4xKSxcbiAgICAgICAgbFxuICAgICAgXSxcbiAgICAgIHNpemU6IHAsXG4gICAgICBjbGFzc05hbWU6IGcuY2xhc3NOYW1lLFxuICAgICAgZGlyZWN0aW9uOiBcIlwiXG4gICAgfSk7XG4gIH0pLCBhO1xufVxuZnVuY3Rpb24gVWwodCwgZSkge1xuICBpZiAoIWUubGVuZ3RoKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgbiA9IHQucHJvcHMuZ3JvdXBhYmxlLCByID0gdC5zdGF0ZSwge1xuICAgIGNvbnRhaW5lckNsaWVudFJlY3Q6IHMsXG4gICAgLy8gdGFyZ2V0Q2xpZW50UmVjdDoge1xuICAgIC8vICAgICB0b3A6IGNsaWVudFRvcCxcbiAgICAvLyAgICAgbGVmdDogY2xpZW50TGVmdCxcbiAgICAvLyB9LFxuICAgIHJvb3RNYXRyaXg6IG8sXG4gICAgaXMzZDogaSxcbiAgICBvZmZzZXREZWx0YTogYVxuICB9ID0gciwgYyA9IGkgPyA0IDogMywgW2wsIHVdID0gdWwobywgcywgYyksIGYgPSBuID8gMCA6IGFbMF0sIGQgPSBuID8gMCA6IGFbMV07XG4gIHJldHVybiBlLm1hcCgocCkgPT4ge1xuICAgIGNvbnN0IGcgPSBwLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGggPSBnLmxlZnQgLSBsIC0gZiwgdiA9IGcudG9wIC0gdSAtIGQsIG0gPSB2ICsgZy5oZWlnaHQsIFMgPSBoICsgZy53aWR0aCwgW3gsIENdID0gV2UobywgW2gsIHZdLCBjKSwgW0UsIERdID0gV2UobywgW1MsIG1dLCBjKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucCxcbiAgICAgIHJlY3Q6IHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgcmlnaHQ6IEUsXG4gICAgICAgIHRvcDogQyxcbiAgICAgICAgYm90dG9tOiBELFxuICAgICAgICBjZW50ZXI6ICh4ICsgRSkgLyAyLFxuICAgICAgICBtaWRkbGU6IChDICsgRCkgLyAyXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiB5bih0KSB7XG4gIGNvbnN0IGUgPSB0LnN0YXRlLCBuID0gZS5jb250YWluZXIsIHIgPSB0LnByb3BzLnNuYXBDb250YWluZXIgfHwgbjtcbiAgaWYgKGUuc25hcENvbnRhaW5lciA9PT0gciAmJiBlLmd1aWRlbGluZXMgJiYgZS5ndWlkZWxpbmVzLmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHMgPSBlLmNvbnRhaW5lckNsaWVudFJlY3QsIG8gPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIHJpZ2h0OiAwXG4gIH07XG4gIGlmIChuICE9PSByKSB7XG4gICAgY29uc3QgaSA9IFp0KHIsICEwKTtcbiAgICBpZiAoaSkge1xuICAgICAgY29uc3QgYSA9IG5uKGkpLCBjID0gdW8oZSwgW1xuICAgICAgICBhLmxlZnQgLSBzLmxlZnQsXG4gICAgICAgIGEudG9wIC0gcy50b3BcbiAgICAgIF0pLCBsID0gdW8oZSwgW1xuICAgICAgICBhLnJpZ2h0IC0gcy5yaWdodCxcbiAgICAgICAgYS5ib3R0b20gLSBzLmJvdHRvbVxuICAgICAgXSk7XG4gICAgICBvLmxlZnQgPSB0dChjWzBdLCAxZS01KSwgby50b3AgPSB0dChjWzFdLCAxZS01KSwgby5yaWdodCA9IHR0KGxbMF0sIDFlLTUpLCBvLmJvdHRvbSA9IHR0KGxbMV0sIDFlLTUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZS5zbmFwQ29udGFpbmVyID0gciwgZS5zbmFwT2Zmc2V0ID0gbywgZS5ndWlkZWxpbmVzID0gSXIodCksIGUuZW5hYmxlU25hcCA9ICEwLCAhMDtcbn1cbmZ1bmN0aW9uIHdpKHQsIGUsIG4sIHIsIHMsIG8pIHtcbiAgY29uc3QgaSA9IE1lKHQsIGUsIG4sIG8gPyA0IDogMyksIGEgPSB5dChpLCByKTtcbiAgcmV0dXJuIGhzKGksIEsocywgYSkpO1xufVxuZnVuY3Rpb24gb28odCkge1xuICByZXR1cm4gdCA/IHQgLyBCKHQpIDogMDtcbn1cbmZ1bmN0aW9uIEtsKHQsIGUsIG4sIHIsIHMsIG8pIHtcbiAgY29uc3QgeyBmaXhlZERpcmVjdGlvbjogaSB9ID0gbywgYSA9IGdsKG4sIGksIHIpLCBjID0gZnModCwgZSwgbiwgciksIGwgPSBbXG4gICAgLi4uTWwoXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIGEsXG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIG9cbiAgICApLFxuICAgIC4uLmJpKFxuICAgICAgdCxcbiAgICAgIGMsXG4gICAgICBvXG4gICAgKVxuICBdLCB1ID0gJG4obCwgMCksIGYgPSAkbihsLCAxKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDoge1xuICAgICAgaXNCb3VuZDogdS5pc0JvdW5kLFxuICAgICAgb2Zmc2V0OiB1Lm9mZnNldFswXVxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICBpc0JvdW5kOiBmLmlzQm91bmQsXG4gICAgICBvZmZzZXQ6IGYub2Zmc2V0WzFdXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gWmwodCwgZSwgbiwgciwgcywgbywgaSwgYSwgYykge1xuICBjb25zdCBsID0geXQoZSwgaSksIHtcbiAgICBob3Jpem9udGFsOiB7IG9mZnNldDogdSB9LFxuICAgIHZlcnRpY2FsOiB7IG9mZnNldDogZiB9XG4gIH0gPSBabih0LCBhLCB7XG4gICAgdmVydGljYWw6IFtsWzBdXSxcbiAgICBob3Jpem9udGFsOiBbbFsxXV1cbiAgfSk7XG4gIGlmICh0dChmLCBDcikgfHwgdHQodSwgQ3IpKSB7XG4gICAgY29uc3QgW2QsIHBdID0gUXQoe1xuICAgICAgZGF0YXM6IGMsXG4gICAgICBkaXN0WDogLWYsXG4gICAgICBkaXN0WTogLXVcbiAgICB9KSwgZyA9IE1hdGgubWluKFxuICAgICAgcyB8fCAxIC8gMCxcbiAgICAgIG4gKyBpWzBdICogZFxuICAgICksIGggPSBNYXRoLm1pbihcbiAgICAgIG8gfHwgMSAvIDAsXG4gICAgICByICsgaVsxXSAqIHBcbiAgICApO1xuICAgIHJldHVybiBbZyAtIG4sIGggLSByXTtcbiAgfVxuICByZXR1cm4gWzAsIDBdO1xufVxuZnVuY3Rpb24gSWkodCwgZSwgbiwgciwgcywgbywgaSwgYSkge1xuICBjb25zdCBjID0ganQodC5zdGF0ZSksIGwgPSB0LnByb3BzLmtlZXBSYXRpbztcbiAgbGV0IHUgPSAwLCBmID0gMDtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCAyOyArK2QpIHtcbiAgICBjb25zdCBwID0gZSh1LCBmKSwge1xuICAgICAgd2lkdGg6IGcsXG4gICAgICBoZWlnaHQ6IGhcbiAgICB9ID0gS2woXG4gICAgICB0LFxuICAgICAgcCxcbiAgICAgIHMsXG4gICAgICBsLFxuICAgICAgaSxcbiAgICAgIGFcbiAgICApLCB2ID0gZy5pc0JvdW5kLCBtID0gaC5pc0JvdW5kO1xuICAgIGxldCBTID0gZy5vZmZzZXQsIHggPSBoLm9mZnNldDtcbiAgICBpZiAoZCA9PT0gMSAmJiAodiB8fCAoUyA9IDApLCBtIHx8ICh4ID0gMCkpLCBkID09PSAwICYmIGkgJiYgIXYgJiYgIW0pXG4gICAgICByZXR1cm4gWzAsIDBdO1xuICAgIGlmIChsKSB7XG4gICAgICBjb25zdCBDID0gQihTKSAqIChuID8gMSAvIG4gOiAxKSwgRSA9IEIoeCkgKiAociA/IDEgLyByIDogMSk7XG4gICAgICAodiAmJiBtID8gQyA8IEUgOiBtIHx8ICF2ICYmIEMgPCBFKSA/IFMgPSBuICogeCAvIHIgOiB4ID0gciAqIFMgLyBuO1xuICAgIH1cbiAgICB1ICs9IFMsIGYgKz0geDtcbiAgfVxuICBpZiAoIWwgJiYgc1swXSAmJiBzWzFdKSB7XG4gICAgY29uc3QgeyBtYXhXaWR0aDogZCwgbWF4SGVpZ2h0OiBwIH0gPSBfbChcbiAgICAgIHQsXG4gICAgICBjLFxuICAgICAgcyxcbiAgICAgIG8sXG4gICAgICBhXG4gICAgKSwgW2csIGhdID0gWmwoXG4gICAgICB0LFxuICAgICAgZSh1LCBmKS5tYXAoKHYpID0+IHYubWFwKChtKSA9PiB0dChtLCBDcikpKSxcbiAgICAgIG4gKyB1LFxuICAgICAgciArIGYsXG4gICAgICBkLFxuICAgICAgcCxcbiAgICAgIHMsXG4gICAgICBpLFxuICAgICAgYVxuICAgICk7XG4gICAgdSArPSBnLCBmICs9IGg7XG4gIH1cbiAgcmV0dXJuIFt1LCBmXTtcbn1cbmZ1bmN0aW9uIHRuKHQpIHtcbiAgcmV0dXJuIHQgPCAwICYmICh0ID0gdCAlIDM2MCArIDM2MCksIHQgJT0gMzYwLCB0O1xufVxuZnVuY3Rpb24gSmwodCwgZSkge1xuICBlID0gdG4oZSk7XG4gIGNvbnN0IG4gPSBNYXRoLmZsb29yKHQgLyAzNjApLCByID0gbiAqIDM2MCArIDM2MCAtIGUsIHMgPSBuICogMzYwICsgZTtcbiAgcmV0dXJuIEIodCAtIHIpIDwgQih0IC0gcykgPyByIDogcztcbn1cbmZ1bmN0aW9uIGRyKHQsIGUpIHtcbiAgdCA9IHRuKHQpLCBlID0gdG4oZSk7XG4gIGNvbnN0IG4gPSB0bih0IC0gZSk7XG4gIHJldHVybiBNYXRoLm1pbihuLCAzNjAgLSBuKTtcbn1cbmZ1bmN0aW9uIFFsKHQsIGUsIG4sIHIpIHtcbiAgY29uc3QgcyA9IHQucHJvcHMsIG8gPSBzW2hpXSA/PyA1LCBpID0gc1t2aV07XG4gIGlmIChYZSh0LCBcInJvdGF0YWJsZVwiKSkge1xuICAgIGNvbnN0IHsgcG9zMTogYSwgcG9zMjogYywgcG9zMzogbCwgcG9zNDogdSwgb3JpZ2luOiBmIH0gPSBlLCBkID0gbiAqIE1hdGguUEkgLyAxODAsIHAgPSBbYSwgYywgbCwgdV0ubWFwKChtKSA9PiBLKG0sIGYpKSwgZyA9IHAubWFwKChtKSA9PiBnbihtLCBkKSksIGggPSBbXG4gICAgICAuLi5pbCh0LCBwLCBnLCBmLCBuKSxcbiAgICAgIC4uLkVsKFxuICAgICAgICB0LFxuICAgICAgICBwLFxuICAgICAgICBnLFxuICAgICAgICBmLFxuICAgICAgICBuXG4gICAgICApXG4gICAgXTtcbiAgICBoLnNvcnQoKG0sIFMpID0+IEIobSAtIG4pIC0gQihTIC0gbikpO1xuICAgIGNvbnN0IHYgPSBoLmxlbmd0aCA+IDA7XG4gICAgaWYgKHYpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1NuYXA6IHYsXG4gICAgICAgIGRpc3Q6IHYgPyBoWzBdIDogblxuICAgICAgfTtcbiAgfVxuICBpZiAoaSAhPSBudWxsICYmIGkubGVuZ3RoICYmIG8pIHtcbiAgICBjb25zdCBjID0gaS5zbGljZSgpLnNvcnQoKGwsIHUpID0+IGRyKGwsIHIpIC0gZHIodSwgcikpWzBdO1xuICAgIGlmIChkcihjLCByKSA8PSBvKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNTbmFwOiAhMCxcbiAgICAgICAgZGlzdDogbiArIEpsKHIsIGMpIC0gclxuICAgICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU25hcDogITEsXG4gICAgZGlzdDogblxuICB9O1xufVxuZnVuY3Rpb24gdHUodCwgZSwgbiwgciwgcywgbywgaSkge1xuICBpZiAoIVhlKHQsIFwicmVzaXphYmxlXCIpKVxuICAgIHJldHVybiBbMCwgMF07XG4gIGNvbnN0IHsgZml4ZWREaXJlY3Rpb246IGEsIG5leHRBbGxNYXRyaXg6IGMgfSA9IGksIHsgYWxsTWF0cml4OiBsLCBpczNkOiB1IH0gPSB0LnN0YXRlO1xuICByZXR1cm4gSWkoXG4gICAgdCxcbiAgICAoZiwgZCkgPT4gd2koXG4gICAgICBjIHx8IGwsXG4gICAgICBlICsgZixcbiAgICAgIG4gKyBkLFxuICAgICAgYSxcbiAgICAgIHMsXG4gICAgICB1XG4gICAgKSxcbiAgICBlLFxuICAgIG4sXG4gICAgcixcbiAgICBzLFxuICAgIG8sXG4gICAgaVxuICApO1xufVxuZnVuY3Rpb24gZXUodCwgZSwgbiwgciwgcykge1xuICBpZiAoIVhlKHQsIFwic2NhbGFibGVcIikpXG4gICAgcmV0dXJuIFswLCAwXTtcbiAgY29uc3QgeyBzdGFydE9mZnNldFdpZHRoOiBvLCBzdGFydE9mZnNldEhlaWdodDogaSwgZml4ZWRQb3NpdGlvbjogYSwgZml4ZWREaXJlY3Rpb246IGMsIGlzM2Q6IGwgfSA9IHMsIHUgPSBJaShcbiAgICB0LFxuICAgIChmLCBkKSA9PiB3aShcbiAgICAgIFljKFxuICAgICAgICBzLFxuICAgICAgICBhdChlLCBbZiAvIG8sIGQgLyBpXSlcbiAgICAgICksXG4gICAgICBvLFxuICAgICAgaSxcbiAgICAgIGMsXG4gICAgICBhLFxuICAgICAgbFxuICAgICksXG4gICAgbyxcbiAgICBpLFxuICAgIG4sXG4gICAgYSxcbiAgICByLFxuICAgIHNcbiAgKTtcbiAgcmV0dXJuIFt1WzBdIC8gbywgdVsxXSAvIGldO1xufVxuZnVuY3Rpb24gbnUodCwgZSkge1xuICBlLmFic29sdXRlUG9zZXMgPSBqdCh0LnN0YXRlKTtcbn1cbmZ1bmN0aW9uIGlvKHQpIHtcbiAgY29uc3QgZSA9IFtdO1xuICByZXR1cm4gdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgbi5ndWlkZWxpbmVJbmZvcy5mb3JFYWNoKCh7IGd1aWRlbGluZTogciB9KSA9PiB7XG4gICAgICBrdChlLCAocykgPT4gcy5ndWlkZWxpbmUgPT09IHIpIHx8IChyLmRpcmVjdGlvbiA9IFwiXCIsIGUucHVzaCh7IGd1aWRlbGluZTogciwgcG9zSW5mbzogbiB9KSk7XG4gICAgfSk7XG4gIH0pLCBlLm1hcCgoeyBndWlkZWxpbmU6IG4sIHBvc0luZm86IHIgfSkgPT4gKHtcbiAgICAuLi5uLFxuICAgIGRpcmVjdGlvbjogci5kaXJlY3Rpb25cbiAgfSkpO1xufVxuZnVuY3Rpb24gYW8odCwgZSwgbiwgciwgcywgbykge1xuICBjb25zdCB7XG4gICAgdmVydGljYWw6IGksXG4gICAgaG9yaXpvbnRhbDogYVxuICB9ID0gYXMoXG4gICAgVW4odCwgbyksXG4gICAgZSxcbiAgICBuXG4gICksIGMgPSBCZSgpO1xuICBpLmZvckVhY2goKGQpID0+IHtcbiAgICBkLmlzQm91bmQgJiYgKGQuZGlyZWN0aW9uID09PSBcInN0YXJ0XCIgJiYgKGMubGVmdCA9ICEwKSwgZC5kaXJlY3Rpb24gPT09IFwiZW5kXCIgJiYgKGMucmlnaHQgPSAhMCksIHIucHVzaCh7XG4gICAgICB0eXBlOiBcImJvdW5kc1wiLFxuICAgICAgcG9zOiBkLnBvc1xuICAgIH0pKTtcbiAgfSksIGEuZm9yRWFjaCgoZCkgPT4ge1xuICAgIGQuaXNCb3VuZCAmJiAoZC5kaXJlY3Rpb24gPT09IFwic3RhcnRcIiAmJiAoYy50b3AgPSAhMCksIGQuZGlyZWN0aW9uID09PSBcImVuZFwiICYmIChjLmJvdHRvbSA9ICEwKSwgcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiYm91bmRzXCIsXG4gICAgICBwb3M6IGQucG9zXG4gICAgfSkpO1xuICB9KTtcbiAgY29uc3Qge1xuICAgIGJvdW5kTWFwOiBsLFxuICAgIHZlcnRpY2FsOiB1LFxuICAgIGhvcml6b250YWw6IGZcbiAgfSA9IENsKHQpO1xuICByZXR1cm4gdS5mb3JFYWNoKChkKSA9PiB7XG4gICAgbmUoXG4gICAgICByLFxuICAgICAgKHsgdHlwZTogcCwgcG9zOiBnIH0pID0+IHAgPT09IFwiYm91bmRzXCIgJiYgZyA9PT0gZFxuICAgICkgPj0gMCB8fCByLnB1c2goe1xuICAgICAgdHlwZTogXCJib3VuZHNcIixcbiAgICAgIHBvczogZFxuICAgIH0pO1xuICB9KSwgZi5mb3JFYWNoKChkKSA9PiB7XG4gICAgbmUoXG4gICAgICBzLFxuICAgICAgKHsgdHlwZTogcCwgcG9zOiBnIH0pID0+IHAgPT09IFwiYm91bmRzXCIgJiYgZyA9PT0gZFxuICAgICkgPj0gMCB8fCBzLnB1c2goe1xuICAgICAgdHlwZTogXCJib3VuZHNcIixcbiAgICAgIHBvczogZFxuICAgIH0pO1xuICB9KSwge1xuICAgIGJvdW5kTWFwOiBjLFxuICAgIGlubmVyQm91bmRNYXA6IGxcbiAgfTtcbn1cbmNvbnN0IHJ1ID0geHMoXCJcIiwgW1wicmVzaXphYmxlXCIsIFwic2NhbGFibGVcIl0pLCBzdSA9IHtcbiAgbmFtZTogXCJzbmFwcGFibGVcIixcbiAgZHJhZ1JlbGF0aW9uOiBcInN0cm9uZ1wiLFxuICBwcm9wczogW1xuICAgIFwic25hcHBhYmxlXCIsXG4gICAgXCJzbmFwQ29udGFpbmVyXCIsXG4gICAgXCJzbmFwRGlyZWN0aW9uc1wiLFxuICAgIFwiZWxlbWVudFNuYXBEaXJlY3Rpb25zXCIsXG4gICAgXCJzbmFwR2FwXCIsXG4gICAgXCJzbmFwR3JpZFdpZHRoXCIsXG4gICAgXCJzbmFwR3JpZEhlaWdodFwiLFxuICAgIFwiaXNEaXNwbGF5U25hcERpZ2l0XCIsXG4gICAgXCJpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdFwiLFxuICAgIFwiaXNEaXNwbGF5R3JpZEd1aWRlbGluZXNcIixcbiAgICBcInNuYXBEaWdpdFwiLFxuICAgIFwic25hcFRocmVzaG9sZFwiLFxuICAgIFwic25hcFJlbmRlclRocmVzaG9sZFwiLFxuICAgIFwic25hcEdyaWRBbGxcIixcbiAgICBoaSxcbiAgICB2aSxcbiAgICBtaSxcbiAgICB4aSxcbiAgICBcImhvcml6b250YWxHdWlkZWxpbmVzXCIsXG4gICAgXCJ2ZXJ0aWNhbEd1aWRlbGluZXNcIixcbiAgICBcImVsZW1lbnRHdWlkZWxpbmVzXCIsXG4gICAgXCJib3VuZHNcIixcbiAgICBcImlubmVyQm91bmRzXCIsXG4gICAgXCJzbmFwRGlzdEZvcm1hdFwiLFxuICAgIFwibWF4U25hcEVsZW1lbnRHdWlkZWxpbmVEaXN0YW5jZVwiLFxuICAgIFwibWF4U25hcEVsZW1lbnRHYXBEaXN0YW5jZVwiXG4gIF0sXG4gIGV2ZW50czogW1wic25hcFwiLCBcImJvdW5kXCJdLFxuICBjc3M6IFtcbiAgICBgOmhvc3Qge1xuLS1ib3VuZHMtY29sb3I6ICNkNjY7XG59XG4uZ3VpZGVsaW5lIHtcbnBvaW50ZXItZXZlbnRzOiBub25lO1xuei1pbmRleDogMjtcbn1cbi5ndWlkZWxpbmUuYm91bmRzIHtcbmJhY2tncm91bmQ6ICNkNjY7XG5iYWNrZ3JvdW5kOiB2YXIoLS1ib3VuZHMtY29sb3IpO1xufVxuLmd1aWRlbGluZS1ncm91cCB7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG50b3A6IDA7XG5sZWZ0OiAwO1xufVxuLmd1aWRlbGluZS1ncm91cCAuc2l6ZS12YWx1ZSB7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG5jb2xvcjogI2Y1NTtcbmZvbnQtc2l6ZTogMTJweDtcbmZvbnQtc2l6ZTogY2FsYygxMnB4ICogdmFyKC0tem9vbSkpO1xuZm9udC13ZWlnaHQ6IGJvbGQ7XG59XG4uZ3VpZGVsaW5lLWdyb3VwLmhvcml6b250YWwgLnNpemUtdmFsdWUge1xudHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XG50cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG5sZWZ0OiA1MCU7XG5ib3R0b206IDVweDtcbmJvdHRvbTogY2FsYygycHggKyAzcHggKiB2YXIoLS16b29tKSk7XG59XG4uZ3VpZGVsaW5lLWdyb3VwLnZlcnRpY2FsIC5zaXplLXZhbHVlIHtcbnRyYW5zZm9ybS1vcmlnaW46IDAlIDUwJTtcbnRvcDogNTAlO1xudHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xubGVmdDogNXB4O1xubGVmdDogY2FsYygycHggKyAzcHggKiB2YXIoLS16b29tKSk7XG59XG4uZ3VpZGVsaW5lLmdhcCB7XG5iYWNrZ3JvdW5kOiAjZjU1O1xufVxuLnNpemUtdmFsdWUuZ2FwIHtcbmNvbG9yOiAjZjU1O1xufVxuYFxuICBdLFxuICByZW5kZXIodCwgZSkge1xuICAgIGNvbnN0IG4gPSB0LnN0YXRlLCB7XG4gICAgICB0b3A6IHIsXG4gICAgICBsZWZ0OiBzLFxuICAgICAgcG9zMTogbyxcbiAgICAgIHBvczI6IGksXG4gICAgICBwb3MzOiBhLFxuICAgICAgcG9zNDogYyxcbiAgICAgIHNuYXBSZW5kZXJJbmZvOiBsXG4gICAgfSA9IG4sIHtcbiAgICAgIHNuYXBSZW5kZXJUaHJlc2hvbGQ6IHUgPSAxXG4gICAgfSA9IHQucHJvcHM7XG4gICAgaWYgKCFsIHx8ICFsLnJlbmRlciB8fCAhWGUodCwgXCJcIikpXG4gICAgICByZXR1cm4gQWUoXG4gICAgICAgIHQsXG4gICAgICAgIFwiYm91bmRNYXBcIixcbiAgICAgICAgQmUoKSxcbiAgICAgICAgKHopID0+IEpTT04uc3RyaW5naWZ5KHopXG4gICAgICApLCBBZShcbiAgICAgICAgdCxcbiAgICAgICAgXCJpbm5lckJvdW5kTWFwXCIsXG4gICAgICAgIEJlKCksXG4gICAgICAgICh6KSA9PiBKU09OLnN0cmluZ2lmeSh6KVxuICAgICAgKSwgW107XG4gICAgbi5ndWlkZWxpbmVzID0gSXIodCk7XG4gICAgY29uc3QgZiA9IE1hdGgubWluKG9bMF0sIGlbMF0sIGFbMF0sIGNbMF0pLCBkID0gTWF0aC5taW4ob1sxXSwgaVsxXSwgYVsxXSwgY1sxXSksIHAgPSBsLmV4dGVybmFsUG9zZXMgfHwgW10sIGcgPSBqdCh0LnN0YXRlKSwgaCA9IFtdLCB2ID0gW10sIG0gPSBbXSwgUyA9IFtdLCB4ID0gW10sIHsgd2lkdGg6IEMsIGhlaWdodDogRSwgdG9wOiBELCBsZWZ0OiBSLCBib3R0b206IHksIHJpZ2h0OiBNIH0gPSBZdChnKSwgUCA9IHsgbGVmdDogUiwgcmlnaHQ6IE0sIHRvcDogRCwgYm90dG9tOiB5LCBjZW50ZXI6IChSICsgTSkgLyAyLCBtaWRkbGU6IChEICsgeSkgLyAyIH0sIF8gPSBwLmxlbmd0aCA+IDAsIE8gPSBfID8gWXQocCkgOiB7fTtcbiAgICBpZiAoIWwucmVxdWVzdCkge1xuICAgICAgaWYgKGwuZGlyZWN0aW9uICYmIHgucHVzaChcbiAgICAgICAgcGwoXG4gICAgICAgICAgdCxcbiAgICAgICAgICBnLFxuICAgICAgICAgIGwuZGlyZWN0aW9uLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgdVxuICAgICAgICApXG4gICAgICApLCBsLnNuYXApIHtcbiAgICAgICAgY29uc3QgeiA9IFl0KGcpO1xuICAgICAgICBsLmNlbnRlciAmJiAoei5taWRkbGUgPSAoei50b3AgKyB6LmJvdHRvbSkgLyAyLCB6LmNlbnRlciA9ICh6LmxlZnQgKyB6LnJpZ2h0KSAvIDIpLCB4LnB1c2goVXModCwgeiwgdSwgdSkpO1xuICAgICAgfVxuICAgICAgXyAmJiAobC5jZW50ZXIgJiYgKE8ubWlkZGxlID0gKE8udG9wICsgTy5ib3R0b20pIC8gMiwgTy5jZW50ZXIgPSAoTy5sZWZ0ICsgTy5yaWdodCkgLyAyKSwgeC5wdXNoKFVzKHQsIE8sIHUsIHUpKSksIHguZm9yRWFjaCgoeikgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdmVydGljYWw6IHsgcG9zSW5mb3M6IE4gfSxcbiAgICAgICAgICBob3Jpem9udGFsOiB7IHBvc0luZm9zOiBaIH1cbiAgICAgICAgfSA9IHo7XG4gICAgICAgIGgucHVzaChcbiAgICAgICAgICAuLi5OLmZpbHRlcigoeyBndWlkZWxpbmVJbmZvczogWSB9KSA9PiBZLnNvbWUoKHsgZ3VpZGVsaW5lOiBXIH0pID0+ICFXLmhpZGUpKS5tYXAoXG4gICAgICAgICAgICAoWSkgPT4gKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzbmFwXCIsXG4gICAgICAgICAgICAgIHBvczogWS5wb3NcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApLCB2LnB1c2goXG4gICAgICAgICAgLi4uWi5maWx0ZXIoKHsgZ3VpZGVsaW5lSW5mb3M6IFkgfSkgPT4gWS5zb21lKCh7IGd1aWRlbGluZTogVyB9KSA9PiAhVy5oaWRlKSkubWFwKFxuICAgICAgICAgICAgKFkpID0+ICh7XG4gICAgICAgICAgICAgIHR5cGU6IFwic25hcFwiLFxuICAgICAgICAgICAgICBwb3M6IFkucG9zXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKSwgbS5wdXNoKC4uLmlvKE4pKSwgUy5wdXNoKC4uLmlvKFopKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBib3VuZE1hcDogVCxcbiAgICAgIGlubmVyQm91bmRNYXA6IHdcbiAgICB9ID0gYW8oXG4gICAgICB0LFxuICAgICAgW1IsIE1dLFxuICAgICAgW0QsIHldLFxuICAgICAgaCxcbiAgICAgIHZcbiAgICApO1xuICAgIF8gJiYgYW8oXG4gICAgICB0LFxuICAgICAgW08ubGVmdCwgTy5yaWdodF0sXG4gICAgICBbTy50b3AsIE8uYm90dG9tXSxcbiAgICAgIGgsXG4gICAgICB2LFxuICAgICAgbC5leHRlcm5hbEJvdW5kc1xuICAgICk7XG4gICAgY29uc3QgayA9IFsuLi5tLCAuLi5TXSwgSSA9IGsuZmlsdGVyKCh6KSA9PiB6LmVsZW1lbnQgJiYgIXouZ2FwUmVjdHMpLCAkID0gay5maWx0ZXIoKHopID0+IHouZ2FwUmVjdHMpLnNvcnQoKHosIE4pID0+IHouZ2FwIC0gTi5nYXApO1xuICAgIGooXG4gICAgICB0LFxuICAgICAgXCJvblNuYXBcIixcbiAgICAgIHtcbiAgICAgICAgZ3VpZGVsaW5lczogay5maWx0ZXIoKHsgZWxlbWVudDogeiB9KSA9PiAheiksXG4gICAgICAgIGVsZW1lbnRzOiBJLFxuICAgICAgICBnYXBzOiAkXG4gICAgICB9LFxuICAgICAgITBcbiAgICApO1xuICAgIGNvbnN0IEcgPSBBZShcbiAgICAgIHQsXG4gICAgICBcImJvdW5kTWFwXCIsXG4gICAgICBULFxuICAgICAgKHopID0+IEpTT04uc3RyaW5naWZ5KHopLFxuICAgICAgQmUoKVxuICAgICksIEwgPSBBZShcbiAgICAgIHQsXG4gICAgICBcImlubmVyQm91bmRNYXBcIixcbiAgICAgIHcsXG4gICAgICAoeikgPT4gSlNPTi5zdHJpbmdpZnkoeiksXG4gICAgICBCZSgpXG4gICAgKTtcbiAgICByZXR1cm4gKFQgPT09IEcgfHwgdyA9PT0gTCkgJiYgaihcbiAgICAgIHQsXG4gICAgICBcIm9uQm91bmRcIixcbiAgICAgIHtcbiAgICAgICAgYm91bmRzOiBULFxuICAgICAgICBpbm5lckJvdW5kczogd1xuICAgICAgfSxcbiAgICAgICEwXG4gICAgKSwgW1xuICAgICAgLi4uemwoXG4gICAgICAgIHQsXG4gICAgICAgIEksXG4gICAgICAgIFtmLCBkXSxcbiAgICAgICAgUCxcbiAgICAgICAgZVxuICAgICAgKSxcbiAgICAgIC4uLkFsKFxuICAgICAgICB0LFxuICAgICAgICAkLFxuICAgICAgICBbZiwgZF0sXG4gICAgICAgIFAsXG4gICAgICAgIGVcbiAgICAgICksXG4gICAgICAuLi5ybyhcbiAgICAgICAgdCxcbiAgICAgICAgXCJob3Jpem9udGFsXCIsXG4gICAgICAgIFMsXG4gICAgICAgIFtzLCByXSxcbiAgICAgICAgUCxcbiAgICAgICAgZVxuICAgICAgKSxcbiAgICAgIC4uLnJvKFxuICAgICAgICB0LFxuICAgICAgICBcInZlcnRpY2FsXCIsXG4gICAgICAgIG0sXG4gICAgICAgIFtzLCByXSxcbiAgICAgICAgUCxcbiAgICAgICAgZVxuICAgICAgKSxcbiAgICAgIC4uLm5vKFxuICAgICAgICB0LFxuICAgICAgICBcImhvcml6b250YWxcIixcbiAgICAgICAgdixcbiAgICAgICAgZixcbiAgICAgICAgcixcbiAgICAgICAgQyxcbiAgICAgICAgMCxcbiAgICAgICAgZVxuICAgICAgKSxcbiAgICAgIC4uLm5vKFxuICAgICAgICB0LFxuICAgICAgICBcInZlcnRpY2FsXCIsXG4gICAgICAgIGgsXG4gICAgICAgIGQsXG4gICAgICAgIHMsXG4gICAgICAgIEUsXG4gICAgICAgIDEsXG4gICAgICAgIGVcbiAgICAgIClcbiAgICBdO1xuICB9LFxuICBkcmFnU3RhcnQodCwgZSkge1xuICAgIHQuc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XG4gICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdCxcbiAgICAgIHNuYXA6ICEwLFxuICAgICAgY2VudGVyOiAhMFxuICAgIH0sIHluKHQpO1xuICB9LFxuICBkcmFnKHQpIHtcbiAgICBjb25zdCBlID0gdC5zdGF0ZTtcbiAgICB5bih0KSB8fCAoZS5ndWlkZWxpbmVzID0gSXIodCkpLCBlLnNuYXBSZW5kZXJJbmZvICYmIChlLnNuYXBSZW5kZXJJbmZvLnJlbmRlciA9ICEwKTtcbiAgfSxcbiAgcGluY2hTdGFydCh0KSB7XG4gICAgdGhpcy51bnNldCh0KTtcbiAgfSxcbiAgZHJhZ0VuZCh0KSB7XG4gICAgdGhpcy51bnNldCh0KTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb24odCwgZSkge1xuICAgIGlmIChydSh0LCBlKSB8fCBPcih0LCBlKSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBpZiAoIWUuaXNSZXF1ZXN0ICYmIGUuaW5wdXRFdmVudClcbiAgICAgIHJldHVybiBidChlLmlucHV0RXZlbnQudGFyZ2V0LCBVKFwic25hcC1jb250cm9sXCIpKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydCh0KSB7XG4gICAgdC5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IG51bGwsIHluKHQpO1xuICB9LFxuICBkcmFnQ29udHJvbCh0KSB7XG4gICAgdGhpcy5kcmFnKHQpO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZCh0KSB7XG4gICAgdGhpcy51bnNldCh0KTtcbiAgfSxcbiAgZHJhZ0dyb3VwU3RhcnQodCwgZSkge1xuICAgIHRoaXMuZHJhZ1N0YXJ0KHQsIGUpO1xuICB9LFxuICBkcmFnR3JvdXAodCkge1xuICAgIHRoaXMuZHJhZyh0KTtcbiAgfSxcbiAgZHJhZ0dyb3VwRW5kKHQpIHtcbiAgICB0aGlzLnVuc2V0KHQpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQodCkge1xuICAgIHQuc3RhdGUuc25hcFJlbmRlckluZm8gPSBudWxsLCB5bih0KTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbCh0KSB7XG4gICAgdGhpcy5kcmFnKHQpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sRW5kKHQpIHtcbiAgICB0aGlzLnVuc2V0KHQpO1xuICB9LFxuICB1bnNldCh0KSB7XG4gICAgY29uc3QgZSA9IHQuc3RhdGU7XG4gICAgZS5lbmFibGVTbmFwID0gITEsIGUuZ3VpZGVsaW5lcyA9IFtdLCBlLnNuYXBSZW5kZXJJbmZvID0gbnVsbCwgZS5lbGVtZW50UmVjdHMgPSBbXTtcbiAgfVxufTtcbmZ1bmN0aW9uIG91KHQsIGUpIHtcbiAgcmV0dXJuIFt0WzBdICogZVswXSwgdFsxXSAqIGVbMV1dO1xufVxuZnVuY3Rpb24gVSguLi50KSB7XG4gIHJldHVybiBjYyhIciwgLi4udCk7XG59XG5mdW5jdGlvbiBCaSh0KSB7XG4gIHQoKTtcbn1cbmZ1bmN0aW9uIGl1KHQpIHtcbiAgcmV0dXJuICF0IHx8IHQgPT09IFwibm9uZVwiID8gWzEsIDAsIDAsIDEsIDAsIDBdIDogcXQodCkgPyB0IDogbG4odCk7XG59XG5mdW5jdGlvbiBlbih0LCBlLCBuKSB7XG4gIHJldHVybiBBbihcbiAgICBlLFxuICAgIENlKG4sIGUpLFxuICAgIHQsXG4gICAgQ2UoXG4gICAgICBuLm1hcCgocikgPT4gLXIpLFxuICAgICAgZVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGF1KHQsIGUsIG4pIHtcbiAgcmV0dXJuIGUgPT09IFwiJVwiID8gZ3ModC5vd25lclNWR0VsZW1lbnQpW24gPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSAvIDEwMCA6IDE7XG59XG5mdW5jdGlvbiBjdSh0KSB7XG4gIHJldHVybiBsdSh2cyh0LCBcIjpiZWZvcmVcIikpLm1hcCgobiwgcikgPT4ge1xuICAgIGNvbnN0IHsgdmFsdWU6IHMsIHVuaXQ6IG8gfSA9IHBuKG4pO1xuICAgIHJldHVybiBzICogYXUodCwgbywgciA9PT0gMCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gTG4odCkge1xuICByZXR1cm4gdCA/IHQuc3BsaXQoXCIgXCIpIDogW1wiMFwiLCBcIjBcIl07XG59XG5mdW5jdGlvbiBsdSh0KSB7XG4gIHJldHVybiBMbih0LnRyYW5zZm9ybU9yaWdpbik7XG59XG5mdW5jdGlvbiB6aSh0KSB7XG4gIGNvbnN0IG4gPSBHdCh0KShcInRyYW5zZm9ybVwiKTtcbiAgaWYgKG4gJiYgbiAhPT0gXCJub25lXCIpXG4gICAgcmV0dXJuIG47XG4gIGlmIChcInRyYW5zZm9ybVwiIGluIHQpIHtcbiAgICBjb25zdCBzID0gdC50cmFuc2Zvcm0uYmFzZVZhbDtcbiAgICBpZiAoIXMpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBjb25zdCBvID0gcy5sZW5ndGg7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgY29uc3QgaSA9IFtdO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgbzsgKythKSB7XG4gICAgICBjb25zdCBjID0gc1thXS5tYXRyaXg7XG4gICAgICBpLnB1c2goXG4gICAgICAgIGBtYXRyaXgoJHtbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIl0ubWFwKChsKSA9PiBjW2xdKS5qb2luKFwiLCBcIil9KWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBpLmpvaW4oXCIgXCIpO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gZm4odCwgZSwgbiwgciwgcykge1xuICB2YXIgaCwgdjtcbiAgY29uc3QgbyA9IGVzKHQpIHx8IGZlKHQpO1xuICBsZXQgaSA9ICExLCBhLCBjO1xuICBpZiAoIXQgfHwgbilcbiAgICBhID0gdDtcbiAgZWxzZSB7XG4gICAgY29uc3QgbSA9IChoID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5hc3NpZ25lZFNsb3QpID09IG51bGwgPyB2b2lkIDAgOiBoLnBhcmVudEVsZW1lbnQsIFMgPSB0LnBhcmVudEVsZW1lbnQ7XG4gICAgbSA/IChpID0gITAsIGMgPSBTLCBhID0gbSkgOiBhID0gUztcbiAgfVxuICBsZXQgbCA9ICExLCB1ID0gdCA9PT0gZSB8fCBhID09PSBlLCBmID0gXCJyZWxhdGl2ZVwiLCBkID0gMTtcbiAgY29uc3QgcCA9IHBhcnNlRmxvYXQocyA9PSBudWxsID8gdm9pZCAwIDogcyhcInpvb21cIikpIHx8IDEsIGcgPSBzID09IG51bGwgPyB2b2lkIDAgOiBzKFwicG9zaXRpb25cIik7XG4gIGZvciAoOyBhICYmIGEgIT09IG87ICkge1xuICAgIGUgPT09IGEgJiYgKHUgPSAhMCk7XG4gICAgY29uc3QgbSA9IEd0KGEpLCBTID0gYS50YWdOYW1lLnRvTG93ZXJDYXNlKCksIHggPSB6aShhKSwgQyA9IG0oXCJ3aWxsQ2hhbmdlXCIpLCBFID0gcGFyc2VGbG9hdChtKFwiem9vbVwiKSkgfHwgMTtcbiAgICBpZiAoZiA9IG0oXCJwb3NpdGlvblwiKSwgciAmJiBFICE9PSAxKSB7XG4gICAgICBkID0gRTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAvLyBvZmZzZXRQYXJlbnQgaXMgdGhlIHBhcmVudEVsZW1lbnQgaWYgdGhlIHRhcmdldCdzIHpvb20gaXMgbm90IDEgYW5kIG5vdCBhYnNvbHV0ZS5cbiAgICAgICFuICYmIHIgJiYgcCAhPT0gMSAmJiBnICYmIGcgIT09IFwiYWJzb2x1dGVcIiB8fCBTID09PSBcInN2Z1wiIHx8IFMgPT09IFwiZm9yZWlnbm9iamVjdFwiIHx8IGYgIT09IFwic3RhdGljXCIgfHwgeCAmJiB4ICE9PSBcIm5vbmVcIiB8fCBDID09PSBcInRyYW5zZm9ybVwiXG4gICAgKVxuICAgICAgYnJlYWs7XG4gICAgY29uc3QgRCA9ICh2ID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5hc3NpZ25lZFNsb3QpID09IG51bGwgPyB2b2lkIDAgOiB2LnBhcmVudE5vZGUsIFIgPSBhLnBhcmVudE5vZGU7XG4gICAgRCAmJiAoaSA9ICEwLCBjID0gUik7XG4gICAgY29uc3QgeSA9IFI7XG4gICAgaWYgKHkgJiYgeS5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgIGEgPSB5Lmhvc3QsIGwgPSAhMCwgZiA9IEd0KGEpKFwicG9zaXRpb25cIik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYSA9IHksIGYgPSBcInJlbGF0aXZlXCI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvZmZzZXRab29tOiBkLFxuICAgIGhhc1Nsb3Q6IGksXG4gICAgcGFyZW50U2xvdEVsZW1lbnQ6IGMsXG4gICAgaXNDdXN0b21FbGVtZW50OiBsLFxuICAgIGlzU3RhdGljOiBmID09PSBcInN0YXRpY1wiLFxuICAgIGlzRW5kOiB1IHx8ICFhIHx8IGEgPT09IG8sXG4gICAgb2Zmc2V0UGFyZW50OiBhIHx8IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIHV1KHQsIGUpIHtcbiAgY29uc3QgbiA9IHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgciA9IHQub2Zmc2V0TGVmdCwgcyA9IHQub2Zmc2V0VG9wO1xuICBjb25zdCBvID0gR3QodCksIGkgPSBLcihyKTtcbiAgbGV0IGEgPSAhaSwgYywgbDtcbiAgcmV0dXJuICFhICYmIChuICE9PSBcInN2Z1wiIHx8IHQub3duZXJTVkdFbGVtZW50KSA/IChjID0gRm8gPyBjdSh0KSA6IExuKG8oXCJ0cmFuc2Zvcm1PcmlnaW5cIikpLm1hcChcbiAgICAodSkgPT4gcGFyc2VGbG9hdCh1KVxuICApLCBsID0gYy5zbGljZSgpLCBhID0gITAsIG4gPT09IFwic3ZnXCIgPyAociA9IDAsIHMgPSAwKSA6IFtyLCBzLCBjWzBdLCBjWzFdXSA9IHB1KFxuICAgIHQsXG4gICAgYyxcbiAgICB0ID09PSBlICYmIGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImdcIlxuICApKSA6IChjID0gTG4obyhcInRyYW5zZm9ybU9yaWdpblwiKSkubWFwKFxuICAgICh1KSA9PiBwYXJzZUZsb2F0KHUpXG4gICksIGwgPSBjLnNsaWNlKCkpLCB7XG4gICAgdGFnTmFtZTogbixcbiAgICBpc1NWRzogaSxcbiAgICBoYXNPZmZzZXQ6IGEsXG4gICAgb2Zmc2V0OiBbciB8fCAwLCBzIHx8IDBdLFxuICAgIG9yaWdpbjogYyxcbiAgICB0YXJnZXRPcmlnaW46IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIEFpKHQsIGUpIHtcbiAgY29uc3QgbiA9IEd0KHQpLCByID0gR3QoZmUodCkpLCBzID0gcihcInBvc2l0aW9uXCIpO1xuICBpZiAoIWUgJiYgKCFzIHx8IHMgPT09IFwic3RhdGljXCIpKVxuICAgIHJldHVybiBbMCwgMF07XG4gIGxldCBvID0gcGFyc2VJbnQocihcIm1hcmdpbkxlZnRcIiksIDEwKSwgaSA9IHBhcnNlSW50KHIoXCJtYXJnaW5Ub3BcIiksIDEwKTtcbiAgcmV0dXJuIG4oXCJwb3NpdGlvblwiKSA9PT0gXCJhYnNvbHV0ZVwiICYmICgobihcInRvcFwiKSAhPT0gXCJhdXRvXCIgfHwgbihcImJvdHRvbVwiKSAhPT0gXCJhdXRvXCIpICYmIChpID0gMCksIChuKFwibGVmdFwiKSAhPT0gXCJhdXRvXCIgfHwgbihcInJpZ2h0XCIpICE9PSBcImF1dG9cIikgJiYgKG8gPSAwKSksIFtvLCBpXTtcbn1cbmZ1bmN0aW9uIEJyKHQpIHtcbiAgdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgY29uc3QgbiA9IGUubWF0cml4O1xuICAgIG4gJiYgKGUubWF0cml4ID0gVXQobiwgMywgNCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZ1KHQpIHtcbiAgbGV0IGUgPSB0LnBhcmVudEVsZW1lbnQsIG4gPSAhMTtcbiAgY29uc3QgciA9IGZlKHQpO1xuICBmb3IgKDsgZTsgKSB7XG4gICAgY29uc3QgcyA9IHZzKGUpLnRyYW5zZm9ybTtcbiAgICBpZiAocyAmJiBzICE9PSBcIm5vbmVcIikge1xuICAgICAgbiA9ICEwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChlID09PSByKVxuICAgICAgYnJlYWs7XG4gICAgZSA9IGUucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpeGVkQ29udGFpbmVyOiBlIHx8IHIsXG4gICAgaGFzVHJhbnNmb3JtOiBuXG4gIH07XG59XG5mdW5jdGlvbiBKbih0LCBlID0gdC5sZW5ndGggPiA5KSB7XG4gIHJldHVybiBgJHtlID8gXCJtYXRyaXgzZFwiIDogXCJtYXRyaXhcIn0oJHtlaSh0LCAhZSkuam9pbihcIixcIil9KWA7XG59XG5mdW5jdGlvbiBncyh0KSB7XG4gIGNvbnN0IGUgPSB0LmNsaWVudFdpZHRoLCBuID0gdC5jbGllbnRIZWlnaHQ7XG4gIGlmICghdClcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBjbGllbnRXaWR0aDogZSwgY2xpZW50SGVpZ2h0OiBuIH07XG4gIGNvbnN0IHIgPSB0LnZpZXdCb3gsIHMgPSByICYmIHIuYmFzZVZhbCB8fCB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICByZXR1cm4ge1xuICAgIHg6IHMueCxcbiAgICB5OiBzLnksXG4gICAgd2lkdGg6IHMud2lkdGggfHwgZSxcbiAgICBoZWlnaHQ6IHMuaGVpZ2h0IHx8IG4sXG4gICAgY2xpZW50V2lkdGg6IGUsXG4gICAgY2xpZW50SGVpZ2h0OiBuXG4gIH07XG59XG5mdW5jdGlvbiBkdSh0LCBlKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aDogbixcbiAgICBoZWlnaHQ6IHIsXG4gICAgY2xpZW50V2lkdGg6IHMsXG4gICAgY2xpZW50SGVpZ2h0OiBvXG4gIH0gPSBncyh0KSwgaSA9IHMgLyBuLCBhID0gbyAvIHIsIGMgPSB0LnByZXNlcnZlQXNwZWN0UmF0aW8uYmFzZVZhbCwgbCA9IGMuYWxpZ24sIHUgPSBjLm1lZXRPclNsaWNlLCBmID0gWzAsIDBdLCBkID0gW2ksIGFdLCBwID0gWzAsIDBdO1xuICBpZiAobCAhPT0gMSkge1xuICAgIGNvbnN0IGggPSAobCAtIDIpICUgMywgdiA9IE1hdGguZmxvb3IoKGwgLSAyKSAvIDMpO1xuICAgIGZbMF0gPSBuICogaCAvIDIsIGZbMV0gPSByICogdiAvIDI7XG4gICAgY29uc3QgbSA9IHUgPT09IDIgPyBNYXRoLm1heChhLCBpKSA6IE1hdGgubWluKGksIGEpO1xuICAgIGRbMF0gPSBtLCBkWzFdID0gbSwgcFswXSA9IChzIC0gbikgLyAyICogaCwgcFsxXSA9IChvIC0gcikgLyAyICogdjtcbiAgfVxuICBjb25zdCBnID0gcnMoZCwgZSk7XG4gIHJldHVybiBbZ1tlICogKGUgLSAxKV0sIGdbZSAqIChlIC0gMSkgKyAxXV0gPSBwLCBlbihnLCBlLCBmKTtcbn1cbmZ1bmN0aW9uIHB1KHQsIGUsIG4pIHtcbiAgY29uc3QgciA9IHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIXQuZ2V0QkJveCB8fCAhbiAmJiByID09PSBcImdcIilcbiAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICBjb25zdCBvID0gR3QodCkoXCJ0cmFuc2Zvcm0tYm94XCIpID09PSBcImZpbGwtYm94XCIsIGkgPSB0LmdldEJCb3goKSwgYSA9IGdzKHQub3duZXJTVkdFbGVtZW50KTtcbiAgbGV0IGMgPSBpLngsIGwgPSBpLnk7XG4gIHIgPT09IFwiZm9yZWlnbm9iamVjdFwiICYmICFjICYmICFsICYmIChjID0gcGFyc2VGbG9hdCh0LmdldEF0dHJpYnV0ZShcInhcIikpIHx8IDAsIGwgPSBwYXJzZUZsb2F0KHQuZ2V0QXR0cmlidXRlKFwieVwiKSkgfHwgMCk7XG4gIGNvbnN0IHUgPSBjIC0gYS54LCBmID0gbCAtIGEueSwgZCA9IG8gPyBlWzBdIDogZVswXSAtIHUsIHAgPSBvID8gZVsxXSA6IGVbMV0gLSBmO1xuICByZXR1cm4gW3UsIGYsIGQsIHBdO1xufVxuZnVuY3Rpb24gaHQodCwgZSwgbikge1xuICByZXR1cm4gX3QodCwgRWUoZSwgbiksIG4pO1xufVxuZnVuY3Rpb24gTWUodCwgZSwgbiwgcikge1xuICByZXR1cm4gW1xuICAgIFswLCAwXSxcbiAgICBbZSwgMF0sXG4gICAgWzAsIG5dLFxuICAgIFtlLCBuXVxuICBdLm1hcCgocykgPT4gaHQodCwgcywgcikpO1xufVxuZnVuY3Rpb24gWXQodCkge1xuICBjb25zdCBlID0gdC5tYXAoKGwpID0+IGxbMF0pLCBuID0gdC5tYXAoKGwpID0+IGxbMV0pLCByID0gTWF0aC5taW4oLi4uZSksIHMgPSBNYXRoLm1pbiguLi5uKSwgbyA9IE1hdGgubWF4KC4uLmUpLCBpID0gTWF0aC5tYXgoLi4ubiksIGEgPSBvIC0gciwgYyA9IGkgLSBzO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IHIsXG4gICAgdG9wOiBzLFxuICAgIHJpZ2h0OiBvLFxuICAgIGJvdHRvbTogaSxcbiAgICB3aWR0aDogYSxcbiAgICBoZWlnaHQ6IGNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvKHQsIGUsIG4sIHIpIHtcbiAgY29uc3QgcyA9IE1lKHQsIGUsIG4sIHIpO1xuICByZXR1cm4gWXQocyk7XG59XG5mdW5jdGlvbiBndSh0LCBlLCBuLCByLCBzKSB7XG4gIGNvbnN0IG8gPSB0LnRhcmdldCwgaSA9IHQub3JpZ2luLCBhID0gZS5tYXRyaXgsIHsgb2Zmc2V0V2lkdGg6IGMsIG9mZnNldEhlaWdodDogbCB9ID0ga2kobyksIHUgPSBuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBsZXQgZiA9IFswLCAwXTtcbiAgbiA9PT0gZmUobikgJiYgKGYgPSBBaShvLCAhMCkpO1xuICBjb25zdCBkID0gby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgcCA9IGQubGVmdCAtIHUubGVmdCArIG4uc2Nyb2xsTGVmdCAtIChuLmNsaWVudExlZnQgfHwgMCkgKyBmWzBdLCBnID0gZC50b3AgLSB1LnRvcCArIG4uc2Nyb2xsVG9wIC0gKG4uY2xpZW50VG9wIHx8IDApICsgZlsxXSwgaCA9IGQud2lkdGgsIHYgPSBkLmhlaWdodCwgbSA9IEFuKHIsIHMsIGEpLCB7XG4gICAgbGVmdDogUyxcbiAgICB0b3A6IHgsXG4gICAgd2lkdGg6IEMsXG4gICAgaGVpZ2h0OiBFXG4gIH0gPSBjbyhtLCBjLCBsLCByKSwgRCA9IGh0KG0sIGksIHIpLCBSID0gSyhELCBbUywgeF0pLCB5ID0gW1xuICAgIHAgKyBSWzBdICogaCAvIEMsXG4gICAgZyArIFJbMV0gKiB2IC8gRVxuICBdLCBNID0gWzAsIDBdO1xuICBsZXQgUCA9IDA7XG4gIGZvciAoOyArK1AgPCAxMDsgKSB7XG4gICAgY29uc3QgXyA9IEp0KHMsIHIpO1xuICAgIFtNWzBdLCBNWzFdXSA9IEsoXG4gICAgICBodChfLCB5LCByKSxcbiAgICAgIGh0KF8sIEQsIHIpXG4gICAgKTtcbiAgICBjb25zdCBPID0gQW4oXG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIENlKE0sIHIpLFxuICAgICAgYVxuICAgICksIHsgbGVmdDogVCwgdG9wOiB3IH0gPSBjbyhcbiAgICAgIE8sXG4gICAgICBjLFxuICAgICAgbCxcbiAgICAgIHJcbiAgICApLCBrID0gVCAtIHAsIEkgPSB3IC0gZztcbiAgICBpZiAoQihrKSA8IDIgJiYgQihJKSA8IDIpXG4gICAgICBicmVhaztcbiAgICB5WzBdIC09IGssIHlbMV0gLT0gSTtcbiAgfVxuICByZXR1cm4gTS5tYXAoKF8pID0+IE1hdGgucm91bmQoXykpO1xufVxuZnVuY3Rpb24gaHUodCwgZSwgbikge1xuICBjb25zdCBzID0gdC5sZW5ndGggPT09IDE2ID8gNCA6IDMsIG8gPSBlLm1hcCgoYykgPT4gaHQodCwgYywgcykpLCB7IGxlZnQ6IGksIHRvcDogYSB9ID0gbjtcbiAgcmV0dXJuIG8ubWFwKChjKSA9PiBbY1swXSArIGksIGNbMV0gKyBhXSk7XG59XG5mdW5jdGlvbiBWdCh0KSB7XG4gIHJldHVybiBNYXRoLnNxcnQodFswXSAqIHRbMF0gKyB0WzFdICogdFsxXSk7XG59XG5mdW5jdGlvbiBHaSh0LCBlKSB7XG4gIHJldHVybiBWdChbZVswXSAtIHRbMF0sIGVbMV0gLSB0WzFdXSk7XG59XG5mdW5jdGlvbiBKZSh0LCBlLCBuID0gMSwgciA9IHh0KHQsIGUpKSB7XG4gIGNvbnN0IHMgPSBHaSh0LCBlKTtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKC01MCUpIHRyYW5zbGF0ZSgke3RbMF19cHgsICR7dFsxXX1weCkgcm90YXRlKCR7cn1yYWQpIHNjYWxlWSgke259KWAsXG4gICAgd2lkdGg6IGAke3N9cHhgXG4gIH07XG59XG5mdW5jdGlvbiBObih0LCBlLCAuLi5uKSB7XG4gIGNvbnN0IHIgPSBuLmxlbmd0aCwgcyA9IG4ucmVkdWNlKChpLCBhKSA9PiBpICsgYVswXSwgMCkgLyByLCBvID0gbi5yZWR1Y2UoKGksIGEpID0+IGkgKyBhWzFdLCAwKSAvIHI7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWigwcHgpIHRyYW5zbGF0ZSgke3N9cHgsICR7b31weCkgcm90YXRlKCR7dH1yYWQpIHNjYWxlKCR7ZX0pYFxuICB9O1xufVxuZnVuY3Rpb24gRGUodCwgZSkge1xuICBjb25zdCBuID0gdFtlXTtcbiAgcmV0dXJuIHF0KG4pID8ge1xuICAgIC4uLnQsXG4gICAgLi4ublxuICB9IDogdDtcbn1cbmZ1bmN0aW9uIGtpKHQpIHtcbiAgY29uc3QgZSA9IHQgJiYgIUtyKHQub2Zmc2V0V2lkdGgpO1xuICBsZXQgbiA9IDAsIHIgPSAwLCBzID0gMCwgbyA9IDAsIGkgPSAwLCBhID0gMCwgYyA9IDAsIGwgPSAwLCB1ID0gMCwgZiA9IDAsIGQgPSAwLCBwID0gMCwgZyA9IDEgLyAwLCBoID0gMSAvIDAsIHYgPSAxIC8gMCwgbSA9IDEgLyAwLCBTID0gMCwgeCA9IDAsIEMgPSAhMTtcbiAgaWYgKHQpXG4gICAgaWYgKCFlICYmIHQub3duZXJTVkdFbGVtZW50KSB7XG4gICAgICBjb25zdCBFID0gdC5nZXRCQm94KCk7XG4gICAgICBDID0gITAsIG4gPSBFLndpZHRoLCByID0gRS5oZWlnaHQsIGkgPSBuLCBhID0gciwgYyA9IG4sIGwgPSByLCBzID0gbiwgbyA9IHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IEUgPSBHdCh0KSwgRCA9IHQuc3R5bGUsIFIgPSBFKFwiYm94U2l6aW5nXCIpID09PSBcImJvcmRlci1ib3hcIiwgeSA9IHBhcnNlRmxvYXQoRShcImJvcmRlckxlZnRXaWR0aFwiKSkgfHwgMCwgTSA9IHBhcnNlRmxvYXQoRShcImJvcmRlclJpZ2h0V2lkdGhcIikpIHx8IDAsIFAgPSBwYXJzZUZsb2F0KEUoXCJib3JkZXJUb3BXaWR0aFwiKSkgfHwgMCwgXyA9IHBhcnNlRmxvYXQoRShcImJvcmRlckJvdHRvbVdpZHRoXCIpKSB8fCAwLCBPID0gcGFyc2VGbG9hdChFKFwicGFkZGluZ0xlZnRcIikpIHx8IDAsIFQgPSBwYXJzZUZsb2F0KEUoXCJwYWRkaW5nUmlnaHRcIikpIHx8IDAsIHcgPSBwYXJzZUZsb2F0KEUoXCJwYWRkaW5nVG9wXCIpKSB8fCAwLCBrID0gcGFyc2VGbG9hdChFKFwicGFkZGluZ0JvdHRvbVwiKSkgfHwgMCwgSSA9IE8gKyBULCAkID0gdyArIGssIEcgPSB5ICsgTSwgTCA9IFAgKyBfLCB6ID0gSSArIEcsIE4gPSAkICsgTCwgWiA9IEUoXCJwb3NpdGlvblwiKTtcbiAgICAgIGxldCBZID0gMCwgVyA9IDA7XG4gICAgICBpZiAoXCJjbGllbnRMZWZ0XCIgaW4gdCkge1xuICAgICAgICBsZXQgSiA9IG51bGw7XG4gICAgICAgIGlmIChaID09PSBcImFic29sdXRlXCIgPyBKID0gZm4odCwgZmUodCkpLm9mZnNldFBhcmVudCA6IEogPSB0LnBhcmVudEVsZW1lbnQsIEopIHtcbiAgICAgICAgICBjb25zdCBxID0gR3QoSik7XG4gICAgICAgICAgWSA9IHBhcnNlRmxvYXQocShcIndpZHRoXCIpKSwgVyA9IHBhcnNlRmxvYXQocShcImhlaWdodFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHUgPSBNYXRoLm1heChcbiAgICAgICAgSSxcbiAgICAgICAgZnQoRShcIm1pbldpZHRoXCIpLCBZKSB8fCAwXG4gICAgICApLCBmID0gTWF0aC5tYXgoXG4gICAgICAgICQsXG4gICAgICAgIGZ0KEUoXCJtaW5IZWlnaHRcIiksIFcpIHx8IDBcbiAgICAgICksIGcgPSBmdChFKFwibWF4V2lkdGhcIiksIFkpLCBoID0gZnQoRShcIm1heEhlaWdodFwiKSwgVyksIGlzTmFOKGcpICYmIChnID0gMSAvIDApLCBpc05hTihoKSAmJiAoaCA9IDEgLyAwKSwgUyA9IGZ0KEQud2lkdGgsIDApIHx8IDAsIHggPSBmdChELmhlaWdodCwgMCkgfHwgMCwgaSA9IHBhcnNlRmxvYXQoRShcIndpZHRoXCIpKSB8fCAwLCBhID0gcGFyc2VGbG9hdChFKFwiaGVpZ2h0XCIpKSB8fCAwLCBjID0gQihpIC0gUykgPCAxID8gYnIodSwgUyB8fCBpLCBnKSA6IGksIGwgPSBCKGEgLSB4KSA8IDEgPyBicihmLCB4IHx8IGEsIGgpIDogYSwgbiA9IGMsIHIgPSBsLCBzID0gYywgbyA9IGwsIFIgPyAodiA9IGcsIG0gPSBoLCBkID0gdSwgcCA9IGYsIGMgPSBuIC0geiwgbCA9IHIgLSBOKSA6ICh2ID0gZyArIHosIG0gPSBoICsgTiwgZCA9IHUgKyB6LCBwID0gZiArIE4sIG4gPSBjICsgeiwgciA9IGwgKyBOKSwgcyA9IGMgKyBJLCBvID0gbCArICQ7XG4gICAgfVxuICByZXR1cm4ge1xuICAgIHN2ZzogQyxcbiAgICBvZmZzZXRXaWR0aDogbixcbiAgICBvZmZzZXRIZWlnaHQ6IHIsXG4gICAgY2xpZW50V2lkdGg6IHMsXG4gICAgY2xpZW50SGVpZ2h0OiBvLFxuICAgIGNvbnRlbnRXaWR0aDogYyxcbiAgICBjb250ZW50SGVpZ2h0OiBsLFxuICAgIGlubGluZUNTU1dpZHRoOiBTLFxuICAgIGlubGluZUNTU0hlaWdodDogeCxcbiAgICBjc3NXaWR0aDogaSxcbiAgICBjc3NIZWlnaHQ6IGEsXG4gICAgbWluV2lkdGg6IHUsXG4gICAgbWluSGVpZ2h0OiBmLFxuICAgIG1heFdpZHRoOiBnLFxuICAgIG1heEhlaWdodDogaCxcbiAgICBtaW5PZmZzZXRXaWR0aDogZCxcbiAgICBtaW5PZmZzZXRIZWlnaHQ6IHAsXG4gICAgbWF4T2Zmc2V0V2lkdGg6IHYsXG4gICAgbWF4T2Zmc2V0SGVpZ2h0OiBtXG4gIH07XG59XG5mdW5jdGlvbiAkaSh0LCBlKSB7XG4gIHJldHVybiB4dChcbiAgICBlID4gMCA/IHRbMF0gOiB0WzFdLFxuICAgIGUgPiAwID8gdFsxXSA6IHRbMF1cbiAgKTtcbn1cbmZ1bmN0aW9uIFJuKCkge1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgY2xpZW50TGVmdDogMCxcbiAgICBjbGllbnRUb3A6IDAsXG4gICAgY2xpZW50V2lkdGg6IDAsXG4gICAgY2xpZW50SGVpZ2h0OiAwLFxuICAgIHNjcm9sbFdpZHRoOiAwLFxuICAgIHNjcm9sbEhlaWdodDogMFxuICB9O1xufVxuZnVuY3Rpb24gRmkodCwgZSkge1xuICBjb25zdCBuID0gdCA9PT0gZmUodCkgfHwgdCA9PT0gZXModCksIHIgPSB7XG4gICAgY2xpZW50TGVmdDogdC5jbGllbnRMZWZ0LFxuICAgIGNsaWVudFRvcDogdC5jbGllbnRUb3AsXG4gICAgY2xpZW50V2lkdGg6IHQuY2xpZW50V2lkdGgsXG4gICAgY2xpZW50SGVpZ2h0OiB0LmNsaWVudEhlaWdodCxcbiAgICBzY3JvbGxXaWR0aDogdC5zY3JvbGxXaWR0aCxcbiAgICBzY3JvbGxIZWlnaHQ6IHQuc2Nyb2xsSGVpZ2h0LFxuICAgIG92ZXJmbG93OiAhMVxuICB9O1xuICByZXR1cm4gbiAmJiAoci5jbGllbnRIZWlnaHQgPSBNYXRoLm1heChlLmhlaWdodCwgci5jbGllbnRIZWlnaHQpLCByLnNjcm9sbEhlaWdodCA9IE1hdGgubWF4KGUuaGVpZ2h0LCByLnNjcm9sbEhlaWdodCkpLCByLm92ZXJmbG93ID0gR3QodCkoXCJvdmVyZmxvd1wiKSAhPT0gXCJ2aXNpYmxlXCIsIHtcbiAgICAuLi5lLFxuICAgIC4uLnJcbiAgfTtcbn1cbmZ1bmN0aW9uIHByKHQsIGUsIG4sIHIpIHtcbiAgY29uc3QgeyBsZWZ0OiBzLCByaWdodDogbywgdG9wOiBpLCBib3R0b206IGEgfSA9IHQsIGMgPSBlLnRvcCwgbCA9IGUubGVmdCwgdSA9IHtcbiAgICBsZWZ0OiBsICsgcyxcbiAgICB0b3A6IGMgKyBpLFxuICAgIHJpZ2h0OiBsICsgbyxcbiAgICBib3R0b206IGMgKyBhLFxuICAgIHdpZHRoOiBvIC0gcyxcbiAgICBoZWlnaHQ6IGEgLSBpXG4gIH07XG4gIHJldHVybiBuICYmIHIgPyBGaShuLCB1KSA6IHU7XG59XG5mdW5jdGlvbiBubih0LCBlKSB7XG4gIGxldCBuID0gMCwgciA9IDAsIHMgPSAwLCBvID0gMDtcbiAgaWYgKHQpIHtcbiAgICBjb25zdCBhID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBuID0gYS5sZWZ0LCByID0gYS50b3AsIHMgPSBhLndpZHRoLCBvID0gYS5oZWlnaHQ7XG4gIH1cbiAgY29uc3QgaSA9IHtcbiAgICBsZWZ0OiBuLFxuICAgIHRvcDogcixcbiAgICB3aWR0aDogcyxcbiAgICBoZWlnaHQ6IG8sXG4gICAgcmlnaHQ6IG4gKyBzLFxuICAgIGJvdHRvbTogciArIG9cbiAgfTtcbiAgcmV0dXJuIHQgJiYgZSA/IEZpKHQsIGkpIDogaTtcbn1cbmZ1bmN0aW9uIHZ1KHQpIHtcbiAgY29uc3QgeyBncm91cGFibGU6IGUsIHN2Z09yaWdpbjogbiB9ID0gdC5wcm9wcywgeyBvZmZzZXRXaWR0aDogciwgb2Zmc2V0SGVpZ2h0OiBzLCBzdmc6IG8sIHRyYW5zZm9ybU9yaWdpbjogaSB9ID0gdC5nZXRTdGF0ZSgpO1xuICByZXR1cm4gIWUgJiYgbyAmJiBuID8gRXMobiwgciwgcykgOiBpO1xufVxuZnVuY3Rpb24gTGkodCwgZSwgbiwgcikge1xuICBsZXQgcztcbiAgaWYgKHQpXG4gICAgcyA9IHQ7XG4gIGVsc2UgaWYgKGUpXG4gICAgcyA9IFswLCAwXTtcbiAgZWxzZSB7XG4gICAgY29uc3QgbyA9IG4udGFyZ2V0O1xuICAgIHMgPSBOaShvLCByKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIE5pKHQsIGUpIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybjtcbiAgY29uc3QgbiA9IHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yb3RhdGlvblwiKSB8fCBcIlwiLCByID0gdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRpcmVjdGlvblwiKTtcbiAgaWYgKGUuZGVnID0gbiwgIXIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBzID0gWzAsIDBdO1xuICByZXR1cm4gci5pbmRleE9mKFwid1wiKSA+IC0xICYmIChzWzBdID0gLTEpLCByLmluZGV4T2YoXCJlXCIpID4gLTEgJiYgKHNbMF0gPSAxKSwgci5pbmRleE9mKFwiblwiKSA+IC0xICYmIChzWzFdID0gLTEpLCByLmluZGV4T2YoXCJzXCIpID4gLTEgJiYgKHNbMV0gPSAxKSwgcztcbn1cbmZ1bmN0aW9uIGhzKHQsIGUpIHtcbiAgcmV0dXJuIFtcbiAgICBhdChlLCB0WzBdKSxcbiAgICBhdChlLCB0WzFdKSxcbiAgICBhdChlLCB0WzJdKSxcbiAgICBhdChlLCB0WzNdKVxuICBdO1xufVxuZnVuY3Rpb24ganQoe1xuICBsZWZ0OiB0LFxuICB0b3A6IGUsXG4gIHBvczE6IG4sXG4gIHBvczI6IHIsXG4gIHBvczM6IHMsXG4gIHBvczQ6IG9cbn0pIHtcbiAgcmV0dXJuIGhzKFtuLCByLCBzLCBvXSwgW3QsIGVdKTtcbn1cbmZ1bmN0aW9uIHpyKHQsIGUpIHtcbiAgdFtlID8gXCJjb250cm9sQWJsZXNcIiA6IFwidGFyZ2V0QWJsZXNcIl0uZm9yRWFjaCgobikgPT4ge1xuICAgIG4udW5zZXQgJiYgbi51bnNldCh0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB6ZSh0LCBlKSB7XG4gIGNvbnN0IG4gPSBlID8gXCJjb250cm9sR2VzdG9cIiA6IFwidGFyZ2V0R2VzdG9cIiwgciA9IHRbbl07XG4gIChyID09IG51bGwgPyB2b2lkIDAgOiByLmlzSWRsZSgpKSA9PT0gITEgJiYgenIodCwgZSksIHIgPT0gbnVsbCB8fCByLnVuc2V0KCksIHRbbl0gPSBudWxsO1xufVxuZnVuY3Rpb24gSXQodCwgZSkge1xuICBpZiAoZSkge1xuICAgIGNvbnN0IG4gPSBqZShlKTtcbiAgICBuLm5leHRTdHlsZSA9IHtcbiAgICAgIC4uLm4ubmV4dFN0eWxlLFxuICAgICAgLi4udFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdHlsZTogdCxcbiAgICBjc3NUZXh0OiBWZSh0KS5tYXAoKG4pID0+IGAke1NjKG4sIFwiLVwiKX06ICR7dFtuXX07YCkuam9pbihcIlwiKVxuICB9O1xufVxuZnVuY3Rpb24gV2kodCwgZSwgbikge1xuICBjb25zdCByID0gZS5hZnRlclRyYW5zZm9ybSB8fCBlLnRyYW5zZm9ybTtcbiAgcmV0dXJuIHtcbiAgICAuLi5JdChcbiAgICAgIHtcbiAgICAgICAgLi4udC5zdHlsZSxcbiAgICAgICAgLi4uZS5zdHlsZSxcbiAgICAgICAgdHJhbnNmb3JtOiByXG4gICAgICB9LFxuICAgICAgblxuICAgICksXG4gICAgYWZ0ZXJUcmFuc2Zvcm06IHIsXG4gICAgdHJhbnNmb3JtOiB0LnRyYW5zZm9ybVxuICB9O1xufVxuZnVuY3Rpb24gZXQodCwgZSwgbiwgcikge1xuICBjb25zdCBzID0gZS5kYXRhcztcbiAgcy5kYXRhcyB8fCAocy5kYXRhcyA9IHt9KTtcbiAgY29uc3QgbyA9IHtcbiAgICAuLi5uLFxuICAgIHRhcmdldDogdC5zdGF0ZS50YXJnZXQsXG4gICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICBpbnB1dEV2ZW50OiBlLmlucHV0RXZlbnQsXG4gICAgY3VycmVudFRhcmdldDogdCxcbiAgICBtb3ZlYWJsZTogdCxcbiAgICBkYXRhczogcy5kYXRhcyxcbiAgICBpc1JlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxuICAgIGlzUmVxdWVzdENoaWxkOiBlLmlzUmVxdWVzdENoaWxkLFxuICAgIGlzRmlyc3REcmFnOiAhIWUuaXNGaXJzdERyYWcsXG4gICAgaXNUcnVzdGVkOiBlLmlzVHJ1c3RlZCAhPT0gITEsXG4gICAgc3RvcEFibGUoKSB7XG4gICAgICBzLmlzRXZlbnRTdGFydCA9ICExO1xuICAgIH0sXG4gICAgc3RvcERyYWcoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIChpID0gZS5zdG9wKSA9PSBudWxsIHx8IGkuY2FsbChlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBzLmlzU3RhcnRFdmVudCA/IHIgfHwgKHMubGFzdEV2ZW50ID0gbykgOiBzLmlzU3RhcnRFdmVudCA9ICEwLCBvO1xufVxuZnVuY3Rpb24gJHQodCwgZSwgbikge1xuICBjb25zdCByID0gZS5kYXRhcywgcyA9IFwiaXNEcmFnXCIgaW4gbiA/IG4uaXNEcmFnIDogZS5pc0RyYWc7XG4gIHJldHVybiByLmRhdGFzIHx8IChyLmRhdGFzID0ge30pLCB7XG4gICAgaXNEcmFnOiBzLFxuICAgIC4uLm4sXG4gICAgbW92ZWFibGU6IHQsXG4gICAgdGFyZ2V0OiB0LnN0YXRlLnRhcmdldCxcbiAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgIGlucHV0RXZlbnQ6IGUuaW5wdXRFdmVudCxcbiAgICBjdXJyZW50VGFyZ2V0OiB0LFxuICAgIGxhc3RFdmVudDogci5sYXN0RXZlbnQsXG4gICAgaXNEb3VibGU6IGUuaXNEb3VibGUsXG4gICAgZGF0YXM6IHIuZGF0YXMsXG4gICAgaXNGaXJzdERyYWc6ICEhZS5pc0ZpcnN0RHJhZ1xuICB9O1xufVxuZnVuY3Rpb24gUW4odCwgZSwgbikge1xuICB0Ll9lbWl0dGVyLm9uKGUsIG4pO1xufVxuZnVuY3Rpb24gaih0LCBlLCBuLCByLCBzKSB7XG4gIHJldHVybiB0LnRyaWdnZXJFdmVudChlLCBuLCByLCBzKTtcbn1cbmZ1bmN0aW9uIHZzKHQsIGUpIHtcbiAgcmV0dXJuIGFlKHQpLmdldENvbXB1dGVkU3R5bGUodCwgZSk7XG59XG5mdW5jdGlvbiBNbih0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSB7fSwgcyA9IHt9O1xuICByZXR1cm4gdC5maWx0ZXIoKG8pID0+IHtcbiAgICBjb25zdCBpID0gby5uYW1lO1xuICAgIGlmIChyW2ldIHx8ICFlLnNvbWUoKGEpID0+IG9bYV0pKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICghbiAmJiBvLmFibGVHcm91cCkge1xuICAgICAgaWYgKHNbby5hYmxlR3JvdXBdKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBzW28uYWJsZUdyb3VwXSA9ICEwO1xuICAgIH1cbiAgICByZXR1cm4gcltpXSA9ICEwLCAhMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBBcih0LCBlKSB7XG4gIHJldHVybiB0ID09PSBlIHx8IHQgPT0gbnVsbCAmJiBlID09IG51bGw7XG59XG5mdW5jdGlvbiBsbyguLi50KSB7XG4gIGNvbnN0IGUgPSB0Lmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgZTsgKytuKSB7XG4gICAgY29uc3QgciA9IHRbbl07XG4gICAgaWYgKCFLcihyKSlcbiAgICAgIHJldHVybiByO1xuICB9XG4gIHJldHVybiB0W2VdO1xufVxuZnVuY3Rpb24gWWkodCwgZSkge1xuICBjb25zdCBuID0gW10sIHIgPSBbXTtcbiAgcmV0dXJuIHQuZm9yRWFjaCgocywgbykgPT4ge1xuICAgIGNvbnN0IGkgPSBlKHMsIG8sIHQpLCBhID0gci5pbmRleE9mKGkpLCBjID0gblthXSB8fCBbXTtcbiAgICBhID09PSAtMSAmJiAoci5wdXNoKGkpLCBuLnB1c2goYykpLCBjLnB1c2gocyk7XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gbXUodCwgZSkge1xuICBjb25zdCBuID0gW10sIHIgPSB7fTtcbiAgcmV0dXJuIHQuZm9yRWFjaCgocywgbykgPT4ge1xuICAgIGNvbnN0IGkgPSBlKHMsIG8sIHQpO1xuICAgIGxldCBhID0gcltpXTtcbiAgICBhIHx8IChhID0gW10sIHJbaV0gPSBhLCBuLnB1c2goYSkpLCBhLnB1c2gocyk7XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gVmkodCkge1xuICByZXR1cm4gdC5yZWR1Y2UoKGUsIG4pID0+IGUuY29uY2F0KG4pLCBbXSk7XG59XG5mdW5jdGlvbiBOZSguLi50KSB7XG4gIHJldHVybiB0LnNvcnQoKGUsIG4pID0+IEIobikgLSBCKGUpKSwgdFswXTtcbn1cbmZ1bmN0aW9uIFdlKHQsIGUsIG4pIHtcbiAgcmV0dXJuIF90KEp0KHQsIG4pLCBFZShlLCBuKSwgbik7XG59XG5mdW5jdGlvbiB4dSh0LCBlKSB7XG4gIGNvbnN0IHsgaXMzZDogbiwgcm9vdE1hdHJpeDogciB9ID0gdCwgcyA9IG4gPyA0IDogMztcbiAgcmV0dXJuIFtlLmRpc3RYLCBlLmRpc3RZXSA9IFdlKFxuICAgIHIsXG4gICAgW2UuZGlzdFgsIGUuZGlzdFldLFxuICAgIHNcbiAgKSwgZTtcbn1cbmZ1bmN0aW9uIFd0KHQsIGUsIG4sIHIpIHtcbiAgaWYgKCFuWzBdICYmICFuWzFdKVxuICAgIHJldHVybiBlO1xuICBjb25zdCBzID0gaHQodCwgW29vKG5bMF0gfHwgMSksIDBdLCByKSwgbyA9IGh0KHQsIFswLCBvbyhuWzFdIHx8IDEpXSwgciksIGkgPSBodChcbiAgICB0LFxuICAgIFtuWzBdIC8gVnQocyksIG5bMV0gLyBWdChvKV0sXG4gICAgclxuICApO1xuICByZXR1cm4gYXQoZSwgaSk7XG59XG5mdW5jdGlvbiBYdCh0LCBlLCBuKSB7XG4gIHJldHVybiBuID8gYCR7dCAvIGUgKiAxMDB9JWAgOiBgJHt0fXB4YDtcbn1cbmZ1bmN0aW9uIFduKHQpIHtcbiAgcmV0dXJuIEIodCkgPD0gQnQgPyAwIDogdDtcbn1cbmZ1bmN0aW9uIG1zKHQpIHtcbiAgcmV0dXJuIChlKSA9PiB7XG4gICAgaWYgKCFlLmlzRHJhZ2dpbmcodCkpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBjb25zdCByID0gS2MoZSwgdCkuZGVnO1xuICAgIHJldHVybiByID8gVShgdmlldy1jb250cm9sLXJvdGF0aW9uJHtyfWApIDogXCJcIjtcbiAgfTtcbn1cbmZ1bmN0aW9uIHhzKHQsIGUgPSBbdF0pIHtcbiAgcmV0dXJuIChuLCByKSA9PiB7XG4gICAgaWYgKHIuaXNSZXF1ZXN0KVxuICAgICAgcmV0dXJuIGUuc29tZSgobykgPT4gci5yZXF1ZXN0QWJsZSA9PT0gbykgPyByLnBhcmVudERpcmVjdGlvbiA6ICExO1xuICAgIGNvbnN0IHMgPSByLmlucHV0RXZlbnQudGFyZ2V0O1xuICAgIHJldHVybiBidChzLCBVKFwiZGlyZWN0aW9uXCIpKSAmJiAoIXQgfHwgYnQocywgVSh0KSkpO1xuICB9O1xufVxuZnVuY3Rpb24gU3UodCwgZSwgbikge1xuICBjb25zdCByID0gJGUodCwge1xuICAgIFwieCVcIjogKEMpID0+IEMgLyAxMDAgKiBlLm9mZnNldFdpZHRoLFxuICAgIFwieSVcIjogKEMpID0+IEMgLyAxMDAgKiBlLm9mZnNldEhlaWdodFxuICB9KSwgcyA9IHQuc2xpY2UoXG4gICAgMCxcbiAgICBuIDwgMCA/IHZvaWQgMCA6IG5cbiAgKSwgbyA9IHQuc2xpY2UoXG4gICAgMCxcbiAgICBuIDwgMCA/IHZvaWQgMCA6IG4gKyAxXG4gICksIGkgPSB0W25dIHx8IFwiXCIsIGEgPSBuIDwgMCA/IFtdIDogdC5zbGljZShuKSwgYyA9IG4gPCAwID8gW10gOiB0LnNsaWNlKG4gKyAxKSwgbCA9IHIuc2xpY2UoMCwgbiA8IDAgPyB2b2lkIDAgOiBuKSwgdSA9IHIuc2xpY2UoXG4gICAgMCxcbiAgICBuIDwgMCA/IHZvaWQgMCA6IG4gKyAxXG4gICksIGYgPSByW25dID8/ICRlKFtcIlwiXSlbMF0sIGQgPSBuIDwgMCA/IFtdIDogci5zbGljZShuKSwgcCA9IG4gPCAwID8gW10gOiByLnNsaWNlKG4gKyAxKSwgZyA9IGYgPyBbZl0gOiBbXSwgaCA9IHdlKGwpLCB2ID0gd2UodSksIG0gPSB3ZShkKSwgUyA9IHdlKHApLCB4ID0gZHQoXG4gICAgaCxcbiAgICBtLFxuICAgIDRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm1zOiB0LFxuICAgIGJlZm9yZUZ1bmN0aW9uTWF0cml4OiBoLFxuICAgIGJlZm9yZUZ1bmN0aW9uTWF0cml4MjogdixcbiAgICB0YXJnZXRGdW5jdGlvbk1hdHJpeDogd2UoZyksXG4gICAgYWZ0ZXJGdW5jdGlvbk1hdHJpeDogbSxcbiAgICBhZnRlckZ1bmN0aW9uTWF0cml4MjogUyxcbiAgICBhbGxGdW5jdGlvbk1hdHJpeDogeCxcbiAgICBiZWZvcmVGdW5jdGlvbnM6IGwsXG4gICAgYmVmb3JlRnVuY3Rpb25zMjogdSxcbiAgICB0YXJnZXRGdW5jdGlvbjogZ1swXSxcbiAgICBhZnRlckZ1bmN0aW9uczogZCxcbiAgICBhZnRlckZ1bmN0aW9uczI6IHAsXG4gICAgYmVmb3JlRnVuY3Rpb25UZXh0czogcyxcbiAgICBiZWZvcmVGdW5jdGlvblRleHRzMjogbyxcbiAgICB0YXJnZXRGdW5jdGlvblRleHQ6IGksXG4gICAgYWZ0ZXJGdW5jdGlvblRleHRzOiBhLFxuICAgIGFmdGVyRnVuY3Rpb25UZXh0czI6IGNcbiAgfTtcbn1cbmZ1bmN0aW9uIEV1KHQpIHtcbiAgcmV0dXJuICF0IHx8ICFxdCh0KSB8fCBucyh0KSA/ICExIDogUnQodCkgfHwgXCJsZW5ndGhcIiBpbiB0O1xufVxuZnVuY3Rpb24gWnQodCwgZSkge1xuICByZXR1cm4gdCA/IG5zKHQpID8gdCA6IHJlKHQpID8gZSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgOiB0IDogWnIodCkgPyB0KCkgOiBKbyh0KSA/IHQgOiBcImN1cnJlbnRcIiBpbiB0ID8gdC5jdXJyZW50IDogdCA6IG51bGw7XG59XG5mdW5jdGlvbiBTcyh0LCBlKSB7XG4gIHJldHVybiB0ID8gKEV1KHQpID8gW10uc2xpY2UuY2FsbCh0KSA6IFt0XSkucmVkdWNlKChyLCBzKSA9PiByZShzKSAmJiBlID8gW1xuICAgIC4uLnIsXG4gICAgLi4uW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHMpKVxuICBdIDogKFJ0KHMpID8gci5wdXNoKFNzKHMsIGUpKSA6IHIucHVzaChadChzLCBlKSksIHIpLCBbXSkgOiBbXTtcbn1cbmZ1bmN0aW9uIEN1KHQsIGUsIG4pIHtcbiAgbGV0IHIgPSB4dCh0LCBlKSAvIE1hdGguUEkgKiAxODA7XG4gIHJldHVybiByID0gbiA+PSAwID8gciA6IDE4MCAtIHIsIHIgPSByID49IDAgPyByIDogMzYwICsgciwgcjtcbn1cbmZ1bmN0aW9uIHVvKHQsIGUpIHtcbiAgY29uc3QgeyByb290TWF0cml4OiBuLCBpczNkOiByIH0gPSB0O1xuICBsZXQgbyA9IEp0KG4sIHIgPyA0IDogMyk7XG4gIHJldHVybiByIHx8IChvID0gVXQobywgMywgNCkpLCBvWzEyXSA9IDAsIG9bMTNdID0gMCwgb1sxNF0gPSAwLCBBYyhvLCBlKTtcbn1cbmZ1bmN0aW9uIGppKHQsIGUsIG4sIHIsIHMpIHtcbiAgY29uc3QgW28sIGldID0gdDtcbiAgbGV0IGEgPSAwLCBjID0gMDtcbiAgaWYgKHMgJiYgbyAmJiBpKSB7XG4gICAgY29uc3QgbCA9IHh0KFswLCAwXSwgZSksIHUgPSB4dChbMCwgMF0sIHIpLCBmID0gVnQoZSksIGQgPSBNYXRoLmNvcyhsIC0gdSkgKiBmO1xuICAgIGlmICghclswXSlcbiAgICAgIGMgPSBkLCBhID0gYyAqIG47XG4gICAgZWxzZSBpZiAoIXJbMV0pXG4gICAgICBhID0gZCwgYyA9IGEgLyBuO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcCA9IHJbMF0gKiBvLCBnID0gclsxXSAqIGk7XG4gICAgICBsZXQgaCA9IE1hdGguYXRhbjIoXG4gICAgICAgIHAgKyBlWzBdLFxuICAgICAgICBnICsgZVsxXVxuICAgICAgKSwgdiA9IE1hdGguYXRhbjIocCwgZyk7XG4gICAgICBoIDwgMCAmJiAoaCArPSBNYXRoLlBJICogMiksIHYgPCAwICYmICh2ICs9IE1hdGguUEkgKiAyKTtcbiAgICAgIGxldCBtID0gMDtcbiAgICAgIEIoaCAtIHYpIDwgTWF0aC5QSSAvIDIgfHwgQihoIC0gdikgPiBNYXRoLlBJIC8gMiAqIDMgfHwgKHYgKz0gTWF0aC5QSSksIG0gPSBoIC0gdiwgbSA+IE1hdGguUEkgKiAyID8gbSAtPSBNYXRoLlBJICogMiA6IG0gPiBNYXRoLlBJID8gbSA9IDIgKiBNYXRoLlBJIC0gbSA6IG0gPCAtTWF0aC5QSSAmJiAobSA9IC0yICogTWF0aC5QSSAtIG0pO1xuICAgICAgY29uc3QgUyA9IFZ0KFtwICsgZVswXSwgZyArIGVbMV1dKSAqIE1hdGguY29zKG0pO1xuICAgICAgYSA9IFMgKiBNYXRoLnNpbih2KSAtIHAsIGMgPSBTICogTWF0aC5jb3ModikgLSBnLCByWzBdIDwgMCAmJiAoYSAqPSAtMSksIHJbMV0gPCAwICYmIChjICo9IC0xKTtcbiAgICB9XG4gIH0gZWxzZVxuICAgIGEgPSByWzBdICogZVswXSwgYyA9IHJbMV0gKiBlWzFdO1xuICByZXR1cm4gW2EsIGNdO1xufVxuZnVuY3Rpb24gWGkodCwgZSwgbiwgcikge1xuICBjb25zdCB7IHJhdGlvOiBzLCBzdGFydE9mZnNldFdpZHRoOiBvLCBzdGFydE9mZnNldEhlaWdodDogaSB9ID0gbjtcbiAgbGV0IGEgPSAwLCBjID0gMDtcbiAgY29uc3QgeyBkaXN0WDogbCwgZGlzdFk6IHUsIHBpbmNoU2NhbGU6IGYsIHBhcmVudERpc3RhbmNlOiBkLCBwYXJlbnREaXN0OiBwLCBwYXJlbnRTY2FsZTogZyB9ID0gciwgaCA9IG4uZml4ZWREaXJlY3Rpb24sIHYgPSBbMCwgMV0ubWFwKChTKSA9PiBCKHRbU10gLSBoW1NdKSksIG0gPSBbMCwgMV0ubWFwKChTKSA9PiB7XG4gICAgbGV0IHggPSB2W1NdO1xuICAgIHJldHVybiB4ICE9PSAwICYmICh4ID0gMiAvIHgpLCB4O1xuICB9KTtcbiAgaWYgKHApXG4gICAgYSA9IHBbMF0sIGMgPSBwWzFdLCBlICYmIChhID8gYyB8fCAoYyA9IGEgLyBzKSA6IGEgPSBjICogcyk7XG4gIGVsc2UgaWYgKGFuKGYpKVxuICAgIGEgPSAoZiAtIDEpICogbywgYyA9IChmIC0gMSkgKiBpO1xuICBlbHNlIGlmIChnKVxuICAgIGEgPSAoZ1swXSAtIDEpICogbywgYyA9IChnWzFdIC0gMSkgKiBpO1xuICBlbHNlIGlmIChkKSB7XG4gICAgY29uc3QgUyA9IG8gKiB2WzBdLCB4ID0gaSAqIHZbMV0sIEMgPSBWdChbUywgeF0pO1xuICAgIGEgPSBkIC8gQyAqIFMgKiBtWzBdLCBjID0gZCAvIEMgKiB4ICogbVsxXTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgUyA9IFF0KHsgZGF0YXM6IG4sIGRpc3RYOiBsLCBkaXN0WTogdSB9KTtcbiAgICBTID0gbS5tYXAoKHgsIEMpID0+IFNbQ10gKiB4KSwgW2EsIGNdID0gamkoXG4gICAgICBbbywgaV0sXG4gICAgICBTLFxuICAgICAgcyxcbiAgICAgIHQsXG4gICAgICBlXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC8vIGRpcmVjdGlvbixcbiAgICAvLyBzaXplRGlyZWN0aW9uLFxuICAgIGRpc3RXaWR0aDogYSxcbiAgICBkaXN0SGVpZ2h0OiBjXG4gIH07XG59XG5mdW5jdGlvbiBHcih0LCBlKSB7XG4gIGlmIChlKSB7XG4gICAgaWYgKHQgPT09IFwibGVmdFwiKVxuICAgICAgcmV0dXJuIHsgeDogXCIwJVwiLCB5OiBcIjUwJVwiIH07XG4gICAgaWYgKHQgPT09IFwidG9wXCIpXG4gICAgICByZXR1cm4geyB4OiBcIjUwJVwiLCB5OiBcIjUwJVwiIH07XG4gICAgaWYgKHQgPT09IFwiY2VudGVyXCIpXG4gICAgICByZXR1cm4geyB4OiBcIjUwJVwiLCB5OiBcIjUwJVwiIH07XG4gICAgaWYgKHQgPT09IFwicmlnaHRcIilcbiAgICAgIHJldHVybiB7IHg6IFwiMTAwJVwiLCB5OiBcIjUwJVwiIH07XG4gICAgaWYgKHQgPT09IFwiYm90dG9tXCIpXG4gICAgICByZXR1cm4geyB4OiBcIjUwJVwiLCB5OiBcIjEwMCVcIiB9O1xuICAgIGNvbnN0IFtuLCByXSA9IHQuc3BsaXQoXCIgXCIpLCBzID0gR3IobiB8fCBcIlwiKSwgbyA9IEdyKHIgfHwgXCJcIiksIGkgPSB7XG4gICAgICAuLi5zLFxuICAgICAgLi4ub1xuICAgIH0sIGEgPSB7XG4gICAgICB4OiBcIjUwJVwiLFxuICAgICAgeTogXCI1MCVcIlxuICAgIH07XG4gICAgcmV0dXJuIGkueCAmJiAoYS54ID0gaS54KSwgaS55ICYmIChhLnkgPSBpLnkpLCBpLnZhbHVlICYmIChpLnggJiYgIWkueSAmJiAoYS55ID0gaS52YWx1ZSksICFpLnggJiYgaS55ICYmIChhLnggPSBpLnZhbHVlKSksIGE7XG4gIH1cbiAgcmV0dXJuIHQgPT09IFwibGVmdFwiID8geyB4OiBcIjAlXCIgfSA6IHQgPT09IFwicmlnaHRcIiA/IHsgeDogXCIxMDAlXCIgfSA6IHQgPT09IFwidG9wXCIgPyB7IHk6IFwiMCVcIiB9IDogdCA9PT0gXCJib3R0b21cIiA/IHsgeTogXCIxMDAlXCIgfSA6IHQgPyB0ID09PSBcImNlbnRlclwiID8geyB2YWx1ZTogXCI1MCVcIiB9IDogeyB2YWx1ZTogdCB9IDoge307XG59XG5mdW5jdGlvbiBFcyh0LCBlLCBuKSB7XG4gIGNvbnN0IHsgeDogciwgeTogcyB9ID0gR3IodCwgITApO1xuICByZXR1cm4gW2Z0KHIsIGUpIHx8IDAsIGZ0KHMsIG4pIHx8IDBdO1xufVxuZnVuY3Rpb24gRHUodCwgZSwgbikge1xuICBjb25zdCByID0gdC5tYXAoKG8pID0+IEsobywgZSkpLCBzID0gci5tYXAoKG8pID0+IGduKG8sIG4pKTtcbiAgcmV0dXJuIHtcbiAgICBwcmV2OiByLFxuICAgIG5leHQ6IHMsXG4gICAgcmVzdWx0OiBzLm1hcCgobykgPT4gYXQobywgZSkpXG4gIH07XG59XG5mdW5jdGlvbiBIaSh0LCBlKSB7XG4gIHJldHVybiB0Lmxlbmd0aCA9PT0gZS5sZW5ndGggJiYgdC5ldmVyeSgobiwgcikgPT4ge1xuICAgIGNvbnN0IHMgPSBlW3JdLCBvID0gUnQobiksIGkgPSBSdChzKTtcbiAgICByZXR1cm4gbyAmJiBpID8gSGkobiwgcykgOiAhbyAmJiAhaSA/IG4gPT09IHMgOiAhMTtcbiAgfSk7XG59XG5mdW5jdGlvbiBBZSh0LCBlLCBuLCByLCBzKSB7XG4gIGNvbnN0IG8gPSB0Ll9zdG9yZTtcbiAgbGV0IGkgPSBvW2VdO1xuICBpZiAoIShlIGluIG8pKVxuICAgIGlmIChzICE9IG51bGwpXG4gICAgICBvW2VdID0gcywgaSA9IHM7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIG9bZV0gPSBuLCBuO1xuICByZXR1cm4gaSA9PT0gbiB8fCByKGkpID09PSByKG4pID8gaSA6IChvW2VdID0gbiwgbik7XG59XG5mdW5jdGlvbiB3dCh0KSB7XG4gIHJldHVybiB0ID49IDAgPyAxIDogLTE7XG59XG5mdW5jdGlvbiBCKHQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHQpO1xufVxuZnVuY3Rpb24gZ3IodCwgZSkge1xuICByZXR1cm4gYmModCkubWFwKChuKSA9PiBlKG4pKTtcbn1cbmZ1bmN0aW9uIHFpKHQpIHtcbiAgcmV0dXJuIGFuKHQpID8ge1xuICAgIHRvcDogdCxcbiAgICBsZWZ0OiB0LFxuICAgIHJpZ2h0OiB0LFxuICAgIGJvdHRvbTogdFxuICB9IDoge1xuICAgIGxlZnQ6IHQubGVmdCB8fCAwLFxuICAgIHRvcDogdC50b3AgfHwgMCxcbiAgICByaWdodDogdC5yaWdodCB8fCAwLFxuICAgIGJvdHRvbTogdC5ib3R0b20gfHwgMFxuICB9O1xufVxuY29uc3QgYnUgPSBkbihcInBpbmNoYWJsZVwiLCB7XG4gIHByb3BzOiBbXG4gICAgXCJwaW5jaGFibGVcIlxuICBdLFxuICBldmVudHM6IFtcbiAgICBcInBpbmNoU3RhcnRcIixcbiAgICBcInBpbmNoXCIsXG4gICAgXCJwaW5jaEVuZFwiLFxuICAgIFwicGluY2hHcm91cFN0YXJ0XCIsXG4gICAgXCJwaW5jaEdyb3VwXCIsXG4gICAgXCJwaW5jaEdyb3VwRW5kXCJcbiAgXSxcbiAgZHJhZ1N0YXJ0KCkge1xuICAgIHJldHVybiAhMDtcbiAgfSxcbiAgcGluY2hTdGFydCh0LCBlKSB7XG4gICAgY29uc3QgeyBkYXRhczogbiwgdGFyZ2V0czogciwgYW5nbGU6IHMsIG9yaWdpbmFsRGF0YXM6IG8gfSA9IGUsIHsgcGluY2hhYmxlOiBpLCBhYmxlczogYSB9ID0gdC5wcm9wcztcbiAgICBpZiAoIWkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYyA9IGBvblBpbmNoJHtyID8gXCJHcm91cFwiIDogXCJcIn1TdGFydGAsIGwgPSBgZHJhZyR7ciA/IFwiR3JvdXBcIiA6IFwiXCJ9Q29udHJvbFN0YXJ0YCwgdSA9IChpID09PSAhMCA/IHQuY29udHJvbEFibGVzIDogYS5maWx0ZXIoKGcpID0+IGkuaW5kZXhPZihnLm5hbWUpID4gLTEpKS5maWx0ZXIoKGcpID0+IGcuY2FuUGluY2ggJiYgZ1tsXSksIGYgPSBldCh0LCBlLCB7fSk7XG4gICAgciAmJiAoZi50YXJnZXRzID0gcik7XG4gICAgY29uc3QgZCA9IGoodCwgYywgZik7XG4gICAgbi5pc1BpbmNoID0gZCAhPT0gITEsIG4uYWJsZXMgPSB1O1xuICAgIGNvbnN0IHAgPSBuLmlzUGluY2g7XG4gICAgcmV0dXJuIHAgPyAodS5mb3JFYWNoKChnKSA9PiB7XG4gICAgICBpZiAob1tnLm5hbWVdID0gb1tnLm5hbWVdIHx8IHt9LCAhZ1tsXSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaCA9IHtcbiAgICAgICAgLi4uZSxcbiAgICAgICAgZGF0YXM6IG9bZy5uYW1lXSxcbiAgICAgICAgcGFyZW50Um90YXRlOiBzLFxuICAgICAgICBpc1BpbmNoOiAhMFxuICAgICAgfTtcbiAgICAgIGdbbF0odCwgaCk7XG4gICAgfSksIHQuc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XG4gICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdCxcbiAgICAgIGRpcmVjdGlvbjogWzAsIDBdXG4gICAgfSwgcCkgOiAhMTtcbiAgfSxcbiAgcGluY2godCwgZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFzOiBuLFxuICAgICAgc2NhbGU6IHIsXG4gICAgICBkaXN0YW5jZTogcyxcbiAgICAgIG9yaWdpbmFsRGF0YXM6IG8sXG4gICAgICBpbnB1dEV2ZW50OiBpLFxuICAgICAgdGFyZ2V0czogYSxcbiAgICAgIGFuZ2xlOiBjXG4gICAgfSA9IGU7XG4gICAgaWYgKCFuLmlzUGluY2gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbCA9IHMgKiAoMSAtIDEgLyByKSwgdSA9IGV0KHQsIGUsIHt9KTtcbiAgICBhICYmICh1LnRhcmdldHMgPSBhKSwgaih0LCBgb25QaW5jaCR7YSA/IFwiR3JvdXBcIiA6IFwiXCJ9YCwgdSk7XG4gICAgY29uc3QgZCA9IG4uYWJsZXMsIHAgPSBgZHJhZyR7YSA/IFwiR3JvdXBcIiA6IFwiXCJ9Q29udHJvbGA7XG4gICAgcmV0dXJuIGQuZm9yRWFjaCgoZykgPT4ge1xuICAgICAgZ1twXSAmJiBnW3BdKHQsIHtcbiAgICAgICAgLi4uZSxcbiAgICAgICAgZGF0YXM6IG9bZy5uYW1lXSxcbiAgICAgICAgaW5wdXRFdmVudDogaSxcbiAgICAgICAgcmVzb2x2ZU1hdHJpeDogITAsXG4gICAgICAgIHBpbmNoU2NhbGU6IHIsXG4gICAgICAgIHBhcmVudERpc3RhbmNlOiBsLFxuICAgICAgICBwYXJlbnRSb3RhdGU6IGMsXG4gICAgICAgIGlzUGluY2g6ICEwXG4gICAgICB9KTtcbiAgICB9KSwgdTtcbiAgfSxcbiAgcGluY2hFbmQodCwgZSkge1xuICAgIGNvbnN0IHsgZGF0YXM6IG4sIGlzUGluY2g6IHIsIGlucHV0RXZlbnQ6IHMsIHRhcmdldHM6IG8sIG9yaWdpbmFsRGF0YXM6IGkgfSA9IGU7XG4gICAgaWYgKCFuLmlzUGluY2gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYSA9IGBvblBpbmNoJHtvID8gXCJHcm91cFwiIDogXCJcIn1FbmRgLCBjID0gJHQodCwgZSwgeyBpc0RyYWc6IHIgfSk7XG4gICAgbyAmJiAoYy50YXJnZXRzID0gbyksIGoodCwgYSwgYyk7XG4gICAgY29uc3QgbCA9IG4uYWJsZXMsIHUgPSBgZHJhZyR7byA/IFwiR3JvdXBcIiA6IFwiXCJ9Q29udHJvbEVuZGA7XG4gICAgcmV0dXJuIGwuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgZlt1XSAmJiBmW3VdKHQsIHtcbiAgICAgICAgLi4uZSxcbiAgICAgICAgaXNEcmFnOiByLFxuICAgICAgICBkYXRhczogaVtmLm5hbWVdLFxuICAgICAgICBpbnB1dEV2ZW50OiBzLFxuICAgICAgICBpc1BpbmNoOiAhMFxuICAgICAgfSk7XG4gICAgfSksIHI7XG4gIH0sXG4gIHBpbmNoR3JvdXBTdGFydCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMucGluY2hTdGFydCh0LCB7IC4uLmUsIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyB9KTtcbiAgfSxcbiAgcGluY2hHcm91cCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMucGluY2godCwgeyAuLi5lLCB0YXJnZXRzOiB0LnByb3BzLnRhcmdldHMgfSk7XG4gIH0sXG4gIHBpbmNoR3JvdXBFbmQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLnBpbmNoRW5kKHQsIHsgLi4uZSwgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzIH0pO1xuICB9XG59KSwgZm8gPSB4cyhcInNjYWxhYmxlXCIpLCB5dSA9IHtcbiAgbmFtZTogXCJzY2FsYWJsZVwiLFxuICBhYmxlR3JvdXA6IFwic2l6ZVwiLFxuICBjYW5QaW5jaDogITAsXG4gIHByb3BzOiBbXG4gICAgXCJzY2FsYWJsZVwiLFxuICAgIFwidGhyb3R0bGVTY2FsZVwiLFxuICAgIFwicmVuZGVyRGlyZWN0aW9uc1wiLFxuICAgIFwia2VlcFJhdGlvXCIsXG4gICAgXCJlZGdlXCIsXG4gICAgXCJkaXNwbGF5QXJvdW5kQ29udHJvbHNcIlxuICBdLFxuICBldmVudHM6IFtcbiAgICBcInNjYWxlU3RhcnRcIixcbiAgICBcImJlZm9yZVNjYWxlXCIsXG4gICAgXCJzY2FsZVwiLFxuICAgIFwic2NhbGVFbmRcIixcbiAgICBcInNjYWxlR3JvdXBTdGFydFwiLFxuICAgIFwiYmVmb3JlU2NhbGVHcm91cFwiLFxuICAgIFwic2NhbGVHcm91cFwiLFxuICAgIFwic2NhbGVHcm91cEVuZFwiXG4gIF0sXG4gIHJlbmRlcjogZGkoXCJzY2FsYWJsZVwiKSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZvLFxuICB2aWV3Q2xhc3NOYW1lOiBtcyhcInNjYWxhYmxlXCIpLFxuICBkcmFnQ29udHJvbFN0YXJ0KHQsIGUpIHtcbiAgICBjb25zdCB7IGRhdGFzOiBuLCBpc1BpbmNoOiByLCBpbnB1dEV2ZW50OiBzLCBwYXJlbnREaXJlY3Rpb246IG8gfSA9IGUsIGkgPSBMaShcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIG5cbiAgICApLCB7IHdpZHRoOiBhLCBoZWlnaHQ6IGMsIHRhcmdldFRyYW5zZm9ybTogbCwgdGFyZ2V0OiB1LCBwb3MxOiBmLCBwb3MyOiBkLCBwb3M0OiBwIH0gPSB0LnN0YXRlO1xuICAgIGlmICghaSB8fCAhdSlcbiAgICAgIHJldHVybiAhMTtcbiAgICByIHx8IFJlKHQsIGUpLCBuLmRhdGFzID0ge30sIG4udHJhbnNmb3JtID0gbCwgbi5wcmV2RGlzdCA9IFsxLCAxXSwgbi5kaXJlY3Rpb24gPSBpLCBuLnN0YXJ0T2Zmc2V0V2lkdGggPSBhLCBuLnN0YXJ0T2Zmc2V0SGVpZ2h0ID0gYywgbi5zdGFydFZhbHVlID0gWzEsIDFdO1xuICAgIGNvbnN0IGcgPSAhaVswXSAmJiAhaVsxXSB8fCBpWzBdIHx8ICFpWzFdO1xuICAgIHFuKHQsIGUsIFwic2NhbGVcIiksIG4uaXNXaWR0aCA9IGc7XG4gICAgZnVuY3Rpb24gaChFKSB7XG4gICAgICBuLnJhdGlvID0gRSAmJiBpc0Zpbml0ZShFKSA/IEUgOiAwO1xuICAgIH1cbiAgICBuLnN0YXJ0UG9zaXRpb25zID0ganQodC5zdGF0ZSk7XG4gICAgZnVuY3Rpb24gdihFKSB7XG4gICAgICBjb25zdCBEID0geWkoXG4gICAgICAgIG4uc3RhcnRQb3NpdGlvbnMsXG4gICAgICAgIEVcbiAgICAgICk7XG4gICAgICBuLmZpeGVkRGlyZWN0aW9uID0gRC5maXhlZERpcmVjdGlvbiwgbi5maXhlZFBvc2l0aW9uID0gRC5maXhlZFBvc2l0aW9uLCBuLmZpeGVkT2Zmc2V0ID0gRC5maXhlZE9mZnNldDtcbiAgICB9XG4gICAgbi5zZXRGaXhlZERpcmVjdGlvbiA9IHYsIGgodGUoZiwgZCkgLyB0ZShkLCBwKSksIHYoWy1pWzBdLCAtaVsxXV0pO1xuICAgIGNvbnN0IG0gPSAoRSkgPT4ge1xuICAgICAgbi5taW5TY2FsZVNpemUgPSBFO1xuICAgIH0sIFMgPSAoRSkgPT4ge1xuICAgICAgbi5tYXhTY2FsZVNpemUgPSBFO1xuICAgIH07XG4gICAgbShbLTEgLyAwLCAtMSAvIDBdKSwgUyhbMSAvIDAsIDEgLyAwXSk7XG4gICAgY29uc3QgeCA9IGV0KHQsIGUsIHtcbiAgICAgIGRpcmVjdGlvbjogaSxcbiAgICAgIHNldDogKEUpID0+IHtcbiAgICAgICAgbi5zdGFydFZhbHVlID0gRTtcbiAgICAgIH0sXG4gICAgICBzZXRSYXRpbzogaCxcbiAgICAgIHNldEZpeGVkRGlyZWN0aW9uOiB2LFxuICAgICAgc2V0TWluU2NhbGVTaXplOiBtLFxuICAgICAgc2V0TWF4U2NhbGVTaXplOiBTLFxuICAgICAgLi4uSG4odCwgZSksXG4gICAgICBkcmFnU3RhcnQ6IE90LmRyYWdTdGFydChcbiAgICAgICAgdCxcbiAgICAgICAgbmV3IEZlKCkuZHJhZ1N0YXJ0KFswLCAwXSwgZSlcbiAgICAgIClcbiAgICB9KSwgQyA9IGoodCwgXCJvblNjYWxlU3RhcnRcIiwgeCk7XG4gICAgcmV0dXJuIG4uc3RhcnRGaXhlZERpcmVjdGlvbiA9IG4uZml4ZWREaXJlY3Rpb24sIEMgIT09ICExICYmIChuLmlzU2NhbGUgPSAhMCwgdC5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxuICAgICAgZGlyZWN0aW9uOiBpXG4gICAgfSksIG4uaXNTY2FsZSA/IHggOiAhMTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2wodCwgZSkge1xuICAgIGpuKHQsIGUsIFwic2NhbGVcIik7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YXM6IG4sXG4gICAgICBwYXJlbnRLZWVwUmF0aW86IHIsXG4gICAgICBwYXJlbnRGbGFnOiBzLFxuICAgICAgaXNQaW5jaDogbyxcbiAgICAgIGRyYWdDbGllbnQ6IGksXG4gICAgICBpc1JlcXVlc3Q6IGEsXG4gICAgICB1c2VTbmFwOiBjLFxuICAgICAgcmVzb2x2ZU1hdHJpeDogbFxuICAgIH0gPSBlLCB7XG4gICAgICBwcmV2RGlzdDogdSxcbiAgICAgIGRpcmVjdGlvbjogZixcbiAgICAgIHN0YXJ0T2Zmc2V0V2lkdGg6IGQsXG4gICAgICBzdGFydE9mZnNldEhlaWdodDogcCxcbiAgICAgIGlzU2NhbGU6IGcsXG4gICAgICBzdGFydFZhbHVlOiBoLFxuICAgICAgaXNXaWR0aDogdixcbiAgICAgIHJhdGlvOiBtXG4gICAgfSA9IG47XG4gICAgaWYgKCFnKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IFMgPSB0LnByb3BzLCB7IHRocm90dGxlU2NhbGU6IHgsIHBhcmVudE1vdmVhYmxlOiBDIH0gPSBTO1xuICAgIGxldCBFID0gZjtcbiAgICAhZlswXSAmJiAhZlsxXSAmJiAoRSA9IFsxLCAxXSk7XG4gICAgY29uc3QgRCA9IG0gJiYgKHIgPz8gUy5rZWVwUmF0aW8pIHx8ICExLCBSID0gdC5zdGF0ZSwgeSA9IFtoWzBdLCBoWzFdXTtcbiAgICBmdW5jdGlvbiBNKCkge1xuICAgICAgY29uc3QgeyBkaXN0V2lkdGg6IHEsIGRpc3RIZWlnaHQ6IEYgfSA9IFhpKFxuICAgICAgICBFLFxuICAgICAgICBELFxuICAgICAgICBuLFxuICAgICAgICBlXG4gICAgICApLCBIID0gZCA/IChkICsgcSkgLyBkIDogMSwgbnQgPSBwID8gKHAgKyBGKSAvIHAgOiAxO1xuICAgICAgaFswXSB8fCAoeVswXSA9IHEgLyBkKSwgaFsxXSB8fCAoeVsxXSA9IEYgLyBwKTtcbiAgICAgIGxldCBsdCA9IChFWzBdIHx8IEQgPyBIIDogMSkgKiB5WzBdLCB2dCA9IChFWzFdIHx8IEQgPyBudCA6IDEpICogeVsxXTtcbiAgICAgIHJldHVybiBsdCA9PT0gMCAmJiAobHQgPSB3dCh1WzBdKSAqIFNuKSwgdnQgPT09IDAgJiYgKHZ0ID0gd3QodVsxXSkgKiBTbiksIFtsdCwgdnRdO1xuICAgIH1cbiAgICBsZXQgUCA9IE0oKTtcbiAgICBpZiAoIW8gJiYgdC5wcm9wcy5ncm91cGFibGUpIHtcbiAgICAgIGNvbnN0IEYgPSAoUi5zbmFwUmVuZGVySW5mbyB8fCB7fSkuZGlyZWN0aW9uO1xuICAgICAgUnQoRikgJiYgKEZbMF0gfHwgRlsxXSkgJiYgKFIuc25hcFJlbmRlckluZm8gPSB7IGRpcmVjdGlvbjogZiwgcmVxdWVzdDogZS5pc1JlcXVlc3QgfSk7XG4gICAgfVxuICAgIGooXG4gICAgICB0LFxuICAgICAgXCJvbkJlZm9yZVNjYWxlXCIsXG4gICAgICBldChcbiAgICAgICAgdCxcbiAgICAgICAgZSxcbiAgICAgICAge1xuICAgICAgICAgIHNjYWxlOiBQLFxuICAgICAgICAgIHNldEZpeGVkRGlyZWN0aW9uKHEpIHtcbiAgICAgICAgICAgIHJldHVybiBuLnNldEZpeGVkRGlyZWN0aW9uKHEpLCBQID0gTSgpLCBQO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhcnRGaXhlZERpcmVjdGlvbjogbi5zdGFydEZpeGVkRGlyZWN0aW9uLFxuICAgICAgICAgIHNldFNjYWxlKHEpIHtcbiAgICAgICAgICAgIFAgPSBxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgITBcbiAgICAgIClcbiAgICApO1xuICAgIGxldCBfID0gW1BbMF0gLyB5WzBdLCBQWzFdIC8geVsxXV0sIE8gPSBpLCBUID0gWzAsIDBdO1xuICAgIGNvbnN0IHcgPSB3dChfWzBdICogX1sxXSksIGsgPSAhaSAmJiAhcyAmJiBvO1xuICAgIGlmIChrIHx8IGwgPyBPID0gaXMoXG4gICAgICB0LFxuICAgICAgbi50YXJnZXRBbGxUcmFuc2Zvcm0sXG4gICAgICBbMCwgMF0sXG4gICAgICBbMCwgMF0sXG4gICAgICBuXG4gICAgKSA6IGkgfHwgKE8gPSBuLmZpeGVkUG9zaXRpb24pLCBvIHx8IChUID0gZXUoXG4gICAgICB0LFxuICAgICAgXyxcbiAgICAgIGYsXG4gICAgICAhYyAmJiBhLFxuICAgICAgblxuICAgICkpLCBEKSB7XG4gICAgICBFWzBdICYmIEVbMV0gJiYgVFswXSAmJiBUWzFdICYmIChNYXRoLmFicyhUWzBdICogZCkgPiBNYXRoLmFicyhUWzFdICogcCkgPyBUWzFdID0gMCA6IFRbMF0gPSAwKTtcbiAgICAgIGNvbnN0IHEgPSAhVFswXSAmJiAhVFsxXTtcbiAgICAgIGlmIChxICYmICh2ID8gX1swXSA9IHR0KF9bMF0gKiB5WzBdLCB4KSAvIHlbMF0gOiBfWzFdID0gdHQoX1sxXSAqIHlbMV0sIHgpIC8geVsxXSksIEVbMF0gJiYgIUVbMV0gfHwgVFswXSAmJiAhVFsxXSB8fCBxICYmIHYpIHtcbiAgICAgICAgX1swXSArPSBUWzBdO1xuICAgICAgICBjb25zdCBGID0gZCAqIF9bMF0gKiB5WzBdIC8gbTtcbiAgICAgICAgX1sxXSA9IHd0KHcgKiBfWzBdKSAqIEIoRiAvIHAgLyB5WzFdKTtcbiAgICAgIH0gZWxzZSBpZiAoIUVbMF0gJiYgRVsxXSB8fCAhVFswXSAmJiBUWzFdIHx8IHEgJiYgIXYpIHtcbiAgICAgICAgX1sxXSArPSBUWzFdO1xuICAgICAgICBjb25zdCBGID0gcCAqIF9bMV0gKiB5WzFdICogbTtcbiAgICAgICAgX1swXSA9IHd0KHcgKiBfWzFdKSAqIEIoRiAvIGQgLyB5WzBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIF9bMF0gKz0gVFswXSwgX1sxXSArPSBUWzFdLCBUWzBdIHx8IChfWzBdID0gdHQoX1swXSAqIHlbMF0sIHgpIC8geVswXSksIFRbMV0gfHwgKF9bMV0gPSB0dChfWzFdICogeVsxXSwgeCkgLyB5WzFdKTtcbiAgICBfWzBdID09PSAwICYmIChfWzBdID0gd3QodVswXSkgKiBTbiksIF9bMV0gPT09IDAgJiYgKF9bMV0gPSB3dCh1WzFdKSAqIFNuKSwgUCA9IG91KF8sIFt5WzBdLCB5WzFdXSk7XG4gICAgY29uc3QgSSA9IFtkLCBwXTtcbiAgICBsZXQgJCA9IFtkICogUFswXSwgcCAqIFBbMV1dO1xuICAgICQgPSBxbyhcbiAgICAgICQsXG4gICAgICBuLm1pblNjYWxlU2l6ZSxcbiAgICAgIG4ubWF4U2NhbGVTaXplLFxuICAgICAgRCA/IG0gOiAhMVxuICAgICksIFAgPSBncigyLCAocSkgPT4gSVtxXSA/ICRbcV0gLyBJW3FdIDogJFtxXSksIF8gPSBncigyLCAocSkgPT4gUFtxXSAvIHlbcV0pO1xuICAgIGNvbnN0IEcgPSBncihcbiAgICAgIDIsXG4gICAgICAocSkgPT4gdVtxXSA/IF9bcV0gLyB1W3FdIDogX1txXVxuICAgICksIEwgPSBgc2NhbGUoJHtfLmpvaW4oXCIsIFwiKX0pYCwgeiA9IGBzY2FsZSgke1Auam9pbihcIiwgXCIpfSlgLCBOID0gWG4obiwgeiwgTCksIFogPSAhaFswXSB8fCAhaFsxXSwgWSA9IFZjKFxuICAgICAgdCxcbiAgICAgIFogPyB6IDogTCxcbiAgICAgIG4uZml4ZWREaXJlY3Rpb24sXG4gICAgICBPLFxuICAgICAgbi5maXhlZE9mZnNldCxcbiAgICAgIG4sXG4gICAgICBaXG4gICAgKSwgVyA9IGsgPyBZIDogSyhZLCBuLnByZXZJbnZlcnNlRGlzdCB8fCBbMCwgMF0pO1xuICAgIGlmIChuLnByZXZEaXN0ID0gXywgbi5wcmV2SW52ZXJzZURpc3QgPSBZLCBQWzBdID09PSB1WzBdICYmIFBbMV0gPT09IHVbMV0gJiYgVy5ldmVyeSgocSkgPT4gIXEpICYmICFDICYmICFrKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IEogPSBldCh0LCBlLCB7XG4gICAgICBvZmZzZXRXaWR0aDogZCxcbiAgICAgIG9mZnNldEhlaWdodDogcCxcbiAgICAgIGRpcmVjdGlvbjogZixcbiAgICAgIHNjYWxlOiBQLFxuICAgICAgZGlzdDogXyxcbiAgICAgIGRlbHRhOiBHLFxuICAgICAgaXNQaW5jaDogISFvLFxuICAgICAgLi4uaWkodCwgTiwgVywgbywgZSlcbiAgICB9KTtcbiAgICByZXR1cm4gaih0LCBcIm9uU2NhbGVcIiwgSiksIEo7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kKHQsIGUpIHtcbiAgICBjb25zdCB7IGRhdGFzOiBuIH0gPSBlO1xuICAgIGlmICghbi5pc1NjYWxlKVxuICAgICAgcmV0dXJuICExO1xuICAgIG4uaXNTY2FsZSA9ICExO1xuICAgIGNvbnN0IHIgPSAkdCh0LCBlLCB7fSk7XG4gICAgcmV0dXJuIGoodCwgXCJvblNjYWxlRW5kXCIsIHIpLCByO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sQ29uZGl0aW9uOiBmbyxcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0KHQsIGUpIHtcbiAgICBjb25zdCB7IGRhdGFzOiBuIH0gPSBlLCByID0gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KHQsIGUpO1xuICAgIGlmICghcilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzID0gSHQodCwgXCJyZXNpemFibGVcIiwgZSk7XG4gICAgbi5tb3ZlYWJsZVNjYWxlID0gdC5zY2FsZTtcbiAgICBjb25zdCBvID0gZWUoXG4gICAgICB0LFxuICAgICAgdGhpcyxcbiAgICAgIFwiZHJhZ0NvbnRyb2xTdGFydFwiLFxuICAgICAgZSxcbiAgICAgIChsLCB1KSA9PiBrbih0LCBsLCBuLCB1KVxuICAgICksIGkgPSAobCkgPT4ge1xuICAgICAgci5zZXRGaXhlZERpcmVjdGlvbihsKSwgby5mb3JFYWNoKCh1LCBmKSA9PiB7XG4gICAgICAgIHUuc2V0Rml4ZWREaXJlY3Rpb24obCksIGtuKHQsIHUubW92ZWFibGUsIG4sIHNbZl0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBuLnNldEZpeGVkRGlyZWN0aW9uID0gaTtcbiAgICBjb25zdCBhID0ge1xuICAgICAgLi4ucixcbiAgICAgIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogbyxcbiAgICAgIHNldEZpeGVkRGlyZWN0aW9uOiBpXG4gICAgfSwgYyA9IGoodCwgXCJvblNjYWxlR3JvdXBTdGFydFwiLCBhKTtcbiAgICByZXR1cm4gbi5pc1NjYWxlID0gYyAhPT0gITEsIG4uaXNTY2FsZSA/IGEgOiAhMTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbCh0LCBlKSB7XG4gICAgY29uc3QgeyBkYXRhczogbiB9ID0gZTtcbiAgICBpZiAoIW4uaXNTY2FsZSlcbiAgICAgIHJldHVybjtcbiAgICBRbih0LCBcIm9uQmVmb3JlU2NhbGVcIiwgKHUpID0+IHtcbiAgICAgIGooXG4gICAgICAgIHQsXG4gICAgICAgIFwib25CZWZvcmVTY2FsZUdyb3VwXCIsXG4gICAgICAgIGV0KFxuICAgICAgICAgIHQsXG4gICAgICAgICAgZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi51LFxuICAgICAgICAgICAgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzXG4gICAgICAgICAgfSxcbiAgICAgICAgICAhMFxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICAgIGNvbnN0IHIgPSB0aGlzLmRyYWdDb250cm9sKHQsIGUpO1xuICAgIGlmICghcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGRpc3Q6IHMgfSA9IHIsIG8gPSBuLm1vdmVhYmxlU2NhbGU7XG4gICAgdC5zY2FsZSA9IFtzWzBdICogb1swXSwgc1sxXSAqIG9bMV1dO1xuICAgIGNvbnN0IGkgPSB0LnByb3BzLmtlZXBSYXRpbywgYSA9IG4uZml4ZWRQb3NpdGlvbiwgYyA9IGVlKFxuICAgICAgdCxcbiAgICAgIHRoaXMsXG4gICAgICBcImRyYWdDb250cm9sXCIsXG4gICAgICBlLFxuICAgICAgKHUsIGYpID0+IHtcbiAgICAgICAgY29uc3QgW2QsIHBdID0gX3QoXG4gICAgICAgICAgaG4odC5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUEksIDMpLFxuICAgICAgICAgIFtmLmRhdGFzLm9yaWdpbmFsWCAqIHNbMF0sIGYuZGF0YXMub3JpZ2luYWxZICogc1sxXSwgMV0sXG4gICAgICAgICAgM1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmYsXG4gICAgICAgICAgcGFyZW50RGlzdDogbnVsbCxcbiAgICAgICAgICBwYXJlbnRTY2FsZTogcyxcbiAgICAgICAgICBwYXJlbnRLZWVwUmF0aW86IGksXG4gICAgICAgICAgLy8gcmVjYWxjdWxhdGUgY2hpbGQgZml4ZWQgcG9zaXRpb24gZm9yIHBhcmVudCBncm91cCdzIGRyYWdnaW5nLlxuICAgICAgICAgIGRyYWdDbGllbnQ6IGF0KGEsIFtkLCBwXSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApLCBsID0ge1xuICAgICAgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBjLFxuICAgICAgLi4uclxuICAgIH07XG4gICAgcmV0dXJuIGoodCwgXCJvblNjYWxlR3JvdXBcIiwgbCksIGw7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xFbmQodCwgZSkge1xuICAgIGNvbnN0IHsgaXNEcmFnOiBuLCBkYXRhczogciB9ID0gZTtcbiAgICBpZiAoIXIuaXNTY2FsZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRyYWdDb250cm9sRW5kKHQsIGUpO1xuICAgIGNvbnN0IHMgPSBlZSh0LCB0aGlzLCBcImRyYWdDb250cm9sRW5kXCIsIGUpLCBvID0gJHQodCwgZSwge1xuICAgICAgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBzXG4gICAgfSk7XG4gICAgcmV0dXJuIGoodCwgXCJvblNjYWxlR3JvdXBFbmRcIiwgbyksIG47XG4gIH0sXG4gIC8qKlxuICAgICAgICogQG1ldGhvZCBNb3ZlYWJsZS5TY2FsYWJsZSNyZXF1ZXN0XG4gICAgICAgKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLlNjYWxhYmxlUmVxdWVzdFBhcmFtfSBlIC0gdGhlIFNjYWxhYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcbiAgICAgICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICAgICAgKiBAZXhhbXBsZVxuICBcbiAgICAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcbiAgICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJzY2FsYWJsZVwiLCB7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSwgdHJ1ZSk7XG4gICAgICAgKlxuICAgICAgICogLy8gcmVxdWVzdFN0YXJ0XG4gICAgICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwic2NhbGFibGVcIik7XG4gICAgICAgKlxuICAgICAgICogLy8gcmVxdWVzdFxuICAgICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xuICAgICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xuICAgICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xuICAgICAgICpcbiAgICAgICAqIC8vIHJlcXVlc3RFbmRcbiAgICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0RW5kKCk7XG4gICAgICAgKi9cbiAgcmVxdWVzdCgpIHtcbiAgICBjb25zdCB0ID0ge307XG4gICAgbGV0IGUgPSAwLCBuID0gMCwgciA9ICExO1xuICAgIHJldHVybiB7XG4gICAgICBpc0NvbnRyb2w6ICEwLFxuICAgICAgcmVxdWVzdFN0YXJ0KHMpIHtcbiAgICAgICAgcmV0dXJuIHIgPSBzLnVzZVNuYXAsIHtcbiAgICAgICAgICBkYXRhczogdCxcbiAgICAgICAgICBwYXJlbnREaXJlY3Rpb246IHMuZGlyZWN0aW9uIHx8IFsxLCAxXSxcbiAgICAgICAgICB1c2VTbmFwOiByXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdChzKSB7XG4gICAgICAgIHJldHVybiBlICs9IHMuZGVsdGFXaWR0aCwgbiArPSBzLmRlbHRhSGVpZ2h0LCB7XG4gICAgICAgICAgZGF0YXM6IHQsXG4gICAgICAgICAgcGFyZW50RGlzdDogW2UsIG5dLFxuICAgICAgICAgIHBhcmVudEtlZXBSYXRpbzogcy5rZWVwUmF0aW8sXG4gICAgICAgICAgdXNlU25hcDogclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RFbmQoKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGFzOiB0LCBpc0RyYWc6ICEwLCB1c2VTbmFwOiByIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNlKHQsIGUpIHtcbiAgcmV0dXJuIHQubWFwKChuLCByKSA9PiB6bihuLCBlW3JdLCAxLCAyKSk7XG59XG5mdW5jdGlvbiBwbyh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSB4dCh0LCBlKSwgbyA9IHh0KHQsIG4pIC0gcjtcbiAgcmV0dXJuIG8gPj0gMCA/IG8gOiBvICsgMiAqIE1hdGguUEk7XG59XG5mdW5jdGlvbiBSdSh0LCBlKSB7XG4gIGNvbnN0IG4gPSBwbyh0WzBdLCB0WzFdLCB0WzJdKSwgciA9IHBvKGVbMF0sIGVbMV0sIGVbMl0pLCBzID0gTWF0aC5QSTtcbiAgcmV0dXJuICEobiA+PSBzICYmIHIgPD0gcyB8fCBuIDw9IHMgJiYgciA+PSBzKTtcbn1cbmNvbnN0IE11ID0ge1xuICBuYW1lOiBcIndhcnBhYmxlXCIsXG4gIGFibGVHcm91cDogXCJzaXplXCIsXG4gIHByb3BzOiBbXG4gICAgXCJ3YXJwYWJsZVwiLFxuICAgIFwicmVuZGVyRGlyZWN0aW9uc1wiLFxuICAgIFwiZWRnZVwiLFxuICAgIFwiZGlzcGxheUFyb3VuZENvbnRyb2xzXCJcbiAgXSxcbiAgZXZlbnRzOiBbXCJ3YXJwU3RhcnRcIiwgXCJ3YXJwXCIsIFwid2FycEVuZFwiXSxcbiAgdmlld0NsYXNzTmFtZTogbXMoXCJ3YXJwYWJsZVwiKSxcbiAgcmVuZGVyKHQsIGUpIHtcbiAgICBjb25zdCB7IHJlc2l6YWJsZTogbiwgc2NhbGFibGU6IHIsIHdhcnBhYmxlOiBzLCB6b29tOiBvIH0gPSB0LnByb3BzO1xuICAgIGlmIChuIHx8IHIgfHwgIXMpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgeyBwb3MxOiBpLCBwb3MyOiBhLCBwb3MzOiBjLCBwb3M0OiBsIH0gPSB0LnN0YXRlLCB1ID0gc2UoaSwgYSksIGYgPSBzZShhLCBpKSwgZCA9IHNlKGksIGMpLCBwID0gc2UoYywgaSksIGcgPSBzZShjLCBsKSwgaCA9IHNlKGwsIGMpLCB2ID0gc2UoYSwgbCksIG0gPSBzZShsLCBhKTtcbiAgICByZXR1cm4gW1xuICAgICAgLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogVShcImxpbmVcIiksXG4gICAgICAgICAgc3R5bGU6IEplKHUsIGcsIG8pXG4gICAgICAgIH0sXG4gICAgICAgIFwibWlkZGVMaW5lMVwiXG4gICAgICApLFxuICAgICAgLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogVShcImxpbmVcIiksXG4gICAgICAgICAgc3R5bGU6IEplKGYsIGgsIG8pXG4gICAgICAgIH0sXG4gICAgICAgIFwibWlkZGVMaW5lMlwiXG4gICAgICApLFxuICAgICAgLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogVShcImxpbmVcIiksXG4gICAgICAgICAgc3R5bGU6IEplKGQsIHYsIG8pXG4gICAgICAgIH0sXG4gICAgICAgIFwibWlkZGVMaW5lM1wiXG4gICAgICApLFxuICAgICAgLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogVShcImxpbmVcIiksXG4gICAgICAgICAgc3R5bGU6IEplKHAsIG0sIG8pXG4gICAgICAgIH0sXG4gICAgICAgIFwibWlkZGVMaW5lNFwiXG4gICAgICApLFxuICAgICAgLi4ucGkodCwgXCJ3YXJwYWJsZVwiLCBlKVxuICAgIF07XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uKHQsIGUpIHtcbiAgICBpZiAoZS5pc1JlcXVlc3QpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbiA9IGUuaW5wdXRFdmVudC50YXJnZXQ7XG4gICAgcmV0dXJuIGJ0KG4sIFUoXCJkaXJlY3Rpb25cIikpICYmIGJ0KG4sIFUoXCJ3YXJwYWJsZVwiKSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQodCwgZSkge1xuICAgIGNvbnN0IHsgZGF0YXM6IG4sIGlucHV0RXZlbnQ6IHIgfSA9IGUsIHsgdGFyZ2V0OiBzIH0gPSB0LnByb3BzLCB7IHRhcmdldDogbyB9ID0gciwgaSA9IE5pKG8sIG4pO1xuICAgIGlmICghaSB8fCAhcylcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBhID0gdC5zdGF0ZSwge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBjLFxuICAgICAgaXMzZDogbCxcbiAgICAgIHRhcmdldFRyYW5zZm9ybTogdSxcbiAgICAgIHRhcmdldE1hdHJpeDogZixcbiAgICAgIHdpZHRoOiBkLFxuICAgICAgaGVpZ2h0OiBwLFxuICAgICAgbGVmdDogZyxcbiAgICAgIHRvcDogaFxuICAgIH0gPSBhO1xuICAgIG4uZGF0YXMgPSB7fSwgbi50YXJnZXRUcmFuc2Zvcm0gPSB1LCBuLndhcnBUYXJnZXRNYXRyaXggPSBsID8gZiA6IFV0KGYsIDMsIDQpLCBuLnRhcmdldEludmVyc2VNYXRyaXggPSBRbyhcbiAgICAgIEp0KG4ud2FycFRhcmdldE1hdHJpeCwgNCksXG4gICAgICAzLFxuICAgICAgNFxuICAgICksIG4uZGlyZWN0aW9uID0gaSwgbi5sZWZ0ID0gZywgbi50b3AgPSBoLCBuLnBvc2VzID0gW1xuICAgICAgWzAsIDBdLFxuICAgICAgW2QsIDBdLFxuICAgICAgWzAsIHBdLFxuICAgICAgW2QsIHBdXG4gICAgXS5tYXAoKFMpID0+IEsoUywgYykpLCBuLm5leHRQb3NlcyA9IG4ucG9zZXMubWFwKFxuICAgICAgKFtTLCB4XSkgPT4gX3Qobi53YXJwVGFyZ2V0TWF0cml4LCBbUywgeCwgMCwgMV0sIDQpXG4gICAgKSwgbi5zdGFydFZhbHVlID0gZ3QoNCksIG4ucHJldk1hdHJpeCA9IGd0KDQpLCBuLmFic29sdXRlUG9zZXMgPSBqdChhKSwgbi5wb3NJbmRleGVzID0gb2koaSksIFJlKHQsIGUpLCBxbih0LCBlLCBcIm1hdHJpeDNkXCIpLCBhLnNuYXBSZW5kZXJJbmZvID0ge1xuICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXG4gICAgICBkaXJlY3Rpb246IGlcbiAgICB9O1xuICAgIGNvbnN0IHYgPSBldCh0LCBlLCB7XG4gICAgICBzZXQ6IChTKSA9PiB7XG4gICAgICAgIG4uc3RhcnRWYWx1ZSA9IFM7XG4gICAgICB9LFxuICAgICAgLi4uSG4odCwgZSlcbiAgICB9KTtcbiAgICByZXR1cm4gaih0LCBcIm9uV2FycFN0YXJ0XCIsIHYpICE9PSAhMSAmJiAobi5pc1dhcnAgPSAhMCksIG4uaXNXYXJwO1xuICB9LFxuICBkcmFnQ29udHJvbCh0LCBlKSB7XG4gICAgY29uc3QgeyBkYXRhczogbiwgaXNSZXF1ZXN0OiByIH0gPSBlO1xuICAgIGxldCB7IGRpc3RYOiBzLCBkaXN0WTogbyB9ID0gZTtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXRJbnZlcnNlTWF0cml4OiBpLFxuICAgICAgcHJldk1hdHJpeDogYSxcbiAgICAgIGlzV2FycDogYyxcbiAgICAgIHN0YXJ0VmFsdWU6IGwsXG4gICAgICBwb3NlczogdSxcbiAgICAgIHBvc0luZGV4ZXM6IGYsXG4gICAgICBhYnNvbHV0ZVBvc2VzOiBkXG4gICAgfSA9IG47XG4gICAgaWYgKCFjKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmIChqbih0LCBlLCBcIm1hdHJpeDNkXCIpLCBYZSh0LCBcIndhcnBhYmxlXCIpKSB7XG4gICAgICBjb25zdCBFID0gZi5tYXAoXG4gICAgICAgICh5KSA9PiBkW3ldXG4gICAgICApO1xuICAgICAgRS5sZW5ndGggPiAxICYmIEUucHVzaChbXG4gICAgICAgIChFWzBdWzBdICsgRVsxXVswXSkgLyAyLFxuICAgICAgICAoRVswXVsxXSArIEVbMV1bMV0pIC8gMlxuICAgICAgXSk7XG4gICAgICBjb25zdCB7IGhvcml6b250YWw6IEQsIHZlcnRpY2FsOiBSIH0gPSBabih0LCByLCB7XG4gICAgICAgIGhvcml6b250YWw6IEUubWFwKCh5KSA9PiB5WzFdICsgbyksXG4gICAgICAgIHZlcnRpY2FsOiBFLm1hcCgoeSkgPT4geVswXSArIHMpXG4gICAgICB9KTtcbiAgICAgIG8gLT0gRC5vZmZzZXQsIHMgLT0gUi5vZmZzZXQ7XG4gICAgfVxuICAgIGNvbnN0IHAgPSBRdCh7IGRhdGFzOiBuLCBkaXN0WDogcywgZGlzdFk6IG8gfSwgITApLCBnID0gbi5uZXh0UG9zZXMuc2xpY2UoKTtcbiAgICBpZiAoZi5mb3JFYWNoKChFKSA9PiB7XG4gICAgICBnW0VdID0gYXQoZ1tFXSwgcCk7XG4gICAgfSksICFpYy5ldmVyeShcbiAgICAgIChFKSA9PiBSdShcbiAgICAgICAgRS5tYXAoKEQpID0+IHVbRF0pLFxuICAgICAgICBFLm1hcCgoRCkgPT4gZ1tEXSlcbiAgICAgIClcbiAgICApKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGggPSBzcyhcbiAgICAgIHVbMF0sXG4gICAgICB1WzJdLFxuICAgICAgdVsxXSxcbiAgICAgIHVbM10sXG4gICAgICBnWzBdLFxuICAgICAgZ1syXSxcbiAgICAgIGdbMV0sXG4gICAgICBnWzNdXG4gICAgKTtcbiAgICBpZiAoIWgubGVuZ3RoKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHYgPSBkdChpLCBoLCA0KSwgbSA9IHJpKG4sIHYsICEwKSwgUyA9IGR0KEp0KGEsIDQpLCBtLCA0KTtcbiAgICBuLnByZXZNYXRyaXggPSBtO1xuICAgIGNvbnN0IHggPSBkdChsLCBtLCA0KSwgQyA9IFhuKFxuICAgICAgbixcbiAgICAgIGBtYXRyaXgzZCgke3guam9pbihcIiwgXCIpfSlgLFxuICAgICAgYG1hdHJpeDNkKCR7bS5qb2luKFwiLCBcIil9KWBcbiAgICApO1xuICAgIHJldHVybiBvcyhlLCBDKSwgaihcbiAgICAgIHQsXG4gICAgICBcIm9uV2FycFwiLFxuICAgICAgZXQodCwgZSwge1xuICAgICAgICBkZWx0YTogUyxcbiAgICAgICAgbWF0cml4OiB4LFxuICAgICAgICBkaXN0OiBtLFxuICAgICAgICBtdWx0aXBseTogZHQsXG4gICAgICAgIHRyYW5zZm9ybTogQyxcbiAgICAgICAgLi4uSXQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBDXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgKSwgITA7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kKHQsIGUpIHtcbiAgICBjb25zdCB7IGRhdGFzOiBuLCBpc0RyYWc6IHIgfSA9IGU7XG4gICAgcmV0dXJuIG4uaXNXYXJwID8gKG4uaXNXYXJwID0gITEsIGooXG4gICAgICB0LFxuICAgICAgXCJvbldhcnBFbmRcIixcbiAgICAgICR0KHQsIGUsIHt9KVxuICAgICksIHIpIDogITE7XG4gIH1cbn0sIFB1ID0gLyogQF9fUFVSRV9fICovIFUoXCJhcmVhLXBpZWNlc1wiKSwgUG4gPSAvKiBAX19QVVJFX18gKi8gVShcImFyZWEtcGllY2VcIiksIFVpID0gLyogQF9fUFVSRV9fICovIFUoXCJhdm9pZFwiKSwgX3UgPSBVKFwidmlldy1kcmFnZ2luZ1wiKTtcbmZ1bmN0aW9uIGhyKHQpIHtcbiAgY29uc3QgZSA9IHQuYXJlYUVsZW1lbnQ7XG4gIGlmICghZSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHsgd2lkdGg6IG4sIGhlaWdodDogciB9ID0gdC5zdGF0ZTtcbiAgWm8oZSwgVWkpLCBlLnN0eWxlLmNzc1RleHQgKz0gYGxlZnQ6IDBweDsgdG9wOiAwcHg7IHdpZHRoOiAke259cHg7IGhlaWdodDogJHtyfXB4YDtcbn1cbmZ1bmN0aW9uIGdvKHQpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpdC5qc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBQdSwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaXQuanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBQbiB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gaXQuanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBQbiB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gaXQuanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBQbiB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gaXQuanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBQbiB9KVxuICBdIH0sIFwiYXJlYV9waWVjZXNcIik7XG59XG5jb25zdCBLaSA9IHtcbiAgbmFtZTogXCJkcmFnQXJlYVwiLFxuICBwcm9wczogW1wiZHJhZ0FyZWFcIiwgXCJwYXNzRHJhZ0FyZWFcIl0sXG4gIGV2ZW50czogW1wiY2xpY2tcIiwgXCJjbGlja0dyb3VwXCJdLFxuICByZW5kZXIodCwgZSkge1xuICAgIGNvbnN0IHsgdGFyZ2V0OiBuLCBkcmFnQXJlYTogciwgZ3JvdXBhYmxlOiBzLCBwYXNzRHJhZ0FyZWE6IG8gfSA9IHQucHJvcHMsIHsgd2lkdGg6IGksIGhlaWdodDogYSwgcmVuZGVyUG9zZXM6IGMgfSA9IHQuZ2V0U3RhdGUoKSwgbCA9IG8gPyBVKFwiYXJlYVwiLCBcInBhc3NcIikgOiBVKFwiYXJlYVwiKTtcbiAgICBpZiAocylcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpdC5qc3goXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZWY6IFNlKHQsIFwiYXJlYUVsZW1lbnRcIiksXG4gICAgICAgICAgICBjbGFzc05hbWU6IGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYXJlYVwiXG4gICAgICAgICksXG4gICAgICAgIGdvKClcbiAgICAgIF07XG4gICAgaWYgKCFuIHx8ICFyKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHUgPSBzcyhcbiAgICAgIFswLCAwXSxcbiAgICAgIFtpLCAwXSxcbiAgICAgIFswLCBhXSxcbiAgICAgIFtpLCBhXSxcbiAgICAgIGNbMF0sXG4gICAgICBjWzFdLFxuICAgICAgY1syXSxcbiAgICAgIGNbM11cbiAgICApLCBmID0gdS5sZW5ndGggPyBKbih1LCAhMCkgOiBcIm5vbmVcIjtcbiAgICByZXR1cm4gW1xuICAgICAgLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogU2UodCwgXCJhcmVhRWxlbWVudFwiKSxcbiAgICAgICAgICBjbGFzc05hbWU6IGwsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHRvcDogXCIwcHhcIixcbiAgICAgICAgICAgIGxlZnQ6IFwiMHB4XCIsXG4gICAgICAgICAgICB3aWR0aDogYCR7aX1weGAsXG4gICAgICAgICAgICBoZWlnaHQ6IGAke2F9cHhgLFxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjAgMFwiLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBmXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImFyZWFcIlxuICAgICAgKSxcbiAgICAgIGdvKClcbiAgICBdO1xuICB9LFxuICBkcmFnU3RhcnQodCwgeyBkYXRhczogZSwgY2xpZW50WDogbiwgY2xpZW50WTogciwgaW5wdXRFdmVudDogcyB9KSB7XG4gICAgaWYgKCFzKVxuICAgICAgcmV0dXJuICExO1xuICAgIGUuaXNEcmFnQXJlYSA9ICExO1xuICAgIGNvbnN0IG8gPSB0LmFyZWFFbGVtZW50LCBpID0gdC5zdGF0ZSwgeyBtb3ZlYWJsZUNsaWVudFJlY3Q6IGEsIHJlbmRlclBvc2VzOiBjLCByb290TWF0cml4OiBsLCBpczNkOiB1IH0gPSBpLCB7IGxlZnQ6IGYsIHRvcDogZCB9ID0gYSwge1xuICAgICAgbGVmdDogcCxcbiAgICAgIHRvcDogZyxcbiAgICAgIHdpZHRoOiBoLFxuICAgICAgaGVpZ2h0OiB2XG4gICAgfSA9IFl0KGMpLCBtID0gdSA/IDQgOiAzO1xuICAgIGxldCBbUywgeF0gPSBXZShcbiAgICAgIGwsXG4gICAgICBbbiAtIGYsIHIgLSBkXSxcbiAgICAgIG1cbiAgICApO1xuICAgIFMgLT0gcCwgeCAtPSBnO1xuICAgIGNvbnN0IEMgPSBbXG4gICAgICB7IGxlZnQ6IHAsIHRvcDogZywgd2lkdGg6IGgsIGhlaWdodDogeCAtIDEwIH0sXG4gICAgICB7IGxlZnQ6IHAsIHRvcDogZywgd2lkdGg6IFMgLSAxMCwgaGVpZ2h0OiB2IH0sXG4gICAgICB7XG4gICAgICAgIGxlZnQ6IHAsXG4gICAgICAgIHRvcDogZyArIHggKyAxMCxcbiAgICAgICAgd2lkdGg6IGgsXG4gICAgICAgIGhlaWdodDogdiAtIHggLSAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbGVmdDogcCArIFMgKyAxMCxcbiAgICAgICAgdG9wOiBnLFxuICAgICAgICB3aWR0aDogaCAtIFMgLSAxMCxcbiAgICAgICAgaGVpZ2h0OiB2XG4gICAgICB9XG4gICAgXSwgRSA9IFtdLnNsaWNlLmNhbGwoXG4gICAgICBvLm5leHRFbGVtZW50U2libGluZy5jaGlsZHJlblxuICAgICk7XG4gICAgQy5mb3JFYWNoKChELCBSKSA9PiB7XG4gICAgICBFW1JdLnN0eWxlLmNzc1RleHQgPSBgbGVmdDogJHtELmxlZnR9cHg7dG9wOiAke0QudG9wfXB4OyB3aWR0aDogJHtELndpZHRofXB4OyBoZWlnaHQ6ICR7RC5oZWlnaHR9cHg7YDtcbiAgICB9KSwgS28obywgVWkpLCBpLmRpc2FibGVOYXRpdmVFdmVudCA9ICEwO1xuICB9LFxuICBkcmFnKHQsIHsgZGF0YXM6IGUsIGlucHV0RXZlbnQ6IG4gfSkge1xuICAgIGlmICh0aGlzLmVuYWJsZU5hdGl2ZUV2ZW50KHQpLCAhbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBlLmlzRHJhZ0FyZWEgfHwgKGUuaXNEcmFnQXJlYSA9ICEwLCBocih0KSk7XG4gIH0sXG4gIGRyYWdFbmQodCwgZSkge1xuICAgIHRoaXMuZW5hYmxlTmF0aXZlRXZlbnQodCk7XG4gICAgY29uc3QgeyBpbnB1dEV2ZW50OiBuLCBkYXRhczogciB9ID0gZTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm4gITE7XG4gICAgci5pc0RyYWdBcmVhIHx8IGhyKHQpO1xuICB9LFxuICBkcmFnR3JvdXBTdGFydCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ1N0YXJ0KHQsIGUpO1xuICB9LFxuICBkcmFnR3JvdXAodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWcodCwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZCh0LCBlKTtcbiAgfSxcbiAgdW5zZXQodCkge1xuICAgIGhyKHQpLCB0LnN0YXRlLmRpc2FibGVOYXRpdmVFdmVudCA9ICExO1xuICB9LFxuICBlbmFibGVOYXRpdmVFdmVudCh0KSB7XG4gICAgY29uc3QgZSA9IHQuc3RhdGU7XG4gICAgZS5kaXNhYmxlTmF0aXZlRXZlbnQgJiYgSG8oKCkgPT4ge1xuICAgICAgZS5kaXNhYmxlTmF0aXZlRXZlbnQgPSAhMTtcbiAgICB9KTtcbiAgfVxufSwgVHUgPSBkbihcIm9yaWdpblwiLCB7XG4gIHByb3BzOiBbXCJvcmlnaW5cIiwgXCJzdmdPcmlnaW5cIl0sXG4gIHJlbmRlcih0LCBlKSB7XG4gICAgY29uc3QgeyB6b29tOiBuLCBzdmdPcmlnaW46IHIsIGdyb3VwYWJsZTogcyB9ID0gdC5wcm9wcywge1xuICAgICAgYmVmb3JlT3JpZ2luOiBvLFxuICAgICAgcm90YXRpb246IGksXG4gICAgICBzdmc6IGEsXG4gICAgICBhbGxNYXRyaXg6IGMsXG4gICAgICBpczNkOiBsLFxuICAgICAgbGVmdDogdSxcbiAgICAgIHRvcDogZixcbiAgICAgIG9mZnNldFdpZHRoOiBkLFxuICAgICAgb2Zmc2V0SGVpZ2h0OiBwXG4gICAgfSA9IHQuZ2V0U3RhdGUoKTtcbiAgICBsZXQgZztcbiAgICBpZiAoIXMgJiYgYSAmJiByKSB7XG4gICAgICBjb25zdCBbaCwgdl0gPSBFcyhyLCBkLCBwKSwgUyA9IGh0KFxuICAgICAgICBjLFxuICAgICAgICBbaCwgdl0sXG4gICAgICAgIGwgPyA0IDogM1xuICAgICAgKTtcbiAgICAgIGcgPSBObihpLCBuLCBLKFMsIFt1LCBmXSkpO1xuICAgIH0gZWxzZVxuICAgICAgZyA9IE5uKGksIG4sIG8pO1xuICAgIHJldHVybiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gaXQuanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBVKFwiY29udHJvbFwiLCBcIm9yaWdpblwiKSwgc3R5bGU6IGcgfSwgXCJiZWZvcmVPcmlnaW5cIilcbiAgICBdO1xuICB9XG59KTtcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xudmFyIGtyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBrciA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIG4sIHIgPSAxLCBzID0gYXJndW1lbnRzLmxlbmd0aDsgciA8IHM7IHIrKykge1xuICAgICAgbiA9IGFyZ3VtZW50c1tyXTtcbiAgICAgIGZvciAodmFyIG8gaW4gbikgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIG8pICYmIChlW29dID0gbltvXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBrci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIE91KCkge1xuICBmb3IgKHZhciB0ID0gMCwgZSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBlIDwgbjsgZSsrKSB0ICs9IGFyZ3VtZW50c1tlXS5sZW5ndGg7XG4gIGZvciAodmFyIHIgPSBBcnJheSh0KSwgcyA9IDAsIGUgPSAwOyBlIDwgbjsgZSsrKSBmb3IgKHZhciBvID0gYXJndW1lbnRzW2VdLCBpID0gMCwgYSA9IG8ubGVuZ3RoOyBpIDwgYTsgaSsrLCBzKyspIHJbc10gPSBvW2ldO1xuICByZXR1cm4gcjtcbn1cbnZhciBDcyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gdCgpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgfVxuICB2YXIgZSA9IHQucHJvdG90eXBlO1xuICByZXR1cm4gZS5vbiA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICBpZiAocXQobikpXG4gICAgICBmb3IgKHZhciBzIGluIG4pXG4gICAgICAgIHRoaXMub24ocywgbltzXSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5fYWRkRXZlbnQobiwgciwge30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LCBlLm9mZiA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICBpZiAoIW4pXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmIChxdChuKSlcbiAgICAgIGZvciAodmFyIHMgaW4gbilcbiAgICAgICAgdGhpcy5vZmYocyk7XG4gICAgZWxzZSBpZiAoIXIpXG4gICAgICB0aGlzLl9ldmVudHNbbl0gPSBbXTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBvID0gdGhpcy5fZXZlbnRzW25dO1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgdmFyIGkgPSBuZShvLCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIGEubGlzdGVuZXIgPT09IHI7XG4gICAgICAgIH0pO1xuICAgICAgICBpID4gLTEgJiYgby5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LCBlLm9uY2UgPSBmdW5jdGlvbihuLCByKSB7XG4gICAgdmFyIHMgPSB0aGlzO1xuICAgIHJldHVybiByICYmIHRoaXMuX2FkZEV2ZW50KG4sIHIsIHtcbiAgICAgIG9uY2U6ICEwXG4gICAgfSksIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHMuX2FkZEV2ZW50KG4sIG8sIHtcbiAgICAgICAgb25jZTogITBcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBlLmVtaXQgPSBmdW5jdGlvbihuLCByKSB7XG4gICAgdmFyIHMgPSB0aGlzO1xuICAgIHIgPT09IHZvaWQgMCAmJiAociA9IHt9KTtcbiAgICB2YXIgbyA9IHRoaXMuX2V2ZW50c1tuXTtcbiAgICBpZiAoIW4gfHwgIW8pXG4gICAgICByZXR1cm4gITA7XG4gICAgdmFyIGkgPSAhMTtcbiAgICByZXR1cm4gci5ldmVudFR5cGUgPSBuLCByLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIGkgPSAhMDtcbiAgICB9LCByLmN1cnJlbnRUYXJnZXQgPSB0aGlzLCBPdShvKS5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGEubGlzdGVuZXIociksIGEub25jZSAmJiBzLm9mZihuLCBhLmxpc3RlbmVyKTtcbiAgICB9KSwgIWk7XG4gIH0sIGUudHJpZ2dlciA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICByZXR1cm4gciA9PT0gdm9pZCAwICYmIChyID0ge30pLCB0aGlzLmVtaXQobiwgcik7XG4gIH0sIGUuX2FkZEV2ZW50ID0gZnVuY3Rpb24obiwgciwgcykge1xuICAgIHZhciBvID0gdGhpcy5fZXZlbnRzO1xuICAgIG9bbl0gPSBvW25dIHx8IFtdO1xuICAgIHZhciBpID0gb1tuXTtcbiAgICBpLnB1c2goa3Ioe1xuICAgICAgbGlzdGVuZXI6IHJcbiAgICB9LCBzKSk7XG4gIH0sIHQ7XG59KCk7XG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbnZhciAkciA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuICRyID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihuLCByKSB7XG4gICAgbi5fX3Byb3RvX18gPSByO1xuICB9IHx8IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICBmb3IgKHZhciBzIGluIHIpIHIuaGFzT3duUHJvcGVydHkocykgJiYgKG5bc10gPSByW3NdKTtcbiAgfSwgJHIodCwgZSk7XG59O1xuZnVuY3Rpb24gd3UodCwgZSkge1xuICAkcih0LCBlKTtcbiAgZnVuY3Rpb24gbigpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gdDtcbiAgfVxuICB0LnByb3RvdHlwZSA9IGUgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGUpIDogKG4ucHJvdG90eXBlID0gZS5wcm90b3R5cGUsIG5ldyBuKCkpO1xufVxudmFyIEdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBHZSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIG4sIHIgPSAxLCBzID0gYXJndW1lbnRzLmxlbmd0aDsgciA8IHM7IHIrKykge1xuICAgICAgbiA9IGFyZ3VtZW50c1tyXTtcbiAgICAgIGZvciAodmFyIG8gaW4gbikgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIG8pICYmIChlW29dID0gbltvXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBHZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIEl1KHQpIHtcbiAgdmFyIGUgPSB0LmNvbnRhaW5lcjtcbiAgcmV0dXJuIGUgPT09IGRvY3VtZW50LmJvZHkgPyBbZS5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LCBlLnNjcm9sbFRvcCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXSA6IFtlLnNjcm9sbExlZnQsIGUuc2Nyb2xsVG9wXTtcbn1cbmZ1bmN0aW9uIGhvKHQsIGUpIHtcbiAgcmV0dXJuIHQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBlKSwgZnVuY3Rpb24oKSB7XG4gICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGUpO1xuICB9O1xufVxuZnVuY3Rpb24gX24odCkge1xuICBpZiAodCkge1xuICAgIGlmIChyZSh0KSlcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpO1xuICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gIGlmIChacih0KSlcbiAgICByZXR1cm4gdCgpO1xuICBpZiAodCBpbnN0YW5jZW9mIEVsZW1lbnQpXG4gICAgcmV0dXJuIHQ7XG4gIGlmIChcImN1cnJlbnRcIiBpbiB0KVxuICAgIHJldHVybiB0LmN1cnJlbnQ7XG4gIGlmIChcInZhbHVlXCIgaW4gdClcbiAgICByZXR1cm4gdC52YWx1ZTtcbn1cbnZhciBCdSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbih0KSB7XG4gIHd1KGUsIHQpO1xuICBmdW5jdGlvbiBlKCkge1xuICAgIHZhciByID0gdCAhPT0gbnVsbCAmJiB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICByZXR1cm4gci5fc3RhcnRSZWN0ID0gbnVsbCwgci5fc3RhcnRQb3MgPSBbXSwgci5fcHJldlRpbWUgPSAwLCByLl90aW1lciA9IDAsIHIuX3ByZXZTY3JvbGxQb3MgPSBbMCwgMF0sIHIuX2lzV2FpdCA9ICExLCByLl9mbGFnID0gITEsIHIuX2N1cnJlbnRPcHRpb25zID0gbnVsbCwgci5fbG9jayA9ICExLCByLl91bnJlZ2lzdGVyID0gbnVsbCwgci5fb25TY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzID0gci5fY3VycmVudE9wdGlvbnM7XG4gICAgICByLl9sb2NrIHx8ICFzIHx8IHIuZW1pdChcInNjcm9sbERyYWdcIiwge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgci5jaGVja1Njcm9sbCh7XG4gICAgICAgICAgICBjb250YWluZXI6IHMuY29udGFpbmVyLFxuICAgICAgICAgICAgaW5wdXRFdmVudDogb1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCByO1xuICB9XG4gIHZhciBuID0gZS5wcm90b3R5cGU7XG4gIHJldHVybiBuLmRyYWdTdGFydCA9IGZ1bmN0aW9uKHIsIHMpIHtcbiAgICB2YXIgbyA9IF9uKHMuY29udGFpbmVyKTtcbiAgICBpZiAoIW8pIHtcbiAgICAgIHRoaXMuX2ZsYWcgPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGkgPSAwLCBhID0gMCwgYyA9IDAsIGwgPSAwO1xuICAgIGlmIChvID09PSBkb2N1bWVudC5ib2R5KVxuICAgICAgYyA9IHdpbmRvdy5pbm5lcldpZHRoLCBsID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGVsc2Uge1xuICAgICAgdmFyIHUgPSBvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaSA9IHUudG9wLCBhID0gdS5sZWZ0LCBjID0gdS53aWR0aCwgbCA9IHUuaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLl9mbGFnID0gITAsIHRoaXMuX3N0YXJ0UG9zID0gW3IuY2xpZW50WCwgci5jbGllbnRZXSwgdGhpcy5fc3RhcnRSZWN0ID0ge1xuICAgICAgdG9wOiBpLFxuICAgICAgbGVmdDogYSxcbiAgICAgIHdpZHRoOiBjLFxuICAgICAgaGVpZ2h0OiBsXG4gICAgfSwgdGhpcy5fcHJldlNjcm9sbFBvcyA9IHRoaXMuX2dldFNjcm9sbFBvc2l0aW9uKFswLCAwXSwgcyksIHRoaXMuX2N1cnJlbnRPcHRpb25zID0gcywgdGhpcy5fcmVnaXN0ZXJTY3JvbGxFdmVudChzKTtcbiAgfSwgbi5kcmFnID0gZnVuY3Rpb24ociwgcykge1xuICAgIGlmIChjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpLCAhIXRoaXMuX2ZsYWcpIHtcbiAgICAgIHZhciBvID0gci5jbGllbnRYLCBpID0gci5jbGllbnRZLCBhID0gcy50aHJlc2hvbGQsIGMgPSBhID09PSB2b2lkIDAgPyAwIDogYSwgbCA9IHRoaXMsIHUgPSBsLl9zdGFydFJlY3QsIGYgPSBsLl9zdGFydFBvcztcbiAgICAgIHRoaXMuX2N1cnJlbnRPcHRpb25zID0gcztcbiAgICAgIHZhciBkID0gWzAsIDBdO1xuICAgICAgcmV0dXJuIHUudG9wID4gaSAtIGMgPyAoZlsxXSA+IHUudG9wIHx8IGkgPCBmWzFdKSAmJiAoZFsxXSA9IC0xKSA6IHUudG9wICsgdS5oZWlnaHQgPCBpICsgYyAmJiAoZlsxXSA8IHUudG9wICsgdS5oZWlnaHQgfHwgaSA+IGZbMV0pICYmIChkWzFdID0gMSksIHUubGVmdCA+IG8gLSBjID8gKGZbMF0gPiB1LmxlZnQgfHwgbyA8IGZbMF0pICYmIChkWzBdID0gLTEpIDogdS5sZWZ0ICsgdS53aWR0aCA8IG8gKyBjICYmIChmWzBdIDwgdS5sZWZ0ICsgdS53aWR0aCB8fCBvID4gZlswXSkgJiYgKGRbMF0gPSAxKSwgIWRbMF0gJiYgIWRbMV0gPyAhMSA6IHRoaXMuX2NvbnRpbnVlRHJhZyhHZShHZSh7fSwgcyksIHtcbiAgICAgICAgZGlyZWN0aW9uOiBkLFxuICAgICAgICBpbnB1dEV2ZW50OiByLFxuICAgICAgICBpc0RyYWc6ICEwXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBuLmNoZWNrU2Nyb2xsID0gZnVuY3Rpb24ocikge1xuICAgIHZhciBzID0gdGhpcztcbiAgICBpZiAodGhpcy5faXNXYWl0KVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBvID0gci5wcmV2U2Nyb2xsUG9zLCBpID0gbyA9PT0gdm9pZCAwID8gdGhpcy5fcHJldlNjcm9sbFBvcyA6IG8sIGEgPSByLmRpcmVjdGlvbiwgYyA9IHIudGhyb3R0bGVUaW1lLCBsID0gYyA9PT0gdm9pZCAwID8gMCA6IGMsIHUgPSByLmlucHV0RXZlbnQsIGYgPSByLmlzRHJhZywgZCA9IHRoaXMuX2dldFNjcm9sbFBvc2l0aW9uKGEgfHwgWzAsIDBdLCByKSwgcCA9IGRbMF0gLSBpWzBdLCBnID0gZFsxXSAtIGlbMV0sIGggPSBhIHx8IFtwID8gTWF0aC5hYnMocCkgLyBwIDogMCwgZyA/IE1hdGguYWJzKGcpIC8gZyA6IDBdO1xuICAgIHJldHVybiB0aGlzLl9wcmV2U2Nyb2xsUG9zID0gZCwgdGhpcy5fbG9jayA9ICExLCAhcCAmJiAhZyA/ICExIDogKHRoaXMuZW1pdChcIm1vdmVcIiwge1xuICAgICAgb2Zmc2V0WDogaFswXSA/IHAgOiAwLFxuICAgICAgb2Zmc2V0WTogaFsxXSA/IGcgOiAwLFxuICAgICAgaW5wdXRFdmVudDogdVxuICAgIH0pLCBsICYmIGYgJiYgKGNsZWFyVGltZW91dCh0aGlzLl90aW1lciksIHRoaXMuX3RpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzLl9jb250aW51ZURyYWcocik7XG4gICAgfSwgbCkpLCAhMCk7XG4gIH0sIG4uZHJhZ0VuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZsYWcgPSAhMSwgdGhpcy5fbG9jayA9ICExLCBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpLCB0aGlzLl91bnJlZ2lzdGVyU2Nyb2xsRXZlbnQoKTtcbiAgfSwgbi5fZ2V0U2Nyb2xsUG9zaXRpb24gPSBmdW5jdGlvbihyLCBzKSB7XG4gICAgdmFyIG8gPSBzLmNvbnRhaW5lciwgaSA9IHMuZ2V0U2Nyb2xsUG9zaXRpb24sIGEgPSBpID09PSB2b2lkIDAgPyBJdSA6IGk7XG4gICAgcmV0dXJuIGEoe1xuICAgICAgY29udGFpbmVyOiBfbihvKSxcbiAgICAgIGRpcmVjdGlvbjogclxuICAgIH0pO1xuICB9LCBuLl9jb250aW51ZURyYWcgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIHMgPSB0aGlzLCBvLCBpID0gci5jb250YWluZXIsIGEgPSByLmRpcmVjdGlvbiwgYyA9IHIudGhyb3R0bGVUaW1lLCBsID0gci51c2VTY3JvbGwsIHUgPSByLmlzRHJhZywgZiA9IHIuaW5wdXRFdmVudDtcbiAgICBpZiAoISghdGhpcy5fZmxhZyB8fCB1ICYmIHRoaXMuX2lzV2FpdCkpIHtcbiAgICAgIHZhciBkID0gY24oKSwgcCA9IE1hdGgubWF4KGMgKyB0aGlzLl9wcmV2VGltZSAtIGQsIDApO1xuICAgICAgaWYgKHAgPiAwKVxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKSwgdGhpcy5fdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBzLl9jb250aW51ZURyYWcocik7XG4gICAgICAgIH0sIHApLCAhMTtcbiAgICAgIHRoaXMuX3ByZXZUaW1lID0gZDtcbiAgICAgIHZhciBnID0gdGhpcy5fZ2V0U2Nyb2xsUG9zaXRpb24oYSwgcik7XG4gICAgICB0aGlzLl9wcmV2U2Nyb2xsUG9zID0gZywgdSAmJiAodGhpcy5faXNXYWl0ID0gITApLCBsIHx8ICh0aGlzLl9sb2NrID0gITApO1xuICAgICAgdmFyIGggPSB7XG4gICAgICAgIGNvbnRhaW5lcjogX24oaSksXG4gICAgICAgIGRpcmVjdGlvbjogYSxcbiAgICAgICAgaW5wdXRFdmVudDogZlxuICAgICAgfTtcbiAgICAgIHJldHVybiAobyA9IHIucmVxdWVzdFNjcm9sbCkgPT09IG51bGwgfHwgbyA9PT0gdm9pZCAwIHx8IG8uY2FsbChyLCBoKSwgdGhpcy5lbWl0KFwic2Nyb2xsXCIsIGgpLCB0aGlzLl9pc1dhaXQgPSAhMSwgbCB8fCB0aGlzLmNoZWNrU2Nyb2xsKEdlKEdlKHt9LCByKSwge1xuICAgICAgICBwcmV2U2Nyb2xsUG9zOiBnLFxuICAgICAgICBkaXJlY3Rpb246IGEsXG4gICAgICAgIGlucHV0RXZlbnQ6IGZcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIG4uX3JlZ2lzdGVyU2Nyb2xsRXZlbnQgPSBmdW5jdGlvbihyKSB7XG4gICAgdGhpcy5fdW5yZWdpc3RlclNjcm9sbEV2ZW50KCk7XG4gICAgdmFyIHMgPSByLmNoZWNrU2Nyb2xsRXZlbnQ7XG4gICAgaWYgKHMpIHtcbiAgICAgIHZhciBvID0gcyA9PT0gITAgPyBobyA6IHMsIGkgPSBfbihyLmNvbnRhaW5lcik7XG4gICAgICBzID09PSAhMCAmJiAoaSA9PT0gZG9jdW1lbnQuYm9keSB8fCBpID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpID8gdGhpcy5fdW5yZWdpc3RlciA9IGhvKHdpbmRvdywgdGhpcy5fb25TY3JvbGwpIDogdGhpcy5fdW5yZWdpc3RlciA9IG8oaSwgdGhpcy5fb25TY3JvbGwpO1xuICAgIH1cbiAgfSwgbi5fdW5yZWdpc3RlclNjcm9sbEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHI7XG4gICAgKHIgPSB0aGlzLl91bnJlZ2lzdGVyKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgfHwgci5jYWxsKHRoaXMpLCB0aGlzLl91bnJlZ2lzdGVyID0gbnVsbDtcbiAgfSwgZTtcbn0oQ3MpO1xuZnVuY3Rpb24genUodCkge1xuICBjb25zdCBlID0gdC5zY3JvbGxDb250YWluZXI7XG4gIHJldHVybiBbXG4gICAgZS5zY3JvbGxMZWZ0LFxuICAgIGUuc2Nyb2xsVG9wXG4gIF07XG59XG5jb25zdCBBdSA9IHtcbiAgbmFtZTogXCJzY3JvbGxhYmxlXCIsXG4gIGNhblBpbmNoOiAhMCxcbiAgcHJvcHM6IFtcbiAgICBcInNjcm9sbGFibGVcIixcbiAgICBcInNjcm9sbENvbnRhaW5lclwiLFxuICAgIFwic2Nyb2xsVGhyZXNob2xkXCIsXG4gICAgXCJzY3JvbGxUaHJvdHRsZVRpbWVcIixcbiAgICBcImdldFNjcm9sbFBvc2l0aW9uXCIsXG4gICAgXCJzY3JvbGxPcHRpb25zXCJcbiAgXSxcbiAgZXZlbnRzOiBbXG4gICAgXCJzY3JvbGxcIixcbiAgICBcInNjcm9sbEdyb3VwXCJcbiAgXSxcbiAgZHJhZ1JlbGF0aW9uOiBcInN0cm9uZ1wiLFxuICBkcmFnU3RhcnQodCwgZSkge1xuICAgIGNvbnN0IG4gPSB0LnByb3BzLCB7XG4gICAgICBzY3JvbGxDb250YWluZXI6IHIgPSB0LmdldENvbnRhaW5lcigpLFxuICAgICAgc2Nyb2xsT3B0aW9uczogc1xuICAgIH0gPSBuLCBvID0gbmV3IEJ1KCksIGkgPSBadChyLCAhMCk7XG4gICAgZS5kYXRhcy5kcmFnU2Nyb2xsID0gbywgdC5zdGF0ZS5kcmFnU2Nyb2xsID0gbztcbiAgICBjb25zdCBhID0gZS5pc0NvbnRyb2wgPyBcImNvbnRyb2xHZXN0b1wiIDogXCJ0YXJnZXRHZXN0b1wiLCBjID0gZS50YXJnZXRzO1xuICAgIG8ub24oXCJzY3JvbGxcIiwgKHsgY29udGFpbmVyOiBsLCBkaXJlY3Rpb246IHUgfSkgPT4ge1xuICAgICAgY29uc3QgZiA9IGV0KHQsIGUsIHtcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyOiBsLFxuICAgICAgICBkaXJlY3Rpb246IHVcbiAgICAgIH0pLCBkID0gYyA/IFwib25TY3JvbGxHcm91cFwiIDogXCJvblNjcm9sbFwiO1xuICAgICAgYyAmJiAoZi50YXJnZXRzID0gYyksIGoodCwgZCwgZik7XG4gICAgfSkub24oXCJtb3ZlXCIsICh7IG9mZnNldFg6IGwsIG9mZnNldFk6IHUsIGlucHV0RXZlbnQ6IGYgfSkgPT4ge1xuICAgICAgdFthXS5zY3JvbGxCeShsLCB1LCBmLmlucHV0RXZlbnQsICExKTtcbiAgICB9KS5vbihcInNjcm9sbERyYWdcIiwgKHsgbmV4dDogbCB9KSA9PiB7XG4gICAgICBsKHRbYV0uZ2V0Q3VycmVudEV2ZW50KCkpO1xuICAgIH0pLCBvLmRyYWdTdGFydChlLCB7XG4gICAgICBjb250YWluZXI6IGksXG4gICAgICAuLi5zXG4gICAgfSk7XG4gIH0sXG4gIGNoZWNrU2Nyb2xsKHQsIGUpIHtcbiAgICBjb25zdCBuID0gZS5kYXRhcy5kcmFnU2Nyb2xsO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxDb250YWluZXI6IHIgPSB0LmdldENvbnRhaW5lcigpLFxuICAgICAgc2Nyb2xsVGhyZXNob2xkOiBzID0gMCxcbiAgICAgIHNjcm9sbFRocm90dGxlVGltZTogbyA9IDAsXG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbjogaSA9IHp1LFxuICAgICAgc2Nyb2xsT3B0aW9uczogYVxuICAgIH0gPSB0LnByb3BzO1xuICAgIHJldHVybiBuLmRyYWcoZSwge1xuICAgICAgY29udGFpbmVyOiByLFxuICAgICAgdGhyZXNob2xkOiBzLFxuICAgICAgdGhyb3R0bGVUaW1lOiBvLFxuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb246IChjKSA9PiBpKHsgc2Nyb2xsQ29udGFpbmVyOiBjLmNvbnRhaW5lciwgZGlyZWN0aW9uOiBjLmRpcmVjdGlvbiB9KSxcbiAgICAgIC4uLmFcbiAgICB9KSwgITA7XG4gIH0sXG4gIGRyYWcodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmNoZWNrU2Nyb2xsKHQsIGUpO1xuICB9LFxuICBkcmFnRW5kKHQsIGUpIHtcbiAgICBlLmRhdGFzLmRyYWdTY3JvbGwuZHJhZ0VuZCgpLCBlLmRhdGFzLmRyYWdTY3JvbGwgPSBudWxsO1xuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0KHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQodCwgeyAuLi5lLCBpc0NvbnRyb2w6ICEwIH0pO1xuICB9LFxuICBkcmFnQ29udHJvbCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZyh0LCBlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdFbmQodCwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0KHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQodCwgeyAuLi5lLCB0YXJnZXRzOiB0LnByb3BzLnRhcmdldHMgfSk7XG4gIH0sXG4gIGRyYWdHcm91cCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZyh0LCB7IC4uLmUsIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyB9KTtcbiAgfSxcbiAgZHJhZ0dyb3VwRW5kKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kKHQsIHsgLi4uZSwgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzIH0pO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydCh0LCB7IC4uLmUsIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cywgaXNDb250cm9sOiAhMCB9KTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZyh0LCB7IC4uLmUsIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyB9KTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvRW5kKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kKHQsIHsgLi4uZSwgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzIH0pO1xuICB9LFxuICB1bnNldCh0KSB7XG4gICAgdmFyIG47XG4gICAgY29uc3QgZSA9IHQuc3RhdGU7XG4gICAgKG4gPSBlLmRyYWdTY3JvbGwpID09IG51bGwgfHwgbi5kcmFnRW5kKCksIGUuZHJhZ1Njcm9sbCA9IG51bGw7XG4gIH1cbn0sIFppID0ge1xuICBuYW1lOiBcIlwiLFxuICBwcm9wczogW1xuICAgIFwidGFyZ2V0XCIsXG4gICAgXCJkcmFnVGFyZ2V0U2VsZlwiLFxuICAgIFwiZHJhZ1RhcmdldFwiLFxuICAgIFwiZHJhZ0NvbnRhaW5lclwiLFxuICAgIFwiY29udGFpbmVyXCIsXG4gICAgXCJ3YXJwU2VsZlwiLFxuICAgIFwicm9vdENvbnRhaW5lclwiLFxuICAgIFwidXNlUmVzaXplT2JzZXJ2ZXJcIixcbiAgICBcInVzZU11dGF0aW9uT2JzZXJ2ZXJcIixcbiAgICBcInpvb21cIixcbiAgICBcImRyYWdGb2N1c2VkSW5wdXRcIixcbiAgICBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgIFwiYWJsZXNcIixcbiAgICBcImNsYXNzTmFtZVwiLFxuICAgIFwicGluY2hUaHJlc2hvbGRcIixcbiAgICBcInBpbmNoT3V0c2lkZVwiLFxuICAgIFwidHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHlcIixcbiAgICBcImNoZWNrSW5wdXRcIixcbiAgICBcImNzcE5vbmNlXCIsXG4gICAgXCJ0cmFuc2xhdGVaXCIsXG4gICAgXCJoaWRlRGVmYXVsdExpbmVzXCIsXG4gICAgXCJwcm9wc1wiLFxuICAgIFwiZmx1c2hTeW5jXCIsXG4gICAgXCJzdG9wUHJvcGFnYXRpb25cIixcbiAgICBcInByZXZlbnRDbGlja0V2ZW50T25EcmFnXCIsXG4gICAgXCJwcmV2ZW50Q2xpY2tEZWZhdWx0XCIsXG4gICAgXCJ2aWV3Q29udGFpbmVyXCIsXG4gICAgXCJwZXJzaXN0RGF0YVwiLFxuICAgIFwidXNlQWNjdXJhdGVQb3NpdGlvblwiLFxuICAgIFwiZmlyc3RSZW5kZXJTdGF0ZVwiLFxuICAgIFwibGluZVBhZGRpbmdcIixcbiAgICBcImNvbnRyb2xQYWRkaW5nXCIsXG4gICAgXCJwcmV2ZW50RGVmYXVsdFwiLFxuICAgIFwicHJldmVudFJpZ2h0Q2xpY2tcIixcbiAgICBcInByZXZlbnRXaGVlbENsaWNrXCIsXG4gICAgXCJyZXF1ZXN0U3R5bGVzXCJcbiAgXSxcbiAgZXZlbnRzOiBbXG4gICAgXCJjaGFuZ2VUYXJnZXRzXCJcbiAgXVxufSwgR3UgPSBkbihcInBhZGRpbmdcIiwge1xuICBwcm9wczogW1wicGFkZGluZ1wiXSxcbiAgcmVuZGVyKHQsIGUpIHtcbiAgICBjb25zdCBuID0gdC5wcm9wcztcbiAgICBpZiAobi5kcmFnQXJlYSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiByLFxuICAgICAgdG9wOiBzLFxuICAgICAgcmlnaHQ6IG8sXG4gICAgICBib3R0b206IGlcbiAgICB9ID0gcWkobi5wYWRkaW5nIHx8IHt9KSwge1xuICAgICAgcmVuZGVyUG9zZXM6IGEsXG4gICAgICBwb3MxOiBjLFxuICAgICAgcG9zMjogbCxcbiAgICAgIHBvczM6IHUsXG4gICAgICBwb3M0OiBmXG4gICAgfSA9IHQuZ2V0U3RhdGUoKSwgZCA9IFtjLCBsLCB1LCBmXSwgcCA9IFtdO1xuICAgIHJldHVybiByID4gMCAmJiBwLnB1c2goWzAsIDJdKSwgcyA+IDAgJiYgcC5wdXNoKFswLCAxXSksIG8gPiAwICYmIHAucHVzaChbMSwgM10pLCBpID4gMCAmJiBwLnB1c2goWzIsIDNdKSwgcC5tYXAoKFtnLCBoXSwgdikgPT4ge1xuICAgICAgY29uc3QgbSA9IGRbZ10sIFMgPSBkW2hdLCB4ID0gYVtnXSwgQyA9IGFbaF0sIEUgPSBzcyhcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMTAwLCAwXSxcbiAgICAgICAgWzAsIDEwMF0sXG4gICAgICAgIFsxMDAsIDEwMF0sXG4gICAgICAgIG0sXG4gICAgICAgIFMsXG4gICAgICAgIHgsXG4gICAgICAgIENcbiAgICAgICk7XG4gICAgICBpZiAoRS5sZW5ndGgpXG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaXQuanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBVKFwicGFkZGluZ1wiKSwgc3R5bGU6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IEpuKEUsICEwKVxuICAgICAgICB9IH0sIGBwYWRkaW5nJHt2fWApO1xuICAgIH0pO1xuICB9XG59KSwgdm8gPSBbXCJud1wiLCBcIm5lXCIsIFwic2VcIiwgXCJzd1wiXTtcbmZ1bmN0aW9uIFRuKHQsIGUpIHtcbiAgY29uc3QgbiA9IHRbMF0gKyB0WzFdLCByID0gbiA+IGUgPyBlIC8gbiA6IDE7XG4gIHJldHVybiB0WzBdICo9IHIsIHRbMV0gPSBlIC0gdFsxXSAqIHIsIHQ7XG59XG5jb25zdCBrdSA9IFsxLCAyLCA1LCA2XSwgJHUgPSBbMCwgMywgNCwgN10sIHZlID0gWzEsIC0xLCAtMSwgMV0sIG1lID0gWzEsIDEsIC0xLCAtMV07XG5mdW5jdGlvbiBEcyh0LCBlLCBuLCByLCBzID0gMCwgbyA9IDAsIGkgPSBuLCBhID0gcikge1xuICBjb25zdCBjID0gW107XG4gIGxldCBsID0gITE7XG4gIGNvbnN0IHUgPSB0LmZpbHRlcigoZCkgPT4gIWQudmlydHVhbCksIGYgPSB1Lm1hcCgoZCkgPT4ge1xuICAgIGNvbnN0IHsgaG9yaXpvbnRhbDogcCwgdmVydGljYWw6IGcsIHBvczogaCB9ID0gZDtcbiAgICBpZiAoZyAmJiAhbCAmJiAobCA9ICEwLCBjLnB1c2goXCIvXCIpKSwgbCkge1xuICAgICAgY29uc3QgdiA9IE1hdGgubWF4KDAsIGcgPT09IDEgPyBoWzFdIC0gbyA6IGEgLSBoWzFdKTtcbiAgICAgIHJldHVybiBjLnB1c2goWHQodiwgciwgZSkpLCB2O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2ID0gTWF0aC5tYXgoMCwgcCA9PT0gMSA/IGhbMF0gLSBzIDogaSAtIGhbMF0pO1xuICAgICAgcmV0dXJuIGMucHVzaChYdCh2LCBuLCBlKSksIHY7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByYWRpdXNQb3NlczogdSxcbiAgICBzdHlsZXM6IGMsXG4gICAgcmF3czogZlxuICB9O1xufVxuZnVuY3Rpb24gSmkodCkge1xuICBjb25zdCBlID0gWzAsIDBdLCBuID0gWzAsIDBdLCByID0gdC5sZW5ndGg7XG4gIGZvciAobGV0IHMgPSAwOyBzIDwgcjsgKytzKSB7XG4gICAgY29uc3QgbyA9IHRbc107XG4gICAgby5zdWIgJiYgKG8uaG9yaXpvbnRhbCAmJiAoZVsxXSA9PT0gMCAmJiAoZVswXSA9IHMpLCBlWzFdID0gcyAtIGVbMF0gKyAxLCBuWzBdID0gcyArIDEpLCBvLnZlcnRpY2FsICYmIChuWzFdID09PSAwICYmIChuWzBdID0gcyksIG5bMV0gPSBzIC0gblswXSArIDEpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhvcml6b250YWxSYW5nZTogZSxcbiAgICB2ZXJ0aWNhbFJhbmdlOiBuXG4gIH07XG59XG5mdW5jdGlvbiBGdSh0LCBlLCBuLCByLCBzLCBvID0gWzAsIDBdLCBpID0gITEpIHtcbiAgY29uc3QgYSA9IHQuaW5kZXhPZihcIi9cIiksIGMgPSAoYSA+IC0xID8gdC5zbGljZSgwLCBhKSA6IHQpLmxlbmd0aCwgbCA9IHQuc2xpY2UoMCwgYyksIHUgPSB0LnNsaWNlKGMgKyAxKSwgZiA9IGwubGVuZ3RoLCBkID0gdS5sZW5ndGgsIHAgPSBkID4gMCwgW1xuICAgIGcgPSBcIjBweFwiLFxuICAgIGggPSBnLFxuICAgIHYgPSBnLFxuICAgIG0gPSBoXG4gIF0gPSBsLCBbXG4gICAgUyA9IGcsXG4gICAgeCA9IHAgPyBTIDogaCxcbiAgICBDID0gcCA/IFMgOiB2LFxuICAgIEUgPSBwID8geCA6IG1cbiAgXSA9IHUsIEQgPSBbZywgaCwgdiwgbV0ubWFwKChPKSA9PiBmdChPLCBlKSksIFIgPSBbUywgeCwgQywgRV0ubWFwKChPKSA9PiBmdChPLCBuKSksIHkgPSBELnNsaWNlKCksIE0gPSBSLnNsaWNlKCk7XG4gIFt5WzBdLCB5WzFdXSA9IFRuKFxuICAgIFt5WzBdLCB5WzFdXSxcbiAgICBlXG4gICksIFt5WzNdLCB5WzJdXSA9IFRuKFxuICAgIFt5WzNdLCB5WzJdXSxcbiAgICBlXG4gICksIFtNWzBdLCBNWzNdXSA9IFRuKFxuICAgIFtNWzBdLCBNWzNdXSxcbiAgICBuXG4gICksIFtNWzFdLCBNWzJdXSA9IFRuKFxuICAgIFtNWzFdLCBNWzJdXSxcbiAgICBuXG4gICk7XG4gIGNvbnN0IFAgPSBpID8geSA6IHkuc2xpY2UoMCwgTWF0aC5tYXgob1swXSwgZikpLCBfID0gaSA/IE0gOiBNLnNsaWNlKDAsIE1hdGgubWF4KG9bMV0sIGQpKTtcbiAgcmV0dXJuIFtcbiAgICAuLi5QLm1hcCgoTywgVCkgPT4ge1xuICAgICAgY29uc3QgdyA9IHZvW1RdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmlydHVhbDogVCA+PSBmLFxuICAgICAgICBob3Jpem9udGFsOiB2ZVtUXSxcbiAgICAgICAgdmVydGljYWw6IDAsXG4gICAgICAgIHBvczogW3IgKyBPLCBzICsgKG1lW1RdID09PSAtMSA/IG4gOiAwKV0sXG4gICAgICAgIHN1YjogITAsXG4gICAgICAgIHJhdzogRFtUXSxcbiAgICAgICAgZGlyZWN0aW9uOiB3XG4gICAgICB9O1xuICAgIH0pLFxuICAgIC4uLl8ubWFwKChPLCBUKSA9PiB7XG4gICAgICBjb25zdCB3ID0gdm9bVF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2aXJ0dWFsOiBUID49IGQsXG4gICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgIHZlcnRpY2FsOiBtZVtUXSxcbiAgICAgICAgcG9zOiBbciArICh2ZVtUXSA9PT0gLTEgPyBlIDogMCksIHMgKyBPXSxcbiAgICAgICAgc3ViOiAhMCxcbiAgICAgICAgcmF3OiBSW1RdLFxuICAgICAgICBkaXJlY3Rpb246IHdcbiAgICAgIH07XG4gICAgfSlcbiAgXTtcbn1cbmZ1bmN0aW9uIEx1KHQsIGUsIG4sIHIsIHMgPSBlLmxlbmd0aCkge1xuICBjb25zdCB7XG4gICAgaG9yaXpvbnRhbFJhbmdlOiBvLFxuICAgIHZlcnRpY2FsUmFuZ2U6IGlcbiAgfSA9IEppKHQuc2xpY2UocikpLCBhID0gbiAtIHI7XG4gIGxldCBjID0gMDtcbiAgaWYgKGEgPT09IDApXG4gICAgYyA9IHM7XG4gIGVsc2UgaWYgKGEgPiAwICYmIGEgPCBvWzFdKVxuICAgIGMgPSBvWzFdIC0gYTtcbiAgZWxzZSBpZiAoYSA+PSBpWzBdKVxuICAgIGMgPSBpWzBdICsgaVsxXSAtIGE7XG4gIGVsc2VcbiAgICByZXR1cm47XG4gIHQuc3BsaWNlKG4sIGMpLCBlLnNwbGljZShuLCBjKTtcbn1cbmZ1bmN0aW9uIE51KHQsIGUsIG4sIHIsIHMsIG8sIGksIGEsIGMsIGwgPSAwLCB1ID0gMCkge1xuICBjb25zdCB7XG4gICAgaG9yaXpvbnRhbFJhbmdlOiBmLFxuICAgIHZlcnRpY2FsUmFuZ2U6IGRcbiAgfSA9IEppKHQuc2xpY2UobikpO1xuICBpZiAociA+IC0xKSB7XG4gICAgY29uc3QgcCA9IHZlW3JdID09PSAxID8gbyAtIGwgOiBhIC0gbztcbiAgICBmb3IgKGxldCBnID0gZlsxXTsgZyA8PSByOyArK2cpIHtcbiAgICAgIGNvbnN0IGggPSBtZVtnXSA9PT0gMSA/IHUgOiBjO1xuICAgICAgbGV0IHYgPSAwO1xuICAgICAgaWYgKHIgPT09IGcgPyB2ID0gbyA6IGcgPT09IDAgPyB2ID0gbCArIHAgOiB2ZVtnXSA9PT0gLTEgJiYgKHYgPSBhIC0gKGVbbl1bMF0gLSBsKSksIHQuc3BsaWNlKG4gKyBnLCAwLCB7XG4gICAgICAgIGhvcml6b250YWw6IHZlW2ddLFxuICAgICAgICB2ZXJ0aWNhbDogMCxcbiAgICAgICAgcG9zOiBbdiwgaF1cbiAgICAgIH0pLCBlLnNwbGljZShuICsgZywgMCwgW3YsIGhdKSwgZyA9PT0gMClcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2UgaWYgKHMgPiAtMSkge1xuICAgIGNvbnN0IHAgPSBtZVtzXSA9PT0gMSA/IGkgLSB1IDogYyAtIGk7XG4gICAgaWYgKGZbMV0gPT09IDAgJiYgZFsxXSA9PT0gMCkge1xuICAgICAgY29uc3QgaCA9IFtcbiAgICAgICAgbCArIHAsXG4gICAgICAgIHVcbiAgICAgIF07XG4gICAgICB0LnB1c2goe1xuICAgICAgICBob3Jpem9udGFsOiB2ZVswXSxcbiAgICAgICAgdmVydGljYWw6IDAsXG4gICAgICAgIHBvczogaFxuICAgICAgfSksIGUucHVzaChoKTtcbiAgICB9XG4gICAgY29uc3QgZyA9IGRbMF07XG4gICAgZm9yIChsZXQgaCA9IGRbMV07IGggPD0gczsgKytoKSB7XG4gICAgICBjb25zdCB2ID0gdmVbaF0gPT09IDEgPyBsIDogYTtcbiAgICAgIGxldCBtID0gMDtcbiAgICAgIGlmIChzID09PSBoID8gbSA9IGkgOiBoID09PSAwID8gbSA9IHUgKyBwIDogbWVbaF0gPT09IDEgPyBtID0gZVtuICsgZ11bMV0gOiBtZVtoXSA9PT0gLTEgJiYgKG0gPSBjIC0gKGVbbiArIGddWzFdIC0gdSkpLCB0LnB1c2goe1xuICAgICAgICBob3Jpem9udGFsOiAwLFxuICAgICAgICB2ZXJ0aWNhbDogbWVbaF0sXG4gICAgICAgIHBvczogW3YsIG1dXG4gICAgICB9KSwgZS5wdXNoKFt2LCBtXSksIGggPT09IDApXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gV3UodCwgZSA9IHQubWFwKChuKSA9PiBuLnJhdykpIHtcbiAgY29uc3QgbiA9IHQubWFwKChzLCBvKSA9PiBzLmhvcml6b250YWwgPyBlW29dIDogbnVsbCkuZmlsdGVyKChzKSA9PiBzICE9IG51bGwpLCByID0gdC5tYXAoKHMsIG8pID0+IHMudmVydGljYWwgPyBlW29dIDogbnVsbCkuZmlsdGVyKChzKSA9PiBzICE9IG51bGwpO1xuICByZXR1cm4ge1xuICAgIGhvcml6b250YWxzOiBuLFxuICAgIHZlcnRpY2FsczogclxuICB9O1xufVxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5mdW5jdGlvbiBZdSgpIHtcbiAgZm9yICh2YXIgdCA9IDAsIGUgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgZSA8IG47IGUrKykgdCArPSBhcmd1bWVudHNbZV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkodCksIHMgPSAwLCBlID0gMDsgZSA8IG47IGUrKykgZm9yICh2YXIgbyA9IGFyZ3VtZW50c1tlXSwgaSA9IDAsIGEgPSBvLmxlbmd0aDsgaSA8IGE7IGkrKywgcysrKSByW3NdID0gb1tpXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBBdCh0KSB7XG4gIHJldHVybiB0dCh0LCBEdCk7XG59XG5mdW5jdGlvbiBWdSh0LCBlKSB7XG4gIHJldHVybiB0LmV2ZXJ5KGZ1bmN0aW9uKG4sIHIpIHtcbiAgICByZXR1cm4gQXQobiAtIGVbcl0pID09PSAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGp1KHQsIGUpIHtcbiAgcmV0dXJuICFBdCh0WzBdIC0gZVswXSkgJiYgIUF0KHRbMV0gLSBlWzFdKTtcbn1cbmZ1bmN0aW9uIFFpKHQpIHtcbiAgcmV0dXJuIHQubGVuZ3RoIDwgMyA/IDAgOiBNYXRoLmFicyhDYyh0Lm1hcChmdW5jdGlvbihlLCBuKSB7XG4gICAgdmFyIHIgPSB0W24gKyAxXSB8fCB0WzBdO1xuICAgIHJldHVybiBlWzBdICogclsxXSAtIHJbMF0gKiBlWzFdO1xuICB9KSkpIC8gMjtcbn1cbmZ1bmN0aW9uIG1vKHQsIGUpIHtcbiAgdmFyIG4gPSBlLndpZHRoLCByID0gZS5oZWlnaHQsIHMgPSBlLmxlZnQsIG8gPSBlLnRvcCwgaSA9IGJlKHQpLCBhID0gaS5taW5YLCBjID0gaS5taW5ZLCBsID0gaS5tYXhYLCB1ID0gaS5tYXhZLCBmID0gbiAvIChsIC0gYSksIGQgPSByIC8gKHUgLSBjKTtcbiAgcmV0dXJuIHQubWFwKGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gW3MgKyAocFswXSAtIGEpICogZiwgbyArIChwWzFdIC0gYykgKiBkXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBiZSh0KSB7XG4gIHZhciBlID0gdC5tYXAoZnVuY3Rpb24ocikge1xuICAgIHJldHVybiByWzBdO1xuICB9KSwgbiA9IHQubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gclsxXTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbWluWDogTWF0aC5taW4uYXBwbHkoTWF0aCwgZSksXG4gICAgbWluWTogTWF0aC5taW4uYXBwbHkoTWF0aCwgbiksXG4gICAgbWF4WDogTWF0aC5tYXguYXBwbHkoTWF0aCwgZSksXG4gICAgbWF4WTogTWF0aC5tYXguYXBwbHkoTWF0aCwgbilcbiAgfTtcbn1cbmZ1bmN0aW9uIEZyKHQsIGUsIG4pIHtcbiAgdmFyIHIgPSB0WzBdLCBzID0gdFsxXSwgbyA9IGJlKGUpLCBpID0gby5taW5YLCBhID0gby5tYXhYLCBjID0gW1tpLCBzXSwgW2EsIHNdXSwgbCA9IFluKGNbMF0sIGNbMV0pLCB1ID0gTHIoZSksIGYgPSBbXTtcbiAgaWYgKHUuZm9yRWFjaChmdW5jdGlvbihnKSB7XG4gICAgdmFyIGggPSBZbihnWzBdLCBnWzFdKSwgdiA9IGdbMF07XG4gICAgaWYgKFZ1KGwsIGgpKVxuICAgICAgZi5wdXNoKHtcbiAgICAgICAgcG9zOiB0LFxuICAgICAgICBsaW5lOiBnLFxuICAgICAgICB0eXBlOiBcImxpbmVcIlxuICAgICAgfSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbSA9IHRhKGJzKGwsIGgpLCBbYywgZ10pO1xuICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgZy5zb21lKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4ganUoeCwgUyk7XG4gICAgICAgIH0pID8gZi5wdXNoKHtcbiAgICAgICAgICBwb3M6IFMsXG4gICAgICAgICAgbGluZTogZyxcbiAgICAgICAgICB0eXBlOiBcInBvaW50XCJcbiAgICAgICAgfSkgOiBBdCh2WzFdIC0gcykgIT09IDAgJiYgZi5wdXNoKHtcbiAgICAgICAgICBwb3M6IFMsXG4gICAgICAgICAgbGluZTogZyxcbiAgICAgICAgICB0eXBlOiBcImludGVyc2VjdGlvblwiXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KSwga3QoZiwgZnVuY3Rpb24oZykge1xuICAgIHJldHVybiBnWzBdID09PSByO1xuICB9KSlcbiAgICByZXR1cm4gITA7XG4gIHZhciBkID0gMCwgcCA9IHt9O1xuICByZXR1cm4gZi5mb3JFYWNoKGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgaCA9IGcucG9zLCB2ID0gZy50eXBlLCBtID0gZy5saW5lO1xuICAgIGlmICghKGhbMF0gPiByKSlcbiAgICAgIGlmICh2ID09PSBcImludGVyc2VjdGlvblwiKVxuICAgICAgICArK2Q7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHYgPT09IFwibGluZVwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHYgPT09IFwicG9pbnRcIikge1xuICAgICAgICAgIHZhciBTID0ga3QobSwgZnVuY3Rpb24oRSkge1xuICAgICAgICAgICAgcmV0dXJuIEVbMV0gIT09IHM7XG4gICAgICAgICAgfSksIHggPSBwW2hbMF1dLCBDID0gU1sxXSA+IHMgPyAxIDogLTE7XG4gICAgICAgICAgeCA/IHggIT09IEMgJiYgKytkIDogcFtoWzBdXSA9IEM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSksIGQgJSAyID09PSAxO1xufVxuZnVuY3Rpb24gWW4odCwgZSkge1xuICB2YXIgbiA9IHRbMF0sIHIgPSB0WzFdLCBzID0gZVswXSwgbyA9IGVbMV0sIGkgPSBzIC0gbiwgYSA9IG8gLSByO1xuICBNYXRoLmFicyhpKSA8IER0ICYmIChpID0gMCksIE1hdGguYWJzKGEpIDwgRHQgJiYgKGEgPSAwKTtcbiAgdmFyIGMgPSAwLCBsID0gMCwgdSA9IDA7XG4gIHJldHVybiBpID8gYSA/IChjID0gLWEgLyBpLCBsID0gMSwgdSA9IC1jICogbiAtIHIpIDogKGwgPSAxLCB1ID0gLXIpIDogYSAmJiAoYyA9IC0xLCB1ID0gbiksIFtjLCBsLCB1XTtcbn1cbmZ1bmN0aW9uIGJzKHQsIGUpIHtcbiAgdmFyIG4gPSB0WzBdLCByID0gdFsxXSwgcyA9IHRbMl0sIG8gPSBlWzBdLCBpID0gZVsxXSwgYSA9IGVbMl0sIGMgPSBuID09PSAwICYmIG8gPT09IDAsIGwgPSByID09PSAwICYmIGkgPT09IDAsIHUgPSBbXTtcbiAgaWYgKGMgJiYgbClcbiAgICByZXR1cm4gW107XG4gIGlmIChjKSB7XG4gICAgdmFyIGYgPSAtcyAvIHIsIGQgPSAtYSAvIGk7XG4gICAgcmV0dXJuIGYgIT09IGQgPyBbXSA6IFtbLTEgLyAwLCBmXSwgWzEgLyAwLCBmXV07XG4gIH0gZWxzZSBpZiAobCkge1xuICAgIHZhciBwID0gLXMgLyBuLCBnID0gLWEgLyBvO1xuICAgIHJldHVybiBwICE9PSBnID8gW10gOiBbW3AsIC0xIC8gMF0sIFtwLCAxIC8gMF1dO1xuICB9IGVsc2UgaWYgKG4gPT09IDApIHtcbiAgICB2YXIgaCA9IC1zIC8gciwgdiA9IC0oaSAqIGggKyBhKSAvIG87XG4gICAgdSA9IFtbdiwgaF1dO1xuICB9IGVsc2UgaWYgKG8gPT09IDApIHtcbiAgICB2YXIgaCA9IC1hIC8gaSwgdiA9IC0ociAqIGggKyBzKSAvIG47XG4gICAgdSA9IFtbdiwgaF1dO1xuICB9IGVsc2UgaWYgKHIgPT09IDApIHtcbiAgICB2YXIgdiA9IC1zIC8gbiwgaCA9IC0obyAqIHYgKyBhKSAvIGk7XG4gICAgdSA9IFtbdiwgaF1dO1xuICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICB2YXIgdiA9IC1hIC8gbywgaCA9IC0obiAqIHYgKyBzKSAvIHI7XG4gICAgdSA9IFtbdiwgaF1dO1xuICB9IGVsc2Uge1xuICAgIHZhciB2ID0gKHIgKiBhIC0gaSAqIHMpIC8gKGkgKiBuIC0gciAqIG8pLCBoID0gLShuICogdiArIHMpIC8gcjtcbiAgICB1ID0gW1t2LCBoXV07XG4gIH1cbiAgcmV0dXJuIHUubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gW21bMF0sIG1bMV1dO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRhKHQsIGUpIHtcbiAgdmFyIG4gPSBlLm1hcChmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIFswLCAxXS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIFtNYXRoLm1pbihmWzBdW2RdLCBmWzFdW2RdKSwgTWF0aC5tYXgoZlswXVtkXSwgZlsxXVtkXSldO1xuICAgIH0pO1xuICB9KSwgciA9IFtdO1xuICBpZiAodC5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcyA9IHRbMF0sIG8gPSBzWzBdLCBpID0gc1sxXTtcbiAgICBpZiAoQXQobyAtIHRbMV1bMF0pKSB7XG4gICAgICBpZiAoIUF0KGkgLSB0WzFdWzFdKSkge1xuICAgICAgICB2YXIgbCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIG4ubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gZlswXVswXTtcbiAgICAgICAgfSkpLCB1ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgbi5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgIHJldHVybiBmWzBdWzFdO1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChBdChsIC0gdSkgPiAwKVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgciA9IFtbbCwgaV0sIFt1LCBpXV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgbi5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZlsxXVswXTtcbiAgICAgIH0pKSwgYyA9IE1hdGgubWluLmFwcGx5KE1hdGgsIG4ubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGZbMV1bMV07XG4gICAgICB9KSk7XG4gICAgICBpZiAoQXQoYSAtIGMpID4gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgciA9IFtbbywgYV0sIFtvLCBjXV07XG4gICAgfVxuICB9XG4gIHJldHVybiByLmxlbmd0aCB8fCAociA9IHQuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgZCA9IGZbMF0sIHAgPSBmWzFdO1xuICAgIHJldHVybiBuLmV2ZXJ5KGZ1bmN0aW9uKGcpIHtcbiAgICAgIHJldHVybiAwIDw9IEF0KGQgLSBnWzBdWzBdKSAmJiAwIDw9IEF0KGdbMF1bMV0gLSBkKSAmJiAwIDw9IEF0KHAgLSBnWzFdWzBdKSAmJiAwIDw9IEF0KGdbMV1bMV0gLSBwKTtcbiAgICB9KTtcbiAgfSkpLCByLm1hcChmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIFtBdChmWzBdKSwgQXQoZlsxXSldO1xuICB9KTtcbn1cbmZ1bmN0aW9uIExyKHQpIHtcbiAgcmV0dXJuIFl1KHQuc2xpY2UoMSksIFt0WzBdXSkubWFwKGZ1bmN0aW9uKGUsIG4pIHtcbiAgICByZXR1cm4gW3Rbbl0sIGVdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFh1KHQsIGUpIHtcbiAgdmFyIG4gPSB0LnNsaWNlKCksIHIgPSBlLnNsaWNlKCk7XG4gIE5zKG4pID09PSAtMSAmJiBuLnJldmVyc2UoKSwgTnMocikgPT09IC0xICYmIHIucmV2ZXJzZSgpO1xuICB2YXIgcyA9IExyKG4pLCBvID0gTHIociksIGkgPSBzLm1hcChmdW5jdGlvbih1KSB7XG4gICAgcmV0dXJuIFluKHVbMF0sIHVbMV0pO1xuICB9KSwgYSA9IG8ubWFwKGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gWW4odVswXSwgdVsxXSk7XG4gIH0pLCBjID0gW107XG4gIGkuZm9yRWFjaChmdW5jdGlvbih1LCBmKSB7XG4gICAgdmFyIGQgPSBzW2ZdLCBwID0gW107XG4gICAgYS5mb3JFYWNoKGZ1bmN0aW9uKGcsIGgpIHtcbiAgICAgIHZhciB2ID0gYnModSwgZyksIG0gPSB0YSh2LCBbZCwgb1toXV0pO1xuICAgICAgcC5wdXNoLmFwcGx5KHAsIG0ubWFwKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRleDE6IGYsXG4gICAgICAgICAgaW5kZXgyOiBoLFxuICAgICAgICAgIHBvczogUyxcbiAgICAgICAgICB0eXBlOiBcImludGVyc2VjdGlvblwiXG4gICAgICAgIH07XG4gICAgICB9KSk7XG4gICAgfSksIHAuc29ydChmdW5jdGlvbihnLCBoKSB7XG4gICAgICByZXR1cm4gdGUoZFswXSwgZy5wb3MpIC0gdGUoZFswXSwgaC5wb3MpO1xuICAgIH0pLCBjLnB1c2guYXBwbHkoYywgcCksIEZyKGRbMV0sIHIpICYmIGMucHVzaCh7XG4gICAgICBpbmRleDE6IGYsXG4gICAgICBpbmRleDI6IC0xLFxuICAgICAgcG9zOiBkWzFdLFxuICAgICAgdHlwZTogXCJpbnNpZGVcIlxuICAgIH0pO1xuICB9KSwgby5mb3JFYWNoKGZ1bmN0aW9uKHUsIGYpIHtcbiAgICBpZiAoRnIodVsxXSwgbikpIHtcbiAgICAgIHZhciBkID0gITEsIHAgPSBuZShjLCBmdW5jdGlvbihnKSB7XG4gICAgICAgIHZhciBoID0gZy5pbmRleDI7XG4gICAgICAgIHJldHVybiBoID09PSBmID8gKGQgPSAhMCwgITEpIDogISFkO1xuICAgICAgfSk7XG4gICAgICBwID09PSAtMSAmJiAoZCA9ICExLCBwID0gbmUoYywgZnVuY3Rpb24oZykge1xuICAgICAgICB2YXIgaCA9IGcuaW5kZXgxLCB2ID0gZy5pbmRleDI7XG4gICAgICAgIHJldHVybiBoID09PSAtMSAmJiB2ICsgMSA9PT0gZiA/IChkID0gITAsICExKSA6ICEhZDtcbiAgICAgIH0pKSwgcCA9PT0gLTEgPyBjLnB1c2goe1xuICAgICAgICBpbmRleDE6IC0xLFxuICAgICAgICBpbmRleDI6IGYsXG4gICAgICAgIHBvczogdVsxXSxcbiAgICAgICAgdHlwZTogXCJpbnNpZGVcIlxuICAgICAgfSkgOiBjLnNwbGljZShwLCAwLCB7XG4gICAgICAgIGluZGV4MTogLTEsXG4gICAgICAgIGluZGV4MjogZixcbiAgICAgICAgcG9zOiB1WzFdLFxuICAgICAgICB0eXBlOiBcImluc2lkZVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICB2YXIgbCA9IHt9O1xuICByZXR1cm4gYy5maWx0ZXIoZnVuY3Rpb24odSkge1xuICAgIHZhciBmID0gdS5wb3MsIGQgPSBmWzBdICsgXCJ4XCIgKyBmWzFdO1xuICAgIHJldHVybiBsW2RdID8gITEgOiAobFtkXSA9ICEwLCAhMCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gSHUodCwgZSkge1xuICB2YXIgbiA9IFh1KHQsIGUpO1xuICByZXR1cm4gbi5tYXAoZnVuY3Rpb24ocikge1xuICAgIHZhciBzID0gci5wb3M7XG4gICAgcmV0dXJuIHM7XG4gIH0pO1xufVxuZnVuY3Rpb24gcXUodCwgZSkge1xuICB2YXIgbiA9IEh1KHQsIGUpO1xuICByZXR1cm4gUWkobik7XG59XG5jb25zdCBVdSA9IFtcbiAgWzAsIC0xLCBcIm5cIl0sXG4gIFsxLCAwLCBcImVcIl1cbl0sIEt1ID0gW1xuICBbLTEsIC0xLCBcIm53XCJdLFxuICBbMCwgLTEsIFwiblwiXSxcbiAgWzEsIC0xLCBcIm5lXCJdLFxuICBbMSwgMCwgXCJlXCJdLFxuICBbMSwgMSwgXCJzZVwiXSxcbiAgWzAsIDEsIFwic1wiXSxcbiAgWy0xLCAxLCBcInN3XCJdLFxuICBbLTEsIDAsIFwid1wiXVxuXTtcbmZ1bmN0aW9uIHlzKHQsIGUsIG4pIHtcbiAgY29uc3QgeyBjbGlwUmVsYXRpdmU6IHIgfSA9IHQucHJvcHMsIHsgd2lkdGg6IHMsIGhlaWdodDogbyB9ID0gdC5zdGF0ZSwgeyB0eXBlOiBpLCBwb3NlczogYSB9ID0gZSwgYyA9IGkgPT09IFwicmVjdFwiLCBsID0gaSA9PT0gXCJjaXJjbGVcIjtcbiAgaWYgKGkgPT09IFwicG9seWdvblwiKVxuICAgIHJldHVybiBuLm1hcChcbiAgICAgICh1KSA9PiBgJHtYdCh1WzBdLCBzLCByKX0gJHtYdCh1WzFdLCBvLCByKX1gXG4gICAgKTtcbiAgaWYgKGMgfHwgaSA9PT0gXCJpbnNldFwiKSB7XG4gICAgY29uc3QgdSA9IG5bMV1bMV0sIGYgPSBuWzNdWzBdLCBkID0gbls3XVswXSwgcCA9IG5bNV1bMV07XG4gICAgaWYgKGMpXG4gICAgICByZXR1cm4gW3UsIGYsIHAsIGRdLm1hcCgoaCkgPT4gYCR7aH1weGApO1xuICAgIGNvbnN0IGcgPSBbdSwgcyAtIGYsIG8gLSBwLCBkXS5tYXAoXG4gICAgICAoaCwgdikgPT4gWHQoaCwgdiAlIDIgPyBzIDogbywgcilcbiAgICApO1xuICAgIGlmIChuLmxlbmd0aCA+IDgpIHtcbiAgICAgIGNvbnN0IFtoLCB2XSA9IEsobls0XSwgblswXSk7XG4gICAgICBnLnB1c2goXG4gICAgICAgIFwicm91bmRcIixcbiAgICAgICAgLi4uRHMoXG4gICAgICAgICAgYS5zbGljZSg4KS5tYXAoKG0sIFMpID0+ICh7XG4gICAgICAgICAgICAuLi5tLFxuICAgICAgICAgICAgcG9zOiBuW1NdXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgaCxcbiAgICAgICAgICB2LFxuICAgICAgICAgIGQsXG4gICAgICAgICAgdSxcbiAgICAgICAgICBmLFxuICAgICAgICAgIHBcbiAgICAgICAgKS5zdHlsZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBnO1xuICB9IGVsc2UgaWYgKGwgfHwgaSA9PT0gXCJlbGxpcHNlXCIpIHtcbiAgICBjb25zdCB1ID0gblswXSwgZiA9IFh0KFxuICAgICAgQihuWzFdWzFdIC0gdVsxXSksXG4gICAgICBsID8gTWF0aC5zcXJ0KChzICogcyArIG8gKiBvKSAvIDIpIDogbyxcbiAgICAgIHJcbiAgICApLCBkID0gbCA/IFtmXSA6IFtYdChCKG5bMl1bMF0gLSB1WzBdKSwgcywgciksIGZdO1xuICAgIHJldHVybiBkLnB1c2goXG4gICAgICBcImF0XCIsXG4gICAgICBYdCh1WzBdLCBzLCByKSxcbiAgICAgIFh0KHVbMV0sIG8sIHIpXG4gICAgKSwgZDtcbiAgfVxufVxuZnVuY3Rpb24gVm4odCwgZSwgbiwgcikge1xuICBjb25zdCBzID0gW3IsIChyICsgZSkgLyAyLCBlXSwgbyA9IFt0LCAodCArIG4pIC8gMiwgbl07XG4gIHJldHVybiBLdS5tYXAoKFtpLCBhLCBjXSkgPT4ge1xuICAgIGNvbnN0IGwgPSBzW2kgKyAxXSwgdSA9IG9bYSArIDFdO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0aWNhbDogQihhKSxcbiAgICAgIGhvcml6b250YWw6IEIoaSksXG4gICAgICBkaXJlY3Rpb246IGMsXG4gICAgICBwb3M6IFtsLCB1XVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gZWEodCkge1xuICBjb25zdCBlID0gWzEgLyAwLCAtMSAvIDBdLCBuID0gWzEgLyAwLCAtMSAvIDBdO1xuICByZXR1cm4gdC5mb3JFYWNoKCh7IHBvczogciB9KSA9PiB7XG4gICAgZVswXSA9IE1hdGgubWluKGVbMF0sIHJbMF0pLCBlWzFdID0gTWF0aC5tYXgoZVsxXSwgclswXSksIG5bMF0gPSBNYXRoLm1pbihuWzBdLCByWzFdKSwgblsxXSA9IE1hdGgubWF4KG5bMV0sIHJbMV0pO1xuICB9KSwgW0IoZVsxXSAtIGVbMF0pLCBCKG5bMV0gLSBuWzBdKV07XG59XG5mdW5jdGlvbiB4byh0LCBlLCBuLCByLCBzKSB7XG4gIGlmICghdClcbiAgICByZXR1cm47XG4gIGxldCBvID0gcztcbiAgaWYgKCFvKSB7XG4gICAgY29uc3QgdSA9IEd0KHQpLCBmID0gdShcImNsaXBQYXRoXCIpO1xuICAgIG8gPSBmICE9PSBcIm5vbmVcIiA/IGYgOiB1KFwiY2xpcFwiKTtcbiAgfVxuICBpZiAoKCFvIHx8IG8gPT09IFwibm9uZVwiIHx8IG8gPT09IFwiYXV0b1wiKSAmJiAobyA9IHIsICFvKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHsgcHJlZml4OiBpID0gbywgdmFsdWU6IGEgPSBcIlwiIH0gPSBYbyhvKSwgYyA9IGkgPT09IFwiY2lyY2xlXCI7XG4gIGxldCBsID0gXCIgXCI7XG4gIGlmIChpID09PSBcInBvbHlnb25cIikge1xuICAgIGNvbnN0IHUgPSB4ZShhIHx8IFwiMCUgMCUsIDEwMCUgMCUsIDEwMCUgMTAwJSwgMCUgMTAwJVwiKTtcbiAgICBsID0gXCIsXCI7XG4gICAgY29uc3QgZiA9IHUubWFwKChwKSA9PiB7XG4gICAgICBjb25zdCBbZywgaF0gPSBwLnNwbGl0KFwiIFwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRpY2FsOiAxLFxuICAgICAgICBob3Jpem9udGFsOiAxLFxuICAgICAgICBwb3M6IFtmdChnLCBlKSwgZnQoaCwgbildXG4gICAgICB9O1xuICAgIH0pLCBkID0gYmUoZi5tYXAoKHApID0+IHAucG9zKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGksXG4gICAgICBjbGlwVGV4dDogbyxcbiAgICAgIHBvc2VzOiBmLFxuICAgICAgc3BsaXR0ZXI6IGwsXG4gICAgICBsZWZ0OiBkLm1pblgsXG4gICAgICByaWdodDogZC5tYXhYLFxuICAgICAgdG9wOiBkLm1pblksXG4gICAgICBib3R0b206IGQubWF4WVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYyB8fCBpID09PSBcImVsbGlwc2VcIikge1xuICAgIGxldCB1ID0gXCJcIiwgZiA9IFwiXCIsIGQgPSAwLCBwID0gMDtcbiAgICBjb25zdCBnID0gY2UoYSk7XG4gICAgaWYgKGMpIHtcbiAgICAgIGxldCBtID0gXCJcIjtcbiAgICAgIFttID0gXCI1MCVcIiwgLCB1ID0gXCI1MCVcIiwgZiA9IFwiNTAlXCJdID0gZywgZCA9IGZ0KFxuICAgICAgICBtLFxuICAgICAgICBNYXRoLnNxcnQoKGUgKiBlICsgbiAqIG4pIC8gMilcbiAgICAgICksIHAgPSBkO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbSA9IFwiXCIsIFMgPSBcIlwiO1xuICAgICAgW20gPSBcIjUwJVwiLCBTID0gXCI1MCVcIiwgLCB1ID0gXCI1MCVcIiwgZiA9IFwiNTAlXCJdID0gZywgZCA9IGZ0KG0sIGUpLCBwID0gZnQoUywgbik7XG4gICAgfVxuICAgIGNvbnN0IGggPSBbXG4gICAgICBmdCh1LCBlKSxcbiAgICAgIGZ0KGYsIG4pXG4gICAgXSwgdiA9IFtcbiAgICAgIHtcbiAgICAgICAgdmVydGljYWw6IDEsXG4gICAgICAgIGhvcml6b250YWw6IDEsXG4gICAgICAgIHBvczogaCxcbiAgICAgICAgZGlyZWN0aW9uOiBcIm5lc3dcIlxuICAgICAgfSxcbiAgICAgIC4uLlV1LnNsaWNlKDAsIGMgPyAxIDogMikubWFwKChtKSA9PiAoe1xuICAgICAgICB2ZXJ0aWNhbDogQihtWzFdKSxcbiAgICAgICAgaG9yaXpvbnRhbDogbVswXSxcbiAgICAgICAgZGlyZWN0aW9uOiBtWzJdLFxuICAgICAgICBzdWI6ICEwLFxuICAgICAgICBwb3M6IFtoWzBdICsgbVswXSAqIGQsIGhbMV0gKyBtWzFdICogcF1cbiAgICAgIH0pKVxuICAgIF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGksXG4gICAgICBjbGlwVGV4dDogbyxcbiAgICAgIHJhZGl1c1g6IGQsXG4gICAgICByYWRpdXNZOiBwLFxuICAgICAgbGVmdDogaFswXSAtIGQsXG4gICAgICB0b3A6IGhbMV0gLSBwLFxuICAgICAgcmlnaHQ6IGhbMF0gKyBkLFxuICAgICAgYm90dG9tOiBoWzFdICsgcCxcbiAgICAgIHBvc2VzOiB2LFxuICAgICAgc3BsaXR0ZXI6IGxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGkgPT09IFwiaW5zZXRcIikge1xuICAgIGNvbnN0IHUgPSBjZShhIHx8IFwiMCAwIDAgMCByb3VuZCAwcHhcIiksIGYgPSB1LmluZGV4T2YoXCJyb3VuZFwiKSwgZCA9IChmID4gLTEgPyB1LnNsaWNlKDAsIGYpIDogdSkubGVuZ3RoLCBwID0gdS5zbGljZShkICsgMSksIFtcbiAgICAgIGcsXG4gICAgICBoID0gZyxcbiAgICAgIHYgPSBnLFxuICAgICAgbSA9IGhcbiAgICBdID0gdS5zbGljZSgwLCBkKSwgW1MsIHhdID0gW2csIHZdLm1hcChcbiAgICAgIChNKSA9PiBmdChNLCBuKVxuICAgICksIFtDLCBFXSA9IFttLCBoXS5tYXAoXG4gICAgICAoTSkgPT4gZnQoTSwgZSlcbiAgICApLCBEID0gZSAtIEUsIFIgPSBuIC0geCwgeSA9IFtcbiAgICAgIC4uLlZuKFMsIEQsIFIsIEMpXG4gICAgXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbnNldFwiLFxuICAgICAgY2xpcFRleHQ6IG8sXG4gICAgICBwb3NlczogeSxcbiAgICAgIHRvcDogUyxcbiAgICAgIGxlZnQ6IEMsXG4gICAgICByaWdodDogRCxcbiAgICAgIGJvdHRvbTogUixcbiAgICAgIHJhZGl1czogcCxcbiAgICAgIHNwbGl0dGVyOiBsXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpID09PSBcInJlY3RcIikge1xuICAgIGNvbnN0IHUgPSB4ZShhIHx8IGAwcHgsICR7ZX1weCwgJHtufXB4LCAwcHhgKTtcbiAgICBsID0gXCIsXCI7XG4gICAgY29uc3QgW2YsIGQsIHAsIGddID0gdS5tYXAoKHYpID0+IHtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IG0gfSA9IHBuKHYpO1xuICAgICAgcmV0dXJuIG07XG4gICAgfSksIGggPSBWbihmLCBkLCBwLCBnKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyZWN0XCIsXG4gICAgICBjbGlwVGV4dDogbyxcbiAgICAgIHBvc2VzOiBoLFxuICAgICAgdG9wOiBmLFxuICAgICAgcmlnaHQ6IGQsXG4gICAgICBib3R0b206IHAsXG4gICAgICBsZWZ0OiBnLFxuICAgICAgdmFsdWVzOiB1LFxuICAgICAgc3BsaXR0ZXI6IGxcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBadSh0LCBlLCBuLCByLCBzKSB7XG4gIGNvbnN0IHsgZGlyZWN0aW9uOiBvLCBzdWI6IGkgfSA9IHRbZV0sIGEgPSB0Lm1hcCgoKSA9PiBbMCwgMF0pLCBjID0gbyA/IG8uc3BsaXQoXCJcIikgOiBbXTtcbiAgaWYgKHIgJiYgZSA8IDgpIHtcbiAgICBjb25zdCBsID0gYy5maWx0ZXIoXG4gICAgICAodikgPT4gdiA9PT0gXCJ3XCIgfHwgdiA9PT0gXCJlXCJcbiAgICApLCB1ID0gYy5maWx0ZXIoXG4gICAgICAodikgPT4gdiA9PT0gXCJuXCIgfHwgdiA9PT0gXCJzXCJcbiAgICApLCBmID0gbFswXSwgZCA9IHVbMF07XG4gICAgYVtlXSA9IG47XG4gICAgY29uc3QgW3AsIGddID0gZWEodCksIGggPSBwICYmIGcgPyBwIC8gZyA6IDA7XG4gICAgaWYgKGggJiYgcykge1xuICAgICAgY29uc3QgdiA9IChlICsgNCkgJSA4LCBtID0gdFt2XS5wb3MsIFMgPSBbMCwgMF07XG4gICAgICBvLmluZGV4T2YoXCJ3XCIpID4gLTEgPyBTWzBdID0gLTEgOiBvLmluZGV4T2YoXCJlXCIpID4gLTEgJiYgKFNbMF0gPSAxKSwgby5pbmRleE9mKFwiblwiKSA+IC0xID8gU1sxXSA9IC0xIDogby5pbmRleE9mKFwic1wiKSA+IC0xICYmIChTWzFdID0gMSk7XG4gICAgICBjb25zdCB4ID0gamkoXG4gICAgICAgIFtwLCBnXSxcbiAgICAgICAgbixcbiAgICAgICAgaCxcbiAgICAgICAgUyxcbiAgICAgICAgITBcbiAgICAgICksIEMgPSBwICsgeFswXSwgRSA9IGcgKyB4WzFdO1xuICAgICAgbGV0IEQgPSBtWzFdLCBSID0gbVsxXSwgeSA9IG1bMF0sIE0gPSBtWzBdO1xuICAgICAgU1swXSA9PT0gLTEgPyB5ID0gTSAtIEMgOiBTWzBdID09PSAxID8gTSA9IHkgKyBDIDogKHkgPSB5IC0gQyAvIDIsIE0gPSBNICsgQyAvIDIpLCBTWzFdID09PSAtMSA/IEQgPSBSIC0gRSA6IChTWzFdID09PSAxIHx8IChEID0gUiAtIEUgLyAyKSwgUiA9IEQgKyBFKTtcbiAgICAgIGNvbnN0IFAgPSBWbihELCBNLCBSLCB5KTtcbiAgICAgIHQuZm9yRWFjaCgoXywgTykgPT4ge1xuICAgICAgICBhW09dWzBdID0gUFtPXS5wb3NbMF0gLSBfLnBvc1swXSwgYVtPXVsxXSA9IFBbT10ucG9zWzFdIC0gXy5wb3NbMV07XG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICAgIHQuZm9yRWFjaCgodiwgbSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRpcmVjdGlvbjogUyB9ID0gdjtcbiAgICAgICAgUyAmJiAoUy5pbmRleE9mKGYpID4gLTEgJiYgKGFbbV1bMF0gPSBuWzBdKSwgUy5pbmRleE9mKGQpID4gLTEgJiYgKGFbbV1bMV0gPSBuWzFdKSk7XG4gICAgICB9KSwgZiAmJiAoYVsxXVswXSA9IG5bMF0gLyAyLCBhWzVdWzBdID0gblswXSAvIDIpLCBkICYmIChhWzNdWzFdID0gblsxXSAvIDIsIGFbN11bMV0gPSBuWzFdIC8gMik7XG4gIH0gZWxzZSBvICYmICFpID8gYy5mb3JFYWNoKChsKSA9PiB7XG4gICAgY29uc3QgdSA9IGwgPT09IFwiblwiIHx8IGwgPT09IFwic1wiO1xuICAgIHQuZm9yRWFjaCgoZiwgZCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkaXJlY3Rpb246IHAsXG4gICAgICAgIGhvcml6b250YWw6IGcsXG4gICAgICAgIHZlcnRpY2FsOiBoXG4gICAgICB9ID0gZjtcbiAgICAgICFwIHx8IHAuaW5kZXhPZihsKSA9PT0gLTEgfHwgKGFbZF0gPSBbXG4gICAgICAgIHUgfHwgIWcgPyAwIDogblswXSxcbiAgICAgICAgIXUgfHwgIWggPyAwIDogblsxXVxuICAgICAgXSk7XG4gICAgfSk7XG4gIH0pIDogYVtlXSA9IG47XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gSnUodCwgZSkge1xuICBjb25zdCBbbiwgcl0gPSBuaSh0LCBlKSwgeyBjbGlwUGF0aDogcywgY2xpcEluZGV4OiBvIH0gPSBlLmRhdGFzLCB7XG4gICAgdHlwZTogaSxcbiAgICBwb3NlczogYSxcbiAgICBzcGxpdHRlcjogY1xuICB9ID0gcywgbCA9IGEubWFwKChkKSA9PiBkLnBvcyk7XG4gIGlmIChpID09PSBcInBvbHlnb25cIilcbiAgICBsLnNwbGljZShvLCAwLCBbbiwgcl0pO1xuICBlbHNlIGlmIChpID09PSBcImluc2V0XCIpIHtcbiAgICBjb25zdCBkID0ga3UuaW5kZXhPZihvKSwgcCA9ICR1LmluZGV4T2YobyksIGcgPSBhLmxlbmd0aDtcbiAgICBpZiAoTnUoXG4gICAgICBhLFxuICAgICAgbCxcbiAgICAgIDgsXG4gICAgICBkLFxuICAgICAgcCxcbiAgICAgIG4sXG4gICAgICByLFxuICAgICAgbFs0XVswXSxcbiAgICAgIGxbNF1bMV0sXG4gICAgICBsWzBdWzBdLFxuICAgICAgbFswXVsxXVxuICAgICksIGcgPT09IGEubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICB9IGVsc2VcbiAgICByZXR1cm47XG4gIGNvbnN0IHUgPSB5cyh0LCBzLCBsKSwgZiA9IGAke2l9KCR7dS5qb2luKGMpfSlgO1xuICBqKFxuICAgIHQsXG4gICAgXCJvbkNsaXBcIixcbiAgICBldCh0LCBlLCB7XG4gICAgICBjbGlwRXZlbnRUeXBlOiBcImFkZGVkXCIsXG4gICAgICBjbGlwVHlwZTogaSxcbiAgICAgIHBvc2VzOiBsLFxuICAgICAgY2xpcFN0eWxlczogdSxcbiAgICAgIGNsaXBTdHlsZTogZixcbiAgICAgIGRpc3RYOiAwLFxuICAgICAgZGlzdFk6IDAsXG4gICAgICAuLi5JdChcbiAgICAgICAge1xuICAgICAgICAgIGNsaXBQYXRoOiBmXG4gICAgICAgIH0sXG4gICAgICAgIGVcbiAgICAgIClcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gUXUodCwgZSkge1xuICBjb25zdCB7IGNsaXBQYXRoOiBuLCBjbGlwSW5kZXg6IHIgfSA9IGUuZGF0YXMsIHtcbiAgICB0eXBlOiBzLFxuICAgIHBvc2VzOiBvLFxuICAgIHNwbGl0dGVyOiBpXG4gIH0gPSBuLCBhID0gby5tYXAoKGYpID0+IGYucG9zKSwgYyA9IGEubGVuZ3RoO1xuICBpZiAocyA9PT0gXCJwb2x5Z29uXCIpXG4gICAgby5zcGxpY2UociwgMSksIGEuc3BsaWNlKHIsIDEpO1xuICBlbHNlIGlmIChzID09PSBcImluc2V0XCIpIHtcbiAgICBpZiAociA8IDggfHwgKEx1KG8sIGEsIHIsIDgsIGMpLCBjID09PSBvLmxlbmd0aCkpXG4gICAgICByZXR1cm47XG4gIH0gZWxzZVxuICAgIHJldHVybjtcbiAgY29uc3QgbCA9IHlzKHQsIG4sIGEpLCB1ID0gYCR7c30oJHtsLmpvaW4oaSl9KWA7XG4gIGooXG4gICAgdCxcbiAgICBcIm9uQ2xpcFwiLFxuICAgIGV0KHQsIGUsIHtcbiAgICAgIGNsaXBFdmVudFR5cGU6IFwicmVtb3ZlZFwiLFxuICAgICAgY2xpcFR5cGU6IHMsXG4gICAgICBwb3NlczogYSxcbiAgICAgIGNsaXBTdHlsZXM6IGwsXG4gICAgICBjbGlwU3R5bGU6IHUsXG4gICAgICBkaXN0WDogMCxcbiAgICAgIGRpc3RZOiAwLFxuICAgICAgLi4uSXQoXG4gICAgICAgIHtcbiAgICAgICAgICBjbGlwUGF0aDogdVxuICAgICAgICB9LFxuICAgICAgICBlXG4gICAgICApXG4gICAgfSlcbiAgKTtcbn1cbmNvbnN0IHRmID0ge1xuICBuYW1lOiBcImNsaXBwYWJsZVwiLFxuICBwcm9wczogW1xuICAgIFwiY2xpcHBhYmxlXCIsXG4gICAgXCJkZWZhdWx0Q2xpcFBhdGhcIixcbiAgICBcImN1c3RvbUNsaXBQYXRoXCIsXG4gICAgXCJrZWVwUmF0aW9cIixcbiAgICBcImNsaXBSZWxhdGl2ZVwiLFxuICAgIFwiY2xpcEFyZWFcIixcbiAgICBcImRyYWdXaXRoQ2xpcFwiLFxuICAgIFwiY2xpcFRhcmdldEJvdW5kc1wiLFxuICAgIFwiY2xpcFZlcnRpY2FsR3VpZGVsaW5lc1wiLFxuICAgIFwiY2xpcEhvcml6b250YWxHdWlkZWxpbmVzXCIsXG4gICAgXCJjbGlwU25hcFRocmVzaG9sZFwiXG4gIF0sXG4gIGV2ZW50czogW1wiY2xpcFN0YXJ0XCIsIFwiY2xpcFwiLCBcImNsaXBFbmRcIl0sXG4gIGNzczogW1xuICAgIGAuY29udHJvbC5jbGlwLWNvbnRyb2wge1xuYmFja2dyb3VuZDogcmVkO1xuY3Vyc29yOiBwb2ludGVyO1xufVxuLmNvbnRyb2wuY2xpcC1jb250cm9sLmNsaXAtcmFkaXVzIHtcbmJhY2tncm91bmQ6ICNkNjY7XG59XG4ubGluZS5jbGlwLWxpbmUge1xuYmFja2dyb3VuZDogIzZlNjtcbmN1cnNvcjogbW92ZTtcbnotaW5kZXg6IDE7XG59XG4uY2xpcC1hcmVhIHtcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcbnRvcDogMDtcbmxlZnQ6IDA7XG59XG4uY2xpcC1lbGxpcHNlIHtcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcbmN1cnNvcjogbW92ZTtcbmJvcmRlcjogMXB4IHNvbGlkICM2ZDY7XG5ib3JkZXI6IHZhcigtLXpvb21weCkgc29saWQgIzZkNjtcbmJvcmRlci1yYWRpdXM6IDUwJTtcbnRyYW5zZm9ybS1vcmlnaW46IDBweCAwcHg7XG59YCxcbiAgICBgOmhvc3Qge1xuLS1ib3VuZHMtY29sb3I6ICNkNjY7XG59YCxcbiAgICBgLmd1aWRlbGluZSB7XG5wb2ludGVyLWV2ZW50czogbm9uZTtcbnotaW5kZXg6IDI7XG59YCxcbiAgICBgLmxpbmUuZ3VpZGVsaW5lLmJvdW5kcyB7XG5iYWNrZ3JvdW5kOiAjZDY2O1xuYmFja2dyb3VuZDogdmFyKC0tYm91bmRzLWNvbG9yKTtcbn1gXG4gIF0sXG4gIHJlbmRlcih0LCBlKSB7XG4gICAgY29uc3QgeyBjdXN0b21DbGlwUGF0aDogbiwgZGVmYXVsdENsaXBQYXRoOiByLCBjbGlwQXJlYTogcywgem9vbTogbywgZ3JvdXBhYmxlOiBpIH0gPSB0LnByb3BzLCB7XG4gICAgICB0YXJnZXQ6IGEsXG4gICAgICB3aWR0aDogYyxcbiAgICAgIGhlaWdodDogbCxcbiAgICAgIGFsbE1hdHJpeDogdSxcbiAgICAgIGlzM2Q6IGYsXG4gICAgICBsZWZ0OiBkLFxuICAgICAgdG9wOiBwLFxuICAgICAgcG9zMTogZyxcbiAgICAgIHBvczI6IGgsXG4gICAgICBwb3MzOiB2LFxuICAgICAgcG9zNDogbSxcbiAgICAgIGNsaXBQYXRoU3RhdGU6IFMsXG4gICAgICBzbmFwQm91bmRJbmZvczogeCxcbiAgICAgIHJvdGF0aW9uOiBDXG4gICAgfSA9IHQuZ2V0U3RhdGUoKTtcbiAgICBpZiAoIWEgfHwgaSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBFID0geG8oXG4gICAgICBhLFxuICAgICAgYyxcbiAgICAgIGwsXG4gICAgICByIHx8IFwiaW5zZXRcIixcbiAgICAgIFMgfHwgblxuICAgICk7XG4gICAgaWYgKCFFKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IEQgPSBmID8gNCA6IDMsIFIgPSBFLnR5cGUsIE0gPSBFLnBvc2VzLm1hcCgoSSkgPT4ge1xuICAgICAgY29uc3QgJCA9IGh0KHUsIEkucG9zLCBEKTtcbiAgICAgIHJldHVybiBbJFswXSAtIGQsICRbMV0gLSBwXTtcbiAgICB9KTtcbiAgICBsZXQgUCA9IFtdLCBfID0gW107XG4gICAgY29uc3QgTyA9IFIgPT09IFwicmVjdFwiLCBUID0gUiA9PT0gXCJpbnNldFwiLCB3ID0gUiA9PT0gXCJwb2x5Z29uXCI7XG4gICAgaWYgKE8gfHwgVCB8fCB3KSB7XG4gICAgICBjb25zdCBJID0gVCA/IE0uc2xpY2UoMCwgOCkgOiBNO1xuICAgICAgXyA9IEkubWFwKCgkLCBHKSA9PiB7XG4gICAgICAgIGNvbnN0IEwgPSBHID09PSAwID8gSVtJLmxlbmd0aCAtIDFdIDogSVtHIC0gMV0sIHogPSB4dChMLCAkKSwgTiA9IEdpKEwsICQpO1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogVShcImxpbmVcIiwgXCJjbGlwLWxpbmVcIiwgXCJzbmFwLWNvbnRyb2xcIiksXG4gICAgICAgICAgICBcImRhdGEtY2xpcC1pbmRleFwiOiBHLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IGAke059cHhgLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtMWzBdfXB4LCAke0xbMV19cHgpIHJvdGF0ZSgke3p9cmFkKSBzY2FsZVkoJHtvfSlgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBgY2xpcExpbmUke0d9YFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGsgPSBbXCJud1wiLCBcIm5cIiwgXCJuZVwiLCBcImVcIiwgXCJzZVwiLCBcInNcIiwgXCJzd1wiLCBcIndcIl07XG4gICAgaWYgKFAgPSBNLm1hcCgoSSwgJCkgPT4ge1xuICAgICAgY29uc3QgRyA9IGtbJF07XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogVShcbiAgICAgICAgICAgIFwiY29udHJvbFwiLFxuICAgICAgICAgICAgXCJjbGlwLWNvbnRyb2xcIixcbiAgICAgICAgICAgIFwic25hcC1jb250cm9sXCIsXG4gICAgICAgICAgICBgY2xpcC0ke0d9YFxuICAgICAgICAgICksXG4gICAgICAgICAgXCJkYXRhLWNsaXAtaW5kZXhcIjogJCxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7SVswXX1weCwgJHtJWzFdfXB4KSByb3RhdGUoJHtDfXJhZCkgc2NhbGUoJHtvfSlgLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImdyZWVuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGBjbGlwQ29udHJvbCR7JH1gXG4gICAgICApO1xuICAgIH0pLCBUICYmIFAucHVzaChcbiAgICAgIC4uLk0uc2xpY2UoOCkubWFwKChJLCAkKSA9PiAvKiBAX19QVVJFX18gKi8gaXQuanN4KFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBVKFxuICAgICAgICAgICAgXCJjb250cm9sXCIsXG4gICAgICAgICAgICBcImNsaXAtY29udHJvbFwiLFxuICAgICAgICAgICAgXCJjbGlwLXJhZGl1c1wiLFxuICAgICAgICAgICAgXCJzbmFwLWNvbnRyb2xcIlxuICAgICAgICAgICksXG4gICAgICAgICAgXCJkYXRhLWNsaXAtaW5kZXhcIjogOCArICQsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke0lbMF19cHgsICR7SVsxXX1weCkgcm90YXRlKCR7Q31yYWQpIHNjYWxlKCR7b30pYFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYGNsaXBSYWRpdXNDb250cm9sJHskfWBcbiAgICAgICkpXG4gICAgKSwgUiA9PT0gXCJjaXJjbGVcIiB8fCBSID09PSBcImVsbGlwc2VcIikge1xuICAgICAgY29uc3QgeyBsZWZ0OiBJLCB0b3A6ICQsIHJhZGl1c1g6IEcsIHJhZGl1c1k6IEwgfSA9IEUsIFt6LCBOXSA9IEsoXG4gICAgICAgIGh0KHUsIFtJLCAkXSwgRCksXG4gICAgICAgIGh0KHUsIFswLCAwXSwgRClcbiAgICAgICk7XG4gICAgICBsZXQgWiA9IFwibm9uZVwiO1xuICAgICAgaWYgKCFzKSB7XG4gICAgICAgIGNvbnN0IFkgPSBNYXRoLm1heCgxMCwgRyAvIDUsIEwgLyA1KSwgVyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBKID0gMDsgSiA8PSBZOyArK0opIHtcbiAgICAgICAgICBjb25zdCBxID0gTWF0aC5QSSAqIDIgLyBZICogSjtcbiAgICAgICAgICBXLnB1c2goW1xuICAgICAgICAgICAgRyArIChHIC0gbykgKiBNYXRoLmNvcyhxKSxcbiAgICAgICAgICAgIEwgKyAoTCAtIG8pICogTWF0aC5zaW4ocSlcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBXLnB1c2goW0csIC0yXSksIFcucHVzaChbLTIsIC0yXSksIFcucHVzaChbLTIsIEwgKiAyICsgMl0pLCBXLnB1c2goW0cgKiAyICsgMiwgTCAqIDIgKyAyXSksIFcucHVzaChbRyAqIDIgKyAyLCAtMl0pLCBXLnB1c2goW0csIC0yXSksIFogPSBgcG9seWdvbigke1cubWFwKChKKSA9PiBgJHtKWzBdfXB4ICR7SlsxXX1weGApLmpvaW4oXCIsIFwiKX0pYDtcbiAgICAgIH1cbiAgICAgIFAucHVzaChcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogVShcImNsaXAtZWxsaXBzZVwiLCBcInNuYXAtY29udHJvbFwiKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBgJHtHICogMn1weGAsXG4gICAgICAgICAgICAgIGhlaWdodDogYCR7TCAqIDJ9cHhgLFxuICAgICAgICAgICAgICBjbGlwUGF0aDogWixcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7LWQgKyB6fXB4LCAkey1wICsgTn1weCkgJHtKbih1KX1gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNsaXBFbGxpcHNlXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGg6IEksXG4gICAgICAgIGhlaWdodDogJCxcbiAgICAgICAgbGVmdDogRyxcbiAgICAgICAgdG9wOiBMXG4gICAgICB9ID0gWXQoW2csIGgsIHYsIG0sIC4uLk1dKTtcbiAgICAgIGlmICh3IHx8IE8gfHwgVCkge1xuICAgICAgICBjb25zdCB6ID0gVCA/IE0uc2xpY2UoMCwgOCkgOiBNO1xuICAgICAgICBQLnB1c2goXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogVShcImNsaXAtYXJlYVwiLCBcInNuYXAtY29udHJvbFwiKSxcbiAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogYCR7SX1weGAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHskfXB4YCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtHfXB4LCAke0x9cHgpYCxcbiAgICAgICAgICAgICAgICBjbGlwUGF0aDogYHBvbHlnb24oJHt6Lm1hcCgoTikgPT4gYCR7TlswXSAtIEd9cHggJHtOWzFdIC0gTH1weGApLmpvaW4oXCIsIFwiKX0pYFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGlwQXJlYVwiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geCAmJiBbXCJ2ZXJ0aWNhbFwiLCBcImhvcml6b250YWxcIl0uZm9yRWFjaCgoSSkgPT4ge1xuICAgICAgY29uc3QgJCA9IHhbSV0sIEcgPSBJID09PSBcImhvcml6b250YWxcIjtcbiAgICAgICQuaXNTbmFwICYmIF8ucHVzaChcbiAgICAgICAgLi4uJC5zbmFwLnBvc0luZm9zLm1hcCgoeyBwb3M6IEwgfSwgeikgPT4ge1xuICAgICAgICAgIGNvbnN0IE4gPSBLKFxuICAgICAgICAgICAgaHQoXG4gICAgICAgICAgICAgIHUsXG4gICAgICAgICAgICAgIEcgPyBbMCwgTF0gOiBbTCwgMF0sXG4gICAgICAgICAgICAgIERcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBbZCwgcF1cbiAgICAgICAgICApLCBaID0gSyhcbiAgICAgICAgICAgIGh0KFxuICAgICAgICAgICAgICB1LFxuICAgICAgICAgICAgICBHID8gW2MsIExdIDogW0wsIGxdLFxuICAgICAgICAgICAgICBEXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgW2QsIHBdXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdW4oXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIE4sXG4gICAgICAgICAgICBaLFxuICAgICAgICAgICAgbyxcbiAgICAgICAgICAgIGBjbGlwJHtJfXNuYXAke3p9YCxcbiAgICAgICAgICAgIFwiZ3VpZGVsaW5lXCJcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgKSwgJC5pc0JvdW5kICYmIF8ucHVzaChcbiAgICAgICAgLi4uJC5ib3VuZHMubWFwKCh7IHBvczogTCB9LCB6KSA9PiB7XG4gICAgICAgICAgY29uc3QgTiA9IEsoXG4gICAgICAgICAgICBodChcbiAgICAgICAgICAgICAgdSxcbiAgICAgICAgICAgICAgRyA/IFswLCBMXSA6IFtMLCAwXSxcbiAgICAgICAgICAgICAgRFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFtkLCBwXVxuICAgICAgICAgICksIFogPSBLKFxuICAgICAgICAgICAgaHQoXG4gICAgICAgICAgICAgIHUsXG4gICAgICAgICAgICAgIEcgPyBbYywgTF0gOiBbTCwgbF0sXG4gICAgICAgICAgICAgIERcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBbZCwgcF1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB1bihcbiAgICAgICAgICAgIGUsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgTixcbiAgICAgICAgICAgIFosXG4gICAgICAgICAgICBvLFxuICAgICAgICAgICAgYGNsaXAke0l9Ym91bmRzJHt6fWAsXG4gICAgICAgICAgICBcImd1aWRlbGluZVwiLFxuICAgICAgICAgICAgXCJib3VuZHNcIixcbiAgICAgICAgICAgIFwiYm9sZFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSksIFsuLi5QLCAuLi5fXTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb24odCwgZSkge1xuICAgIHJldHVybiBlLmlucHV0RXZlbnQgJiYgKGUuaW5wdXRFdmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIikuaW5kZXhPZihcImNsaXBcIikgPiAtMTtcbiAgfSxcbiAgZHJhZ1N0YXJ0KHQsIGUpIHtcbiAgICBjb25zdCBuID0gdC5wcm9wcywgeyBkcmFnV2l0aENsaXA6IHIgPSAhMCB9ID0gbjtcbiAgICByZXR1cm4gciA/ICExIDogdGhpcy5kcmFnQ29udHJvbFN0YXJ0KHQsIGUpO1xuICB9LFxuICBkcmFnKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbCh0LCB7IC4uLmUsIGlzRHJhZ1RhcmdldDogITAgfSk7XG4gIH0sXG4gIGRyYWdFbmQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdDb250cm9sRW5kKHQsIGUpO1xuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0KHQsIGUpIHtcbiAgICBjb25zdCBuID0gdC5zdGF0ZSwgeyBkZWZhdWx0Q2xpcFBhdGg6IHIsIGN1c3RvbUNsaXBQYXRoOiBzIH0gPSB0LnByb3BzLCB7IHRhcmdldDogbywgd2lkdGg6IGksIGhlaWdodDogYSB9ID0gbiwgYyA9IGUuaW5wdXRFdmVudCA/IGUuaW5wdXRFdmVudC50YXJnZXQgOiBudWxsLCBsID0gYyAmJiBjLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIsIHUgPSBlLmRhdGFzLCBmID0geG8oXG4gICAgICBvLFxuICAgICAgaSxcbiAgICAgIGEsXG4gICAgICByIHx8IFwiaW5zZXRcIixcbiAgICAgIHNcbiAgICApO1xuICAgIGlmICghZilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCB7IGNsaXBUZXh0OiBkLCB0eXBlOiBwLCBwb3NlczogZyB9ID0gZjtcbiAgICByZXR1cm4gaihcbiAgICAgIHQsXG4gICAgICBcIm9uQ2xpcFN0YXJ0XCIsXG4gICAgICBldCh0LCBlLCB7XG4gICAgICAgIGNsaXBUeXBlOiBwLFxuICAgICAgICBjbGlwU3R5bGU6IGQsXG4gICAgICAgIHBvc2VzOiBnLm1hcCgodikgPT4gdi5wb3MpXG4gICAgICB9KVxuICAgICkgPT09ICExID8gKHUuaXNDbGlwU3RhcnQgPSAhMSwgITEpIDogKHUuaXNDb250cm9sID0gbCAmJiBsLmluZGV4T2YoXCJjbGlwLWNvbnRyb2xcIikgPiAtMSwgdS5pc0xpbmUgPSBsLmluZGV4T2YoXCJjbGlwLWxpbmVcIikgPiAtMSwgdS5pc0FyZWEgPSBsLmluZGV4T2YoXCJjbGlwLWFyZWFcIikgPiAtMSB8fCBsLmluZGV4T2YoXCJjbGlwLWVsbGlwc2VcIikgPiAtMSwgdS5jbGlwSW5kZXggPSBjID8gcGFyc2VJbnQoYy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNsaXAtaW5kZXhcIiksIDEwKSA6IC0xLCB1LmNsaXBQYXRoID0gZiwgdS5pc0NsaXBTdGFydCA9ICEwLCBuLmNsaXBQYXRoU3RhdGUgPSBkLCBSZSh0LCBlKSwgITApO1xuICB9LFxuICBkcmFnQ29udHJvbCh0LCBlKSB7XG4gICAgY29uc3QgeyBkYXRhczogbiwgb3JpZ2luYWxEYXRhczogciwgaXNEcmFnVGFyZ2V0OiBzIH0gPSBlO1xuICAgIGlmICghbi5pc0NsaXBTdGFydClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCB7IGlzQ29udHJvbDogbywgaXNMaW5lOiBpLCBpc0FyZWE6IGEsIGNsaXBJbmRleDogYywgY2xpcFBhdGg6IGwgfSA9IG47XG4gICAgaWYgKCFsKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHUgPSBEZSh0LnByb3BzLCBcImNsaXBwYWJsZVwiKSwgeyBrZWVwUmF0aW86IGYgfSA9IHU7XG4gICAgbGV0IGQgPSAwLCBwID0gMDtcbiAgICBjb25zdCBnID0gci5kcmFnZ2FibGUsIGggPSBRdChlKTtcbiAgICBzICYmIGcgPyBbZCwgcF0gPSBnLnByZXZCZWZvcmVEaXN0IDogW2QsIHBdID0gaDtcbiAgICBjb25zdCB2ID0gW2QsIHBdLCBtID0gdC5zdGF0ZSwgeyB3aWR0aDogUywgaGVpZ2h0OiB4IH0gPSBtLCBDID0gIWEgJiYgIW8gJiYgIWksIHsgdHlwZTogRSwgcG9zZXM6IEQsIHNwbGl0dGVyOiBSIH0gPSBsLCB5ID0gRC5tYXAoKEYpID0+IEYucG9zKTtcbiAgICBDICYmIChkID0gLWQsIHAgPSAtcCk7XG4gICAgY29uc3QgTSA9ICFvIHx8IERbY10uZGlyZWN0aW9uID09PSBcIm5lc3dcIiwgUCA9IEUgPT09IFwiaW5zZXRcIiB8fCBFID09PSBcInJlY3RcIjtcbiAgICBsZXQgXyA9IEQubWFwKCgpID0+IFswLCAwXSksIE8gPSB1LmRlZmF1bHRDbGlwUGF0aCA9PT0gXCJpbnNldFwiID8gITEgOiBmO1xuICAgIGlmIChvICYmICFNKSB7XG4gICAgICBjb25zdCB7IGhvcml6b250YWw6IEYsIHZlcnRpY2FsOiBIIH0gPSBEW2NdLCBudCA9IFtkICogQihGKSwgcCAqIEIoSCldO1xuICAgICAgXyA9IFp1KFxuICAgICAgICBELFxuICAgICAgICBjLFxuICAgICAgICBudCxcbiAgICAgICAgUCxcbiAgICAgICAgT1xuICAgICAgKTtcbiAgICB9IGVsc2UgTSAmJiAoXyA9IHkubWFwKCgpID0+IFtkLCBwXSkpO1xuICAgIGNvbnN0IFQgPSB5Lm1hcCgoRiwgSCkgPT4gYXQoRiwgX1tIXSkpLCB3ID0gWy4uLlRdO1xuICAgIG0uc25hcEJvdW5kSW5mb3MgPSBudWxsO1xuICAgIGNvbnN0IGsgPSBsLnR5cGUgPT09IFwiY2lyY2xlXCIsIEkgPSBsLnR5cGUgPT09IFwiZWxsaXBzZVwiO1xuICAgIGlmIChrIHx8IEkpIHtcbiAgICAgIGNvbnN0IEYgPSBZdChUKSwgSCA9IEIoRi5ib3R0b20gLSBGLnRvcCksIG50ID0gQihJID8gRi5yaWdodCAtIEYubGVmdCA6IEgpLCBsdCA9IFRbMF1bMV0gKyBILCB2dCA9IFRbMF1bMF0gLSBudCwgc3QgPSBUWzBdWzBdICsgbnQ7XG4gICAgICBrICYmICh3LnB1c2goW3N0LCBGLmJvdHRvbV0pLCBfLnB1c2goWzEsIDBdKSksIHcucHVzaChbRi5sZWZ0LCBsdF0pLCBfLnB1c2goWzAsIDFdKSwgdy5wdXNoKFt2dCwgRi5ib3R0b21dKSwgXy5wdXNoKFsxLCAwXSk7XG4gICAgfVxuICAgIGNvbnN0ICQgPSBPaShcbiAgICAgICh1LmNsaXBIb3Jpem9udGFsR3VpZGVsaW5lcyB8fCBbXSkubWFwKFxuICAgICAgICAoRikgPT4gZnQoYCR7Rn1gLCB4KVxuICAgICAgKSxcbiAgICAgICh1LmNsaXBWZXJ0aWNhbEd1aWRlbGluZXMgfHwgW10pLm1hcChcbiAgICAgICAgKEYpID0+IGZ0KGAke0Z9YCwgUylcbiAgICAgICksXG4gICAgICBTLFxuICAgICAgeFxuICAgICk7XG4gICAgbGV0IEcgPSBbXSwgTCA9IFtdO1xuICAgIGlmIChrIHx8IEkpXG4gICAgICBHID0gW3dbNF1bMF0sIHdbMl1bMF1dLCBMID0gW3dbMV1bMV0sIHdbM11bMV1dO1xuICAgIGVsc2UgaWYgKFApIHtcbiAgICAgIGNvbnN0IEYgPSBbXG4gICAgICAgIHdbMF0sXG4gICAgICAgIHdbMl0sXG4gICAgICAgIHdbNF0sXG4gICAgICAgIHdbNl1cbiAgICAgIF0sIEggPSBbX1swXSwgX1syXSwgX1s0XSwgX1s2XV07XG4gICAgICBHID0gRi5maWx0ZXIoKG50LCBsdCkgPT4gSFtsdF1bMF0pLm1hcCgobnQpID0+IG50WzBdKSwgTCA9IEYuZmlsdGVyKChudCwgbHQpID0+IEhbbHRdWzFdKS5tYXAoKG50KSA9PiBudFsxXSk7XG4gICAgfSBlbHNlXG4gICAgICBHID0gdy5maWx0ZXIoKEYsIEgpID0+IF9bSF1bMF0pLm1hcCgoRikgPT4gRlswXSksIEwgPSB3LmZpbHRlcigoRiwgSCkgPT4gX1tIXVsxXSkubWFwKChGKSA9PiBGWzFdKTtcbiAgICBjb25zdCB6ID0gWzAsIDBdLCB7IGhvcml6b250YWw6IE4sIHZlcnRpY2FsOiBaIH0gPSBRcyhcbiAgICAgICQsXG4gICAgICB1LmNsaXBUYXJnZXRCb3VuZHMgJiYge1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiBTLFxuICAgICAgICBib3R0b206IHhcbiAgICAgIH0sXG4gICAgICBHLFxuICAgICAgTCxcbiAgICAgIDUsXG4gICAgICA1XG4gICAgKTtcbiAgICBsZXQgWSA9IE4ub2Zmc2V0LCBXID0gWi5vZmZzZXQ7XG4gICAgaWYgKE4uaXNCb3VuZCAmJiAoelsxXSArPSBZKSwgWi5pc0JvdW5kICYmICh6WzBdICs9IFcpLCAoSSB8fCBrKSAmJiBfWzBdWzBdID09PSAwICYmIF9bMF1bMV0gPT09IDApIHtcbiAgICAgIGNvbnN0IEYgPSBZdChUKTtcbiAgICAgIGxldCBIID0gRi5ib3R0b20gLSBGLnRvcCwgbnQgPSBJID8gRi5yaWdodCAtIEYubGVmdCA6IEg7XG4gICAgICBjb25zdCBsdCA9IFouaXNCb3VuZCA/IEIoVykgOiBaLnNuYXBJbmRleCA9PT0gMCA/IC1XIDogVywgdnQgPSBOLmlzQm91bmQgPyBCKFkpIDogTi5zbmFwSW5kZXggPT09IDAgPyAtWSA6IFk7XG4gICAgICBudCAtPSBsdCwgSCAtPSB2dCwgayAmJiAoSCA9IEVpKFosIE4pID4gMCA/IEggOiBudCwgbnQgPSBIKTtcbiAgICAgIGNvbnN0IHN0ID0gd1swXTtcbiAgICAgIHdbMV1bMV0gPSBzdFsxXSAtIEgsIHdbMl1bMF0gPSBzdFswXSArIG50LCB3WzNdWzFdID0gc3RbMV0gKyBILCB3WzRdWzBdID0gc3RbMF0gLSBudDtcbiAgICB9IGVsc2UgaWYgKFAgJiYgTyAmJiBvKSB7XG4gICAgICBjb25zdCBbRiwgSF0gPSBlYShEKSwgbnQgPSBGICYmIEggPyBGIC8gSCA6IDAsIHZ0ID0gRFtjXS5kaXJlY3Rpb24gfHwgXCJcIjtcbiAgICAgIGxldCBzdCA9IHdbMV1bMV0sIEZ0ID0gd1s1XVsxXSwgTHQgPSB3WzddWzBdLCB1dCA9IHdbM11bMF07XG4gICAgICBCKFkpIDw9IEIoVykgPyBZID0gd3QoWSkgKiBCKFcpIC8gbnQgOiBXID0gd3QoVykgKiBCKFkpICogbnQsIHZ0LmluZGV4T2YoXCJ3XCIpID4gLTEgPyBMdCAtPSBXIDogdnQuaW5kZXhPZihcImVcIikgPiAtMSA/IHV0IC09IFcgOiAoTHQgKz0gVyAvIDIsIHV0IC09IFcgLyAyKSwgdnQuaW5kZXhPZihcIm5cIikgPiAtMSA/IHN0IC09IFkgOiB2dC5pbmRleE9mKFwic1wiKSA+IC0xID8gRnQgLT0gWSA6IChzdCArPSBZIC8gMiwgRnQgLT0gWSAvIDIpO1xuICAgICAgY29uc3QgU3QgPSBWbihzdCwgdXQsIEZ0LCBMdCk7XG4gICAgICB3LmZvckVhY2goKEt0LCBkZSkgPT4ge1xuICAgICAgICBbS3RbMF0sIEt0WzFdXSA9IFN0W2RlXS5wb3M7XG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICAgIHcuZm9yRWFjaCgoRiwgSCkgPT4ge1xuICAgICAgICBjb25zdCBudCA9IF9bSF07XG4gICAgICAgIG50WzBdICYmIChGWzBdIC09IFcpLCBudFsxXSAmJiAoRlsxXSAtPSBZKTtcbiAgICAgIH0pO1xuICAgIGNvbnN0IEogPSB5cyh0LCBsLCBUKSwgcSA9IGAke0V9KCR7Si5qb2luKFIpfSAke2wucmFkaXVzLmxlbmd0aCA/IFwicm91bmQgXCIgKyBsLnJhZGl1cy5qb2luKFwiIFwiKSA6IFwiXCJ9KWA7XG4gICAgaWYgKG0uY2xpcFBhdGhTdGF0ZSA9IHEsIGsgfHwgSSlcbiAgICAgIEcgPSBbd1s0XVswXSwgd1syXVswXV0sIEwgPSBbd1sxXVsxXSwgd1szXVsxXV07XG4gICAgZWxzZSBpZiAoUCkge1xuICAgICAgY29uc3QgRiA9IFtcbiAgICAgICAgd1swXSxcbiAgICAgICAgd1syXSxcbiAgICAgICAgd1s0XSxcbiAgICAgICAgd1s2XVxuICAgICAgXTtcbiAgICAgIEcgPSBGLm1hcCgoSCkgPT4gSFswXSksIEwgPSBGLm1hcCgoSCkgPT4gSFsxXSk7XG4gICAgfSBlbHNlXG4gICAgICBHID0gdy5tYXAoKEYpID0+IEZbMF0pLCBMID0gdy5tYXAoKEYpID0+IEZbMV0pO1xuICAgIGlmIChtLnNuYXBCb3VuZEluZm9zID0gUXMoXG4gICAgICAkLFxuICAgICAgdS5jbGlwVGFyZ2V0Qm91bmRzICYmIHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogUyxcbiAgICAgICAgYm90dG9tOiB4XG4gICAgICB9LFxuICAgICAgRyxcbiAgICAgIEwsXG4gICAgICAxLFxuICAgICAgMVxuICAgICksIGcpIHtcbiAgICAgIGNvbnN0IHsgaXMzZDogRiwgYWxsTWF0cml4OiBIIH0gPSBtLCBudCA9IEYgPyA0IDogMztcbiAgICAgIGxldCBsdCA9IHo7XG4gICAgICBzICYmIChsdCA9IFtcbiAgICAgICAgdlswXSArIHpbMF0gLSBoWzBdLFxuICAgICAgICB2WzFdICsgelsxXSAtIGhbMV1cbiAgICAgIF0pLCBnLmRlbHRhT2Zmc2V0ID0gZHQoXG4gICAgICAgIEgsXG4gICAgICAgIFtsdFswXSwgbHRbMV0sIDAsIDBdLFxuICAgICAgICBudFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGooXG4gICAgICB0LFxuICAgICAgXCJvbkNsaXBcIixcbiAgICAgIGV0KHQsIGUsIHtcbiAgICAgICAgY2xpcEV2ZW50VHlwZTogXCJjaGFuZ2VkXCIsXG4gICAgICAgIGNsaXBUeXBlOiBFLFxuICAgICAgICBwb3NlczogVCxcbiAgICAgICAgY2xpcFN0eWxlOiBxLFxuICAgICAgICBjbGlwU3R5bGVzOiBKLFxuICAgICAgICBkaXN0WDogZCxcbiAgICAgICAgZGlzdFk6IHAsXG4gICAgICAgIC4uLkl0KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIFtFID09PSBcInJlY3RcIiA/IFwiY2xpcFwiIDogXCJjbGlwUGF0aFwiXTogcVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZVxuICAgICAgICApXG4gICAgICB9KVxuICAgICksICEwO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZCh0LCBlKSB7XG4gICAgdGhpcy51bnNldCh0KTtcbiAgICBjb25zdCB7IGlzRHJhZzogbiwgZGF0YXM6IHIsIGlzRG91YmxlOiBzIH0gPSBlLCB7IGlzTGluZTogbywgaXNDbGlwU3RhcnQ6IGksIGlzQ29udHJvbDogYSB9ID0gcjtcbiAgICByZXR1cm4gaSA/IChqKFxuICAgICAgdCxcbiAgICAgIFwib25DbGlwRW5kXCIsXG4gICAgICAkdCh0LCBlLCB7fSlcbiAgICApLCBzICYmIChhID8gKGNvbnNvbGUubG9nKFwicmVtb3ZlQ2xpcFBhdGhcIiksIFF1KHQsIGUpKSA6IG8gJiYgKGNvbnNvbGUubG9nKFwiYWRkQ2xpcFBhdGhcIiksIEp1KHQsIGUpKSksIHMgfHwgbikgOiAhMTtcbiAgfSxcbiAgdW5zZXQodCkge1xuICAgIHQuc3RhdGUuY2xpcFBhdGhTdGF0ZSA9IFwiXCIsIHQuc3RhdGUuc25hcEJvdW5kSW5mb3MgPSBudWxsO1xuICB9XG59LCBlZiA9IHtcbiAgbmFtZTogXCJvcmlnaW5EcmFnZ2FibGVcIixcbiAgcHJvcHM6IFtcbiAgICBcIm9yaWdpbkRyYWdnYWJsZVwiLFxuICAgIFwib3JpZ2luUmVsYXRpdmVcIlxuICBdLFxuICBldmVudHM6IFtcbiAgICBcImRyYWdPcmlnaW5TdGFydFwiLFxuICAgIFwiZHJhZ09yaWdpblwiLFxuICAgIFwiZHJhZ09yaWdpbkVuZFwiXG4gIF0sXG4gIGNzczogW1xuICAgIGA6aG9zdFtkYXRhLWFibGUtb3JpZ2luZHJhZ2dhYmxlXSAuY29udHJvbC5vcmlnaW4ge1xucG9pbnRlci1ldmVudHM6IGF1dG87XG59YFxuICBdLFxuICBkcmFnQ29udHJvbENvbmRpdGlvbih0LCBlKSB7XG4gICAgcmV0dXJuIGUuaXNSZXF1ZXN0ID8gZS5yZXF1ZXN0QWJsZSA9PT0gXCJvcmlnaW5EcmFnZ2FibGVcIiA6IGJ0KGUuaW5wdXRFdmVudC50YXJnZXQsIFUoXCJvcmlnaW5cIikpO1xuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0KHQsIGUpIHtcbiAgICBjb25zdCB7IGRhdGFzOiBuIH0gPSBlO1xuICAgIFJlKHQsIGUpO1xuICAgIGNvbnN0IHIgPSBldCh0LCBlLCB7XG4gICAgICBkcmFnU3RhcnQ6IE90LmRyYWdTdGFydChcbiAgICAgICAgdCxcbiAgICAgICAgbmV3IEZlKCkuZHJhZ1N0YXJ0KFswLCAwXSwgZSlcbiAgICAgIClcbiAgICB9KSwgcyA9IGoodCwgXCJvbkRyYWdPcmlnaW5TdGFydFwiLCByKTtcbiAgICByZXR1cm4gbi5zdGFydE9yaWdpbiA9IHQuc3RhdGUudHJhbnNmb3JtT3JpZ2luLCBuLnN0YXJ0VGFyZ2V0T3JpZ2luID0gdC5zdGF0ZS50YXJnZXRPcmlnaW4sIG4ucHJldk9yaWdpbiA9IFswLCAwXSwgbi5pc0RyYWdPcmlnaW4gPSAhMCwgcyA9PT0gITEgPyAobi5pc0RyYWdPcmlnaW4gPSAhMSwgITEpIDogcjtcbiAgfSxcbiAgZHJhZ0NvbnRyb2wodCwgZSkge1xuICAgIGNvbnN0IHsgZGF0YXM6IG4sIGlzUGluY2g6IHIsIGlzUmVxdWVzdDogcyB9ID0gZTtcbiAgICBpZiAoIW4uaXNEcmFnT3JpZ2luKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IFtvLCBpXSA9IFF0KGUpLCBhID0gdC5zdGF0ZSwge1xuICAgICAgd2lkdGg6IGMsXG4gICAgICBoZWlnaHQ6IGwsXG4gICAgICBvZmZzZXRNYXRyaXg6IHUsXG4gICAgICB0YXJnZXRNYXRyaXg6IGYsXG4gICAgICBpczNkOiBkXG4gICAgfSA9IGEsIHtcbiAgICAgIG9yaWdpblJlbGF0aXZlOiBwID0gITBcbiAgICB9ID0gdC5wcm9wcywgZyA9IGQgPyA0IDogMztcbiAgICBsZXQgaCA9IFtvLCBpXTtcbiAgICBpZiAocykge1xuICAgICAgY29uc3QgUCA9IGUuZGlzdE9yaWdpbjtcbiAgICAgIChQWzBdIHx8IFBbMV0pICYmIChoID0gUCk7XG4gICAgfVxuICAgIGNvbnN0IHYgPSBhdChuLnN0YXJ0T3JpZ2luLCBoKSwgbSA9IGF0KG4uc3RhcnRUYXJnZXRPcmlnaW4sIGgpLCBTID0gSyhoLCBuLnByZXZPcmlnaW4pLCB4ID0gbW4oXG4gICAgICB1LFxuICAgICAgZixcbiAgICAgIHYsXG4gICAgICBnXG4gICAgKSwgQyA9IHQuZ2V0UmVjdCgpLCBFID0gWXQoTWUoeCwgYywgbCwgZykpLCBEID0gW1xuICAgICAgQy5sZWZ0IC0gRS5sZWZ0LFxuICAgICAgQy50b3AgLSBFLnRvcFxuICAgIF07XG4gICAgbi5wcmV2T3JpZ2luID0gaDtcbiAgICBjb25zdCBSID0gW1xuICAgICAgWHQobVswXSwgYywgcCksXG4gICAgICBYdChtWzFdLCBsLCBwKVxuICAgIF0uam9pbihcIiBcIiksIHkgPSBPdC5kcmFnKFxuICAgICAgdCxcbiAgICAgIHZuKGUsIHQuc3RhdGUsIEQsICEhcilcbiAgICApLCBNID0gZXQodCwgZSwge1xuICAgICAgd2lkdGg6IGMsXG4gICAgICBoZWlnaHQ6IGwsXG4gICAgICBvcmlnaW46IHYsXG4gICAgICBkaXN0OiBoLFxuICAgICAgZGVsdGE6IFMsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IFIsXG4gICAgICBkcmFnOiB5LFxuICAgICAgLi4uSXQoe1xuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFIsXG4gICAgICAgIHRyYW5zZm9ybTogeS50cmFuc2Zvcm1cbiAgICAgIH0sIGUpLFxuICAgICAgYWZ0ZXJUcmFuc2Zvcm06IHkudHJhbnNmb3JtXG4gICAgfSk7XG4gICAgcmV0dXJuIGoodCwgXCJvbkRyYWdPcmlnaW5cIiwgTSksIE07XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kKHQsIGUpIHtcbiAgICBjb25zdCB7IGRhdGFzOiBuIH0gPSBlO1xuICAgIHJldHVybiBuLmlzRHJhZ09yaWdpbiA/IChqKFxuICAgICAgdCxcbiAgICAgIFwib25EcmFnT3JpZ2luRW5kXCIsXG4gICAgICAkdCh0LCBlLCB7fSlcbiAgICApLCAhMCkgOiAhMTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbih0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2xDb25kaXRpb24odCwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xTdGFydCh0LCBlKSB7XG4gICAgcmV0dXJuICEhdGhpcy5kcmFnQ29udHJvbFN0YXJ0KHQsIGUpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sKHQsIGUpIHtcbiAgICBjb25zdCBuID0gdGhpcy5kcmFnQ29udHJvbCh0LCBlKTtcbiAgICByZXR1cm4gbiA/ICh0LnRyYW5zZm9ybU9yaWdpbiA9IG4udHJhbnNmb3JtT3JpZ2luLCAhMCkgOiAhMTtcbiAgfSxcbiAgLyoqXG4gICAgICAqIEBtZXRob2QgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlI3JlcXVlc3RcbiAgICAgICogQHBhcmFtIHtvYmplY3R9IGUgLSB0aGUgT3JpZ2luRHJhZ2dhYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcbiAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLnhdIC0geCBwb3NpdGlvblxuICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2UueV0gLSB5IHBvc2l0aW9uXG4gICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVhdIC0geCBudW1iZXIgdG8gbW92ZVxuICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2UuZGVsdGFZXSAtIHkgbnVtYmVyIHRvIG1vdmVcbiAgICAgICogQHBhcmFtIHthcnJheX0gW2UuZGVsdGFPcmlnaW5dIC0gbGVmdCwgdG9wIG51bWJlciB0byBtb3ZlIHRyYW5zZm9ybS1vcmlnaW5cbiAgICAgICogQHBhcmFtIHthcnJheX0gW2Uub3JpZ2luXSAtIHRyYW5zZm9ybS1vcmlnaW4gcG9zaXRpb25cbiAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmlzSW5zdGFudF0gLSBXaGV0aGVyIHRvIGV4ZWN1dGUgdGhlIHJlcXVlc3QgaW5zdGFudGx5XG4gICAgICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICAgICAqIEBleGFtcGxlXG4gIFxuICAgICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXG4gICAgICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxuICAgICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9LCB0cnVlKTtcbiAgICAgICogLy8gVXNlIEFic29sdXRlIFZhbHVlXG4gICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9LCB0cnVlKTtcbiAgICAgICogLy8gVXNlIFRyYW5zZm9ybSBWYWx1ZVxuICAgICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgZGVsdGFPcmlnaW46IFsxMCwgMF0gfSwgdHJ1ZSk7XG4gICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyBvcmlnaW46IFsxMDAsIDBdIH0sIHRydWUpO1xuICAgICAgKiAvLyByZXF1ZXN0U3RhcnRcbiAgICAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiKTtcbiAgICAgICpcbiAgICAgICogLy8gcmVxdWVzdFxuICAgICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcbiAgICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgICAgICogLy8gVXNlIEFic29sdXRlIFZhbHVlXG4gICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9KTtcbiAgICAgICogbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiLCB7IHg6IDIyMCwgeTogMTAwIH0pO1xuICAgICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgeDogMjQwLCB5OiAxMDAgfSk7XG4gICAgICAqXG4gICAgICAqIC8vIHJlcXVlc3RFbmRcbiAgICAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgICAgICovXG4gIHJlcXVlc3QodCkge1xuICAgIGNvbnN0IGUgPSB7fSwgbiA9IHQuZ2V0UmVjdCgpO1xuICAgIGxldCByID0gMCwgcyA9IDA7XG4gICAgY29uc3QgbyA9IG4udHJhbnNmb3JtT3JpZ2luLCBpID0gWzAsIDBdO1xuICAgIHJldHVybiB7XG4gICAgICBpc0NvbnRyb2w6ICEwLFxuICAgICAgcmVxdWVzdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4geyBkYXRhczogZSB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3QoYSkge1xuICAgICAgICByZXR1cm4gXCJkZWx0YU9yaWdpblwiIGluIGEgPyAoaVswXSArPSBhLmRlbHRhT3JpZ2luWzBdLCBpWzFdICs9IGEuZGVsdGFPcmlnaW5bMV0pIDogXCJvcmlnaW5cIiBpbiBhID8gKGlbMF0gPSBhLm9yaWdpblswXSAtIG9bMF0sIGlbMV0gPSBhLm9yaWdpblsxXSAtIG9bMV0pIDogKFwieFwiIGluIGEgPyByID0gYS54IC0gbi5sZWZ0IDogXCJkZWx0YVhcIiBpbiBhICYmIChyICs9IGEuZGVsdGFYKSwgXCJ5XCIgaW4gYSA/IHMgPSBhLnkgLSBuLnRvcCA6IFwiZGVsdGFZXCIgaW4gYSAmJiAocyArPSBhLmRlbHRhWSkpLCB7IGRhdGFzOiBlLCBkaXN0WDogciwgZGlzdFk6IHMsIGRpc3RPcmlnaW46IGkgfTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0RW5kKCkge1xuICAgICAgICByZXR1cm4geyBkYXRhczogZSwgaXNEcmFnOiAhMCB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBuZih0LCBlLCBuLCByKSB7XG4gIGNvbnN0IHMgPSB0LmZpbHRlcigoeyB2aXJ0dWFsOiBjLCBob3Jpem9udGFsOiBsIH0pID0+IGwgJiYgIWMpLmxlbmd0aCwgbyA9IHQuZmlsdGVyKCh7IHZpcnR1YWw6IGMsIHZlcnRpY2FsOiBsIH0pID0+IGwgJiYgIWMpLmxlbmd0aDtcbiAgbGV0IGkgPSAtMTtcbiAgaWYgKGUgPT09IDAgJiYgKHMgPT09IDAgPyBpID0gMCA6IHMgPT09IDEgJiYgKGkgPSAxKSksIGUgPT09IDIgJiYgKHMgPD0gMiA/IGkgPSAyIDogcyA8PSAzICYmIChpID0gMykpLCBlID09PSAzICYmIChvID09PSAwID8gaSA9IDQgOiBvIDwgNCAmJiAoaSA9IDcpKSwgZSA9PT0gMSAmJiAobyA8PSAxID8gaSA9IDUgOiBvIDw9IDIgJiYgKGkgPSA2KSksIGkgPT09IC0xIHx8ICF0W2ldLnZpcnR1YWwpXG4gICAgcmV0dXJuO1xuICBjb25zdCBhID0gdFtpXTtcbiAgcmYodCwgaSksIGkgPCA0ID8gYS5wb3NbMF0gPSBuIDogYS5wb3NbMV0gPSByO1xufVxuZnVuY3Rpb24gcmYodCwgZSkge1xuICBlIDwgNCA/IHQuc2xpY2UoMCwgZSArIDEpLmZvckVhY2goKG4pID0+IHtcbiAgICBuLnZpcnR1YWwgPSAhMTtcbiAgfSkgOiAodFswXS52aXJ0dWFsICYmICh0WzBdLnZpcnR1YWwgPSAhMSksIHQuc2xpY2UoNCwgZSArIDEpLmZvckVhY2goKG4pID0+IHtcbiAgICBuLnZpcnR1YWwgPSAhMTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gc2YodCwgZSkge1xuICBlIDwgNCA/IHQuc2xpY2UoZSwgNCkuZm9yRWFjaCgobikgPT4ge1xuICAgIG4udmlydHVhbCA9ICEwO1xuICB9KSA6IHQuc2xpY2UoZSkuZm9yRWFjaCgobikgPT4ge1xuICAgIG4udmlydHVhbCA9ICEwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFNvKHQsIGUsIG4sIHIgPSBbMCwgMF0sIHMpIHtcbiAgbGV0IG8gPSBbXTtcbiAgcmV0dXJuICF0IHx8IHQgPT09IFwiMHB4XCIgPyBvID0gW10gOiBvID0gY2UodCksIEZ1KG8sIGUsIG4sIDAsIDAsIHIsIHMpO1xufVxuZnVuY3Rpb24gRW8odCwgZSwgbiwgciwgcykge1xuICBjb25zdCBvID0gdC5zdGF0ZSwge1xuICAgIHdpZHRoOiBpLFxuICAgIGhlaWdodDogYVxuICB9ID0gbywge1xuICAgIHJhd3M6IGMsXG4gICAgc3R5bGVzOiBsLFxuICAgIHJhZGl1c1Bvc2VzOiB1XG4gIH0gPSBEcyhcbiAgICBzLFxuICAgIHQucHJvcHMucm91bmRSZWxhdGl2ZSxcbiAgICBpLFxuICAgIGFcbiAgKSwge1xuICAgIGhvcml6b250YWxzOiBmLFxuICAgIHZlcnRpY2FsczogZFxuICB9ID0gV3UodSwgYyksIHAgPSBsLmpvaW4oXCIgXCIpO1xuICBvLmJvcmRlclJhZGl1c1N0YXRlID0gcDtcbiAgY29uc3QgZyA9IGV0KHQsIGUsIHtcbiAgICBob3Jpem9udGFsczogZixcbiAgICB2ZXJ0aWNhbHM6IGQsXG4gICAgYm9yZGVyUmFkaXVzOiBwLFxuICAgIHdpZHRoOiBpLFxuICAgIGhlaWdodDogYSxcbiAgICBkZWx0YTogcixcbiAgICBkaXN0OiBuLFxuICAgIC4uLkl0KHtcbiAgICAgIGJvcmRlclJhZGl1czogcFxuICAgIH0sIGUpXG4gIH0pO1xuICByZXR1cm4gaih0LCBcIm9uUm91bmRcIiwgZyksIGc7XG59XG5mdW5jdGlvbiBDbyh0KSB7XG4gIHZhciByO1xuICBjb25zdCB7XG4gICAgc3R5bGU6IGVcbiAgfSA9IHQuZ2V0U3RhdGUoKTtcbiAgbGV0IG4gPSBlLmJvcmRlclJhZGl1cyB8fCBcIlwiO1xuICBpZiAoIW4gJiYgdC5wcm9wcy5ncm91cGFibGUpIHtcbiAgICBjb25zdCBzID0gdC5tb3ZlYWJsZXNbMF0sIG8gPSB0LmdldFRhcmdldHMoKVswXTtcbiAgICBvICYmICgocyA9PSBudWxsID8gdm9pZCAwIDogcy5wcm9wcy50YXJnZXQpID09PSBvID8gKG4gPSAoKHIgPSB0Lm1vdmVhYmxlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuc3RhdGUuc3R5bGUuYm9yZGVyUmFkaXVzKSA/PyBcIlwiLCBlLmJvcmRlclJhZGl1cyA9IG4pIDogKG4gPSB2cyhvKS5ib3JkZXJSYWRpdXMsIGUuYm9yZGVyUmFkaXVzID0gbikpO1xuICB9XG4gIHJldHVybiBuO1xufVxuY29uc3Qgb2YgPSB7XG4gIG5hbWU6IFwicm91bmRhYmxlXCIsXG4gIHByb3BzOiBbXG4gICAgXCJyb3VuZGFibGVcIixcbiAgICBcInJvdW5kUmVsYXRpdmVcIixcbiAgICBcIm1pblJvdW5kQ29udHJvbHNcIixcbiAgICBcIm1heFJvdW5kQ29udHJvbHNcIixcbiAgICBcInJvdW5kQ2xpY2thYmxlXCIsXG4gICAgXCJyb3VuZFBhZGRpbmdcIixcbiAgICBcImlzRGlzcGxheVNoYWRvd1JvdW5kQ29udHJvbHNcIlxuICBdLFxuICBldmVudHM6IFtcbiAgICBcInJvdW5kU3RhcnRcIixcbiAgICBcInJvdW5kXCIsXG4gICAgXCJyb3VuZEVuZFwiLFxuICAgIFwicm91bmRHcm91cFN0YXJ0XCIsXG4gICAgXCJyb3VuZEdyb3VwXCIsXG4gICAgXCJyb3VuZEdyb3VwRW5kXCJcbiAgXSxcbiAgY3NzOiBbXG4gICAgYC5jb250cm9sLmJvcmRlci1yYWRpdXMge1xuYmFja2dyb3VuZDogI2Q2NjtcbmN1cnNvcjogcG9pbnRlcjtcbnotaW5kZXg6IDM7XG59YCxcbiAgICBgLmNvbnRyb2wuYm9yZGVyLXJhZGl1cy52ZXJ0aWNhbCB7XG5iYWNrZ3JvdW5kOiAjZDZkO1xuei1pbmRleDogMjtcbn1gLFxuICAgIGAuY29udHJvbC5ib3JkZXItcmFkaXVzLnZpcnR1YWwge1xub3BhY2l0eTogMC41O1xuei1pbmRleDogMTtcbn1gLFxuICAgIGA6aG9zdC5yb3VuZC1saW5lLWNsaWNrYWJsZSAubGluZS5kaXJlY3Rpb24ge1xuY3Vyc29yOiBwb2ludGVyO1xufWBcbiAgXSxcbiAgY2xhc3NOYW1lKHQpIHtcbiAgICBjb25zdCBlID0gdC5wcm9wcy5yb3VuZENsaWNrYWJsZTtcbiAgICByZXR1cm4gZSA9PT0gITAgfHwgZSA9PT0gXCJsaW5lXCIgPyBVKFwicm91bmQtbGluZS1jbGlja2FibGVcIikgOiBcIlwiO1xuICB9LFxuICByZXF1ZXN0U3R5bGUoKSB7XG4gICAgcmV0dXJuIFtcImJvcmRlclJhZGl1c1wiXTtcbiAgfSxcbiAgcmVxdWVzdENoaWxkU3R5bGUoKSB7XG4gICAgcmV0dXJuIFtcImJvcmRlclJhZGl1c1wiXTtcbiAgfSxcbiAgcmVuZGVyKHQsIGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQ6IG4sXG4gICAgICB3aWR0aDogcixcbiAgICAgIGhlaWdodDogcyxcbiAgICAgIGFsbE1hdHJpeDogbyxcbiAgICAgIGlzM2Q6IGksXG4gICAgICBsZWZ0OiBhLFxuICAgICAgdG9wOiBjLFxuICAgICAgYm9yZGVyUmFkaXVzU3RhdGU6IGxcbiAgICB9ID0gdC5nZXRTdGF0ZSgpLCB7XG4gICAgICBtaW5Sb3VuZENvbnRyb2xzOiB1ID0gWzAsIDBdLFxuICAgICAgbWF4Um91bmRDb250cm9sczogZiA9IFs0LCA0XSxcbiAgICAgIHpvb206IGQsXG4gICAgICByb3VuZFBhZGRpbmc6IHAgPSAwLFxuICAgICAgaXNEaXNwbGF5U2hhZG93Um91bmRDb250cm9sczogZyxcbiAgICAgIGdyb3VwYWJsZTogaFxuICAgIH0gPSB0LnByb3BzO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHYgPSBsIHx8IENvKHQpLCBtID0gaSA/IDQgOiAzLCBTID0gU28oXG4gICAgICB2LFxuICAgICAgcixcbiAgICAgIHMsXG4gICAgICB1LFxuICAgICAgITBcbiAgICApO1xuICAgIGlmICghUylcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB4ID0gMCwgQyA9IDA7XG4gICAgY29uc3QgRSA9IGggPyBbMCwgMF0gOiBbYSwgY107XG4gICAgcmV0dXJuIFMubWFwKChELCBSKSA9PiB7XG4gICAgICBjb25zdCB5ID0gRC5ob3Jpem9udGFsLCBNID0gRC52ZXJ0aWNhbCwgUCA9IEQuZGlyZWN0aW9uIHx8IFwiXCIsIF8gPSBbLi4uRC5wb3NdO1xuICAgICAgQyArPSBNYXRoLmFicyh5KSwgeCArPSBNYXRoLmFicyhNKSwgeSAmJiBQLmluZGV4T2YoXCJuXCIpID4gLTEgJiYgKF9bMV0gLT0gcCksIE0gJiYgUC5pbmRleE9mKFwid1wiKSA+IC0xICYmIChfWzBdIC09IHApLCB5ICYmIFAuaW5kZXhPZihcInNcIikgPiAtMSAmJiAoX1sxXSArPSBwKSwgTSAmJiBQLmluZGV4T2YoXCJlXCIpID4gLTEgJiYgKF9bMF0gKz0gcCk7XG4gICAgICBjb25zdCBPID0gSyhodChvLCBfLCBtKSwgRSksIFQgPSBnICYmIGcgIT09IFwiaG9yaXpvbnRhbFwiLCB3ID0gRC52ZXJ0aWNhbCA/IHggPD0gZlsxXSAmJiAoVCB8fCAhRC52aXJ0dWFsKSA6IEMgPD0gZlswXSAmJiAoZyB8fCAhRC52aXJ0dWFsKTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaXQuanN4KFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBVKFxuICAgICAgICAgICAgXCJjb250cm9sXCIsXG4gICAgICAgICAgICBcImJvcmRlci1yYWRpdXNcIixcbiAgICAgICAgICAgIEQudmVydGljYWwgPyBcInZlcnRpY2FsXCIgOiBcIlwiLFxuICAgICAgICAgICAgRC52aXJ0dWFsID8gXCJ2aXJ0dWFsXCIgOiBcIlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICBcImRhdGEtcmFkaXVzLWluZGV4XCI6IFIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHcgPyBcImJsb2NrXCIgOiBcIm5vbmVcIixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke09bMF19cHgsICR7T1sxXX1weCkgc2NhbGUoJHtkfSlgXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBgYm9yZGVyUmFkaXVzQ29udHJvbCR7Un1gXG4gICAgICApO1xuICAgIH0pO1xuICB9LFxuICBkcmFnQ29udHJvbENvbmRpdGlvbih0LCBlKSB7XG4gICAgaWYgKCFlLmlucHV0RXZlbnQgfHwgZS5pc1JlcXVlc3QpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbiA9IGUuaW5wdXRFdmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIjtcbiAgICByZXR1cm4gbi5pbmRleE9mKFwiYm9yZGVyLXJhZGl1c1wiKSA+IC0xIHx8IG4uaW5kZXhPZihcIm1vdmVhYmxlLWxpbmVcIikgPiAtMSAmJiBuLmluZGV4T2YoXCJtb3ZlYWJsZS1kaXJlY3Rpb25cIikgPiAtMTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbih0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2xDb25kaXRpb24odCwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQodCwgZSkge1xuICAgIGNvbnN0IHsgaW5wdXRFdmVudDogbiwgZGF0YXM6IHIgfSA9IGUsIHMgPSBuLnRhcmdldCwgbyA9IHMuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiwgaSA9IG8uaW5kZXhPZihcImJvcmRlci1yYWRpdXNcIikgPiAtMSwgYSA9IG8uaW5kZXhPZihcIm1vdmVhYmxlLWxpbmVcIikgPiAtMSAmJiBvLmluZGV4T2YoXCJtb3ZlYWJsZS1kaXJlY3Rpb25cIikgPiAtMSwgYyA9IGkgPyBwYXJzZUludChzLmdldEF0dHJpYnV0ZShcImRhdGEtcmFkaXVzLWluZGV4XCIpLCAxMCkgOiAtMTtcbiAgICBsZXQgbCA9IC0xO1xuICAgIGlmIChhKSB7XG4gICAgICBjb25zdCB4ID0gcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWxpbmUta2V5XCIpIHx8IFwiXCI7XG4gICAgICB4ICYmIChsID0gcGFyc2VJbnQoeC5yZXBsYWNlKC9yZW5kZXItbGluZS0vZywgXCJcIiksIDEwKSwgaXNOYU4obCkgJiYgKGwgPSAtMSkpO1xuICAgIH1cbiAgICBpZiAoIWkgJiYgIWEpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgdSA9IGV0KHQsIGUsIHt9KTtcbiAgICBpZiAoaihcbiAgICAgIHQsXG4gICAgICBcIm9uUm91bmRTdGFydFwiLFxuICAgICAgdVxuICAgICkgPT09ICExKVxuICAgICAgcmV0dXJuICExO1xuICAgIHIubGluZUluZGV4ID0gbCwgci5jb250cm9sSW5kZXggPSBjLCByLmlzQ29udHJvbCA9IGksIHIuaXNMaW5lID0gYSwgUmUodCwgZSk7XG4gICAgY29uc3Qge1xuICAgICAgcm91bmRSZWxhdGl2ZTogZCxcbiAgICAgIG1pblJvdW5kQ29udHJvbHM6IHAgPSBbMCwgMF1cbiAgICB9ID0gdC5wcm9wcywgZyA9IHQuc3RhdGUsIHtcbiAgICAgIHdpZHRoOiBoLFxuICAgICAgaGVpZ2h0OiB2XG4gICAgfSA9IGc7XG4gICAgci5pc1JvdW5kID0gITAsIHIucHJldkRpc3QgPSBbMCwgMF07XG4gICAgY29uc3QgbSA9IENvKHQpLCBTID0gU28oXG4gICAgICBtIHx8IFwiXCIsXG4gICAgICBoLFxuICAgICAgdixcbiAgICAgIHAsXG4gICAgICAhMFxuICAgICkgfHwgW107XG4gICAgcmV0dXJuIHIuY29udHJvbFBvc2VzID0gUywgZy5ib3JkZXJSYWRpdXNTdGF0ZSA9IERzKFxuICAgICAgUyxcbiAgICAgIGQsXG4gICAgICBoLFxuICAgICAgdlxuICAgICkuc3R5bGVzLmpvaW4oXCIgXCIpLCB1O1xuICB9LFxuICBkcmFnQ29udHJvbCh0LCBlKSB7XG4gICAgY29uc3QgeyBkYXRhczogbiB9ID0gZSwgciA9IG4uY29udHJvbFBvc2VzO1xuICAgIGlmICghbi5pc1JvdW5kIHx8ICFuLmlzQ29udHJvbCB8fCAhci5sZW5ndGgpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcyA9IG4uY29udHJvbEluZGV4LCBbbywgaV0gPSBRdChlKSwgYSA9IFtvLCBpXSwgYyA9IEsoYSwgbi5wcmV2RGlzdCksIHtcbiAgICAgIG1heFJvdW5kQ29udHJvbHM6IGwgPSBbNCwgNF1cbiAgICB9ID0gdC5wcm9wcywgeyB3aWR0aDogdSwgaGVpZ2h0OiBmIH0gPSB0LnN0YXRlLCBkID0gcltzXSwgcCA9IGQudmVydGljYWwsIGcgPSBkLmhvcml6b250YWwsIGggPSByLm1hcCgobSkgPT4ge1xuICAgICAgY29uc3QgeyBob3Jpem9udGFsOiBTLCB2ZXJ0aWNhbDogeCB9ID0gbSwgQyA9IFtcbiAgICAgICAgUyAqIGcgKiBhWzBdLFxuICAgICAgICB4ICogcCAqIGFbMV1cbiAgICAgIF07XG4gICAgICBpZiAoUykge1xuICAgICAgICBpZiAobFswXSA9PT0gMSlcbiAgICAgICAgICByZXR1cm4gQztcbiAgICAgICAgaWYgKGxbMF0gPCA0ICYmIFMgIT09IGcpXG4gICAgICAgICAgcmV0dXJuIEM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobFsxXSA9PT0gMClcbiAgICAgICAgICByZXR1cm4gQ1sxXSA9IHggKiBnICogYVswXSAvIHUgKiBmLCBDO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIGlmIChsWzFdID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIEM7XG4gICAgICAgICAgaWYgKGxbMV0gPCA0ICYmIHggIT09IHApXG4gICAgICAgICAgICByZXR1cm4gQztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9KTtcbiAgICBoW3NdID0gYTtcbiAgICBjb25zdCB2ID0gci5tYXAoKG0sIFMpID0+ICh7XG4gICAgICAuLi5tLFxuICAgICAgcG9zOiBhdChtLnBvcywgaFtTXSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIHMgPCA0ID8gdi5zbGljZSgwLCBzICsgMSkuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgbS52aXJ0dWFsID0gITE7XG4gICAgfSkgOiB2LnNsaWNlKDQsIHMgKyAxKS5mb3JFYWNoKChtKSA9PiB7XG4gICAgICBtLnZpcnR1YWwgPSAhMTtcbiAgICB9KSwgbi5wcmV2RGlzdCA9IFtvLCBpXSwgRW8oXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIGEsXG4gICAgICBjLFxuICAgICAgdlxuICAgICk7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kKHQsIGUpIHtcbiAgICBjb25zdCBuID0gdC5zdGF0ZTtcbiAgICBuLmJvcmRlclJhZGl1c1N0YXRlID0gXCJcIjtcbiAgICBjb25zdCB7IGRhdGFzOiByLCBpc0RvdWJsZTogcyB9ID0gZTtcbiAgICBpZiAoIXIuaXNSb3VuZClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCB7XG4gICAgICBpc0NvbnRyb2w6IG8sXG4gICAgICBjb250cm9sSW5kZXg6IGksXG4gICAgICBpc0xpbmU6IGEsXG4gICAgICBsaW5lSW5kZXg6IGNcbiAgICB9ID0gciwgbCA9IHIuY29udHJvbFBvc2VzLCB1ID0gbC5maWx0ZXIoKHsgdmlydHVhbDogcCB9KSA9PiBwKS5sZW5ndGgsIHtcbiAgICAgIHJvdW5kQ2xpY2thYmxlOiBmID0gITBcbiAgICB9ID0gdC5wcm9wcztcbiAgICBpZiAocyAmJiBmKSB7XG4gICAgICBpZiAobyAmJiAoZiA9PT0gITAgfHwgZiA9PT0gXCJjb250cm9sXCIpKVxuICAgICAgICBzZihsLCBpKTtcbiAgICAgIGVsc2UgaWYgKGEgJiYgKGYgPT09ICEwIHx8IGYgPT09IFwibGluZVwiKSkge1xuICAgICAgICBjb25zdCBbcCwgZ10gPSBuaSh0LCBlKTtcbiAgICAgICAgbmYobCwgYywgcCwgZyk7XG4gICAgICB9XG4gICAgICB1ICE9PSBsLmZpbHRlcigoeyB2aXJ0dWFsOiBwIH0pID0+IHApLmxlbmd0aCAmJiBFbyhcbiAgICAgICAgdCxcbiAgICAgICAgZSxcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMCwgMF0sXG4gICAgICAgIGxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGQgPSAkdCh0LCBlLCB7fSk7XG4gICAgcmV0dXJuIGoodCwgXCJvblJvdW5kRW5kXCIsIGQpLCBuLmJvcmRlclJhZGl1c1N0YXRlID0gXCJcIiwgZDtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0KHQsIGUpIHtcbiAgICBjb25zdCBuID0gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KHQsIGUpO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCByID0gdC5tb3ZlYWJsZXMsIHMgPSB0LnByb3BzLnRhcmdldHMsIG8gPSBIdCh0LCBcInJvdW5kYWJsZVwiLCBlKSwgaSA9IHtcbiAgICAgIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogby5tYXAoKGEsIGMpID0+ICh7XG4gICAgICAgIC4uLmEsXG4gICAgICAgIHRhcmdldDogc1tjXSxcbiAgICAgICAgbW92ZWFibGU6IHJbY10sXG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IHJbY11cbiAgICAgIH0pKSxcbiAgICAgIC4uLm5cbiAgICB9O1xuICAgIHJldHVybiBqKHQsIFwib25Sb3VuZEdyb3VwU3RhcnRcIiwgaSksIG47XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2wodCwgZSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmRyYWdDb250cm9sKHQsIGUpO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCByID0gdC5tb3ZlYWJsZXMsIHMgPSB0LnByb3BzLnRhcmdldHMsIG8gPSBIdCh0LCBcInJvdW5kYWJsZVwiLCBlKSwgaSA9IHtcbiAgICAgIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogby5tYXAoKGEsIGMpID0+ICh7XG4gICAgICAgIC4uLmEsXG4gICAgICAgIHRhcmdldDogc1tjXSxcbiAgICAgICAgbW92ZWFibGU6IHJbY10sXG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IHJbY10sXG4gICAgICAgIC4uLkl0KHtcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IG4uYm9yZGVyUmFkaXVzXG4gICAgICAgIH0sIGEpXG4gICAgICB9KSksXG4gICAgICAuLi5uXG4gICAgfTtcbiAgICByZXR1cm4gaih0LCBcIm9uUm91bmRHcm91cFwiLCBpKSwgaTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZCh0LCBlKSB7XG4gICAgY29uc3QgbiA9IHQubW92ZWFibGVzLCByID0gdC5wcm9wcy50YXJnZXRzLCBzID0gSHQodCwgXCJyb3VuZGFibGVcIiwgZSk7XG4gICAgUW4odCwgXCJvblJvdW5kXCIsIChhKSA9PiB7XG4gICAgICBjb25zdCBjID0ge1xuICAgICAgICB0YXJnZXRzOiB0LnByb3BzLnRhcmdldHMsXG4gICAgICAgIGV2ZW50czogcy5tYXAoKGwsIHUpID0+ICh7XG4gICAgICAgICAgLi4ubCxcbiAgICAgICAgICB0YXJnZXQ6IHJbdV0sXG4gICAgICAgICAgbW92ZWFibGU6IG5bdV0sXG4gICAgICAgICAgY3VycmVudFRhcmdldDogblt1XSxcbiAgICAgICAgICAuLi5JdCh7XG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IGEuYm9yZGVyUmFkaXVzXG4gICAgICAgICAgfSwgbClcbiAgICAgICAgfSkpLFxuICAgICAgICAuLi5hXG4gICAgICB9O1xuICAgICAgaih0LCBcIm9uUm91bmRHcm91cFwiLCBjKTtcbiAgICB9KTtcbiAgICBjb25zdCBvID0gdGhpcy5kcmFnQ29udHJvbEVuZCh0LCBlKTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgaSA9IHtcbiAgICAgIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogcy5tYXAoKGEsIGMpID0+IHtcbiAgICAgICAgdmFyIGw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYSxcbiAgICAgICAgICB0YXJnZXQ6IHJbY10sXG4gICAgICAgICAgbW92ZWFibGU6IG5bY10sXG4gICAgICAgICAgY3VycmVudFRhcmdldDogbltjXSxcbiAgICAgICAgICBsYXN0RXZlbnQ6IChsID0gYS5kYXRhcykgPT0gbnVsbCA/IHZvaWQgMCA6IGwubGFzdEV2ZW50XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIC4uLm9cbiAgICB9O1xuICAgIHJldHVybiBqKHQsIFwib25Sb3VuZEdyb3VwRW5kXCIsIGkpLCBpO1xuICB9LFxuICB1bnNldCh0KSB7XG4gICAgdC5zdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IFwiXCI7XG4gIH1cbn07XG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbnZhciBOciA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIE5yID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obiwgcikge1xuICAgIG4uX19wcm90b19fID0gcjtcbiAgfSB8fCBmdW5jdGlvbihuLCByKSB7XG4gICAgZm9yICh2YXIgcyBpbiByKSByLmhhc093blByb3BlcnR5KHMpICYmIChuW3NdID0gcltzXSk7XG4gIH0sIE5yKHQsIGUpO1xufTtcbmZ1bmN0aW9uIGFmKHQsIGUpIHtcbiAgTnIodCwgZSk7XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IHQ7XG4gIH1cbiAgdC5wcm90b3R5cGUgPSBlID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShlKSA6IChuLnByb3RvdHlwZSA9IGUucHJvdG90eXBlLCBuZXcgbigpKTtcbn1cbnZhciBDdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQ3QgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciBuLCByID0gMSwgcyA9IGFyZ3VtZW50cy5sZW5ndGg7IHIgPCBzOyByKyspIHtcbiAgICAgIG4gPSBhcmd1bWVudHNbcl07XG4gICAgICBmb3IgKHZhciBvIGluIG4pIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCBvKSAmJiAoZVtvXSA9IG5bb10pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgQ3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBjZih0LCBlKSB7XG4gIHZhciBuID0gZVswXSAtIHRbMF0sIHIgPSBlWzFdIC0gdFsxXSwgcyA9IE1hdGguYXRhbjIociwgbik7XG4gIHJldHVybiBzID49IDAgPyBzIDogcyArIE1hdGguUEkgKiAyO1xufVxuZnVuY3Rpb24gdnIodCkge1xuICByZXR1cm4gY2YoW1xuICAgIHRbMF0uY2xpZW50WCxcbiAgICB0WzBdLmNsaWVudFlcbiAgXSwgW1xuICAgIHRbMV0uY2xpZW50WCxcbiAgICB0WzFdLmNsaWVudFlcbiAgXSkgLyBNYXRoLlBJICogMTgwO1xufVxuZnVuY3Rpb24gbGYodCkge1xuICByZXR1cm4gdC50b3VjaGVzICYmIHQudG91Y2hlcy5sZW5ndGggPj0gMjtcbn1cbmZ1bmN0aW9uIE9uKHQpIHtcbiAgcmV0dXJuIHQgPyB0LnRvdWNoZXMgPyBmZih0LnRvdWNoZXMpIDogW25hKHQpXSA6IFtdO1xufVxuZnVuY3Rpb24gdWYodCkge1xuICByZXR1cm4gdCAmJiAodC50eXBlLmluZGV4T2YoXCJtb3VzZVwiKSA+IC0xIHx8IFwiYnV0dG9uXCIgaW4gdCk7XG59XG5mdW5jdGlvbiBEbyh0LCBlLCBuKSB7XG4gIHZhciByID0gbi5sZW5ndGgsIHMgPSBybih0LCByKSwgbyA9IHMuY2xpZW50WCwgaSA9IHMuY2xpZW50WSwgYSA9IHMub3JpZ2luYWxDbGllbnRYLCBjID0gcy5vcmlnaW5hbENsaWVudFksIGwgPSBybihlLCByKSwgdSA9IGwuY2xpZW50WCwgZiA9IGwuY2xpZW50WSwgZCA9IHJuKG4sIHIpLCBwID0gZC5jbGllbnRYLCBnID0gZC5jbGllbnRZLCBoID0gbyAtIHUsIHYgPSBpIC0gZiwgbSA9IG8gLSBwLCBTID0gaSAtIGc7XG4gIHJldHVybiB7XG4gICAgY2xpZW50WDogYSxcbiAgICBjbGllbnRZOiBjLFxuICAgIGRlbHRhWDogaCxcbiAgICBkZWx0YVk6IHYsXG4gICAgZGlzdFg6IG0sXG4gICAgZGlzdFk6IFNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1yKHQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0WzBdLmNsaWVudFggLSB0WzFdLmNsaWVudFgsIDIpICsgTWF0aC5wb3codFswXS5jbGllbnRZIC0gdFsxXS5jbGllbnRZLCAyKSk7XG59XG5mdW5jdGlvbiBmZih0KSB7XG4gIGZvciAodmFyIGUgPSBNYXRoLm1pbih0Lmxlbmd0aCwgMiksIG4gPSBbXSwgciA9IDA7IHIgPCBlOyArK3IpXG4gICAgbi5wdXNoKG5hKHRbcl0pKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBuYSh0KSB7XG4gIHJldHVybiB7XG4gICAgY2xpZW50WDogdC5jbGllbnRYLFxuICAgIGNsaWVudFk6IHQuY2xpZW50WVxuICB9O1xufVxuZnVuY3Rpb24gcm4odCwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSB0Lmxlbmd0aCk7XG4gIGZvciAodmFyIG4gPSB7XG4gICAgY2xpZW50WDogMCxcbiAgICBjbGllbnRZOiAwLFxuICAgIG9yaWdpbmFsQ2xpZW50WDogMCxcbiAgICBvcmlnaW5hbENsaWVudFk6IDBcbiAgfSwgciA9IE1hdGgubWluKHQubGVuZ3RoLCBlKSwgcyA9IDA7IHMgPCByOyArK3MpIHtcbiAgICB2YXIgbyA9IHRbc107XG4gICAgbi5vcmlnaW5hbENsaWVudFggKz0gXCJvcmlnaW5hbENsaWVudFhcIiBpbiBvID8gby5vcmlnaW5hbENsaWVudFggOiBvLmNsaWVudFgsIG4ub3JpZ2luYWxDbGllbnRZICs9IFwib3JpZ2luYWxDbGllbnRZXCIgaW4gbyA/IG8ub3JpZ2luYWxDbGllbnRZIDogby5jbGllbnRZLCBuLmNsaWVudFggKz0gby5jbGllbnRYLCBuLmNsaWVudFkgKz0gby5jbGllbnRZO1xuICB9XG4gIHJldHVybiBlID8ge1xuICAgIGNsaWVudFg6IG4uY2xpZW50WCAvIGUsXG4gICAgY2xpZW50WTogbi5jbGllbnRZIC8gZSxcbiAgICBvcmlnaW5hbENsaWVudFg6IG4ub3JpZ2luYWxDbGllbnRYIC8gZSxcbiAgICBvcmlnaW5hbENsaWVudFk6IG4ub3JpZ2luYWxDbGllbnRZIC8gZVxuICB9IDogbjtcbn1cbnZhciB4ciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gdChlKSB7XG4gICAgdGhpcy5wcmV2Q2xpZW50cyA9IFtdLCB0aGlzLnN0YXJ0Q2xpZW50cyA9IFtdLCB0aGlzLm1vdmVtZW50ID0gMCwgdGhpcy5sZW5ndGggPSAwLCB0aGlzLnN0YXJ0Q2xpZW50cyA9IGUsIHRoaXMucHJldkNsaWVudHMgPSBlLCB0aGlzLmxlbmd0aCA9IGUubGVuZ3RoO1xuICB9XG4gIHJldHVybiB0LnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gdGhpcy5wcmV2Q2xpZW50cyksIHZyKGUpO1xuICB9LCB0LnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gdGhpcy5wcmV2Q2xpZW50cyksIHZyKGUpIC0gdnIodGhpcy5zdGFydENsaWVudHMpO1xuICB9LCB0LnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKGUsIG4pIHtcbiAgICBlID09PSB2b2lkIDAgJiYgKGUgPSB0aGlzLnByZXZDbGllbnRzKTtcbiAgICB2YXIgciA9IERvKGUgfHwgdGhpcy5wcmV2Q2xpZW50cywgdGhpcy5wcmV2Q2xpZW50cywgdGhpcy5zdGFydENsaWVudHMpLCBzID0gci5kZWx0YVgsIG8gPSByLmRlbHRhWTtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudCArPSBNYXRoLnNxcnQocyAqIHMgKyBvICogbyksIHRoaXMucHJldkNsaWVudHMgPSBlLCByO1xuICB9LCB0LnByb3RvdHlwZS5nZXRQb3NpdGlvbnMgPSBmdW5jdGlvbihlKSB7XG4gICAgZSA9PT0gdm9pZCAwICYmIChlID0gdGhpcy5wcmV2Q2xpZW50cyk7XG4gICAgZm9yICh2YXIgbiA9IHRoaXMucHJldkNsaWVudHMsIHIgPSB0aGlzLnN0YXJ0Q2xpZW50cywgcyA9IE1hdGgubWluKHRoaXMubGVuZ3RoLCBuLmxlbmd0aCksIG8gPSBbXSwgaSA9IDA7IGkgPCBzOyArK2kpXG4gICAgICBvW2ldID0gRG8oW2VbaV1dLCBbbltpXV0sIFtyW2ldXSk7XG4gICAgcmV0dXJuIG87XG4gIH0sIHQucHJvdG90eXBlLmdldE1vdmVtZW50ID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBuID0gdGhpcy5tb3ZlbWVudDtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gbjtcbiAgICB2YXIgciA9IHJuKGUsIHRoaXMubGVuZ3RoKSwgcyA9IHJuKHRoaXMucHJldkNsaWVudHMsIHRoaXMubGVuZ3RoKSwgbyA9IHIuY2xpZW50WCAtIHMuY2xpZW50WCwgaSA9IHIuY2xpZW50WSAtIHMuY2xpZW50WTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KG8gKiBvICsgaSAqIGkpICsgbjtcbiAgfSwgdC5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHRoaXMucHJldkNsaWVudHMpLCBtcihlKTtcbiAgfSwgdC5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHRoaXMucHJldkNsaWVudHMpLCBtcihlKSAvIG1yKHRoaXMuc3RhcnRDbGllbnRzKTtcbiAgfSwgdC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGUsIG4pIHtcbiAgICB0aGlzLnN0YXJ0Q2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHIuY2xpZW50WCAtPSBlLCByLmNsaWVudFkgLT0gbjtcbiAgICB9KSwgdGhpcy5wcmV2Q2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHIuY2xpZW50WCAtPSBlLCByLmNsaWVudFkgLT0gbjtcbiAgICB9KTtcbiAgfSwgdDtcbn0oKSwgYm8gPSBbXCJ0ZXh0YXJlYVwiLCBcImlucHV0XCJdLCBkZiA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbih0KSB7XG4gIGFmKGUsIHQpO1xuICBmdW5jdGlvbiBlKG4sIHIpIHtcbiAgICByID09PSB2b2lkIDAgJiYgKHIgPSB7fSk7XG4gICAgdmFyIHMgPSB0LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBzLm9wdGlvbnMgPSB7fSwgcy5mbGFnID0gITEsIHMucGluY2hGbGFnID0gITEsIHMuZGF0YSA9IHt9LCBzLmlzRHJhZyA9ICExLCBzLmlzUGluY2ggPSAhMSwgcy5jbGllbnRTdG9yZXMgPSBbXSwgcy50YXJnZXRzID0gW10sIHMucHJldlRpbWUgPSAwLCBzLmRvdWJsZUZsYWcgPSAhMSwgcy5fdXNlTW91c2UgPSAhMSwgcy5fdXNlVG91Y2ggPSAhMSwgcy5fdXNlRHJhZyA9ICExLCBzLl9kcmFnRmxhZyA9ICExLCBzLl9pc1RydXN0ZWQgPSAhMSwgcy5faXNNb3VzZUV2ZW50ID0gITEsIHMuX2lzU2Vjb25kYXJ5QnV0dG9uID0gITEsIHMuX3ByZXZlbnRNb3VzZUV2ZW50ID0gITEsIHMuX3ByZXZJbnB1dEV2ZW50ID0gbnVsbCwgcy5faXNEcmFnQVBJID0gITEsIHMuX2lzSWRsZSA9ICEwLCBzLl9wcmV2ZW50TW91c2VFdmVudElkID0gMCwgcy5fd2luZG93ID0gd2luZG93LCBzLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZCwgcCkge1xuICAgICAgaWYgKHAgPT09IHZvaWQgMCAmJiAocCA9ICEwKSwgISghcy5mbGFnICYmIGQuY2FuY2VsYWJsZSA9PT0gITEpKSB7XG4gICAgICAgIHZhciBnID0gZC50eXBlLmluZGV4T2YoXCJkcmFnXCIpID49IC0xO1xuICAgICAgICBpZiAoIShzLmZsYWcgJiYgZykpIHtcbiAgICAgICAgICBzLl9pc0RyYWdBUEkgPSAhMDtcbiAgICAgICAgICB2YXIgaCA9IHMub3B0aW9ucywgdiA9IGguY29udGFpbmVyLCBtID0gaC5waW5jaE91dHNpZGUsIFMgPSBoLnByZXZlbnRXaGVlbENsaWNrLCB4ID0gaC5wcmV2ZW50UmlnaHRDbGljaywgQyA9IGgucHJldmVudERlZmF1bHQsIEUgPSBoLmNoZWNrSW5wdXQsIEQgPSBoLmRyYWdGb2N1c2VkSW5wdXQsIFIgPSBoLnByZXZlbnRDbGlja0V2ZW50T25EcmFnU3RhcnQsIHkgPSBoLnByZXZlbnRDbGlja0V2ZW50T25EcmFnLCBNID0gaC5wcmV2ZW50Q2xpY2tFdmVudEJ5Q29uZGl0aW9uLCBQID0gcy5fdXNlVG91Y2gsIF8gPSAhcy5mbGFnO1xuICAgICAgICAgIGlmIChzLl9pc1NlY29uZGFyeUJ1dHRvbiA9IGQud2hpY2ggPT09IDMgfHwgZC5idXR0b24gPT09IDIsIFMgJiYgKGQud2hpY2ggPT09IDIgfHwgZC5idXR0b24gPT09IDEpIHx8IHggJiYgKGQud2hpY2ggPT09IDMgfHwgZC5idXR0b24gPT09IDIpKVxuICAgICAgICAgICAgcmV0dXJuIHMuc3RvcCgpLCAhMTtcbiAgICAgICAgICBpZiAoXykge1xuICAgICAgICAgICAgdmFyIE8gPSBzLl93aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgVCA9IGQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKFQpIHtcbiAgICAgICAgICAgICAgdmFyIHcgPSBULnRhZ05hbWUudG9Mb3dlckNhc2UoKSwgayA9IGJvLmluZGV4T2YodykgPiAtMSwgSSA9IFQuaXNDb250ZW50RWRpdGFibGU7XG4gICAgICAgICAgICAgIGlmIChrIHx8IEkpIHtcbiAgICAgICAgICAgICAgICBpZiAoRSB8fCAhRCAmJiBPID09PSBUKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGlmIChPICYmIChPID09PSBUIHx8IEkgJiYgTy5pc0NvbnRlbnRFZGl0YWJsZSAmJiBPLmNvbnRhaW5zKFQpKSlcbiAgICAgICAgICAgICAgICAgIGlmIChEKVxuICAgICAgICAgICAgICAgICAgICBULmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKChDIHx8IGQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpICYmIE8pIHtcbiAgICAgICAgICAgICAgICB2YXIgJCA9IE8udGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIChPLmlzQ29udGVudEVkaXRhYmxlIHx8IGJvLmluZGV4T2YoJCkgPiAtMSkgJiYgTy5ibHVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKFIgfHwgeSB8fCBNKSAmJiBQdChzLl93aW5kb3csIFwiY2xpY2tcIiwgcy5fb25DbGljaywgITApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcy5jbGllbnRTdG9yZXMgPSBbbmV3IHhyKE9uKGQpKV0sIHMuX2lzSWRsZSA9ICExLCBzLmZsYWcgPSAhMCwgcy5pc0RyYWcgPSAhMSwgcy5faXNUcnVzdGVkID0gcCwgcy5fZHJhZ0ZsYWcgPSAhMCwgcy5fcHJldklucHV0RXZlbnQgPSBkLCBzLmRhdGEgPSB7fSwgcy5kb3VibGVGbGFnID0gY24oKSAtIHMucHJldlRpbWUgPCAyMDAsIHMuX2lzTW91c2VFdmVudCA9IHVmKGQpLCAhcy5faXNNb3VzZUV2ZW50ICYmIHMuX3ByZXZlbnRNb3VzZUV2ZW50ICYmIHMuX2FsbG93TW91c2VFdmVudCgpO1xuICAgICAgICAgICAgdmFyIEcgPSBzLl9wcmV2ZW50TW91c2VFdmVudCB8fCBzLmVtaXQoXCJkcmFnU3RhcnRcIiwgQ3QoQ3QoeyBkYXRhOiBzLmRhdGEsIGRhdGFzOiBzLmRhdGEsIGlucHV0RXZlbnQ6IGQsIGlzTW91c2VFdmVudDogcy5faXNNb3VzZUV2ZW50LCBpc1NlY29uZGFyeUJ1dHRvbjogcy5faXNTZWNvbmRhcnlCdXR0b24sIGlzVHJ1c3RlZDogcCwgaXNEb3VibGU6IHMuZG91YmxlRmxhZyB9LCBzLmdldEN1cnJlbnRTdG9yZSgpLmdldFBvc2l0aW9uKCkpLCB7IHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSwgcHJldmVudERyYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzLl9kcmFnRmxhZyA9ICExO1xuICAgICAgICAgICAgfSB9KSk7XG4gICAgICAgICAgICBHID09PSAhMSAmJiBzLnN0b3AoKSwgcy5faXNNb3VzZUV2ZW50ICYmIHMuZmxhZyAmJiBDICYmIGQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzLmZsYWcpXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgdmFyIEwgPSAwO1xuICAgICAgICAgIGlmIChfID8gKHMuX2F0dGNoRHJhZ0V2ZW50KCksIFAgJiYgbSAmJiAoTCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBQdCh2LCBcInRvdWNoc3RhcnRcIiwgcy5vbkRyYWdTdGFydCwge1xuICAgICAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkpKSA6IFAgJiYgbSAmJiBNdCh2LCBcInRvdWNoc3RhcnRcIiwgcy5vbkRyYWdTdGFydCksIHMuZmxhZyAmJiBsZihkKSkge1xuICAgICAgICAgICAgaWYgKGNsZWFyVGltZW91dChMKSwgXyAmJiBkLnRvdWNoZXMubGVuZ3RoICE9PSBkLmNoYW5nZWRUb3VjaGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcy5waW5jaEZsYWcgfHwgcy5vblBpbmNoU3RhcnQoZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgcy5vbkRyYWcgPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgICBpZiAocy5mbGFnKSB7XG4gICAgICAgIHZhciBnID0gcy5vcHRpb25zLnByZXZlbnREZWZhdWx0O1xuICAgICAgICAhcy5faXNNb3VzZUV2ZW50ICYmIGcgJiYgZC5wcmV2ZW50RGVmYXVsdCgpLCBzLl9wcmV2SW5wdXRFdmVudCA9IGQ7XG4gICAgICAgIHZhciBoID0gT24oZCksIHYgPSBzLm1vdmVDbGllbnRzKGgsIGQsICExKTtcbiAgICAgICAgaWYgKHMuX2RyYWdGbGFnKSB7XG4gICAgICAgICAgaWYgKHMucGluY2hGbGFnIHx8IHYuZGVsdGFYIHx8IHYuZGVsdGFZKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHMuX3ByZXZlbnRNb3VzZUV2ZW50IHx8IHMuZW1pdChcImRyYWdcIiwgQ3QoQ3Qoe30sIHYpLCB7IGlzU2Nyb2xsOiAhIXAsIGlucHV0RXZlbnQ6IGQgfSkpO1xuICAgICAgICAgICAgaWYgKG0gPT09ICExKSB7XG4gICAgICAgICAgICAgIHMuc3RvcCgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHMucGluY2hGbGFnICYmIHMub25QaW5jaChkLCBoKTtcbiAgICAgICAgfVxuICAgICAgICBzLmdldEN1cnJlbnRTdG9yZSgpLmdldFBvc2l0aW9uKGgsICEwKTtcbiAgICAgIH1cbiAgICB9LCBzLm9uRHJhZ0VuZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmIChzLmZsYWcpIHtcbiAgICAgICAgdmFyIHAgPSBzLm9wdGlvbnMsIGcgPSBwLnBpbmNoT3V0c2lkZSwgaCA9IHAuY29udGFpbmVyLCB2ID0gcC5wcmV2ZW50Q2xpY2tFdmVudE9uRHJhZywgbSA9IHAucHJldmVudENsaWNrRXZlbnRPbkRyYWdTdGFydCwgUyA9IHAucHJldmVudENsaWNrRXZlbnRCeUNvbmRpdGlvbiwgeCA9IHMuaXNEcmFnO1xuICAgICAgICAodiB8fCBtIHx8IFMpICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBzLl9hbGxvd0NsaWNrRXZlbnQoKTtcbiAgICAgICAgfSksICFTICYmICFtICYmIHYgJiYgIXggJiYgcy5fYWxsb3dDbGlja0V2ZW50KCksIHMuX3VzZVRvdWNoICYmIGcgJiYgTXQoaCwgXCJ0b3VjaHN0YXJ0XCIsIHMub25EcmFnU3RhcnQpLCBzLnBpbmNoRmxhZyAmJiBzLm9uUGluY2hFbmQoZCk7XG4gICAgICAgIHZhciBDID0gZCAhPSBudWxsICYmIGQudG91Y2hlcyA/IE9uKGQpIDogW10sIEUgPSBDLmxlbmd0aDtcbiAgICAgICAgRSA9PT0gMCB8fCAhcy5vcHRpb25zLmtlZXBEcmFnZ2luZyA/IHMuZmxhZyA9ICExIDogcy5fYWRkU3RvcmUobmV3IHhyKEMpKTtcbiAgICAgICAgdmFyIEQgPSBzLl9nZXRQb3NpdGlvbigpLCBSID0gY24oKSwgeSA9ICF4ICYmIHMuZG91YmxlRmxhZztcbiAgICAgICAgcy5fcHJldklucHV0RXZlbnQgPSBudWxsLCBzLnByZXZUaW1lID0geCB8fCB5ID8gMCA6IFIsIHMuZmxhZyB8fCAocy5fZGV0dGFjaERyYWdFdmVudCgpLCBzLl9wcmV2ZW50TW91c2VFdmVudCB8fCBzLmVtaXQoXCJkcmFnRW5kXCIsIEN0KHsgZGF0YTogcy5kYXRhLCBkYXRhczogcy5kYXRhLCBpc0RvdWJsZTogeSwgaXNEcmFnOiB4LCBpc0NsaWNrOiAheCwgaXNNb3VzZUV2ZW50OiBzLl9pc01vdXNlRXZlbnQsIGlzU2Vjb25kYXJ5QnV0dG9uOiBzLl9pc1NlY29uZGFyeUJ1dHRvbiwgaW5wdXRFdmVudDogZCwgaXNUcnVzdGVkOiBzLl9pc1RydXN0ZWQgfSwgRCkpLCBzLmNsaWVudFN0b3JlcyA9IFtdLCBzLl9pc01vdXNlRXZlbnQgfHwgKHMuX3ByZXZlbnRNb3VzZUV2ZW50ID0gITAsIGNsZWFyVGltZW91dChzLl9wcmV2ZW50TW91c2VFdmVudElkKSwgcy5fcHJldmVudE1vdXNlRXZlbnRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcy5fcHJldmVudE1vdXNlRXZlbnQgPSAhMTtcbiAgICAgICAgfSwgMjAwKSksIHMuX2lzSWRsZSA9ICEwKTtcbiAgICAgIH1cbiAgICB9LCBzLm9uQmx1ciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcy5vbkRyYWdFbmQoKTtcbiAgICB9LCBzLl9hbGxvd0NsaWNrRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIE10KHMuX3dpbmRvdywgXCJjbGlja1wiLCBzLl9vbkNsaWNrLCAhMCk7XG4gICAgfSwgcy5fb25DbGljayA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHMuX2FsbG93Q2xpY2tFdmVudCgpLCBzLl9hbGxvd01vdXNlRXZlbnQoKTtcbiAgICAgIHZhciBwID0gcy5vcHRpb25zLnByZXZlbnRDbGlja0V2ZW50QnlDb25kaXRpb247XG4gICAgICBwICE9IG51bGwgJiYgcChkKSB8fCAoZC5zdG9wUHJvcGFnYXRpb24oKSwgZC5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICB9LCBzLl9vbkNvbnRleHRNZW51ID0gZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIHAgPSBzLm9wdGlvbnM7XG4gICAgICBwLnByZXZlbnRSaWdodENsaWNrID8gcy5vbkRyYWdFbmQoZCkgOiBkLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSwgcy5fcGFzc0NhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgICB2YXIgbyA9IFtdLmNvbmNhdChuKSwgaSA9IG9bMF07XG4gICAgcy5fd2luZG93ID0gSm8oaSkgPyBpIDogYWUoaSksIHMub3B0aW9ucyA9IEN0KHsgY2hlY2tJbnB1dDogITEsIGNvbnRhaW5lcjogaSAmJiAhKFwiZG9jdW1lbnRcIiBpbiBpKSA/IGFlKGkpIDogaSwgcHJldmVudFJpZ2h0Q2xpY2s6ICEwLCBwcmV2ZW50V2hlZWxDbGljazogITAsIHByZXZlbnRDbGlja0V2ZW50T25EcmFnU3RhcnQ6ICExLCBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZzogITEsIHByZXZlbnRDbGlja0V2ZW50QnlDb25kaXRpb246IG51bGwsIHByZXZlbnREZWZhdWx0OiAhMCwgY2hlY2tXaW5kb3dCbHVyOiAhMSwga2VlcERyYWdnaW5nOiAhMSwgcGluY2hUaHJlc2hvbGQ6IDAsIGV2ZW50czogW1widG91Y2hcIiwgXCJtb3VzZVwiXSB9LCByKTtcbiAgICB2YXIgYSA9IHMub3B0aW9ucywgYyA9IGEuY29udGFpbmVyLCBsID0gYS5ldmVudHMsIHUgPSBhLmNoZWNrV2luZG93Qmx1cjtcbiAgICBpZiAocy5fdXNlRHJhZyA9IGwuaW5kZXhPZihcImRyYWdcIikgPiAtMSwgcy5fdXNlVG91Y2ggPSBsLmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xLCBzLl91c2VNb3VzZSA9IGwuaW5kZXhPZihcIm1vdXNlXCIpID4gLTEsIHMudGFyZ2V0cyA9IG8sIHMuX3VzZURyYWcgJiYgby5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgIFB0KGQsIFwiZHJhZ3N0YXJ0XCIsIHMub25EcmFnU3RhcnQpO1xuICAgIH0pLCBzLl91c2VNb3VzZSAmJiAoby5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgIFB0KGQsIFwibW91c2Vkb3duXCIsIHMub25EcmFnU3RhcnQpLCBQdChkLCBcIm1vdXNlbW92ZVwiLCBzLl9wYXNzQ2FsbGJhY2spO1xuICAgIH0pLCBQdChjLCBcImNvbnRleHRtZW51XCIsIHMuX29uQ29udGV4dE1lbnUpKSwgdSAmJiBQdChhZSgpLCBcImJsdXJcIiwgcy5vbkJsdXIpLCBzLl91c2VUb3VjaCkge1xuICAgICAgdmFyIGYgPSB7XG4gICAgICAgIHBhc3NpdmU6ICExXG4gICAgICB9O1xuICAgICAgby5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgUHQoZCwgXCJ0b3VjaHN0YXJ0XCIsIHMub25EcmFnU3RhcnQsIGYpLCBQdChkLCBcInRvdWNobW92ZVwiLCBzLl9wYXNzQ2FsbGJhY2ssIGYpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG4gIHJldHVybiBlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc0RyYWcgPSAhMSwgdGhpcy5kYXRhID0ge30sIHRoaXMuY2xpZW50U3RvcmVzID0gW10sIHRoaXMucGluY2hGbGFnID0gITEsIHRoaXMuZG91YmxlRmxhZyA9ICExLCB0aGlzLnByZXZUaW1lID0gMCwgdGhpcy5mbGFnID0gITEsIHRoaXMuX2lzSWRsZSA9ICEwLCB0aGlzLl9hbGxvd0NsaWNrRXZlbnQoKSwgdGhpcy5fZGV0dGFjaERyYWdFdmVudCgpLCB0aGlzLl9pc0RyYWdBUEkgPSAhMTtcbiAgfSwgZS5wcm90b3R5cGUuZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFN0b3JlKCkuZ2V0TW92ZW1lbnQobikgKyB0aGlzLmNsaWVudFN0b3Jlcy5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24ociwgcykge1xuICAgICAgcmV0dXJuIHIgKyBzLm1vdmVtZW50O1xuICAgIH0sIDApO1xuICB9LCBlLnByb3RvdHlwZS5pc0RyYWdnaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEcmFnO1xuICB9LCBlLnByb3RvdHlwZS5pc0lkbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faXNJZGxlO1xuICB9LCBlLnByb3RvdHlwZS5pc0ZsYWcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mbGFnO1xuICB9LCBlLnByb3RvdHlwZS5pc1BpbmNoRmxhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBpbmNoRmxhZztcbiAgfSwgZS5wcm90b3R5cGUuaXNEb3VibGVGbGFnID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZG91YmxlRmxhZztcbiAgfSwgZS5wcm90b3R5cGUuaXNQaW5jaGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGluY2g7XG4gIH0sIGUucHJvdG90eXBlLnNjcm9sbEJ5ID0gZnVuY3Rpb24obiwgciwgcywgbykge1xuICAgIG8gPT09IHZvaWQgMCAmJiAobyA9ICEwKSwgdGhpcy5mbGFnICYmICh0aGlzLmNsaWVudFN0b3Jlc1swXS5tb3ZlKG4sIHIpLCBvICYmIHRoaXMub25EcmFnKHMsICEwKSk7XG4gIH0sIGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihuLCByKSB7XG4gICAgdmFyIHMgPSBuWzBdLCBvID0gblsxXSwgaSA9IHRoaXMuZ2V0Q3VycmVudFN0b3JlKCksIGEgPSBpLnByZXZDbGllbnRzO1xuICAgIHJldHVybiB0aGlzLm1vdmVDbGllbnRzKGEubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBsID0gYy5jbGllbnRYLCB1ID0gYy5jbGllbnRZO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xpZW50WDogbCArIHMsXG4gICAgICAgIGNsaWVudFk6IHUgKyBvLFxuICAgICAgICBvcmlnaW5hbENsaWVudFg6IGwsXG4gICAgICAgIG9yaWdpbmFsQ2xpZW50WTogdVxuICAgICAgfTtcbiAgICB9KSwgciwgITApO1xuICB9LCBlLnByb3RvdHlwZS50cmlnZ2VyRHJhZ1N0YXJ0ID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMub25EcmFnU3RhcnQobiwgITEpO1xuICB9LCBlLnByb3RvdHlwZS5zZXRFdmVudERhdGEgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHIgPSB0aGlzLmRhdGE7XG4gICAgZm9yICh2YXIgcyBpbiBuKVxuICAgICAgcltzXSA9IG5bc107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIGUucHJvdG90eXBlLnNldEV2ZW50RGF0YXMgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0RXZlbnREYXRhKG4pO1xuICB9LCBlLnByb3RvdHlwZS5nZXRDdXJyZW50RXZlbnQgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IHRoaXMuX3ByZXZJbnB1dEV2ZW50KSwgQ3QoQ3QoeyBkYXRhOiB0aGlzLmRhdGEsIGRhdGFzOiB0aGlzLmRhdGEgfSwgdGhpcy5fZ2V0UG9zaXRpb24oKSksIHsgbW92ZW1lbnQ6IHRoaXMuZ2V0TW92ZW1lbnQoKSwgaXNEcmFnOiB0aGlzLmlzRHJhZywgaXNQaW5jaDogdGhpcy5pc1BpbmNoLCBpc1Njcm9sbDogITEsIGlucHV0RXZlbnQ6IG4gfSk7XG4gIH0sIGUucHJvdG90eXBlLmdldEV2ZW50RGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH0sIGUucHJvdG90eXBlLmdldEV2ZW50RGF0YXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9LCBlLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gdGhpcywgciA9IHRoaXMudGFyZ2V0cywgcyA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5vZmYoKSwgTXQodGhpcy5fd2luZG93LCBcImJsdXJcIiwgdGhpcy5vbkJsdXIpLCB0aGlzLl91c2VEcmFnICYmIHIuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgICBNdChvLCBcImRyYWdzdGFydFwiLCBuLm9uRHJhZ1N0YXJ0KTtcbiAgICB9KSwgdGhpcy5fdXNlTW91c2UgJiYgKHIuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgICBNdChvLCBcIm1vdXNlZG93blwiLCBuLm9uRHJhZ1N0YXJ0KTtcbiAgICB9KSwgTXQocywgXCJjb250ZXh0bWVudVwiLCB0aGlzLl9vbkNvbnRleHRNZW51KSksIHRoaXMuX3VzZVRvdWNoICYmIChyLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgICAgTXQobywgXCJ0b3VjaHN0YXJ0XCIsIG4ub25EcmFnU3RhcnQpO1xuICAgIH0pLCBNdChzLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5vbkRyYWdTdGFydCkpLCB0aGlzLl9wcmV2SW5wdXRFdmVudCA9IG51bGwsIHRoaXMuX2FsbG93Q2xpY2tFdmVudCgpLCB0aGlzLl9kZXR0YWNoRHJhZ0V2ZW50KCk7XG4gIH0sIGUucHJvdG90eXBlLm9uUGluY2hTdGFydCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgciA9IHRoaXMsIHMgPSB0aGlzLm9wdGlvbnMucGluY2hUaHJlc2hvbGQ7XG4gICAgaWYgKCEodGhpcy5pc0RyYWcgJiYgdGhpcy5nZXRNb3ZlbWVudCgpID4gcykpIHtcbiAgICAgIHZhciBvID0gbmV3IHhyKE9uKG4pKTtcbiAgICAgIHRoaXMucGluY2hGbGFnID0gITAsIHRoaXMuX2FkZFN0b3JlKG8pO1xuICAgICAgdmFyIGkgPSB0aGlzLmVtaXQoXCJwaW5jaFN0YXJ0XCIsIEN0KEN0KHsgZGF0YTogdGhpcy5kYXRhLCBkYXRhczogdGhpcy5kYXRhLCBhbmdsZTogby5nZXRBbmdsZSgpLCB0b3VjaGVzOiB0aGlzLmdldEN1cnJlbnRTdG9yZSgpLmdldFBvc2l0aW9ucygpIH0sIG8uZ2V0UG9zaXRpb24oKSksIHsgaW5wdXRFdmVudDogbiwgaXNUcnVzdGVkOiB0aGlzLl9pc1RydXN0ZWQsIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgbi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSwgcHJldmVudERyYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByLl9kcmFnRmxhZyA9ICExO1xuICAgICAgfSB9KSk7XG4gICAgICBpID09PSAhMSAmJiAodGhpcy5waW5jaEZsYWcgPSAhMSk7XG4gICAgfVxuICB9LCBlLnByb3RvdHlwZS5vblBpbmNoID0gZnVuY3Rpb24obiwgcikge1xuICAgIGlmICghKCF0aGlzLmZsYWcgfHwgIXRoaXMucGluY2hGbGFnIHx8IHIubGVuZ3RoIDwgMikpIHtcbiAgICAgIHZhciBzID0gdGhpcy5nZXRDdXJyZW50U3RvcmUoKTtcbiAgICAgIHRoaXMuaXNQaW5jaCA9ICEwLCB0aGlzLmVtaXQoXCJwaW5jaFwiLCBDdChDdCh7IGRhdGE6IHRoaXMuZGF0YSwgZGF0YXM6IHRoaXMuZGF0YSwgbW92ZW1lbnQ6IHRoaXMuZ2V0TW92ZW1lbnQociksIGFuZ2xlOiBzLmdldEFuZ2xlKHIpLCByb3RhdGlvbjogcy5nZXRSb3RhdGlvbihyKSwgdG91Y2hlczogcy5nZXRQb3NpdGlvbnMociksIHNjYWxlOiBzLmdldFNjYWxlKHIpLCBkaXN0YW5jZTogcy5nZXREaXN0YW5jZShyKSB9LCBzLmdldFBvc2l0aW9uKHIpKSwgeyBpbnB1dEV2ZW50OiBuLCBpc1RydXN0ZWQ6IHRoaXMuX2lzVHJ1c3RlZCB9KSk7XG4gICAgfVxuICB9LCBlLnByb3RvdHlwZS5vblBpbmNoRW5kID0gZnVuY3Rpb24obikge1xuICAgIGlmICh0aGlzLnBpbmNoRmxhZykge1xuICAgICAgdmFyIHIgPSB0aGlzLmlzUGluY2g7XG4gICAgICB0aGlzLmlzUGluY2ggPSAhMSwgdGhpcy5waW5jaEZsYWcgPSAhMTtcbiAgICAgIHZhciBzID0gdGhpcy5nZXRDdXJyZW50U3RvcmUoKTtcbiAgICAgIHRoaXMuZW1pdChcInBpbmNoRW5kXCIsIEN0KEN0KHsgZGF0YTogdGhpcy5kYXRhLCBkYXRhczogdGhpcy5kYXRhLCBpc1BpbmNoOiByLCB0b3VjaGVzOiBzLmdldFBvc2l0aW9ucygpIH0sIHMuZ2V0UG9zaXRpb24oKSksIHsgaW5wdXRFdmVudDogbiB9KSk7XG4gICAgfVxuICB9LCBlLnByb3RvdHlwZS5nZXRDdXJyZW50U3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRTdG9yZXNbMF07XG4gIH0sIGUucHJvdG90eXBlLm1vdmVDbGllbnRzID0gZnVuY3Rpb24obiwgciwgcykge1xuICAgIHZhciBvID0gdGhpcy5fZ2V0UG9zaXRpb24obiwgcyksIGkgPSB0aGlzLmlzRHJhZztcbiAgICAoby5kZWx0YVggfHwgby5kZWx0YVkpICYmICh0aGlzLmlzRHJhZyA9ICEwKTtcbiAgICB2YXIgYSA9ICExO1xuICAgIHJldHVybiAhaSAmJiB0aGlzLmlzRHJhZyAmJiAoYSA9ICEwKSwgQ3QoQ3QoeyBkYXRhOiB0aGlzLmRhdGEsIGRhdGFzOiB0aGlzLmRhdGEgfSwgbyksIHsgbW92ZW1lbnQ6IHRoaXMuZ2V0TW92ZW1lbnQobiksIGlzRHJhZzogdGhpcy5pc0RyYWcsIGlzUGluY2g6IHRoaXMuaXNQaW5jaCwgaXNTY3JvbGw6ICExLCBpc01vdXNlRXZlbnQ6IHRoaXMuX2lzTW91c2VFdmVudCwgaXNTZWNvbmRhcnlCdXR0b246IHRoaXMuX2lzU2Vjb25kYXJ5QnV0dG9uLCBpbnB1dEV2ZW50OiByLCBpc1RydXN0ZWQ6IHRoaXMuX2lzVHJ1c3RlZCwgaXNGaXJzdERyYWc6IGEgfSk7XG4gIH0sIGUucHJvdG90eXBlLl9hZGRTdG9yZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLmNsaWVudFN0b3Jlcy5zcGxpY2UoMCwgMCwgbik7XG4gIH0sIGUucHJvdG90eXBlLl9nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICB2YXIgcyA9IHRoaXMuZ2V0Q3VycmVudFN0b3JlKCksIG8gPSBzLmdldFBvc2l0aW9uKG4sIHIpLCBpID0gdGhpcy5jbGllbnRTdG9yZXMuc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uKGwsIHUpIHtcbiAgICAgIHZhciBmID0gdS5nZXRQb3NpdGlvbigpO1xuICAgICAgcmV0dXJuIGwuZGlzdFggKz0gZi5kaXN0WCwgbC5kaXN0WSArPSBmLmRpc3RZLCBsO1xuICAgIH0sIG8pLCBhID0gaS5kaXN0WCwgYyA9IGkuZGlzdFk7XG4gICAgcmV0dXJuIEN0KEN0KHt9LCBvKSwgeyBkaXN0WDogYSwgZGlzdFk6IGMgfSk7XG4gIH0sIGUucHJvdG90eXBlLl9hdHRjaERyYWdFdmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gdGhpcy5fd2luZG93LCByID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lciwgcyA9IHtcbiAgICAgIHBhc3NpdmU6ICExXG4gICAgfTtcbiAgICB0aGlzLl9pc0RyYWdBUEkgJiYgKFB0KHIsIFwiZHJhZ292ZXJcIiwgdGhpcy5vbkRyYWcsIHMpLCBQdChuLCBcImRyYWdlbmRcIiwgdGhpcy5vbkRyYWdFbmQpKSwgdGhpcy5fdXNlTW91c2UgJiYgKFB0KHIsIFwibW91c2Vtb3ZlXCIsIHRoaXMub25EcmFnKSwgUHQobiwgXCJtb3VzZXVwXCIsIHRoaXMub25EcmFnRW5kKSksIHRoaXMuX3VzZVRvdWNoICYmIChQdChyLCBcInRvdWNobW92ZVwiLCB0aGlzLm9uRHJhZywgcyksIFB0KG4sIFwidG91Y2hlbmRcIiwgdGhpcy5vbkRyYWdFbmQsIHMpLCBQdChuLCBcInRvdWNoY2FuY2VsXCIsIHRoaXMub25EcmFnRW5kLCBzKSk7XG4gIH0sIGUucHJvdG90eXBlLl9kZXR0YWNoRHJhZ0V2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSB0aGlzLl93aW5kb3csIHIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMuX2lzRHJhZ0FQSSAmJiAoTXQociwgXCJkcmFnb3ZlclwiLCB0aGlzLm9uRHJhZyksIE10KG4sIFwiZHJhZ2VuZFwiLCB0aGlzLm9uRHJhZ0VuZCkpLCB0aGlzLl91c2VNb3VzZSAmJiAoTXQociwgXCJtb3VzZW1vdmVcIiwgdGhpcy5vbkRyYWcpLCBNdChuLCBcIm1vdXNldXBcIiwgdGhpcy5vbkRyYWdFbmQpKSwgdGhpcy5fdXNlVG91Y2ggJiYgKE10KHIsIFwidG91Y2hzdGFydFwiLCB0aGlzLm9uRHJhZ1N0YXJ0KSwgTXQociwgXCJ0b3VjaG1vdmVcIiwgdGhpcy5vbkRyYWcpLCBNdChuLCBcInRvdWNoZW5kXCIsIHRoaXMub25EcmFnRW5kKSwgTXQobiwgXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLm9uRHJhZ0VuZCkpO1xuICB9LCBlLnByb3RvdHlwZS5fYWxsb3dNb3VzZUV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcHJldmVudE1vdXNlRXZlbnQgPSAhMSwgY2xlYXJUaW1lb3V0KHRoaXMuX3ByZXZlbnRNb3VzZUV2ZW50SWQpO1xuICB9LCBlO1xufShDcyk7XG5mdW5jdGlvbiBwZih0LCBlKSB7XG4gIGNvbnN0IHIgPSBndChlID8gNCA6IDMpLCBzID0gYG1hdHJpeCR7ZSA/IFwiM2RcIiA6IFwiXCJ9KCR7ci5qb2luKFwiLFwiKX0pYDtcbiAgcmV0dXJuIHQgPT09IHMgfHwgdCA9PT0gXCJtYXRyaXgoMSwwLDAsMSwwLDApXCI7XG59XG5jb25zdCByYSA9IHtcbiAgaXNQaW5jaDogITAsXG4gIG5hbWU6IFwiYmVmb3JlUmVuZGVyYWJsZVwiLFxuICBwcm9wczogW10sXG4gIGV2ZW50czogW1xuICAgIFwiYmVmb3JlUmVuZGVyU3RhcnRcIixcbiAgICBcImJlZm9yZVJlbmRlclwiLFxuICAgIFwiYmVmb3JlUmVuZGVyRW5kXCIsXG4gICAgXCJiZWZvcmVSZW5kZXJHcm91cFN0YXJ0XCIsXG4gICAgXCJiZWZvcmVSZW5kZXJHcm91cFwiLFxuICAgIFwiYmVmb3JlUmVuZGVyR3JvdXBFbmRcIlxuICBdLFxuICBkcmFnUmVsYXRpb246IFwid2Vha1wiLFxuICBzZXRUcmFuc2Zvcm0odCwgZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzM2Q6IG4sXG4gICAgICB0YXJnZXRNYXRyaXg6IHIsXG4gICAgICBpbmxpbmVUcmFuc2Zvcm06IHNcbiAgICB9ID0gdC5zdGF0ZSwgbyA9IG4gPyBgbWF0cml4M2QoJHtyLmpvaW4oXCIsXCIpfSlgIDogYG1hdHJpeCgke2VpKHIsICEwKX0pYCwgaSA9ICFzIHx8IHMgPT09IFwibm9uZVwiID8gbyA6IHM7XG4gICAgZS5kYXRhcy5zdGFydFRyYW5zZm9ybXMgPSBwZihpLCBuKSA/IFtdIDogY2UoaSk7XG4gIH0sXG4gIHJlc2V0U3R5bGUodCkge1xuICAgIGNvbnN0IGUgPSB0LmRhdGFzO1xuICAgIGUubmV4dFN0eWxlID0ge30sIGUubmV4dFRyYW5zZm9ybXMgPSB0LmRhdGFzLnN0YXJ0VHJhbnNmb3JtcywgZS5uZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzID0gW107XG4gIH0sXG4gIGZpbGxEcmFnU3RhcnRQYXJhbXModCwgZSkge1xuICAgIHJldHVybiBldCh0LCBlLCB7XG4gICAgICBzZXRUcmFuc2Zvcm06IChuKSA9PiB7XG4gICAgICAgIGUuZGF0YXMuc3RhcnRUcmFuc2Zvcm1zID0gUnQobikgPyBuIDogY2Uobik7XG4gICAgICB9LFxuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2hcbiAgICB9KTtcbiAgfSxcbiAgZmlsbERyYWdQYXJhbXModCwgZSkge1xuICAgIHJldHVybiBldCh0LCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaFxuICAgIH0pO1xuICB9LFxuICBkcmFnU3RhcnQodCwgZSkge1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtKHQsIGUpLCB0aGlzLnJlc2V0U3R5bGUoZSksIGoodCwgXCJvbkJlZm9yZVJlbmRlclN0YXJ0XCIsIHRoaXMuZmlsbERyYWdTdGFydFBhcmFtcyh0LCBlKSk7XG4gIH0sXG4gIGRyYWcodCwgZSkge1xuICAgIGUuZGF0YXMuc3RhcnRUcmFuc2Zvcm1zIHx8IHRoaXMuc2V0VHJhbnNmb3JtKHQsIGUpLCB0aGlzLnJlc2V0U3R5bGUoZSksIGoodCwgXCJvbkJlZm9yZVJlbmRlclwiLCBldCh0LCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaFxuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0VuZCh0LCBlKSB7XG4gICAgZS5kYXRhcy5zdGFydFRyYW5zZm9ybXMgfHwgKHRoaXMuc2V0VHJhbnNmb3JtKHQsIGUpLCB0aGlzLnJlc2V0U3R5bGUoZSkpLCBqKHQsIFwib25CZWZvcmVSZW5kZXJFbmRcIiwgZXQodCwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICBpc0RyYWc6IGUuaXNEcmFnXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXBTdGFydCh0LCBlKSB7XG4gICAgdGhpcy5kcmFnU3RhcnQodCwgZSk7XG4gICAgY29uc3QgbiA9IEh0KHQsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKSwgciA9IHQubW92ZWFibGVzLCBzID0gbi5tYXAoKG8sIGkpID0+IHtcbiAgICAgIGNvbnN0IGEgPSByW2ldO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0VHJhbnNmb3JtKGEsIG8pLCB0aGlzLnJlc2V0U3R5bGUobyksIHRoaXMuZmlsbERyYWdTdGFydFBhcmFtcyhhLCBvKTtcbiAgICB9KTtcbiAgICBqKHQsIFwib25CZWZvcmVSZW5kZXJHcm91cFN0YXJ0XCIsIGV0KHQsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxuICAgICAgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzLFxuICAgICAgc2V0VHJhbnNmb3JtKCkge1xuICAgICAgfSxcbiAgICAgIGV2ZW50czogc1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwKHQsIGUpIHtcbiAgICB0aGlzLmRyYWcodCwgZSk7XG4gICAgY29uc3QgbiA9IEh0KHQsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKSwgciA9IHQubW92ZWFibGVzLCBzID0gbi5tYXAoKG8sIGkpID0+IHtcbiAgICAgIGNvbnN0IGEgPSByW2ldO1xuICAgICAgcmV0dXJuIHRoaXMucmVzZXRTdHlsZShvKSwgdGhpcy5maWxsRHJhZ1BhcmFtcyhhLCBvKTtcbiAgICB9KTtcbiAgICBqKHQsIFwib25CZWZvcmVSZW5kZXJHcm91cFwiLCBldCh0LCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogc1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwRW5kKHQsIGUpIHtcbiAgICB0aGlzLmRyYWdFbmQodCwgZSksIGoodCwgXCJvbkJlZm9yZVJlbmRlckdyb3VwRW5kXCIsIGV0KHQsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxuICAgICAgaXNEcmFnOiBlLmlzRHJhZyxcbiAgICAgIHRhcmdldHM6IHQucHJvcHMudGFyZ2V0c1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ1N0YXJ0KHQsIGUpO1xuICB9LFxuICBkcmFnQ29udHJvbCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZyh0LCBlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdFbmQodCwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xTdGFydCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwU3RhcnQodCwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2wodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cCh0LCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwRW5kKHQsIGUpO1xuICB9XG59LCBzYSA9IHtcbiAgbmFtZTogXCJyZW5kZXJhYmxlXCIsXG4gIHByb3BzOiBbXSxcbiAgZXZlbnRzOiBbXG4gICAgXCJyZW5kZXJTdGFydFwiLFxuICAgIFwicmVuZGVyXCIsXG4gICAgXCJyZW5kZXJFbmRcIixcbiAgICBcInJlbmRlckdyb3VwU3RhcnRcIixcbiAgICBcInJlbmRlckdyb3VwXCIsXG4gICAgXCJyZW5kZXJHcm91cEVuZFwiXG4gIF0sXG4gIGRyYWdSZWxhdGlvbjogXCJ3ZWFrXCIsXG4gIGRyYWdTdGFydCh0LCBlKSB7XG4gICAgaih0LCBcIm9uUmVuZGVyU3RhcnRcIiwgZXQodCwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2hcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWcodCwgZSkge1xuICAgIGoodCwgXCJvblJlbmRlclwiLCB0aGlzLmZpbGxEcmFnUGFyYW1zKHQsIGUpKTtcbiAgfSxcbiAgZHJhZ0FmdGVyKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnKHQsIGUpO1xuICB9LFxuICBkcmFnRW5kKHQsIGUpIHtcbiAgICBqKHQsIFwib25SZW5kZXJFbmRcIiwgdGhpcy5maWxsRHJhZ0VuZFBhcmFtcyh0LCBlKSk7XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0KHQsIGUpIHtcbiAgICBqKHQsIFwib25SZW5kZXJHcm91cFN0YXJ0XCIsIGV0KHQsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxuICAgICAgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXAodCwgZSkge1xuICAgIGNvbnN0IG4gPSBIdCh0LCBcImJlZm9yZVJlbmRlcmFibGVcIiwgZSksIHIgPSB0Lm1vdmVhYmxlcywgcyA9IG4ubWFwKChvLCBpKSA9PiB7XG4gICAgICBjb25zdCBhID0gcltpXTtcbiAgICAgIHJldHVybiB0aGlzLmZpbGxEcmFnUGFyYW1zKGEsIG8pO1xuICAgIH0pO1xuICAgIGoodCwgXCJvblJlbmRlckdyb3VwXCIsIGV0KHQsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxuICAgICAgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzLFxuICAgICAgdHJhbnNmb3JtOiBEbihlKSxcbiAgICAgIHRyYW5zZm9ybU9iamVjdDoge30sXG4gICAgICAuLi5JdChibihlKSksXG4gICAgICBldmVudHM6IHNcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZCh0LCBlKSB7XG4gICAgY29uc3QgbiA9IEh0KHQsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKSwgciA9IHQubW92ZWFibGVzLCBzID0gbi5tYXAoKG8sIGkpID0+IHtcbiAgICAgIGNvbnN0IGEgPSByW2ldO1xuICAgICAgcmV0dXJuIHRoaXMuZmlsbERyYWdFbmRQYXJhbXMoYSwgbyk7XG4gICAgfSk7XG4gICAgaih0LCBcIm9uUmVuZGVyR3JvdXBFbmRcIiwgZXQodCwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICBpc0RyYWc6IGUuaXNEcmFnLFxuICAgICAgdGFyZ2V0czogdC5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBzLFxuICAgICAgdHJhbnNmb3JtT2JqZWN0OiB7fSxcbiAgICAgIHRyYW5zZm9ybTogRG4oZSksXG4gICAgICAuLi5JdChibihlKSlcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydCh0LCBlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2wodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWcodCwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sQWZ0ZXIodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdBZnRlcih0LCBlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdFbmQodCwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xTdGFydCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwU3RhcnQodCwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2wodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cCh0LCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwRW5kKHQsIGUpO1xuICB9LFxuICBmaWxsRHJhZ1BhcmFtcyh0LCBlKSB7XG4gICAgY29uc3QgbiA9IHt9O1xuICAgIHJldHVybiAkZShHbihlKSB8fCBbXSkuZm9yRWFjaCgocikgPT4ge1xuICAgICAgbltyLm5hbWVdID0gci5mdW5jdGlvblZhbHVlO1xuICAgIH0pLCBldCh0LCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIHRyYW5zZm9ybU9iamVjdDogbixcbiAgICAgIHRyYW5zZm9ybTogRG4oZSksXG4gICAgICAuLi5JdChibihlKSlcbiAgICB9KTtcbiAgfSxcbiAgZmlsbERyYWdFbmRQYXJhbXModCwgZSkge1xuICAgIGNvbnN0IG4gPSB7fTtcbiAgICByZXR1cm4gJGUoR24oZSkgfHwgW10pLmZvckVhY2goKHIpID0+IHtcbiAgICAgIG5bci5uYW1lXSA9IHIuZnVuY3Rpb25WYWx1ZTtcbiAgICB9KSwgZXQodCwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICBpc0RyYWc6IGUuaXNEcmFnLFxuICAgICAgdHJhbnNmb3JtT2JqZWN0OiBuLFxuICAgICAgdHJhbnNmb3JtOiBEbihlKSxcbiAgICAgIC4uLkl0KGJuKGUpKVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gc24odCwgZSwgbiwgciwgcywgbywgaSkge1xuICBvLmNsaWVudERpc3RYID0gby5kaXN0WCwgby5jbGllbnREaXN0WSA9IG8uZGlzdFk7XG4gIGNvbnN0IGEgPSBzID09PSBcIlN0YXJ0XCIsIGMgPSBzID09PSBcIkVuZFwiLCBsID0gcyA9PT0gXCJBZnRlclwiLCB1ID0gdC5zdGF0ZS50YXJnZXQsIGYgPSBvLmlzUmVxdWVzdCwgZCA9IHIuaW5kZXhPZihcIkNvbnRyb2xcIikgPiAtMTtcbiAgaWYgKCF1IHx8IGEgJiYgZCAmJiAhZiAmJiB0LmFyZWFFbGVtZW50ID09PSBvLmlucHV0RXZlbnQudGFyZ2V0KVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgcCA9IFsuLi5lXTtcbiAgaWYgKGYpIHtcbiAgICBjb25zdCBQID0gby5yZXF1ZXN0QWJsZTtcbiAgICBwLnNvbWUoKF8pID0+IF8ubmFtZSA9PT0gUCkgfHwgcC5wdXNoKC4uLnQucHJvcHMuYWJsZXMuZmlsdGVyKChfKSA9PiBfLm5hbWUgPT09IFApKTtcbiAgfVxuICBpZiAoIXAubGVuZ3RoIHx8IHAuZXZlcnkoKFApID0+IFAuZHJhZ1JlbGF0aW9uKSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGcgPSBvLmlucHV0RXZlbnQ7XG4gIGxldCBoO1xuICBjICYmIGcgJiYgKGggPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KG8uY2xpZW50WCwgby5jbGllbnRZKSB8fCBnLnRhcmdldCk7XG4gIGxldCB2ID0gITE7XG4gIGNvbnN0IG0gPSAoKSA9PiB7XG4gICAgdmFyIFA7XG4gICAgdiA9ICEwLCAoUCA9IG8uc3RvcCkgPT0gbnVsbCB8fCBQLmNhbGwobyk7XG4gIH0sIFMgPSBhICYmICghdC50YXJnZXRHZXN0byB8fCAhdC5jb250cm9sR2VzdG8gfHwgIXQudGFyZ2V0R2VzdG8uaXNGbGFnKCkgfHwgIXQuY29udHJvbEdlc3RvLmlzRmxhZygpKTtcbiAgUyAmJiB0LnVwZGF0ZVJlY3QocywgITAsICExKTtcbiAgY29uc3QgeCA9IG8uZGF0YXMsIEMgPSBkID8gXCJjb250cm9sR2VzdG9cIiA6IFwidGFyZ2V0R2VzdG9cIiwgRSA9IHRbQ10sIEQgPSAoUCwgXywgTykgPT4ge1xuICAgIGlmICghKF8gaW4gUCkgfHwgRSAhPT0gdFtDXSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBUID0gUC5uYW1lLCB3ID0geFtUXSB8fCAoeFtUXSA9IHt9KTtcbiAgICBpZiAoYSAmJiAody5pc0V2ZW50U3RhcnQgPSAhTyB8fCAhUFtPXSB8fCBQW09dKHQsIG8pKSwgIXcuaXNFdmVudFN0YXJ0KVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGsgPSBQW19dKHQsIHtcbiAgICAgIC4uLm8sXG4gICAgICBzdG9wOiBtLFxuICAgICAgZGF0YXM6IHcsXG4gICAgICBvcmlnaW5hbERhdGFzOiB4LFxuICAgICAgaW5wdXRUYXJnZXQ6IGhcbiAgICB9KTtcbiAgICByZXR1cm4gdC5fZW1pdHRlci5vZmYoKSwgYSAmJiBrID09PSAhMSAmJiAody5pc0V2ZW50U3RhcnQgPSAhMSksIGs7XG4gIH07XG4gIFMgJiYgcC5mb3JFYWNoKChQKSA9PiB7XG4gICAgUC51bnNldCAmJiBQLnVuc2V0KHQpO1xuICB9KSwgRChyYSwgYGRyYWcke3J9JHtzfWApO1xuICBsZXQgUiA9IDAsIHkgPSAwO1xuICBuLmZvckVhY2goKFApID0+IHtcbiAgICBpZiAodilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBfID0gYCR7UH0ke3J9JHtzfWAsIE8gPSBgJHtQfSR7cn1Db25kaXRpb25gO1xuICAgIHMgPT09IFwiXCIgJiYgIWYgJiYgeHUodC5zdGF0ZSwgbyk7XG4gICAgbGV0IFQgPSBwLmZpbHRlcigoSSkgPT4gSVtfXSk7XG4gICAgVCA9IFQuZmlsdGVyKChJLCAkKSA9PiBJLm5hbWUgJiYgVC5pbmRleE9mKEkpID09PSAkKTtcbiAgICBjb25zdCBrID0gVC5maWx0ZXIoKEkpID0+IEQoSSwgXywgTykpLmxlbmd0aDtcbiAgICB2ICYmICsrUiwgayAmJiArK3ksICF2ICYmIGEgJiYgVC5sZW5ndGggJiYgIWsgJiYgKFIgKz0gVC5maWx0ZXIoKEkpID0+IHtcbiAgICAgIGNvbnN0ICQgPSBJLm5hbWU7XG4gICAgICByZXR1cm4geFskXS5pc0V2ZW50U3RhcnQgPyBJLmRyYWdSZWxhdGlvbiAhPT0gXCJzdHJvbmdcIiA6ICExO1xuICAgIH0pLmxlbmd0aCA/IDEgOiAwKTtcbiAgfSksICghbCB8fCB5KSAmJiBEKHNhLCBgZHJhZyR7cn0ke3N9YCk7XG4gIGNvbnN0IE0gPSBFICE9PSB0W0NdIHx8IFIgPT09IG4ubGVuZ3RoO1xuICByZXR1cm4gKGMgfHwgdiB8fCBNKSAmJiAodC5zdGF0ZS5nZXN0b3MgPSB7fSwgdC5tb3ZlYWJsZXMgJiYgdC5tb3ZlYWJsZXMuZm9yRWFjaCgoUCkgPT4ge1xuICAgIFAuc3RhdGUuZ2VzdG9zID0ge307XG4gIH0pLCBwLmZvckVhY2goKFApID0+IHtcbiAgICBQLnVuc2V0ICYmIFAudW5zZXQodCk7XG4gIH0pKSwgYSAmJiAhTSAmJiAhZiAmJiB5ICYmIHQucHJvcHMucHJldmVudERlZmF1bHQgJiYgKG8gPT0gbnVsbCB8fCBvLnByZXZlbnREZWZhdWx0KCkpLCB0LmlzVW5tb3VudGVkIHx8IE0gPyAhMSA6ICgoIWEgJiYgeSAmJiAhaSB8fCBjKSAmJiAodC5wcm9wcy5mbHVzaFN5bmMgfHwgQmkpKCgpID0+IHtcbiAgICB0LnVwZGF0ZVJlY3QoYyA/IHMgOiBcIlwiLCAhMCwgITEpLCB0LmZvcmNlVXBkYXRlKCk7XG4gIH0pLCAhYSAmJiAhYyAmJiAhbCAmJiB5ICYmICFpICYmIHNuKHQsIGUsIG4sIHIsIHMgKyBcIkFmdGVyXCIsIG8pLCAhMCk7XG59XG5mdW5jdGlvbiBScyh0LCBlKSB7XG4gIHJldHVybiAobiwgciA9IG4uaW5wdXRFdmVudC50YXJnZXQpID0+IHtcbiAgICB2YXIgYTtcbiAgICBjb25zdCBzID0gciwgbyA9IHQuYXJlYUVsZW1lbnQsIGkgPSB0Ll9kcmFnVGFyZ2V0O1xuICAgIHJldHVybiAhaSB8fCAhZSAmJiAoKGEgPSB0LmNvbnRyb2xHZXN0bykgIT0gbnVsbCAmJiBhLmlzRmxhZygpKSA/ICExIDogcyA9PT0gaSB8fCBpLmNvbnRhaW5zKHMpIHx8IHMgPT09IG8gfHwgIXQuaXNNb3ZlYWJsZUVsZW1lbnQocykgJiYgIXQuY29udHJvbEJveC5jb250YWlucyhzKSB8fCBidChzLCBcIm1vdmVhYmxlLWFyZWFcIikgfHwgYnQocywgXCJtb3ZlYWJsZS1wYWRkaW5nXCIpIHx8IGJ0KHMsIFwibW92ZWFibGUtZWRnZURyYWdnYWJsZVwiKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG9hKHQsIGUsIG4pIHtcbiAgY29uc3QgciA9IHQuY29udHJvbEJveCwgcyA9IFtdLCBvID0gdC5wcm9wcywgaSA9IG8uZHJhZ0FyZWEsIGEgPSB0LnN0YXRlLnRhcmdldCwgYyA9IG8uZHJhZ1RhcmdldDtcbiAgcy5wdXNoKHIpLCAoIWkgfHwgYykgJiYgcy5wdXNoKGUpLCAhaSAmJiBjICYmIGEgJiYgZSAhPT0gYSAmJiBvLmRyYWdUYXJnZXRTZWxmICYmIHMucHVzaChhKTtcbiAgY29uc3QgbCA9IFJzKHQpO1xuICByZXR1cm4gYWEodCwgcywgXCJ0YXJnZXRBYmxlc1wiLCBuLCB7XG4gICAgZHJhZ1N0YXJ0OiBsLFxuICAgIHBpbmNoU3RhcnQ6IGxcbiAgfSk7XG59XG5mdW5jdGlvbiBpYSh0LCBlKSB7XG4gIGNvbnN0IG4gPSB0LmNvbnRyb2xCb3gsIHIgPSBbXTtcbiAgci5wdXNoKG4pO1xuICBjb25zdCBzID0gUnModCwgITApLCBvID0gKGksIGEgPSBpLmlucHV0RXZlbnQudGFyZ2V0KSA9PiBhID09PSBuID8gITAgOiAhcyhpLCBhKTtcbiAgcmV0dXJuIGFhKHQsIHIsIFwiY29udHJvbEFibGVzXCIsIGUsIHtcbiAgICBkcmFnU3RhcnQ6IG8sXG4gICAgcGluY2hTdGFydDogb1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFhKHQsIGUsIG4sIHIsIHMgPSB7fSkge1xuICBjb25zdCBvID0gbiA9PT0gXCJ0YXJnZXRBYmxlc1wiLCB7XG4gICAgcGluY2hPdXRzaWRlOiBpLFxuICAgIHBpbmNoVGhyZXNob2xkOiBhLFxuICAgIHByZXZlbnRDbGlja0V2ZW50T25EcmFnOiBjLFxuICAgIHByZXZlbnRDbGlja0RlZmF1bHQ6IGwsXG4gICAgY2hlY2tJbnB1dDogdSxcbiAgICBkcmFnRm9jdXNlZElucHV0OiBmLFxuICAgIHByZXZlbnREZWZhdWx0OiBkID0gITAsXG4gICAgcHJldmVudFJpZ2h0Q2xpY2s6IHAgPSAhMCxcbiAgICBwcmV2ZW50V2hlZWxDbGljazogZyA9ICEwLFxuICAgIGRyYWdDb250YWluZXI6IGhcbiAgfSA9IHQucHJvcHMsIHYgPSBadChoLCAhMCksIG0gPSB7XG4gICAgcHJldmVudERlZmF1bHQ6IGQsXG4gICAgcHJldmVudFJpZ2h0Q2xpY2s6IHAsXG4gICAgcHJldmVudFdoZWVsQ2xpY2s6IGcsXG4gICAgY29udGFpbmVyOiB2IHx8IGFlKHQuZ2V0Q29udHJvbEJveEVsZW1lbnQoKSksXG4gICAgcGluY2hUaHJlc2hvbGQ6IGEsXG4gICAgcGluY2hPdXRzaWRlOiBpLFxuICAgIHByZXZlbnRDbGlja0V2ZW50T25EcmFnOiBvID8gYyA6ICExLFxuICAgIHByZXZlbnRDbGlja0V2ZW50T25EcmFnU3RhcnQ6IG8gPyBsIDogITEsXG4gICAgcHJldmVudENsaWNrRXZlbnRCeUNvbmRpdGlvbjogbyA/IG51bGwgOiAoQykgPT4gdC5jb250cm9sQm94LmNvbnRhaW5zKEMudGFyZ2V0KSxcbiAgICBjaGVja0lucHV0OiBvID8gdSA6ICExLFxuICAgIGRyYWdGb2N1c2VkSW5wdXQ6IGZcbiAgfSwgUyA9IG5ldyBkZihlLCBtKSwgeCA9IHIgPT09IFwiQ29udHJvbFwiO1xuICByZXR1cm4gW1wiZHJhZ1wiLCBcInBpbmNoXCJdLmZvckVhY2goKEMpID0+IHtcbiAgICBbXCJTdGFydFwiLCBcIlwiLCBcIkVuZFwiXS5mb3JFYWNoKChFKSA9PiB7XG4gICAgICBTLm9uKGAke0N9JHtFfWAsIChEKSA9PiB7XG4gICAgICAgIHZhciBPO1xuICAgICAgICBjb25zdCBSID0gRC5ldmVudFR5cGUsIHkgPSBDID09PSBcImRyYWdcIiAmJiBELmlzUGluY2g7XG4gICAgICAgIGlmIChzW1JdICYmICFzW1JdKEQpKSB7XG4gICAgICAgICAgRC5zdG9wKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgTSA9IEMgPT09IFwiZHJhZ1wiID8gW0NdIDogW1wiZHJhZ1wiLCBDXSwgUCA9IFsuLi50W25dXTtcbiAgICAgICAgc24odCwgUCwgTSwgciwgRSwgRCkgPyAodC5wcm9wcy5zdG9wUHJvcGFnYXRpb24gfHwgRSA9PT0gXCJTdGFydFwiICYmIHgpICYmICgoTyA9IEQgPT0gbnVsbCA/IHZvaWQgMCA6IEQuaW5wdXRFdmVudCkgPT0gbnVsbCB8fCBPLnN0b3BQcm9wYWdhdGlvbigpKSA6IEQuc3RvcCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pLCBTO1xufVxuY2xhc3MgZ2Yge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByKSB7XG4gICAgWCh0aGlzLCBcImFibGVzXCIsIFtdKTtcbiAgICBYKHRoaXMsIFwiX29uRXZlbnRcIiwgKGUpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmV2ZW50TmFtZSwgciA9IHRoaXMubW92ZWFibGU7XG4gICAgICByLnN0YXRlLmRpc2FibGVOYXRpdmVFdmVudCB8fCB0aGlzLmFibGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgc1tuXShyLCB7XG4gICAgICAgICAgaW5wdXRFdmVudDogZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMudGFyZ2V0ID0gZSwgdGhpcy5tb3ZlYWJsZSA9IG4sIHRoaXMuZXZlbnROYW1lID0gciwgZS5hZGRFdmVudExpc3RlbmVyKHIudG9Mb3dlckNhc2UoKSwgdGhpcy5fb25FdmVudCk7XG4gIH1cbiAgc2V0QWJsZXMoZSkge1xuICAgIHRoaXMuYWJsZXMgPSBlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIHRoaXMuZXZlbnROYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICB0aGlzLl9vbkV2ZW50XG4gICAgKSwgdGhpcy50YXJnZXQgPSBudWxsLCB0aGlzLm1vdmVhYmxlID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gaGYodCkge1xuICBmb3IgKHZhciBlID0gNTM4MSwgbiA9IHQubGVuZ3RoOyBuOyApXG4gICAgZSA9IGUgKiAzMyBeIHQuY2hhckNvZGVBdCgtLW4pO1xuICByZXR1cm4gZSA+Pj4gMDtcbn1cbnZhciB2ZiA9IGhmO1xuZnVuY3Rpb24gbWYodCkge1xuICByZXR1cm4gdmYodCkudG9TdHJpbmcoMzYpO1xufVxuZnVuY3Rpb24geGYodCkge1xuICBpZiAodCAmJiB0LmdldFJvb3ROb2RlKSB7XG4gICAgdmFyIGUgPSB0LmdldFJvb3ROb2RlKCk7XG4gICAgaWYgKGUubm9kZVR5cGUgPT09IDExKVxuICAgICAgcmV0dXJuIGU7XG4gIH1cbn1cbmZ1bmN0aW9uIFNmKHQsIGUsIG4pIHtcbiAgcmV0dXJuIG4ub3JpZ2luYWwgPyBlIDogZS5yZXBsYWNlKC8oW159O3tcXHN9XVtefTt7XSp8Xlxccyopey9tZywgZnVuY3Rpb24ociwgcykge1xuICAgIHZhciBvID0gcy50cmltKCk7XG4gICAgcmV0dXJuIChvID8geGUobykgOiBbXCJcIl0pLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgYSA9IGkudHJpbSgpO1xuICAgICAgcmV0dXJuIGEuaW5kZXhPZihcIkBcIikgPT09IDAgPyBhIDogYS5pbmRleE9mKFwiOmdsb2JhbFwiKSA+IC0xID8gYS5yZXBsYWNlKC9cXDpnbG9iYWwvZywgXCJcIikgOiBhLmluZGV4T2YoXCI6aG9zdFwiKSA+IC0xID8gXCJcIi5jb25jYXQoYS5yZXBsYWNlKC9cXDpob3N0L2csIFwiLlwiLmNvbmNhdCh0KSkpIDogYSA/IFwiLlwiLmNvbmNhdCh0LCBcIiBcIikuY29uY2F0KGEpIDogXCIuXCIuY29uY2F0KHQpO1xuICAgIH0pLmpvaW4oXCIsIFwiKSArIFwiIHtcIjtcbiAgfSk7XG59XG5mdW5jdGlvbiBFZih0LCBlLCBuLCByLCBzKSB7XG4gIHZhciBvID0gdHMociksIGkgPSBvLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIGkuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvY3NzXCIpLCBpLnNldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVkLWlkXCIsIHQpLCBpLnNldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVkLWNvdW50XCIsIFwiMVwiKSwgbi5ub25jZSAmJiBpLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG4ubm9uY2UpLCBpLmlubmVySFRNTCA9IFNmKHQsIGUsIG4pLCAocyB8fCBvLmhlYWQgfHwgby5ib2R5KS5hcHBlbmRDaGlsZChpKSwgaTtcbn1cbmZ1bmN0aW9uIENmKHQpIHtcbiAgdmFyIGUgPSBcInJDU1wiICsgbWYodCk7XG4gIHJldHVybiB7XG4gICAgY2xhc3NOYW1lOiBlLFxuICAgIGluamVjdDogZnVuY3Rpb24obiwgcikge1xuICAgICAgciA9PT0gdm9pZCAwICYmIChyID0ge30pO1xuICAgICAgdmFyIHMgPSB4ZihuKSwgbyA9IChzIHx8IG4ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1zdHlsZWQtaWQ9XCInLmNvbmNhdChlLCAnXCJdJykpO1xuICAgICAgaWYgKCFvKVxuICAgICAgICBvID0gRWYoZSwgdCwgciwgbiwgcyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBwYXJzZUZsb2F0KG8uZ2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZWQtY291bnRcIikpIHx8IDA7XG4gICAgICAgIG8uc2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZWQtY291bnRcIiwgXCJcIi5jb25jYXQoaSArIDEpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhLCBjID0gcGFyc2VGbG9hdChvLmdldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVkLWNvdW50XCIpKSB8fCAwO1xuICAgICAgICAgIGMgPD0gMSA/IChvLnJlbW92ZSA/IG8ucmVtb3ZlKCkgOiAoYSA9IG8ucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgYSA9PT0gdm9pZCAwIHx8IGEucmVtb3ZlQ2hpbGQobyksIG8gPSBudWxsKSA6IG8uc2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZWQtY291bnRcIiwgXCJcIi5jb25jYXQoYyAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG52YXIgV3IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFdyID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgbiwgciA9IDEsIHMgPSBhcmd1bWVudHMubGVuZ3RoOyByIDwgczsgcisrKSB7XG4gICAgICBuID0gYXJndW1lbnRzW3JdO1xuICAgICAgZm9yICh2YXIgbyBpbiBuKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgbykgJiYgKGVbb10gPSBuW29dKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIFdyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gRGYodCwgZSkge1xuICB2YXIgbiA9IHt9O1xuICBmb3IgKHZhciByIGluIHQpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiBlLmluZGV4T2YocikgPCAwICYmIChuW3JdID0gdFtyXSk7XG4gIGlmICh0ICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBzID0gMCwgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7IHMgPCByLmxlbmd0aDsgcysrKVxuICAgIGUuaW5kZXhPZihyW3NdKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHQsIHJbc10pICYmIChuW3Jbc11dID0gdFtyW3NdXSk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gY2EodCwgZSkge1xuICB2YXIgbiA9IENmKGUpLCByID0gbi5jbGFzc05hbWU7XG4gIHJldHVybiBMYShmdW5jdGlvbihzLCBvKSB7XG4gICAgdmFyIGkgPSBzLmNsYXNzTmFtZSwgYSA9IGkgPT09IHZvaWQgMCA/IFwiXCIgOiBpO1xuICAgIHMuY3NwTm9uY2U7XG4gICAgdmFyIGMgPSBEZihzLCBbXCJjbGFzc05hbWVcIiwgXCJjc3BOb25jZVwiXSksIGwgPSBOYSgpO1xuICAgIHJldHVybiBXYShvLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsLmN1cnJlbnQ7XG4gICAgfSwgW10pLCBZYShmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1ID0gbi5pbmplY3QobC5jdXJyZW50LCB7XG4gICAgICAgIG5vbmNlOiBzLmNzcE5vbmNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdS5kZXN0cm95KCk7XG4gICAgICB9O1xuICAgIH0sIFtdKSwgQm4odCwgV3Ioe1xuICAgICAgcmVmOiBsLFxuICAgICAgXCJkYXRhLXN0eWxlZC1pZFwiOiByLFxuICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChhLCBcIiBcIikuY29uY2F0KHIpXG4gICAgfSwgYykpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGJmKHQsIGUsIG4gPSBlLCByKSB7XG4gIHZhciBJO1xuICBjb25zdCB7XG4gICAgbWF0cml4ZXM6IHMsXG4gICAgaXMzZDogbyxcbiAgICB0YXJnZXRNYXRyaXg6IGksXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBhLFxuICAgIHRhcmdldE9yaWdpbjogYyxcbiAgICBvZmZzZXRDb250YWluZXI6IGwsXG4gICAgaGFzRml4ZWQ6IHUsXG4gICAgem9vbTogZlxuICB9ID0gY2kodCwgZSksIHtcbiAgICBtYXRyaXhlczogZCxcbiAgICBpczNkOiBwLFxuICAgIG9mZnNldENvbnRhaW5lcjogZyxcbiAgICB6b29tOiBoXG4gIH0gPSB0bChsLCBuKSwgdiA9IHIsIG0gPSA0LCBTID0gdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwic3ZnXCIgJiYgXCJvd25lclNWR0VsZW1lbnRcIiBpbiB0O1xuICBsZXQgeCA9IGksIEMgPSBndChtKSwgRSA9IGd0KG0pLCBEID0gZ3QobSksIFIgPSBndChtKTtcbiAgY29uc3QgeSA9IHMubGVuZ3RoLCBNID0gZC5tYXAoKCQpID0+ICh7XG4gICAgLi4uJCxcbiAgICBtYXRyaXg6ICQubWF0cml4ID8gWy4uLiQubWF0cml4XSA6IHZvaWQgMFxuICB9KSkucmV2ZXJzZSgpO1xuICBzLnJldmVyc2UoKSwgIW8gJiYgdiAmJiAoeCA9IFV0KHgsIDMsIDQpLCBCcihzKSksICFwICYmIHYgJiYgQnIoTSksIE0uZm9yRWFjaCgoJCkgPT4ge1xuICAgIEUgPSBkdChFLCAkLm1hdHJpeCwgbSk7XG4gIH0pO1xuICBjb25zdCBQID0gbiB8fCBmZSh0KSwgXyA9ICgoSSA9IE1bMF0pID09IG51bGwgPyB2b2lkIDAgOiBJLnRhcmdldCkgfHwgZm4oUCwgUCwgITApLm9mZnNldFBhcmVudCwgTyA9IE0uc2xpY2UoMSkucmVkdWNlKCgkLCBHKSA9PiBkdCgkLCBHLm1hdHJpeCwgbSksIGd0KG0pKTtcbiAgcy5mb3JFYWNoKCgkLCBHKSA9PiB7XG4gICAgaWYgKHkgLSAyID09PSBHICYmIChEID0gQy5zbGljZSgpKSwgeSAtIDEgPT09IEcgJiYgKFIgPSBDLnNsaWNlKCkpLCAhJC5tYXRyaXgpIHtcbiAgICAgIGNvbnN0IEwgPSBzW0cgKyAxXSwgeiA9IGd1KFxuICAgICAgICAkLFxuICAgICAgICBMLFxuICAgICAgICBfLFxuICAgICAgICBtLFxuICAgICAgICBkdChPLCBDLCBtKVxuICAgICAgKTtcbiAgICAgICQubWF0cml4ID0gQ2UoeiwgbSk7XG4gICAgfVxuICAgIEMgPSBkdChDLCAkLm1hdHJpeCwgbSk7XG4gIH0pO1xuICBjb25zdCBUID0gIVMgJiYgbztcbiAgeCB8fCAoeCA9IGd0KFQgPyA0IDogMykpO1xuICBjb25zdCB3ID0gSm4oXG4gICAgUyAmJiB4Lmxlbmd0aCA9PT0gMTYgPyBVdCh4LCA0LCAzKSA6IHgsXG4gICAgVFxuICApLCBrID0gRTtcbiAgcmV0dXJuIEUgPSBRbyhFLCBtLCBtKSwge1xuICAgIGhhc1pvb206IGYgIT09IDEgfHwgaCAhPT0gMSxcbiAgICBoYXNGaXhlZDogdSxcbiAgICBtYXRyaXhlczogcyxcbiAgICByb290TWF0cml4OiBFLFxuICAgIG9yaWdpbmFsUm9vdE1hdHJpeDogayxcbiAgICBiZWZvcmVNYXRyaXg6IEQsXG4gICAgb2Zmc2V0TWF0cml4OiBSLFxuICAgIGFsbE1hdHJpeDogQyxcbiAgICB0YXJnZXRNYXRyaXg6IHgsXG4gICAgdGFyZ2V0VHJhbnNmb3JtOiB3LFxuICAgIGlubGluZVRyYW5zZm9ybTogdC5zdHlsZS50cmFuc2Zvcm0sXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBhLFxuICAgIHRhcmdldE9yaWdpbjogYyxcbiAgICBpczNkOiB2LFxuICAgIG9mZnNldENvbnRhaW5lcjogbCxcbiAgICBvZmZzZXRSb290Q29udGFpbmVyOiBnXG4gIH07XG59XG5mdW5jdGlvbiBsYSh0LCBlLCBuID0gZSwgcikge1xuICBsZXQgcyA9IDAsIG8gPSAwLCBpID0gMCwgYSA9IHt9O1xuICBjb25zdCBjID0ga2kodCk7XG4gIGlmICh0ICYmIChzID0gYy5vZmZzZXRXaWR0aCwgbyA9IGMub2Zmc2V0SGVpZ2h0KSwgdCkge1xuICAgIGNvbnN0IHUgPSBiZihcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgbixcbiAgICAgIHJcbiAgICAgIC8vIHByZXZNYXRyaXgsIHByZXZSb290TWF0cml4LCBwcmV2TixcbiAgICApLCBmID0ga2UoXG4gICAgICB1LmFsbE1hdHJpeCxcbiAgICAgIHUudHJhbnNmb3JtT3JpZ2luLFxuICAgICAgcyxcbiAgICAgIG9cbiAgICApO1xuICAgIGEgPSB7XG4gICAgICAuLi51LFxuICAgICAgLi4uZlxuICAgIH07XG4gICAgY29uc3QgZCA9IGtlKFxuICAgICAgdS5hbGxNYXRyaXgsXG4gICAgICBbNTAsIDUwXSxcbiAgICAgIDEwMCxcbiAgICAgIDEwMFxuICAgICk7XG4gICAgaSA9ICRpKFtkLnBvczEsIGQucG9zMl0sIGQuZGlyZWN0aW9uKTtcbiAgfVxuICBjb25zdCBsID0gNDtcbiAgcmV0dXJuIHtcbiAgICBoYXNab29tOiAhMSxcbiAgICB3aWR0aDogcyxcbiAgICBoZWlnaHQ6IG8sXG4gICAgcm90YXRpb246IGksXG4gICAgLi4uYyxcbiAgICBvcmlnaW5hbFJvb3RNYXRyaXg6IGd0KGwpLFxuICAgIHJvb3RNYXRyaXg6IGd0KGwpLFxuICAgIGJlZm9yZU1hdHJpeDogZ3QobCksXG4gICAgb2Zmc2V0TWF0cml4OiBndChsKSxcbiAgICBhbGxNYXRyaXg6IGd0KGwpLFxuICAgIHRhcmdldE1hdHJpeDogZ3QobCksXG4gICAgdGFyZ2V0VHJhbnNmb3JtOiBcIlwiLFxuICAgIGlubGluZVRyYW5zZm9ybTogXCJcIixcbiAgICB0cmFuc2Zvcm1PcmlnaW46IFswLCAwXSxcbiAgICB0YXJnZXRPcmlnaW46IFswLCAwXSxcbiAgICBpczNkOiAhIXIsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIG9yaWdpbjogWzAsIDBdLFxuICAgIHBvczE6IFswLCAwXSxcbiAgICBwb3MyOiBbMCwgMF0sXG4gICAgcG9zMzogWzAsIDBdLFxuICAgIHBvczQ6IFswLCAwXSxcbiAgICBkaXJlY3Rpb246IDEsXG4gICAgaGFzRml4ZWQ6ICExLFxuICAgIG9mZnNldENvbnRhaW5lcjogbnVsbCxcbiAgICBvZmZzZXRSb290Q29udGFpbmVyOiBudWxsLFxuICAgIG1hdHJpeGVzOiBbXSxcbiAgICAuLi5hXG4gIH07XG59XG5mdW5jdGlvbiBJZih0LCBlLCBuID0gZSkge1xuICByZXR1cm4gbGEodCwgZSwgbiwgITApO1xufVxuZnVuY3Rpb24gWXIodCwgZSwgbiwgciwgcywgbyA9IFtdKSB7XG4gIGxldCBpID0gMSwgYSA9IFswLCAwXSwgYyA9IFJuKCksIGwgPSBSbigpLCB1ID0gUm4oKSwgZiA9IFJuKCksIGQgPSBbMCwgMF07XG4gIGNvbnN0IHAgPSB7fSwgZyA9IGxhKFxuICAgIGUsXG4gICAgbixcbiAgICBzLFxuICAgICEwXG4gICk7XG4gIGlmIChlKSB7XG4gICAgY29uc3QgaCA9IEd0KGUpO1xuICAgIG8uZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgcFt4XSA9IGgoeCk7XG4gICAgfSk7XG4gICAgY29uc3QgdiA9IGcuaXMzZCA/IDQgOiAzLCBtID0ga2UoXG4gICAgICBnLm9mZnNldE1hdHJpeCxcbiAgICAgIGF0KGcudHJhbnNmb3JtT3JpZ2luLCB0aShnLnRhcmdldE1hdHJpeCwgdikpLFxuICAgICAgZy53aWR0aCxcbiAgICAgIGcuaGVpZ2h0XG4gICAgKTtcbiAgICBpID0gbS5kaXJlY3Rpb24sIGEgPSBhdChcbiAgICAgIG0ub3JpZ2luLFxuICAgICAgW20ubGVmdCAtIGcubGVmdCwgbS50b3AgLSBnLnRvcF1cbiAgICApLCBmID0gbm4oZy5vZmZzZXRSb290Q29udGFpbmVyKTtcbiAgICBjb25zdCBTID0gZm4ociwgciwgITApLm9mZnNldFBhcmVudCB8fCBnLm9mZnNldFJvb3RDb250YWluZXI7XG4gICAgaWYgKGcuaGFzWm9vbSkge1xuICAgICAgY29uc3QgeCA9IGtlKFxuICAgICAgICBkdChnLm9yaWdpbmFsUm9vdE1hdHJpeCwgZy5hbGxNYXRyaXgpLFxuICAgICAgICBnLnRyYW5zZm9ybU9yaWdpbixcbiAgICAgICAgZy53aWR0aCxcbiAgICAgICAgZy5oZWlnaHRcbiAgICAgICksIEMgPSBrZShcbiAgICAgICAgZy5vcmlnaW5hbFJvb3RNYXRyaXgsXG4gICAgICAgIExuKEd0KFMpKFwidHJhbnNmb3JtT3JpZ2luXCIpKS5tYXAoKEUpID0+IHBhcnNlRmxvYXQoRSkpLFxuICAgICAgICBTLm9mZnNldFdpZHRoLFxuICAgICAgICBTLm9mZnNldEhlaWdodFxuICAgICAgKTtcbiAgICAgIGlmIChjID0gcHIoeCwgZiksIHUgPSBwcihcbiAgICAgICAgQyxcbiAgICAgICAgZixcbiAgICAgICAgUyxcbiAgICAgICAgITBcbiAgICAgICksIHQpIHtcbiAgICAgICAgY29uc3QgRSA9IHgubGVmdCwgRCA9IHgudG9wO1xuICAgICAgICBsID0gcHIoe1xuICAgICAgICAgIGxlZnQ6IEUsXG4gICAgICAgICAgdG9wOiBELFxuICAgICAgICAgIGJvdHRvbTogRCxcbiAgICAgICAgICByaWdodDogRFxuICAgICAgICB9LCBmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IG5uKGUpLCB1ID0gUWMoUyksIHQgJiYgKGwgPSBubih0KSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHRvcDogQyxcbiAgICAgICAgY2xpZW50TGVmdDogRSxcbiAgICAgICAgY2xpZW50VG9wOiBEXG4gICAgICB9ID0gdSwgUiA9IFtcbiAgICAgICAgYy5sZWZ0IC0geCxcbiAgICAgICAgYy50b3AgLSBDXG4gICAgICBdO1xuICAgICAgZCA9IEsoXG4gICAgICAgIFdlKGcucm9vdE1hdHJpeCwgUiwgNCksXG4gICAgICAgIFtFICsgZy5sZWZ0LCBEICsgZy50b3BdXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRhcmdldENsaWVudFJlY3Q6IGMsXG4gICAgY29udGFpbmVyQ2xpZW50UmVjdDogdSxcbiAgICBtb3ZlYWJsZUNsaWVudFJlY3Q6IGwsXG4gICAgcm9vdENvbnRhaW5lckNsaWVudFJlY3Q6IGYsXG4gICAgYmVmb3JlRGlyZWN0aW9uOiBpLFxuICAgIGJlZm9yZU9yaWdpbjogYSxcbiAgICBvcmlnaW5hbEJlZm9yZU9yaWdpbjogYSxcbiAgICB0YXJnZXQ6IGUsXG4gICAgc3R5bGU6IHAsXG4gICAgb2Zmc2V0RGVsdGE6IGQsXG4gICAgLi4uZ1xuICB9O1xufVxuZnVuY3Rpb24geW8odCkge1xuICBsZXQge1xuICAgIHBvczE6IGUsXG4gICAgcG9zMjogbixcbiAgICBwb3MzOiByLFxuICAgIHBvczQ6IHNcbiAgfSA9IHQ7XG4gIGlmICghZSB8fCAhbiB8fCAhciB8fCAhcylcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbyA9IGJlKFtlLCBuLCByLCBzXSksIGkgPSBbby5taW5YLCBvLm1pblldLCBhID0gSyh0Lm9yaWdpbiwgaSk7XG4gIHJldHVybiBlID0gSyhlLCBpKSwgbiA9IEsobiwgaSksIHIgPSBLKHIsIGkpLCBzID0gSyhzLCBpKSwge1xuICAgIC4uLnQsXG4gICAgbGVmdDogdC5sZWZ0LFxuICAgIHRvcDogdC50b3AsXG4gICAgcG9zRGVsdGE6IGksXG4gICAgcG9zMTogZSxcbiAgICBwb3MyOiBuLFxuICAgIHBvczM6IHIsXG4gICAgcG9zNDogcyxcbiAgICBvcmlnaW46IGEsXG4gICAgYmVmb3JlT3JpZ2luOiBhLFxuICAgIC8vIG9yaWdpbmFsQmVmb3JlT3JpZ2luOiBvcmlnaW4sXG4gICAgaXNQZXJzaXN0ZWQ6ICEwXG4gIH07XG59XG5jbGFzcyB5ZSBleHRlbmRzIF9vLlB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIFgodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICBnZXN0b3M6IHt9LFxuICAgICAgcmVuZGVyTGluZXM6IFtcbiAgICAgICAgW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMCwgMF1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMCwgMF1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMCwgMF1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMCwgMF1cbiAgICAgICAgXVxuICAgICAgXSxcbiAgICAgIHJlbmRlclBvc2VzOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFswLCAwXVxuICAgICAgXSxcbiAgICAgIGRpc2FibGVOYXRpdmVFdmVudDogITEsXG4gICAgICBwb3NEZWx0YTogWzAsIDBdLFxuICAgICAgLi4uWXIobnVsbClcbiAgICB9KTtcbiAgICBYKHRoaXMsIFwicmVuZGVyU3RhdGVcIiwge30pO1xuICAgIFgodGhpcywgXCJlbmFibGVkQWJsZXNcIiwgW10pO1xuICAgIFgodGhpcywgXCJ0YXJnZXRBYmxlc1wiLCBbXSk7XG4gICAgWCh0aGlzLCBcImNvbnRyb2xBYmxlc1wiLCBbXSk7XG4gICAgWCh0aGlzLCBcImNvbnRyb2xCb3hcIik7XG4gICAgWCh0aGlzLCBcImFyZWFFbGVtZW50XCIpO1xuICAgIFgodGhpcywgXCJ0YXJnZXRHZXN0b1wiKTtcbiAgICBYKHRoaXMsIFwiY29udHJvbEdlc3RvXCIpO1xuICAgIFgodGhpcywgXCJyb3RhdGlvblwiLCAwKTtcbiAgICBYKHRoaXMsIFwic2NhbGVcIiwgWzEsIDFdKTtcbiAgICBYKHRoaXMsIFwiaXNNb3ZlYWJsZU1vdW50ZWRcIiwgITEpO1xuICAgIFgodGhpcywgXCJpc1VubW91bnRlZFwiLCAhMSk7XG4gICAgWCh0aGlzLCBcImV2ZW50c1wiLCB7XG4gICAgICBtb3VzZUVudGVyOiBudWxsLFxuICAgICAgbW91c2VMZWF2ZTogbnVsbFxuICAgIH0pO1xuICAgIFgodGhpcywgXCJfZW1pdHRlclwiLCBuZXcgQ3MoKSk7XG4gICAgWCh0aGlzLCBcIl9wcmV2T3JpZ2luYWxEcmFnVGFyZ2V0XCIsIG51bGwpO1xuICAgIFgodGhpcywgXCJfb3JpZ2luYWxEcmFnVGFyZ2V0XCIsIG51bGwpO1xuICAgIFgodGhpcywgXCJfcHJldkRyYWdUYXJnZXRcIiwgbnVsbCk7XG4gICAgWCh0aGlzLCBcIl9kcmFnVGFyZ2V0XCIsIG51bGwpO1xuICAgIFgodGhpcywgXCJfcHJldlByb3BUYXJnZXRcIiwgbnVsbCk7XG4gICAgWCh0aGlzLCBcIl9wcm9wVGFyZ2V0XCIsIG51bGwpO1xuICAgIFgodGhpcywgXCJfcHJldkRyYWdBcmVhXCIsICExKTtcbiAgICBYKHRoaXMsIFwiX2lzUHJvcFRhcmdldENoYW5nZWRcIiwgITEpO1xuICAgIFgodGhpcywgXCJfaGFzRmlyc3RUYXJnZXRcIiwgITEpO1xuICAgIFgodGhpcywgXCJfcmVpc3plT2JzZXJ2ZXJcIiwgbnVsbCk7XG4gICAgWCh0aGlzLCBcIl9vYnNlcnZlcklkXCIsIDApO1xuICAgIFgodGhpcywgXCJfbXV0YXRpb25PYnNlcnZlclwiLCBudWxsKTtcbiAgICBYKHRoaXMsIFwiX3Jvb3RDb250YWluZXJcIiwgbnVsbCk7XG4gICAgWCh0aGlzLCBcIl92aWV3Q29udGFpbmVyXCIsIG51bGwpO1xuICAgIFgodGhpcywgXCJfdmlld0NsYXNzTmFtZXNcIiwgW10pO1xuICAgIFgodGhpcywgXCJfc3RvcmVcIiwge30pO1xuICAgIFgodGhpcywgXCJjaGVja1VwZGF0ZVJlY3RcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBuID0gdGhpcy5wcm9wcy5wYXJlbnRNb3ZlYWJsZTtcbiAgICAgIGlmIChuKSB7XG4gICAgICAgIG4uY2hlY2tVcGRhdGVSZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIEVjKHRoaXMuX29ic2VydmVySWQpLCB0aGlzLl9vYnNlcnZlcklkID0gSG8oKCkgPT4ge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcoKSB8fCB0aGlzLnVwZGF0ZVJlY3QoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFgodGhpcywgXCJfb25QcmV2ZW50Q2xpY2tcIiwgKG4pID0+IHtcbiAgICAgIG4uc3RvcFByb3BhZ2F0aW9uKCksIG4ucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMucHJvcHMsIHIgPSB0aGlzLmdldFN0YXRlKCksIHtcbiAgICAgIHBhcmVudFBvc2l0aW9uOiBzLFxuICAgICAgY2xhc3NOYW1lOiBvLFxuICAgICAgdGFyZ2V0OiBpLFxuICAgICAgem9vbTogYSxcbiAgICAgIGNzcE5vbmNlOiBjLFxuICAgICAgdHJhbnNsYXRlWjogbCxcbiAgICAgIGNzc1N0eWxlZDogdSxcbiAgICAgIGdyb3VwYWJsZTogZixcbiAgICAgIGxpbmVQYWRkaW5nOiBkLFxuICAgICAgY29udHJvbFBhZGRpbmc6IHBcbiAgICB9ID0gbjtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZVJvb3RDb250YWluZXIoKSwgdGhpcy5jaGVja1VwZGF0ZSgpLCB0aGlzLnVwZGF0ZVJlbmRlclBvc2VzKCk7XG4gICAgY29uc3QgW2csIGhdID0gcyB8fCBbMCwgMF0sIHtcbiAgICAgIGxlZnQ6IHYsXG4gICAgICB0b3A6IG0sXG4gICAgICB0YXJnZXQ6IFMsXG4gICAgICBkaXJlY3Rpb246IHgsXG4gICAgICBoYXNGaXhlZDogQyxcbiAgICAgIG9mZnNldERlbHRhOiBFXG4gICAgfSA9IHIsIEQgPSBuLnRhcmdldHMsIFIgPSB0aGlzLmlzRHJhZ2dpbmcoKSwgeSA9IHt9O1xuICAgIHRoaXMuZ2V0RW5hYmxlZEFibGVzKCkuZm9yRWFjaCgodykgPT4ge1xuICAgICAgeVtgZGF0YS1hYmxlLSR7dy5uYW1lLnRvTG93ZXJDYXNlKCl9YF0gPSAhMDtcbiAgICB9KTtcbiAgICBjb25zdCBNID0gdGhpcy5fZ2V0QWJsZUNsYXNzTmFtZSgpLCBQID0gRCAmJiBELmxlbmd0aCAmJiAoUyB8fCBmKSB8fCBpIHx8ICF0aGlzLl9oYXNGaXJzdFRhcmdldCAmJiB0aGlzLnN0YXRlLmlzUGVyc2lzdGVkLCBfID0gdGhpcy5jb250cm9sQm94IHx8IHRoaXMucHJvcHMuZmlyc3RSZW5kZXJTdGF0ZSB8fCB0aGlzLnByb3BzLnBlcnNpc3REYXRhLCBPID0gW3YgLSBnLCBtIC0gaF07XG4gICAgIWYgJiYgbi51c2VBY2N1cmF0ZVBvc2l0aW9uICYmIChPWzBdICs9IEVbMF0sIE9bMV0gKz0gRVsxXSk7XG4gICAgY29uc3QgVCA9IHtcbiAgICAgIHBvc2l0aW9uOiBDID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiLFxuICAgICAgZGlzcGxheTogUCA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLFxuICAgICAgdmlzaWJpbGl0eTogXyA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIixcbiAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7T1swXX1weCwgJHtPWzFdfXB4LCAke2x9KWAsXG4gICAgICBcIi0tem9vbVwiOiBhLFxuICAgICAgXCItLXpvb21weFwiOiBgJHthfXB4YFxuICAgIH07XG4gICAgcmV0dXJuIGQgJiYgKFRbXCItLW1vdmVhYmxlLWxpbmUtcGFkZGluZ1wiXSA9IGQpLCBwICYmIChUW1wiLS1tb3ZlYWJsZS1jb250cm9sLXBhZGRpbmdcIl0gPSBwKSwgLyogQF9fUFVSRV9fICovIGl0LmpzeHMoXG4gICAgICB1LFxuICAgICAge1xuICAgICAgICBjc3BOb25jZTogYyxcbiAgICAgICAgcmVmOiBTZSh0aGlzLCBcImNvbnRyb2xCb3hcIiksXG4gICAgICAgIGNsYXNzTmFtZTogYCR7VShcImNvbnRyb2wtYm94XCIsIHggPT09IC0xID8gXCJyZXZlcnNlXCIgOiBcIlwiLCBSID8gXCJkcmFnZ2luZ1wiIDogXCJcIil9ICR7TX0gJHtvfWAsXG4gICAgICAgIC4uLnksXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uUHJldmVudENsaWNrLFxuICAgICAgICBzdHlsZTogVCxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB0aGlzLnJlbmRlckFibGVzKCksXG4gICAgICAgICAgdGhpcy5fcmVuZGVyTGluZXMoKVxuICAgICAgICBdXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmlzTW92ZWFibGVNb3VudGVkID0gITAsIHRoaXMuaXNVbm1vdW50ZWQgPSAhMTtcbiAgICBjb25zdCBuID0gdGhpcy5wcm9wcywgeyBwYXJlbnRNb3ZlYWJsZTogciwgY29udGFpbmVyOiBzIH0gPSBuO1xuICAgIHRoaXMuX2NoZWNrVXBkYXRlUm9vdENvbnRhaW5lcigpLCB0aGlzLl9jaGVja1VwZGF0ZVZpZXdDb250YWluZXIoKSwgdGhpcy5fdXBkYXRlVGFyZ2V0cygpLCB0aGlzLl91cGRhdGVOYXRpdmVFdmVudHMoKSwgdGhpcy5fdXBkYXRlRXZlbnRzKCksIHRoaXMudXBkYXRlQ2hlY2tJbnB1dCgpLCB0aGlzLl91cGRhdGVPYnNlcnZlcih0aGlzLnByb3BzKSwgIXMgJiYgIXIgJiYgIXRoaXMuc3RhdGUuaXNQZXJzaXN0ZWQgJiYgKHRoaXMudXBkYXRlUmVjdChcIlwiLCAhMSwgITEpLCB0aGlzLmZvcmNlVXBkYXRlKCkpO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShuKSB7XG4gICAgdGhpcy5fY2hlY2tVcGRhdGVSb290Q29udGFpbmVyKCksIHRoaXMuX2NoZWNrVXBkYXRlVmlld0NvbnRhaW5lcigpLCB0aGlzLl91cGRhdGVOYXRpdmVFdmVudHMoKSwgdGhpcy5fdXBkYXRlVGFyZ2V0cygpLCB0aGlzLl91cGRhdGVFdmVudHMoKSwgdGhpcy51cGRhdGVDaGVja0lucHV0KCksIHRoaXMuX3VwZGF0ZU9ic2VydmVyKG4pO1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciBzLCBvO1xuICAgIHRoaXMuaXNNb3ZlYWJsZU1vdW50ZWQgPSAhMSwgdGhpcy5pc1VubW91bnRlZCA9ICEwLCB0aGlzLl9lbWl0dGVyLm9mZigpLCAocyA9IHRoaXMuX3JlaXN6ZU9ic2VydmVyKSA9PSBudWxsIHx8IHMuZGlzY29ubmVjdCgpLCAobyA9IHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIpID09IG51bGwgfHwgby5kaXNjb25uZWN0KCksIHRoaXMuX3ZpZXdDb250YWluZXIgJiYgdGhpcy5fY2hhbmdlQWJsZVZpZXdDbGFzc05hbWVzKFtdKSwgemUodGhpcywgITEpLCB6ZSh0aGlzLCAhMCk7XG4gICAgY29uc3QgciA9IHRoaXMuZXZlbnRzO1xuICAgIGZvciAoY29uc3QgaSBpbiByKSB7XG4gICAgICBjb25zdCBhID0gcltpXTtcbiAgICAgIGEgJiYgYS5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIGdldFRhcmdldHMoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMucHJvcHMudGFyZ2V0O1xuICAgIHJldHVybiBuID8gW25dIDogW107XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYWJsZSB1c2VkIGluIE1vdmVhYmxlTWFuYWdlci5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNnZXRBYmxlXG4gICAqIEBwYXJhbSAtIGFibGUgbmFtZVxuICAgKi9cbiAgZ2V0QWJsZShuKSB7XG4gICAgY29uc3QgciA9IHRoaXMucHJvcHMuYWJsZXMgfHwgW107XG4gICAgcmV0dXJuIGt0KHIsIChzKSA9PiBzLm5hbWUgPT09IG4pO1xuICB9XG4gIGdldENvbnRhaW5lcigpIHtcbiAgICBjb25zdCB7IHBhcmVudE1vdmVhYmxlOiBuLCB3cmFwcGVyTW92ZWFibGU6IHIsIGNvbnRhaW5lcjogcyB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gcyB8fCByICYmIHIuZ2V0Q29udGFpbmVyKCkgfHwgbiAmJiBuLmdldENvbnRhaW5lcigpIHx8IHRoaXMuY29udHJvbEJveC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IG9mIHRoZSBjb250cm9sIGJveC5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNnZXRDb250cm9sQm94RWxlbWVudFxuICAgKi9cbiAgZ2V0Q29udHJvbEJveEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbEJveDtcbiAgfVxuICAvKipcbiAgICogVGFyZ2V0IGVsZW1lbnQgdG8gYmUgZHJhZ2dlZCBpbiBtb3ZlYWJsZVxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2dldERyYWdFbGVtZW50XG4gICAqL1xuICBnZXREcmFnRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJhZ1RhcmdldDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRhcmdldCBpcyBhbiBlbGVtZW50IGluY2x1ZGVkIGluIHRoZSBtb3ZlYWJsZS5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNpc01vdmVhYmxlRWxlbWVudFxuICAgKiBAcGFyYW0gLSB0aGUgdGFyZ2V0XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAqICAgICBpZiAoIW1vdmVhYmxlLmlzTW92ZWFibGVFbGVtZW50KGUudGFyZ2V0KSkge1xuICAgKiAgICAgICAgIG1vdmVhYmxlLnRhcmdldCA9IGUudGFyZ2V0O1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICovXG4gIGlzTW92ZWFibGVFbGVtZW50KG4pIHtcbiAgICB2YXIgcjtcbiAgICByZXR1cm4gbiAmJiAoKChyID0gbi5nZXRBdHRyaWJ1dGUpID09IG51bGwgPyB2b2lkIDAgOiByLmNhbGwobiwgXCJjbGFzc1wiKSkgfHwgXCJcIikuaW5kZXhPZihIcikgPiAtMTtcbiAgfVxuICAvKipcbiAgICogWW91IGNhbiBkcmFnIHN0YXJ0IHRoZSBNb3ZlYWJsZSB0aHJvdWdoIHRoZSBleHRlcm5hbCBgTW91c2VFdmVudGBvciBgVG91Y2hFdmVudGAuIChBbmd1bGFyOiBuZ0RyYWdTdGFydClcbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNkcmFnU3RhcnRcbiAgICogQHBhcmFtIC0gZXh0ZXJuYWwgYE1vdXNlRXZlbnRgb3IgYFRvdWNoRXZlbnRgXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcbiAgICogICAgIGlmICghbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoZS50YXJnZXQpKSB7XG4gICAqICAgICAgICAgIG1vdmVhYmxlLmRyYWdTdGFydChlKTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqL1xuICBkcmFnU3RhcnQobiwgciA9IG4udGFyZ2V0KSB7XG4gICAgY29uc3QgcyA9IHRoaXMudGFyZ2V0R2VzdG8sIG8gPSB0aGlzLmNvbnRyb2xHZXN0bztcbiAgICByZXR1cm4gcyAmJiBScyh0aGlzKSh7IGlucHV0RXZlbnQ6IG4gfSwgcikgPyBzLmlzRmxhZygpIHx8IHMudHJpZ2dlckRyYWdTdGFydChuKSA6IG8gJiYgdGhpcy5pc01vdmVhYmxlRWxlbWVudChyKSAmJiAoby5pc0ZsYWcoKSB8fCBvLnRyaWdnZXJEcmFnU3RhcnQobikpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBIaXQgdGVzdCBhbiBlbGVtZW50IG9yIHJlY3Qgb24gYSBtb3ZlYWJsZSB0YXJnZXQuXG4gICAqICgxMDAlID0gMTAwKVxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2hpdFRlc3RcbiAgICogQHBhcmFtIC0gZWxlbWVudCBvciByZWN0IHRvIHRlc3RcbiAgICogQHJldHVybiAtIEdldCBoaXQgdGVzdCByYXRlIChyYXRlID4gMCBpcyBoaXR0ZWQpXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcbiAgICogICAgIGlmIChtb3ZlYWJsZS5oaXRUZXN0KGUudGFyZ2V0KSA+IDApIHtcbiAgICogICAgICAgICAgY29uc29sZS5sb2coXCJoaWl0ZWRcIik7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKi9cbiAgaGl0VGVzdChuKSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IHIsIHBvczE6IHMsIHBvczI6IG8sIHBvczM6IGksIHBvczQ6IGEsIHRhcmdldENsaWVudFJlY3Q6IGMgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuIDA7XG4gICAgbGV0IGw7XG4gICAgaWYgKG5zKG4pKSB7XG4gICAgICBjb25zdCBtID0gbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGwgPSB7XG4gICAgICAgIGxlZnQ6IG0ubGVmdCxcbiAgICAgICAgdG9wOiBtLnRvcCxcbiAgICAgICAgd2lkdGg6IG0ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbS5oZWlnaHRcbiAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICBsID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCAuLi5uIH07XG4gICAgY29uc3Qge1xuICAgICAgbGVmdDogdSxcbiAgICAgIHRvcDogZixcbiAgICAgIHdpZHRoOiBkLFxuICAgICAgaGVpZ2h0OiBwXG4gICAgfSA9IGwsIGcgPSBtbyhbcywgbywgYSwgaV0sIGMpLCBoID0gcXUoZywgW1xuICAgICAgW3UsIGZdLFxuICAgICAgW3UgKyBkLCBmXSxcbiAgICAgIFt1ICsgZCwgZiArIHBdLFxuICAgICAgW3UsIGYgKyBwXVxuICAgIF0pLCB2ID0gUWkoZyk7XG4gICAgcmV0dXJuICFoIHx8ICF2ID8gMCA6IE1hdGgubWluKDEwMCwgaCAvIHYgKiAxMDApO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjb29yZGluYXRlcyBhcmUgaW5zaWRlIE1vdmVhYmxlXG4gICAqIEBtZXRob2QgTW92ZWFibGUjaXNJbnNpZGVcbiAgICogQHBhcmFtIC0geCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSAtIHkgY29vcmRpbmF0ZVxuICAgKiBAcmV0dXJuIC0gVHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZSBpcyBpbiBtb3ZlYWJsZSBvciBmYWxzZVxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB7XG4gICAqICAgICBpZiAobW92ZWFibGUuaXNJbnNpZGUoZS5jbGllbnRYLCBlLmNsaWVudFkpKSB7XG4gICAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW5zaWRlXCIpO1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICovXG4gIGlzSW5zaWRlKG4sIHIpIHtcbiAgICBjb25zdCB7IHRhcmdldDogcywgcG9zMTogbywgcG9zMjogaSwgcG9zMzogYSwgcG9zNDogYywgdGFyZ2V0Q2xpZW50UmVjdDogbCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gcyA/IEZyKFxuICAgICAgW24sIHJdLFxuICAgICAgbW8oW28sIGksIGMsIGFdLCBsKVxuICAgICkgOiAhMTtcbiAgfVxuICAvKipcbiAgICogSWYgdGhlIHdpZHRoLCBoZWlnaHQsIGxlZnQsIGFuZCB0b3Agb2YgYWxsIGVsZW1lbnRzIGNoYW5nZSwgdXBkYXRlIHRoZSBzaGFwZSBvZiB0aGUgbW92ZWFibGUuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjdXBkYXRlUmVjdFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBlID0+IHtcbiAgICogICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QoKTtcbiAgICogfSk7XG4gICAqL1xuICB1cGRhdGVSZWN0KG4sIHIsIHMgPSAhMCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLnByb3BzLCBpID0gIW8ucGFyZW50UG9zaXRpb24gJiYgIW8ud3JhcHBlck1vdmVhYmxlO1xuICAgIGkgJiYgTGUoITApO1xuICAgIGNvbnN0IGEgPSBvLnBhcmVudE1vdmVhYmxlLCBsID0gdGhpcy5zdGF0ZS50YXJnZXQgfHwgby50YXJnZXQsIHUgPSB0aGlzLmdldENvbnRhaW5lcigpLCBmID0gYSA/IGEuX3Jvb3RDb250YWluZXIgOiB0aGlzLl9yb290Q29udGFpbmVyLCBkID0gWXIoXG4gICAgICB0aGlzLmNvbnRyb2xCb3gsXG4gICAgICBsLFxuICAgICAgdSxcbiAgICAgIHUsXG4gICAgICBmIHx8IHUsXG4gICAgICB0aGlzLl9nZXRSZXF1ZXN0U3R5bGVzKClcbiAgICApO1xuICAgIGlmICghbCAmJiB0aGlzLl9oYXNGaXJzdFRhcmdldCAmJiBvLnBlcnNpc3REYXRhKSB7XG4gICAgICBjb25zdCBwID0geW8oby5wZXJzaXN0RGF0YSk7XG4gICAgICBmb3IgKGNvbnN0IGcgaW4gcClcbiAgICAgICAgZFtnXSA9IHBbZ107XG4gICAgfVxuICAgIGkgJiYgTGUoKSwgdGhpcy51cGRhdGVTdGF0ZShkLCBhID8gITEgOiBzKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIG1vdmVhYmxlIHN0YXRlIGlzIGJlaW5nIGRyYWdnZWQuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjaXNEcmFnZ2luZ1xuICAgKiBAcGFyYW0gLSBJZiB5b3Ugd2FudCB0byBjaGVjayBpZiBhYmxlIGlzIGRyYWdnaW5nLCBzcGVjaWZ5IGFibGVOYW1lLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiAvLyBmYWxzZVxuICAgKiBjb25zb2xlLmxvZyhtb3ZlYWJsZS5pc0RyYWdnaW5nKCkpO1xuICAgKlxuICAgKiBtb3ZlYWJsZS5vbihcImRyYWdcIiwgKCkgPT4ge1xuICAgKiAgIC8vIHRydWVcbiAgICogICBjb25zb2xlLmxvZyhtb3ZlYWJsZS5pc0RyYWdnaW5nKCkpO1xuICAgKiB9KTtcbiAgICovXG4gIGlzRHJhZ2dpbmcobikge1xuICAgIHZhciBvLCBpO1xuICAgIGNvbnN0IHIgPSB0aGlzLnRhcmdldEdlc3RvLCBzID0gdGhpcy5jb250cm9sR2VzdG87XG4gICAgcmV0dXJuIHIgIT0gbnVsbCAmJiByLmlzRmxhZygpID8gbiA/ICEhKChvID0gci5nZXRFdmVudERhdGEoKVtuXSkgIT0gbnVsbCAmJiBvLmlzRXZlbnRTdGFydCkgOiAhMCA6IHMgIT0gbnVsbCAmJiBzLmlzRmxhZygpID8gbiA/ICEhKChpID0gcy5nZXRFdmVudERhdGEoKVtuXSkgIT0gbnVsbCAmJiBpLmlzRXZlbnRTdGFydCkgOiAhMCA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0aGUgd2lkdGgsIGhlaWdodCwgbGVmdCwgYW5kIHRvcCBvZiB0aGUgb25seSB0YXJnZXQgY2hhbmdlLCB1cGRhdGUgdGhlIHNoYXBlIG9mIHRoZSBtb3ZlYWJsZS5cbiAgICogVXNlIGAudXBkYXRlUmVjdCgpYCBtZXRob2RcbiAgICogQG1ldGhvZCBNb3ZlYWJsZSN1cGRhdGVUYXJnZXRcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogbW92ZWFibGUudXBkYXRlVGFyZ2V0KCk7XG4gICAqL1xuICB1cGRhdGVUYXJnZXQobikge1xuICAgIHRoaXMudXBkYXRlUmVjdChuLCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFlvdSBjYW4gZ2V0IHRoZSB2ZXJ0ZXggaW5mb3JtYXRpb24sIHBvc2l0aW9uIGFuZCBvZmZzZXQgc2l6ZSBpbmZvcm1hdGlvbiBvZiB0aGUgdGFyZ2V0IGJhc2VkIG9uIHRoZSBjb250YWluZXIuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjZ2V0UmVjdFxuICAgKiBAcmV0dXJuIC0gVGhlIFJlY3QgSW5mb1xuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiBjb25zdCByZWN0SW5mbyA9IG1vdmVhYmxlLmdldFJlY3QoKTtcbiAgICovXG4gIGdldFJlY3QoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuc3RhdGUsIHIgPSBqdCh0aGlzLnN0YXRlKSwgW3MsIG8sIGksIGFdID0gciwgYyA9IFl0KHIpLCB7IHdpZHRoOiBsLCBoZWlnaHQ6IHUgfSA9IG4sIHsgd2lkdGg6IGYsIGhlaWdodDogZCwgbGVmdDogcCwgdG9wOiBnIH0gPSBjLCBoID0gW24ubGVmdCwgbi50b3BdLCB2ID0gYXQoaCwgbi5vcmlnaW4pLCBtID0gYXQoaCwgbi5iZWZvcmVPcmlnaW4pLCBTID0gbi50cmFuc2Zvcm1PcmlnaW47XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBmLFxuICAgICAgaGVpZ2h0OiBkLFxuICAgICAgbGVmdDogcCxcbiAgICAgIHRvcDogZyxcbiAgICAgIHBvczE6IHMsXG4gICAgICBwb3MyOiBvLFxuICAgICAgcG9zMzogaSxcbiAgICAgIHBvczQ6IGEsXG4gICAgICBvZmZzZXRXaWR0aDogbCxcbiAgICAgIG9mZnNldEhlaWdodDogdSxcbiAgICAgIGJlZm9yZU9yaWdpbjogbSxcbiAgICAgIG9yaWdpbjogdixcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogUyxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBtYW5hZ2VyIHRoYXQgbWFuYWdlcyB0aGUgbW92ZWFibGUncyBzdGF0ZSBhbmQgcHJvcHMuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjZ2V0TWFuYWdlclxuICAgKiBAcmV0dXJuIC0gVGhlIFJlY3QgSW5mb1xuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiBjb25zdCBtYW5hZ2VyID0gbW92ZWFibGUuZ2V0TWFuYWdlcigpOyAvLyByZWFsIG1vdmVhYmxlIGNsYXNzIGluc3RhbmNlXG4gICAqL1xuICBnZXRNYW5hZ2VyKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBZb3UgY2FuIHN0b3AgdGhlIGRyYWdnaW5nIGN1cnJlbnRseSBpbiBwcm9ncmVzcyB0aHJvdWdoIGEgbWV0aG9kIGZyb20gb3V0c2lkZS5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNzdG9wRHJhZ1xuICAgKiBAcmV0dXJuIC0gVGhlIFJlY3QgSW5mb1xuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiBtb3ZlYWJsZS5zdG9wRHJhZygpO1xuICAgKi9cbiAgc3RvcERyYWcobikge1xuICAgIGlmICghbiB8fCBuID09PSBcInRhcmdldFwiKSB7XG4gICAgICBjb25zdCByID0gdGhpcy50YXJnZXRHZXN0bztcbiAgICAgIChyID09IG51bGwgPyB2b2lkIDAgOiByLmlzSWRsZSgpKSA9PT0gITEgJiYgenIodGhpcywgITEpLCByID09IG51bGwgfHwgci5zdG9wKCk7XG4gICAgfVxuICAgIGlmICghbiB8fCBuID09PSBcImNvbnRyb2xcIikge1xuICAgICAgY29uc3QgciA9IHRoaXMuY29udHJvbEdlc3RvO1xuICAgICAgKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaXNJZGxlKCkpID09PSAhMSAmJiB6cih0aGlzLCAhMCksIHIgPT0gbnVsbCB8fCByLnN0b3AoKTtcbiAgICB9XG4gIH1cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgY29uc3QgeyBwb3MxOiBuLCBwb3MyOiByLCBkaXJlY3Rpb246IHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIEN1KG4sIHIsIHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0IGFibGUgdGhyb3VnaCBhIG1ldGhvZCByYXRoZXIgdGhhbiBhbiBldmVudC5cbiAgICogQXQgdGhlIG1vbWVudCBvZiBleGVjdXRpb24sIHJlcXVlc3RTdGFydCBpcyBleGVjdXRlZCxcbiAgICogYW5kIHRoZW4gcmVxdWVzdCBhbmQgcmVxdWVzdEVuZCBjYW4gYmUgZXhlY3V0ZWQgdGhyb3VnaCBSZXF1ZXN0ZXIuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjcmVxdWVzdFxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuRHJhZ2dhYmxlLmh0bWwjcmVxdWVzdHxEcmFnZ2FibGUgUmVxdWVzdGVyfVxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuUmVzaXphYmxlLmh0bWwjcmVxdWVzdHxSZXNpemFibGUgUmVxdWVzdGVyfVxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU2NhbGFibGUuaHRtbCNyZXF1ZXN0fFNjYWxhYmxlIFJlcXVlc3Rlcn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlJvdGF0YWJsZS5odG1sI3JlcXVlc3R8Um90YXRhYmxlIFJlcXVlc3Rlcn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZS5odG1sI3JlcXVlc3R8T3JpZ2luRHJhZ2dhYmxlIFJlcXVlc3Rlcn1cbiAgICogQHBhcmFtIC0gYWJsZU5hbWVcbiAgICogQHBhcmFtIC0gcmVxdWVzdCB0byBiZSBhYmxlIHBhcmFtcy5cbiAgICogQHBhcmFtIC0gSWYgaXNJbnN0YW50IGlzIHRydWUsIHJlcXVlc3QgYW5kIHJlcXVlc3RFbmQgYXJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgKiBAcmV0dXJuIC0gQWJsZSBSZXF1ZXN0ZXIuIElmIHRoZXJlIGlzIG5vIHJlcXVlc3QgaW4gYWJsZSwgbm90aGluZyB3aWxsIHdvcmsuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcbiAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSwgdHJ1ZSk7XG4gICAqXG4gICAqIC8vIFN0YXJ0IG1vdmVcbiAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiKTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgICovXG4gIHJlcXVlc3QobiwgciA9IHt9LCBzKSB7XG4gICAgY29uc3QgbyA9IHRoaXMsIGkgPSBvLnByb3BzLCBhID0gaS5wYXJlbnRNb3ZlYWJsZSB8fCBpLndyYXBwZXJNb3ZlYWJsZSB8fCBvLCBjID0gYS5wcm9wcy5hYmxlcywgbCA9IGkuZ3JvdXBhYmxlLCB1ID0ga3QoYywgKG0pID0+IG0ubmFtZSA9PT0gbik7XG4gICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpIHx8ICF1IHx8ICF1LnJlcXVlc3QpXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXF1ZXN0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0RW5kKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIGNvbnN0IGYgPSB1LnJlcXVlc3QobyksIGQgPSBzIHx8IHIuaXNJbnN0YW50LCBwID0gZi5pc0NvbnRyb2wgPyBcImNvbnRyb2xBYmxlc1wiIDogXCJ0YXJnZXRBYmxlc1wiLCBnID0gYCR7bCA/IFwiR3JvdXBcIiA6IFwiXCJ9JHtmLmlzQ29udHJvbCA/IFwiQ29udHJvbFwiIDogXCJcIn1gLCBoID0gWy4uLmFbcF1dLCB2ID0ge1xuICAgICAgcmVxdWVzdChtKSB7XG4gICAgICAgIHJldHVybiBzbihcbiAgICAgICAgICBvLFxuICAgICAgICAgIGgsXG4gICAgICAgICAgW1wiZHJhZ1wiXSxcbiAgICAgICAgICBnLFxuICAgICAgICAgIFwiXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uZi5yZXF1ZXN0KG0pLFxuICAgICAgICAgICAgcmVxdWVzdEFibGU6IG4sXG4gICAgICAgICAgICBpc1JlcXVlc3Q6ICEwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkXG4gICAgICAgICksIHY7XG4gICAgICB9LFxuICAgICAgcmVxdWVzdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHNuKFxuICAgICAgICAgIG8sXG4gICAgICAgICAgaCxcbiAgICAgICAgICBbXCJkcmFnXCJdLFxuICAgICAgICAgIGcsXG4gICAgICAgICAgXCJFbmRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5mLnJlcXVlc3RFbmQoKSxcbiAgICAgICAgICAgIHJlcXVlc3RBYmxlOiBuLFxuICAgICAgICAgICAgaXNSZXF1ZXN0OiAhMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZFxuICAgICAgICApLCB2O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHNuKFxuICAgICAgbyxcbiAgICAgIGgsXG4gICAgICBbXCJkcmFnXCJdLFxuICAgICAgZyxcbiAgICAgIFwiU3RhcnRcIixcbiAgICAgIHtcbiAgICAgICAgLi4uZi5yZXF1ZXN0U3RhcnQociksXG4gICAgICAgIHJlcXVlc3RBYmxlOiBuLFxuICAgICAgICBpc1JlcXVlc3Q6ICEwXG4gICAgICB9LFxuICAgICAgZFxuICAgICksIGQgPyB2LnJlcXVlc3QocikucmVxdWVzdEVuZCgpIDogdjtcbiAgfVxuICAvKipcbiAgICogbW92ZWFibGUgaXMgdGhlIHRvcCBsZXZlbCB0aGF0IG1hbmFnZXMgdGFyZ2V0c1xuICAgKiBgU2luZ2xlYDogTW92ZWFibGVNYW5hZ2VyIGluc3RhbmNlXG4gICAqIGBHcm91cGA6IE1vdmVhYmxlR3JvdXAgaW5zdGFuY2VcbiAgICogYEluZGl2aWR1YWxHcm91cGA6IE1vdmVhYmxlSW5kaXZpZGF1bEdyb3VwIGluc3RhbmNlXG4gICAqIFJldHVybnMgbGVhZiB0YXJnZXQgTW92ZWFibGVNYW5hZ2Vycy5cbiAgICovXG4gIGdldE1vdmVhYmxlcygpIHtcbiAgICByZXR1cm4gW3RoaXNdO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIE1vdmVhYmxlIG9iamVjdCBhbmQgdGhlIGV2ZW50cy5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNkZXN0cm95XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIG1vdmVhYmxlLmRlc3Ryb3koKTtcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG4gIHVwZGF0ZVJlbmRlclBvc2VzKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldFN0YXRlKCksIHIgPSB0aGlzLnByb3BzLCBzID0gci5wYWRkaW5nLCB7XG4gICAgICBvcmlnaW5hbEJlZm9yZU9yaWdpbjogbyxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogaSxcbiAgICAgIGFsbE1hdHJpeDogYSxcbiAgICAgIGlzM2Q6IGMsXG4gICAgICBwb3MxOiBsLFxuICAgICAgcG9zMjogdSxcbiAgICAgIHBvczM6IGYsXG4gICAgICBwb3M0OiBkLFxuICAgICAgbGVmdDogcCxcbiAgICAgIHRvcDogZyxcbiAgICAgIGlzUGVyc2lzdGVkOiBoXG4gICAgfSA9IG4sIHYgPSByLnpvb20gfHwgMTtcbiAgICBpZiAoIXMgJiYgdiA8PSAxKSB7XG4gICAgICBuLnJlbmRlclBvc2VzID0gW2wsIHUsIGYsIGRdLCBuLnJlbmRlckxpbmVzID0gW1xuICAgICAgICBbbCwgdV0sXG4gICAgICAgIFt1LCBkXSxcbiAgICAgICAgW2QsIGZdLFxuICAgICAgICBbZiwgbF1cbiAgICAgIF07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgbGVmdDogbSwgdG9wOiBTLCBib3R0b206IHgsIHJpZ2h0OiBDIH0gPSBxaShzIHx8IHt9KSwgRSA9IGMgPyA0IDogMztcbiAgICBsZXQgRCA9IFtdO1xuICAgIGggPyBEID0gaSA6IHRoaXMuY29udHJvbEJveCAmJiByLmdyb3VwYWJsZSA/IEQgPSBvIDogRCA9IGF0KG8sIFtwLCBnXSk7XG4gICAgY29uc3QgUiA9IEFuKFxuICAgICAgRSxcbiAgICAgIENlKFxuICAgICAgICBELm1hcCgoTykgPT4gLU8pLFxuICAgICAgICBFXG4gICAgICApLFxuICAgICAgYSxcbiAgICAgIENlKGksIEUpXG4gICAgKSwgeSA9IFd0KFIsIGwsIFstbSwgLVNdLCBFKSwgTSA9IFd0KFIsIHUsIFtDLCAtU10sIEUpLCBQID0gV3QoUiwgZiwgWy1tLCB4XSwgRSksIF8gPSBXdChSLCBkLCBbQywgeF0sIEUpO1xuICAgIGlmIChuLnJlbmRlclBvc2VzID0gW3ksIE0sIFAsIF9dLCBuLnJlbmRlckxpbmVzID0gW1xuICAgICAgW3ksIE1dLFxuICAgICAgW00sIF9dLFxuICAgICAgW18sIFBdLFxuICAgICAgW1AsIHldXG4gICAgXSwgdikge1xuICAgICAgY29uc3QgTyA9IHYgLyAyO1xuICAgICAgbi5yZW5kZXJMaW5lcyA9IFtcbiAgICAgICAgW1xuICAgICAgICAgIFd0KFIsIGwsIFstbSAtIE8sIC1TXSwgRSksXG4gICAgICAgICAgV3QoUiwgdSwgW0MgKyBPLCAtU10sIEUpXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBXdChSLCB1LCBbQywgLVMgLSBPXSwgRSksXG4gICAgICAgICAgV3QoUiwgZCwgW0MsIHggKyBPXSwgRSlcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFd0KFIsIGQsIFtDICsgTywgeF0sIEUpLFxuICAgICAgICAgIFd0KFIsIGYsIFstbSAtIE8sIHhdLCBFKVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgV3QoUiwgZiwgWy1tLCB4ICsgT10sIEUpLFxuICAgICAgICAgIFd0KFIsIGwsIFstbSwgLVMgLSBPXSwgRSlcbiAgICAgICAgXVxuICAgICAgXTtcbiAgICB9XG4gIH1cbiAgY2hlY2tVcGRhdGUoKSB7XG4gICAgdGhpcy5faXNQcm9wVGFyZ2V0Q2hhbmdlZCA9ICExO1xuICAgIGNvbnN0IHsgdGFyZ2V0OiBuLCBjb250YWluZXI6IHIsIHBhcmVudE1vdmVhYmxlOiBzIH0gPSB0aGlzLnByb3BzLCB7IHRhcmdldDogbywgY29udGFpbmVyOiBpIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghbyAmJiAhbilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnVwZGF0ZUFibGVzKCk7XG4gICAgY29uc3QgYSA9ICFBcihvLCBuKTtcbiAgICBpZiAoIShhIHx8ICFBcihpLCByKSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbCA9IHIgfHwgdGhpcy5jb250cm9sQm94O1xuICAgIGwgJiYgdGhpcy51bnNldEFibGVzKCksIHRoaXMudXBkYXRlU3RhdGUoeyB0YXJnZXQ6IG4sIGNvbnRhaW5lcjogciB9KSwgIXMgJiYgbCAmJiB0aGlzLnVwZGF0ZVJlY3QoXCJFbmRcIiwgITEsICExKSwgdGhpcy5faXNQcm9wVGFyZ2V0Q2hhbmdlZCA9IGE7XG4gIH1cbiAgd2FpdFRvQ2hhbmdlVGFyZ2V0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgfSk7XG4gIH1cbiAgdHJpZ2dlckV2ZW50KG4sIHIpIHtcbiAgICBjb25zdCBzID0gdGhpcy5wcm9wcztcbiAgICBpZiAodGhpcy5fZW1pdHRlci50cmlnZ2VyKG4sIHIpLCBzLnBhcmVudE1vdmVhYmxlICYmIHIuaXNSZXF1ZXN0ICYmICFyLmlzUmVxdWVzdENoaWxkKVxuICAgICAgcmV0dXJuIHMucGFyZW50TW92ZWFibGUudHJpZ2dlckV2ZW50KG4sIHIsICEwKTtcbiAgICBjb25zdCBvID0gc1tuXTtcbiAgICByZXR1cm4gbyAmJiBvKHIpO1xuICB9XG4gIHVzZUNTUyhuLCByKSB7XG4gICAgY29uc3QgcyA9IHRoaXMucHJvcHMuY3VzdG9tU3R5bGVkTWFwLCBvID0gbiArIHI7XG4gICAgcmV0dXJuIHNbb10gfHwgKHNbb10gPSBjYShuLCByKSksIHNbb107XG4gIH1cbiAgZ2V0U3RhdGUoKSB7XG4gICAgdmFyIGk7XG4gICAgY29uc3QgbiA9IHRoaXMucHJvcHM7XG4gICAgKG4udGFyZ2V0IHx8IChpID0gbi50YXJnZXRzKSAhPSBudWxsICYmIGkubGVuZ3RoKSAmJiAodGhpcy5faGFzRmlyc3RUYXJnZXQgPSAhMCk7XG4gICAgY29uc3QgciA9IHRoaXMuY29udHJvbEJveCwgcyA9IG4ucGVyc2lzdERhdGEsIG8gPSBuLmZpcnN0UmVuZGVyU3RhdGU7XG4gICAgaWYgKG8gJiYgIXIpXG4gICAgICByZXR1cm4gbztcbiAgICBpZiAoIXRoaXMuX2hhc0ZpcnN0VGFyZ2V0ICYmIHMpIHtcbiAgICAgIGNvbnN0IGEgPSB5byhzKTtcbiAgICAgIGlmIChhKVxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVTdGF0ZShhLCAhMSksIHRoaXMuc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzUGVyc2lzdGVkID0gITEsIHRoaXMuc3RhdGU7XG4gIH1cbiAgdXBkYXRlU2VsZWN0b3JzKCkge1xuICB9XG4gIHVuc2V0QWJsZXMoKSB7XG4gICAgdGhpcy50YXJnZXRBYmxlcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBuLnVuc2V0ICYmIG4udW5zZXQodGhpcyk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQWJsZXMobiA9IHRoaXMucHJvcHMuYWJsZXMsIHIgPSBcIlwiKSB7XG4gICAgY29uc3QgbyA9IHRoaXMucHJvcHMudHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHksIGkgPSB0aGlzLmdldEVuYWJsZWRBYmxlcyhuKSwgYSA9IGBkcmFnJHtyfVN0YXJ0YCwgYyA9IGBwaW5jaCR7cn1TdGFydGAsIGwgPSBgZHJhZyR7cn1Db250cm9sU3RhcnRgLCB1ID0gTW4oXG4gICAgICBpLFxuICAgICAgW2EsIGNdLFxuICAgICAgb1xuICAgICksIGYgPSBNbihcbiAgICAgIGksXG4gICAgICBbbF0sXG4gICAgICBvXG4gICAgKTtcbiAgICB0aGlzLmVuYWJsZWRBYmxlcyA9IGksIHRoaXMudGFyZ2V0QWJsZXMgPSB1LCB0aGlzLmNvbnRyb2xBYmxlcyA9IGY7XG4gIH1cbiAgdXBkYXRlU3RhdGUobiwgcikge1xuICAgIGlmIChyKSB7XG4gICAgICBpZiAodGhpcy5pc1VubW91bnRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5zZXRTdGF0ZShuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcyA9IHRoaXMuc3RhdGU7XG4gICAgICBmb3IgKGNvbnN0IG8gaW4gbilcbiAgICAgICAgc1tvXSA9IG5bb107XG4gICAgfVxuICB9XG4gIGdldEVuYWJsZWRBYmxlcyhuID0gdGhpcy5wcm9wcy5hYmxlcykge1xuICAgIGNvbnN0IHIgPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiBuLmZpbHRlcihcbiAgICAgIChzKSA9PiBzICYmIChzLmFsd2F5cyAmJiByW3MubmFtZV0gIT09ICExIHx8IHJbcy5uYW1lXSlcbiAgICApO1xuICB9XG4gIHJlbmRlckFibGVzKCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLnByb3BzLnRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5LCBzID0ge1xuICAgICAgY3JlYXRlRWxlbWVudDogQm5cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnJlbmRlclN0YXRlID0ge30sIG11KFxuICAgICAgVmkoXG4gICAgICAgIE1uKFxuICAgICAgICAgIHRoaXMuZ2V0RW5hYmxlZEFibGVzKCksXG4gICAgICAgICAgW1wicmVuZGVyXCJdLFxuICAgICAgICAgIHJcbiAgICAgICAgKS5tYXAoKHsgcmVuZGVyOiBvIH0pID0+IG8odGhpcywgcykgfHwgW10pXG4gICAgICApLmZpbHRlcigobykgPT4gbyksXG4gICAgICAoeyBrZXk6IG8gfSkgPT4gb1xuICAgICkubWFwKChvKSA9PiBvWzBdKTtcbiAgfVxuICB1cGRhdGVDaGVja0lucHV0KCkge1xuICAgIHRoaXMudGFyZ2V0R2VzdG8gJiYgKHRoaXMudGFyZ2V0R2VzdG8ub3B0aW9ucy5jaGVja0lucHV0ID0gdGhpcy5wcm9wcy5jaGVja0lucHV0KTtcbiAgfVxuICBfZ2V0UmVxdWVzdFN0eWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbmFibGVkQWJsZXMoKS5yZWR1Y2UoXG4gICAgICAociwgcykgPT4ge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgY29uc3QgbyA9ICgoaSA9IHMucmVxdWVzdFN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogaS5jYWxsKHMpKSA/PyBbXTtcbiAgICAgICAgcmV0dXJuIFsuLi5yLCAuLi5vXTtcbiAgICAgIH0sXG4gICAgICBbLi4udGhpcy5wcm9wcy5yZXF1ZXN0U3R5bGVzIHx8IFtdXVxuICAgICk7XG4gIH1cbiAgX3VwZGF0ZU9ic2VydmVyKG4pIHtcbiAgICB0aGlzLl91cGRhdGVSZXNpemVPYnNlcnZlcihuKSwgdGhpcy5fdXBkYXRlTXV0YXRpb25PYnNlcnZlcihuKTtcbiAgfVxuICBfdXBkYXRlRXZlbnRzKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLnRhcmdldEFibGVzLmxlbmd0aCwgciA9IHRoaXMuY29udHJvbEFibGVzLmxlbmd0aCwgcyA9IHRoaXMuX2RyYWdUYXJnZXQ7XG4gICAgKCFuICYmIHRoaXMudGFyZ2V0R2VzdG8gfHwgdGhpcy5faXNUYXJnZXRDaGFuZ2VkKCEwKSkgJiYgKHplKHRoaXMsICExKSwgdGhpcy51cGRhdGVTdGF0ZSh7IGdlc3Rvczoge30gfSkpLCByIHx8IHplKHRoaXMsICEwKSwgcyAmJiBuICYmICF0aGlzLnRhcmdldEdlc3RvICYmICh0aGlzLnRhcmdldEdlc3RvID0gb2EodGhpcywgcywgXCJcIikpLCAhdGhpcy5jb250cm9sR2VzdG8gJiYgciAmJiAodGhpcy5jb250cm9sR2VzdG8gPSBpYSh0aGlzLCBcIkNvbnRyb2xcIikpO1xuICB9XG4gIF91cGRhdGVUYXJnZXRzKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuX3ByZXZQcm9wVGFyZ2V0ID0gdGhpcy5fcHJvcFRhcmdldCwgdGhpcy5fcHJldkRyYWdUYXJnZXQgPSB0aGlzLl9kcmFnVGFyZ2V0LCB0aGlzLl9wcmV2T3JpZ2luYWxEcmFnVGFyZ2V0ID0gdGhpcy5fb3JpZ2luYWxEcmFnVGFyZ2V0LCB0aGlzLl9wcmV2RHJhZ0FyZWEgPSBuLmRyYWdBcmVhLCB0aGlzLl9wcm9wVGFyZ2V0ID0gbi50YXJnZXQsIHRoaXMuX29yaWdpbmFsRHJhZ1RhcmdldCA9IG4uZHJhZ1RhcmdldCB8fCBuLnRhcmdldCwgdGhpcy5fZHJhZ1RhcmdldCA9IFp0KHRoaXMuX29yaWdpbmFsRHJhZ1RhcmdldCwgITApO1xuICB9XG4gIF9yZW5kZXJMaW5lcygpIHtcbiAgICBjb25zdCBuID0gdGhpcy5wcm9wcywge1xuICAgICAgem9vbTogcixcbiAgICAgIGhpZGVEZWZhdWx0TGluZXM6IHMsXG4gICAgICBoaWRlQ2hpbGRNb3ZlYWJsZURlZmF1bHRMaW5lczogbyxcbiAgICAgIHBhcmVudE1vdmVhYmxlOiBpXG4gICAgfSA9IG47XG4gICAgaWYgKHMgfHwgaSAmJiBvKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGEgPSB0aGlzLmdldFN0YXRlKCksIGMgPSB7XG4gICAgICBjcmVhdGVFbGVtZW50OiBCblxuICAgIH07XG4gICAgcmV0dXJuIGEucmVuZGVyTGluZXMubWFwKChsLCB1KSA9PiB1bihcbiAgICAgIGMsXG4gICAgICBcIlwiLFxuICAgICAgbFswXSxcbiAgICAgIGxbMV0sXG4gICAgICByLFxuICAgICAgYHJlbmRlci1saW5lLSR7dX1gXG4gICAgKSk7XG4gIH1cbiAgX2lzVGFyZ2V0Q2hhbmdlZChuKSB7XG4gICAgY29uc3QgciA9IHRoaXMucHJvcHMsIHMgPSByLmRyYWdUYXJnZXQgfHwgci50YXJnZXQsIG8gPSB0aGlzLl9wcmV2T3JpZ2luYWxEcmFnVGFyZ2V0LCBpID0gdGhpcy5fcHJldkRyYWdBcmVhLCBhID0gci5kcmFnQXJlYTtcbiAgICByZXR1cm4gIWEgJiYgbyAhPT0gcyB8fCAobiB8fCBhKSAmJiBpICE9PSBhIHx8IHRoaXMuX3ByZXZQcm9wVGFyZ2V0ICE9IHRoaXMuX3Byb3BUYXJnZXQ7XG4gIH1cbiAgX3VwZGF0ZU5hdGl2ZUV2ZW50cygpIHtcbiAgICBjb25zdCByID0gdGhpcy5wcm9wcy5kcmFnQXJlYSA/IHRoaXMuYXJlYUVsZW1lbnQgOiB0aGlzLnN0YXRlLnRhcmdldCwgcyA9IHRoaXMuZXZlbnRzLCBvID0gVmUocyk7XG4gICAgaWYgKHRoaXMuX2lzVGFyZ2V0Q2hhbmdlZCgpKVxuICAgICAgZm9yIChjb25zdCBhIGluIHMpIHtcbiAgICAgICAgY29uc3QgYyA9IHNbYV07XG4gICAgICAgIGMgJiYgYy5kZXN0cm95KCksIHNbYV0gPSBudWxsO1xuICAgICAgfVxuICAgIGlmICghcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdGhpcy5lbmFibGVkQWJsZXM7XG4gICAgby5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBjb25zdCBjID0gTW4oaSwgW2FdKSwgbCA9IGMubGVuZ3RoID4gMDtcbiAgICAgIGxldCB1ID0gc1thXTtcbiAgICAgIGlmICghbCkge1xuICAgICAgICB1ICYmICh1LmRlc3Ryb3koKSwgc1thXSA9IG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1IHx8ICh1ID0gbmV3IGdmKHIsIHRoaXMsIGEpLCBzW2FdID0gdSksIHUuc2V0QWJsZXMoYyk7XG4gICAgfSk7XG4gIH1cbiAgX2NoZWNrVXBkYXRlUm9vdENvbnRhaW5lcigpIHtcbiAgICBjb25zdCBuID0gdGhpcy5wcm9wcy5yb290Q29udGFpbmVyO1xuICAgICF0aGlzLl9yb290Q29udGFpbmVyICYmIG4gJiYgKHRoaXMuX3Jvb3RDb250YWluZXIgPSBadChuLCAhMCkpO1xuICB9XG4gIF9jaGVja1VwZGF0ZVZpZXdDb250YWluZXIoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMucHJvcHMudmlld0NvbnRhaW5lcjtcbiAgICAhdGhpcy5fdmlld0NvbnRhaW5lciAmJiBuICYmICh0aGlzLl92aWV3Q29udGFpbmVyID0gWnQobiwgITApKSwgdGhpcy5fdmlld0NvbnRhaW5lciAmJiB0aGlzLl9jaGFuZ2VBYmxlVmlld0NsYXNzTmFtZXMoW1xuICAgICAgLi4udGhpcy5fZ2V0QWJsZVZpZXdDbGFzc05hbWVzKCksXG4gICAgICB0aGlzLmlzRHJhZ2dpbmcoKSA/IF91IDogXCJcIlxuICAgIF0pO1xuICB9XG4gIF9jaGFuZ2VBYmxlVmlld0NsYXNzTmFtZXMobikge1xuICAgIGNvbnN0IHIgPSB0aGlzLl92aWV3Q29udGFpbmVyLCBzID0gWWkobi5maWx0ZXIoQm9vbGVhbiksIChjKSA9PiBjKS5tYXAoXG4gICAgICAoW2NdKSA9PiBjXG4gICAgKSwgbyA9IHRoaXMuX3ZpZXdDbGFzc05hbWVzLCB7IHJlbW92ZWQ6IGksIGFkZGVkOiBhIH0gPSBwcyhvLCBzKTtcbiAgICBpLmZvckVhY2goKGMpID0+IHtcbiAgICAgIFpvKHIsIG9bY10pO1xuICAgIH0pLCBhLmZvckVhY2goKGMpID0+IHtcbiAgICAgIEtvKHIsIHNbY10pO1xuICAgIH0pLCB0aGlzLl92aWV3Q2xhc3NOYW1lcyA9IHM7XG4gIH1cbiAgX2dldEFibGVWaWV3Q2xhc3NOYW1lcygpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0RW5hYmxlZEFibGVzKCkubWFwKChuKSA9PiB7XG4gICAgICB2YXIgcjtcbiAgICAgIHJldHVybiAoKHIgPSBuLnZpZXdDbGFzc05hbWUpID09IG51bGwgPyB2b2lkIDAgOiByLmNhbGwobiwgdGhpcykpIHx8IFwiXCI7XG4gICAgfSkuam9pbihcIiBcIikgKyBgICR7dGhpcy5fZ2V0QWJsZUNsYXNzTmFtZShcIi12aWV3XCIpfWApLnNwbGl0KC9cXHMrL2cpO1xuICB9XG4gIF9nZXRBYmxlQ2xhc3NOYW1lKG4gPSBcIlwiKSB7XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0RW5hYmxlZEFibGVzKCksIHMgPSB0aGlzLnRhcmdldEdlc3RvLCBvID0gdGhpcy5jb250cm9sR2VzdG8sIGkgPSBzICE9IG51bGwgJiYgcy5pc0ZsYWcoKSA/IHMuZ2V0RXZlbnREYXRhKCkgOiB7fSwgYSA9IG8gIT0gbnVsbCAmJiBvLmlzRmxhZygpID8gby5nZXRFdmVudERhdGEoKSA6IHt9O1xuICAgIHJldHVybiByLm1hcCgoYykgPT4ge1xuICAgICAgdmFyIGYsIGQsIHA7XG4gICAgICBjb25zdCBsID0gYy5uYW1lO1xuICAgICAgbGV0IHUgPSAoKGYgPSBjLmNsYXNzTmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYuY2FsbChjLCB0aGlzKSkgfHwgXCJcIjtcbiAgICAgIHJldHVybiAoKGQgPSBpW2xdKSAhPSBudWxsICYmIGQuaXNFdmVudFN0YXJ0IHx8IChwID0gYVtsXSkgIT0gbnVsbCAmJiBwLmlzRXZlbnRTdGFydCkgJiYgKHUgKz0gYCAke1UoYCR7bH0ke259LWRyYWdnaW5nYCl9YCksIHUudHJpbSgpO1xuICAgIH0pLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgfVxuICBfdXBkYXRlUmVzaXplT2JzZXJ2ZXIobikge1xuICAgIHZhciBhO1xuICAgIGNvbnN0IHIgPSB0aGlzLnByb3BzLCBzID0gci50YXJnZXQsIG8gPSBhZSh0aGlzLmdldENvbnRyb2xCb3hFbGVtZW50KCkpO1xuICAgIGlmICghby5SZXNpemVPYnNlcnZlciB8fCAhcyB8fCAhci51c2VSZXNpemVPYnNlcnZlcikge1xuICAgICAgKGEgPSB0aGlzLl9yZWlzemVPYnNlcnZlcikgPT0gbnVsbCB8fCBhLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG4udGFyZ2V0ID09PSBzICYmIHRoaXMuX3JlaXN6ZU9ic2VydmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBuZXcgby5SZXNpemVPYnNlcnZlcih0aGlzLmNoZWNrVXBkYXRlUmVjdCk7XG4gICAgaS5vYnNlcnZlKHMsIHtcbiAgICAgIGJveDogXCJib3JkZXItYm94XCJcbiAgICB9KSwgdGhpcy5fcmVpc3plT2JzZXJ2ZXIgPSBpO1xuICB9XG4gIF91cGRhdGVNdXRhdGlvbk9ic2VydmVyKG4pIHtcbiAgICB2YXIgYTtcbiAgICBjb25zdCByID0gdGhpcy5wcm9wcywgcyA9IHIudGFyZ2V0LCBvID0gYWUodGhpcy5nZXRDb250cm9sQm94RWxlbWVudCgpKTtcbiAgICBpZiAoIW8uTXV0YXRpb25PYnNlcnZlciB8fCAhcyB8fCAhci51c2VNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAoYSA9IHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIpID09IG51bGwgfHwgYS5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuLnRhcmdldCA9PT0gcyAmJiB0aGlzLl9tdXRhdGlvbk9ic2VydmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBuZXcgby5NdXRhdGlvbk9ic2VydmVyKChjKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGwgb2YgYylcbiAgICAgICAgbC50eXBlID09PSBcImF0dHJpYnV0ZXNcIiAmJiBsLmF0dHJpYnV0ZU5hbWUgPT09IFwic3R5bGVcIiAmJiB0aGlzLmNoZWNrVXBkYXRlUmVjdCgpO1xuICAgIH0pO1xuICAgIGkub2JzZXJ2ZShzLCB7XG4gICAgICBhdHRyaWJ1dGVzOiAhMFxuICAgIH0pLCB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gaTtcbiAgfVxufVxuWCh5ZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBkcmFnVGFyZ2V0U2VsZjogITEsXG4gIHRhcmdldDogbnVsbCxcbiAgZHJhZ1RhcmdldDogbnVsbCxcbiAgY29udGFpbmVyOiBudWxsLFxuICByb290Q29udGFpbmVyOiBudWxsLFxuICBvcmlnaW46ICEwLFxuICBwYXJlbnRNb3ZlYWJsZTogbnVsbCxcbiAgd3JhcHBlck1vdmVhYmxlOiBudWxsLFxuICBpc1dyYXBwZXJNb3VudGVkOiAhMSxcbiAgcGFyZW50UG9zaXRpb246IG51bGwsXG4gIHdhcnBTZWxmOiAhMSxcbiAgc3ZnT3JpZ2luOiBcIlwiLFxuICBkcmFnQ29udGFpbmVyOiBudWxsLFxuICB1c2VSZXNpemVPYnNlcnZlcjogITEsXG4gIHVzZU11dGF0aW9uT2JzZXJ2ZXI6ICExLFxuICBwcmV2ZW50RGVmYXVsdDogITAsXG4gIHByZXZlbnRSaWdodENsaWNrOiAhMCxcbiAgcHJldmVudFdoZWVsQ2xpY2s6ICEwLFxuICBsaW5lUGFkZGluZzogMCxcbiAgY29udHJvbFBhZGRpbmc6IDAsXG4gIGFibGVzOiBbXSxcbiAgcGluY2hUaHJlc2hvbGQ6IDIwLFxuICBkcmFnQXJlYTogITEsXG4gIHBhc3NEcmFnQXJlYTogITEsXG4gIHRyYW5zZm9ybU9yaWdpbjogXCJcIixcbiAgY2xhc3NOYW1lOiBcIlwiLFxuICB6b29tOiAxLFxuICB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseTogITEsXG4gIHBhZGRpbmc6IHt9LFxuICBwaW5jaE91dHNpZGU6ICEwLFxuICBjaGVja0lucHV0OiAhMSxcbiAgZHJhZ0ZvY3VzZWRJbnB1dDogITEsXG4gIGdyb3VwYWJsZTogITEsXG4gIGhpZGVEZWZhdWx0TGluZXM6ICExLFxuICBjc3BOb25jZTogXCJcIixcbiAgdHJhbnNsYXRlWjogMCxcbiAgY3NzU3R5bGVkOiBudWxsLFxuICBjdXN0b21TdHlsZWRNYXA6IHt9LFxuICBwcm9wczoge30sXG4gIHN0b3BQcm9wYWdhdGlvbjogITEsXG4gIHByZXZlbnRDbGlja0RlZmF1bHQ6ICExLFxuICBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZzogITAsXG4gIGZsdXNoU3luYzogQmksXG4gIGZpcnN0UmVuZGVyU3RhdGU6IG51bGwsXG4gIHBlcnNpc3REYXRhOiBudWxsLFxuICB2aWV3Q29udGFpbmVyOiBudWxsLFxuICByZXF1ZXN0U3R5bGVzOiBbXSxcbiAgdXNlQWNjdXJhdGVQb3NpdGlvbjogITFcbn0pO1xuY29uc3QgTXMgPSB7XG4gIG5hbWU6IFwiZ3JvdXBhYmxlXCIsXG4gIHByb3BzOiBbXG4gICAgXCJkZWZhdWx0R3JvdXBSb3RhdGVcIixcbiAgICBcInVzZURlZmF1bHRHcm91cFJvdGF0ZVwiLFxuICAgIFwiZGVmYXVsdEdyb3VwT3JpZ2luXCIsXG4gICAgXCJncm91cGFibGVcIixcbiAgICBcImdyb3VwYWJsZVByb3BzXCIsXG4gICAgXCJ0YXJnZXRHcm91cHNcIixcbiAgICBcImhpZGVDaGlsZE1vdmVhYmxlRGVmYXVsdExpbmVzXCJcbiAgXSxcbiAgZXZlbnRzOiBbXSxcbiAgcmVuZGVyKHQsIGUpIHtcbiAgICB2YXIgZDtcbiAgICBjb25zdCBuID0gdC5wcm9wcztcbiAgICBsZXQgciA9IG4udGFyZ2V0cyB8fCBbXTtcbiAgICBjb25zdCB7IGxlZnQ6IHMsIHRvcDogbywgaXNQZXJzaXN0ZWQ6IGkgfSA9IHQuZ2V0U3RhdGUoKSwgYSA9IG4uem9vbSB8fCAxLCBjID0gdC5yZW5kZXJHcm91cFJlY3RzO1xuICAgIGxldCBsID0gKChkID0gbi5wZXJzaXN0RGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IGQuY2hpbGRyZW4pIHx8IFtdO1xuICAgIGkgPyByID0gbC5tYXAoKCkgPT4gbnVsbCkgOiBsID0gW107XG4gICAgY29uc3QgdSA9IEFlKFxuICAgICAgdCxcbiAgICAgIFwicGFyZW50UG9zaXRpb25cIixcbiAgICAgIFtzLCBvXSxcbiAgICAgIChwKSA9PiBwLmpvaW4oXCIsXCIpXG4gICAgKSwgZiA9IEFlKFxuICAgICAgdCxcbiAgICAgIFwicmVxdWVzdFN0eWxlc1wiLFxuICAgICAgdC5nZXRSZXF1ZXN0Q2hpbGRTdHlsZXMoKSxcbiAgICAgIChwKSA9PiBwLmpvaW4oXCIsXCIpXG4gICAgKTtcbiAgICByZXR1cm4gdC5tb3ZlYWJsZXMgPSB0Lm1vdmVhYmxlcy5zbGljZSgwLCByLmxlbmd0aCksIFtcbiAgICAgIC4uLnIubWFwKChwLCBnKSA9PiAvKiBAX19QVVJFX18gKi8gaXQuanN4KFxuICAgICAgICB5ZSxcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogWW8odCwgXCJtb3ZlYWJsZXNcIiwgZyksXG4gICAgICAgICAgdGFyZ2V0OiBwLFxuICAgICAgICAgIG9yaWdpbjogITEsXG4gICAgICAgICAgcmVxdWVzdFN0eWxlczogZixcbiAgICAgICAgICBjc3NTdHlsZWQ6IG4uY3NzU3R5bGVkLFxuICAgICAgICAgIGN1c3RvbVN0eWxlZE1hcDogbi5jdXN0b21TdHlsZWRNYXAsXG4gICAgICAgICAgdXNlUmVzaXplT2JzZXJ2ZXI6IG4udXNlUmVzaXplT2JzZXJ2ZXIsXG4gICAgICAgICAgdXNlTXV0YXRpb25PYnNlcnZlcjogbi51c2VNdXRhdGlvbk9ic2VydmVyLFxuICAgICAgICAgIGhpZGVDaGlsZE1vdmVhYmxlRGVmYXVsdExpbmVzOiBuLmhpZGVDaGlsZE1vdmVhYmxlRGVmYXVsdExpbmVzLFxuICAgICAgICAgIHBhcmVudE1vdmVhYmxlOiB0LFxuICAgICAgICAgIHBhcmVudFBvc2l0aW9uOiBbcywgb10sXG4gICAgICAgICAgcGVyc2lzdERhdGE6IGxbZ10sXG4gICAgICAgICAgem9vbTogYVxuICAgICAgICB9LFxuICAgICAgICBcIm1vdmVhYmxlXCIgKyBnXG4gICAgICApKSxcbiAgICAgIC4uLlZpKFxuICAgICAgICBjLm1hcCgoeyBwb3MxOiBwLCBwb3MyOiBnLCBwb3MzOiBoLCBwb3M0OiB2IH0sIG0pID0+IHtcbiAgICAgICAgICBjb25zdCBTID0gW3AsIGcsIGgsIHZdO1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbMCwgMV0sXG4gICAgICAgICAgICBbMSwgM10sXG4gICAgICAgICAgICBbMywgMl0sXG4gICAgICAgICAgICBbMiwgMF1cbiAgICAgICAgICBdLm1hcCgoW3gsIENdLCBFKSA9PiB1bihcbiAgICAgICAgICAgIGUsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgSyhTW3hdLCB1KSxcbiAgICAgICAgICAgIEsoU1tDXSwgdSksXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYGdyb3VwLXJlY3QtJHttfS0ke0V9YFxuICAgICAgICAgICkpO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgIF07XG4gIH1cbn0sIHlmID0gZG4oXCJjbGlja2FibGVcIiwge1xuICBwcm9wczogW1xuICAgIFwiY2xpY2thYmxlXCJcbiAgXSxcbiAgZXZlbnRzOiBbXG4gICAgXCJjbGlja1wiLFxuICAgIFwiY2xpY2tHcm91cFwiXG4gIF0sXG4gIGFsd2F5czogITAsXG4gIGRyYWdSZWxhdGlvbjogXCJ3ZWFrXCIsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgZHJhZ1N0YXJ0KCkge1xuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0KCkge1xuICB9LFxuICBkcmFnR3JvdXBTdGFydCh0LCBlKSB7XG4gICAgZS5kYXRhcy5pbnB1dFRhcmdldCA9IGUuaW5wdXRFdmVudCAmJiBlLmlucHV0RXZlbnQudGFyZ2V0O1xuICB9LFxuICBkcmFnRW5kKHQsIGUpIHtcbiAgICBjb25zdCBuID0gdC5wcm9wcy50YXJnZXQsIHIgPSBlLmlucHV0RXZlbnQsIHMgPSBlLmlucHV0VGFyZ2V0LCBpID0gIXQuaXNNb3ZlYWJsZUVsZW1lbnQocykgJiYgdC5jb250cm9sQm94LmNvbnRhaW5zKHMpO1xuICAgIGlmICghciB8fCAhcyB8fCBlLmlzRHJhZyB8fCB0LmlzTW92ZWFibGVFbGVtZW50KHMpIHx8IGkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYSA9IG4uY29udGFpbnMocyk7XG4gICAgaih0LCBcIm9uQ2xpY2tcIiwgZXQodCwgZSwge1xuICAgICAgaXNEb3VibGU6IGUuaXNEb3VibGUsXG4gICAgICBpbnB1dFRhcmdldDogcyxcbiAgICAgIGlzVGFyZ2V0OiBuID09PSBzLFxuICAgICAgbW92ZWFibGVUYXJnZXQ6IHQucHJvcHMudGFyZ2V0LFxuICAgICAgY29udGFpbnNUYXJnZXQ6IGFcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZCh0LCBlKSB7XG4gICAgY29uc3QgbiA9IGUuaW5wdXRFdmVudCwgciA9IGUuaW5wdXRUYXJnZXQ7XG4gICAgaWYgKCFuIHx8ICFyIHx8IGUuaXNEcmFnIHx8IHQuaXNNb3ZlYWJsZUVsZW1lbnQocikgfHwgZS5kYXRhcy5pbnB1dFRhcmdldCA9PT0gcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gdC5wcm9wcy50YXJnZXRzO1xuICAgIGxldCBvID0gcy5pbmRleE9mKHIpO1xuICAgIGNvbnN0IGkgPSBvID4gLTE7XG4gICAgbGV0IGEgPSAhMTtcbiAgICBvID09PSAtMSAmJiAobyA9IG5lKHMsIChjKSA9PiBjLmNvbnRhaW5zKHIpKSwgYSA9IG8gPiAtMSksIGoodCwgXCJvbkNsaWNrR3JvdXBcIiwgZXQodCwgZSwge1xuICAgICAgaXNEb3VibGU6IGUuaXNEb3VibGUsXG4gICAgICB0YXJnZXRzOiBzLFxuICAgICAgaW5wdXRUYXJnZXQ6IHIsXG4gICAgICB0YXJnZXRJbmRleDogbyxcbiAgICAgIGlzVGFyZ2V0OiBpLFxuICAgICAgY29udGFpbnNUYXJnZXQ6IGEsXG4gICAgICBtb3ZlYWJsZVRhcmdldDogc1tvXVxuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQodCwgZSkge1xuICAgIHRoaXMuZHJhZ0VuZCh0LCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZCh0LCBlKSB7XG4gICAgdGhpcy5kcmFnRW5kKHQsIGUpO1xuICB9XG59KTtcbmZ1bmN0aW9uIE9lKHQpIHtcbiAgbGV0IGUgPSB0Lm9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlO1xuICByZXR1cm4gZSB8fCAodC5vcmlnaW5hbERhdGFzLmRyYWdnYWJsZSA9IHt9LCBlID0gdC5vcmlnaW5hbERhdGFzLmRyYWdnYWJsZSksIHsgLi4udCwgZGF0YXM6IGUgfTtcbn1cbmNvbnN0IFJmID0gZG4oXCJlZGdlRHJhZ2dhYmxlXCIsIHtcbiAgY3NzOiBbXG4gICAgYC5lZGdlLmVkZ2VEcmFnZ2FibGUubGluZSB7XG5jdXJzb3I6IG1vdmU7XG59YFxuICBdLFxuICByZW5kZXIodCwgZSkge1xuICAgIGNvbnN0IG4gPSB0LnByb3BzLCByID0gbi5lZGdlRHJhZ2dhYmxlO1xuICAgIHJldHVybiByID8gZmkoXG4gICAgICBlLFxuICAgICAgXCJlZGdlRHJhZ2dhYmxlXCIsXG4gICAgICByLFxuICAgICAgdC5nZXRTdGF0ZSgpLnJlbmRlclBvc2VzLFxuICAgICAgbi56b29tXG4gICAgKSA6IFtdO1xuICB9LFxuICBkcmFnQ29uZGl0aW9uKHQsIGUpIHtcbiAgICB2YXIgcztcbiAgICBjb25zdCBuID0gdC5wcm9wcywgciA9IChzID0gZS5pbnB1dEV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogcy50YXJnZXQ7XG4gICAgcmV0dXJuICFuLmVkZ2VEcmFnZ2FibGUgfHwgIXIgPyAhMSA6ICFuLmRyYWdnYWJsZSAmJiBidChyLCBVKFwiZGlyZWN0aW9uXCIpKSAmJiBidChyLCBVKFwiZWRnZVwiKSkgJiYgYnQociwgVShcImVkZ2VEcmFnZ2FibGVcIikpO1xuICB9LFxuICBkcmFnU3RhcnQodCwgZSkge1xuICAgIHJldHVybiBPdC5kcmFnU3RhcnQodCwgT2UoZSkpO1xuICB9LFxuICBkcmFnKHQsIGUpIHtcbiAgICByZXR1cm4gT3QuZHJhZyh0LCBPZShlKSk7XG4gIH0sXG4gIGRyYWdFbmQodCwgZSkge1xuICAgIHJldHVybiBPdC5kcmFnRW5kKHQsIE9lKGUpKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29uZGl0aW9uKHQsIGUpIHtcbiAgICB2YXIgcztcbiAgICBjb25zdCBuID0gdC5wcm9wcywgciA9IChzID0gZS5pbnB1dEV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogcy50YXJnZXQ7XG4gICAgcmV0dXJuICFuLmVkZ2VEcmFnZ2FibGUgfHwgIXIgPyAhMSA6ICFuLmRyYWdnYWJsZSAmJiBidChyLCBVKFwiZGlyZWN0aW9uXCIpKSAmJiBidChyLCBVKFwibGluZVwiKSk7XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0KHQsIGUpIHtcbiAgICByZXR1cm4gT3QuZHJhZ0dyb3VwU3RhcnQodCwgT2UoZSkpO1xuICB9LFxuICBkcmFnR3JvdXAodCwgZSkge1xuICAgIHJldHVybiBPdC5kcmFnR3JvdXAodCwgT2UoZSkpO1xuICB9LFxuICBkcmFnR3JvdXBFbmQodCwgZSkge1xuICAgIHJldHVybiBPdC5kcmFnR3JvdXBFbmQodCwgT2UoZSkpO1xuICB9LFxuICB1bnNldCh0KSB7XG4gICAgcmV0dXJuIE90LnVuc2V0KHQpO1xuICB9XG59KSwgdWEgPSB7XG4gIG5hbWU6IFwiaW5kaXZpZHVhbEdyb3VwYWJsZVwiLFxuICBwcm9wczogW1xuICAgIFwiaW5kaXZpZHVhbEdyb3VwYWJsZVwiLFxuICAgIFwiaW5kaXZpZHVhbEdyb3VwYWJsZVByb3BzXCJcbiAgXSxcbiAgZXZlbnRzOiBbXVxufSwgUHMgPSBbXG4gIHJhLFxuICBaaSxcbiAgc3UsXG4gIGJ1LFxuICBPdCxcbiAgUmYsXG4gIFRyLFxuICB5dSxcbiAgTXUsXG4gIHdsLFxuICBBdSxcbiAgR3UsXG4gIFR1LFxuICBlZixcbiAgdGYsXG4gIG9mLFxuICBNcyxcbiAgdWEsXG4gIHlmLFxuICBLaSxcbiAgc2Fcbl0sIEJmID0gLyogQF9fUFVSRV9fICovIFBzLnJlZHVjZSgodCwgZSkgPT4gKChlLmV2ZW50cyB8fCBbXSkuZm9yRWFjaCgobikgPT4ge1xuICBVbyh0LCBuKTtcbn0pLCB0KSwgW10pLCB6ZiA9IC8qIEBfX1BVUkVfXyAqLyBQcy5yZWR1Y2UoKHQsIGUpID0+ICgoZS5wcm9wcyB8fCBbXSkuZm9yRWFjaCgobikgPT4ge1xuICBVbyh0LCBuKTtcbn0pLCB0KSwgW10pO1xuZnVuY3Rpb24gUm8oW3QsIGUsIG5dLCByKSB7XG4gIHJldHVybiAodCAqIHJbMF0gKyBlICogclsxXSArIG4pIC8gTWF0aC5zcXJ0KHQgKiB0ICsgZSAqIGUpO1xufVxuZnVuY3Rpb24gd24oW3QsIGVdLCBuKSB7XG4gIHJldHVybiAtdCAqIG5bMF0gLSBlICogblsxXTtcbn1cbmZ1bmN0aW9uIE1vKHQsIGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KFxuICAgIC4uLnQubWFwKChbbiwgciwgcywgb10pID0+IE1hdGgubWF4KG5bZV0sIHJbZV0sIHNbZV0sIG9bZV0pKVxuICApO1xufVxuZnVuY3Rpb24gUG8odCwgZSkge1xuICByZXR1cm4gTWF0aC5taW4oXG4gICAgLi4udC5tYXAoKFtuLCByLCBzLCBvXSkgPT4gTWF0aC5taW4obltlXSwgcltlXSwgc1tlXSwgb1tlXSkpXG4gICk7XG59XG5mdW5jdGlvbiBNZih0LCBlKSB7XG4gIGxldCBuID0gWzAsIDBdLCByID0gWzAsIDBdLCBzID0gWzAsIDBdLCBvID0gWzAsIDBdLCBpID0gMCwgYSA9IDA7XG4gIGlmICghdC5sZW5ndGgpXG4gICAgcmV0dXJuIHtcbiAgICAgIHBvczE6IG4sXG4gICAgICBwb3MyOiByLFxuICAgICAgcG9zMzogcyxcbiAgICAgIHBvczQ6IG8sXG4gICAgICBtaW5YOiAwLFxuICAgICAgbWluWTogMCxcbiAgICAgIG1heFg6IDAsXG4gICAgICBtYXhZOiAwLFxuICAgICAgd2lkdGg6IGksXG4gICAgICBoZWlnaHQ6IGEsXG4gICAgICByb3RhdGlvbjogZVxuICAgIH07XG4gIGNvbnN0IGMgPSB0dChlLCBCdCk7XG4gIGlmIChjICUgOTApIHtcbiAgICBjb25zdCBwID0gYyAvIDE4MCAqIE1hdGguUEksIGcgPSBNYXRoLnRhbihwKSwgaCA9IC0xIC8gZywgdiA9IFtEciwgRnNdLCBtID0gW1xuICAgICAgWzAsIDBdLFxuICAgICAgWzAsIDBdXG4gICAgXSwgUyA9IFtEciwgRnNdLCB4ID0gW1xuICAgICAgWzAsIDBdLFxuICAgICAgWzAsIDBdXG4gICAgXTtcbiAgICB0LmZvckVhY2goKE8pID0+IHtcbiAgICAgIE8uZm9yRWFjaCgoVCkgPT4ge1xuICAgICAgICBjb25zdCB3ID0gUm8oWy1nLCAxLCAwXSwgVCksIGsgPSBSbyhbLWgsIDEsIDBdLCBUKTtcbiAgICAgICAgdlswXSA+IHcgJiYgKG1bMF0gPSBULCB2WzBdID0gdyksIHZbMV0gPCB3ICYmIChtWzFdID0gVCwgdlsxXSA9IHcpLCBTWzBdID4gayAmJiAoeFswXSA9IFQsIFNbMF0gPSBrKSwgU1sxXSA8IGsgJiYgKHhbMV0gPSBULCBTWzFdID0gayk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBbQywgRV0gPSBtLCBbRCwgUl0gPSB4LCB5ID0gWy1nLCAxLCB3bihbLWcsIDFdLCBDKV0sIE0gPSBbLWcsIDEsIHduKFstZywgMV0sIEUpXSwgUCA9IFstaCwgMSwgd24oWy1oLCAxXSwgRCldLCBfID0gWy1oLCAxLCB3bihbLWgsIDFdLCBSKV07XG4gICAgW24sIHIsIHMsIG9dID0gW1xuICAgICAgW3ksIFBdLFxuICAgICAgW3ksIF9dLFxuICAgICAgW00sIFBdLFxuICAgICAgW00sIF9dXG4gICAgXS5tYXAoXG4gICAgICAoW08sIFRdKSA9PiBicyhPLCBUKVswXVxuICAgICksIGkgPSBTWzFdIC0gU1swXSwgYSA9IHZbMV0gLSB2WzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHAgPSBQbyh0LCAwKSwgZyA9IFBvKHQsIDEpLCBoID0gTW8odCwgMCksIHYgPSBNbyh0LCAxKTtcbiAgICBuID0gW3AsIGddLCByID0gW2gsIGddLCBzID0gW3AsIHZdLCBvID0gW2gsIHZdLCBpID0gaCAtIHAsIGEgPSB2IC0gZywgYyAlIDE4MCAmJiAoW24sIHIsIHMsIG9dID0gW3MsIG4sIG8sIHJdLCBpID0gdiAtIGcsIGEgPSBoIC0gcCk7XG4gIH1cbiAgYyAlIDM2MCA+IDE4MCAmJiAoW24sIHIsIHMsIG9dID0gW28sIHMsIHIsIG5dKTtcbiAgY29uc3QgeyBtaW5YOiBsLCBtaW5ZOiB1LCBtYXhYOiBmLCBtYXhZOiBkIH0gPSBiZShbbiwgciwgcywgb10pO1xuICByZXR1cm4ge1xuICAgIHBvczE6IG4sXG4gICAgcG9zMjogcixcbiAgICBwb3MzOiBzLFxuICAgIHBvczQ6IG8sXG4gICAgd2lkdGg6IGksXG4gICAgaGVpZ2h0OiBhLFxuICAgIG1pblg6IGwsXG4gICAgbWluWTogdSxcbiAgICBtYXhYOiBmLFxuICAgIG1heFk6IGQsXG4gICAgcm90YXRpb246IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZhKHQsIGUpIHtcbiAgY29uc3QgbiA9IGUubWFwKChyKSA9PiB7XG4gICAgaWYgKFJ0KHIpKSB7XG4gICAgICBjb25zdCBzID0gZmEodCwgciksIG8gPSBzLmxlbmd0aDtcbiAgICAgIHJldHVybiBvID4gMSA/IHMgOiBvID09PSAxID8gc1swXSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMgPSBrdChcbiAgICAgICAgdCxcbiAgICAgICAgKHsgbWFuYWdlcjogbyB9KSA9PiBvLnByb3BzLnRhcmdldCA9PT0gclxuICAgICAgKTtcbiAgICAgIHJldHVybiBzID8gKHMuZmluZGVkID0gITAsIHMubWFuYWdlcikgOiBudWxsO1xuICAgIH1cbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICByZXR1cm4gbi5sZW5ndGggPT09IDEgJiYgUnQoblswXSkgPyBuWzBdIDogbjtcbn1cbmNsYXNzIGRhIGV4dGVuZHMgeWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIFgodGhpcywgXCJkaWZmZXJcIiwgbmV3IF9pKCkpO1xuICAgIFgodGhpcywgXCJtb3ZlYWJsZXNcIiwgW10pO1xuICAgIFgodGhpcywgXCJ0cmFuc2Zvcm1PcmlnaW5cIiwgXCI1MCUgNTAlXCIpO1xuICAgIFgodGhpcywgXCJyZW5kZXJHcm91cFJlY3RzXCIsIFtdKTtcbiAgICBYKHRoaXMsIFwiX3RhcmdldEdyb3Vwc1wiLCBbXSk7XG4gICAgWCh0aGlzLCBcIl9oYXNGaXJzdFRhcmdldHNcIiwgITEpO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KCk7XG4gIH1cbiAgY2hlY2tVcGRhdGUoKSB7XG4gICAgdGhpcy5faXNQcm9wVGFyZ2V0Q2hhbmdlZCA9ICExLCB0aGlzLnVwZGF0ZUFibGVzKCk7XG4gIH1cbiAgZ2V0VGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy50YXJnZXRzO1xuICB9XG4gIHVwZGF0ZVJlY3QobiwgciwgcyA9ICEwKSB7XG4gICAgdmFyIFc7XG4gICAgY29uc3QgbyA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xCb3ggfHwgby5pc1BlcnNpc3RlZClcbiAgICAgIHJldHVybjtcbiAgICBMZSghMCksIHRoaXMubW92ZWFibGVzLmZvckVhY2goKEopID0+IHtcbiAgICAgIEoudXBkYXRlUmVjdChuLCAhMSwgITEpO1xuICAgIH0pO1xuICAgIGNvbnN0IGkgPSB0aGlzLnByb3BzLCBhID0gdGhpcy5tb3ZlYWJsZXMsIGMgPSBvLnRhcmdldCB8fCBpLnRhcmdldCwgbCA9IGEubWFwKChKKSA9PiAoe1xuICAgICAgZmluZGVkOiAhMSxcbiAgICAgIG1hbmFnZXI6IEpcbiAgICB9KSksIHUgPSB0aGlzLnByb3BzLnRhcmdldEdyb3VwcyB8fCBbXSwgZiA9IGZhKGwsIHUpLCBkID0gaS51c2VEZWZhdWx0R3JvdXBSb3RhdGU7XG4gICAgZi5wdXNoKFxuICAgICAgLi4ubC5maWx0ZXIoKHsgZmluZGVkOiBKIH0pID0+ICFKKS5tYXAoKHsgbWFuYWdlcjogSiB9KSA9PiBKKVxuICAgICk7XG4gICAgY29uc3QgcCA9IFtdLCBnID0gIXIgfHwgbiAhPT0gXCJcIiAmJiBpLnVwZGF0ZUdyb3VwO1xuICAgIGxldCBoID0gaS5kZWZhdWx0R3JvdXBSb3RhdGUgfHwgMDtcbiAgICBpZiAoIXRoaXMuX2hhc0ZpcnN0VGFyZ2V0cykge1xuICAgICAgY29uc3QgSiA9IChXID0gaS5wZXJzaXN0RGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IFcucm90YXRpb247XG4gICAgICBKICE9IG51bGwgJiYgKGggPSBKKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdihKLCBxLCBGKSB7XG4gICAgICBjb25zdCBIID0gSi5tYXAoKHV0KSA9PiB7XG4gICAgICAgIGlmIChSdCh1dCkpIHtcbiAgICAgICAgICBjb25zdCBTdCA9IHYodXQsIHEpLCBLdCA9IFtTdC5wb3MxLCBTdC5wb3MyLCBTdC5wb3MzLCBTdC5wb3M0XTtcbiAgICAgICAgICByZXR1cm4gcC5wdXNoKFN0KSwgeyBwb3NlczogS3QsIHJvdGF0aW9uOiBTdC5yb3RhdGlvbiB9O1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zZXM6IGp0KHV0LnN0YXRlKSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiB1dC5nZXRSb3RhdGlvbigpXG4gICAgICAgICAgfTtcbiAgICAgIH0pLCBudCA9IEgubWFwKCh7IHJvdGF0aW9uOiB1dCB9KSA9PiB1dCk7XG4gICAgICBsZXQgbHQgPSAwO1xuICAgICAgY29uc3QgdnQgPSBudFswXSwgc3QgPSBudC5ldmVyeSgodXQpID0+IE1hdGguYWJzKHZ0IC0gdXQpIDwgMC4xKTtcbiAgICAgIGcgPyBsdCA9ICFkICYmIHN0ID8gdnQgOiBoIDogbHQgPSAhZCAmJiAhRiAmJiBzdCA/IHZ0IDogcTtcbiAgICAgIGNvbnN0IEZ0ID0gSC5tYXAoKHsgcG9zZXM6IHV0IH0pID0+IHV0KTtcbiAgICAgIHJldHVybiBNZihGdCwgbHQpO1xuICAgIH1cbiAgICBjb25zdCBtID0gdihcbiAgICAgIGYsXG4gICAgICB0aGlzLnJvdGF0aW9uLFxuICAgICAgITBcbiAgICApO1xuICAgIGcgJiYgKHRoaXMucm90YXRpb24gPSBtLnJvdGF0aW9uLCB0aGlzLnRyYW5zZm9ybU9yaWdpbiA9IGkuZGVmYXVsdEdyb3VwT3JpZ2luIHx8IFwiNTAlIDUwJVwiLCB0aGlzLnNjYWxlID0gWzEsIDFdKSwgdGhpcy5fdGFyZ2V0R3JvdXBzID0gdSwgdGhpcy5yZW5kZXJHcm91cFJlY3RzID0gcDtcbiAgICBjb25zdCBTID0gdGhpcy50cmFuc2Zvcm1PcmlnaW4sIHggPSB0aGlzLnJvdGF0aW9uLCBDID0gdGhpcy5zY2FsZSwgeyB3aWR0aDogRSwgaGVpZ2h0OiBELCBtaW5YOiBSLCBtaW5ZOiB5IH0gPSBtLCBNID0gRHUoXG4gICAgICBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW0UsIDBdLFxuICAgICAgICBbMCwgRF0sXG4gICAgICAgIFtFLCBEXVxuICAgICAgXSxcbiAgICAgIEVzKFMsIEUsIEQpLFxuICAgICAgdGhpcy5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUElcbiAgICApLCB7IG1pblg6IFAsIG1pblk6IF8gfSA9IGJlKE0ucmVzdWx0KSwgTyA9IGAgcm90YXRlKCR7eH1kZWcpIHNjYWxlKCR7d3QoQ1swXSl9LCAke3d0KENbMV0pfSlgLCBUID0gYHRyYW5zbGF0ZSgkey1QfXB4LCAkey1ffXB4KSR7T31gO1xuICAgIHRoaXMuY29udHJvbEJveC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtSfXB4LCAke3l9cHgsICR7dGhpcy5wcm9wcy50cmFuc2xhdGVaIHx8IDB9KWAsIGMuc3R5bGUuY3NzVGV4dCArPSBgbGVmdDowcHg7dG9wOjBweDt0cmFuc2Zvcm0tb3JpZ2luOiR7U307d2lkdGg6JHtFfXB4O2hlaWdodDoke0R9cHg7dHJhbnNmb3JtOiAke1R9YCwgby53aWR0aCA9IEUsIG8uaGVpZ2h0ID0gRDtcbiAgICBjb25zdCB3ID0gdGhpcy5nZXRDb250YWluZXIoKSwgayA9IFlyKFxuICAgICAgdGhpcy5jb250cm9sQm94LFxuICAgICAgYyxcbiAgICAgIHRoaXMuY29udHJvbEJveCxcbiAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCksXG4gICAgICB0aGlzLl9yb290Q29udGFpbmVyIHx8IHcsXG4gICAgICBbXVxuICAgICksIEkgPSBbay5sZWZ0LCBrLnRvcF0sIFskLCBHLCBMLCB6XSA9IGp0KGspLCBOID0gYmUoWyQsIEcsIEwsIHpdKSwgWiA9IFtOLm1pblgsIE4ubWluWV0sIFkgPSB3dChDWzBdICogQ1sxXSk7XG4gICAgay5wb3MxID0gSygkLCBaKSwgay5wb3MyID0gSyhHLCBaKSwgay5wb3MzID0gSyhMLCBaKSwgay5wb3M0ID0gSyh6LCBaKSwgay5sZWZ0ID0gUiAtIGsubGVmdCArIFpbMF0sIGsudG9wID0geSAtIGsudG9wICsgWlsxXSwgay5vcmlnaW4gPSBLKGF0KEksIGsub3JpZ2luKSwgWiksIGsuYmVmb3JlT3JpZ2luID0gSyhhdChJLCBrLmJlZm9yZU9yaWdpbiksIFopLCBrLm9yaWdpbmFsQmVmb3JlT3JpZ2luID0gYXQoSSwgay5vcmlnaW5hbEJlZm9yZU9yaWdpbiksIGsudHJhbnNmb3JtT3JpZ2luID0gSyhhdChJLCBrLnRyYW5zZm9ybU9yaWdpbiksIFopLCBjLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHstUCAtIFpbMF19cHgsICR7LV8gLSBaWzFdfXB4KWAgKyBPLCBMZSgpLCB0aGlzLnVwZGF0ZVN0YXRlKFxuICAgICAge1xuICAgICAgICAuLi5rLFxuICAgICAgICBwb3NEZWx0YTogWixcbiAgICAgICAgZGlyZWN0aW9uOiBZLFxuICAgICAgICBiZWZvcmVEaXJlY3Rpb246IFlcbiAgICAgIH0sXG4gICAgICBzXG4gICAgKTtcbiAgfVxuICBnZXRSZWN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXRSZWN0KCksXG4gICAgICBjaGlsZHJlbjogdGhpcy5tb3ZlYWJsZXMubWFwKChuKSA9PiBuLmdldFJlY3QoKSlcbiAgICB9O1xuICB9XG4gIHRyaWdnZXJFdmVudChuLCByLCBzKSB7XG4gICAgaWYgKHMgfHwgbi5pbmRleE9mKFwiR3JvdXBcIikgPiAtMSlcbiAgICAgIHJldHVybiBzdXBlci50cmlnZ2VyRXZlbnQobiwgcik7XG4gICAgdGhpcy5fZW1pdHRlci50cmlnZ2VyKG4sIHIpO1xuICB9XG4gIGdldFJlcXVlc3RDaGlsZFN0eWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbmFibGVkQWJsZXMoKS5yZWR1Y2UoXG4gICAgICAociwgcykgPT4ge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgY29uc3QgbyA9ICgoaSA9IHMucmVxdWVzdENoaWxkU3R5bGUpID09IG51bGwgPyB2b2lkIDAgOiBpLmNhbGwocykpID8/IFtdO1xuICAgICAgICByZXR1cm4gWy4uLnIsIC4uLm9dO1xuICAgICAgfSxcbiAgICAgIFtdXG4gICAgKTtcbiAgfVxuICBnZXRNb3ZlYWJsZXMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLm1vdmVhYmxlc107XG4gIH1cbiAgdXBkYXRlQWJsZXMoKSB7XG4gICAgc3VwZXIudXBkYXRlQWJsZXMoWy4uLnRoaXMucHJvcHMuYWJsZXMsIE1zXSwgXCJHcm91cFwiKTtcbiAgfVxuICBfdXBkYXRlVGFyZ2V0cygpIHtcbiAgICBzdXBlci5fdXBkYXRlVGFyZ2V0cygpLCB0aGlzLl9vcmlnaW5hbERyYWdUYXJnZXQgPSB0aGlzLnByb3BzLmRyYWdUYXJnZXQgfHwgdGhpcy5hcmVhRWxlbWVudCwgdGhpcy5fZHJhZ1RhcmdldCA9IFp0KHRoaXMuX29yaWdpbmFsRHJhZ1RhcmdldCwgITApO1xuICB9XG4gIF91cGRhdGVFdmVudHMoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuc3RhdGUsIHIgPSB0aGlzLnByb3BzLCBzID0gdGhpcy5fcHJldkRyYWdUYXJnZXQsIG8gPSByLmRyYWdUYXJnZXQgfHwgdGhpcy5hcmVhRWxlbWVudCwgaSA9IHIudGFyZ2V0cywgeyBhZGRlZDogYSwgY2hhbmdlZDogYywgcmVtb3ZlZDogbCB9ID0gdGhpcy5kaWZmZXIudXBkYXRlKGkpLCB1ID0gYS5sZW5ndGggfHwgbC5sZW5ndGg7XG4gICAgKHUgfHwgdGhpcy5fcHJldk9yaWdpbmFsRHJhZ1RhcmdldCAhPT0gdGhpcy5fb3JpZ2luYWxEcmFnVGFyZ2V0KSAmJiAoemUodGhpcywgITEpLCB6ZSh0aGlzLCAhMCksIHRoaXMudXBkYXRlU3RhdGUoeyBnZXN0b3M6IHt9IH0pKSwgcyAhPT0gbyAmJiAobi50YXJnZXQgPSBudWxsKSwgbi50YXJnZXQgfHwgKG4udGFyZ2V0ID0gdGhpcy5hcmVhRWxlbWVudCwgdGhpcy5jb250cm9sQm94LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIpLCBuLnRhcmdldCAmJiAodGhpcy50YXJnZXRHZXN0byB8fCAodGhpcy50YXJnZXRHZXN0byA9IG9hKHRoaXMsIHRoaXMuX2RyYWdUYXJnZXQsIFwiR3JvdXBcIikpLCB0aGlzLmNvbnRyb2xHZXN0byB8fCAodGhpcy5jb250cm9sR2VzdG8gPSBpYSh0aGlzLCBcIkdyb3VwQ29udHJvbFwiKSkpO1xuICAgIGNvbnN0IGYgPSAhQXIobi5jb250YWluZXIsIHIuY29udGFpbmVyKTtcbiAgICBmICYmIChuLmNvbnRhaW5lciA9IHIuY29udGFpbmVyKSwgKGYgfHwgdSB8fCB0aGlzLnRyYW5zZm9ybU9yaWdpbiAhPT0gKHIuZGVmYXVsdEdyb3VwT3JpZ2luIHx8IFwiNTAlIDUwJVwiKSB8fCBjLmxlbmd0aCB8fCBpLmxlbmd0aCAmJiAhSGkodGhpcy5fdGFyZ2V0R3JvdXBzLCByLnRhcmdldEdyb3VwcyB8fCBbXSkpICYmICh0aGlzLnVwZGF0ZVJlY3QoKSwgdGhpcy5faGFzRmlyc3RUYXJnZXRzID0gITApLCB0aGlzLl9pc1Byb3BUYXJnZXRDaGFuZ2VkID0gISF1O1xuICB9XG4gIF91cGRhdGVPYnNlcnZlcigpIHtcbiAgfVxufVxuWChkYSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICAuLi55ZS5kZWZhdWx0UHJvcHMsXG4gIHRyYW5zZm9ybU9yaWdpbjogW1wiNTAlXCIsIFwiNTAlXCJdLFxuICBncm91cGFibGU6ICEwLFxuICBkcmFnQXJlYTogITAsXG4gIGtlZXBSYXRpbzogITAsXG4gIHRhcmdldHM6IFtdLFxuICBkZWZhdWx0R3JvdXBSb3RhdGU6IDAsXG4gIGRlZmF1bHRHcm91cE9yaWdpbjogXCI1MCUgNTAlXCJcbn0pO1xuY2xhc3MgUGYgZXh0ZW5kcyB5ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgWCh0aGlzLCBcIm1vdmVhYmxlc1wiLCBbXSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLnByb3BzLCB7IGNzcE5vbmNlOiByLCBjc3NTdHlsZWQ6IHMsIHBlcnNpc3REYXRhOiBvIH0gPSBuO1xuICAgIGxldCBpID0gbi50YXJnZXRzIHx8IFtdO1xuICAgIGNvbnN0IGEgPSBpLmxlbmd0aCwgYyA9IHRoaXMuaXNVbm1vdW50ZWQgfHwgIWE7XG4gICAgbGV0IGwgPSAobyA9PSBudWxsID8gdm9pZCAwIDogby5jaGlsZHJlbikgPz8gW107XG4gICAgcmV0dXJuIGMgJiYgIWEgJiYgbC5sZW5ndGggPyBpID0gbC5tYXAoKCkgPT4gbnVsbCkgOiBjIHx8IChsID0gW10pLCAvKiBAX19QVVJFX18gKi8gaXQuanN4KFxuICAgICAgcyxcbiAgICAgIHtcbiAgICAgICAgY3NwTm9uY2U6IHIsXG4gICAgICAgIHJlZjogU2UodGhpcywgXCJjb250cm9sQm94XCIpLFxuICAgICAgICBjbGFzc05hbWU6IFUoXCJjb250cm9sLWJveFwiKSxcbiAgICAgICAgY2hpbGRyZW46IGkubWFwKCh1LCBmKSA9PiB7XG4gICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgY29uc3QgZCA9ICgocCA9IG4uaW5kaXZpZHVhbEdyb3VwYWJsZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogcC5jYWxsKG4sIHUsIGYpKSA/PyB7fTtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgICAgIHllLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZWY6IFlvKHRoaXMsIFwibW92ZWFibGVzXCIsIGYpLFxuICAgICAgICAgICAgICAuLi5uLFxuICAgICAgICAgICAgICAuLi5kLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHUsXG4gICAgICAgICAgICAgIHdyYXBwZXJNb3ZlYWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgaXNXcmFwcGVyTW91bnRlZDogdGhpcy5pc01vdmVhYmxlTW91bnRlZCxcbiAgICAgICAgICAgICAgcGVyc2lzdERhdGE6IGxbZl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1vdmVhYmxlXCIgKyBmXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgfVxuICBnZXRUYXJnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnRhcmdldHM7XG4gIH1cbiAgdXBkYXRlUmVjdChuLCByLCBzID0gITApIHtcbiAgICBMZSghMCksIHRoaXMubW92ZWFibGVzLmZvckVhY2goKG8pID0+IHtcbiAgICAgIG8udXBkYXRlUmVjdChuLCByLCBzKTtcbiAgICB9KSwgTGUoKTtcbiAgfVxuICBnZXRSZWN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXRSZWN0KCksXG4gICAgICBjaGlsZHJlbjogdGhpcy5tb3ZlYWJsZXMubWFwKChuKSA9PiBuLmdldFJlY3QoKSlcbiAgICB9O1xuICB9XG4gIHJlcXVlc3QobiwgciA9IHt9LCBzKSB7XG4gICAgY29uc3QgbyA9IHRoaXMubW92ZWFibGVzLm1hcChcbiAgICAgIChjKSA9PiBjLnJlcXVlc3QobiwgeyAuLi5yLCBpc0luc3RhbnQ6ICExIH0sICExKVxuICAgICksIGkgPSBzIHx8IHIuaXNJbnN0YW50LCBhID0ge1xuICAgICAgcmVxdWVzdChjKSB7XG4gICAgICAgIHJldHVybiBvLmZvckVhY2goKGwpID0+IGwucmVxdWVzdChjKSksIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVxdWVzdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIG8uZm9yRWFjaCgoYykgPT4gYy5yZXF1ZXN0RW5kKCkpLCB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGkgPyBhLnJlcXVlc3QocikucmVxdWVzdEVuZCgpIDogYTtcbiAgfVxuICBkcmFnU3RhcnQobiwgciA9IG4udGFyZ2V0KSB7XG4gICAgY29uc3QgcyA9IHIsIG8gPSBrdCh0aGlzLm1vdmVhYmxlcywgKGkpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBpLmdldFRhcmdldHMoKVswXSwgYyA9IGkuZ2V0Q29udHJvbEJveEVsZW1lbnQoKSwgbCA9IGkuZ2V0RHJhZ0VsZW1lbnQoKTtcbiAgICAgIHJldHVybiAhYSB8fCAhbCA/ICExIDogbCA9PT0gcyB8fCBsLmNvbnRhaW5zKHMpIHx8IGwgIT09IGEgJiYgYSA9PT0gcyB8fCBhLmNvbnRhaW5zKHMpIHx8IGMgPT09IHMgfHwgYy5jb250YWlucyhzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbyAmJiBvLmRyYWdTdGFydChuLCByKSwgdGhpcztcbiAgfVxuICBoaXRUZXN0KCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlzSW5zaWRlKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBpc0RyYWdnaW5nKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBnZXREcmFnRWxlbWVudCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRNb3ZlYWJsZXMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLm1vdmVhYmxlc107XG4gIH1cbiAgdXBkYXRlUmVuZGVyUG9zZXMoKSB7XG4gIH1cbiAgY2hlY2tVcGRhdGUoKSB7XG4gIH1cbiAgdHJpZ2dlckV2ZW50KCkge1xuICB9XG4gIHVwZGF0ZUFibGVzKCkge1xuICB9XG4gIF91cGRhdGVFdmVudHMoKSB7XG4gIH1cbiAgX3VwZGF0ZU9ic2VydmVyKCkge1xuICB9XG59XG5mdW5jdGlvbiBwYSh0LCBlKSB7XG4gIGNvbnN0IG4gPSBbXTtcbiAgcmV0dXJuIHQuZm9yRWFjaCgocikgPT4ge1xuICAgIGlmIChyKSB7XG4gICAgICBpZiAocmUocikpIHtcbiAgICAgICAgZVtyXSAmJiBuLnB1c2goLi4uZVtyXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFJ0KHIpID8gbi5wdXNoKC4uLnBhKHIsIGUpKSA6IG4ucHVzaChyKTtcbiAgICB9XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gZ2EodCwgZSkge1xuICBjb25zdCBuID0gW107XG4gIHJldHVybiB0LmZvckVhY2goKHIpID0+IHtcbiAgICBpZiAocikge1xuICAgICAgaWYgKHJlKHIpKSB7XG4gICAgICAgIGVbcl0gJiYgbi5wdXNoKC4uLmVbcl0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBSdChyKSA/IG4ucHVzaChnYShyLCBlKSkgOiBuLnB1c2gocik7XG4gICAgfVxuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIGhhKHQsIGUpIHtcbiAgcmV0dXJuIHQubGVuZ3RoICE9PSBlLmxlbmd0aCB8fCB0LnNvbWUoKG4sIHIpID0+IHtcbiAgICBjb25zdCBzID0gZVtyXTtcbiAgICByZXR1cm4gIW4gJiYgIXMgPyAhMSA6IG4gIT0gcyA/IFJ0KG4pICYmIFJ0KHMpID8gaGEobiwgcykgOiAhMCA6ICExO1xuICB9KTtcbn1cbmNsYXNzIG9uIGV4dGVuZHMgX28uUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLy8gQHdpdGhNZXRob2RzKE1PVkVBQkxFX01FVEhPRFMpXG4gICAgWCh0aGlzLCBcIm1vdmVhYmxlXCIpO1xuICAgIFgodGhpcywgXCJyZWZUYXJnZXRzXCIsIFtdKTtcbiAgICBYKHRoaXMsIFwic2VsZWN0b3JNYXBcIiwge30pO1xuICAgIFgodGhpcywgXCJfZGlmZmVyXCIsIG5ldyBfaSgpKTtcbiAgICBYKHRoaXMsIFwiX2VsZW1lbnRUYXJnZXRzXCIsIFtdKTtcbiAgICBYKHRoaXMsIFwiX3RtcFJlZlRhcmdldHNcIiwgW10pO1xuICAgIFgodGhpcywgXCJfdG1wU2VsZWN0b3JNYXBcIiwge30pO1xuICAgIFgodGhpcywgXCJfb25DaGFuZ2VUYXJnZXRzXCIsIG51bGwpO1xuICB9XG4gIHN0YXRpYyBtYWtlU3R5bGVkKCkge1xuICAgIGNvbnN0IG4gPSB7fTtcbiAgICB0aGlzLmdldFRvdGFsQWJsZXMoKS5mb3JFYWNoKCh7IGNzczogbyB9KSA9PiB7XG4gICAgICBvICYmIG8uZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBuW2ldID0gITA7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBzID0gVmUobikuam9pbihgXG5gKTtcbiAgICB0aGlzLmRlZmF1bHRTdHlsZWQgPSBjYShcImRpdlwiLCBsYyhIciwgb2MgKyBzKSk7XG4gIH1cbiAgc3RhdGljIGdldFRvdGFsQWJsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFppLFxuICAgICAgTXMsXG4gICAgICB1YSxcbiAgICAgIEtpLFxuICAgICAgLi4udGhpcy5kZWZhdWx0QWJsZXNcbiAgICBdO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBuID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBuLmRlZmF1bHRTdHlsZWQgfHwgbi5tYWtlU3R5bGVkKCk7XG4gICAgY29uc3QgeyBhYmxlczogciwgcHJvcHM6IHMsIC4uLm8gfSA9IHRoaXMucHJvcHMsIFtpLCBhXSA9IHRoaXMuX3VwZGF0ZVJlZnMoITApLCBjID0gcGEoaSwgYSk7XG4gICAgbGV0IGwgPSBjLmxlbmd0aCA+IDE7XG4gICAgY29uc3QgZiA9IFsuLi5uLmdldFRvdGFsQWJsZXMoKSwgLi4uciB8fCBbXV0sIGQgPSB7XG4gICAgICAuLi5vLFxuICAgICAgLi4ucyB8fCB7fSxcbiAgICAgIGFibGVzOiBmLFxuICAgICAgY3NzU3R5bGVkOiBuLmRlZmF1bHRTdHlsZWQsXG4gICAgICBjdXN0b21TdHlsZWRNYXA6IG4uY3VzdG9tU3R5bGVkTWFwXG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50VGFyZ2V0cyA9IGM7XG4gICAgbGV0IHAgPSBudWxsO1xuICAgIGNvbnN0IGcgPSB0aGlzLm1vdmVhYmxlLCBoID0gby5wZXJzaXN0RGF0YTtcbiAgICBpZiAoaCAhPSBudWxsICYmIGguY2hpbGRyZW4gJiYgKGwgPSAhMCksIG8uaW5kaXZpZHVhbEdyb3VwYWJsZSlcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaXQuanN4KFxuICAgICAgICBQZixcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogU2UodGhpcywgXCJtb3ZlYWJsZVwiKSxcbiAgICAgICAgICAuLi5kLFxuICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICB0YXJnZXRzOiBjXG4gICAgICAgIH0sXG4gICAgICAgIFwiaW5kaXZpZHVhbC1ncm91cFwiXG4gICAgICApO1xuICAgIGlmIChsKSB7XG4gICAgICBjb25zdCB2ID0gZ2EoaSwgYSk7XG4gICAgICBpZiAoZyAmJiAhZy5wcm9wcy5ncm91cGFibGUgJiYgIWcucHJvcHMuaW5kaXZpZHVhbEdyb3VwYWJsZSkge1xuICAgICAgICBjb25zdCBtID0gZy5wcm9wcy50YXJnZXQ7XG4gICAgICAgIG0gJiYgYy5pbmRleE9mKG0pID4gLTEgJiYgKHAgPSB7IC4uLmcuc3RhdGUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGl0LmpzeChcbiAgICAgICAgZGEsXG4gICAgICAgIHtcbiAgICAgICAgICByZWY6IFNlKHRoaXMsIFwibW92ZWFibGVcIiksXG4gICAgICAgICAgLi4uZCxcbiAgICAgICAgICAuLi5vLmdyb3VwYWJsZVByb3BzID8/IHt9LFxuICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICB0YXJnZXRzOiBjLFxuICAgICAgICAgIHRhcmdldEdyb3VwczogdixcbiAgICAgICAgICBmaXJzdFJlbmRlclN0YXRlOiBwXG4gICAgICAgIH0sXG4gICAgICAgIFwiZ3JvdXBcIlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdiA9IGNbMF07XG4gICAgICBpZiAoZyAmJiAoZy5wcm9wcy5ncm91cGFibGUgfHwgZy5wcm9wcy5pbmRpdmlkdWFsR3JvdXBhYmxlKSkge1xuICAgICAgICBjb25zdCBtID0gZy5tb3ZlYWJsZXMgfHwgW10sIFMgPSBrdChcbiAgICAgICAgICBtLFxuICAgICAgICAgICh4KSA9PiB4LnByb3BzLnRhcmdldCA9PT0gdlxuICAgICAgICApO1xuICAgICAgICBTICYmIChwID0geyAuLi5TLnN0YXRlIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpdC5qc3goXG4gICAgICAgIHllLFxuICAgICAgICB7XG4gICAgICAgICAgcmVmOiBTZSh0aGlzLCBcIm1vdmVhYmxlXCIpLFxuICAgICAgICAgIC4uLmQsXG4gICAgICAgICAgdGFyZ2V0OiB2LFxuICAgICAgICAgIGZpcnN0UmVuZGVyU3RhdGU6IHBcbiAgICAgICAgfSxcbiAgICAgICAgXCJzaW5nbGVcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5fY2hlY2tDaGFuZ2VUYXJnZXRzKCk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuX2NoZWNrQ2hhbmdlVGFyZ2V0cygpO1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuc2VsZWN0b3JNYXAgPSB7fSwgdGhpcy5yZWZUYXJnZXRzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0YXJnZXRzIHNldCBpbiBtb3ZlYWJsZSB0aHJvdWdoIHRhcmdldCBvciB0YXJnZXRzIG9mIHByb3BzLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2dldFRhcmdldHNcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gICAqICAgIHRhcmdldDogW3RhcmdldFJlZiwgXCIudGFyZ2V0XCIsIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpXSxcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKG1vdmVhYmxlLmdldFRhcmdldHMoKSk7XG4gICAqL1xuICBnZXRUYXJnZXRzKCkge1xuICAgIHZhciBuO1xuICAgIHJldHVybiAoKG4gPSB0aGlzLm1vdmVhYmxlKSA9PSBudWxsID8gdm9pZCAwIDogbi5nZXRUYXJnZXRzKCkpID8/IFtdO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0aGUgZWxlbWVudCBsaXN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNlbGVjdG9yIGFtb25nIHRoZSB0YXJnZXRzIGlzIGNoYW5nZWQsIGl0IGlzIHVwZGF0ZWQuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjdXBkYXRlU2VsZWN0b3JzXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICAgKiAgICB0YXJnZXQ6IFwiLnRhcmdldFwiLFxuICAgKiB9KTtcbiAgICpcbiAgICogbW92ZWFibGUudXBkYXRlU2VsZWN0b3JzKCk7XG4gICAqL1xuICB1cGRhdGVTZWxlY3RvcnMoKSB7XG4gICAgdGhpcy5zZWxlY3Rvck1hcCA9IHt9LCB0aGlzLl91cGRhdGVSZWZzKCksIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogVXNlciBjaGFuZ2VzIHRhcmdldCBhbmQgd2FpdHMgZm9yIHRhcmdldCB0byBjaGFuZ2UuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjd2FpdFRvQ2hhbmdlVGFyZ2V0XG4gICAqIEBzdG9yeSBjb21iaW5hdGlvbi13aXRoLW90aGVyLWNvbXBvbmVudHMtLWNvbXBvbmVudHMtc2VsZWN0b1xuICAgKiBAZXhhbXBsZVxuICAgKiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xuICAgKiAgIG1vdmVhYmxlLndhaXRUb0NoYW5nZVRhcmdldCgpLnRoZW4oKCkgPT4ge1xuICAgKiAgICAgIG1vdmVhYmxlLmRyYWdTdGFydChlLCBlLmN1cnJlbnRUYXJnZXQpO1xuICAgKiAgIH0pO1xuICAgKiAgIG1vdmVhYmxlLnRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICogfSk7XG4gICAqL1xuICB3YWl0VG9DaGFuZ2VUYXJnZXQoKSB7XG4gICAgbGV0IG47XG4gICAgcmV0dXJuIHRoaXMuX29uQ2hhbmdlVGFyZ2V0cyA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uQ2hhbmdlVGFyZ2V0cyA9IG51bGwsIG4oKTtcbiAgICB9LCBuZXcgUHJvbWlzZSgocikgPT4ge1xuICAgICAgbiA9IHI7XG4gICAgfSk7XG4gIH1cbiAgd2FpdFRvQ2hhbmdlVGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy53YWl0VG9DaGFuZ2VUYXJnZXQoKTtcbiAgfVxuICBnZXRNYW5hZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLm1vdmVhYmxlO1xuICB9XG4gIGdldE1vdmVhYmxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlYWJsZS5nZXRNb3ZlYWJsZXMoKTtcbiAgfVxuICBnZXREcmFnRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlYWJsZS5nZXREcmFnRWxlbWVudCgpO1xuICB9XG4gIF91cGRhdGVSZWZzKG4pIHtcbiAgICBjb25zdCByID0gdGhpcy5yZWZUYXJnZXRzLCBzID0gU3MoXG4gICAgICB0aGlzLnByb3BzLnRhcmdldCB8fCB0aGlzLnByb3BzLnRhcmdldHNcbiAgICApLCBvID0gdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCI7XG4gICAgbGV0IGkgPSBoYShyLCBzKTtcbiAgICBjb25zdCBhID0gdGhpcy5zZWxlY3Rvck1hcCwgYyA9IHt9O1xuICAgIHJldHVybiB0aGlzLnJlZlRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiBsKHUpIHtcbiAgICAgIHJlKHUpID8gYVt1XSA/IGNbdV0gPSBhW3VdIDogbyAmJiAoaSA9ICEwLCBjW3VdID0gW10uc2xpY2UuY2FsbChcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh1KVxuICAgICAgKSkgOiBSdCh1KSAmJiB1LmZvckVhY2gobCk7XG4gICAgfSksIHRoaXMuX3RtcFJlZlRhcmdldHMgPSBzLCB0aGlzLl90bXBTZWxlY3Rvck1hcCA9IGMsIFtzLCBjLCAhbiAmJiBpXTtcbiAgfVxuICBfY2hlY2tDaGFuZ2VUYXJnZXRzKCkge1xuICAgIHZhciBjLCBsLCB1O1xuICAgIHRoaXMucmVmVGFyZ2V0cyA9IHRoaXMuX3RtcFJlZlRhcmdldHMsIHRoaXMuc2VsZWN0b3JNYXAgPSB0aGlzLl90bXBTZWxlY3Rvck1hcDtcbiAgICBjb25zdCB7IGFkZGVkOiBuLCByZW1vdmVkOiByIH0gPSB0aGlzLl9kaWZmZXIudXBkYXRlKHRoaXMuX2VsZW1lbnRUYXJnZXRzKTtcbiAgICAobi5sZW5ndGggfHwgci5sZW5ndGgpICYmICgobCA9IChjID0gdGhpcy5wcm9wcykub25DaGFuZ2VUYXJnZXRzKSA9PSBudWxsIHx8IGwuY2FsbChjLCB7XG4gICAgICBtb3ZlYWJsZTogdGhpcy5tb3ZlYWJsZSxcbiAgICAgIHRhcmdldHM6IHRoaXMuX2VsZW1lbnRUYXJnZXRzXG4gICAgfSksICh1ID0gdGhpcy5fb25DaGFuZ2VUYXJnZXRzKSA9PSBudWxsIHx8IHUuY2FsbCh0aGlzKSk7XG4gICAgY29uc3QgW28sIGksIGFdID0gdGhpcy5fdXBkYXRlUmVmcygpO1xuICAgIHRoaXMucmVmVGFyZ2V0cyA9IG8sIHRoaXMuc2VsZWN0b3JNYXAgPSBpLCBhICYmIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxufVxuWChvbiwgXCJkZWZhdWx0QWJsZXNcIiwgW10pLCBYKG9uLCBcImN1c3RvbVN0eWxlZE1hcFwiLCB7fSksIFgob24sIFwiZGVmYXVsdFN0eWxlZFwiLCBudWxsKTtcbmNsYXNzIF9mIGV4dGVuZHMgb24ge1xufVxuWChfZiwgXCJkZWZhdWx0QWJsZXNcIiwgUHMpO1xuZnVuY3Rpb24gR2YodCkge1xuICB2YXIgZTtcbiAgcmV0dXJuIGUgPSBjbGFzcyBleHRlbmRzIG9uIHtcbiAgfSwgWChlLCBcImRlZmF1bHRBYmxlc1wiLCB0KSwgZTtcbn1cbmV4cG9ydCB7XG4gIHRmIGFzIENsaXBwYWJsZSxcbiAgWHIgYXMgRElSRUNUSU9OUyxcbiAgT3QgYXMgRHJhZ2dhYmxlLFxuICBSZiBhcyBFZGdlRHJhZ2dhYmxlLFxuICBvbiBhcyBJbml0aWFsTW92ZWFibGUsXG4gIFBzIGFzIE1PVkVBQkxFX0FCTEVTLFxuICBCZiBhcyBNT1ZFQUJMRV9FVkVOVFMsXG4gIHdmIGFzIE1PVkVBQkxFX01FVEhPRFMsXG4gIHpmIGFzIE1PVkVBQkxFX1BST1BTLFxuICBidSBhcyBQaW5jaGFibGUsXG4gIFRyIGFzIFJlc2l6YWJsZSxcbiAgd2wgYXMgUm90YXRhYmxlLFxuICBvZiBhcyBSb3VuZGFibGUsXG4gIHl1IGFzIFNjYWxhYmxlLFxuICBzdSBhcyBTbmFwcGFibGUsXG4gIE11IGFzIFdhcnBhYmxlLFxuICBrZSBhcyBjYWxjdWxhdGVFbGVtZW50UG9zaXRpb24sXG4gIF9mIGFzIGRlZmF1bHQsXG4gIElmIGFzIGdldEVsZW1lbnRJbmZvLFxuICBkbiBhcyBtYWtlQWJsZSxcbiAgR2YgYXMgbWFrZU1vdmVhYmxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@interactify/moveable/dist/index.es.js\n");

/***/ })

};
;
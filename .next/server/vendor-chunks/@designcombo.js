"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@designcombo";
exports.ids = ["vendor-chunks/@designcombo"];
exports.modules = {

/***/ "(ssr)/./node_modules/@designcombo/events/dist/index.es.js":
/*!***********************************************************!*\
  !*** ./node_modules/@designcombo/events/dist/index.es.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dispatch: () => (/* binding */ sr),\n/* harmony export */   filter: () => (/* binding */ or),\n/* harmony export */   subject: () => (/* binding */ ir)\n/* harmony export */ });\nvar E = function(e, t) {\n  return E = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {\n    r.__proto__ = n;\n  } || function(r, n) {\n    for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (r[o] = n[o]);\n  }, E(e, t);\n};\nfunction b(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  E(e, t);\n  function r() {\n    this.constructor = e;\n  }\n  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());\n}\nfunction g(e) {\n  var t = typeof Symbol == \"function\" && Symbol.iterator, r = t && e[t], n = 0;\n  if (r) return r.call(e);\n  if (e && typeof e.length == \"number\") return {\n    next: function() {\n      return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e };\n    }\n  };\n  throw new TypeError(t ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction O(e, t) {\n  var r = typeof Symbol == \"function\" && e[Symbol.iterator];\n  if (!r) return e;\n  var n = r.call(e), o, i = [], s;\n  try {\n    for (; (t === void 0 || t-- > 0) && !(o = n.next()).done; ) i.push(o.value);\n  } catch (u) {\n    s = { error: u };\n  } finally {\n    try {\n      o && !o.done && (r = n.return) && r.call(n);\n    } finally {\n      if (s) throw s.error;\n    }\n  }\n  return i;\n}\nfunction x(e, t, r) {\n  if (r || arguments.length === 2) for (var n = 0, o = t.length, i; n < o; n++)\n    (i || !(n in t)) && (i || (i = Array.prototype.slice.call(t, 0, n)), i[n] = t[n]);\n  return e.concat(i || Array.prototype.slice.call(t));\n}\nfunction l(e) {\n  return typeof e == \"function\";\n}\nfunction D(e) {\n  var t = function(n) {\n    Error.call(n), n.stack = new Error().stack;\n  }, r = e(t);\n  return r.prototype = Object.create(Error.prototype), r.prototype.constructor = r, r;\n}\nvar m = D(function(e) {\n  return function(r) {\n    e(this), this.message = r ? r.length + ` errors occurred during unsubscription:\n` + r.map(function(n, o) {\n      return o + 1 + \") \" + n.toString();\n    }).join(`\n  `) : \"\", this.name = \"UnsubscriptionError\", this.errors = r;\n  };\n});\nfunction P(e, t) {\n  if (e) {\n    var r = e.indexOf(t);\n    0 <= r && e.splice(r, 1);\n  }\n}\nvar S = function() {\n  function e(t) {\n    this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null;\n  }\n  return e.prototype.unsubscribe = function() {\n    var t, r, n, o, i;\n    if (!this.closed) {\n      this.closed = !0;\n      var s = this._parentage;\n      if (s)\n        if (this._parentage = null, Array.isArray(s))\n          try {\n            for (var u = g(s), c = u.next(); !c.done; c = u.next()) {\n              var f = c.value;\n              f.remove(this);\n            }\n          } catch (a) {\n            t = { error: a };\n          } finally {\n            try {\n              c && !c.done && (r = u.return) && r.call(u);\n            } finally {\n              if (t) throw t.error;\n            }\n          }\n        else\n          s.remove(this);\n      var p = this.initialTeardown;\n      if (l(p))\n        try {\n          p();\n        } catch (a) {\n          i = a instanceof m ? a.errors : [a];\n        }\n      var T = this._finalizers;\n      if (T) {\n        this._finalizers = null;\n        try {\n          for (var d = g(T), h = d.next(); !h.done; h = d.next()) {\n            var z = h.value;\n            try {\n              U(z);\n            } catch (a) {\n              i = i ?? [], a instanceof m ? i = x(x([], O(i)), O(a.errors)) : i.push(a);\n            }\n          }\n        } catch (a) {\n          n = { error: a };\n        } finally {\n          try {\n            h && !h.done && (o = d.return) && o.call(d);\n          } finally {\n            if (n) throw n.error;\n          }\n        }\n      }\n      if (i)\n        throw new m(i);\n    }\n  }, e.prototype.add = function(t) {\n    var r;\n    if (t && t !== this)\n      if (this.closed)\n        U(t);\n      else {\n        if (t instanceof e) {\n          if (t.closed || t._hasParent(this))\n            return;\n          t._addParent(this);\n        }\n        (this._finalizers = (r = this._finalizers) !== null && r !== void 0 ? r : []).push(t);\n      }\n  }, e.prototype._hasParent = function(t) {\n    var r = this._parentage;\n    return r === t || Array.isArray(r) && r.includes(t);\n  }, e.prototype._addParent = function(t) {\n    var r = this._parentage;\n    this._parentage = Array.isArray(r) ? (r.push(t), r) : r ? [r, t] : t;\n  }, e.prototype._removeParent = function(t) {\n    var r = this._parentage;\n    r === t ? this._parentage = null : Array.isArray(r) && P(r, t);\n  }, e.prototype.remove = function(t) {\n    var r = this._finalizers;\n    r && P(r, t), t instanceof e && t._removeParent(this);\n  }, e.EMPTY = function() {\n    var t = new e();\n    return t.closed = !0, t;\n  }(), e;\n}(), M = S.EMPTY;\nfunction R(e) {\n  return e instanceof S || e && \"closed\" in e && l(e.remove) && l(e.add) && l(e.unsubscribe);\n}\nfunction U(e) {\n  l(e) ? e() : e.unsubscribe();\n}\nvar Y = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: void 0,\n  useDeprecatedSynchronousErrorHandling: !1,\n  useDeprecatedNextContext: !1\n}, B = {\n  setTimeout: function(e, t) {\n    for (var r = [], n = 2; n < arguments.length; n++)\n      r[n - 2] = arguments[n];\n    return setTimeout.apply(void 0, x([e, t], O(r)));\n  },\n  clearTimeout: function(e) {\n    var t = B.delegate;\n    return ((t == null ? void 0 : t.clearTimeout) || clearTimeout)(e);\n  },\n  delegate: void 0\n};\nfunction L(e) {\n  B.setTimeout(function() {\n    throw e;\n  });\n}\nfunction I() {\n}\nfunction y(e) {\n  e();\n}\nvar A = function(e) {\n  b(t, e);\n  function t(r) {\n    var n = e.call(this) || this;\n    return n.isStopped = !1, r ? (n.destination = r, R(r) && r.add(n)) : n.destination = J, n;\n  }\n  return t.create = function(r, n, o) {\n    return new j(r, n, o);\n  }, t.prototype.next = function(r) {\n    this.isStopped || this._next(r);\n  }, t.prototype.error = function(r) {\n    this.isStopped || (this.isStopped = !0, this._error(r));\n  }, t.prototype.complete = function() {\n    this.isStopped || (this.isStopped = !0, this._complete());\n  }, t.prototype.unsubscribe = function() {\n    this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null);\n  }, t.prototype._next = function(r) {\n    this.destination.next(r);\n  }, t.prototype._error = function(r) {\n    try {\n      this.destination.error(r);\n    } finally {\n      this.unsubscribe();\n    }\n  }, t.prototype._complete = function() {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }, t;\n}(S), V = Function.prototype.bind;\nfunction _(e, t) {\n  return V.call(e, t);\n}\nvar q = function() {\n  function e(t) {\n    this.partialObserver = t;\n  }\n  return e.prototype.next = function(t) {\n    var r = this.partialObserver;\n    if (r.next)\n      try {\n        r.next(t);\n      } catch (n) {\n        v(n);\n      }\n  }, e.prototype.error = function(t) {\n    var r = this.partialObserver;\n    if (r.error)\n      try {\n        r.error(t);\n      } catch (n) {\n        v(n);\n      }\n    else\n      v(t);\n  }, e.prototype.complete = function() {\n    var t = this.partialObserver;\n    if (t.complete)\n      try {\n        t.complete();\n      } catch (r) {\n        v(r);\n      }\n  }, e;\n}(), j = function(e) {\n  b(t, e);\n  function t(r, n, o) {\n    var i = e.call(this) || this, s;\n    if (l(r) || !r)\n      s = {\n        next: r ?? void 0,\n        error: n ?? void 0,\n        complete: o ?? void 0\n      };\n    else {\n      var u;\n      i && Y.useDeprecatedNextContext ? (u = Object.create(r), u.unsubscribe = function() {\n        return i.unsubscribe();\n      }, s = {\n        next: r.next && _(r.next, u),\n        error: r.error && _(r.error, u),\n        complete: r.complete && _(r.complete, u)\n      }) : s = r;\n    }\n    return i.destination = new q(s), i;\n  }\n  return t;\n}(A);\nfunction v(e) {\n  L(e);\n}\nfunction G(e) {\n  throw e;\n}\nvar J = {\n  closed: !0,\n  next: I,\n  error: G,\n  complete: I\n}, K = function() {\n  return typeof Symbol == \"function\" && Symbol.observable || \"@@observable\";\n}();\nfunction Q(e) {\n  return e;\n}\nfunction W(e) {\n  return e.length === 0 ? Q : e.length === 1 ? e[0] : function(r) {\n    return e.reduce(function(n, o) {\n      return o(n);\n    }, r);\n  };\n}\nvar C = function() {\n  function e(t) {\n    t && (this._subscribe = t);\n  }\n  return e.prototype.lift = function(t) {\n    var r = new e();\n    return r.source = this, r.operator = t, r;\n  }, e.prototype.subscribe = function(t, r, n) {\n    var o = this, i = Z(t) ? t : new j(t, r, n);\n    return y(function() {\n      var s = o, u = s.operator, c = s.source;\n      i.add(u ? u.call(i, c) : c ? o._subscribe(i) : o._trySubscribe(i));\n    }), i;\n  }, e.prototype._trySubscribe = function(t) {\n    try {\n      return this._subscribe(t);\n    } catch (r) {\n      t.error(r);\n    }\n  }, e.prototype.forEach = function(t, r) {\n    var n = this;\n    return r = F(r), new r(function(o, i) {\n      var s = new j({\n        next: function(u) {\n          try {\n            t(u);\n          } catch (c) {\n            i(c), s.unsubscribe();\n          }\n        },\n        error: i,\n        complete: o\n      });\n      n.subscribe(s);\n    });\n  }, e.prototype._subscribe = function(t) {\n    var r;\n    return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(t);\n  }, e.prototype[K] = function() {\n    return this;\n  }, e.prototype.pipe = function() {\n    for (var t = [], r = 0; r < arguments.length; r++)\n      t[r] = arguments[r];\n    return W(t)(this);\n  }, e.prototype.toPromise = function(t) {\n    var r = this;\n    return t = F(t), new t(function(n, o) {\n      var i;\n      r.subscribe(function(s) {\n        return i = s;\n      }, function(s) {\n        return o(s);\n      }, function() {\n        return n(i);\n      });\n    });\n  }, e.create = function(t) {\n    return new e(t);\n  }, e;\n}();\nfunction F(e) {\n  var t;\n  return (t = e ?? Y.Promise) !== null && t !== void 0 ? t : Promise;\n}\nfunction X(e) {\n  return e && l(e.next) && l(e.error) && l(e.complete);\n}\nfunction Z(e) {\n  return e && e instanceof A || X(e) && R(e);\n}\nfunction $(e) {\n  return l(e == null ? void 0 : e.lift);\n}\nfunction N(e) {\n  return function(t) {\n    if ($(t))\n      return t.lift(function(r) {\n        try {\n          return e(r, this);\n        } catch (n) {\n          this.error(n);\n        }\n      });\n    throw new TypeError(\"Unable to lift unknown Observable type\");\n  };\n}\nfunction rr(e, t, r, n, o) {\n  return new tr(e, t, r, n, o);\n}\nvar tr = function(e) {\n  b(t, e);\n  function t(r, n, o, i, s, u) {\n    var c = e.call(this, r) || this;\n    return c.onFinalize = s, c.shouldUnsubscribe = u, c._next = n ? function(f) {\n      try {\n        n(f);\n      } catch (p) {\n        r.error(p);\n      }\n    } : e.prototype._next, c._error = i ? function(f) {\n      try {\n        i(f);\n      } catch (p) {\n        r.error(p);\n      } finally {\n        this.unsubscribe();\n      }\n    } : e.prototype._error, c._complete = o ? function() {\n      try {\n        o();\n      } catch (f) {\n        r.error(f);\n      } finally {\n        this.unsubscribe();\n      }\n    } : e.prototype._complete, c;\n  }\n  return t.prototype.unsubscribe = function() {\n    var r;\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      var n = this.closed;\n      e.prototype.unsubscribe.call(this), !n && ((r = this.onFinalize) === null || r === void 0 || r.call(this));\n    }\n  }, t;\n}(A), er = D(function(e) {\n  return function() {\n    e(this), this.name = \"ObjectUnsubscribedError\", this.message = \"object unsubscribed\";\n  };\n}), H = function(e) {\n  b(t, e);\n  function t() {\n    var r = e.call(this) || this;\n    return r.closed = !1, r.currentObservers = null, r.observers = [], r.isStopped = !1, r.hasError = !1, r.thrownError = null, r;\n  }\n  return t.prototype.lift = function(r) {\n    var n = new k(this, this);\n    return n.operator = r, n;\n  }, t.prototype._throwIfClosed = function() {\n    if (this.closed)\n      throw new er();\n  }, t.prototype.next = function(r) {\n    var n = this;\n    y(function() {\n      var o, i;\n      if (n._throwIfClosed(), !n.isStopped) {\n        n.currentObservers || (n.currentObservers = Array.from(n.observers));\n        try {\n          for (var s = g(n.currentObservers), u = s.next(); !u.done; u = s.next()) {\n            var c = u.value;\n            c.next(r);\n          }\n        } catch (f) {\n          o = { error: f };\n        } finally {\n          try {\n            u && !u.done && (i = s.return) && i.call(s);\n          } finally {\n            if (o) throw o.error;\n          }\n        }\n      }\n    });\n  }, t.prototype.error = function(r) {\n    var n = this;\n    y(function() {\n      if (n._throwIfClosed(), !n.isStopped) {\n        n.hasError = n.isStopped = !0, n.thrownError = r;\n        for (var o = n.observers; o.length; )\n          o.shift().error(r);\n      }\n    });\n  }, t.prototype.complete = function() {\n    var r = this;\n    y(function() {\n      if (r._throwIfClosed(), !r.isStopped) {\n        r.isStopped = !0;\n        for (var n = r.observers; n.length; )\n          n.shift().complete();\n      }\n    });\n  }, t.prototype.unsubscribe = function() {\n    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;\n  }, Object.defineProperty(t.prototype, \"observed\", {\n    get: function() {\n      var r;\n      return ((r = this.observers) === null || r === void 0 ? void 0 : r.length) > 0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._trySubscribe = function(r) {\n    return this._throwIfClosed(), e.prototype._trySubscribe.call(this, r);\n  }, t.prototype._subscribe = function(r) {\n    return this._throwIfClosed(), this._checkFinalizedStatuses(r), this._innerSubscribe(r);\n  }, t.prototype._innerSubscribe = function(r) {\n    var n = this, o = this, i = o.hasError, s = o.isStopped, u = o.observers;\n    return i || s ? M : (this.currentObservers = null, u.push(r), new S(function() {\n      n.currentObservers = null, P(u, r);\n    }));\n  }, t.prototype._checkFinalizedStatuses = function(r) {\n    var n = this, o = n.hasError, i = n.thrownError, s = n.isStopped;\n    o ? r.error(i) : s && r.complete();\n  }, t.prototype.asObservable = function() {\n    var r = new C();\n    return r.source = this, r;\n  }, t.create = function(r, n) {\n    return new k(r, n);\n  }, t;\n}(C), k = function(e) {\n  b(t, e);\n  function t(r, n) {\n    var o = e.call(this) || this;\n    return o.destination = r, o.source = n, o;\n  }\n  return t.prototype.next = function(r) {\n    var n, o;\n    (o = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || o === void 0 || o.call(n, r);\n  }, t.prototype.error = function(r) {\n    var n, o;\n    (o = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || o === void 0 || o.call(n, r);\n  }, t.prototype.complete = function() {\n    var r, n;\n    (n = (r = this.destination) === null || r === void 0 ? void 0 : r.complete) === null || n === void 0 || n.call(r);\n  }, t.prototype._subscribe = function(r) {\n    var n, o;\n    return (o = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(r)) !== null && o !== void 0 ? o : M;\n  }, t;\n}(H);\nfunction or(e, t) {\n  return N(function(r, n) {\n    var o = 0;\n    r.subscribe(rr(n, function(i) {\n      return e.call(t, i, o++) && n.next(i);\n    }));\n  });\n}\nlet w = null;\nfunction nr() {\n  if (!w) {\n    const e = new H();\n    w = { subject: e, dispatch: (r, n) => e.next({ key: r, value: n }) };\n  }\n  return w;\n}\nconst { subject: ir, dispatch: sr } = nr();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRlc2lnbmNvbWJvL2V2ZW50cy9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBbUQ7QUFDOUQsSUFBSTtBQUNKLFVBQVU7QUFDVixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGdCQUFnQjtBQUNoQixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRCQUE0QjtBQUtsQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlbW90aW9uLWNhcHRpb25zLy4vbm9kZV9tb2R1bGVzL0BkZXNpZ25jb21iby9ldmVudHMvZGlzdC9pbmRleC5lcy5qcz9mZDZhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBFID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gRSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKHIsIG4pIHtcbiAgICByLl9fcHJvdG9fXyA9IG47XG4gIH0gfHwgZnVuY3Rpb24ociwgbikge1xuICAgIGZvciAodmFyIG8gaW4gbikgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIG8pICYmIChyW29dID0gbltvXSk7XG4gIH0sIEUoZSwgdCk7XG59O1xuZnVuY3Rpb24gYihlLCB0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgJiYgdCAhPT0gbnVsbClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyh0KSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIEUoZSwgdCk7XG4gIGZ1bmN0aW9uIHIoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGU7XG4gIH1cbiAgZS5wcm90b3R5cGUgPSB0ID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZSh0KSA6IChyLnByb3RvdHlwZSA9IHQucHJvdG90eXBlLCBuZXcgcigpKTtcbn1cbmZ1bmN0aW9uIGcoZSkge1xuICB2YXIgdCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgciA9IHQgJiYgZVt0XSwgbiA9IDA7XG4gIGlmIChyKSByZXR1cm4gci5jYWxsKGUpO1xuICBpZiAoZSAmJiB0eXBlb2YgZS5sZW5ndGggPT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlICYmIG4gPj0gZS5sZW5ndGggJiYgKGUgPSB2b2lkIDApLCB7IHZhbHVlOiBlICYmIGVbbisrXSwgZG9uZTogIWUgfTtcbiAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IodCA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cbmZ1bmN0aW9uIE8oZSwgdCkge1xuICB2YXIgciA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFyKSByZXR1cm4gZTtcbiAgdmFyIG4gPSByLmNhbGwoZSksIG8sIGkgPSBbXSwgcztcbiAgdHJ5IHtcbiAgICBmb3IgKDsgKHQgPT09IHZvaWQgMCB8fCB0LS0gPiAwKSAmJiAhKG8gPSBuLm5leHQoKSkuZG9uZTsgKSBpLnB1c2goby52YWx1ZSk7XG4gIH0gY2F0Y2ggKHUpIHtcbiAgICBzID0geyBlcnJvcjogdSB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBvICYmICFvLmRvbmUgJiYgKHIgPSBuLnJldHVybikgJiYgci5jYWxsKG4pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAocykgdGhyb3cgcy5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB4KGUsIHQsIHIpIHtcbiAgaWYgKHIgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgbiA9IDAsIG8gPSB0Lmxlbmd0aCwgaTsgbiA8IG87IG4rKylcbiAgICAoaSB8fCAhKG4gaW4gdCkpICYmIChpIHx8IChpID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCwgMCwgbikpLCBpW25dID0gdFtuXSk7XG4gIHJldHVybiBlLmNvbmNhdChpIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQpKTtcbn1cbmZ1bmN0aW9uIGwoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gRChlKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24obikge1xuICAgIEVycm9yLmNhbGwobiksIG4uc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgfSwgciA9IGUodCk7XG4gIHJldHVybiByLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSwgci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSByLCByO1xufVxudmFyIG0gPSBEKGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICBlKHRoaXMpLCB0aGlzLm1lc3NhZ2UgPSByID8gci5sZW5ndGggKyBgIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XG5gICsgci5tYXAoZnVuY3Rpb24obiwgbykge1xuICAgICAgcmV0dXJuIG8gKyAxICsgXCIpIFwiICsgbi50b1N0cmluZygpO1xuICAgIH0pLmpvaW4oYFxuICBgKSA6IFwiXCIsIHRoaXMubmFtZSA9IFwiVW5zdWJzY3JpcHRpb25FcnJvclwiLCB0aGlzLmVycm9ycyA9IHI7XG4gIH07XG59KTtcbmZ1bmN0aW9uIFAoZSwgdCkge1xuICBpZiAoZSkge1xuICAgIHZhciByID0gZS5pbmRleE9mKHQpO1xuICAgIDAgPD0gciAmJiBlLnNwbGljZShyLCAxKTtcbiAgfVxufVxudmFyIFMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgdGhpcy5pbml0aWFsVGVhcmRvd24gPSB0LCB0aGlzLmNsb3NlZCA9ICExLCB0aGlzLl9wYXJlbnRhZ2UgPSBudWxsLCB0aGlzLl9maW5hbGl6ZXJzID0gbnVsbDtcbiAgfVxuICByZXR1cm4gZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCwgciwgbiwgbywgaTtcbiAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICB0aGlzLmNsb3NlZCA9ICEwO1xuICAgICAgdmFyIHMgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgICBpZiAocylcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudGFnZSA9IG51bGwsIEFycmF5LmlzQXJyYXkocykpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHUgPSBnKHMpLCBjID0gdS5uZXh0KCk7ICFjLmRvbmU7IGMgPSB1Lm5leHQoKSkge1xuICAgICAgICAgICAgICB2YXIgZiA9IGMudmFsdWU7XG4gICAgICAgICAgICAgIGYucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgICAgICAgIHQgPSB7IGVycm9yOiBhIH07XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGMgJiYgIWMuZG9uZSAmJiAociA9IHUucmV0dXJuKSAmJiByLmNhbGwodSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAodCkgdGhyb3cgdC5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzLnJlbW92ZSh0aGlzKTtcbiAgICAgIHZhciBwID0gdGhpcy5pbml0aWFsVGVhcmRvd247XG4gICAgICBpZiAobChwKSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwKCk7XG4gICAgICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgICAgICBpID0gYSBpbnN0YW5jZW9mIG0gPyBhLmVycm9ycyA6IFthXTtcbiAgICAgICAgfVxuICAgICAgdmFyIFQgPSB0aGlzLl9maW5hbGl6ZXJzO1xuICAgICAgaWYgKFQpIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVycyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgZCA9IGcoVCksIGggPSBkLm5leHQoKTsgIWguZG9uZTsgaCA9IGQubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgeiA9IGgudmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBVKHopO1xuICAgICAgICAgICAgfSBjYXRjaCAoYSkge1xuICAgICAgICAgICAgICBpID0gaSA/PyBbXSwgYSBpbnN0YW5jZW9mIG0gPyBpID0geCh4KFtdLCBPKGkpKSwgTyhhLmVycm9ycykpIDogaS5wdXNoKGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoYSkge1xuICAgICAgICAgIG4gPSB7IGVycm9yOiBhIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGggJiYgIWguZG9uZSAmJiAobyA9IGQucmV0dXJuKSAmJiBvLmNhbGwoZCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChuKSB0aHJvdyBuLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkpXG4gICAgICAgIHRocm93IG5ldyBtKGkpO1xuICAgIH1cbiAgfSwgZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24odCkge1xuICAgIHZhciByO1xuICAgIGlmICh0ICYmIHQgIT09IHRoaXMpXG4gICAgICBpZiAodGhpcy5jbG9zZWQpXG4gICAgICAgIFUodCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBlKSB7XG4gICAgICAgICAgaWYgKHQuY2xvc2VkIHx8IHQuX2hhc1BhcmVudCh0aGlzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB0Ll9hZGRQYXJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgKHRoaXMuX2ZpbmFsaXplcnMgPSAociA9IHRoaXMuX2ZpbmFsaXplcnMpICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiBbXSkucHVzaCh0KTtcbiAgICAgIH1cbiAgfSwgZS5wcm90b3R5cGUuX2hhc1BhcmVudCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgciA9IHRoaXMuX3BhcmVudGFnZTtcbiAgICByZXR1cm4gciA9PT0gdCB8fCBBcnJheS5pc0FycmF5KHIpICYmIHIuaW5jbHVkZXModCk7XG4gIH0sIGUucHJvdG90eXBlLl9hZGRQYXJlbnQgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHIgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgdGhpcy5fcGFyZW50YWdlID0gQXJyYXkuaXNBcnJheShyKSA/IChyLnB1c2godCksIHIpIDogciA/IFtyLCB0XSA6IHQ7XG4gIH0sIGUucHJvdG90eXBlLl9yZW1vdmVQYXJlbnQgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHIgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgciA9PT0gdCA/IHRoaXMuX3BhcmVudGFnZSA9IG51bGwgOiBBcnJheS5pc0FycmF5KHIpICYmIFAociwgdCk7XG4gIH0sIGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgciA9IHRoaXMuX2ZpbmFsaXplcnM7XG4gICAgciAmJiBQKHIsIHQpLCB0IGluc3RhbmNlb2YgZSAmJiB0Ll9yZW1vdmVQYXJlbnQodGhpcyk7XG4gIH0sIGUuRU1QVFkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG5ldyBlKCk7XG4gICAgcmV0dXJuIHQuY2xvc2VkID0gITAsIHQ7XG4gIH0oKSwgZTtcbn0oKSwgTSA9IFMuRU1QVFk7XG5mdW5jdGlvbiBSKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBTIHx8IGUgJiYgXCJjbG9zZWRcIiBpbiBlICYmIGwoZS5yZW1vdmUpICYmIGwoZS5hZGQpICYmIGwoZS51bnN1YnNjcmliZSk7XG59XG5mdW5jdGlvbiBVKGUpIHtcbiAgbChlKSA/IGUoKSA6IGUudW5zdWJzY3JpYmUoKTtcbn1cbnZhciBZID0ge1xuICBvblVuaGFuZGxlZEVycm9yOiBudWxsLFxuICBvblN0b3BwZWROb3RpZmljYXRpb246IG51bGwsXG4gIFByb21pc2U6IHZvaWQgMCxcbiAgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZzogITEsXG4gIHVzZURlcHJlY2F0ZWROZXh0Q29udGV4dDogITFcbn0sIEIgPSB7XG4gIHNldFRpbWVvdXQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBmb3IgKHZhciByID0gW10sIG4gPSAyOyBuIDwgYXJndW1lbnRzLmxlbmd0aDsgbisrKVxuICAgICAgcltuIC0gMl0gPSBhcmd1bWVudHNbbl07XG4gICAgcmV0dXJuIHNldFRpbWVvdXQuYXBwbHkodm9pZCAwLCB4KFtlLCB0XSwgTyhyKSkpO1xuICB9LFxuICBjbGVhclRpbWVvdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IEIuZGVsZWdhdGU7XG4gICAgcmV0dXJuICgodCA9PSBudWxsID8gdm9pZCAwIDogdC5jbGVhclRpbWVvdXQpIHx8IGNsZWFyVGltZW91dCkoZSk7XG4gIH0sXG4gIGRlbGVnYXRlOiB2b2lkIDBcbn07XG5mdW5jdGlvbiBMKGUpIHtcbiAgQi5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRocm93IGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gSSgpIHtcbn1cbmZ1bmN0aW9uIHkoZSkge1xuICBlKCk7XG59XG52YXIgQSA9IGZ1bmN0aW9uKGUpIHtcbiAgYih0LCBlKTtcbiAgZnVuY3Rpb24gdChyKSB7XG4gICAgdmFyIG4gPSBlLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICByZXR1cm4gbi5pc1N0b3BwZWQgPSAhMSwgciA/IChuLmRlc3RpbmF0aW9uID0gciwgUihyKSAmJiByLmFkZChuKSkgOiBuLmRlc3RpbmF0aW9uID0gSiwgbjtcbiAgfVxuICByZXR1cm4gdC5jcmVhdGUgPSBmdW5jdGlvbihyLCBuLCBvKSB7XG4gICAgcmV0dXJuIG5ldyBqKHIsIG4sIG8pO1xuICB9LCB0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24ocikge1xuICAgIHRoaXMuaXNTdG9wcGVkIHx8IHRoaXMuX25leHQocik7XG4gIH0sIHQucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24ocikge1xuICAgIHRoaXMuaXNTdG9wcGVkIHx8ICh0aGlzLmlzU3RvcHBlZCA9ICEwLCB0aGlzLl9lcnJvcihyKSk7XG4gIH0sIHQucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc1N0b3BwZWQgfHwgKHRoaXMuaXNTdG9wcGVkID0gITAsIHRoaXMuX2NvbXBsZXRlKCkpO1xuICB9LCB0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xvc2VkIHx8ICh0aGlzLmlzU3RvcHBlZCA9ICEwLCBlLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpLCB0aGlzLmRlc3RpbmF0aW9uID0gbnVsbCk7XG4gIH0sIHQucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24ocikge1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyKTtcbiAgfSwgdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24ocikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9LCB0LnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9LCB0O1xufShTKSwgViA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuZnVuY3Rpb24gXyhlLCB0KSB7XG4gIHJldHVybiBWLmNhbGwoZSwgdCk7XG59XG52YXIgcSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBlKHQpIHtcbiAgICB0aGlzLnBhcnRpYWxPYnNlcnZlciA9IHQ7XG4gIH1cbiAgcmV0dXJuIGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHIgPSB0aGlzLnBhcnRpYWxPYnNlcnZlcjtcbiAgICBpZiAoci5uZXh0KVxuICAgICAgdHJ5IHtcbiAgICAgICAgci5uZXh0KHQpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB2KG4pO1xuICAgICAgfVxuICB9LCBlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgciA9IHRoaXMucGFydGlhbE9ic2VydmVyO1xuICAgIGlmIChyLmVycm9yKVxuICAgICAgdHJ5IHtcbiAgICAgICAgci5lcnJvcih0KTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdihuKTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICB2KHQpO1xuICB9LCBlLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gdGhpcy5wYXJ0aWFsT2JzZXJ2ZXI7XG4gICAgaWYgKHQuY29tcGxldGUpXG4gICAgICB0cnkge1xuICAgICAgICB0LmNvbXBsZXRlKCk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHYocik7XG4gICAgICB9XG4gIH0sIGU7XG59KCksIGogPSBmdW5jdGlvbihlKSB7XG4gIGIodCwgZSk7XG4gIGZ1bmN0aW9uIHQociwgbiwgbykge1xuICAgIHZhciBpID0gZS5jYWxsKHRoaXMpIHx8IHRoaXMsIHM7XG4gICAgaWYgKGwocikgfHwgIXIpXG4gICAgICBzID0ge1xuICAgICAgICBuZXh0OiByID8/IHZvaWQgMCxcbiAgICAgICAgZXJyb3I6IG4gPz8gdm9pZCAwLFxuICAgICAgICBjb21wbGV0ZTogbyA/PyB2b2lkIDBcbiAgICAgIH07XG4gICAgZWxzZSB7XG4gICAgICB2YXIgdTtcbiAgICAgIGkgJiYgWS51c2VEZXByZWNhdGVkTmV4dENvbnRleHQgPyAodSA9IE9iamVjdC5jcmVhdGUociksIHUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGkudW5zdWJzY3JpYmUoKTtcbiAgICAgIH0sIHMgPSB7XG4gICAgICAgIG5leHQ6IHIubmV4dCAmJiBfKHIubmV4dCwgdSksXG4gICAgICAgIGVycm9yOiByLmVycm9yICYmIF8oci5lcnJvciwgdSksXG4gICAgICAgIGNvbXBsZXRlOiByLmNvbXBsZXRlICYmIF8oci5jb21wbGV0ZSwgdSlcbiAgICAgIH0pIDogcyA9IHI7XG4gICAgfVxuICAgIHJldHVybiBpLmRlc3RpbmF0aW9uID0gbmV3IHEocyksIGk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59KEEpO1xuZnVuY3Rpb24gdihlKSB7XG4gIEwoZSk7XG59XG5mdW5jdGlvbiBHKGUpIHtcbiAgdGhyb3cgZTtcbn1cbnZhciBKID0ge1xuICBjbG9zZWQ6ICEwLFxuICBuZXh0OiBJLFxuICBlcnJvcjogRyxcbiAgY29tcGxldGU6IElcbn0sIEsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8IFwiQEBvYnNlcnZhYmxlXCI7XG59KCk7XG5mdW5jdGlvbiBRKGUpIHtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBXKGUpIHtcbiAgcmV0dXJuIGUubGVuZ3RoID09PSAwID8gUSA6IGUubGVuZ3RoID09PSAxID8gZVswXSA6IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gZS5yZWR1Y2UoZnVuY3Rpb24obiwgbykge1xuICAgICAgcmV0dXJuIG8obik7XG4gICAgfSwgcik7XG4gIH07XG59XG52YXIgQyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBlKHQpIHtcbiAgICB0ICYmICh0aGlzLl9zdWJzY3JpYmUgPSB0KTtcbiAgfVxuICByZXR1cm4gZS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgciA9IG5ldyBlKCk7XG4gICAgcmV0dXJuIHIuc291cmNlID0gdGhpcywgci5vcGVyYXRvciA9IHQsIHI7XG4gIH0sIGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKHQsIHIsIG4pIHtcbiAgICB2YXIgbyA9IHRoaXMsIGkgPSBaKHQpID8gdCA6IG5ldyBqKHQsIHIsIG4pO1xuICAgIHJldHVybiB5KGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHMgPSBvLCB1ID0gcy5vcGVyYXRvciwgYyA9IHMuc291cmNlO1xuICAgICAgaS5hZGQodSA/IHUuY2FsbChpLCBjKSA6IGMgPyBvLl9zdWJzY3JpYmUoaSkgOiBvLl90cnlTdWJzY3JpYmUoaSkpO1xuICAgIH0pLCBpO1xuICB9LCBlLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24odCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHQpO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIHQuZXJyb3Iocik7XG4gICAgfVxuICB9LCBlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24odCwgcikge1xuICAgIHZhciBuID0gdGhpcztcbiAgICByZXR1cm4gciA9IEYociksIG5ldyByKGZ1bmN0aW9uKG8sIGkpIHtcbiAgICAgIHZhciBzID0gbmV3IGooe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbih1KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHQodSk7XG4gICAgICAgICAgfSBjYXRjaCAoYykge1xuICAgICAgICAgICAgaShjKSwgcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGksXG4gICAgICAgIGNvbXBsZXRlOiBvXG4gICAgICB9KTtcbiAgICAgIG4uc3Vic2NyaWJlKHMpO1xuICAgIH0pO1xuICB9LCBlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciByO1xuICAgIHJldHVybiAociA9IHRoaXMuc291cmNlKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgPyB2b2lkIDAgOiByLnN1YnNjcmliZSh0KTtcbiAgfSwgZS5wcm90b3R5cGVbS10gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSwgZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHQgPSBbXSwgciA9IDA7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspXG4gICAgICB0W3JdID0gYXJndW1lbnRzW3JdO1xuICAgIHJldHVybiBXKHQpKHRoaXMpO1xuICB9LCBlLnByb3RvdHlwZS50b1Byb21pc2UgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHJldHVybiB0ID0gRih0KSwgbmV3IHQoZnVuY3Rpb24obiwgbykge1xuICAgICAgdmFyIGk7XG4gICAgICByLnN1YnNjcmliZShmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBpID0gcztcbiAgICAgIH0sIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG8ocyk7XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG4oaSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgZS5jcmVhdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIG5ldyBlKHQpO1xuICB9LCBlO1xufSgpO1xuZnVuY3Rpb24gRihlKSB7XG4gIHZhciB0O1xuICByZXR1cm4gKHQgPSBlID8/IFkuUHJvbWlzZSkgIT09IG51bGwgJiYgdCAhPT0gdm9pZCAwID8gdCA6IFByb21pc2U7XG59XG5mdW5jdGlvbiBYKGUpIHtcbiAgcmV0dXJuIGUgJiYgbChlLm5leHQpICYmIGwoZS5lcnJvcikgJiYgbChlLmNvbXBsZXRlKTtcbn1cbmZ1bmN0aW9uIFooZSkge1xuICByZXR1cm4gZSAmJiBlIGluc3RhbmNlb2YgQSB8fCBYKGUpICYmIFIoZSk7XG59XG5mdW5jdGlvbiAkKGUpIHtcbiAgcmV0dXJuIGwoZSA9PSBudWxsID8gdm9pZCAwIDogZS5saWZ0KTtcbn1cbmZ1bmN0aW9uIE4oZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGlmICgkKHQpKVxuICAgICAgcmV0dXJuIHQubGlmdChmdW5jdGlvbihyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGUociwgdGhpcyk7XG4gICAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgICB0aGlzLmVycm9yKG4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5hYmxlIHRvIGxpZnQgdW5rbm93biBPYnNlcnZhYmxlIHR5cGVcIik7XG4gIH07XG59XG5mdW5jdGlvbiBycihlLCB0LCByLCBuLCBvKSB7XG4gIHJldHVybiBuZXcgdHIoZSwgdCwgciwgbiwgbyk7XG59XG52YXIgdHIgPSBmdW5jdGlvbihlKSB7XG4gIGIodCwgZSk7XG4gIGZ1bmN0aW9uIHQociwgbiwgbywgaSwgcywgdSkge1xuICAgIHZhciBjID0gZS5jYWxsKHRoaXMsIHIpIHx8IHRoaXM7XG4gICAgcmV0dXJuIGMub25GaW5hbGl6ZSA9IHMsIGMuc2hvdWxkVW5zdWJzY3JpYmUgPSB1LCBjLl9uZXh0ID0gbiA/IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG4oZik7XG4gICAgICB9IGNhdGNoIChwKSB7XG4gICAgICAgIHIuZXJyb3IocCk7XG4gICAgICB9XG4gICAgfSA6IGUucHJvdG90eXBlLl9uZXh0LCBjLl9lcnJvciA9IGkgPyBmdW5jdGlvbihmKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpKGYpO1xuICAgICAgfSBjYXRjaCAocCkge1xuICAgICAgICByLmVycm9yKHApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH0gOiBlLnByb3RvdHlwZS5fZXJyb3IsIGMuX2NvbXBsZXRlID0gbyA/IGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbygpO1xuICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICByLmVycm9yKGYpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH0gOiBlLnByb3RvdHlwZS5fY29tcGxldGUsIGM7XG4gIH1cbiAgcmV0dXJuIHQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHI7XG4gICAgaWYgKCF0aGlzLnNob3VsZFVuc3Vic2NyaWJlIHx8IHRoaXMuc2hvdWxkVW5zdWJzY3JpYmUoKSkge1xuICAgICAgdmFyIG4gPSB0aGlzLmNsb3NlZDtcbiAgICAgIGUucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyksICFuICYmICgociA9IHRoaXMub25GaW5hbGl6ZSkgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwIHx8IHIuY2FsbCh0aGlzKSk7XG4gICAgfVxuICB9LCB0O1xufShBKSwgZXIgPSBEKGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGUodGhpcyksIHRoaXMubmFtZSA9IFwiT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JcIiwgdGhpcy5tZXNzYWdlID0gXCJvYmplY3QgdW5zdWJzY3JpYmVkXCI7XG4gIH07XG59KSwgSCA9IGZ1bmN0aW9uKGUpIHtcbiAgYih0LCBlKTtcbiAgZnVuY3Rpb24gdCgpIHtcbiAgICB2YXIgciA9IGUuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIHJldHVybiByLmNsb3NlZCA9ICExLCByLmN1cnJlbnRPYnNlcnZlcnMgPSBudWxsLCByLm9ic2VydmVycyA9IFtdLCByLmlzU3RvcHBlZCA9ICExLCByLmhhc0Vycm9yID0gITEsIHIudGhyb3duRXJyb3IgPSBudWxsLCByO1xuICB9XG4gIHJldHVybiB0LnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24ocikge1xuICAgIHZhciBuID0gbmV3IGsodGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIG4ub3BlcmF0b3IgPSByLCBuO1xuICB9LCB0LnByb3RvdHlwZS5fdGhyb3dJZkNsb3NlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNsb3NlZClcbiAgICAgIHRocm93IG5ldyBlcigpO1xuICB9LCB0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24ocikge1xuICAgIHZhciBuID0gdGhpcztcbiAgICB5KGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG8sIGk7XG4gICAgICBpZiAobi5fdGhyb3dJZkNsb3NlZCgpLCAhbi5pc1N0b3BwZWQpIHtcbiAgICAgICAgbi5jdXJyZW50T2JzZXJ2ZXJzIHx8IChuLmN1cnJlbnRPYnNlcnZlcnMgPSBBcnJheS5mcm9tKG4ub2JzZXJ2ZXJzKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgcyA9IGcobi5jdXJyZW50T2JzZXJ2ZXJzKSwgdSA9IHMubmV4dCgpOyAhdS5kb25lOyB1ID0gcy5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBjID0gdS52YWx1ZTtcbiAgICAgICAgICAgIGMubmV4dChyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgICBvID0geyBlcnJvcjogZiB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1ICYmICF1LmRvbmUgJiYgKGkgPSBzLnJldHVybikgJiYgaS5jYWxsKHMpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAobykgdGhyb3cgby5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIG4gPSB0aGlzO1xuICAgIHkoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobi5fdGhyb3dJZkNsb3NlZCgpLCAhbi5pc1N0b3BwZWQpIHtcbiAgICAgICAgbi5oYXNFcnJvciA9IG4uaXNTdG9wcGVkID0gITAsIG4udGhyb3duRXJyb3IgPSByO1xuICAgICAgICBmb3IgKHZhciBvID0gbi5vYnNlcnZlcnM7IG8ubGVuZ3RoOyApXG4gICAgICAgICAgby5zaGlmdCgpLmVycm9yKHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCB0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB5KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHIuX3Rocm93SWZDbG9zZWQoKSwgIXIuaXNTdG9wcGVkKSB7XG4gICAgICAgIHIuaXNTdG9wcGVkID0gITA7XG4gICAgICAgIGZvciAodmFyIG4gPSByLm9ic2VydmVyczsgbi5sZW5ndGg7IClcbiAgICAgICAgICBuLnNoaWZ0KCkuY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzU3RvcHBlZCA9IHRoaXMuY2xvc2VkID0gITAsIHRoaXMub2JzZXJ2ZXJzID0gdGhpcy5jdXJyZW50T2JzZXJ2ZXJzID0gbnVsbDtcbiAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLCBcIm9ic2VydmVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHI7XG4gICAgICByZXR1cm4gKChyID0gdGhpcy5vYnNlcnZlcnMpID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIubGVuZ3RoKSA+IDA7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICBjb25maWd1cmFibGU6ICEwXG4gIH0pLCB0LnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiB0aGlzLl90aHJvd0lmQ2xvc2VkKCksIGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUuY2FsbCh0aGlzLCByKTtcbiAgfSwgdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhyb3dJZkNsb3NlZCgpLCB0aGlzLl9jaGVja0ZpbmFsaXplZFN0YXR1c2VzKHIpLCB0aGlzLl9pbm5lclN1YnNjcmliZShyKTtcbiAgfSwgdC5wcm90b3R5cGUuX2lubmVyU3Vic2NyaWJlID0gZnVuY3Rpb24ocikge1xuICAgIHZhciBuID0gdGhpcywgbyA9IHRoaXMsIGkgPSBvLmhhc0Vycm9yLCBzID0gby5pc1N0b3BwZWQsIHUgPSBvLm9ic2VydmVycztcbiAgICByZXR1cm4gaSB8fCBzID8gTSA6ICh0aGlzLmN1cnJlbnRPYnNlcnZlcnMgPSBudWxsLCB1LnB1c2gociksIG5ldyBTKGZ1bmN0aW9uKCkge1xuICAgICAgbi5jdXJyZW50T2JzZXJ2ZXJzID0gbnVsbCwgUCh1LCByKTtcbiAgICB9KSk7XG4gIH0sIHQucHJvdG90eXBlLl9jaGVja0ZpbmFsaXplZFN0YXR1c2VzID0gZnVuY3Rpb24ocikge1xuICAgIHZhciBuID0gdGhpcywgbyA9IG4uaGFzRXJyb3IsIGkgPSBuLnRocm93bkVycm9yLCBzID0gbi5pc1N0b3BwZWQ7XG4gICAgbyA/IHIuZXJyb3IoaSkgOiBzICYmIHIuY29tcGxldGUoKTtcbiAgfSwgdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSBuZXcgQygpO1xuICAgIHJldHVybiByLnNvdXJjZSA9IHRoaXMsIHI7XG4gIH0sIHQuY3JlYXRlID0gZnVuY3Rpb24ociwgbikge1xuICAgIHJldHVybiBuZXcgayhyLCBuKTtcbiAgfSwgdDtcbn0oQyksIGsgPSBmdW5jdGlvbihlKSB7XG4gIGIodCwgZSk7XG4gIGZ1bmN0aW9uIHQociwgbikge1xuICAgIHZhciBvID0gZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmV0dXJuIG8uZGVzdGluYXRpb24gPSByLCBvLnNvdXJjZSA9IG4sIG87XG4gIH1cbiAgcmV0dXJuIHQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIG4sIG87XG4gICAgKG8gPSAobiA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4ubmV4dCkgPT09IG51bGwgfHwgbyA9PT0gdm9pZCAwIHx8IG8uY2FsbChuLCByKTtcbiAgfSwgdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIG4sIG87XG4gICAgKG8gPSAobiA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uZXJyb3IpID09PSBudWxsIHx8IG8gPT09IHZvaWQgMCB8fCBvLmNhbGwobiwgcik7XG4gIH0sIHQucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIsIG47XG4gICAgKG4gPSAociA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIuY29tcGxldGUpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCB8fCBuLmNhbGwocik7XG4gIH0sIHQucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIG4sIG87XG4gICAgcmV0dXJuIChvID0gKG4gPSB0aGlzLnNvdXJjZSkgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbi5zdWJzY3JpYmUocikpICE9PSBudWxsICYmIG8gIT09IHZvaWQgMCA/IG8gOiBNO1xuICB9LCB0O1xufShIKTtcbmZ1bmN0aW9uIG9yKGUsIHQpIHtcbiAgcmV0dXJuIE4oZnVuY3Rpb24ociwgbikge1xuICAgIHZhciBvID0gMDtcbiAgICByLnN1YnNjcmliZShycihuLCBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gZS5jYWxsKHQsIGksIG8rKykgJiYgbi5uZXh0KGkpO1xuICAgIH0pKTtcbiAgfSk7XG59XG5sZXQgdyA9IG51bGw7XG5mdW5jdGlvbiBucigpIHtcbiAgaWYgKCF3KSB7XG4gICAgY29uc3QgZSA9IG5ldyBIKCk7XG4gICAgdyA9IHsgc3ViamVjdDogZSwgZGlzcGF0Y2g6IChyLCBuKSA9PiBlLm5leHQoeyBrZXk6IHIsIHZhbHVlOiBuIH0pIH07XG4gIH1cbiAgcmV0dXJuIHc7XG59XG5jb25zdCB7IHN1YmplY3Q6IGlyLCBkaXNwYXRjaDogc3IgfSA9IG5yKCk7XG5leHBvcnQge1xuICBzciBhcyBkaXNwYXRjaCxcbiAgb3IgYXMgZmlsdGVyLFxuICBpciBhcyBzdWJqZWN0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@designcombo/events/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@designcombo/state/dist/index.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/@designcombo/state/dist/index.es.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACTIVE_CLONE: () => (/* binding */ ui),\n/* harmony export */   ACTIVE_DELETE: () => (/* binding */ La),\n/* harmony export */   ACTIVE_PASTE: () => (/* binding */ ci),\n/* harmony export */   ACTIVE_PREFIX: () => (/* binding */ Ce),\n/* harmony export */   ACTIVE_SET: () => (/* binding */ Ha),\n/* harmony export */   ACTIVE_SPLIT: () => (/* binding */ li),\n/* harmony export */   ADD_ANIMATION: () => (/* binding */ ei),\n/* harmony export */   ADD_AUDIO: () => (/* binding */ Js),\n/* harmony export */   ADD_CAPTIONS: () => (/* binding */ ri),\n/* harmony export */   ADD_COMPOSITION: () => (/* binding */ ii),\n/* harmony export */   ADD_ILLUSTRATION: () => (/* binding */ Qs),\n/* harmony export */   ADD_IMAGE: () => (/* binding */ Zs),\n/* harmony export */   ADD_ITEMS: () => (/* binding */ si),\n/* harmony export */   ADD_MASK: () => (/* binding */ Pa),\n/* harmony export */   ADD_PLACEHOLDER: () => (/* binding */ Ca),\n/* harmony export */   ADD_PREFIX: () => (/* binding */ gt),\n/* harmony export */   ADD_SHAPE: () => (/* binding */ ti),\n/* harmony export */   ADD_SUFFIX: () => (/* binding */ Aa),\n/* harmony export */   ADD_TEMPLATE: () => (/* binding */ ni),\n/* harmony export */   ADD_TEXT: () => (/* binding */ Vs),\n/* harmony export */   ADD_TRANSITION: () => (/* binding */ Ra),\n/* harmony export */   ADD_VIDEO: () => (/* binding */ qs),\n/* harmony export */   DELETE_TEMPLATE_ITEM: () => (/* binding */ Na),\n/* harmony export */   DESIGN_LOAD: () => (/* binding */ Xs),\n/* harmony export */   DESIGN_PREFIX: () => (/* binding */ Dn),\n/* harmony export */   DESIGN_RESIZE: () => (/* binding */ Ks),\n/* harmony export */   EDIT_OBJECT: () => (/* binding */ ai),\n/* harmony export */   EDIT_PREFIX: () => (/* binding */ be),\n/* harmony export */   EDIT_SHAPE: () => (/* binding */ Fa),\n/* harmony export */   EDIT_TEMPLATE_ITEM: () => (/* binding */ $a),\n/* harmony export */   EDIT_TEXT: () => (/* binding */ za),\n/* harmony export */   ENTER_EDIT_MODE: () => (/* binding */ ja),\n/* harmony export */   HISTORY_PREFIX: () => (/* binding */ Sr),\n/* harmony export */   HISTORY_REDO: () => (/* binding */ mi),\n/* harmony export */   HISTORY_RESET: () => (/* binding */ to),\n/* harmony export */   HISTORY_UNDO: () => (/* binding */ hi),\n/* harmony export */   LAYER_CLONE: () => (/* binding */ di),\n/* harmony export */   LAYER_COPY: () => (/* binding */ qa),\n/* harmony export */   LAYER_CUT: () => (/* binding */ Qa),\n/* harmony export */   LAYER_DELETE: () => (/* binding */ fi),\n/* harmony export */   LAYER_EDITING_NAME: () => (/* binding */ Va),\n/* harmony export */   LAYER_HIDDEN: () => (/* binding */ Wa),\n/* harmony export */   LAYER_LOCKED: () => (/* binding */ Ua),\n/* harmony export */   LAYER_MOVE: () => (/* binding */ Ga),\n/* harmony export */   LAYER_PASTE: () => (/* binding */ Ja),\n/* harmony export */   LAYER_PREFIX: () => (/* binding */ pt),\n/* harmony export */   LAYER_RENAME: () => (/* binding */ Ka),\n/* harmony export */   LAYER_REPLACE: () => (/* binding */ pi),\n/* harmony export */   LAYER_SELECT: () => (/* binding */ Ya),\n/* harmony export */   LAYER_SELECTION: () => (/* binding */ Ba),\n/* harmony export */   LAYER_SEND_TO: () => (/* binding */ Xa),\n/* harmony export */   LAYER_SPLIT: () => (/* binding */ Za),\n/* harmony export */   REPLACE_MEDIA: () => (/* binding */ oi),\n/* harmony export */   STATE_CHANGED: () => (/* binding */ Oa),\n/* harmony export */   STATE_PREFIX: () => (/* binding */ Bs),\n/* harmony export */   TIMELINE_SCALE_CHANGED: () => (/* binding */ yi),\n/* harmony export */   TIMELINE_SCALE_PREFIX: () => (/* binding */ us),\n/* harmony export */   TRACKS_CHANGED: () => (/* binding */ xa),\n/* harmony export */   TRACK_ITEMS_CHANGED: () => (/* binding */ Da),\n/* harmony export */   TRACK_ITEMS_PREFIX: () => (/* binding */ Ys),\n/* harmony export */   TRACK_PREFIX: () => (/* binding */ Gs),\n/* harmony export */   \"default\": () => (/* binding */ eo)\n/* harmony export */ });\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @designcombo/events */ \"(ssr)/./node_modules/@designcombo/events/dist/index.es.js\");\nvar xs = Object.defineProperty;\nvar Ds = (t, e, r) => e in t ? xs(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;\nvar le = (t, e, r) => Ds(t, typeof e != \"symbol\" ? e + \"\" : e, r);\n\nvar mn = function(t, e) {\n  return mn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, s) {\n    r.__proto__ = s;\n  } || function(r, s) {\n    for (var a in s) Object.prototype.hasOwnProperty.call(s, a) && (r[a] = s[a]);\n  }, mn(t, e);\n};\nfunction Qe(t, e) {\n  if (typeof e != \"function\" && e !== null)\n    throw new TypeError(\"Class extends value \" + String(e) + \" is not a constructor or null\");\n  mn(t, e);\n  function r() {\n    this.constructor = t;\n  }\n  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());\n}\nfunction yn(t) {\n  var e = typeof Symbol == \"function\" && Symbol.iterator, r = e && t[e], s = 0;\n  if (r) return r.call(t);\n  if (t && typeof t.length == \"number\") return {\n    next: function() {\n      return t && s >= t.length && (t = void 0), { value: t && t[s++], done: !t };\n    }\n  };\n  throw new TypeError(e ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction gn(t, e) {\n  var r = typeof Symbol == \"function\" && t[Symbol.iterator];\n  if (!r) return t;\n  var s = r.call(t), a, c = [], d;\n  try {\n    for (; (e === void 0 || e-- > 0) && !(a = s.next()).done; ) c.push(a.value);\n  } catch (f) {\n    d = { error: f };\n  } finally {\n    try {\n      a && !a.done && (r = s.return) && r.call(s);\n    } finally {\n      if (d) throw d.error;\n    }\n  }\n  return c;\n}\nfunction In(t, e, r) {\n  if (r || arguments.length === 2) for (var s = 0, a = e.length, c; s < a; s++)\n    (c || !(s in e)) && (c || (c = Array.prototype.slice.call(e, 0, s)), c[s] = e[s]);\n  return t.concat(c || Array.prototype.slice.call(e));\n}\nfunction Wt(t) {\n  return typeof t == \"function\";\n}\nfunction ss(t) {\n  var e = function(s) {\n    Error.call(s), s.stack = new Error().stack;\n  }, r = t(e);\n  return r.prototype = Object.create(Error.prototype), r.prototype.constructor = r, r;\n}\nvar ln = ss(function(t) {\n  return function(r) {\n    t(this), this.message = r ? r.length + ` errors occurred during unsubscription:\n` + r.map(function(s, a) {\n      return a + 1 + \") \" + s.toString();\n    }).join(`\n  `) : \"\", this.name = \"UnsubscriptionError\", this.errors = r;\n  };\n});\nfunction bn(t, e) {\n  if (t) {\n    var r = t.indexOf(e);\n    0 <= r && t.splice(r, 1);\n  }\n}\nvar kr = function() {\n  function t(e) {\n    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;\n  }\n  return t.prototype.unsubscribe = function() {\n    var e, r, s, a, c;\n    if (!this.closed) {\n      this.closed = !0;\n      var d = this._parentage;\n      if (d)\n        if (this._parentage = null, Array.isArray(d))\n          try {\n            for (var f = yn(d), b = f.next(); !b.done; b = f.next()) {\n              var _ = b.value;\n              _.remove(this);\n            }\n          } catch (u) {\n            e = { error: u };\n          } finally {\n            try {\n              b && !b.done && (r = f.return) && r.call(f);\n            } finally {\n              if (e) throw e.error;\n            }\n          }\n        else\n          d.remove(this);\n      var M = this.initialTeardown;\n      if (Wt(M))\n        try {\n          M();\n        } catch (u) {\n          c = u instanceof ln ? u.errors : [u];\n        }\n      var E = this._finalizers;\n      if (E) {\n        this._finalizers = null;\n        try {\n          for (var m = yn(E), T = m.next(); !T.done; T = m.next()) {\n            var C = T.value;\n            try {\n              $n(C);\n            } catch (u) {\n              c = c ?? [], u instanceof ln ? c = In(In([], gn(c)), gn(u.errors)) : c.push(u);\n            }\n          }\n        } catch (u) {\n          s = { error: u };\n        } finally {\n          try {\n            T && !T.done && (a = m.return) && a.call(m);\n          } finally {\n            if (s) throw s.error;\n          }\n        }\n      }\n      if (c)\n        throw new ln(c);\n    }\n  }, t.prototype.add = function(e) {\n    var r;\n    if (e && e !== this)\n      if (this.closed)\n        $n(e);\n      else {\n        if (e instanceof t) {\n          if (e.closed || e._hasParent(this))\n            return;\n          e._addParent(this);\n        }\n        (this._finalizers = (r = this._finalizers) !== null && r !== void 0 ? r : []).push(e);\n      }\n  }, t.prototype._hasParent = function(e) {\n    var r = this._parentage;\n    return r === e || Array.isArray(r) && r.includes(e);\n  }, t.prototype._addParent = function(e) {\n    var r = this._parentage;\n    this._parentage = Array.isArray(r) ? (r.push(e), r) : r ? [r, e] : e;\n  }, t.prototype._removeParent = function(e) {\n    var r = this._parentage;\n    r === e ? this._parentage = null : Array.isArray(r) && bn(r, e);\n  }, t.prototype.remove = function(e) {\n    var r = this._finalizers;\n    r && bn(r, e), e instanceof t && e._removeParent(this);\n  }, t.EMPTY = function() {\n    var e = new t();\n    return e.closed = !0, e;\n  }(), t;\n}(), is = kr.EMPTY;\nfunction as(t) {\n  return t instanceof kr || t && \"closed\" in t && Wt(t.remove) && Wt(t.add) && Wt(t.unsubscribe);\n}\nfunction $n(t) {\n  Wt(t) ? t() : t.unsubscribe();\n}\nvar Os = {\n  Promise: void 0\n}, Cs = {\n  setTimeout: function(t, e) {\n    for (var r = [], s = 2; s < arguments.length; s++)\n      r[s - 2] = arguments[s];\n    return setTimeout.apply(void 0, In([t, e], gn(r)));\n  },\n  clearTimeout: function(t) {\n    return clearTimeout(t);\n  },\n  delegate: void 0\n};\nfunction Ps(t) {\n  Cs.setTimeout(function() {\n    throw t;\n  });\n}\nfunction Nn() {\n}\nfunction yr(t) {\n  t();\n}\nvar os = function(t) {\n  Qe(e, t);\n  function e(r) {\n    var s = t.call(this) || this;\n    return s.isStopped = !1, r ? (s.destination = r, as(r) && r.add(s)) : s.destination = Fs, s;\n  }\n  return e.create = function(r, s, a) {\n    return new vn(r, s, a);\n  }, e.prototype.next = function(r) {\n    this.isStopped || this._next(r);\n  }, e.prototype.error = function(r) {\n    this.isStopped || (this.isStopped = !0, this._error(r));\n  }, e.prototype.complete = function() {\n    this.isStopped || (this.isStopped = !0, this._complete());\n  }, e.prototype.unsubscribe = function() {\n    this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this), this.destination = null);\n  }, e.prototype._next = function(r) {\n    this.destination.next(r);\n  }, e.prototype._error = function(r) {\n    try {\n      this.destination.error(r);\n    } finally {\n      this.unsubscribe();\n    }\n  }, e.prototype._complete = function() {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }, e;\n}(kr), Rs = function() {\n  function t(e) {\n    this.partialObserver = e;\n  }\n  return t.prototype.next = function(e) {\n    var r = this.partialObserver;\n    if (r.next)\n      try {\n        r.next(e);\n      } catch (s) {\n        mr(s);\n      }\n  }, t.prototype.error = function(e) {\n    var r = this.partialObserver;\n    if (r.error)\n      try {\n        r.error(e);\n      } catch (s) {\n        mr(s);\n      }\n    else\n      mr(e);\n  }, t.prototype.complete = function() {\n    var e = this.partialObserver;\n    if (e.complete)\n      try {\n        e.complete();\n      } catch (r) {\n        mr(r);\n      }\n  }, t;\n}(), vn = function(t) {\n  Qe(e, t);\n  function e(r, s, a) {\n    var c = t.call(this) || this, d;\n    return Wt(r) || !r ? d = {\n      next: r ?? void 0,\n      error: s ?? void 0,\n      complete: a ?? void 0\n    } : d = r, c.destination = new Rs(d), c;\n  }\n  return e;\n}(os);\nfunction mr(t) {\n  Ps(t);\n}\nfunction zs(t) {\n  throw t;\n}\nvar Fs = {\n  closed: !0,\n  next: Nn,\n  error: zs,\n  complete: Nn\n}, $s = function() {\n  return typeof Symbol == \"function\" && Symbol.observable || \"@@observable\";\n}();\nfunction Ns(t) {\n  return t;\n}\nfunction js(t) {\n  return t.length === 0 ? Ns : t.length === 1 ? t[0] : function(r) {\n    return t.reduce(function(s, a) {\n      return a(s);\n    }, r);\n  };\n}\nvar jn = function() {\n  function t(e) {\n    e && (this._subscribe = e);\n  }\n  return t.prototype.lift = function(e) {\n    var r = new t();\n    return r.source = this, r.operator = e, r;\n  }, t.prototype.subscribe = function(e, r, s) {\n    var a = this, c = Ls(e) ? e : new vn(e, r, s);\n    return yr(function() {\n      var d = a, f = d.operator, b = d.source;\n      c.add(f ? f.call(c, b) : b ? a._subscribe(c) : a._trySubscribe(c));\n    }), c;\n  }, t.prototype._trySubscribe = function(e) {\n    try {\n      return this._subscribe(e);\n    } catch (r) {\n      e.error(r);\n    }\n  }, t.prototype.forEach = function(e, r) {\n    var s = this;\n    return r = Hn(r), new r(function(a, c) {\n      var d = new vn({\n        next: function(f) {\n          try {\n            e(f);\n          } catch (b) {\n            c(b), d.unsubscribe();\n          }\n        },\n        error: c,\n        complete: a\n      });\n      s.subscribe(d);\n    });\n  }, t.prototype._subscribe = function(e) {\n    var r;\n    return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(e);\n  }, t.prototype[$s] = function() {\n    return this;\n  }, t.prototype.pipe = function() {\n    for (var e = [], r = 0; r < arguments.length; r++)\n      e[r] = arguments[r];\n    return js(e)(this);\n  }, t.prototype.toPromise = function(e) {\n    var r = this;\n    return e = Hn(e), new e(function(s, a) {\n      var c;\n      r.subscribe(function(d) {\n        return c = d;\n      }, function(d) {\n        return a(d);\n      }, function() {\n        return s(c);\n      });\n    });\n  }, t.create = function(e) {\n    return new t(e);\n  }, t;\n}();\nfunction Hn(t) {\n  var e;\n  return (e = t ?? Os.Promise) !== null && e !== void 0 ? e : Promise;\n}\nfunction Hs(t) {\n  return t && Wt(t.next) && Wt(t.error) && Wt(t.complete);\n}\nfunction Ls(t) {\n  return t && t instanceof os || Hs(t) && as(t);\n}\nvar Us = ss(function(t) {\n  return function() {\n    t(this), this.name = \"ObjectUnsubscribedError\", this.message = \"object unsubscribed\";\n  };\n}), cs = function(t) {\n  Qe(e, t);\n  function e() {\n    var r = t.call(this) || this;\n    return r.closed = !1, r.currentObservers = null, r.observers = [], r.isStopped = !1, r.hasError = !1, r.thrownError = null, r;\n  }\n  return e.prototype.lift = function(r) {\n    var s = new Ln(this, this);\n    return s.operator = r, s;\n  }, e.prototype._throwIfClosed = function() {\n    if (this.closed)\n      throw new Us();\n  }, e.prototype.next = function(r) {\n    var s = this;\n    yr(function() {\n      var a, c;\n      if (s._throwIfClosed(), !s.isStopped) {\n        s.currentObservers || (s.currentObservers = Array.from(s.observers));\n        try {\n          for (var d = yn(s.currentObservers), f = d.next(); !f.done; f = d.next()) {\n            var b = f.value;\n            b.next(r);\n          }\n        } catch (_) {\n          a = { error: _ };\n        } finally {\n          try {\n            f && !f.done && (c = d.return) && c.call(d);\n          } finally {\n            if (a) throw a.error;\n          }\n        }\n      }\n    });\n  }, e.prototype.error = function(r) {\n    var s = this;\n    yr(function() {\n      if (s._throwIfClosed(), !s.isStopped) {\n        s.hasError = s.isStopped = !0, s.thrownError = r;\n        for (var a = s.observers; a.length; )\n          a.shift().error(r);\n      }\n    });\n  }, e.prototype.complete = function() {\n    var r = this;\n    yr(function() {\n      if (r._throwIfClosed(), !r.isStopped) {\n        r.isStopped = !0;\n        for (var s = r.observers; s.length; )\n          s.shift().complete();\n      }\n    });\n  }, e.prototype.unsubscribe = function() {\n    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;\n  }, Object.defineProperty(e.prototype, \"observed\", {\n    get: function() {\n      var r;\n      return ((r = this.observers) === null || r === void 0 ? void 0 : r.length) > 0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), e.prototype._trySubscribe = function(r) {\n    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, r);\n  }, e.prototype._subscribe = function(r) {\n    return this._throwIfClosed(), this._checkFinalizedStatuses(r), this._innerSubscribe(r);\n  }, e.prototype._innerSubscribe = function(r) {\n    var s = this, a = this, c = a.hasError, d = a.isStopped, f = a.observers;\n    return c || d ? is : (this.currentObservers = null, f.push(r), new kr(function() {\n      s.currentObservers = null, bn(f, r);\n    }));\n  }, e.prototype._checkFinalizedStatuses = function(r) {\n    var s = this, a = s.hasError, c = s.thrownError, d = s.isStopped;\n    a ? r.error(c) : d && r.complete();\n  }, e.prototype.asObservable = function() {\n    var r = new jn();\n    return r.source = this, r;\n  }, e.create = function(r, s) {\n    return new Ln(r, s);\n  }, e;\n}(jn), Ln = function(t) {\n  Qe(e, t);\n  function e(r, s) {\n    var a = t.call(this) || this;\n    return a.destination = r, a.source = s, a;\n  }\n  return e.prototype.next = function(r) {\n    var s, a;\n    (a = (s = this.destination) === null || s === void 0 ? void 0 : s.next) === null || a === void 0 || a.call(s, r);\n  }, e.prototype.error = function(r) {\n    var s, a;\n    (a = (s = this.destination) === null || s === void 0 ? void 0 : s.error) === null || a === void 0 || a.call(s, r);\n  }, e.prototype.complete = function() {\n    var r, s;\n    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.complete) === null || s === void 0 || s.call(r);\n  }, e.prototype._subscribe = function(r) {\n    var s, a;\n    return (a = (s = this.source) === null || s === void 0 ? void 0 : s.subscribe(r)) !== null && a !== void 0 ? a : is;\n  }, e;\n}(cs), Un = function(t) {\n  Qe(e, t);\n  function e(r) {\n    var s = t.call(this) || this;\n    return s._value = r, s;\n  }\n  return Object.defineProperty(e.prototype, \"value\", {\n    get: function() {\n      return this.getValue();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), e.prototype._subscribe = function(r) {\n    var s = t.prototype._subscribe.call(this, r);\n    return !s.closed && r.next(this._value), s;\n  }, e.prototype.getValue = function() {\n    var r = this, s = r.hasError, a = r.thrownError, c = r._value;\n    if (s)\n      throw a;\n    return this._throwIfClosed(), c;\n  }, e.prototype.next = function(r) {\n    t.prototype.next.call(this, this._value = r);\n  }, e;\n}(cs), St = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction xn(t) {\n  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n}\nvar gr = { exports: {} };\ngr.exports;\n(function(t, e) {\n  var r = 200, s = \"__lodash_hash_undefined__\", a = 1, c = 2, d = 9007199254740991, f = \"[object Arguments]\", b = \"[object Array]\", _ = \"[object AsyncFunction]\", M = \"[object Boolean]\", E = \"[object Date]\", m = \"[object Error]\", T = \"[object Function]\", C = \"[object GeneratorFunction]\", u = \"[object Map]\", l = \"[object Number]\", S = \"[object Null]\", w = \"[object Object]\", k = \"[object Promise]\", h = \"[object Proxy]\", y = \"[object RegExp]\", v = \"[object Set]\", I = \"[object String]\", x = \"[object Symbol]\", g = \"[object Undefined]\", O = \"[object WeakMap]\", D = \"[object ArrayBuffer]\", j = \"[object DataView]\", L = \"[object Float32Array]\", R = \"[object Float64Array]\", F = \"[object Int8Array]\", V = \"[object Int16Array]\", kt = \"[object Int32Array]\", Dt = \"[object Uint8Array]\", Ot = \"[object Uint8ClampedArray]\", U = \"[object Uint16Array]\", zt = \"[object Uint32Array]\", wt = /[\\\\^$.*+?()[\\]{}|]/g, at = /^\\[object .+?Constructor\\]$/, Ft = /^(?:0|[1-9]\\d*)$/, A = {};\n  A[L] = A[R] = A[F] = A[V] = A[kt] = A[Dt] = A[Ot] = A[U] = A[zt] = !0, A[f] = A[b] = A[D] = A[M] = A[j] = A[E] = A[m] = A[T] = A[u] = A[l] = A[w] = A[y] = A[v] = A[I] = A[O] = !1;\n  var et = typeof St == \"object\" && St && St.Object === Object && St, Mt = typeof self == \"object\" && self && self.Object === Object && self, ot = et || Mt || Function(\"return this\")(), $t = e && !e.nodeType && e, Et = $t && !0 && t && !t.nodeType && t, Gt = Et && Et.exports === $t, Yt = Gt && et.process, ee = function() {\n    try {\n      return Yt && Yt.binding && Yt.binding(\"util\");\n    } catch {\n    }\n  }(), Bt = ee && ee.isTypedArray;\n  function re(n, i) {\n    for (var o = -1, p = n == null ? 0 : n.length, N = 0, P = []; ++o < p; ) {\n      var G = n[o];\n      i(G, o, n) && (P[N++] = G);\n    }\n    return P;\n  }\n  function Xt(n, i) {\n    for (var o = -1, p = i.length, N = n.length; ++o < p; )\n      n[N + o] = i[o];\n    return n;\n  }\n  function ne(n, i) {\n    for (var o = -1, p = n == null ? 0 : n.length; ++o < p; )\n      if (i(n[o], o, n))\n        return !0;\n    return !1;\n  }\n  function _e(n, i) {\n    for (var o = -1, p = Array(n); ++o < n; )\n      p[o] = i(o);\n    return p;\n  }\n  function ke(n) {\n    return function(i) {\n      return n(i);\n    };\n  }\n  function Nt(n, i) {\n    return n.has(i);\n  }\n  function Kt(n, i) {\n    return n == null ? void 0 : n[i];\n  }\n  function $(n) {\n    var i = -1, o = Array(n.size);\n    return n.forEach(function(p, N) {\n      o[++i] = [N, p];\n    }), o;\n  }\n  function H(n, i) {\n    return function(o) {\n      return n(i(o));\n    };\n  }\n  function z(n) {\n    var i = -1, o = Array(n.size);\n    return n.forEach(function(p) {\n      o[++i] = p;\n    }), o;\n  }\n  var rt = Array.prototype, ct = Function.prototype, B = Object.prototype, ut = ot[\"__core-js_shared__\"], q = ct.toString, ht = B.hasOwnProperty, Se = function() {\n    var n = /[^.]+$/.exec(ut && ut.keys && ut.keys.IE_PROTO || \"\");\n    return n ? \"Symbol(src)_1.\" + n : \"\";\n  }(), se = B.toString, Pe = RegExp(\n    \"^\" + q.call(ht).replace(wt, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n  ), Y = Gt ? ot.Buffer : void 0, mt = ot.Symbol, Vt = ot.Uint8Array, qt = B.propertyIsEnumerable, Tt = rt.splice, At = mt ? mt.toStringTag : void 0, we = Object.getOwnPropertySymbols, Re = Y ? Y.isBuffer : void 0, ie = H(Object.keys, Object), ze = Ht(ot, \"DataView\"), ae = Ht(ot, \"Map\"), Fe = Ht(ot, \"Promise\"), $e = Ht(ot, \"Set\"), Ne = Ht(ot, \"WeakMap\"), Jt = Ht(Object, \"create\"), rr = yt(ze), jt = yt(ae), Er = yt(Fe), Tr = yt($e), Ar = yt(Ne), nr = mt ? mt.prototype : void 0, je = nr ? nr.valueOf : void 0;\n  function nt(n) {\n    var i = -1, o = n == null ? 0 : n.length;\n    for (this.clear(); ++i < o; ) {\n      var p = n[i];\n      this.set(p[0], p[1]);\n    }\n  }\n  function xr() {\n    this.__data__ = Jt ? Jt(null) : {}, this.size = 0;\n  }\n  function Dr(n) {\n    var i = this.has(n) && delete this.__data__[n];\n    return this.size -= i ? 1 : 0, i;\n  }\n  function Or(n) {\n    var i = this.__data__;\n    if (Jt) {\n      var o = i[n];\n      return o === s ? void 0 : o;\n    }\n    return ht.call(i, n) ? i[n] : void 0;\n  }\n  function Cr(n) {\n    var i = this.__data__;\n    return Jt ? i[n] !== void 0 : ht.call(i, n);\n  }\n  function Pr(n, i) {\n    var o = this.__data__;\n    return this.size += this.has(n) ? 0 : 1, o[n] = Jt && i === void 0 ? s : i, this;\n  }\n  nt.prototype.clear = xr, nt.prototype.delete = Dr, nt.prototype.get = Or, nt.prototype.has = Cr, nt.prototype.set = Pr;\n  function lt(n) {\n    var i = -1, o = n == null ? 0 : n.length;\n    for (this.clear(); ++i < o; ) {\n      var p = n[i];\n      this.set(p[0], p[1]);\n    }\n  }\n  function Rr() {\n    this.__data__ = [], this.size = 0;\n  }\n  function zr(n) {\n    var i = this.__data__, o = Te(i, n);\n    if (o < 0)\n      return !1;\n    var p = i.length - 1;\n    return o == p ? i.pop() : Tt.call(i, o, 1), --this.size, !0;\n  }\n  function Fr(n) {\n    var i = this.__data__, o = Te(i, n);\n    return o < 0 ? void 0 : i[o][1];\n  }\n  function $r(n) {\n    return Te(this.__data__, n) > -1;\n  }\n  function Nr(n, i) {\n    var o = this.__data__, p = Te(o, n);\n    return p < 0 ? (++this.size, o.push([n, i])) : o[p][1] = i, this;\n  }\n  lt.prototype.clear = Rr, lt.prototype.delete = zr, lt.prototype.get = Fr, lt.prototype.has = $r, lt.prototype.set = Nr;\n  function It(n) {\n    var i = -1, o = n == null ? 0 : n.length;\n    for (this.clear(); ++i < o; ) {\n      var p = n[i];\n      this.set(p[0], p[1]);\n    }\n  }\n  function jr() {\n    this.size = 0, this.__data__ = {\n      hash: new nt(),\n      map: new (ae || lt)(),\n      string: new nt()\n    };\n  }\n  function Hr(n) {\n    var i = xt(this, n).delete(n);\n    return this.size -= i ? 1 : 0, i;\n  }\n  function Lr(n) {\n    return xt(this, n).get(n);\n  }\n  function Ur(n) {\n    return xt(this, n).has(n);\n  }\n  function Wr(n, i) {\n    var o = xt(this, n), p = o.size;\n    return o.set(n, i), this.size += o.size == p ? 0 : 1, this;\n  }\n  It.prototype.clear = jr, It.prototype.delete = Hr, It.prototype.get = Lr, It.prototype.has = Ur, It.prototype.set = Wr;\n  function Me(n) {\n    var i = -1, o = n == null ? 0 : n.length;\n    for (this.__data__ = new It(); ++i < o; )\n      this.add(n[i]);\n  }\n  function sr(n) {\n    return this.__data__.set(n, s), this;\n  }\n  function Ee(n) {\n    return this.__data__.has(n);\n  }\n  Me.prototype.add = Me.prototype.push = sr, Me.prototype.has = Ee;\n  function Ct(n) {\n    var i = this.__data__ = new lt(n);\n    this.size = i.size;\n  }\n  function He() {\n    this.__data__ = new lt(), this.size = 0;\n  }\n  function Gr(n) {\n    var i = this.__data__, o = i.delete(n);\n    return this.size = i.size, o;\n  }\n  function Yr(n) {\n    return this.__data__.get(n);\n  }\n  function Br(n) {\n    return this.__data__.has(n);\n  }\n  function Xr(n, i) {\n    var o = this.__data__;\n    if (o instanceof lt) {\n      var p = o.__data__;\n      if (!ae || p.length < r - 1)\n        return p.push([n, i]), this.size = ++o.size, this;\n      o = this.__data__ = new It(p);\n    }\n    return o.set(n, i), this.size = o.size, this;\n  }\n  Ct.prototype.clear = He, Ct.prototype.delete = Gr, Ct.prototype.get = Yr, Ct.prototype.has = Br, Ct.prototype.set = Xr;\n  function Kr(n, i) {\n    var o = Ae(n), p = !o && ur(n), N = !o && !p && xe(n), P = !o && !p && !N && fr(n), G = o || p || N || P, W = G ? _e(n.length, String) : [], J = W.length;\n    for (var X in n)\n      ht.call(n, X) && !(G && // Safari 9 has enumerable `arguments.length` in strict mode.\n      (X == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n      N && (X == \"offset\" || X == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n      P && (X == \"buffer\" || X == \"byteLength\" || X == \"byteOffset\") || // Skip index properties.\n      rn(X, J))) && W.push(X);\n    return W;\n  }\n  function Te(n, i) {\n    for (var o = n.length; o--; )\n      if (cr(n[o][0], i))\n        return o;\n    return -1;\n  }\n  function Le(n, i, o) {\n    var p = i(n);\n    return Ae(n) ? p : Xt(p, o(n));\n  }\n  function oe(n) {\n    return n == null ? n === void 0 ? g : S : At && At in Object(n) ? Lt(n) : or(n);\n  }\n  function ir(n) {\n    return Rt(n) && oe(n) == f;\n  }\n  function ar(n, i, o, p, N) {\n    return n === i ? !0 : n == null || i == null || !Rt(n) && !Rt(i) ? n !== n && i !== i : Vr(n, i, o, p, ar, N);\n  }\n  function Vr(n, i, o, p, N, P) {\n    var G = Ae(n), W = Ae(i), J = G ? b : Pt(n), X = W ? b : Pt(i);\n    J = J == f ? w : J, X = X == f ? w : X;\n    var dt = J == w, bt = X == w, Z = J == X;\n    if (Z && xe(n)) {\n      if (!xe(i))\n        return !1;\n      G = !0, dt = !1;\n    }\n    if (Z && !dt)\n      return P || (P = new Ct()), G || fr(n) ? Ue(n, i, o, p, N, P) : Qr(n, i, J, o, p, N, P);\n    if (!(o & a)) {\n      var ft = dt && ht.call(n, \"__wrapped__\"), st = bt && ht.call(i, \"__wrapped__\");\n      if (ft || st) {\n        var Zt = ft ? n.value() : n, Ut = st ? i.value() : i;\n        return P || (P = new Ct()), N(Zt, Ut, o, p, P);\n      }\n    }\n    return Z ? (P || (P = new Ct()), tn(n, i, o, p, N, P)) : !1;\n  }\n  function qr(n) {\n    if (!dr(n) || sn(n))\n      return !1;\n    var i = lr(n) ? Pe : at;\n    return i.test(yt(n));\n  }\n  function Jr(n) {\n    return Rt(n) && Ge(n.length) && !!A[oe(n)];\n  }\n  function Zr(n) {\n    if (!an(n))\n      return ie(n);\n    var i = [];\n    for (var o in Object(n))\n      ht.call(n, o) && o != \"constructor\" && i.push(o);\n    return i;\n  }\n  function Ue(n, i, o, p, N, P) {\n    var G = o & a, W = n.length, J = i.length;\n    if (W != J && !(G && J > W))\n      return !1;\n    var X = P.get(n);\n    if (X && P.get(i))\n      return X == i;\n    var dt = -1, bt = !0, Z = o & c ? new Me() : void 0;\n    for (P.set(n, i), P.set(i, n); ++dt < W; ) {\n      var ft = n[dt], st = i[dt];\n      if (p)\n        var Zt = G ? p(st, ft, dt, i, n, P) : p(ft, st, dt, n, i, P);\n      if (Zt !== void 0) {\n        if (Zt)\n          continue;\n        bt = !1;\n        break;\n      }\n      if (Z) {\n        if (!ne(i, function(Ut, ue) {\n          if (!Nt(Z, ue) && (ft === Ut || N(ft, Ut, o, p, P)))\n            return Z.push(ue);\n        })) {\n          bt = !1;\n          break;\n        }\n      } else if (!(ft === st || N(ft, st, o, p, P))) {\n        bt = !1;\n        break;\n      }\n    }\n    return P.delete(n), P.delete(i), bt;\n  }\n  function Qr(n, i, o, p, N, P, G) {\n    switch (o) {\n      case j:\n        if (n.byteLength != i.byteLength || n.byteOffset != i.byteOffset)\n          return !1;\n        n = n.buffer, i = i.buffer;\n      case D:\n        return !(n.byteLength != i.byteLength || !P(new Vt(n), new Vt(i)));\n      case M:\n      case E:\n      case l:\n        return cr(+n, +i);\n      case m:\n        return n.name == i.name && n.message == i.message;\n      case y:\n      case I:\n        return n == i + \"\";\n      case u:\n        var W = $;\n      case v:\n        var J = p & a;\n        if (W || (W = z), n.size != i.size && !J)\n          return !1;\n        var X = G.get(n);\n        if (X)\n          return X == i;\n        p |= c, G.set(n, i);\n        var dt = Ue(W(n), W(i), p, N, P, G);\n        return G.delete(n), dt;\n      case x:\n        if (je)\n          return je.call(n) == je.call(i);\n    }\n    return !1;\n  }\n  function tn(n, i, o, p, N, P) {\n    var G = o & a, W = ce(n), J = W.length, X = ce(i), dt = X.length;\n    if (J != dt && !G)\n      return !1;\n    for (var bt = J; bt--; ) {\n      var Z = W[bt];\n      if (!(G ? Z in i : ht.call(i, Z)))\n        return !1;\n    }\n    var ft = P.get(n);\n    if (ft && P.get(i))\n      return ft == i;\n    var st = !0;\n    P.set(n, i), P.set(i, n);\n    for (var Zt = G; ++bt < J; ) {\n      Z = W[bt];\n      var Ut = n[Z], ue = i[Z];\n      if (p)\n        var Fn = G ? p(ue, Ut, Z, i, n, P) : p(Ut, ue, Z, n, i, P);\n      if (!(Fn === void 0 ? Ut === ue || N(Ut, ue, o, p, P) : Fn)) {\n        st = !1;\n        break;\n      }\n      Zt || (Zt = Z == \"constructor\");\n    }\n    if (st && !Zt) {\n      var pr = n.constructor, hr = i.constructor;\n      pr != hr && \"constructor\" in n && \"constructor\" in i && !(typeof pr == \"function\" && pr instanceof pr && typeof hr == \"function\" && hr instanceof hr) && (st = !1);\n    }\n    return P.delete(n), P.delete(i), st;\n  }\n  function ce(n) {\n    return Le(n, Ye, en);\n  }\n  function xt(n, i) {\n    var o = n.__data__;\n    return nn(i) ? o[typeof i == \"string\" ? \"string\" : \"hash\"] : o.map;\n  }\n  function Ht(n, i) {\n    var o = Kt(n, i);\n    return qr(o) ? o : void 0;\n  }\n  function Lt(n) {\n    var i = ht.call(n, At), o = n[At];\n    try {\n      n[At] = void 0;\n      var p = !0;\n    } catch {\n    }\n    var N = se.call(n);\n    return p && (i ? n[At] = o : delete n[At]), N;\n  }\n  var en = we ? function(n) {\n    return n == null ? [] : (n = Object(n), re(we(n), function(i) {\n      return qt.call(n, i);\n    }));\n  } : cn, Pt = oe;\n  (ze && Pt(new ze(new ArrayBuffer(1))) != j || ae && Pt(new ae()) != u || Fe && Pt(Fe.resolve()) != k || $e && Pt(new $e()) != v || Ne && Pt(new Ne()) != O) && (Pt = function(n) {\n    var i = oe(n), o = i == w ? n.constructor : void 0, p = o ? yt(o) : \"\";\n    if (p)\n      switch (p) {\n        case rr:\n          return j;\n        case jt:\n          return u;\n        case Er:\n          return k;\n        case Tr:\n          return v;\n        case Ar:\n          return O;\n      }\n    return i;\n  });\n  function rn(n, i) {\n    return i = i ?? d, !!i && (typeof n == \"number\" || Ft.test(n)) && n > -1 && n % 1 == 0 && n < i;\n  }\n  function nn(n) {\n    var i = typeof n;\n    return i == \"string\" || i == \"number\" || i == \"symbol\" || i == \"boolean\" ? n !== \"__proto__\" : n === null;\n  }\n  function sn(n) {\n    return !!Se && Se in n;\n  }\n  function an(n) {\n    var i = n && n.constructor, o = typeof i == \"function\" && i.prototype || B;\n    return n === o;\n  }\n  function or(n) {\n    return se.call(n);\n  }\n  function yt(n) {\n    if (n != null) {\n      try {\n        return q.call(n);\n      } catch {\n      }\n      try {\n        return n + \"\";\n      } catch {\n      }\n    }\n    return \"\";\n  }\n  function cr(n, i) {\n    return n === i || n !== n && i !== i;\n  }\n  var ur = ir(/* @__PURE__ */ function() {\n    return arguments;\n  }()) ? ir : function(n) {\n    return Rt(n) && ht.call(n, \"callee\") && !qt.call(n, \"callee\");\n  }, Ae = Array.isArray;\n  function We(n) {\n    return n != null && Ge(n.length) && !lr(n);\n  }\n  var xe = Re || un;\n  function on(n, i) {\n    return ar(n, i);\n  }\n  function lr(n) {\n    if (!dr(n))\n      return !1;\n    var i = oe(n);\n    return i == T || i == C || i == _ || i == h;\n  }\n  function Ge(n) {\n    return typeof n == \"number\" && n > -1 && n % 1 == 0 && n <= d;\n  }\n  function dr(n) {\n    var i = typeof n;\n    return n != null && (i == \"object\" || i == \"function\");\n  }\n  function Rt(n) {\n    return n != null && typeof n == \"object\";\n  }\n  var fr = Bt ? ke(Bt) : Jr;\n  function Ye(n) {\n    return We(n) ? Kr(n) : Zr(n);\n  }\n  function cn() {\n    return [];\n  }\n  function un() {\n    return !1;\n  }\n  t.exports = on;\n})(gr, gr.exports);\nvar Ws = gr.exports;\nconst Q = /* @__PURE__ */ xn(Ws), Aa = \"add\", Gs = \"track\", Ys = \"trackItems\", xa = `${Gs}:changed`, Da = `${Ys}:changed`, Bs = \"state\", Oa = `${Bs}:changed`, Dn = \"design\", Xs = `${Dn}:load`, Ks = `${Dn}:resize`, gt = \"add\", Vs = `${gt}:text`, qs = `${gt}:video`, Js = `${gt}:audio`, Ca = `${gt}:placeholder`, Zs = `${gt}:image`, Qs = `${gt}:illustration`, ti = `${gt}:shape`, Pa = `${gt}:mask`, Ra = `${gt}:transition`, ei = `${gt}:animation`, ri = `${gt}:caption`, ni = `${gt}:template`, si = `${gt}:items`, ii = `${gt}:composition`, be = \"edit\", ai = `${be}:object`, oi = `${be}:replaceMedia`, za = `${be}:text`, Fa = `${be}:shape`, $a = `${be}:templateItem`, Na = `${be}:deleteTemplateItem`, ja = \"enterEditMode\", Ce = \"active\", Ha = `${Ce}:set`, La = `${Ce}:delete`, ci = `${Ce}:paste`, ui = `${Ce}:clone`, li = `${Ce}:split`, pt = \"layer\", Ua = `${pt}:locked`, Wa = `${pt}:hidden`, Ga = `${pt}:move`, Ya = `${pt}:select`, Ba = `${pt}:selection`, Xa = `${pt}:sendTo`, Ka = `${pt}:rename`, Va = `${pt}:editingName`, qa = `${pt}:copy`, Ja = `${pt}:paste`, di = `${pt}:clone`, Za = `${pt}:split`, Qa = `${pt}:cut`, fi = `${pt}:delete`, pi = `${pt}:replace`, Sr = \"history\", hi = `${Sr}:undo`, mi = `${Sr}:redo`, to = `${Sr}:reset`, us = \"scale\", yi = `${us}:changed`;\nvar Ir = { exports: {} };\nIr.exports;\n(function(t, e) {\n  var r = 200, s = \"__lodash_hash_undefined__\", a = 9007199254740991, c = \"[object Arguments]\", d = \"[object Array]\", f = \"[object Boolean]\", b = \"[object Date]\", _ = \"[object Error]\", M = \"[object Function]\", E = \"[object GeneratorFunction]\", m = \"[object Map]\", T = \"[object Number]\", C = \"[object Object]\", u = \"[object Promise]\", l = \"[object RegExp]\", S = \"[object Set]\", w = \"[object String]\", k = \"[object Symbol]\", h = \"[object WeakMap]\", y = \"[object ArrayBuffer]\", v = \"[object DataView]\", I = \"[object Float32Array]\", x = \"[object Float64Array]\", g = \"[object Int8Array]\", O = \"[object Int16Array]\", D = \"[object Int32Array]\", j = \"[object Uint8Array]\", L = \"[object Uint8ClampedArray]\", R = \"[object Uint16Array]\", F = \"[object Uint32Array]\", V = /[\\\\^$.*+?()[\\]{}|]/g, kt = /\\w*$/, Dt = /^\\[object .+?Constructor\\]$/, Ot = /^(?:0|[1-9]\\d*)$/, U = {};\n  U[c] = U[d] = U[y] = U[v] = U[f] = U[b] = U[I] = U[x] = U[g] = U[O] = U[D] = U[m] = U[T] = U[C] = U[l] = U[S] = U[w] = U[k] = U[j] = U[L] = U[R] = U[F] = !0, U[_] = U[M] = U[h] = !1;\n  var zt = typeof St == \"object\" && St && St.Object === Object && St, wt = typeof self == \"object\" && self && self.Object === Object && self, at = zt || wt || Function(\"return this\")(), Ft = e && !e.nodeType && e, A = Ft && !0 && t && !t.nodeType && t, et = A && A.exports === Ft;\n  function Mt(n, i) {\n    return n.set(i[0], i[1]), n;\n  }\n  function ot(n, i) {\n    return n.add(i), n;\n  }\n  function $t(n, i) {\n    for (var o = -1, p = n ? n.length : 0; ++o < p && i(n[o], o, n) !== !1; )\n      ;\n    return n;\n  }\n  function Et(n, i) {\n    for (var o = -1, p = i.length, N = n.length; ++o < p; )\n      n[N + o] = i[o];\n    return n;\n  }\n  function Gt(n, i, o, p) {\n    for (var N = -1, P = n ? n.length : 0; ++N < P; )\n      o = i(o, n[N], N, n);\n    return o;\n  }\n  function Yt(n, i) {\n    for (var o = -1, p = Array(n); ++o < n; )\n      p[o] = i(o);\n    return p;\n  }\n  function ee(n, i) {\n    return n == null ? void 0 : n[i];\n  }\n  function Bt(n) {\n    var i = !1;\n    if (n != null && typeof n.toString != \"function\")\n      try {\n        i = !!(n + \"\");\n      } catch {\n      }\n    return i;\n  }\n  function re(n) {\n    var i = -1, o = Array(n.size);\n    return n.forEach(function(p, N) {\n      o[++i] = [N, p];\n    }), o;\n  }\n  function Xt(n, i) {\n    return function(o) {\n      return n(i(o));\n    };\n  }\n  function ne(n) {\n    var i = -1, o = Array(n.size);\n    return n.forEach(function(p) {\n      o[++i] = p;\n    }), o;\n  }\n  var _e = Array.prototype, ke = Function.prototype, Nt = Object.prototype, Kt = at[\"__core-js_shared__\"], $ = function() {\n    var n = /[^.]+$/.exec(Kt && Kt.keys && Kt.keys.IE_PROTO || \"\");\n    return n ? \"Symbol(src)_1.\" + n : \"\";\n  }(), H = ke.toString, z = Nt.hasOwnProperty, rt = Nt.toString, ct = RegExp(\n    \"^\" + H.call(z).replace(V, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n  ), B = et ? at.Buffer : void 0, ut = at.Symbol, q = at.Uint8Array, ht = Xt(Object.getPrototypeOf, Object), Se = Object.create, se = Nt.propertyIsEnumerable, Pe = _e.splice, Y = Object.getOwnPropertySymbols, mt = B ? B.isBuffer : void 0, Vt = Xt(Object.keys, Object), qt = xt(at, \"DataView\"), Tt = xt(at, \"Map\"), At = xt(at, \"Promise\"), we = xt(at, \"Set\"), Re = xt(at, \"WeakMap\"), ie = xt(Object, \"create\"), ze = yt(qt), ae = yt(Tt), Fe = yt(At), $e = yt(we), Ne = yt(Re), Jt = ut ? ut.prototype : void 0, rr = Jt ? Jt.valueOf : void 0;\n  function jt(n) {\n    var i = -1, o = n ? n.length : 0;\n    for (this.clear(); ++i < o; ) {\n      var p = n[i];\n      this.set(p[0], p[1]);\n    }\n  }\n  function Er() {\n    this.__data__ = ie ? ie(null) : {};\n  }\n  function Tr(n) {\n    return this.has(n) && delete this.__data__[n];\n  }\n  function Ar(n) {\n    var i = this.__data__;\n    if (ie) {\n      var o = i[n];\n      return o === s ? void 0 : o;\n    }\n    return z.call(i, n) ? i[n] : void 0;\n  }\n  function nr(n) {\n    var i = this.__data__;\n    return ie ? i[n] !== void 0 : z.call(i, n);\n  }\n  function je(n, i) {\n    var o = this.__data__;\n    return o[n] = ie && i === void 0 ? s : i, this;\n  }\n  jt.prototype.clear = Er, jt.prototype.delete = Tr, jt.prototype.get = Ar, jt.prototype.has = nr, jt.prototype.set = je;\n  function nt(n) {\n    var i = -1, o = n ? n.length : 0;\n    for (this.clear(); ++i < o; ) {\n      var p = n[i];\n      this.set(p[0], p[1]);\n    }\n  }\n  function xr() {\n    this.__data__ = [];\n  }\n  function Dr(n) {\n    var i = this.__data__, o = Ee(i, n);\n    if (o < 0)\n      return !1;\n    var p = i.length - 1;\n    return o == p ? i.pop() : Pe.call(i, o, 1), !0;\n  }\n  function Or(n) {\n    var i = this.__data__, o = Ee(i, n);\n    return o < 0 ? void 0 : i[o][1];\n  }\n  function Cr(n) {\n    return Ee(this.__data__, n) > -1;\n  }\n  function Pr(n, i) {\n    var o = this.__data__, p = Ee(o, n);\n    return p < 0 ? o.push([n, i]) : o[p][1] = i, this;\n  }\n  nt.prototype.clear = xr, nt.prototype.delete = Dr, nt.prototype.get = Or, nt.prototype.has = Cr, nt.prototype.set = Pr;\n  function lt(n) {\n    var i = -1, o = n ? n.length : 0;\n    for (this.clear(); ++i < o; ) {\n      var p = n[i];\n      this.set(p[0], p[1]);\n    }\n  }\n  function Rr() {\n    this.__data__ = {\n      hash: new jt(),\n      map: new (Tt || nt)(),\n      string: new jt()\n    };\n  }\n  function zr(n) {\n    return ce(this, n).delete(n);\n  }\n  function Fr(n) {\n    return ce(this, n).get(n);\n  }\n  function $r(n) {\n    return ce(this, n).has(n);\n  }\n  function Nr(n, i) {\n    return ce(this, n).set(n, i), this;\n  }\n  lt.prototype.clear = Rr, lt.prototype.delete = zr, lt.prototype.get = Fr, lt.prototype.has = $r, lt.prototype.set = Nr;\n  function It(n) {\n    this.__data__ = new nt(n);\n  }\n  function jr() {\n    this.__data__ = new nt();\n  }\n  function Hr(n) {\n    return this.__data__.delete(n);\n  }\n  function Lr(n) {\n    return this.__data__.get(n);\n  }\n  function Ur(n) {\n    return this.__data__.has(n);\n  }\n  function Wr(n, i) {\n    var o = this.__data__;\n    if (o instanceof nt) {\n      var p = o.__data__;\n      if (!Tt || p.length < r - 1)\n        return p.push([n, i]), this;\n      o = this.__data__ = new lt(p);\n    }\n    return o.set(n, i), this;\n  }\n  It.prototype.clear = jr, It.prototype.delete = Hr, It.prototype.get = Lr, It.prototype.has = Ur, It.prototype.set = Wr;\n  function Me(n, i) {\n    var o = We(n) || Ae(n) ? Yt(n.length, String) : [], p = o.length, N = !!p;\n    for (var P in n)\n      z.call(n, P) && !(N && (P == \"length\" || nn(P, p))) && o.push(P);\n    return o;\n  }\n  function sr(n, i, o) {\n    var p = n[i];\n    (!(z.call(n, i) && ur(p, o)) || o === void 0 && !(i in n)) && (n[i] = o);\n  }\n  function Ee(n, i) {\n    for (var o = n.length; o--; )\n      if (ur(n[o][0], i))\n        return o;\n    return -1;\n  }\n  function Ct(n, i) {\n    return n && Ue(i, Ye(i), n);\n  }\n  function He(n, i, o, p, N, P, G) {\n    var W;\n    if (p && (W = P ? p(n, N, P, G) : p(n)), W !== void 0)\n      return W;\n    if (!Rt(n))\n      return n;\n    var J = We(n);\n    if (J) {\n      if (W = en(n), !i)\n        return Zr(n, W);\n    } else {\n      var X = Lt(n), dt = X == M || X == E;\n      if (lr(n))\n        return Te(n, i);\n      if (X == C || X == c || dt && !P) {\n        if (Bt(n))\n          return P ? n : {};\n        if (W = Pt(dt ? {} : n), !i)\n          return Qr(n, Ct(W, n));\n      } else {\n        if (!U[X])\n          return P ? n : {};\n        W = rn(n, X, He, i);\n      }\n    }\n    G || (G = new It());\n    var bt = G.get(n);\n    if (bt)\n      return bt;\n    if (G.set(n, W), !J)\n      var Z = o ? tn(n) : Ye(n);\n    return $t(Z || n, function(ft, st) {\n      Z && (st = ft, ft = n[st]), sr(W, st, He(ft, i, o, p, st, n, G));\n    }), W;\n  }\n  function Gr(n) {\n    return Rt(n) ? Se(n) : {};\n  }\n  function Yr(n, i, o) {\n    var p = i(n);\n    return We(n) ? p : Et(p, o(n));\n  }\n  function Br(n) {\n    return rt.call(n);\n  }\n  function Xr(n) {\n    if (!Rt(n) || an(n))\n      return !1;\n    var i = Ge(n) || Bt(n) ? ct : Dt;\n    return i.test(yt(n));\n  }\n  function Kr(n) {\n    if (!or(n))\n      return Vt(n);\n    var i = [];\n    for (var o in Object(n))\n      z.call(n, o) && o != \"constructor\" && i.push(o);\n    return i;\n  }\n  function Te(n, i) {\n    if (i)\n      return n.slice();\n    var o = new n.constructor(n.length);\n    return n.copy(o), o;\n  }\n  function Le(n) {\n    var i = new n.constructor(n.byteLength);\n    return new q(i).set(new q(n)), i;\n  }\n  function oe(n, i) {\n    var o = i ? Le(n.buffer) : n.buffer;\n    return new n.constructor(o, n.byteOffset, n.byteLength);\n  }\n  function ir(n, i, o) {\n    var p = i ? o(re(n), !0) : re(n);\n    return Gt(p, Mt, new n.constructor());\n  }\n  function ar(n) {\n    var i = new n.constructor(n.source, kt.exec(n));\n    return i.lastIndex = n.lastIndex, i;\n  }\n  function Vr(n, i, o) {\n    var p = i ? o(ne(n), !0) : ne(n);\n    return Gt(p, ot, new n.constructor());\n  }\n  function qr(n) {\n    return rr ? Object(rr.call(n)) : {};\n  }\n  function Jr(n, i) {\n    var o = i ? Le(n.buffer) : n.buffer;\n    return new n.constructor(o, n.byteOffset, n.length);\n  }\n  function Zr(n, i) {\n    var o = -1, p = n.length;\n    for (i || (i = Array(p)); ++o < p; )\n      i[o] = n[o];\n    return i;\n  }\n  function Ue(n, i, o, p) {\n    o || (o = {});\n    for (var N = -1, P = i.length; ++N < P; ) {\n      var G = i[N], W = void 0;\n      sr(o, G, W === void 0 ? n[G] : W);\n    }\n    return o;\n  }\n  function Qr(n, i) {\n    return Ue(n, Ht(n), i);\n  }\n  function tn(n) {\n    return Yr(n, Ye, Ht);\n  }\n  function ce(n, i) {\n    var o = n.__data__;\n    return sn(i) ? o[typeof i == \"string\" ? \"string\" : \"hash\"] : o.map;\n  }\n  function xt(n, i) {\n    var o = ee(n, i);\n    return Xr(o) ? o : void 0;\n  }\n  var Ht = Y ? Xt(Y, Object) : cn, Lt = Br;\n  (qt && Lt(new qt(new ArrayBuffer(1))) != v || Tt && Lt(new Tt()) != m || At && Lt(At.resolve()) != u || we && Lt(new we()) != S || Re && Lt(new Re()) != h) && (Lt = function(n) {\n    var i = rt.call(n), o = i == C ? n.constructor : void 0, p = o ? yt(o) : void 0;\n    if (p)\n      switch (p) {\n        case ze:\n          return v;\n        case ae:\n          return m;\n        case Fe:\n          return u;\n        case $e:\n          return S;\n        case Ne:\n          return h;\n      }\n    return i;\n  });\n  function en(n) {\n    var i = n.length, o = n.constructor(i);\n    return i && typeof n[0] == \"string\" && z.call(n, \"index\") && (o.index = n.index, o.input = n.input), o;\n  }\n  function Pt(n) {\n    return typeof n.constructor == \"function\" && !or(n) ? Gr(ht(n)) : {};\n  }\n  function rn(n, i, o, p) {\n    var N = n.constructor;\n    switch (i) {\n      case y:\n        return Le(n);\n      case f:\n      case b:\n        return new N(+n);\n      case v:\n        return oe(n, p);\n      case I:\n      case x:\n      case g:\n      case O:\n      case D:\n      case j:\n      case L:\n      case R:\n      case F:\n        return Jr(n, p);\n      case m:\n        return ir(n, p, o);\n      case T:\n      case w:\n        return new N(n);\n      case l:\n        return ar(n);\n      case S:\n        return Vr(n, p, o);\n      case k:\n        return qr(n);\n    }\n  }\n  function nn(n, i) {\n    return i = i ?? a, !!i && (typeof n == \"number\" || Ot.test(n)) && n > -1 && n % 1 == 0 && n < i;\n  }\n  function sn(n) {\n    var i = typeof n;\n    return i == \"string\" || i == \"number\" || i == \"symbol\" || i == \"boolean\" ? n !== \"__proto__\" : n === null;\n  }\n  function an(n) {\n    return !!$ && $ in n;\n  }\n  function or(n) {\n    var i = n && n.constructor, o = typeof i == \"function\" && i.prototype || Nt;\n    return n === o;\n  }\n  function yt(n) {\n    if (n != null) {\n      try {\n        return H.call(n);\n      } catch {\n      }\n      try {\n        return n + \"\";\n      } catch {\n      }\n    }\n    return \"\";\n  }\n  function cr(n) {\n    return He(n, !0, !0);\n  }\n  function ur(n, i) {\n    return n === i || n !== n && i !== i;\n  }\n  function Ae(n) {\n    return on(n) && z.call(n, \"callee\") && (!se.call(n, \"callee\") || rt.call(n) == c);\n  }\n  var We = Array.isArray;\n  function xe(n) {\n    return n != null && dr(n.length) && !Ge(n);\n  }\n  function on(n) {\n    return fr(n) && xe(n);\n  }\n  var lr = mt || un;\n  function Ge(n) {\n    var i = Rt(n) ? rt.call(n) : \"\";\n    return i == M || i == E;\n  }\n  function dr(n) {\n    return typeof n == \"number\" && n > -1 && n % 1 == 0 && n <= a;\n  }\n  function Rt(n) {\n    var i = typeof n;\n    return !!n && (i == \"object\" || i == \"function\");\n  }\n  function fr(n) {\n    return !!n && typeof n == \"object\";\n  }\n  function Ye(n) {\n    return xe(n) ? Me(n) : Kr(n);\n  }\n  function cn() {\n    return [];\n  }\n  function un() {\n    return !1;\n  }\n  t.exports = cr;\n})(Ir, Ir.exports);\nvar gi = Ir.exports;\nconst K = /* @__PURE__ */ xn(gi), Oe = (t) => new Promise((e, r) => {\n  const s = new Image();\n  console.warn(\"update cdn config for cors?\"), s.onload = () => {\n    const a = s.width, c = s.height;\n    e({ width: a, height: c });\n  }, s.onerror = (a) => {\n    r(a);\n  }, s.crossOrigin = \"anonymous\", s.src = t;\n}), ls = (t) => new Promise((e, r) => {\n  const s = new Audio();\n  s.preload = \"auto\", s.addEventListener(\"loadedmetadata\", () => {\n    const a = s.duration * 1e3;\n    e({ duration: a });\n  }), s.addEventListener(\"error\", (a) => {\n    r(a);\n  }), s.src = t, s.crossOrigin = \"anonymous\", s.load();\n}), _n = (t) => new Promise((e, r) => {\n  const s = document.createElement(\"video\");\n  s.preload = \"auto\", s.addEventListener(\"loadedmetadata\", () => {\n    const a = s.duration * 1e3, c = s.videoWidth, d = s.videoHeight;\n    e({ duration: a, width: c, height: d });\n  }), s.addEventListener(\"error\", (a) => {\n    r(a);\n  }), s.src = t, s.load();\n}), Ii = async (t) => {\n  var a, c;\n  const e = t.duration, r = (a = t.details) == null ? void 0 : a.width, s = (c = t.details) == null ? void 0 : c.height;\n  return e && r && s ? { duration: e, width: r, height: s } : _n(t.details.src);\n}, ds = (t, e) => {\n  const r = document.createElement(\"div\");\n  Object.keys(e).forEach((a) => {\n    a !== \"height\" && (r.style[a] = e[a]);\n  }), document.body.appendChild(r), r.textContent = t, r.style.whiteSpace = \"normal\", r.style.position = \"absolute\", r.style.visibility = \"hidden\", r.style.display = \"inline-block\", r.style.width = e.width + \"px\", r.style.fontSize = e.fontSize + \"px\";\n  const s = getComputedStyle(r).height;\n  return document.body.removeChild(r), parseFloat(s);\n}, br = (t) => {\n  const e = t.map((r) => new FontFace(r.fontFamily, `url(${r.url})`).load().catch((s) => s));\n  return e.length === 0 ? Promise.resolve(!0) : new Promise((r, s) => {\n    Promise.all(e).then((a) => {\n      a.forEach((c) => {\n        c && c.family && (document.fonts.add(c), r(!0));\n      });\n    }).catch((a) => s(a));\n  });\n}, bi = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet Xe = (t = 21) => {\n  let e = \"\", r = crypto.getRandomValues(new Uint8Array(t |= 0));\n  for (; t--; )\n    e += bi[r[t] & 63];\n  return e;\n};\nfunction De(t = 16) {\n  const e = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", r = e.charAt(Math.floor(Math.random() * e.length));\n  let s = Xe(t - 1);\n  return s = s.replace(/[^a-zA-Z0-9]/g, \"\").slice(0, t - 1), r + s;\n}\nfunction vi(t) {\n  const e = /#([0-9a-fA-F]{3,6})\\b/g, r = /rgb\\(\\s*(\\d+),\\s*(\\d+),\\s*(\\d+)\\s*\\)/g, s = /rgba\\(\\s*(\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([0-9.]+)\\s*\\)/g;\n  function a(d) {\n    return d.length === 3 ? `#${d[0]}${d[0]}${d[1]}${d[1]}${d[2]}${d[2]}`.toUpperCase() : `#${d.toUpperCase()}`;\n  }\n  function c(d, f, b) {\n    return `#${(1 << 24 | d << 16 | f << 8 | b).toString(16).slice(1).toUpperCase()}`;\n  }\n  return t = t.replace(e, (d, f) => a(f)), t = t.replace(\n    r,\n    (d, f, b, _) => c(+f, +b, +_)\n  ), t = t.replace(\n    s,\n    (d, f, b, _) => c(+f, +b, +_)\n  ), t;\n}\nfunction it(t) {\n  return /^#[0-9a-fA-F]{3}$/.test(t) ? \"#\" + t[1] + t[1] + t[2] + t[2] + t[3] + t[3] : t;\n}\nfunction Wn(t, e) {\n  let r = t;\n  for (const s in e)\n    if (Object.prototype.hasOwnProperty.call(e, s)) {\n      const a = new RegExp(s, \"g\");\n      r = r.replace(a, e[s]);\n    }\n  return r;\n}\nfunction fs(t) {\n  const e = t.getAttribute(\"fill\");\n  if (e && e.trim() !== \"\" && e.trim() !== \"none\")\n    return e.trim();\n  const r = t.getAttribute(\"style\");\n  if (r) {\n    const a = /fill\\s*:\\s*([^;]+);?/.exec(r);\n    if (a) {\n      const c = a[1].trim();\n      if (c !== \"\" && c !== \"none\")\n        return c;\n    }\n  }\n  const s = t.parentElement;\n  return s ? fs(s) : null;\n}\nfunction Be(t) {\n  return /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/.test(t);\n}\nconst _i = (t) => {\n  const e = `.${t.split(\".\").filter((c) => c.includes(\"fill:\")).join(\".\")}`, r = {}, s = /\\.([\\w-]+)\\s*\\{\\s*([^}]+)\\s*\\}/g;\n  let a;\n  for (; (a = s.exec(e)) !== null; ) {\n    const c = a[1], d = a[2], f = {}, b = /fill\\s*:\\s*([^;]+);?/.exec(d), _ = /stroke\\s*:\\s*([^;]+);?/.exec(d);\n    b && (f.fill = it(b[1].trim())), _ && (f.stroke = it(_[1].trim())), r[c] = f;\n  }\n  return r;\n};\nfunction dn(t) {\n  let e = t.parentElement;\n  for (; e; ) {\n    if (e.tagName.toLowerCase() === \"mask\")\n      return !0;\n    e = e.parentElement;\n  }\n  return !1;\n}\nfunction ki(t, e, r = 300, s = 300) {\n  const a = [], d = new DOMParser().parseFromString(t, \"image/svg+xml\"), f = d.documentElement;\n  f.setAttribute(\"width\", `${r}`), f.setAttribute(\"height\", `${s}`);\n  const b = f.querySelectorAll(\"style\"), _ = {};\n  b.forEach((u) => {\n    const l = u.textContent || \"\", S = _i(l);\n    Object.assign(_, S);\n    const w = l.replace(/\\.(st[\\w-]+)/g, `.${e}-$1`).replace(/url\\(#(.*?)\\)/g, `url(#${e}-$1)`);\n    u.textContent = w;\n    const k = Array.from(d.querySelectorAll(\"*\")), h = /* @__PURE__ */ new Set();\n    k.forEach((y) => {\n      if (dn(y)) return;\n      [\"fill\", \"stroke\", \"stop-color\"].forEach((x) => {\n        const g = y.getAttribute(x);\n        g && ![\"none\", \"transparent\"].includes(g) && h.add(it(g));\n      });\n      const v = y.getAttribute(\"style\");\n      if (v) {\n        const x = /fill\\s*:\\s*([^;]+);?/.exec(v), g = /stroke\\s*:\\s*([^;]+);?/.exec(v), O = /stop-color\\s*:\\s*([^;]+);?/.exec(v);\n        if (x) {\n          const D = x[1].trim();\n          D && ![\"none\", \"transparent\"].includes(D) && Be(it(D)) && h.add(it(D));\n        }\n        if (g) {\n          const D = g[1].trim();\n          D && ![\"none\", \"transparent\"].includes(D) && Be(it(D)) && h.add(it(D));\n        }\n        if (O) {\n          const D = O[1].trim();\n          D && ![\"none\", \"transparent\"].includes(D) && Be(it(D)) && h.add(it(D));\n        }\n      }\n      const I = y.getAttribute(\"class\");\n      I && I.split(\" \").forEach((x) => {\n        const g = _[x];\n        g != null && g.fill && ![\"none\", \"transparent\"].includes(g.fill) && h.add(it(g.fill)), g != null && g.stroke && ![\"none\", \"transparent\"].includes(g.stroke) && h.add(it(g.stroke));\n      });\n    }), Array.from(h).forEach((y) => {\n      Be(y) && a.push(y);\n    });\n  });\n  const M = Array.from(d.querySelectorAll(\"*\")), E = /* @__PURE__ */ new Set();\n  return M.forEach((u) => {\n    if (dn(u)) return;\n    const l = u.getAttribute(\"class\");\n    if (l) {\n      const w = l.split(\" \").map((k) => `${e}-${k}`).join(\" \");\n      u.setAttribute(\"class\", w), w.split(\" \").forEach((k) => {\n        const h = _[k];\n        h != null && h.fill && ![\"none\", \"transparent\"].includes(h.fill) && E.add(it(h.fill)), h != null && h.stroke && ![\"none\", \"transparent\"].includes(h.stroke) && E.add(it(h.stroke));\n      });\n    }\n    [\"fill\", \"stroke\", \"stop-color\"].forEach((w) => {\n      const k = u.getAttribute(w);\n      k && ![\"none\", \"transparent\"].includes(k) && E.add(it(k));\n    });\n    const S = u.getAttribute(\"style\");\n    if (S) {\n      const w = /fill\\s*:\\s*([^;]+);?/.exec(S), k = /stroke\\s*:\\s*([^;]+);?/.exec(S), h = /stop-color\\s*:\\s*([^;]+);?/.exec(S);\n      if (w) {\n        const y = w[1].trim();\n        y && ![\"none\", \"transparent\"].includes(y) && E.add(it(y));\n      }\n      if (k) {\n        const y = k[1].trim();\n        y && ![\"none\", \"transparent\"].includes(y) && E.add(it(y));\n      }\n      if (h) {\n        const y = h[1].trim();\n        y && ![\"none\", \"transparent\"].includes(y) && E.add(it(y));\n      }\n    }\n  }), E.forEach(\n    (u) => !a.includes(u) && Be(u) && a.push(u)\n  ), Array.from(d.querySelectorAll(\"*\")).forEach((u) => {\n    if (u.hasAttribute(\"id\")) {\n      const l = u.getAttribute(\"id\");\n      u.setAttribute(\"id\", `${e}-${l}`);\n    }\n    if ([\"fill\", \"stroke\", \"stop-color\", \"filter\", \"clip-path\", \"mask\"].forEach(\n      (l) => {\n        const S = u.getAttribute(l);\n        S && S.includes(\"url(#\") && u.setAttribute(\n          l,\n          S.replace(/url\\(#(.*?)\\)/g, `url(#${e}-$1)`)\n        );\n      }\n    ), u.hasAttribute(\"style\")) {\n      const l = u.getAttribute(\"style\");\n      l.includes(\"url(#\") && u.setAttribute(\n        \"style\",\n        l.replace(/url\\(#(.*?)\\)/g, `url(#${e}-$1)`)\n      );\n    }\n  }), Array.from(d.querySelectorAll(\"path\")).forEach((u) => {\n    if (dn(u)) return;\n    !fs(u) && !u.getAttribute(\"class\") && (u.setAttribute(\"fill\", \"#000000\"), a.includes(\"#000000\") || a.push(\"#000000\"));\n  }), { serializer: new XMLSerializer().serializeToString(d), colors: a };\n}\nconst wr = {\n  color: \"#000000\",\n  x: 0,\n  y: 0,\n  blur: 0\n}, ve = (t, e) => {\n  let r = e != null && e.trim ? e.trim.to - e.trim.from : (e == null ? void 0 : e.duration) || 5e3;\n  const s = {\n    from: 0,\n    to: r\n  };\n  if (!t)\n    return s;\n  if (t.from < 0)\n    return console.error(\n      \"'from' must be a non-negative number. Returning default display.\"\n    ), s;\n  if (t.from !== void 0 && t.to === void 0)\n    return {\n      from: t.from,\n      to: t.from + r\n    };\n  if (t.to !== void 0) {\n    if (t.to < 0)\n      return console.error(\n        \"'to' must be a non-negative number. Returning default display.\"\n      ), s;\n    if (t.to < t.from)\n      return console.error(\n        \"'to' must be greater than or equal to 'from'. Returning default display.\"\n      ), s;\n  }\n  return t;\n}, ps = (t, e) => t ? t.from && !t.to ? {\n  from: t.from,\n  to: e.duration\n} : t : {\n  from: 0,\n  to: e.duration\n};\nfunction te(t, e) {\n  const r = t.scaleMode, s = {\n    x: t.size.width / 2,\n    y: t.size.height / 2\n  }, a = { x: e.width / 2, y: e.height / 2 };\n  let c;\n  r === \"fill\" ? c = Math.max(\n    t.size.width / e.width,\n    t.size.height / e.height\n  ) : c = Math.min(\n    t.size.width / e.width,\n    t.size.height / e.height\n  );\n  const d = s.x - a.x;\n  return {\n    top: `${s.y - a.y}px`,\n    left: `${d}px`,\n    transform: `scale(${c})`\n  };\n}\nconst hs = async (t, e) => {\n  const r = t.details.src, s = await Ii(t), a = te(e, {\n    ...s\n  }), c = ps(t.trim, { duration: s.duration }), d = {\n    width: s.width,\n    height: s.height,\n    opacity: 100,\n    src: r,\n    volume: t.details.volume ?? 100,\n    // Default volume\n    borderRadius: t.details.borderRadius ?? 0,\n    // Default border radius\n    borderWidth: t.details.borderWidth ?? 0,\n    // Default border width\n    borderColor: t.details.borderColor || \"#000000\",\n    // Default border color\n    boxShadow: t.details.boxShadow || wr,\n    top: t.details.top || a.top || \"0px\",\n    // Default top\n    left: t.details.left || a.left || \"0px\",\n    // Default left\n    transform: t.details.transform || a.transform,\n    // Default transform\n    blur: t.details.blur || 0,\n    brightness: t.details.brightness || 100,\n    flipX: t.details.flipX || !1,\n    flipY: t.details.flipY || !1,\n    rotate: t.details.rotate || \"0deg\",\n    visibility: t.details.visibility || \"visible\"\n  };\n  return {\n    ...t,\n    trim: c,\n    type: \"video\",\n    name: \"video\",\n    details: d,\n    playbackRate: t.playbackRate || 1,\n    display: ve(t.display, { duration: s.duration, trim: c }),\n    duration: s.duration\n  };\n}, ms = async (t) => {\n  const e = t.id, r = t.details, a = (await ls(r.src)).duration, c = ps(t.trim, { duration: a });\n  return {\n    id: e,\n    name: t.name || \"audio\",\n    type: \"audio\",\n    display: ve(t.display, { duration: a, trim: c }),\n    trim: c,\n    playbackRate: t.playbackRate || 1,\n    details: {\n      src: r.src,\n      volume: r.volume ?? 100\n      // Default volume\n    },\n    metadata: { ...t.metadata },\n    duration: a\n  };\n}, ys = async (t, e) => {\n  var E;\n  const r = t.trackItemIds, s = t.size || {\n    width: t.details.width,\n    height: t.details.height\n  }, a = Math.min(\n    e.size.width / s.width,\n    e.size.height / s.height\n  ), c = ((E = t.details) == null ? void 0 : E.rotate) || 0, d = te(e, s), f = t.display;\n  let b = 1 / 0, _ = 0;\n  r.forEach((m) => {\n    const T = t.trackItemsMap[m];\n    T.display.from < b && (b = T.display.from), T.display.to > _ && (_ = T.display.to);\n  });\n  const M = t.trim || t.display || { from: b, to: _ };\n  return {\n    id: t.id,\n    type: \"template\",\n    details: {\n      ...s,\n      top: t.details.top || d.top,\n      left: t.details.left || d.left,\n      scale: a,\n      rotate: c\n    },\n    trim: M,\n    display: f || { from: b, to: _ },\n    activeEdit: !1\n  };\n}, Si = async (t, e) => {\n  var M;\n  const r = t.trackItemIds, s = t.size || {\n    width: t.details.width,\n    height: t.details.height\n  }, a = Math.min(\n    e.size.width / s.width,\n    e.size.height / s.height\n  ), c = ((M = t.details) == null ? void 0 : M.rotate) || 0, d = te(e, s), f = t.display;\n  let b = 1 / 0, _ = 0;\n  return r.forEach((E) => {\n    const m = t.trackItemsMap[E];\n    m.display.from < b && (b = m.display.from), m.display.to > _ && (_ = m.display.to);\n  }), {\n    id: t.id,\n    type: \"composition\",\n    details: {\n      ...s,\n      top: t.details.top || d.top,\n      left: t.details.left || d.left,\n      scale: a,\n      rotate: c\n    },\n    display: f || { from: b, to: _ }\n  };\n}, Gn = async (t, e) => {\n  const r = t.details, s = Oe(r.src), a = fetch(r.src), [c, d] = await Promise.all([\n    s,\n    a\n  ]), f = await d.text(), b = te(e, c), { serializer: _, colors: M } = ki(\n    vi(f),\n    t.id,\n    parseFloat(r.width || c.width),\n    parseFloat(r.height || c.height)\n  ), E = t.details.colorMap || Object.fromEntries(M.map((m) => [m, m]));\n  return {\n    id: t.id,\n    name: \"illustration\",\n    type: t.type,\n    display: ve(t.display),\n    playbackRate: t.playbackRate || 1,\n    details: {\n      src: r.src || \"\",\n      // Default source URL\n      width: r.width || c.width || 100,\n      // Default width\n      height: r.height || c.height || 100,\n      // Default height\n      opacity: r.opacity ?? 100,\n      // Default opacity\n      transform: r.transform || b.transform,\n      // Default transform\n      border: r.border || \"none\",\n      // Default border\n      borderRadius: r.borderRadius || 0,\n      // Default border radius\n      top: r.top || b.top || \"0px\",\n      // Default top\n      left: r.left || b.left || \"0px\",\n      // Default left\n      borderWidth: r.borderWidth ?? 0,\n      // Default border width\n      borderColor: r.borderColor || \"#000000\",\n      // Default border color\n      flipX: r.flipX || !1,\n      flipY: r.flipY || !1,\n      rotate: r.rotate || \"0deg\",\n      visibility: r.visibility || \"visible\",\n      svgString: _,\n      initialSvgString: K(_),\n      colorMap: E\n    },\n    metadata: t.metadata || {}\n  };\n}, wi = async (t, e) => {\n  const r = t.details, s = Oe(r.src), [a] = await Promise.all([s]), c = te(e, a);\n  return {\n    id: t.id,\n    name: \"shape\",\n    type: t.type,\n    display: ve(t.display),\n    playbackRate: t.playbackRate || 1,\n    details: {\n      src: r.src || \"\",\n      // Default source URL\n      width: r.width || a.width || 100,\n      // Default width\n      height: r.height || a.height || 100,\n      // Default height\n      opacity: r.opacity ?? 100,\n      // Default opacity\n      transform: r.transform || c.transform,\n      // Default transform\n      border: r.border || \"none\",\n      // Default border\n      borderRadius: r.borderRadius || 0,\n      // Default border radius\n      top: r.top || c.top || \"0px\",\n      // Default top\n      left: r.left || c.left || \"0px\",\n      // Default left\n      borderWidth: r.borderWidth ?? 0,\n      // Default border width\n      borderColor: r.borderColor || \"#000000\",\n      // Default border color\n      flipX: r.flipX || !1,\n      flipY: r.flipY || !1,\n      rotate: r.rotate || \"0deg\",\n      visibility: r.visibility || \"visible\",\n      backgroundColor: r.backgroundColor || \"#808080\"\n    },\n    metadata: t.metadata || {}\n  };\n}, gs = async (t, e) => {\n  const r = t.details, s = await Oe(r.src), a = te(e, s);\n  return {\n    id: t.id,\n    type: \"image\",\n    name: \"image\",\n    display: ve(t.display),\n    playbackRate: t.playbackRate || 1,\n    details: {\n      src: r.src || \"\",\n      // Default source URL\n      width: r.width || s.width || 100,\n      // Default width\n      height: r.height || s.height || 100,\n      // Default height\n      opacity: r.opacity ?? 100,\n      // Default opacity\n      transform: r.transform || a.transform,\n      // Default transform\n      border: r.border || \"none\",\n      // Default border\n      borderRadius: r.borderRadius || 0,\n      // Default border radius\n      boxShadow: r.boxShadow || wr,\n      // Default box shadow\n      top: r.top || a.top || \"0px\",\n      // Default top\n      left: r.left || a.left || \"0px\",\n      // Default left\n      borderWidth: r.borderWidth ?? 0,\n      // Default border width\n      borderColor: r.borderColor || \"#000000\",\n      // Default border color\n      blur: r.blur || 0,\n      brightness: r.brightness || 100,\n      flipX: r.flipX || !1,\n      flipY: r.flipY || !1,\n      rotate: r.rotate || \"0deg\",\n      visibility: r.visibility || \"visible\"\n    },\n    metadata: t.metadata || {}\n  };\n}, Is = async (t, e) => {\n  const r = t;\n  r.details.fontUrl && await br([\n    {\n      fontFamily: r.details.fontFamily,\n      url: r.details.fontUrl\n    }\n  ]);\n  const s = r.id, a = r.details, c = vs(a), d = ds(r.details.text, c), f = te(e, {\n    width: c.width,\n    height: d\n  });\n  return {\n    id: s,\n    name: \"caption\",\n    type: \"caption\",\n    display: ve(r.display),\n    details: {\n      ...c,\n      text: a.text || \"\",\n      // Default text content\n      height: d,\n      // Default height\n      fontUrl: a.fontUrl,\n      top: c.top || f.top,\n      left: c.left || f.left,\n      borderWidth: a.borderWidth || 0,\n      borderColor: a.borderColor || \"#000000\",\n      boxShadow: a.boxShadow || wr,\n      words: a.words || [],\n      appearedColor: a.appearedColor || a.color,\n      activeColor: a.activeColor || a.color,\n      activeFillColor: a.activeFillColor || \"transparent\"\n    },\n    metadata: t.metadata || {}\n  };\n}, bs = async (t, e) => {\n  t.details.fontUrl && await br([\n    {\n      fontFamily: t.details.fontFamily,\n      url: t.details.fontUrl\n    }\n  ]);\n  const r = t.id, s = t.details, a = vs(s), c = ds(t.details.text, a), d = te(e, {\n    width: a.width,\n    height: c\n  });\n  return {\n    id: r,\n    name: \"text\",\n    type: \"text\",\n    display: ve(t.display),\n    details: {\n      ...a,\n      text: s.text || \"\",\n      // Default text content\n      height: c,\n      // Default height\n      fontUrl: s.fontUrl,\n      top: a.top || d.top,\n      left: a.left || d.left,\n      borderWidth: s.borderWidth || 0,\n      borderColor: s.borderColor || \"#000000\",\n      boxShadow: s.boxShadow || wr\n    },\n    metadata: {}\n  };\n}, vs = (t) => ({\n  fontFamily: t.fontFamily || \"Arial\",\n  // Default font family\n  fontSize: t.fontSize || \"16px\",\n  // Default font size\n  fontWeight: t.fontWeight || \"normal\",\n  // Default font weight\n  fontStyle: t.fontStyle || \"normal\",\n  // Default font style\n  textDecoration: t.textDecoration || \"none\",\n  // Default text decoration\n  textAlign: t.textAlign || \"left\",\n  // Default text alignment\n  lineHeight: t.lineHeight || \"normal\",\n  // Default line height\n  letterSpacing: t.letterSpacing || \"normal\",\n  // Default letter spacing\n  wordSpacing: t.wordSpacing || \"normal\",\n  // Default word spacing\n  color: t.color || \"#ffffff\",\n  // Default text color (black)\n  backgroundColor: t.backgroundColor || \"transparent\",\n  // Default background color\n  border: t.border || \"none\",\n  // Default border\n  textShadow: t.textShadow || \"none\",\n  // Default text shadow\n  text: t.text || \"\",\n  // Default text content\n  opacity: t.opacity ?? 100,\n  // Default opacity\n  width: t.width || 300,\n  wordWrap: t.wordWrap || \"normal\",\n  //'break-word'\n  wordBreak: t.wordBreak || \"normal\",\n  //'break-all',\n  WebkitTextStrokeColor: t.WebkitTextStrokeColor || \"#ffffff\",\n  WebkitTextStrokeWidth: t.WebkitTextStrokeWidth || \"0px\",\n  top: t.top,\n  left: t.left,\n  textTransform: t.textTransform || \"none\",\n  transform: t.transform || \"none\",\n  skewX: t.skewX || 0,\n  skewY: t.skewY || 0\n}), Mi = async (t, e) => {\n  switch (t.type) {\n    case \"video\":\n      return hs(t, e || {});\n    case \"audio\":\n      return ms(t);\n    case \"image\":\n      return gs(t, e || {});\n    case \"text\":\n      return bs(t, e || {});\n    case \"caption\":\n      return Is(t, e || {});\n    case \"template\":\n      return ys(t, {\n        size: e == null ? void 0 : e.size\n      });\n    default:\n      throw new Error(\"Unsupported track item\");\n  }\n};\nfunction Ei(t, e) {\n  return e.some(\n    (r) => t.some((s) => s.id === r.id)\n  );\n}\nconst Ti = (t = [], e = []) => t.length === 0 ? e.map((s) => ({\n  id: De(),\n  items: [s.id],\n  type: s.type,\n  accepts: [\"text\", \"image\", \"video\", \"audio\", \"caption\", \"template\"]\n})) : t.map((r) => ({\n  ...r,\n  items: r.items || [],\n  accepts: [\"audio\", \"video\", \"image\", \"text\", \"caption\", \"template\"],\n  type: r.type || \"text\",\n  magnetic: r.magnetic || !1,\n  static: r.static || !1,\n  id: r.id || De()\n}));\nfunction Ai(t, e) {\n  return t.filter((s) => {\n    if (e.forEach((a) => {\n      s.items.includes(a) && (s.items = s.items.filter((c) => c !== a));\n    }), s.items.length !== 0 || s.static)\n      return s;\n  });\n}\nconst he = (t) => Object.keys(t).reduce((e, r) => {\n  const { display: s, playbackRate: a } = t[r];\n  return Math.max(e, s.to / (a || 1));\n}, 0);\nfunction kn(t, e, r) {\n  return Math.min(Math.max(t, e), r);\n}\nconst xi = (t, e, r, s, a) => {\n  if (s === void 0 && a === void 0)\n    return { trackId: void 0, trackIndex: void 0 };\n  const c = a !== void 0 ? e[kn(a, 0, e.length)] : e.find((b) => b.id === s);\n  if (!c)\n    return {\n      trackId: void 0,\n      trackIndex: a !== void 0 ? kn(a, 0, e.length) : void 0\n    };\n  const d = c.items.map((b) => r[b]), f = t.map((b) => r[b]);\n  for (const b of d) {\n    const _ = b.display.from, M = b.display.to;\n    for (const E of f) {\n      const m = E.display.from;\n      if (!(E.display.to <= _ || m >= M))\n        return {\n          trackId: void 0,\n          trackIndex: e.indexOf(c)\n        };\n    }\n  }\n  return {\n    trackId: c.id,\n    trackIndex: e.indexOf(c)\n  };\n}, Yn = (t, e) => {\n  var f, b;\n  const r = ((f = t.details.crop) == null ? void 0 : f.width) || t.details.width || 0, s = ((b = t.details.crop) == null ? void 0 : b.height) || t.details.height || 0;\n  let a = e.width, c = e.height;\n  const d = e.width / e.height;\n  return r / s > d ? (a = r, c = r / d) : (c = s, a = s * d), {\n    newWidth: a,\n    newHeight: c,\n    crop: {\n      x: 0,\n      y: 0,\n      height: s,\n      width: r\n    }\n  };\n}, Bn = (t, e) => {\n  const r = K(t.trim), s = K(t.display);\n  return e.duration < t.display.to && (s.to = e.duration, r && (r.to = e.duration)), {\n    duration: e.duration,\n    trim: r,\n    display: s\n  };\n}, Di = (t) => {\n  const { trackItemIds: e, transitionsMap: r, trackItemsMap: s } = t, a = /* @__PURE__ */ new Map();\n  Object.values(r).forEach((_) => {\n    var T, C;\n    const { fromId: M, toId: E, kind: m } = _;\n    m !== \"none\" && (a.has(M) || a.set(M, []), a.has(E) || a.set(E, []), (T = a.get(M)) == null || T.push(_), (C = a.get(E)) == null || C.push(_));\n  });\n  const c = [], d = /* @__PURE__ */ new Set(), f = (_) => {\n    const M = [];\n    let E = _;\n    for (; E && !d.has(E); ) {\n      d.add(E);\n      const m = s[E];\n      M.push(m);\n      const T = Object.values(r).find(\n        (C) => C.fromId === E && C.kind !== \"none\"\n        // Filter here\n      );\n      if (!T) break;\n      M.push(T), E = T.toId;\n    }\n    return M;\n  }, b = Object.values(r).filter(\n    (_) => _.kind !== \"none\"\n  );\n  for (const _ of e)\n    if (!d.has(_) && (!a.has(_) || !b.some((M) => M.toId === _))) {\n      const M = f(_);\n      M.length > 0 && c.push(M);\n    }\n  return c.forEach((_) => {\n    _.sort((M, E) => \"display\" in M && \"display\" in E ? M.display.from - E.display.from : 0);\n  }), c.filter((_) => _.filter((E) => E !== void 0).length > 0);\n};\nfunction Xn(t, e, r) {\n  t.forEach((s) => {\n    const d = Object.values(e).filter(\n      (_) => s.items.includes(_.id)\n    ).sort(\n      (_, M) => _.display.from - M.display.from\n    ).map((_) => _.id), f = Di({\n      trackItemIds: d,\n      transitionsMap: r,\n      trackItemsMap: e\n    });\n    let b = 0;\n    d.forEach((_) => {\n      const M = [];\n      for (const m of f)\n        if (m.find((T) => T.id === _)) {\n          const T = f.findIndex(\n            (C) => C.find((u) => u.id === _)\n          );\n          if (T - 1 >= 0)\n            for (let C = T - 1; C >= 0; C--) {\n              const u = f[C];\n              M.push(u);\n            }\n        }\n      let E = 0;\n      if (M.forEach((m) => {\n        m.forEach((T) => {\n          T.type === \"transition\" && (E += T.duration);\n        });\n      }), e[_]) {\n        const m = e[_].display.to - e[_].display.from;\n        e[_].display = {\n          from: b - E,\n          to: b + m - E\n        }, b += m;\n      }\n    });\n  });\n}\nfunction Oi(t, e) {\n  let s = e.reduce(\n    (a, c) => c.display.to > a.display.to ? c : a,\n    { display: { to: 0 } }\n  ).display.to;\n  t.forEach((a) => {\n    const c = a.display.from, f = a.display.to - c;\n    a.display.from = s, a.display.to = a.display.from + f, s = a.display.to;\n  });\n}\nfunction Ci(t) {\n  const e = t, r = e.tracks, s = e.trackItemsMap, a = [], c = {}, d = e.structure;\n  return r.forEach((f) => {\n    var _;\n    const b = f.items.map((M) => s[M]).sort((M, E) => M.display.from - E.display.from);\n    for (let M = 0; M < b.length - 1; M++) {\n      const E = b[M], m = b[M + 1];\n      if (Math.abs(E.display.to - m.display.from) <= 1) {\n        const T = `${E.id}-${m.id}`;\n        if ((_ = e.transitionIds) == null ? void 0 : _.includes(T))\n          c[T] = e.transitionsMap[T];\n        else {\n          const u = {\n            id: T,\n            duration: 1500,\n            fromId: E.id,\n            toId: m.id,\n            kind: \"none\",\n            trackId: f.id,\n            type: \"transition\"\n          };\n          c[T] = u;\n        }\n        a.push(T);\n      }\n    }\n  }), d.forEach((f) => {\n    f.transitions.forEach((b) => {\n      c[b] = {\n        ...e.transitionsMap[b],\n        trackId: f.id\n      };\n    });\n  }), e.transitionIds = a, e.transitionsMap = c, {\n    transitionIds: a,\n    transitionsMap: c\n  };\n}\nfunction Pi(t, e, r) {\n  const s = t.toId, a = r[s], c = e.find((d) => d.items.includes(s));\n  c && (c.magnetic || c.items.forEach((d) => {\n    const f = r[d];\n    f.display.from > a.display.from && (f.display.from = f.display.from + t.duration, f.display.to = f.display.to + t.duration);\n  }));\n}\nfunction Ri(t) {\n  const e = _designcombo_events__WEBPACK_IMPORTED_MODULE_0__.subject.pipe(\n    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.filter)(({ key: u }) => u.startsWith(Dn))\n  ), r = _designcombo_events__WEBPACK_IMPORTED_MODULE_0__.subject.pipe(\n    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.filter)(({ key: u }) => u.startsWith(gt))\n  ), s = _designcombo_events__WEBPACK_IMPORTED_MODULE_0__.subject.pipe(\n    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.filter)(({ key: u }) => u.startsWith(pt))\n  ), a = _designcombo_events__WEBPACK_IMPORTED_MODULE_0__.subject.pipe(\n    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.filter)(({ key: u }) => u.startsWith(Sr))\n  ), c = _designcombo_events__WEBPACK_IMPORTED_MODULE_0__.subject.pipe(\n    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.filter)(({ key: u }) => u.startsWith(Ce))\n  ), d = _designcombo_events__WEBPACK_IMPORTED_MODULE_0__.subject.pipe(\n    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.filter)(({ key: u }) => u.startsWith(be))\n  ), f = _designcombo_events__WEBPACK_IMPORTED_MODULE_0__.subject.pipe(\n    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.filter)(({ key: u }) => u.startsWith(us))\n  ), b = e.subscribe(async (u) => {\n    var l, S;\n    if (u.key === Xs) {\n      const w = (l = u.value) == null ? void 0 : l.payload, k = w.trackItemsMap, h = w.trackItemDetailsMap;\n      console.warn(\"IMPROVE FONTS LOADING\");\n      for (const v in h)\n        if (h[v].type === \"text\" || h[v].type === \"caption\") {\n          const I = h[v].details;\n          await br([\n            {\n              fontFamily: I.fontFamily,\n              url: I.fontUrl\n            }\n          ]);\n        } else if (h[v].type === \"illustration\") {\n          const I = k[v], x = h[v].details, g = await Gn(\n            { ...I, details: x },\n            {\n              size: { width: x.width, height: x.height }\n            }\n          ), O = Wn(\n            g.details.svgString,\n            x.colorMap\n          );\n          g.details.svgString = O, h[v].details = g.details, k[v] = g;\n        }\n      const y = he(k);\n      t.updateState(\n        {\n          ...w,\n          duration: y\n        },\n        {\n          kind: \"design:load\",\n          updateHistory: !1\n        }\n      );\n    }\n    if (u.key === Ks) {\n      const w = (S = u.value) == null ? void 0 : S.payload;\n      t.updateState(\n        {\n          size: w\n        },\n        {\n          kind: \"design:resize\",\n          updateHistory: !1\n        }\n      );\n    }\n  }), _ = a.subscribe((u) => {\n    if (u.key === hi) return t.undo();\n    if (u.key === mi) return t.redo();\n  }), M = f.subscribe((u) => {\n    var l;\n    if (u.key === yi) {\n      const S = (l = u.value) == null ? void 0 : l.payload.scale;\n      t.updateState(\n        {\n          scale: S\n        },\n        {\n          kind: \"update\",\n          updateHistory: !1\n        }\n      );\n    }\n  }), E = s.subscribe(async (u) => {\n    var S, w, k, h, y;\n    const l = [];\n    if ((S = u.value) != null && S.payload.trackItemIds && (l.push((w = u.value) == null ? void 0 : w.payload.trackItemIds), t.updateState(\n      { activeIds: l },\n      {\n        kind: \"update\",\n        updateHistory: !1\n      }\n    )), u.key === fi) {\n      const v = (k = u.value) == null ? void 0 : k.payload.trackItemIds, I = K(t.getState()), x = v && v.length ? v : I.activeIds, g = x.map((A) => I.trackItemsMap[A]).filter((A) => !!A).map((A) => A.id), O = I.transitionIds.filter(\n        (A) => {\n          const et = I.transitionsMap[A];\n          return g.includes(et.fromId) || g.includes(et.toId);\n        }\n      );\n      g.push(...O);\n      const D = {}, j = I.trackItemIds, L = I.transitionIds, R = I.trackItemDetailsMap, F = K(I.tracks), V = K(I.structure);\n      g.forEach((A) => {\n        var Mt;\n        const et = I.trackItemsMap[A] || I.transitionsMap[A];\n        if (et.type === \"template\") {\n          const ot = (Mt = I.structure.find(\n            (Et) => Et.id === et.id\n          )) == null ? void 0 : Mt.items;\n          g.push(...ot);\n          const $t = V.findIndex(\n            (Et) => Et.id === et.id\n          );\n          V.splice($t, 1);\n        }\n      }), g.forEach((A) => {\n        V.forEach((et) => {\n          et.items.includes(A) && (et.items = et.items.filter((Mt) => Mt !== A));\n        });\n      });\n      const kt = j.filter(\n        (A) => !g.includes(A)\n      );\n      L.forEach((A) => {\n        x.includes(A) && x.length === 1 && (D[A] = K(I.transitionsMap[A]));\n      });\n      const Dt = L.filter(\n        (A) => !g.includes(A) && !x.includes(A)\n      ), Ot = Object.fromEntries(\n        Object.entries(R).filter(\n          ([A]) => !g.includes(A)\n        )\n      ), U = Object.fromEntries(\n        Object.entries(I.transitionsMap).filter(\n          ([A]) => !g.includes(A)\n        )\n      );\n      Object.keys(U).forEach((A) => {\n        x.includes(A) && (U[A].kind = \"none\");\n      });\n      const zt = Ai(\n        I.tracks,\n        g\n      ), wt = Object.fromEntries(\n        Object.entries(I.trackItemsMap).filter(\n          ([A]) => !g.includes(A)\n        )\n      ), at = F.filter((A) => A.magnetic);\n      Xn(\n        at,\n        wt,\n        I.transitionsMap\n      );\n      const Ft = he(wt);\n      Object.keys(D).forEach((A) => {\n        Pi(\n          D[A],\n          zt,\n          wt\n        );\n      }), t.updateState(\n        {\n          trackItemIds: kt,\n          trackItemDetailsMap: Ot,\n          activeIds: [],\n          trackItemsMap: wt,\n          tracks: zt,\n          duration: Ft,\n          structure: V,\n          transitionIds: Dt,\n          transitionsMap: U\n        },\n        { updateHistory: !0, kind: \"remove\" }\n      );\n    }\n    if (u.key === di) {\n      const v = K(t.getState()), I = {}, x = ((h = u.value) == null ? void 0 : h.payload.trackItemIds) || v.activeIds;\n      if (x.length === 0) return;\n      x.forEach((O) => {\n        const D = v.trackItemsMap[O], j = v.trackItemDetailsMap[O], L = De();\n        v.trackItemsMap[L] = {\n          ...K(D),\n          id: L\n        }, v.trackItemDetailsMap[L] = {\n          ...K(j)\n        }, v.trackItemIds.push(L);\n        const R = v.tracks.find(\n          (F) => F.items.includes(O)\n        );\n        I[R.id] ? I[R.id].items.push(L) : I[R.id] = {\n          ...R,\n          id: De(),\n          items: [L],\n          static: !1,\n          magnetic: !1\n        };\n      });\n      const g = Object.values(I);\n      v.tracks = [...g, ...v.tracks], t.updateState(\n        {\n          trackItemDetailsMap: v.trackItemDetailsMap,\n          tracks: v.tracks,\n          trackItemIds: v.trackItemIds,\n          trackItemsMap: v.trackItemsMap\n        },\n        {\n          updateHistory: !0,\n          kind: \"update\"\n        }\n      );\n    }\n    if (u.key === pi) {\n      const v = (y = u.value) == null ? void 0 : y.payload, I = Object.keys(v)[0], x = Object.values(v)[0], g = K(t.getState()), O = g.trackItemDetailsMap[I], D = K(g.trackItemsMap[I]), j = O.details;\n      if (!x.details.src) return;\n      if (O.type === \"image\") {\n        const L = await Oe(x.details.src), { crop: R, newHeight: F, newWidth: V } = Yn(\n          O,\n          L\n        );\n        x.details.crop = R, x.details.height = F, x.details.width = V;\n      } else if (O.type === \"video\") {\n        const L = await _n(x.details.src), R = g.trackItemsMap[I], { display: F, duration: V, trim: kt } = Bn(R, L), { crop: Dt, newHeight: Ot, newWidth: U } = Yn(\n          O,\n          L\n        );\n        x.details.crop = Dt, x.details.height = Ot, x.details.width = U, D.display = F, D.duration = V, D.trim = kt;\n      } else if (O.type === \"audio\") {\n        const L = await ls(x.details.src), R = g.trackItemsMap[I], { display: F, duration: V, trim: kt } = Bn(R, L);\n        D.display = F, D.duration = V, D.trim = kt;\n      }\n      O.details = { ...j, ...x.details }, g.trackItemDetailsMap[I] = { ...O }, g.trackItemsMap[I] = { ...D }, t.updateState(\n        {\n          trackItemDetailsMap: g.trackItemDetailsMap,\n          trackItemsMap: g.trackItemsMap\n        },\n        {\n          updateHistory: !0,\n          kind: \"update:details\"\n        }\n      );\n    }\n  }), m = r.subscribe(async (u) => {\n    var g, O, D, j, L, R, F, V, kt, Dt, Ot, U, zt, wt, at, Ft, A, et, Mt, ot, $t, Et, Gt, Yt, ee, Bt, re, Xt, ne, _e, ke, Nt, Kt;\n    const l = K(t.getState()), S = ((O = (g = u.value) == null ? void 0 : g.options) == null ? void 0 : O.isSelected) || !1, w = (j = (D = u.value) == null ? void 0 : D.options) == null ? void 0 : j.scaleMode, k = (R = (L = u.value) == null ? void 0 : L.options) == null ? void 0 : R.isNewTrack;\n    let h = [], y = \"text\";\n    const v = (V = (F = u.value) == null ? void 0 : F.options) == null ? void 0 : V.trackId;\n    let I = (Dt = (kt = u.value) == null ? void 0 : kt.options) == null ? void 0 : Dt.trackIndex;\n    if (u.key === ei) {\n      const $ = (Ot = u.value) == null ? void 0 : Ot.payload;\n      let H = l.trackItemsMap[$.id].animations;\n      H ? H.in && $.animations.in ? H.in = $.animations.in : H.out && $.animations.out || !H.out && $.animations.out ? H.out = $.animations.out : !H.in && $.animations.in ? H.in = $.animations.in : H = $.animations : l.trackItemsMap[$.id].animations = $.animations;\n    }\n    if (u.key === si) {\n      const $ = (U = u.value) == null ? void 0 : U.payload, H = $.trackItems.map(\n        (Y) => Mi(Y, {\n          size: l.size\n        })\n      ), z = await Promise.all(H), rt = Ti($.tracks, $.trackItems), ct = [];\n      $.trackItems.forEach((Y) => {\n        if (Y.type !== \"template\") return;\n        l.trackItemsMap = {\n          ...l.trackItemsMap,\n          ...Y.trackItemsMap\n        }, l.trackItemDetailsMap = {\n          ...l.trackItemDetailsMap,\n          ...Y.trackItemDetailsMap\n        }, l.transitionsMap = {\n          ...l.transitionsMap,\n          ...Y.transitionsMap\n        };\n        const mt = {\n          id: Y.id,\n          items: Y.trackItemIds,\n          transitions: Y.transitionsIds || [],\n          tracks: Y.tracks\n        };\n        ct.push(mt);\n      });\n      const B = [], ut = {}, q = {};\n      if (z.forEach((Y) => {\n        const { details: mt, ...Vt } = Y;\n        B.push(Y.id), ut[Y.id] = {\n          type: Y.type,\n          details: mt\n        }, q[Y.id] = Vt;\n      }), Ei(\n        l.tracks,\n        rt\n      ))\n        l.tracks.forEach((Y) => {\n          rt.forEach((mt) => {\n            if (Y.id === mt.id) {\n              if (Y.magnetic) {\n                const Vt = mt.items.map((Tt) => q[Tt]), qt = Y.items.map(\n                  (Tt) => l.trackItemsMap[Tt]\n                );\n                Oi(\n                  Vt,\n                  qt\n                );\n              }\n              Y.items.push(...B);\n            }\n          });\n        });\n      else {\n        const Y = ((wt = (zt = u.value) == null ? void 0 : zt.options) == null ? void 0 : wt.trackIndex) || 0, mt = kn(\n          Y,\n          0,\n          l.tracks.length\n        );\n        l.tracks.splice(mt, 0, ...rt);\n      }\n      l.trackItemDetailsMap = {\n        ...l.trackItemDetailsMap,\n        ...ut\n      }, l.trackItemsMap = {\n        ...l.trackItemsMap,\n        ...q\n      }, l.trackItemIds = [\n        ...l.trackItemIds,\n        ...B\n      ], l.structure = [...l.structure, ...ct], l.duration = he(l.trackItemsMap);\n      const { transitionIds: Se, transitionsMap: se } = Ci(\n        l\n      ), Pe = l.tracks.filter((Y) => Y.magnetic);\n      Xn(\n        Pe,\n        l.trackItemsMap,\n        se\n      ), t.updateState(\n        {\n          trackItemIds: l.trackItemIds,\n          trackItemDetailsMap: l.trackItemDetailsMap,\n          trackItemsMap: l.trackItemsMap,\n          tracks: l.tracks,\n          duration: l.duration,\n          structure: l.structure,\n          transitionIds: Se,\n          transitionsMap: se\n        },\n        {\n          updateHistory: !0,\n          kind: \"add\"\n        }\n      );\n      return;\n    }\n    if (u.key === ri) {\n      y = \"caption\";\n      const $ = (at = u.value) == null ? void 0 : at.payload, H = [];\n      for (const ct of $) {\n        const B = Is(ct, {\n          size: l.size\n        });\n        H.push(B);\n      }\n      const z = await Promise.all(H), rt = [];\n      for (const ct of z) {\n        const B = ct.id;\n        rt.push(B);\n        const { details: ut, ...q } = ct;\n        l.trackItemDetailsMap[B] = {\n          type: y,\n          details: ut\n        }, l.trackItemsMap[B] = q, l.trackItemIds.push(B);\n      }\n      h = rt;\n    }\n    if (u.key === Vs) {\n      y = \"text\";\n      const $ = await bs((Ft = u.value) == null ? void 0 : Ft.payload, {\n        size: l.size\n      }), { details: H, ...z } = $;\n      l.trackItemDetailsMap[z.id] = {\n        type: y,\n        details: H\n      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];\n    }\n    if (u.key === ni) {\n      y = \"template\";\n      const $ = (A = u.value) == null ? void 0 : A.payload.trackItemsMap, H = (et = u.value) == null ? void 0 : et.payload.trackItemDetailsMap, z = (Mt = u.value) == null ? void 0 : Mt.payload.transitionsMap, rt = ((ot = u.value) == null ? void 0 : ot.payload.transitionIds) || [], ct = ($t = u.value) == null ? void 0 : $t.payload.trackItemIds, B = ((Et = u.value) == null ? void 0 : Et.payload.tracks) || [], { details: ut, ...q } = await ys((Gt = u.value) == null ? void 0 : Gt.payload, {\n        size: l.size\n      }), ht = {\n        id: q.id,\n        items: ct,\n        transitions: rt,\n        tracks: B\n      };\n      l.trackItemDetailsMap[q.id] = {\n        type: y,\n        details: ut\n      }, l.trackItemsMap[q.id] = q, l.trackItemIds.push(q.id), h = [q.id], l.trackItemsMap = {\n        ...l.trackItemsMap,\n        ...$,\n        [q.id]: {\n          ...q\n        }\n      }, l.trackItemDetailsMap = {\n        ...l.trackItemDetailsMap,\n        ...H,\n        [q.id]: {\n          type: \"template\",\n          details: ut\n        }\n      }, l.transitionsMap = {\n        ...l.transitionsMap,\n        ...z\n      }, l.structure = [...l.structure, ht];\n    }\n    if (u.key === Qs) {\n      y = \"illustration\";\n      const $ = await Gn((Yt = u.value) == null ? void 0 : Yt.payload, {\n        size: l.size\n      }), { details: H, ...z } = $;\n      l.trackItemDetailsMap[z.id] = {\n        type: y,\n        details: H\n      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];\n    }\n    if (u.key === ti) {\n      y = \"shape\";\n      const $ = await wi((ee = u.value) == null ? void 0 : ee.payload, {\n        size: l.size\n      }), { details: H, ...z } = $;\n      l.trackItemDetailsMap[z.id] = {\n        type: y,\n        details: H\n      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];\n    }\n    if (u.key === Zs) {\n      y = \"image\";\n      const $ = await gs((Bt = u.value) == null ? void 0 : Bt.payload, {\n        size: l.size,\n        scaleMode: w\n      }), { details: H, ...z } = $;\n      l.trackItemDetailsMap[z.id] = {\n        type: y,\n        details: H\n      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];\n    }\n    if (u.key === Js) {\n      y = \"audio\";\n      const $ = await ms((re = u.value) == null ? void 0 : re.payload), { details: H, ...z } = $;\n      l.trackItemDetailsMap[z.id] = {\n        type: y,\n        details: H\n      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];\n    }\n    if (u.key === qs) {\n      y = \"video\";\n      const $ = await hs((Xt = u.value) == null ? void 0 : Xt.payload, {\n        size: l.size,\n        scaleMode: w\n      }), { details: H, ...z } = $;\n      l.trackItemDetailsMap[z.id] = {\n        type: y,\n        details: H,\n        metadata: z.metadata\n      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];\n    }\n    if (u.key === ii) {\n      y = \"composition\";\n      const $ = (ne = u.value) == null ? void 0 : ne.payload.trackItemsMap, H = (_e = u.value) == null ? void 0 : _e.payload.trackItemDetailsMap, z = (ke = u.value) == null ? void 0 : ke.payload.trackItemIds, rt = ((Nt = u.value) == null ? void 0 : Nt.payload.tracks) || [], { details: ct, ...B } = await Si(\n        (Kt = u.value) == null ? void 0 : Kt.payload,\n        {\n          size: l.size\n        }\n      ), ut = {\n        id: B.id,\n        items: z,\n        transitions: [],\n        tracks: rt\n      };\n      l.trackItemDetailsMap[B.id] = {\n        type: y,\n        details: ct\n      }, l.trackItemsMap[B.id] = B, l.trackItemIds.push(B.id), h = [B.id], l.trackItemsMap = {\n        ...l.trackItemsMap,\n        ...$,\n        [B.id]: {\n          ...B\n        }\n      }, l.trackItemDetailsMap = {\n        ...l.trackItemDetailsMap,\n        ...H,\n        [B.id]: {\n          type: y,\n          details: ct\n        }\n      }, l.structure = [...l.structure, ut];\n    }\n    const x = xi(\n      h,\n      l.tracks,\n      l.trackItemsMap,\n      v,\n      I\n    );\n    if (k) {\n      const $ = Xe();\n      x.trackId = $;\n      const H = {\n        id: x.trackId,\n        accepts: [\n          \"text\",\n          \"audio\",\n          \"helper\",\n          \"video\",\n          \"image\",\n          \"caption\",\n          \"template\"\n        ],\n        type: y,\n        items: h,\n        magnetic: !1,\n        static: !1\n      };\n      l.tracks.splice(x.trackIndex, 0, H);\n    } else if (x.trackId) {\n      const $ = l.tracks.find(\n        (H) => H.id === x.trackId\n      );\n      $ && $.items.push(...h);\n    } else if (x.trackIndex !== void 0) {\n      const $ = {\n        id: Xe(),\n        accepts: [\n          \"text\",\n          \"audio\",\n          \"helper\",\n          \"video\",\n          \"image\",\n          \"caption\",\n          \"template\"\n        ],\n        type: y,\n        items: h,\n        magnetic: !1,\n        static: !1\n      };\n      l.tracks.splice(x.trackIndex, 0, $);\n    } else\n      l.tracks.unshift({\n        id: Xe(),\n        accepts: [\n          \"text\",\n          \"audio\",\n          \"helper\",\n          \"video\",\n          \"image\",\n          \"caption\",\n          \"template\"\n        ],\n        type: y,\n        items: h,\n        magnetic: !1,\n        static: !1\n      });\n    S && (l.activeIds = h), l.duration = he(l.trackItemsMap), t.updateState(\n      {\n        activeIds: l.activeIds,\n        trackItemIds: l.trackItemIds,\n        trackItemDetailsMap: l.trackItemDetailsMap,\n        trackItemsMap: l.trackItemsMap,\n        transitionsMap: l.transitionsMap,\n        tracks: l.tracks,\n        duration: l.duration,\n        structure: l.structure\n      },\n      {\n        updateHistory: !0,\n        kind: \"add\"\n      }\n    );\n  }), T = c.subscribe(async (u) => {\n    var l;\n    if (u.key === li) {\n      const S = K(t.getState()), w = (l = u.value) == null ? void 0 : l.options.time;\n      if (S.activeIds.length === 1) {\n        const k = S.activeIds[0], h = K(S.trackItemsMap[k]);\n        if (w >= h.display.to || w <= h.display.from)\n          return;\n        const y = K(S.trackItemDetailsMap[k]), v = De(), I = K({\n          ...h,\n          display: {\n            from: h.display.from,\n            to: w\n          }\n        }), x = K({\n          ...h,\n          id: v,\n          display: {\n            from: w,\n            to: h.display.to\n          }\n        });\n        if (h.type === \"video\" || h.type === \"audio\") {\n          const g = w - I.display.from;\n          I.trim = {\n            from: h.trim.from,\n            to: h.trim.from + g\n          }, x.trim = {\n            from: h.trim.from + g,\n            to: h.trim.to\n          };\n        }\n        S.trackItemsMap[k] = I, S.trackItemsMap[v] = x, S.trackItemIds.push(v), S.trackItemDetailsMap[v] = y, S.tracks.forEach((g) => {\n          g.items.includes(k) && g.items.push(v);\n        }), t.updateState(\n          {\n            trackItemDetailsMap: S.trackItemDetailsMap,\n            tracks: S.tracks,\n            trackItemIds: S.trackItemIds,\n            trackItemsMap: S.trackItemsMap\n          },\n          {\n            updateHistory: !0,\n            kind: \"update\"\n          }\n        );\n      }\n      return;\n    }\n    if (u.key === ui) {\n      const S = K(t.getState());\n      if (S.activeIds.length) {\n        const w = S.activeIds, k = [], h = {\n          activeIds: w,\n          trackItemDetailsMap: {},\n          trackItemsMap: {},\n          tracks: []\n        };\n        w.forEach((v) => {\n          h.trackItemDetailsMap[v] = S.trackItemDetailsMap[v], h.trackItemsMap[v] = S.trackItemsMap[v], k.push(\n            S.tracks.find((I) => I.items.includes(v))\n          );\n        });\n        const y = /* @__PURE__ */ new Set();\n        k.filter((v) => y.has(v.id) ? !1 : (y.add(v), !0)), h.tracks = Array.from(y.keys()), localStorage.setItem(\"DesignComboTemp\", JSON.stringify(h));\n      }\n    }\n    if (u.key === ci) {\n      const S = localStorage.getItem(\"DesignComboTemp\");\n      if (!S) return;\n      const w = K(t.getState()), k = JSON.parse(S), h = {}, y = k.trackItemsMap, v = k.trackItemDetailsMap, I = k.tracks, x = [], g = k.activeIds.map(async (O) => {\n        const D = v[O];\n        (D.type === \"caption\" || D.type === \"text\") && D.details.fontUrl && await br([\n          {\n            fontFamily: D.details.fontFamily,\n            url: D.details.fontUrl\n          }\n        ]);\n        const j = De();\n        return h[O] = j, w.trackItemsMap[j] = {\n          ...y[O],\n          id: j\n        }, w.trackItemDetailsMap[j] = D, w.trackItemIds.push(j), !0;\n      });\n      await Promise.all(g), I.forEach((O) => {\n        const D = O.items.map((L) => h[L]), j = {\n          ...O,\n          magnetic: !1,\n          static: !1,\n          items: D,\n          id: Xe()\n        };\n        x.push(j);\n      }), w.tracks = [...x, ...w.tracks], t.updateState(\n        {\n          trackItemDetailsMap: w.trackItemDetailsMap,\n          tracks: w.tracks,\n          trackItemIds: w.trackItemIds,\n          trackItemsMap: w.trackItemsMap\n        },\n        {\n          updateHistory: !0,\n          kind: \"update\"\n        }\n      );\n    }\n  }), C = d.subscribe(async (u) => {\n    var l, S, w;\n    if (u.key === ai) {\n      const k = K(t.getState()), h = k.trackItemDetailsMap, y = k.trackItemsMap, v = Object.keys((l = u.value) == null ? void 0 : l.payload);\n      if (!v.length) return;\n      const I = (S = u.value) == null ? void 0 : S.payload;\n      v.forEach((g) => {\n        const O = I[g];\n        if (O.details) {\n          if (h[g].details = {\n            ...h[g].details,\n            ...O.details\n          }, O.details.colorMap) {\n            const D = h[g].details.initialSvgString, j = Wn(\n              D,\n              O.details.colorMap\n            );\n            h[g].details.svgString = j;\n          }\n        } else I[g].playbackRate && (y[g].playbackRate = I[g].playbackRate);\n        I[g].metadata && (y[g].metadata ? y[g].metadata = {\n          ...y[g].metadata,\n          ...I[g].metadata\n        } : y[g].metadata = I[g].metadata), I[g].display && (y[g].display = I[g].display);\n      });\n      for (const g of v) {\n        const O = I[g];\n        if (y[g].type === \"shape\" && O.details.src) {\n          const D = await Oe(O.details.src);\n          h[g].details.width = D.width, h[g].details.height = D.height;\n        }\n      }\n      const x = he(y);\n      t.updateState(\n        {\n          trackItemDetailsMap: { ...h },\n          trackItemsMap: { ...y },\n          duration: x\n        },\n        {\n          updateHistory: !0,\n          kind: \"update:details\"\n        }\n      );\n    }\n    if (u.key === oi) {\n      const k = (w = u.value) == null ? void 0 : w.payload, h = Object.keys(k)[0], y = Object.values(k)[0], v = K(t.getState()), I = v.trackItemDetailsMap[h], x = I.details;\n      if (y.details) {\n        if (y.type === \"image\" && y.details.src) {\n          const O = await Oe(y.details.src), D = I.details.width || 0, j = I.details.height || 0;\n          let L = O.width, R = O.height;\n          const F = O.width / O.height;\n          D / j > F ? (L = D, R = D / F) : (R = j, L = j * F), x.crop = {\n            x: 0,\n            y: 0,\n            height: x.height,\n            width: x.width\n          }, y.details.width = L, y.details.height = R;\n        }\n        if (y.type === \"video\" && y.details.src) {\n          const O = await _n(y.details.src), D = I.details.width || 0, j = I.details.height || 0;\n          let L = O.width, R = O.height;\n          const F = O.width / O.height;\n          D / j > F ? (L = D, R = D / F) : (R = j, L = j * F), x.crop = {\n            x: 0,\n            y: 0,\n            height: x.height,\n            width: x.width\n          }, y.details.width = L, y.details.height = R;\n        }\n        I.details = { ...x, ...y.details }, y.details = I.details;\n      }\n      const g = { ...I, ...y };\n      v.trackItemDetailsMap[h] = g, v.trackItemsMap[h] = {\n        ...v.trackItemsMap[h],\n        type: y.type\n      }, t.updateState(\n        {\n          trackItemDetailsMap: {\n            ...v.trackItemDetailsMap\n          },\n          trackItemsMap: {\n            ...v.trackItemsMap\n          }\n        },\n        {\n          updateHistory: !0,\n          kind: \"update:details\"\n        }\n      );\n    }\n  });\n  return {\n    unsubscribe: () => {\n      m.unsubscribe(), T.unsubscribe(), C.unsubscribe(), _.unsubscribe(), E.unsubscribe(), b.unsubscribe(), M.unsubscribe();\n    }\n  };\n}\nconst zi = { Date: !0, RegExp: !0, String: !0, Number: !0 };\nfunction _s(t, e, r = { cyclesFix: !0 }, s = []) {\n  var f, b;\n  let a = [];\n  const c = Array.isArray(t);\n  for (const _ in t) {\n    const M = t[_], E = c ? +_ : _;\n    if (!(_ in e)) {\n      a.push({\n        type: \"REMOVE\",\n        path: [E],\n        oldValue: t[_]\n      });\n      continue;\n    }\n    const m = e[_], T = typeof M == \"object\" && typeof m == \"object\" && Array.isArray(M) === Array.isArray(m);\n    M && m && T && !zi[(b = (f = Object.getPrototypeOf(M)) == null ? void 0 : f.constructor) == null ? void 0 : b.name] && (!r.cyclesFix || !s.includes(M)) ? a.push.apply(a, _s(M, m, r, r.cyclesFix ? s.concat([M]) : []).map((C) => (C.path.unshift(E), C))) : M !== m && // treat NaN values as equivalent\n    !(Number.isNaN(M) && Number.isNaN(m)) && !(T && (isNaN(M) ? M + \"\" == m + \"\" : +M == +m)) && a.push({\n      path: [E],\n      type: \"CHANGE\",\n      value: m,\n      oldValue: M\n    });\n  }\n  const d = Array.isArray(e);\n  for (const _ in e)\n    _ in t || a.push({\n      type: \"CREATE\",\n      path: [d ? +_ : _],\n      value: e[_]\n    });\n  return a;\n}\nvar On = Symbol.for(\"immer-nothing\"), Ke = Symbol.for(\"immer-draftable\"), vt = Symbol.for(\"immer-state\"), ks =  true ? [\n  // All error codes, starting by 0:\n  function(t) {\n    return `The plugin for '${t}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${t}()\\` when initializing your application.`;\n  },\n  function(t) {\n    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${t}'`;\n  },\n  \"This object has been frozen and should not be mutated\",\n  function(t) {\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + t;\n  },\n  \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n  \"Immer forbids circular references\",\n  \"The first or second argument to `produce` must be a function\",\n  \"The third argument to `produce` must be a function or undefined\",\n  \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n  \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n  function(t) {\n    return `'current' expects a draft, got: ${t}`;\n  },\n  \"Object.defineProperty() cannot be used on an Immer draft\",\n  \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n  \"Immer only supports deleting array indices\",\n  \"Immer only supports setting array indices and the 'length' property\",\n  function(t) {\n    return `'original' expects a draft, got: ${t}`;\n  }\n  // Note: if more errors are added, the errorOffset in Patches.ts should be increased\n  // See Patches.ts for additional errors\n] : 0;\nfunction tt(t, ...e) {\n  if (true) {\n    const r = ks[t], s = typeof r == \"function\" ? r.apply(null, e) : r;\n    throw new Error(`[Immer] ${s}`);\n  }\n  throw new Error(\n    `[Immer] minified error nr: ${t}. Full error at: https://bit.ly/3cXEKWf`\n  );\n}\nvar me = Object.getPrototypeOf;\nfunction ye(t) {\n  return !!t && !!t[vt];\n}\nfunction Qt(t) {\n  var e;\n  return t ? Ss(t) || Array.isArray(t) || !!t[Ke] || !!((e = t.constructor) != null && e[Ke]) || tr(t) || er(t) : !1;\n}\nvar Fi = Object.prototype.constructor.toString();\nfunction Ss(t) {\n  if (!t || typeof t != \"object\")\n    return !1;\n  const e = me(t);\n  if (e === null)\n    return !0;\n  const r = Object.hasOwnProperty.call(e, \"constructor\") && e.constructor;\n  return r === Object ? !0 : typeof r == \"function\" && Function.toString.call(r) === Fi;\n}\nfunction Ve(t, e) {\n  ge(t) === 0 ? Reflect.ownKeys(t).forEach((r) => {\n    e(r, t[r], t);\n  }) : t.forEach((r, s) => e(s, r, t));\n}\nfunction ge(t) {\n  const e = t[vt];\n  return e ? e.type_ : Array.isArray(t) ? 1 : tr(t) ? 2 : er(t) ? 3 : 0;\n}\nfunction qe(t, e) {\n  return ge(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);\n}\nfunction fn(t, e) {\n  return ge(t) === 2 ? t.get(e) : t[e];\n}\nfunction ws(t, e, r) {\n  const s = ge(t);\n  s === 2 ? t.set(e, r) : s === 3 ? t.add(r) : t[e] = r;\n}\nfunction $i(t, e) {\n  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;\n}\nfunction tr(t) {\n  return t instanceof Map;\n}\nfunction er(t) {\n  return t instanceof Set;\n}\nfunction pe(t) {\n  return t.copy_ || t.base_;\n}\nfunction Sn(t, e) {\n  if (tr(t))\n    return new Map(t);\n  if (er(t))\n    return new Set(t);\n  if (Array.isArray(t))\n    return Array.prototype.slice.call(t);\n  const r = Ss(t);\n  if (e === !0 || e === \"class_only\" && !r) {\n    const s = Object.getOwnPropertyDescriptors(t);\n    delete s[vt];\n    let a = Reflect.ownKeys(s);\n    for (let c = 0; c < a.length; c++) {\n      const d = a[c], f = s[d];\n      f.writable === !1 && (f.writable = !0, f.configurable = !0), (f.get || f.set) && (s[d] = {\n        configurable: !0,\n        writable: !0,\n        // could live with !!desc.set as well here...\n        enumerable: f.enumerable,\n        value: t[d]\n      });\n    }\n    return Object.create(me(t), s);\n  } else {\n    const s = me(t);\n    if (s !== null && r)\n      return { ...t };\n    const a = Object.create(s);\n    return Object.assign(a, t);\n  }\n}\nfunction Cn(t, e = !1) {\n  return Mr(t) || ye(t) || !Qt(t) || (ge(t) > 1 && (t.set = t.add = t.clear = t.delete = Ni), Object.freeze(t), e && Object.entries(t).forEach(([r, s]) => Cn(s, !0))), t;\n}\nfunction Ni() {\n  tt(2);\n}\nfunction Mr(t) {\n  return Object.isFrozen(t);\n}\nvar wn = {};\nfunction Ie(t) {\n  const e = wn[t];\n  return e || tt(0, t), e;\n}\nfunction ji(t, e) {\n  wn[t] || (wn[t] = e);\n}\nvar Je;\nfunction Ms() {\n  return Je;\n}\nfunction Hi(t, e) {\n  return {\n    drafts_: [],\n    parent_: t,\n    immer_: e,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: !0,\n    unfinalizedDrafts_: 0\n  };\n}\nfunction Kn(t, e) {\n  e && (Ie(\"Patches\"), t.patches_ = [], t.inversePatches_ = [], t.patchListener_ = e);\n}\nfunction Mn(t) {\n  En(t), t.drafts_.forEach(Li), t.drafts_ = null;\n}\nfunction En(t) {\n  t === Je && (Je = t.parent_);\n}\nfunction Vn(t) {\n  return Je = Hi(Je, t);\n}\nfunction Li(t) {\n  const e = t[vt];\n  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;\n}\nfunction qn(t, e) {\n  e.unfinalizedDrafts_ = e.drafts_.length;\n  const r = e.drafts_[0];\n  return t !== void 0 && t !== r ? (r[vt].modified_ && (Mn(e), tt(4)), Qt(t) && (t = vr(e, t), e.parent_ || _r(e, t)), e.patches_ && Ie(\"Patches\").generateReplacementPatches_(\n    r[vt].base_,\n    t,\n    e.patches_,\n    e.inversePatches_\n  )) : t = vr(e, r, []), Mn(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), t !== On ? t : void 0;\n}\nfunction vr(t, e, r) {\n  if (Mr(e))\n    return e;\n  const s = e[vt];\n  if (!s)\n    return Ve(\n      e,\n      (a, c) => Jn(t, s, e, a, c, r)\n    ), e;\n  if (s.scope_ !== t)\n    return e;\n  if (!s.modified_)\n    return _r(t, s.base_, !0), s.base_;\n  if (!s.finalized_) {\n    s.finalized_ = !0, s.scope_.unfinalizedDrafts_--;\n    const a = s.copy_;\n    let c = a, d = !1;\n    s.type_ === 3 && (c = new Set(a), a.clear(), d = !0), Ve(\n      c,\n      (f, b) => Jn(t, s, a, f, b, r, d)\n    ), _r(t, a, !1), r && t.patches_ && Ie(\"Patches\").generatePatches_(\n      s,\n      r,\n      t.patches_,\n      t.inversePatches_\n    );\n  }\n  return s.copy_;\n}\nfunction Jn(t, e, r, s, a, c, d) {\n  if ( true && a === r && tt(5), ye(a)) {\n    const f = c && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.\n    !qe(e.assigned_, s) ? c.concat(s) : void 0, b = vr(t, a, f);\n    if (ws(r, s, b), ye(b))\n      t.canAutoFreeze_ = !1;\n    else\n      return;\n  } else d && r.add(a);\n  if (Qt(a) && !Mr(a)) {\n    if (!t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1)\n      return;\n    vr(t, a), (!e || !e.scope_.parent_) && typeof s != \"symbol\" && Object.prototype.propertyIsEnumerable.call(r, s) && _r(t, a);\n  }\n}\nfunction _r(t, e, r = !1) {\n  !t.parent_ && t.immer_.autoFreeze_ && t.canAutoFreeze_ && Cn(e, r);\n}\nfunction Ui(t, e) {\n  const r = Array.isArray(t), s = {\n    type_: r ? 1 : 0,\n    // Track which produce call this is associated with.\n    scope_: e ? e.scope_ : Ms(),\n    // True for both shallow and deep changes.\n    modified_: !1,\n    // Used during finalization.\n    finalized_: !1,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: e,\n    // The base state.\n    base_: t,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: !1\n  };\n  let a = s, c = Pn;\n  r && (a = [s], c = Ze);\n  const { revoke: d, proxy: f } = Proxy.revocable(a, c);\n  return s.draft_ = f, s.revoke_ = d, f;\n}\nvar Pn = {\n  get(t, e) {\n    if (e === vt)\n      return t;\n    const r = pe(t);\n    if (!qe(r, e))\n      return Wi(t, r, e);\n    const s = r[e];\n    return t.finalized_ || !Qt(s) ? s : s === pn(t.base_, e) ? (hn(t), t.copy_[e] = An(s, t)) : s;\n  },\n  has(t, e) {\n    return e in pe(t);\n  },\n  ownKeys(t) {\n    return Reflect.ownKeys(pe(t));\n  },\n  set(t, e, r) {\n    const s = Es(pe(t), e);\n    if (s != null && s.set)\n      return s.set.call(t.draft_, r), !0;\n    if (!t.modified_) {\n      const a = pn(pe(t), e), c = a == null ? void 0 : a[vt];\n      if (c && c.base_ === r)\n        return t.copy_[e] = r, t.assigned_[e] = !1, !0;\n      if ($i(r, a) && (r !== void 0 || qe(t.base_, e)))\n        return !0;\n      hn(t), Tn(t);\n    }\n    return t.copy_[e] === r && // special case: handle new props with value 'undefined'\n    (r !== void 0 || e in t.copy_) || // special case: NaN\n    Number.isNaN(r) && Number.isNaN(t.copy_[e]) || (t.copy_[e] = r, t.assigned_[e] = !0), !0;\n  },\n  deleteProperty(t, e) {\n    return pn(t.base_, e) !== void 0 || e in t.base_ ? (t.assigned_[e] = !1, hn(t), Tn(t)) : delete t.assigned_[e], t.copy_ && delete t.copy_[e], !0;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor(t, e) {\n    const r = pe(t), s = Reflect.getOwnPropertyDescriptor(r, e);\n    return s && {\n      writable: !0,\n      configurable: t.type_ !== 1 || e !== \"length\",\n      enumerable: s.enumerable,\n      value: r[e]\n    };\n  },\n  defineProperty() {\n    tt(11);\n  },\n  getPrototypeOf(t) {\n    return me(t.base_);\n  },\n  setPrototypeOf() {\n    tt(12);\n  }\n}, Ze = {};\nVe(Pn, (t, e) => {\n  Ze[t] = function() {\n    return arguments[0] = arguments[0][0], e.apply(this, arguments);\n  };\n});\nZe.deleteProperty = function(t, e) {\n  return  true && isNaN(parseInt(e)) && tt(13), Ze.set.call(this, t, e, void 0);\n};\nZe.set = function(t, e, r) {\n  return  true && e !== \"length\" && isNaN(parseInt(e)) && tt(14), Pn.set.call(this, t[0], e, r, t[0]);\n};\nfunction pn(t, e) {\n  const r = t[vt];\n  return (r ? pe(r) : t)[e];\n}\nfunction Wi(t, e, r) {\n  var a;\n  const s = Es(e, r);\n  return s ? \"value\" in s ? s.value : (\n    // This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    (a = s.get) == null ? void 0 : a.call(t.draft_)\n  ) : void 0;\n}\nfunction Es(t, e) {\n  if (!(e in t))\n    return;\n  let r = me(t);\n  for (; r; ) {\n    const s = Object.getOwnPropertyDescriptor(r, e);\n    if (s)\n      return s;\n    r = me(r);\n  }\n}\nfunction Tn(t) {\n  t.modified_ || (t.modified_ = !0, t.parent_ && Tn(t.parent_));\n}\nfunction hn(t) {\n  t.copy_ || (t.copy_ = Sn(\n    t.base_,\n    t.scope_.immer_.useStrictShallowCopy_\n  ));\n}\nvar Gi = class {\n  constructor(t) {\n    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, r, s) => {\n      if (typeof e == \"function\" && typeof r != \"function\") {\n        const c = r;\n        r = e;\n        const d = this;\n        return function(b = c, ..._) {\n          return d.produce(b, (M) => r.call(this, M, ..._));\n        };\n      }\n      typeof r != \"function\" && tt(6), s !== void 0 && typeof s != \"function\" && tt(7);\n      let a;\n      if (Qt(e)) {\n        const c = Vn(this), d = An(e, void 0);\n        let f = !0;\n        try {\n          a = r(d), f = !1;\n        } finally {\n          f ? Mn(c) : En(c);\n        }\n        return Kn(c, s), qn(a, c);\n      } else if (!e || typeof e != \"object\") {\n        if (a = r(e), a === void 0 && (a = e), a === On && (a = void 0), this.autoFreeze_ && Cn(a, !0), s) {\n          const c = [], d = [];\n          Ie(\"Patches\").generateReplacementPatches_(e, a, c, d), s(c, d);\n        }\n        return a;\n      } else\n        tt(1, e);\n    }, this.produceWithPatches = (e, r) => {\n      if (typeof e == \"function\")\n        return (d, ...f) => this.produceWithPatches(d, (b) => e(b, ...f));\n      let s, a;\n      return [this.produce(e, r, (d, f) => {\n        s = d, a = f;\n      }), s, a];\n    }, typeof (t == null ? void 0 : t.autoFreeze) == \"boolean\" && this.setAutoFreeze(t.autoFreeze), typeof (t == null ? void 0 : t.useStrictShallowCopy) == \"boolean\" && this.setUseStrictShallowCopy(t.useStrictShallowCopy);\n  }\n  createDraft(t) {\n    Qt(t) || tt(8), ye(t) && (t = Yi(t));\n    const e = Vn(this), r = An(t, void 0);\n    return r[vt].isManual_ = !0, En(e), r;\n  }\n  finishDraft(t, e) {\n    const r = t && t[vt];\n    (!r || !r.isManual_) && tt(9);\n    const { scope_: s } = r;\n    return Kn(s, e), qn(void 0, s);\n  }\n  /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */\n  setAutoFreeze(t) {\n    this.autoFreeze_ = t;\n  }\n  /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */\n  setUseStrictShallowCopy(t) {\n    this.useStrictShallowCopy_ = t;\n  }\n  applyPatches(t, e) {\n    let r;\n    for (r = e.length - 1; r >= 0; r--) {\n      const a = e[r];\n      if (a.path.length === 0 && a.op === \"replace\") {\n        t = a.value;\n        break;\n      }\n    }\n    r > -1 && (e = e.slice(r + 1));\n    const s = Ie(\"Patches\").applyPatches_;\n    return ye(t) ? s(t, e) : this.produce(\n      t,\n      (a) => s(a, e)\n    );\n  }\n};\nfunction An(t, e) {\n  const r = tr(t) ? Ie(\"MapSet\").proxyMap_(t, e) : er(t) ? Ie(\"MapSet\").proxySet_(t, e) : Ui(t, e);\n  return (e ? e.scope_ : Ms()).drafts_.push(r), r;\n}\nfunction Yi(t) {\n  return ye(t) || tt(10, t), Ts(t);\n}\nfunction Ts(t) {\n  if (!Qt(t) || Mr(t))\n    return t;\n  const e = t[vt];\n  let r;\n  if (e) {\n    if (!e.modified_)\n      return e.base_;\n    e.finalized_ = !0, r = Sn(t, e.scope_.immer_.useStrictShallowCopy_);\n  } else\n    r = Sn(t, !0);\n  return Ve(r, (s, a) => {\n    ws(r, s, Ts(a));\n  }), e && (e.finalized_ = !1), r;\n}\nfunction Zn() {\n   true && ks.push(\n    'Sets cannot have \"replace\" patches.',\n    function(m) {\n      return \"Unsupported patch operation: \" + m;\n    },\n    function(m) {\n      return \"Cannot apply patch, path doesn't resolve: \" + m;\n    },\n    \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n  );\n  const e = \"replace\", r = \"add\", s = \"remove\";\n  function a(m, T, C, u) {\n    switch (m.type_) {\n      case 0:\n      case 2:\n        return d(\n          m,\n          T,\n          C,\n          u\n        );\n      case 1:\n        return c(m, T, C, u);\n      case 3:\n        return f(\n          m,\n          T,\n          C,\n          u\n        );\n    }\n  }\n  function c(m, T, C, u) {\n    let { base_: l, assigned_: S } = m, w = m.copy_;\n    w.length < l.length && ([l, w] = [w, l], [C, u] = [u, C]);\n    for (let k = 0; k < l.length; k++)\n      if (S[k] && w[k] !== l[k]) {\n        const h = T.concat([k]);\n        C.push({\n          op: e,\n          path: h,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: E(w[k])\n        }), u.push({\n          op: e,\n          path: h,\n          value: E(l[k])\n        });\n      }\n    for (let k = l.length; k < w.length; k++) {\n      const h = T.concat([k]);\n      C.push({\n        op: r,\n        path: h,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: E(w[k])\n      });\n    }\n    for (let k = w.length - 1; l.length <= k; --k) {\n      const h = T.concat([k]);\n      u.push({\n        op: s,\n        path: h\n      });\n    }\n  }\n  function d(m, T, C, u) {\n    const { base_: l, copy_: S } = m;\n    Ve(m.assigned_, (w, k) => {\n      const h = fn(l, w), y = fn(S, w), v = k ? qe(l, w) ? e : r : s;\n      if (h === y && v === e)\n        return;\n      const I = T.concat(w);\n      C.push(v === s ? { op: v, path: I } : { op: v, path: I, value: y }), u.push(\n        v === r ? { op: s, path: I } : v === s ? { op: r, path: I, value: E(h) } : { op: e, path: I, value: E(h) }\n      );\n    });\n  }\n  function f(m, T, C, u) {\n    let { base_: l, copy_: S } = m, w = 0;\n    l.forEach((k) => {\n      if (!S.has(k)) {\n        const h = T.concat([w]);\n        C.push({\n          op: s,\n          path: h,\n          value: k\n        }), u.unshift({\n          op: r,\n          path: h,\n          value: k\n        });\n      }\n      w++;\n    }), w = 0, S.forEach((k) => {\n      if (!l.has(k)) {\n        const h = T.concat([w]);\n        C.push({\n          op: r,\n          path: h,\n          value: k\n        }), u.unshift({\n          op: s,\n          path: h,\n          value: k\n        });\n      }\n      w++;\n    });\n  }\n  function b(m, T, C, u) {\n    C.push({\n      op: e,\n      path: [],\n      value: T === On ? void 0 : T\n    }), u.push({\n      op: e,\n      path: [],\n      value: m\n    });\n  }\n  function _(m, T) {\n    return T.forEach((C) => {\n      const { path: u, op: l } = C;\n      let S = m;\n      for (let y = 0; y < u.length - 1; y++) {\n        const v = ge(S);\n        let I = u[y];\n        typeof I != \"string\" && typeof I != \"number\" && (I = \"\" + I), (v === 0 || v === 1) && (I === \"__proto__\" || I === \"constructor\") && tt(19), typeof S == \"function\" && I === \"prototype\" && tt(19), S = fn(S, I), typeof S != \"object\" && tt(18, u.join(\"/\"));\n      }\n      const w = ge(S), k = M(C.value), h = u[u.length - 1];\n      switch (l) {\n        case e:\n          switch (w) {\n            case 2:\n              return S.set(h, k);\n            case 3:\n              tt(16);\n            default:\n              return S[h] = k;\n          }\n        case r:\n          switch (w) {\n            case 1:\n              return h === \"-\" ? S.push(k) : S.splice(h, 0, k);\n            case 2:\n              return S.set(h, k);\n            case 3:\n              return S.add(k);\n            default:\n              return S[h] = k;\n          }\n        case s:\n          switch (w) {\n            case 1:\n              return S.splice(h, 1);\n            case 2:\n              return S.delete(h);\n            case 3:\n              return S.delete(C.value);\n            default:\n              return delete S[h];\n          }\n        default:\n          tt(17, l);\n      }\n    }), m;\n  }\n  function M(m) {\n    if (!Qt(m))\n      return m;\n    if (Array.isArray(m))\n      return m.map(M);\n    if (tr(m))\n      return new Map(\n        Array.from(m.entries()).map(([C, u]) => [C, M(u)])\n      );\n    if (er(m))\n      return new Set(Array.from(m).map(M));\n    const T = Object.create(me(m));\n    for (const C in m)\n      T[C] = M(m[C]);\n    return qe(m, Ke) && (T[Ke] = m[Ke]), T;\n  }\n  function E(m) {\n    return ye(m) ? M(m) : m;\n  }\n  ji(\"Patches\", {\n    applyPatches_: _,\n    generatePatches_: a,\n    generateReplacementPatches_: b\n  });\n}\nvar _t = new Gi(), Bi = _t.produce;\n_t.produceWithPatches.bind(\n  _t\n);\n_t.setAutoFreeze.bind(_t);\n_t.setUseStrictShallowCopy.bind(_t);\nvar Xi = _t.applyPatches.bind(_t);\n_t.createDraft.bind(_t);\n_t.finishDraft.bind(_t);\nvar Ki = 9007199254740991, Vi = \"[object Arguments]\", qi = \"[object Function]\", Ji = \"[object GeneratorFunction]\", Zi = \"[object Symbol]\", Qi = typeof St == \"object\" && St && St.Object === Object && St, ta = typeof self == \"object\" && self && self.Object === Object && self, ea = Qi || ta || Function(\"return this\")();\nfunction ra(t, e, r) {\n  switch (r.length) {\n    case 0:\n      return t.call(e);\n    case 1:\n      return t.call(e, r[0]);\n    case 2:\n      return t.call(e, r[0], r[1]);\n    case 3:\n      return t.call(e, r[0], r[1], r[2]);\n  }\n  return t.apply(e, r);\n}\nfunction na(t, e) {\n  for (var r = -1, s = t ? t.length : 0, a = Array(s); ++r < s; )\n    a[r] = e(t[r], r, t);\n  return a;\n}\nfunction sa(t, e) {\n  for (var r = -1, s = e.length, a = t.length; ++r < s; )\n    t[a + r] = e[r];\n  return t;\n}\nvar Rn = Object.prototype, ia = Rn.hasOwnProperty, zn = Rn.toString, Qn = ea.Symbol, aa = Rn.propertyIsEnumerable, ts = Qn ? Qn.isConcatSpreadable : void 0, es = Math.max;\nfunction oa(t, e, r, s, a) {\n  var c = -1, d = t.length;\n  for (r || (r = da), a || (a = []); ++c < d; ) {\n    var f = t[c];\n    r(f) ? sa(a, f) : a[a.length] = f;\n  }\n  return a;\n}\nfunction ca(t, e) {\n  return t = Object(t), ua(t, e, function(r, s) {\n    return s in t;\n  });\n}\nfunction ua(t, e, r) {\n  for (var s = -1, a = e.length, c = {}; ++s < a; ) {\n    var d = e[s], f = t[d];\n    r(f, d) && (c[d] = f);\n  }\n  return c;\n}\nfunction la(t, e) {\n  return e = es(e === void 0 ? t.length - 1 : e, 0), function() {\n    for (var r = arguments, s = -1, a = es(r.length - e, 0), c = Array(a); ++s < a; )\n      c[s] = r[e + s];\n    s = -1;\n    for (var d = Array(e + 1); ++s < e; )\n      d[s] = r[s];\n    return d[e] = c, ra(t, this, d);\n  };\n}\nfunction da(t) {\n  return ha(t) || pa(t) || !!(ts && t && t[ts]);\n}\nfunction fa(t) {\n  if (typeof t == \"string\" || va(t))\n    return t;\n  var e = t + \"\";\n  return e == \"0\" && 1 / t == -1 / 0 ? \"-0\" : e;\n}\nfunction pa(t) {\n  return ya(t) && ia.call(t, \"callee\") && (!aa.call(t, \"callee\") || zn.call(t) == Vi);\n}\nvar ha = Array.isArray;\nfunction ma(t) {\n  return t != null && Ia(t.length) && !ga(t);\n}\nfunction ya(t) {\n  return As(t) && ma(t);\n}\nfunction ga(t) {\n  var e = ba(t) ? zn.call(t) : \"\";\n  return e == qi || e == Ji;\n}\nfunction Ia(t) {\n  return typeof t == \"number\" && t > -1 && t % 1 == 0 && t <= Ki;\n}\nfunction ba(t) {\n  var e = typeof t;\n  return !!t && (e == \"object\" || e == \"function\");\n}\nfunction As(t) {\n  return !!t && typeof t == \"object\";\n}\nfunction va(t) {\n  return typeof t == \"symbol\" || As(t) && zn.call(t) == Zi;\n}\nvar _a = la(function(t, e) {\n  return t == null ? {} : ca(t, na(oa(e), fa));\n}), ka = _a;\nconst rs = /* @__PURE__ */ xn(ka), Sa = {\n  width: 1080,\n  height: 1920\n}, wa = 30, Ma = {\n  size: Sa,\n  fps: wa,\n  tracks: [],\n  trackItemIds: [],\n  trackItemsMap: {},\n  transitionIds: [],\n  transitionsMap: {},\n  scale: {\n    unit: 1,\n    zoom: 1,\n    segments: 1,\n    index: 1\n  },\n  duration: 0,\n  activeIds: [],\n  trackItemDetailsMap: {},\n  structure: []\n}, ns = [\n  \"tracks\",\n  \"trackItemsMap\",\n  \"trackItemDetailsMap\",\n  \"transitionIds\",\n  \"transitionsMap\",\n  \"trackItemIds\",\n  \"structure\"\n];\nclass eo {\n  constructor(e) {\n    le(this, \"stateSubject\");\n    le(this, \"stateHistorySubject\");\n    le(this, \"prevState\");\n    le(this, \"undos\", []);\n    le(this, \"redos\", []);\n    le(this, \"listener\");\n    const r = Object.assign({}, Ma, e);\n    this.stateSubject = new Un(r), this.stateHistorySubject = new Un({\n      handleRedo: !1,\n      handleUndo: !1\n    }), this.prevState = r, this.initListeners();\n  }\n  initListeners() {\n    Ri(this);\n  }\n  destroyListeners() {\n    this.listener && this.listener.unsubscribe();\n  }\n  purge() {\n    this.destroyListeners();\n  }\n  updateHistory(e, r) {\n    const s = rs(e, ns), a = rs(this.getState(), ns), c = _s(a, s);\n    c.length && (this.undos.push({ undos: c, type: r }), this.redos = []);\n  }\n  getStateHistory() {\n    return this.stateHistorySubject.getValue();\n  }\n  subscribeHistory(e) {\n    return this.stateHistorySubject.subscribe(e);\n  }\n  // Get the current state\n  getState() {\n    return this.stateSubject.getValue();\n  }\n  // Subscribe to state changes\n  subscribe(e) {\n    return this.stateSubject.subscribe(e);\n  }\n  // Update the state, emitting only if the part of the state has changed\n  updateState(e, r = { updateHistory: !1 }) {\n    const s = this.getState(), a = {\n      ...K(s),\n      ...K(e)\n    };\n    Q(s, a) || (r.updateHistory && this.updateHistory(a, r.kind), this.prevState = s, this.stateSubject.next(a));\n  }\n  // emit changes for design size\n  subscribeToSize(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      Q(r.size, this.prevState.size) || e({ size: r.size });\n    });\n  }\n  // Selectively subscribe to scale changes\n  subscribeToScale(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      Q(r.scale, this.prevState.scale) || e({ scale: r.scale });\n    });\n  }\n  // Selectively subscribe to fps changes\n  subscribeToFps(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      r.fps !== this.prevState.fps && e({ fps: r.fps });\n    });\n  }\n  subscribeToUpdateTrackItem(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      Q(r.trackItemsMap, this.prevState.trackItemsMap) || e({ trackItemsMap: r.trackItemsMap });\n    });\n  }\n  subscribeToUpdateAnimations(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      const s = Object.keys(r.trackItemsMap).filter(\n        (a) => {\n          const c = this.prevState.trackItemsMap[a], d = r.trackItemsMap[a];\n          return c && d && !Q(c.animations, d.animations);\n        }\n      );\n      e({ trackItemsMap: r.trackItemsMap, changedAnimationIds: s });\n    });\n  }\n  subscribeToUpdateTrackItemTiming(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      if (!Q(r.trackItemsMap, this.prevState.trackItemsMap)) {\n        const s = Object.keys(r.trackItemsMap).filter((c) => {\n          const d = this.prevState.trackItemsMap[c], f = r.trackItemsMap[c];\n          return d && f && !Q(d.trim, f.trim);\n        }), a = Object.keys(r.trackItemsMap).filter(\n          (c) => {\n            const d = this.prevState.trackItemsMap[c], f = r.trackItemsMap[c];\n            return d && f && !Q(d.display, f.display);\n          }\n        );\n        e({\n          trackItemsMap: r.trackItemsMap,\n          changedTrimIds: s.length > 0 ? s : void 0,\n          changedDisplayIds: a.length > 0 ? a : void 0\n        });\n      }\n    });\n  }\n  subscribeToUpdateItemDetails(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      Q(r.trackItemDetailsMap, this.prevState.trackItemDetailsMap) || e({ trackItemDetailsMap: r.trackItemDetailsMap });\n    });\n  }\n  // Selectively subscribe to duration changes\n  subscribeToDuration(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      r.duration !== this.prevState.duration && e({ duration: r.duration });\n    });\n  }\n  subscribeToHistory(e) {\n    return this.stateHistorySubject.asObservable().subscribe((r) => {\n      if (r.handleRedo) {\n        const s = this.undos[this.undos.length - 1].type;\n        e({ ...this.getState(), type: s }), this.stateHistorySubject.next({ handleRedo: !1, handleUndo: !1 });\n      }\n      if (r.handleUndo) {\n        const s = this.redos[this.redos.length - 1].type;\n        e({ ...this.getState(), type: s }), this.stateHistorySubject.next({ handleRedo: !1, handleUndo: !1 });\n      }\n    });\n  }\n  subscribeToAddOrRemoveItems(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      const s = [...r.trackItemIds].sort(), a = [...this.prevState.trackItemIds].sort(), c = [...r.transitionIds].sort(), d = [...this.prevState.transitionIds].sort();\n      (!Q(s, a) || !Q(c, d)) && e({ trackItemIds: r.trackItemIds });\n    });\n  }\n  // Selectively subscribe to activeIds changes\n  subscribeToActiveIds(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      Q(r.activeIds, this.prevState.activeIds) || e({ activeIds: r.activeIds });\n    });\n  }\n  subscribeToTracks(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      const s = r.tracks, c = this.prevState.tracks.map((f) => f.id), d = s.filter(\n        (f) => !c.includes(f.id)\n      );\n      d.length && e({\n        tracks: r.tracks,\n        changedTracks: d.map((f) => f.id)\n      });\n    });\n  }\n  // Selectively subscribe to multiple track-related properties\n  subscribeToState(e) {\n    return this.stateSubject.asObservable().subscribe((r) => {\n      (!Q(r.tracks, this.prevState.tracks) || !Q(r.trackItemIds, this.prevState.trackItemIds) || !Q(r.trackItemsMap, this.prevState.trackItemsMap) || !Q(r.transitionIds, this.prevState.transitionIds) || !Q(r.transitionsMap, this.prevState.transitionsMap) || !Q(\n        r.trackItemDetailsMap,\n        this.prevState.trackItemDetailsMap\n      ) || !Q(r.structure, this.prevState.structure)) && e({\n        tracks: r.tracks,\n        trackItemIds: r.trackItemIds,\n        trackItemsMap: r.trackItemsMap,\n        transitionIds: r.transitionIds,\n        transitionsMap: r.transitionsMap,\n        trackItemDetailsMap: r.trackItemDetailsMap,\n        structure: r.structure\n      });\n    });\n  }\n  undo() {\n    const e = this.undos.pop(), r = e == null ? void 0 : e.undos, s = e == null ? void 0 : e.type;\n    if (!r || !s) return;\n    Zn();\n    const {\n      trackItemDetailsMap: a,\n      trackItemIds: c,\n      tracks: d,\n      transitionIds: f,\n      transitionsMap: b,\n      trackItemsMap: _,\n      structure: M\n    } = this.getState(), E = K({\n      trackItemDetailsMap: a,\n      trackItemIds: c,\n      tracks: d,\n      transitionIds: f,\n      transitionsMap: b,\n      trackItemsMap: _,\n      structure: M\n    }), m = [], T = [], C = [], u = [], l = [], S = [], w = [];\n    r.forEach((R) => {\n      let F;\n      const V = R.path.slice(1);\n      R.type === \"CREATE\" ? F = {\n        path: V,\n        op: \"remove\",\n        value: R.value\n      } : R.type === \"CHANGE\" ? F = {\n        path: V,\n        op: \"replace\",\n        value: R.oldValue\n      } : F = {\n        path: V,\n        op: \"add\",\n        value: R.oldValue\n      }, R.path.includes(\"trackItemIds\") ? C.push(F) : R.path.includes(\"transitionIds\") ? T.push(F) : R.path.includes(\"trackItemsMap\") ? l.push(F) : R.path.includes(\"transitionsMap\") ? u.push(F) : R.path.includes(\"tracks\") ? m.push(F) : R.path.includes(\"trackItemDetailsMap\") ? S.push(F) : R.path.includes(\"structure\") && w.push(F);\n    });\n    const k = this.applyPatch(\n      E.tracks,\n      m\n    ), h = this.applyPatch(\n      E.transitionIds,\n      T\n    ), y = this.applyPatch(\n      E.trackItemIds,\n      C\n    ), v = this.applyPatch(\n      E.transitionsMap,\n      u\n    ), I = this.applyPatch(\n      E.trackItemsMap,\n      l\n    ), x = this.applyPatch(\n      E.trackItemDetailsMap,\n      S\n    ), g = this.applyPatch(\n      E.structure,\n      w\n    ), O = K({\n      tracks: k,\n      transitionIds: h,\n      trackItemIds: y,\n      transitionsMap: v,\n      trackItemsMap: I,\n      trackItemDetailsMap: x,\n      structure: g\n    }), D = K(this.getState()), j = { ...D, ...O };\n    this.prevState = D, this.redos.push({ redos: r, type: s });\n    const L = he(j.trackItemsMap);\n    this.stateSubject.next({ ...j, duration: L }), this.stateHistorySubject.next({ handleRedo: !1, handleUndo: !0 }), this.updateState(j, { updateHistory: !1 });\n  }\n  applyPatch(e, r) {\n    return r.reverse().reduce((s, a) => Bi(s, (c) => {\n      Xi(c, [a]);\n    }), e);\n  }\n  redo() {\n    const e = this.redos.pop(), r = e == null ? void 0 : e.redos, s = e == null ? void 0 : e.type;\n    if (!r || !s) return;\n    Zn();\n    const {\n      trackItemDetailsMap: a,\n      trackItemIds: c,\n      tracks: d,\n      transitionIds: f,\n      transitionsMap: b,\n      trackItemsMap: _,\n      structure: M\n    } = this.getState(), E = K({\n      trackItemDetailsMap: a,\n      trackItemIds: c,\n      tracks: d,\n      transitionIds: f,\n      transitionsMap: b,\n      trackItemsMap: _,\n      structure: M\n    }), m = [], T = [], C = [], u = [], l = [], S = [], w = [];\n    r.forEach((R) => {\n      let F;\n      const V = R.path.slice(1);\n      R.type === \"CREATE\" ? F = {\n        path: V,\n        op: \"add\",\n        value: R.value\n      } : R.type === \"CHANGE\" ? F = {\n        path: V,\n        op: \"replace\",\n        value: R.value\n      } : F = {\n        path: V,\n        op: \"remove\",\n        value: R.oldValue\n      }, R.path.includes(\"trackItemIds\") ? C.push(F) : R.path.includes(\"transitionIds\") ? T.push(F) : R.path.includes(\"trackItemsMap\") ? l.push(F) : R.path.includes(\"transitionsMap\") ? u.push(F) : R.path.includes(\"trackItemDetailsMap\") ? S.push(F) : R.path.includes(\"structure\") ? w.push(F) : m.push(F);\n    });\n    const k = this.applyPatch(\n      E.tracks,\n      m\n    ), h = this.applyPatch(\n      E.transitionIds,\n      T\n    ), y = this.applyPatch(\n      E.trackItemIds,\n      C\n    ), v = this.applyPatch(\n      E.transitionsMap,\n      u\n    ), I = this.applyPatch(\n      E.trackItemsMap,\n      l\n    ), x = this.applyPatch(\n      E.trackItemDetailsMap,\n      S\n    ), g = this.applyPatch(\n      E.structure,\n      w\n    ), O = K({\n      tracks: k,\n      transitionIds: h,\n      trackItemIds: y,\n      transitionsMap: v,\n      trackItemsMap: I,\n      trackItemDetailsMap: x,\n      structure: g\n    }), D = K(this.getState()), j = { ...D, ...O };\n    this.prevState = D, this.undos.push({ undos: r, type: s });\n    const L = he(j.trackItemsMap);\n    this.stateSubject.next({ ...j, duration: L }), this.stateHistorySubject.next({ handleRedo: !0, handleUndo: !1 }), this.updateState(j, { updateHistory: !1 });\n  }\n  toJSON() {\n    const {\n      fps: e,\n      tracks: r,\n      size: s,\n      trackItemDetailsMap: a,\n      trackItemIds: c,\n      transitionsMap: d,\n      trackItemsMap: f,\n      transitionIds: b\n    } = this.getState();\n    return {\n      fps: e,\n      tracks: r,\n      size: s,\n      trackItemDetailsMap: a,\n      trackItemIds: c,\n      transitionsMap: d,\n      trackItemsMap: f,\n      transitionIds: b\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRlc2lnbmNvbWJvL3N0YXRlL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQ2tFO0FBQ2xFO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBbUQ7QUFDOUQsSUFBSTtBQUNKLFVBQVU7QUFDVixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGdCQUFnQjtBQUNoQixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0JBQWdCO0FBQ2hCLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLDgzQkFBODNCO0FBQzkzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QixHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQixHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0NBQWtDO0FBQzFDLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNELDJEQUEyRCxNQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBLGdDQUFnQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssc0JBQXNCLGdCQUFnQjtBQUM5RztBQUNBO0FBQ0EsZUFBZSxxRUFBcUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUUsYUFBYSxFQUFFO0FBQzFDO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQTBELFNBQVMsc0JBQXNCLE9BQU8sUUFBUTtBQUN4SDtBQUNBLFNBQVMsMEJBQTBCO0FBQ25DLG9DQUFvQyxzQkFBc0IsSUFBSSxrQ0FBa0MsSUFBSTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUUsZ0NBQWdDLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRSx3Q0FBd0MsRUFBRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0NBQWtDLElBQUksa0NBQWtDLElBQUksc0NBQXNDLElBQUk7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRSxHQUFHLEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSSxrQ0FBa0MsSUFBSSxzQ0FBc0MsSUFBSTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFLEdBQUcsRUFBRTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRTtBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLEtBQUs7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFFBQVE7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixhQUFhLEVBQUU7QUFDZix3QkFBd0IsRUFBRTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQkFBb0Isc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQkFBK0I7QUFDNUQ7QUFDQTtBQUNBLENBQUM7QUFDRCxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssaUNBQWlDO0FBQ3RDLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQSw2QkFBNkIsbUJBQW1CLG1DQUFtQyxnQ0FBZ0MseUJBQXlCLG1CQUFtQjtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdFRSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlbW90aW9uLWNhcHRpb25zLy4vbm9kZV9tb2R1bGVzL0BkZXNpZ25jb21iby9zdGF0ZS9kaXN0L2luZGV4LmVzLmpzPzY0YmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHhzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIERzID0gKHQsIGUsIHIpID0+IGUgaW4gdCA/IHhzKHQsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHIgfSkgOiB0W2VdID0gcjtcbnZhciBsZSA9ICh0LCBlLCByKSA9PiBEcyh0LCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCByKTtcbmltcG9ydCB7IHN1YmplY3QgYXMgZGUsIGZpbHRlciBhcyBmZSB9IGZyb20gXCJAZGVzaWduY29tYm8vZXZlbnRzXCI7XG52YXIgbW4gPSBmdW5jdGlvbih0LCBlKSB7XG4gIHJldHVybiBtbiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKHIsIHMpIHtcbiAgICByLl9fcHJvdG9fXyA9IHM7XG4gIH0gfHwgZnVuY3Rpb24ociwgcykge1xuICAgIGZvciAodmFyIGEgaW4gcykgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIGEpICYmIChyW2FdID0gc1thXSk7XG4gIH0sIG1uKHQsIGUpO1xufTtcbmZ1bmN0aW9uIFFlKHQsIGUpIHtcbiAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIiAmJiBlICE9PSBudWxsKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGUpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgbW4odCwgZSk7XG4gIGZ1bmN0aW9uIHIoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IHQ7XG4gIH1cbiAgdC5wcm90b3R5cGUgPSBlID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShlKSA6IChyLnByb3RvdHlwZSA9IGUucHJvdG90eXBlLCBuZXcgcigpKTtcbn1cbmZ1bmN0aW9uIHluKHQpIHtcbiAgdmFyIGUgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIHIgPSBlICYmIHRbZV0sIHMgPSAwO1xuICBpZiAocikgcmV0dXJuIHIuY2FsbCh0KTtcbiAgaWYgKHQgJiYgdHlwZW9mIHQubGVuZ3RoID09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdCAmJiBzID49IHQubGVuZ3RoICYmICh0ID0gdm9pZCAwKSwgeyB2YWx1ZTogdCAmJiB0W3MrK10sIGRvbmU6ICF0IH07XG4gICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKGUgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5mdW5jdGlvbiBnbih0LCBlKSB7XG4gIHZhciByID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdFtTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIXIpIHJldHVybiB0O1xuICB2YXIgcyA9IHIuY2FsbCh0KSwgYSwgYyA9IFtdLCBkO1xuICB0cnkge1xuICAgIGZvciAoOyAoZSA9PT0gdm9pZCAwIHx8IGUtLSA+IDApICYmICEoYSA9IHMubmV4dCgpKS5kb25lOyApIGMucHVzaChhLnZhbHVlKTtcbiAgfSBjYXRjaCAoZikge1xuICAgIGQgPSB7IGVycm9yOiBmIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGEgJiYgIWEuZG9uZSAmJiAociA9IHMucmV0dXJuKSAmJiByLmNhbGwocyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChkKSB0aHJvdyBkLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIEluKHQsIGUsIHIpIHtcbiAgaWYgKHIgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgcyA9IDAsIGEgPSBlLmxlbmd0aCwgYzsgcyA8IGE7IHMrKylcbiAgICAoYyB8fCAhKHMgaW4gZSkpICYmIChjIHx8IChjID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSwgMCwgcykpLCBjW3NdID0gZVtzXSk7XG4gIHJldHVybiB0LmNvbmNhdChjIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUpKTtcbn1cbmZ1bmN0aW9uIFd0KHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIHNzKHQpIHtcbiAgdmFyIGUgPSBmdW5jdGlvbihzKSB7XG4gICAgRXJyb3IuY2FsbChzKSwgcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICB9LCByID0gdChlKTtcbiAgcmV0dXJuIHIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpLCByLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHIsIHI7XG59XG52YXIgbG4gPSBzcyhmdW5jdGlvbih0KSB7XG4gIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgdCh0aGlzKSwgdGhpcy5tZXNzYWdlID0gciA/IHIubGVuZ3RoICsgYCBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxuYCArIHIubWFwKGZ1bmN0aW9uKHMsIGEpIHtcbiAgICAgIHJldHVybiBhICsgMSArIFwiKSBcIiArIHMudG9TdHJpbmcoKTtcbiAgICB9KS5qb2luKGBcbiAgYCkgOiBcIlwiLCB0aGlzLm5hbWUgPSBcIlVuc3Vic2NyaXB0aW9uRXJyb3JcIiwgdGhpcy5lcnJvcnMgPSByO1xuICB9O1xufSk7XG5mdW5jdGlvbiBibih0LCBlKSB7XG4gIGlmICh0KSB7XG4gICAgdmFyIHIgPSB0LmluZGV4T2YoZSk7XG4gICAgMCA8PSByICYmIHQuc3BsaWNlKHIsIDEpO1xuICB9XG59XG52YXIga3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gdChlKSB7XG4gICAgdGhpcy5pbml0aWFsVGVhcmRvd24gPSBlLCB0aGlzLmNsb3NlZCA9ICExLCB0aGlzLl9wYXJlbnRhZ2UgPSBudWxsLCB0aGlzLl9maW5hbGl6ZXJzID0gbnVsbDtcbiAgfVxuICByZXR1cm4gdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSwgciwgcywgYSwgYztcbiAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICB0aGlzLmNsb3NlZCA9ICEwO1xuICAgICAgdmFyIGQgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgICBpZiAoZClcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudGFnZSA9IG51bGwsIEFycmF5LmlzQXJyYXkoZCkpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGYgPSB5bihkKSwgYiA9IGYubmV4dCgpOyAhYi5kb25lOyBiID0gZi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgdmFyIF8gPSBiLnZhbHVlO1xuICAgICAgICAgICAgICBfLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoICh1KSB7XG4gICAgICAgICAgICBlID0geyBlcnJvcjogdSB9O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBiICYmICFiLmRvbmUgJiYgKHIgPSBmLnJldHVybikgJiYgci5jYWxsKGYpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZC5yZW1vdmUodGhpcyk7XG4gICAgICB2YXIgTSA9IHRoaXMuaW5pdGlhbFRlYXJkb3duO1xuICAgICAgaWYgKFd0KE0pKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIE0oKTtcbiAgICAgICAgfSBjYXRjaCAodSkge1xuICAgICAgICAgIGMgPSB1IGluc3RhbmNlb2YgbG4gPyB1LmVycm9ycyA6IFt1XTtcbiAgICAgICAgfVxuICAgICAgdmFyIEUgPSB0aGlzLl9maW5hbGl6ZXJzO1xuICAgICAgaWYgKEUpIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVycyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgbSA9IHluKEUpLCBUID0gbS5uZXh0KCk7ICFULmRvbmU7IFQgPSBtLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIEMgPSBULnZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgJG4oQyk7XG4gICAgICAgICAgICB9IGNhdGNoICh1KSB7XG4gICAgICAgICAgICAgIGMgPSBjID8/IFtdLCB1IGluc3RhbmNlb2YgbG4gPyBjID0gSW4oSW4oW10sIGduKGMpKSwgZ24odS5lcnJvcnMpKSA6IGMucHVzaCh1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgICAgICBzID0geyBlcnJvcjogdSB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBUICYmICFULmRvbmUgJiYgKGEgPSBtLnJldHVybikgJiYgYS5jYWxsKG0pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAocykgdGhyb3cgcy5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjKVxuICAgICAgICB0aHJvdyBuZXcgbG4oYyk7XG4gICAgfVxuICB9LCB0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHI7XG4gICAgaWYgKGUgJiYgZSAhPT0gdGhpcylcbiAgICAgIGlmICh0aGlzLmNsb3NlZClcbiAgICAgICAgJG4oZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiB0KSB7XG4gICAgICAgICAgaWYgKGUuY2xvc2VkIHx8IGUuX2hhc1BhcmVudCh0aGlzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBlLl9hZGRQYXJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgKHRoaXMuX2ZpbmFsaXplcnMgPSAociA9IHRoaXMuX2ZpbmFsaXplcnMpICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiBbXSkucHVzaChlKTtcbiAgICAgIH1cbiAgfSwgdC5wcm90b3R5cGUuX2hhc1BhcmVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgciA9IHRoaXMuX3BhcmVudGFnZTtcbiAgICByZXR1cm4gciA9PT0gZSB8fCBBcnJheS5pc0FycmF5KHIpICYmIHIuaW5jbHVkZXMoZSk7XG4gIH0sIHQucHJvdG90eXBlLl9hZGRQYXJlbnQgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHIgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgdGhpcy5fcGFyZW50YWdlID0gQXJyYXkuaXNBcnJheShyKSA/IChyLnB1c2goZSksIHIpIDogciA/IFtyLCBlXSA6IGU7XG4gIH0sIHQucHJvdG90eXBlLl9yZW1vdmVQYXJlbnQgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHIgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgciA9PT0gZSA/IHRoaXMuX3BhcmVudGFnZSA9IG51bGwgOiBBcnJheS5pc0FycmF5KHIpICYmIGJuKHIsIGUpO1xuICB9LCB0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHIgPSB0aGlzLl9maW5hbGl6ZXJzO1xuICAgIHIgJiYgYm4ociwgZSksIGUgaW5zdGFuY2VvZiB0ICYmIGUuX3JlbW92ZVBhcmVudCh0aGlzKTtcbiAgfSwgdC5FTVBUWSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gbmV3IHQoKTtcbiAgICByZXR1cm4gZS5jbG9zZWQgPSAhMCwgZTtcbiAgfSgpLCB0O1xufSgpLCBpcyA9IGtyLkVNUFRZO1xuZnVuY3Rpb24gYXModCkge1xuICByZXR1cm4gdCBpbnN0YW5jZW9mIGtyIHx8IHQgJiYgXCJjbG9zZWRcIiBpbiB0ICYmIFd0KHQucmVtb3ZlKSAmJiBXdCh0LmFkZCkgJiYgV3QodC51bnN1YnNjcmliZSk7XG59XG5mdW5jdGlvbiAkbih0KSB7XG4gIFd0KHQpID8gdCgpIDogdC51bnN1YnNjcmliZSgpO1xufVxudmFyIE9zID0ge1xuICBQcm9taXNlOiB2b2lkIDBcbn0sIENzID0ge1xuICBzZXRUaW1lb3V0OiBmdW5jdGlvbih0LCBlKSB7XG4gICAgZm9yICh2YXIgciA9IFtdLCBzID0gMjsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKylcbiAgICAgIHJbcyAtIDJdID0gYXJndW1lbnRzW3NdO1xuICAgIHJldHVybiBzZXRUaW1lb3V0LmFwcGx5KHZvaWQgMCwgSW4oW3QsIGVdLCBnbihyKSkpO1xuICB9LFxuICBjbGVhclRpbWVvdXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHQpO1xuICB9LFxuICBkZWxlZ2F0ZTogdm9pZCAwXG59O1xuZnVuY3Rpb24gUHModCkge1xuICBDcy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRocm93IHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gTm4oKSB7XG59XG5mdW5jdGlvbiB5cih0KSB7XG4gIHQoKTtcbn1cbnZhciBvcyA9IGZ1bmN0aW9uKHQpIHtcbiAgUWUoZSwgdCk7XG4gIGZ1bmN0aW9uIGUocikge1xuICAgIHZhciBzID0gdC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmV0dXJuIHMuaXNTdG9wcGVkID0gITEsIHIgPyAocy5kZXN0aW5hdGlvbiA9IHIsIGFzKHIpICYmIHIuYWRkKHMpKSA6IHMuZGVzdGluYXRpb24gPSBGcywgcztcbiAgfVxuICByZXR1cm4gZS5jcmVhdGUgPSBmdW5jdGlvbihyLCBzLCBhKSB7XG4gICAgcmV0dXJuIG5ldyB2bihyLCBzLCBhKTtcbiAgfSwgZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHIpIHtcbiAgICB0aGlzLmlzU3RvcHBlZCB8fCB0aGlzLl9uZXh0KHIpO1xuICB9LCBlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICB0aGlzLmlzU3RvcHBlZCB8fCAodGhpcy5pc1N0b3BwZWQgPSAhMCwgdGhpcy5fZXJyb3IocikpO1xuICB9LCBlLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNTdG9wcGVkIHx8ICh0aGlzLmlzU3RvcHBlZCA9ICEwLCB0aGlzLl9jb21wbGV0ZSgpKTtcbiAgfSwgZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsb3NlZCB8fCAodGhpcy5pc1N0b3BwZWQgPSAhMCwgdC5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKSwgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGwpO1xuICB9LCBlLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uKHIpIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocik7XG4gIH0sIGUucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSwgZS5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSwgZTtcbn0oa3IpLCBScyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiB0KGUpIHtcbiAgICB0aGlzLnBhcnRpYWxPYnNlcnZlciA9IGU7XG4gIH1cbiAgcmV0dXJuIHQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHIgPSB0aGlzLnBhcnRpYWxPYnNlcnZlcjtcbiAgICBpZiAoci5uZXh0KVxuICAgICAgdHJ5IHtcbiAgICAgICAgci5uZXh0KGUpO1xuICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICBtcihzKTtcbiAgICAgIH1cbiAgfSwgdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHIgPSB0aGlzLnBhcnRpYWxPYnNlcnZlcjtcbiAgICBpZiAoci5lcnJvcilcbiAgICAgIHRyeSB7XG4gICAgICAgIHIuZXJyb3IoZSk7XG4gICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgIG1yKHMpO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIG1yKGUpO1xuICB9LCB0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gdGhpcy5wYXJ0aWFsT2JzZXJ2ZXI7XG4gICAgaWYgKGUuY29tcGxldGUpXG4gICAgICB0cnkge1xuICAgICAgICBlLmNvbXBsZXRlKCk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIG1yKHIpO1xuICAgICAgfVxuICB9LCB0O1xufSgpLCB2biA9IGZ1bmN0aW9uKHQpIHtcbiAgUWUoZSwgdCk7XG4gIGZ1bmN0aW9uIGUociwgcywgYSkge1xuICAgIHZhciBjID0gdC5jYWxsKHRoaXMpIHx8IHRoaXMsIGQ7XG4gICAgcmV0dXJuIFd0KHIpIHx8ICFyID8gZCA9IHtcbiAgICAgIG5leHQ6IHIgPz8gdm9pZCAwLFxuICAgICAgZXJyb3I6IHMgPz8gdm9pZCAwLFxuICAgICAgY29tcGxldGU6IGEgPz8gdm9pZCAwXG4gICAgfSA6IGQgPSByLCBjLmRlc3RpbmF0aW9uID0gbmV3IFJzKGQpLCBjO1xuICB9XG4gIHJldHVybiBlO1xufShvcyk7XG5mdW5jdGlvbiBtcih0KSB7XG4gIFBzKHQpO1xufVxuZnVuY3Rpb24genModCkge1xuICB0aHJvdyB0O1xufVxudmFyIEZzID0ge1xuICBjbG9zZWQ6ICEwLFxuICBuZXh0OiBObixcbiAgZXJyb3I6IHpzLFxuICBjb21wbGV0ZTogTm5cbn0sICRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wub2JzZXJ2YWJsZSB8fCBcIkBAb2JzZXJ2YWJsZVwiO1xufSgpO1xuZnVuY3Rpb24gTnModCkge1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGpzKHQpIHtcbiAgcmV0dXJuIHQubGVuZ3RoID09PSAwID8gTnMgOiB0Lmxlbmd0aCA9PT0gMSA/IHRbMF0gOiBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIHQucmVkdWNlKGZ1bmN0aW9uKHMsIGEpIHtcbiAgICAgIHJldHVybiBhKHMpO1xuICAgIH0sIHIpO1xuICB9O1xufVxudmFyIGpuID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHQoZSkge1xuICAgIGUgJiYgKHRoaXMuX3N1YnNjcmliZSA9IGUpO1xuICB9XG4gIHJldHVybiB0LnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciByID0gbmV3IHQoKTtcbiAgICByZXR1cm4gci5zb3VyY2UgPSB0aGlzLCByLm9wZXJhdG9yID0gZSwgcjtcbiAgfSwgdC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oZSwgciwgcykge1xuICAgIHZhciBhID0gdGhpcywgYyA9IExzKGUpID8gZSA6IG5ldyB2bihlLCByLCBzKTtcbiAgICByZXR1cm4geXIoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZCA9IGEsIGYgPSBkLm9wZXJhdG9yLCBiID0gZC5zb3VyY2U7XG4gICAgICBjLmFkZChmID8gZi5jYWxsKGMsIGIpIDogYiA/IGEuX3N1YnNjcmliZShjKSA6IGEuX3RyeVN1YnNjcmliZShjKSk7XG4gICAgfSksIGM7XG4gIH0sIHQucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbihlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoZSk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgZS5lcnJvcihyKTtcbiAgICB9XG4gIH0sIHQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihlLCByKSB7XG4gICAgdmFyIHMgPSB0aGlzO1xuICAgIHJldHVybiByID0gSG4ociksIG5ldyByKGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHZhciBkID0gbmV3IHZuKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oZikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlKGYpO1xuICAgICAgICAgIH0gY2F0Y2ggKGIpIHtcbiAgICAgICAgICAgIGMoYiksIGQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBjLFxuICAgICAgICBjb21wbGV0ZTogYVxuICAgICAgfSk7XG4gICAgICBzLnN1YnNjcmliZShkKTtcbiAgICB9KTtcbiAgfSwgdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcjtcbiAgICByZXR1cm4gKHIgPSB0aGlzLnNvdXJjZSkgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogci5zdWJzY3JpYmUoZSk7XG4gIH0sIHQucHJvdG90eXBlWyRzXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LCB0LnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgZSA9IFtdLCByID0gMDsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKylcbiAgICAgIGVbcl0gPSBhcmd1bWVudHNbcl07XG4gICAgcmV0dXJuIGpzKGUpKHRoaXMpO1xuICB9LCB0LnByb3RvdHlwZS50b1Byb21pc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHJldHVybiBlID0gSG4oZSksIG5ldyBlKGZ1bmN0aW9uKHMsIGEpIHtcbiAgICAgIHZhciBjO1xuICAgICAgci5zdWJzY3JpYmUoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gYyA9IGQ7XG4gICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBhKGQpO1xuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzKGMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIHQuY3JlYXRlID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBuZXcgdChlKTtcbiAgfSwgdDtcbn0oKTtcbmZ1bmN0aW9uIEhuKHQpIHtcbiAgdmFyIGU7XG4gIHJldHVybiAoZSA9IHQgPz8gT3MuUHJvbWlzZSkgIT09IG51bGwgJiYgZSAhPT0gdm9pZCAwID8gZSA6IFByb21pc2U7XG59XG5mdW5jdGlvbiBIcyh0KSB7XG4gIHJldHVybiB0ICYmIFd0KHQubmV4dCkgJiYgV3QodC5lcnJvcikgJiYgV3QodC5jb21wbGV0ZSk7XG59XG5mdW5jdGlvbiBMcyh0KSB7XG4gIHJldHVybiB0ICYmIHQgaW5zdGFuY2VvZiBvcyB8fCBIcyh0KSAmJiBhcyh0KTtcbn1cbnZhciBVcyA9IHNzKGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHQodGhpcyksIHRoaXMubmFtZSA9IFwiT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JcIiwgdGhpcy5tZXNzYWdlID0gXCJvYmplY3QgdW5zdWJzY3JpYmVkXCI7XG4gIH07XG59KSwgY3MgPSBmdW5jdGlvbih0KSB7XG4gIFFlKGUsIHQpO1xuICBmdW5jdGlvbiBlKCkge1xuICAgIHZhciByID0gdC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmV0dXJuIHIuY2xvc2VkID0gITEsIHIuY3VycmVudE9ic2VydmVycyA9IG51bGwsIHIub2JzZXJ2ZXJzID0gW10sIHIuaXNTdG9wcGVkID0gITEsIHIuaGFzRXJyb3IgPSAhMSwgci50aHJvd25FcnJvciA9IG51bGwsIHI7XG4gIH1cbiAgcmV0dXJuIGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIHMgPSBuZXcgTG4odGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHMub3BlcmF0b3IgPSByLCBzO1xuICB9LCBlLnByb3RvdHlwZS5fdGhyb3dJZkNsb3NlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNsb3NlZClcbiAgICAgIHRocm93IG5ldyBVcygpO1xuICB9LCBlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24ocikge1xuICAgIHZhciBzID0gdGhpcztcbiAgICB5cihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhLCBjO1xuICAgICAgaWYgKHMuX3Rocm93SWZDbG9zZWQoKSwgIXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHMuY3VycmVudE9ic2VydmVycyB8fCAocy5jdXJyZW50T2JzZXJ2ZXJzID0gQXJyYXkuZnJvbShzLm9ic2VydmVycykpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIGQgPSB5bihzLmN1cnJlbnRPYnNlcnZlcnMpLCBmID0gZC5uZXh0KCk7ICFmLmRvbmU7IGYgPSBkLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGIgPSBmLnZhbHVlO1xuICAgICAgICAgICAgYi5uZXh0KHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIGEgPSB7IGVycm9yOiBfIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGYgJiYgIWYuZG9uZSAmJiAoYyA9IGQucmV0dXJuKSAmJiBjLmNhbGwoZCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChhKSB0aHJvdyBhLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgcyA9IHRoaXM7XG4gICAgeXIoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocy5fdGhyb3dJZkNsb3NlZCgpLCAhcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgcy5oYXNFcnJvciA9IHMuaXNTdG9wcGVkID0gITAsIHMudGhyb3duRXJyb3IgPSByO1xuICAgICAgICBmb3IgKHZhciBhID0gcy5vYnNlcnZlcnM7IGEubGVuZ3RoOyApXG4gICAgICAgICAgYS5zaGlmdCgpLmVycm9yKHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBlLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB5cihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyLl90aHJvd0lmQ2xvc2VkKCksICFyLmlzU3RvcHBlZCkge1xuICAgICAgICByLmlzU3RvcHBlZCA9ICEwO1xuICAgICAgICBmb3IgKHZhciBzID0gci5vYnNlcnZlcnM7IHMubGVuZ3RoOyApXG4gICAgICAgICAgcy5zaGlmdCgpLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGUucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc1N0b3BwZWQgPSB0aGlzLmNsb3NlZCA9ICEwLCB0aGlzLm9ic2VydmVycyA9IHRoaXMuY3VycmVudE9ic2VydmVycyA9IG51bGw7XG4gIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSwgXCJvYnNlcnZlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByO1xuICAgICAgcmV0dXJuICgociA9IHRoaXMub2JzZXJ2ZXJzKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgPyB2b2lkIDAgOiByLmxlbmd0aCkgPiAwO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogITEsXG4gICAgY29uZmlndXJhYmxlOiAhMFxuICB9KSwgZS5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhyb3dJZkNsb3NlZCgpLCB0LnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlLmNhbGwodGhpcywgcik7XG4gIH0sIGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rocm93SWZDbG9zZWQoKSwgdGhpcy5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyhyKSwgdGhpcy5faW5uZXJTdWJzY3JpYmUocik7XG4gIH0sIGUucHJvdG90eXBlLl9pbm5lclN1YnNjcmliZSA9IGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgcyA9IHRoaXMsIGEgPSB0aGlzLCBjID0gYS5oYXNFcnJvciwgZCA9IGEuaXNTdG9wcGVkLCBmID0gYS5vYnNlcnZlcnM7XG4gICAgcmV0dXJuIGMgfHwgZCA/IGlzIDogKHRoaXMuY3VycmVudE9ic2VydmVycyA9IG51bGwsIGYucHVzaChyKSwgbmV3IGtyKGZ1bmN0aW9uKCkge1xuICAgICAgcy5jdXJyZW50T2JzZXJ2ZXJzID0gbnVsbCwgYm4oZiwgcik7XG4gICAgfSkpO1xuICB9LCBlLnByb3RvdHlwZS5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyA9IGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgcyA9IHRoaXMsIGEgPSBzLmhhc0Vycm9yLCBjID0gcy50aHJvd25FcnJvciwgZCA9IHMuaXNTdG9wcGVkO1xuICAgIGEgPyByLmVycm9yKGMpIDogZCAmJiByLmNvbXBsZXRlKCk7XG4gIH0sIGUucHJvdG90eXBlLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gbmV3IGpuKCk7XG4gICAgcmV0dXJuIHIuc291cmNlID0gdGhpcywgcjtcbiAgfSwgZS5jcmVhdGUgPSBmdW5jdGlvbihyLCBzKSB7XG4gICAgcmV0dXJuIG5ldyBMbihyLCBzKTtcbiAgfSwgZTtcbn0oam4pLCBMbiA9IGZ1bmN0aW9uKHQpIHtcbiAgUWUoZSwgdCk7XG4gIGZ1bmN0aW9uIGUociwgcykge1xuICAgIHZhciBhID0gdC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmV0dXJuIGEuZGVzdGluYXRpb24gPSByLCBhLnNvdXJjZSA9IHMsIGE7XG4gIH1cbiAgcmV0dXJuIGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIHMsIGE7XG4gICAgKGEgPSAocyA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHMubmV4dCkgPT09IG51bGwgfHwgYSA9PT0gdm9pZCAwIHx8IGEuY2FsbChzLCByKTtcbiAgfSwgZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIHMsIGE7XG4gICAgKGEgPSAocyA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHMuZXJyb3IpID09PSBudWxsIHx8IGEgPT09IHZvaWQgMCB8fCBhLmNhbGwocywgcik7XG4gIH0sIGUucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIsIHM7XG4gICAgKHMgPSAociA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIuY29tcGxldGUpID09PSBudWxsIHx8IHMgPT09IHZvaWQgMCB8fCBzLmNhbGwocik7XG4gIH0sIGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIHMsIGE7XG4gICAgcmV0dXJuIChhID0gKHMgPSB0aGlzLnNvdXJjZSkgPT09IG51bGwgfHwgcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcy5zdWJzY3JpYmUocikpICE9PSBudWxsICYmIGEgIT09IHZvaWQgMCA/IGEgOiBpcztcbiAgfSwgZTtcbn0oY3MpLCBVbiA9IGZ1bmN0aW9uKHQpIHtcbiAgUWUoZSwgdCk7XG4gIGZ1bmN0aW9uIGUocikge1xuICAgIHZhciBzID0gdC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmV0dXJuIHMuX3ZhbHVlID0gciwgcztcbiAgfVxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6ICExLFxuICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgfSksIGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIHMgPSB0LnByb3RvdHlwZS5fc3Vic2NyaWJlLmNhbGwodGhpcywgcik7XG4gICAgcmV0dXJuICFzLmNsb3NlZCAmJiByLm5leHQodGhpcy5fdmFsdWUpLCBzO1xuICB9LCBlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcywgcyA9IHIuaGFzRXJyb3IsIGEgPSByLnRocm93bkVycm9yLCBjID0gci5fdmFsdWU7XG4gICAgaWYgKHMpXG4gICAgICB0aHJvdyBhO1xuICAgIHJldHVybiB0aGlzLl90aHJvd0lmQ2xvc2VkKCksIGM7XG4gIH0sIGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihyKSB7XG4gICAgdC5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlID0gcik7XG4gIH0sIGU7XG59KGNzKSwgU3QgPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDoge307XG5mdW5jdGlvbiB4bih0KSB7XG4gIHJldHVybiB0ICYmIHQuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgXCJkZWZhdWx0XCIpID8gdC5kZWZhdWx0IDogdDtcbn1cbnZhciBnciA9IHsgZXhwb3J0czoge30gfTtcbmdyLmV4cG9ydHM7XG4oZnVuY3Rpb24odCwgZSkge1xuICB2YXIgciA9IDIwMCwgcyA9IFwiX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfX1wiLCBhID0gMSwgYyA9IDIsIGQgPSA5MDA3MTk5MjU0NzQwOTkxLCBmID0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIiwgYiA9IFwiW29iamVjdCBBcnJheV1cIiwgXyA9IFwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwiLCBNID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIEUgPSBcIltvYmplY3QgRGF0ZV1cIiwgbSA9IFwiW29iamVjdCBFcnJvcl1cIiwgVCA9IFwiW29iamVjdCBGdW5jdGlvbl1cIiwgQyA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiwgdSA9IFwiW29iamVjdCBNYXBdXCIsIGwgPSBcIltvYmplY3QgTnVtYmVyXVwiLCBTID0gXCJbb2JqZWN0IE51bGxdXCIsIHcgPSBcIltvYmplY3QgT2JqZWN0XVwiLCBrID0gXCJbb2JqZWN0IFByb21pc2VdXCIsIGggPSBcIltvYmplY3QgUHJveHldXCIsIHkgPSBcIltvYmplY3QgUmVnRXhwXVwiLCB2ID0gXCJbb2JqZWN0IFNldF1cIiwgSSA9IFwiW29iamVjdCBTdHJpbmddXCIsIHggPSBcIltvYmplY3QgU3ltYm9sXVwiLCBnID0gXCJbb2JqZWN0IFVuZGVmaW5lZF1cIiwgTyA9IFwiW29iamVjdCBXZWFrTWFwXVwiLCBEID0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiLCBqID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCBMID0gXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIiwgUiA9IFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCIsIEYgPSBcIltvYmplY3QgSW50OEFycmF5XVwiLCBWID0gXCJbb2JqZWN0IEludDE2QXJyYXldXCIsIGt0ID0gXCJbb2JqZWN0IEludDMyQXJyYXldXCIsIER0ID0gXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIsIE90ID0gXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiLCBVID0gXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiLCB6dCA9IFwiW29iamVjdCBVaW50MzJBcnJheV1cIiwgd3QgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csIGF0ID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLywgRnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvLCBBID0ge307XG4gIEFbTF0gPSBBW1JdID0gQVtGXSA9IEFbVl0gPSBBW2t0XSA9IEFbRHRdID0gQVtPdF0gPSBBW1VdID0gQVt6dF0gPSAhMCwgQVtmXSA9IEFbYl0gPSBBW0RdID0gQVtNXSA9IEFbal0gPSBBW0VdID0gQVttXSA9IEFbVF0gPSBBW3VdID0gQVtsXSA9IEFbd10gPSBBW3ldID0gQVt2XSA9IEFbSV0gPSBBW09dID0gITE7XG4gIHZhciBldCA9IHR5cGVvZiBTdCA9PSBcIm9iamVjdFwiICYmIFN0ICYmIFN0Lk9iamVjdCA9PT0gT2JqZWN0ICYmIFN0LCBNdCA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGYsIG90ID0gZXQgfHwgTXQgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpLCAkdCA9IGUgJiYgIWUubm9kZVR5cGUgJiYgZSwgRXQgPSAkdCAmJiAhMCAmJiB0ICYmICF0Lm5vZGVUeXBlICYmIHQsIEd0ID0gRXQgJiYgRXQuZXhwb3J0cyA9PT0gJHQsIFl0ID0gR3QgJiYgZXQucHJvY2VzcywgZWUgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFl0ICYmIFl0LmJpbmRpbmcgJiYgWXQuYmluZGluZyhcInV0aWxcIik7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9KCksIEJ0ID0gZWUgJiYgZWUuaXNUeXBlZEFycmF5O1xuICBmdW5jdGlvbiByZShuLCBpKSB7XG4gICAgZm9yICh2YXIgbyA9IC0xLCBwID0gbiA9PSBudWxsID8gMCA6IG4ubGVuZ3RoLCBOID0gMCwgUCA9IFtdOyArK28gPCBwOyApIHtcbiAgICAgIHZhciBHID0gbltvXTtcbiAgICAgIGkoRywgbywgbikgJiYgKFBbTisrXSA9IEcpO1xuICAgIH1cbiAgICByZXR1cm4gUDtcbiAgfVxuICBmdW5jdGlvbiBYdChuLCBpKSB7XG4gICAgZm9yICh2YXIgbyA9IC0xLCBwID0gaS5sZW5ndGgsIE4gPSBuLmxlbmd0aDsgKytvIDwgcDsgKVxuICAgICAgbltOICsgb10gPSBpW29dO1xuICAgIHJldHVybiBuO1xuICB9XG4gIGZ1bmN0aW9uIG5lKG4sIGkpIHtcbiAgICBmb3IgKHZhciBvID0gLTEsIHAgPSBuID09IG51bGwgPyAwIDogbi5sZW5ndGg7ICsrbyA8IHA7IClcbiAgICAgIGlmIChpKG5bb10sIG8sIG4pKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIF9lKG4sIGkpIHtcbiAgICBmb3IgKHZhciBvID0gLTEsIHAgPSBBcnJheShuKTsgKytvIDwgbjsgKVxuICAgICAgcFtvXSA9IGkobyk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZnVuY3Rpb24ga2Uobikge1xuICAgIHJldHVybiBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gbihpKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIE50KG4sIGkpIHtcbiAgICByZXR1cm4gbi5oYXMoaSk7XG4gIH1cbiAgZnVuY3Rpb24gS3QobiwgaSkge1xuICAgIHJldHVybiBuID09IG51bGwgPyB2b2lkIDAgOiBuW2ldO1xuICB9XG4gIGZ1bmN0aW9uICQobikge1xuICAgIHZhciBpID0gLTEsIG8gPSBBcnJheShuLnNpemUpO1xuICAgIHJldHVybiBuLmZvckVhY2goZnVuY3Rpb24ocCwgTikge1xuICAgICAgb1srK2ldID0gW04sIHBdO1xuICAgIH0pLCBvO1xuICB9XG4gIGZ1bmN0aW9uIEgobiwgaSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gbihpKG8pKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHoobikge1xuICAgIHZhciBpID0gLTEsIG8gPSBBcnJheShuLnNpemUpO1xuICAgIHJldHVybiBuLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgb1srK2ldID0gcDtcbiAgICB9KSwgbztcbiAgfVxuICB2YXIgcnQgPSBBcnJheS5wcm90b3R5cGUsIGN0ID0gRnVuY3Rpb24ucHJvdG90eXBlLCBCID0gT2JqZWN0LnByb3RvdHlwZSwgdXQgPSBvdFtcIl9fY29yZS1qc19zaGFyZWRfX1wiXSwgcSA9IGN0LnRvU3RyaW5nLCBodCA9IEIuaGFzT3duUHJvcGVydHksIFNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSAvW14uXSskLy5leGVjKHV0ICYmIHV0LmtleXMgJiYgdXQua2V5cy5JRV9QUk9UTyB8fCBcIlwiKTtcbiAgICByZXR1cm4gbiA/IFwiU3ltYm9sKHNyYylfMS5cIiArIG4gOiBcIlwiO1xuICB9KCksIHNlID0gQi50b1N0cmluZywgUGUgPSBSZWdFeHAoXG4gICAgXCJeXCIgKyBxLmNhbGwoaHQpLnJlcGxhY2Uod3QsIFwiXFxcXCQmXCIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csIFwiJDEuKj9cIikgKyBcIiRcIlxuICApLCBZID0gR3QgPyBvdC5CdWZmZXIgOiB2b2lkIDAsIG10ID0gb3QuU3ltYm9sLCBWdCA9IG90LlVpbnQ4QXJyYXksIHF0ID0gQi5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgVHQgPSBydC5zcGxpY2UsIEF0ID0gbXQgPyBtdC50b1N0cmluZ1RhZyA6IHZvaWQgMCwgd2UgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBSZSA9IFkgPyBZLmlzQnVmZmVyIDogdm9pZCAwLCBpZSA9IEgoT2JqZWN0LmtleXMsIE9iamVjdCksIHplID0gSHQob3QsIFwiRGF0YVZpZXdcIiksIGFlID0gSHQob3QsIFwiTWFwXCIpLCBGZSA9IEh0KG90LCBcIlByb21pc2VcIiksICRlID0gSHQob3QsIFwiU2V0XCIpLCBOZSA9IEh0KG90LCBcIldlYWtNYXBcIiksIEp0ID0gSHQoT2JqZWN0LCBcImNyZWF0ZVwiKSwgcnIgPSB5dCh6ZSksIGp0ID0geXQoYWUpLCBFciA9IHl0KEZlKSwgVHIgPSB5dCgkZSksIEFyID0geXQoTmUpLCBuciA9IG10ID8gbXQucHJvdG90eXBlIDogdm9pZCAwLCBqZSA9IG5yID8gbnIudmFsdWVPZiA6IHZvaWQgMDtcbiAgZnVuY3Rpb24gbnQobikge1xuICAgIHZhciBpID0gLTEsIG8gPSBuID09IG51bGwgPyAwIDogbi5sZW5ndGg7XG4gICAgZm9yICh0aGlzLmNsZWFyKCk7ICsraSA8IG87ICkge1xuICAgICAgdmFyIHAgPSBuW2ldO1xuICAgICAgdGhpcy5zZXQocFswXSwgcFsxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHhyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBKdCA/IEp0KG51bGwpIDoge30sIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gRHIobikge1xuICAgIHZhciBpID0gdGhpcy5oYXMobikgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19bbl07XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSAtPSBpID8gMSA6IDAsIGk7XG4gIH1cbiAgZnVuY3Rpb24gT3Iobikge1xuICAgIHZhciBpID0gdGhpcy5fX2RhdGFfXztcbiAgICBpZiAoSnQpIHtcbiAgICAgIHZhciBvID0gaVtuXTtcbiAgICAgIHJldHVybiBvID09PSBzID8gdm9pZCAwIDogbztcbiAgICB9XG4gICAgcmV0dXJuIGh0LmNhbGwoaSwgbikgPyBpW25dIDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIENyKG4pIHtcbiAgICB2YXIgaSA9IHRoaXMuX19kYXRhX187XG4gICAgcmV0dXJuIEp0ID8gaVtuXSAhPT0gdm9pZCAwIDogaHQuY2FsbChpLCBuKTtcbiAgfVxuICBmdW5jdGlvbiBQcihuLCBpKSB7XG4gICAgdmFyIG8gPSB0aGlzLl9fZGF0YV9fO1xuICAgIHJldHVybiB0aGlzLnNpemUgKz0gdGhpcy5oYXMobikgPyAwIDogMSwgb1tuXSA9IEp0ICYmIGkgPT09IHZvaWQgMCA/IHMgOiBpLCB0aGlzO1xuICB9XG4gIG50LnByb3RvdHlwZS5jbGVhciA9IHhyLCBudC5wcm90b3R5cGUuZGVsZXRlID0gRHIsIG50LnByb3RvdHlwZS5nZXQgPSBPciwgbnQucHJvdG90eXBlLmhhcyA9IENyLCBudC5wcm90b3R5cGUuc2V0ID0gUHI7XG4gIGZ1bmN0aW9uIGx0KG4pIHtcbiAgICB2YXIgaSA9IC0xLCBvID0gbiA9PSBudWxsID8gMCA6IG4ubGVuZ3RoO1xuICAgIGZvciAodGhpcy5jbGVhcigpOyArK2kgPCBvOyApIHtcbiAgICAgIHZhciBwID0gbltpXTtcbiAgICAgIHRoaXMuc2V0KHBbMF0sIHBbMV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBScigpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gW10sIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24genIobikge1xuICAgIHZhciBpID0gdGhpcy5fX2RhdGFfXywgbyA9IFRlKGksIG4pO1xuICAgIGlmIChvIDwgMClcbiAgICAgIHJldHVybiAhMTtcbiAgICB2YXIgcCA9IGkubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gbyA9PSBwID8gaS5wb3AoKSA6IFR0LmNhbGwoaSwgbywgMSksIC0tdGhpcy5zaXplLCAhMDtcbiAgfVxuICBmdW5jdGlvbiBGcihuKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9fZGF0YV9fLCBvID0gVGUoaSwgbik7XG4gICAgcmV0dXJuIG8gPCAwID8gdm9pZCAwIDogaVtvXVsxXTtcbiAgfVxuICBmdW5jdGlvbiAkcihuKSB7XG4gICAgcmV0dXJuIFRlKHRoaXMuX19kYXRhX18sIG4pID4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gTnIobiwgaSkge1xuICAgIHZhciBvID0gdGhpcy5fX2RhdGFfXywgcCA9IFRlKG8sIG4pO1xuICAgIHJldHVybiBwIDwgMCA/ICgrK3RoaXMuc2l6ZSwgby5wdXNoKFtuLCBpXSkpIDogb1twXVsxXSA9IGksIHRoaXM7XG4gIH1cbiAgbHQucHJvdG90eXBlLmNsZWFyID0gUnIsIGx0LnByb3RvdHlwZS5kZWxldGUgPSB6ciwgbHQucHJvdG90eXBlLmdldCA9IEZyLCBsdC5wcm90b3R5cGUuaGFzID0gJHIsIGx0LnByb3RvdHlwZS5zZXQgPSBOcjtcbiAgZnVuY3Rpb24gSXQobikge1xuICAgIHZhciBpID0gLTEsIG8gPSBuID09IG51bGwgPyAwIDogbi5sZW5ndGg7XG4gICAgZm9yICh0aGlzLmNsZWFyKCk7ICsraSA8IG87ICkge1xuICAgICAgdmFyIHAgPSBuW2ldO1xuICAgICAgdGhpcy5zZXQocFswXSwgcFsxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGpyKCkge1xuICAgIHRoaXMuc2l6ZSA9IDAsIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICBoYXNoOiBuZXcgbnQoKSxcbiAgICAgIG1hcDogbmV3IChhZSB8fCBsdCkoKSxcbiAgICAgIHN0cmluZzogbmV3IG50KClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIEhyKG4pIHtcbiAgICB2YXIgaSA9IHh0KHRoaXMsIG4pLmRlbGV0ZShuKTtcbiAgICByZXR1cm4gdGhpcy5zaXplIC09IGkgPyAxIDogMCwgaTtcbiAgfVxuICBmdW5jdGlvbiBMcihuKSB7XG4gICAgcmV0dXJuIHh0KHRoaXMsIG4pLmdldChuKTtcbiAgfVxuICBmdW5jdGlvbiBVcihuKSB7XG4gICAgcmV0dXJuIHh0KHRoaXMsIG4pLmhhcyhuKTtcbiAgfVxuICBmdW5jdGlvbiBXcihuLCBpKSB7XG4gICAgdmFyIG8gPSB4dCh0aGlzLCBuKSwgcCA9IG8uc2l6ZTtcbiAgICByZXR1cm4gby5zZXQobiwgaSksIHRoaXMuc2l6ZSArPSBvLnNpemUgPT0gcCA/IDAgOiAxLCB0aGlzO1xuICB9XG4gIEl0LnByb3RvdHlwZS5jbGVhciA9IGpyLCBJdC5wcm90b3R5cGUuZGVsZXRlID0gSHIsIEl0LnByb3RvdHlwZS5nZXQgPSBMciwgSXQucHJvdG90eXBlLmhhcyA9IFVyLCBJdC5wcm90b3R5cGUuc2V0ID0gV3I7XG4gIGZ1bmN0aW9uIE1lKG4pIHtcbiAgICB2YXIgaSA9IC0xLCBvID0gbiA9PSBudWxsID8gMCA6IG4ubGVuZ3RoO1xuICAgIGZvciAodGhpcy5fX2RhdGFfXyA9IG5ldyBJdCgpOyArK2kgPCBvOyApXG4gICAgICB0aGlzLmFkZChuW2ldKTtcbiAgfVxuICBmdW5jdGlvbiBzcihuKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhX18uc2V0KG4sIHMpLCB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIEVlKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMobik7XG4gIH1cbiAgTWUucHJvdG90eXBlLmFkZCA9IE1lLnByb3RvdHlwZS5wdXNoID0gc3IsIE1lLnByb3RvdHlwZS5oYXMgPSBFZTtcbiAgZnVuY3Rpb24gQ3Qobikge1xuICAgIHZhciBpID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBsdChuKTtcbiAgICB0aGlzLnNpemUgPSBpLnNpemU7XG4gIH1cbiAgZnVuY3Rpb24gSGUoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBsdCgpLCB0aGlzLnNpemUgPSAwO1xuICB9XG4gIGZ1bmN0aW9uIEdyKG4pIHtcbiAgICB2YXIgaSA9IHRoaXMuX19kYXRhX18sIG8gPSBpLmRlbGV0ZShuKTtcbiAgICByZXR1cm4gdGhpcy5zaXplID0gaS5zaXplLCBvO1xuICB9XG4gIGZ1bmN0aW9uIFlyKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQobik7XG4gIH1cbiAgZnVuY3Rpb24gQnIobikge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhuKTtcbiAgfVxuICBmdW5jdGlvbiBYcihuLCBpKSB7XG4gICAgdmFyIG8gPSB0aGlzLl9fZGF0YV9fO1xuICAgIGlmIChvIGluc3RhbmNlb2YgbHQpIHtcbiAgICAgIHZhciBwID0gby5fX2RhdGFfXztcbiAgICAgIGlmICghYWUgfHwgcC5sZW5ndGggPCByIC0gMSlcbiAgICAgICAgcmV0dXJuIHAucHVzaChbbiwgaV0pLCB0aGlzLnNpemUgPSArK28uc2l6ZSwgdGhpcztcbiAgICAgIG8gPSB0aGlzLl9fZGF0YV9fID0gbmV3IEl0KHApO1xuICAgIH1cbiAgICByZXR1cm4gby5zZXQobiwgaSksIHRoaXMuc2l6ZSA9IG8uc2l6ZSwgdGhpcztcbiAgfVxuICBDdC5wcm90b3R5cGUuY2xlYXIgPSBIZSwgQ3QucHJvdG90eXBlLmRlbGV0ZSA9IEdyLCBDdC5wcm90b3R5cGUuZ2V0ID0gWXIsIEN0LnByb3RvdHlwZS5oYXMgPSBCciwgQ3QucHJvdG90eXBlLnNldCA9IFhyO1xuICBmdW5jdGlvbiBLcihuLCBpKSB7XG4gICAgdmFyIG8gPSBBZShuKSwgcCA9ICFvICYmIHVyKG4pLCBOID0gIW8gJiYgIXAgJiYgeGUobiksIFAgPSAhbyAmJiAhcCAmJiAhTiAmJiBmcihuKSwgRyA9IG8gfHwgcCB8fCBOIHx8IFAsIFcgPSBHID8gX2Uobi5sZW5ndGgsIFN0cmluZykgOiBbXSwgSiA9IFcubGVuZ3RoO1xuICAgIGZvciAodmFyIFggaW4gbilcbiAgICAgIGh0LmNhbGwobiwgWCkgJiYgIShHICYmIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgIChYID09IFwibGVuZ3RoXCIgfHwgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICBOICYmIChYID09IFwib2Zmc2V0XCIgfHwgWCA9PSBcInBhcmVudFwiKSB8fCAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICBQICYmIChYID09IFwiYnVmZmVyXCIgfHwgWCA9PSBcImJ5dGVMZW5ndGhcIiB8fCBYID09IFwiYnl0ZU9mZnNldFwiKSB8fCAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICBybihYLCBKKSkpICYmIFcucHVzaChYKTtcbiAgICByZXR1cm4gVztcbiAgfVxuICBmdW5jdGlvbiBUZShuLCBpKSB7XG4gICAgZm9yICh2YXIgbyA9IG4ubGVuZ3RoOyBvLS07IClcbiAgICAgIGlmIChjcihuW29dWzBdLCBpKSlcbiAgICAgICAgcmV0dXJuIG87XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGZ1bmN0aW9uIExlKG4sIGksIG8pIHtcbiAgICB2YXIgcCA9IGkobik7XG4gICAgcmV0dXJuIEFlKG4pID8gcCA6IFh0KHAsIG8obikpO1xuICB9XG4gIGZ1bmN0aW9uIG9lKG4pIHtcbiAgICByZXR1cm4gbiA9PSBudWxsID8gbiA9PT0gdm9pZCAwID8gZyA6IFMgOiBBdCAmJiBBdCBpbiBPYmplY3QobikgPyBMdChuKSA6IG9yKG4pO1xuICB9XG4gIGZ1bmN0aW9uIGlyKG4pIHtcbiAgICByZXR1cm4gUnQobikgJiYgb2UobikgPT0gZjtcbiAgfVxuICBmdW5jdGlvbiBhcihuLCBpLCBvLCBwLCBOKSB7XG4gICAgcmV0dXJuIG4gPT09IGkgPyAhMCA6IG4gPT0gbnVsbCB8fCBpID09IG51bGwgfHwgIVJ0KG4pICYmICFSdChpKSA/IG4gIT09IG4gJiYgaSAhPT0gaSA6IFZyKG4sIGksIG8sIHAsIGFyLCBOKTtcbiAgfVxuICBmdW5jdGlvbiBWcihuLCBpLCBvLCBwLCBOLCBQKSB7XG4gICAgdmFyIEcgPSBBZShuKSwgVyA9IEFlKGkpLCBKID0gRyA/IGIgOiBQdChuKSwgWCA9IFcgPyBiIDogUHQoaSk7XG4gICAgSiA9IEogPT0gZiA/IHcgOiBKLCBYID0gWCA9PSBmID8gdyA6IFg7XG4gICAgdmFyIGR0ID0gSiA9PSB3LCBidCA9IFggPT0gdywgWiA9IEogPT0gWDtcbiAgICBpZiAoWiAmJiB4ZShuKSkge1xuICAgICAgaWYgKCF4ZShpKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgRyA9ICEwLCBkdCA9ICExO1xuICAgIH1cbiAgICBpZiAoWiAmJiAhZHQpXG4gICAgICByZXR1cm4gUCB8fCAoUCA9IG5ldyBDdCgpKSwgRyB8fCBmcihuKSA/IFVlKG4sIGksIG8sIHAsIE4sIFApIDogUXIobiwgaSwgSiwgbywgcCwgTiwgUCk7XG4gICAgaWYgKCEobyAmIGEpKSB7XG4gICAgICB2YXIgZnQgPSBkdCAmJiBodC5jYWxsKG4sIFwiX193cmFwcGVkX19cIiksIHN0ID0gYnQgJiYgaHQuY2FsbChpLCBcIl9fd3JhcHBlZF9fXCIpO1xuICAgICAgaWYgKGZ0IHx8IHN0KSB7XG4gICAgICAgIHZhciBadCA9IGZ0ID8gbi52YWx1ZSgpIDogbiwgVXQgPSBzdCA/IGkudmFsdWUoKSA6IGk7XG4gICAgICAgIHJldHVybiBQIHx8IChQID0gbmV3IEN0KCkpLCBOKFp0LCBVdCwgbywgcCwgUCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBaID8gKFAgfHwgKFAgPSBuZXcgQ3QoKSksIHRuKG4sIGksIG8sIHAsIE4sIFApKSA6ICExO1xuICB9XG4gIGZ1bmN0aW9uIHFyKG4pIHtcbiAgICBpZiAoIWRyKG4pIHx8IHNuKG4pKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBpID0gbHIobikgPyBQZSA6IGF0O1xuICAgIHJldHVybiBpLnRlc3QoeXQobikpO1xuICB9XG4gIGZ1bmN0aW9uIEpyKG4pIHtcbiAgICByZXR1cm4gUnQobikgJiYgR2Uobi5sZW5ndGgpICYmICEhQVtvZShuKV07XG4gIH1cbiAgZnVuY3Rpb24gWnIobikge1xuICAgIGlmICghYW4obikpXG4gICAgICByZXR1cm4gaWUobik7XG4gICAgdmFyIGkgPSBbXTtcbiAgICBmb3IgKHZhciBvIGluIE9iamVjdChuKSlcbiAgICAgIGh0LmNhbGwobiwgbykgJiYgbyAhPSBcImNvbnN0cnVjdG9yXCIgJiYgaS5wdXNoKG8pO1xuICAgIHJldHVybiBpO1xuICB9XG4gIGZ1bmN0aW9uIFVlKG4sIGksIG8sIHAsIE4sIFApIHtcbiAgICB2YXIgRyA9IG8gJiBhLCBXID0gbi5sZW5ndGgsIEogPSBpLmxlbmd0aDtcbiAgICBpZiAoVyAhPSBKICYmICEoRyAmJiBKID4gVykpXG4gICAgICByZXR1cm4gITE7XG4gICAgdmFyIFggPSBQLmdldChuKTtcbiAgICBpZiAoWCAmJiBQLmdldChpKSlcbiAgICAgIHJldHVybiBYID09IGk7XG4gICAgdmFyIGR0ID0gLTEsIGJ0ID0gITAsIFogPSBvICYgYyA/IG5ldyBNZSgpIDogdm9pZCAwO1xuICAgIGZvciAoUC5zZXQobiwgaSksIFAuc2V0KGksIG4pOyArK2R0IDwgVzsgKSB7XG4gICAgICB2YXIgZnQgPSBuW2R0XSwgc3QgPSBpW2R0XTtcbiAgICAgIGlmIChwKVxuICAgICAgICB2YXIgWnQgPSBHID8gcChzdCwgZnQsIGR0LCBpLCBuLCBQKSA6IHAoZnQsIHN0LCBkdCwgbiwgaSwgUCk7XG4gICAgICBpZiAoWnQgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoWnQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGJ0ID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKFopIHtcbiAgICAgICAgaWYgKCFuZShpLCBmdW5jdGlvbihVdCwgdWUpIHtcbiAgICAgICAgICBpZiAoIU50KFosIHVlKSAmJiAoZnQgPT09IFV0IHx8IE4oZnQsIFV0LCBvLCBwLCBQKSkpXG4gICAgICAgICAgICByZXR1cm4gWi5wdXNoKHVlKTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBidCA9ICExO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEoZnQgPT09IHN0IHx8IE4oZnQsIHN0LCBvLCBwLCBQKSkpIHtcbiAgICAgICAgYnQgPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQLmRlbGV0ZShuKSwgUC5kZWxldGUoaSksIGJ0O1xuICB9XG4gIGZ1bmN0aW9uIFFyKG4sIGksIG8sIHAsIE4sIFAsIEcpIHtcbiAgICBzd2l0Y2ggKG8pIHtcbiAgICAgIGNhc2UgajpcbiAgICAgICAgaWYgKG4uYnl0ZUxlbmd0aCAhPSBpLmJ5dGVMZW5ndGggfHwgbi5ieXRlT2Zmc2V0ICE9IGkuYnl0ZU9mZnNldClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIG4gPSBuLmJ1ZmZlciwgaSA9IGkuYnVmZmVyO1xuICAgICAgY2FzZSBEOlxuICAgICAgICByZXR1cm4gIShuLmJ5dGVMZW5ndGggIT0gaS5ieXRlTGVuZ3RoIHx8ICFQKG5ldyBWdChuKSwgbmV3IFZ0KGkpKSk7XG4gICAgICBjYXNlIE06XG4gICAgICBjYXNlIEU6XG4gICAgICBjYXNlIGw6XG4gICAgICAgIHJldHVybiBjcigrbiwgK2kpO1xuICAgICAgY2FzZSBtOlxuICAgICAgICByZXR1cm4gbi5uYW1lID09IGkubmFtZSAmJiBuLm1lc3NhZ2UgPT0gaS5tZXNzYWdlO1xuICAgICAgY2FzZSB5OlxuICAgICAgY2FzZSBJOlxuICAgICAgICByZXR1cm4gbiA9PSBpICsgXCJcIjtcbiAgICAgIGNhc2UgdTpcbiAgICAgICAgdmFyIFcgPSAkO1xuICAgICAgY2FzZSB2OlxuICAgICAgICB2YXIgSiA9IHAgJiBhO1xuICAgICAgICBpZiAoVyB8fCAoVyA9IHopLCBuLnNpemUgIT0gaS5zaXplICYmICFKKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgdmFyIFggPSBHLmdldChuKTtcbiAgICAgICAgaWYgKFgpXG4gICAgICAgICAgcmV0dXJuIFggPT0gaTtcbiAgICAgICAgcCB8PSBjLCBHLnNldChuLCBpKTtcbiAgICAgICAgdmFyIGR0ID0gVWUoVyhuKSwgVyhpKSwgcCwgTiwgUCwgRyk7XG4gICAgICAgIHJldHVybiBHLmRlbGV0ZShuKSwgZHQ7XG4gICAgICBjYXNlIHg6XG4gICAgICAgIGlmIChqZSlcbiAgICAgICAgICByZXR1cm4gamUuY2FsbChuKSA9PSBqZS5jYWxsKGkpO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gdG4obiwgaSwgbywgcCwgTiwgUCkge1xuICAgIHZhciBHID0gbyAmIGEsIFcgPSBjZShuKSwgSiA9IFcubGVuZ3RoLCBYID0gY2UoaSksIGR0ID0gWC5sZW5ndGg7XG4gICAgaWYgKEogIT0gZHQgJiYgIUcpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yICh2YXIgYnQgPSBKOyBidC0tOyApIHtcbiAgICAgIHZhciBaID0gV1tidF07XG4gICAgICBpZiAoIShHID8gWiBpbiBpIDogaHQuY2FsbChpLCBaKSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgdmFyIGZ0ID0gUC5nZXQobik7XG4gICAgaWYgKGZ0ICYmIFAuZ2V0KGkpKVxuICAgICAgcmV0dXJuIGZ0ID09IGk7XG4gICAgdmFyIHN0ID0gITA7XG4gICAgUC5zZXQobiwgaSksIFAuc2V0KGksIG4pO1xuICAgIGZvciAodmFyIFp0ID0gRzsgKytidCA8IEo7ICkge1xuICAgICAgWiA9IFdbYnRdO1xuICAgICAgdmFyIFV0ID0gbltaXSwgdWUgPSBpW1pdO1xuICAgICAgaWYgKHApXG4gICAgICAgIHZhciBGbiA9IEcgPyBwKHVlLCBVdCwgWiwgaSwgbiwgUCkgOiBwKFV0LCB1ZSwgWiwgbiwgaSwgUCk7XG4gICAgICBpZiAoIShGbiA9PT0gdm9pZCAwID8gVXQgPT09IHVlIHx8IE4oVXQsIHVlLCBvLCBwLCBQKSA6IEZuKSkge1xuICAgICAgICBzdCA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFp0IHx8IChadCA9IFogPT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICB9XG4gICAgaWYgKHN0ICYmICFadCkge1xuICAgICAgdmFyIHByID0gbi5jb25zdHJ1Y3RvciwgaHIgPSBpLmNvbnN0cnVjdG9yO1xuICAgICAgcHIgIT0gaHIgJiYgXCJjb25zdHJ1Y3RvclwiIGluIG4gJiYgXCJjb25zdHJ1Y3RvclwiIGluIGkgJiYgISh0eXBlb2YgcHIgPT0gXCJmdW5jdGlvblwiICYmIHByIGluc3RhbmNlb2YgcHIgJiYgdHlwZW9mIGhyID09IFwiZnVuY3Rpb25cIiAmJiBociBpbnN0YW5jZW9mIGhyKSAmJiAoc3QgPSAhMSk7XG4gICAgfVxuICAgIHJldHVybiBQLmRlbGV0ZShuKSwgUC5kZWxldGUoaSksIHN0O1xuICB9XG4gIGZ1bmN0aW9uIGNlKG4pIHtcbiAgICByZXR1cm4gTGUobiwgWWUsIGVuKTtcbiAgfVxuICBmdW5jdGlvbiB4dChuLCBpKSB7XG4gICAgdmFyIG8gPSBuLl9fZGF0YV9fO1xuICAgIHJldHVybiBubihpKSA/IG9bdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IFwic3RyaW5nXCIgOiBcImhhc2hcIl0gOiBvLm1hcDtcbiAgfVxuICBmdW5jdGlvbiBIdChuLCBpKSB7XG4gICAgdmFyIG8gPSBLdChuLCBpKTtcbiAgICByZXR1cm4gcXIobykgPyBvIDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIEx0KG4pIHtcbiAgICB2YXIgaSA9IGh0LmNhbGwobiwgQXQpLCBvID0gbltBdF07XG4gICAgdHJ5IHtcbiAgICAgIG5bQXRdID0gdm9pZCAwO1xuICAgICAgdmFyIHAgPSAhMDtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgdmFyIE4gPSBzZS5jYWxsKG4pO1xuICAgIHJldHVybiBwICYmIChpID8gbltBdF0gPSBvIDogZGVsZXRlIG5bQXRdKSwgTjtcbiAgfVxuICB2YXIgZW4gPSB3ZSA/IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gbiA9PSBudWxsID8gW10gOiAobiA9IE9iamVjdChuKSwgcmUod2UobiksIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBxdC5jYWxsKG4sIGkpO1xuICAgIH0pKTtcbiAgfSA6IGNuLCBQdCA9IG9lO1xuICAoemUgJiYgUHQobmV3IHplKG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGogfHwgYWUgJiYgUHQobmV3IGFlKCkpICE9IHUgfHwgRmUgJiYgUHQoRmUucmVzb2x2ZSgpKSAhPSBrIHx8ICRlICYmIFB0KG5ldyAkZSgpKSAhPSB2IHx8IE5lICYmIFB0KG5ldyBOZSgpKSAhPSBPKSAmJiAoUHQgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGkgPSBvZShuKSwgbyA9IGkgPT0gdyA/IG4uY29uc3RydWN0b3IgOiB2b2lkIDAsIHAgPSBvID8geXQobykgOiBcIlwiO1xuICAgIGlmIChwKVxuICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgIGNhc2UgcnI6XG4gICAgICAgICAgcmV0dXJuIGo7XG4gICAgICAgIGNhc2UganQ6XG4gICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgIGNhc2UgRXI6XG4gICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgIGNhc2UgVHI6XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgQXI6XG4gICAgICAgICAgcmV0dXJuIE87XG4gICAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0pO1xuICBmdW5jdGlvbiBybihuLCBpKSB7XG4gICAgcmV0dXJuIGkgPSBpID8/IGQsICEhaSAmJiAodHlwZW9mIG4gPT0gXCJudW1iZXJcIiB8fCBGdC50ZXN0KG4pKSAmJiBuID4gLTEgJiYgbiAlIDEgPT0gMCAmJiBuIDwgaTtcbiAgfVxuICBmdW5jdGlvbiBubihuKSB7XG4gICAgdmFyIGkgPSB0eXBlb2YgbjtcbiAgICByZXR1cm4gaSA9PSBcInN0cmluZ1wiIHx8IGkgPT0gXCJudW1iZXJcIiB8fCBpID09IFwic3ltYm9sXCIgfHwgaSA9PSBcImJvb2xlYW5cIiA/IG4gIT09IFwiX19wcm90b19fXCIgOiBuID09PSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHNuKG4pIHtcbiAgICByZXR1cm4gISFTZSAmJiBTZSBpbiBuO1xuICB9XG4gIGZ1bmN0aW9uIGFuKG4pIHtcbiAgICB2YXIgaSA9IG4gJiYgbi5jb25zdHJ1Y3RvciwgbyA9IHR5cGVvZiBpID09IFwiZnVuY3Rpb25cIiAmJiBpLnByb3RvdHlwZSB8fCBCO1xuICAgIHJldHVybiBuID09PSBvO1xuICB9XG4gIGZ1bmN0aW9uIG9yKG4pIHtcbiAgICByZXR1cm4gc2UuY2FsbChuKTtcbiAgfVxuICBmdW5jdGlvbiB5dChuKSB7XG4gICAgaWYgKG4gIT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHEuY2FsbChuKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG4gKyBcIlwiO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGNyKG4sIGkpIHtcbiAgICByZXR1cm4gbiA9PT0gaSB8fCBuICE9PSBuICYmIGkgIT09IGk7XG4gIH1cbiAgdmFyIHVyID0gaXIoLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmd1bWVudHM7XG4gIH0oKSkgPyBpciA6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gUnQobikgJiYgaHQuY2FsbChuLCBcImNhbGxlZVwiKSAmJiAhcXQuY2FsbChuLCBcImNhbGxlZVwiKTtcbiAgfSwgQWUgPSBBcnJheS5pc0FycmF5O1xuICBmdW5jdGlvbiBXZShuKSB7XG4gICAgcmV0dXJuIG4gIT0gbnVsbCAmJiBHZShuLmxlbmd0aCkgJiYgIWxyKG4pO1xuICB9XG4gIHZhciB4ZSA9IFJlIHx8IHVuO1xuICBmdW5jdGlvbiBvbihuLCBpKSB7XG4gICAgcmV0dXJuIGFyKG4sIGkpO1xuICB9XG4gIGZ1bmN0aW9uIGxyKG4pIHtcbiAgICBpZiAoIWRyKG4pKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBpID0gb2Uobik7XG4gICAgcmV0dXJuIGkgPT0gVCB8fCBpID09IEMgfHwgaSA9PSBfIHx8IGkgPT0gaDtcbiAgfVxuICBmdW5jdGlvbiBHZShuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09IFwibnVtYmVyXCIgJiYgbiA+IC0xICYmIG4gJSAxID09IDAgJiYgbiA8PSBkO1xuICB9XG4gIGZ1bmN0aW9uIGRyKG4pIHtcbiAgICB2YXIgaSA9IHR5cGVvZiBuO1xuICAgIHJldHVybiBuICE9IG51bGwgJiYgKGkgPT0gXCJvYmplY3RcIiB8fCBpID09IFwiZnVuY3Rpb25cIik7XG4gIH1cbiAgZnVuY3Rpb24gUnQobikge1xuICAgIHJldHVybiBuICE9IG51bGwgJiYgdHlwZW9mIG4gPT0gXCJvYmplY3RcIjtcbiAgfVxuICB2YXIgZnIgPSBCdCA/IGtlKEJ0KSA6IEpyO1xuICBmdW5jdGlvbiBZZShuKSB7XG4gICAgcmV0dXJuIFdlKG4pID8gS3IobikgOiBacihuKTtcbiAgfVxuICBmdW5jdGlvbiBjbigpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZnVuY3Rpb24gdW4oKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHQuZXhwb3J0cyA9IG9uO1xufSkoZ3IsIGdyLmV4cG9ydHMpO1xudmFyIFdzID0gZ3IuZXhwb3J0cztcbmNvbnN0IFEgPSAvKiBAX19QVVJFX18gKi8geG4oV3MpLCBBYSA9IFwiYWRkXCIsIEdzID0gXCJ0cmFja1wiLCBZcyA9IFwidHJhY2tJdGVtc1wiLCB4YSA9IGAke0dzfTpjaGFuZ2VkYCwgRGEgPSBgJHtZc306Y2hhbmdlZGAsIEJzID0gXCJzdGF0ZVwiLCBPYSA9IGAke0JzfTpjaGFuZ2VkYCwgRG4gPSBcImRlc2lnblwiLCBYcyA9IGAke0RufTpsb2FkYCwgS3MgPSBgJHtEbn06cmVzaXplYCwgZ3QgPSBcImFkZFwiLCBWcyA9IGAke2d0fTp0ZXh0YCwgcXMgPSBgJHtndH06dmlkZW9gLCBKcyA9IGAke2d0fTphdWRpb2AsIENhID0gYCR7Z3R9OnBsYWNlaG9sZGVyYCwgWnMgPSBgJHtndH06aW1hZ2VgLCBRcyA9IGAke2d0fTppbGx1c3RyYXRpb25gLCB0aSA9IGAke2d0fTpzaGFwZWAsIFBhID0gYCR7Z3R9Om1hc2tgLCBSYSA9IGAke2d0fTp0cmFuc2l0aW9uYCwgZWkgPSBgJHtndH06YW5pbWF0aW9uYCwgcmkgPSBgJHtndH06Y2FwdGlvbmAsIG5pID0gYCR7Z3R9OnRlbXBsYXRlYCwgc2kgPSBgJHtndH06aXRlbXNgLCBpaSA9IGAke2d0fTpjb21wb3NpdGlvbmAsIGJlID0gXCJlZGl0XCIsIGFpID0gYCR7YmV9Om9iamVjdGAsIG9pID0gYCR7YmV9OnJlcGxhY2VNZWRpYWAsIHphID0gYCR7YmV9OnRleHRgLCBGYSA9IGAke2JlfTpzaGFwZWAsICRhID0gYCR7YmV9OnRlbXBsYXRlSXRlbWAsIE5hID0gYCR7YmV9OmRlbGV0ZVRlbXBsYXRlSXRlbWAsIGphID0gXCJlbnRlckVkaXRNb2RlXCIsIENlID0gXCJhY3RpdmVcIiwgSGEgPSBgJHtDZX06c2V0YCwgTGEgPSBgJHtDZX06ZGVsZXRlYCwgY2kgPSBgJHtDZX06cGFzdGVgLCB1aSA9IGAke0NlfTpjbG9uZWAsIGxpID0gYCR7Q2V9OnNwbGl0YCwgcHQgPSBcImxheWVyXCIsIFVhID0gYCR7cHR9OmxvY2tlZGAsIFdhID0gYCR7cHR9OmhpZGRlbmAsIEdhID0gYCR7cHR9Om1vdmVgLCBZYSA9IGAke3B0fTpzZWxlY3RgLCBCYSA9IGAke3B0fTpzZWxlY3Rpb25gLCBYYSA9IGAke3B0fTpzZW5kVG9gLCBLYSA9IGAke3B0fTpyZW5hbWVgLCBWYSA9IGAke3B0fTplZGl0aW5nTmFtZWAsIHFhID0gYCR7cHR9OmNvcHlgLCBKYSA9IGAke3B0fTpwYXN0ZWAsIGRpID0gYCR7cHR9OmNsb25lYCwgWmEgPSBgJHtwdH06c3BsaXRgLCBRYSA9IGAke3B0fTpjdXRgLCBmaSA9IGAke3B0fTpkZWxldGVgLCBwaSA9IGAke3B0fTpyZXBsYWNlYCwgU3IgPSBcImhpc3RvcnlcIiwgaGkgPSBgJHtTcn06dW5kb2AsIG1pID0gYCR7U3J9OnJlZG9gLCB0byA9IGAke1NyfTpyZXNldGAsIHVzID0gXCJzY2FsZVwiLCB5aSA9IGAke3VzfTpjaGFuZ2VkYDtcbnZhciBJciA9IHsgZXhwb3J0czoge30gfTtcbklyLmV4cG9ydHM7XG4oZnVuY3Rpb24odCwgZSkge1xuICB2YXIgciA9IDIwMCwgcyA9IFwiX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfX1wiLCBhID0gOTAwNzE5OTI1NDc0MDk5MSwgYyA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIGQgPSBcIltvYmplY3QgQXJyYXldXCIsIGYgPSBcIltvYmplY3QgQm9vbGVhbl1cIiwgYiA9IFwiW29iamVjdCBEYXRlXVwiLCBfID0gXCJbb2JqZWN0IEVycm9yXVwiLCBNID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLCBFID0gXCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiLCBtID0gXCJbb2JqZWN0IE1hcF1cIiwgVCA9IFwiW29iamVjdCBOdW1iZXJdXCIsIEMgPSBcIltvYmplY3QgT2JqZWN0XVwiLCB1ID0gXCJbb2JqZWN0IFByb21pc2VdXCIsIGwgPSBcIltvYmplY3QgUmVnRXhwXVwiLCBTID0gXCJbb2JqZWN0IFNldF1cIiwgdyA9IFwiW29iamVjdCBTdHJpbmddXCIsIGsgPSBcIltvYmplY3QgU3ltYm9sXVwiLCBoID0gXCJbb2JqZWN0IFdlYWtNYXBdXCIsIHkgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsIHYgPSBcIltvYmplY3QgRGF0YVZpZXddXCIsIEkgPSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiLCB4ID0gXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIiwgZyA9IFwiW29iamVjdCBJbnQ4QXJyYXldXCIsIE8gPSBcIltvYmplY3QgSW50MTZBcnJheV1cIiwgRCA9IFwiW29iamVjdCBJbnQzMkFycmF5XVwiLCBqID0gXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIsIEwgPSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsIFIgPSBcIltvYmplY3QgVWludDE2QXJyYXldXCIsIEYgPSBcIltvYmplY3QgVWludDMyQXJyYXldXCIsIFYgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csIGt0ID0gL1xcdyokLywgRHQgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvLCBPdCA9IC9eKD86MHxbMS05XVxcZCopJC8sIFUgPSB7fTtcbiAgVVtjXSA9IFVbZF0gPSBVW3ldID0gVVt2XSA9IFVbZl0gPSBVW2JdID0gVVtJXSA9IFVbeF0gPSBVW2ddID0gVVtPXSA9IFVbRF0gPSBVW21dID0gVVtUXSA9IFVbQ10gPSBVW2xdID0gVVtTXSA9IFVbd10gPSBVW2tdID0gVVtqXSA9IFVbTF0gPSBVW1JdID0gVVtGXSA9ICEwLCBVW19dID0gVVtNXSA9IFVbaF0gPSAhMTtcbiAgdmFyIHp0ID0gdHlwZW9mIFN0ID09IFwib2JqZWN0XCIgJiYgU3QgJiYgU3QuT2JqZWN0ID09PSBPYmplY3QgJiYgU3QsIHd0ID0gdHlwZW9mIHNlbGYgPT0gXCJvYmplY3RcIiAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZiwgYXQgPSB6dCB8fCB3dCB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCksIEZ0ID0gZSAmJiAhZS5ub2RlVHlwZSAmJiBlLCBBID0gRnQgJiYgITAgJiYgdCAmJiAhdC5ub2RlVHlwZSAmJiB0LCBldCA9IEEgJiYgQS5leHBvcnRzID09PSBGdDtcbiAgZnVuY3Rpb24gTXQobiwgaSkge1xuICAgIHJldHVybiBuLnNldChpWzBdLCBpWzFdKSwgbjtcbiAgfVxuICBmdW5jdGlvbiBvdChuLCBpKSB7XG4gICAgcmV0dXJuIG4uYWRkKGkpLCBuO1xuICB9XG4gIGZ1bmN0aW9uICR0KG4sIGkpIHtcbiAgICBmb3IgKHZhciBvID0gLTEsIHAgPSBuID8gbi5sZW5ndGggOiAwOyArK28gPCBwICYmIGkobltvXSwgbywgbikgIT09ICExOyApXG4gICAgICA7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgZnVuY3Rpb24gRXQobiwgaSkge1xuICAgIGZvciAodmFyIG8gPSAtMSwgcCA9IGkubGVuZ3RoLCBOID0gbi5sZW5ndGg7ICsrbyA8IHA7IClcbiAgICAgIG5bTiArIG9dID0gaVtvXTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBmdW5jdGlvbiBHdChuLCBpLCBvLCBwKSB7XG4gICAgZm9yICh2YXIgTiA9IC0xLCBQID0gbiA/IG4ubGVuZ3RoIDogMDsgKytOIDwgUDsgKVxuICAgICAgbyA9IGkobywgbltOXSwgTiwgbik7XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgZnVuY3Rpb24gWXQobiwgaSkge1xuICAgIGZvciAodmFyIG8gPSAtMSwgcCA9IEFycmF5KG4pOyArK28gPCBuOyApXG4gICAgICBwW29dID0gaShvKTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBmdW5jdGlvbiBlZShuLCBpKSB7XG4gICAgcmV0dXJuIG4gPT0gbnVsbCA/IHZvaWQgMCA6IG5baV07XG4gIH1cbiAgZnVuY3Rpb24gQnQobikge1xuICAgIHZhciBpID0gITE7XG4gICAgaWYgKG4gIT0gbnVsbCAmJiB0eXBlb2Ygbi50b1N0cmluZyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0cnkge1xuICAgICAgICBpID0gISEobiArIFwiXCIpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgZnVuY3Rpb24gcmUobikge1xuICAgIHZhciBpID0gLTEsIG8gPSBBcnJheShuLnNpemUpO1xuICAgIHJldHVybiBuLmZvckVhY2goZnVuY3Rpb24ocCwgTikge1xuICAgICAgb1srK2ldID0gW04sIHBdO1xuICAgIH0pLCBvO1xuICB9XG4gIGZ1bmN0aW9uIFh0KG4sIGkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIG4oaShvKSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBuZShuKSB7XG4gICAgdmFyIGkgPSAtMSwgbyA9IEFycmF5KG4uc2l6ZSk7XG4gICAgcmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICBvWysraV0gPSBwO1xuICAgIH0pLCBvO1xuICB9XG4gIHZhciBfZSA9IEFycmF5LnByb3RvdHlwZSwga2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsIE50ID0gT2JqZWN0LnByb3RvdHlwZSwgS3QgPSBhdFtcIl9fY29yZS1qc19zaGFyZWRfX1wiXSwgJCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gL1teLl0rJC8uZXhlYyhLdCAmJiBLdC5rZXlzICYmIEt0LmtleXMuSUVfUFJPVE8gfHwgXCJcIik7XG4gICAgcmV0dXJuIG4gPyBcIlN5bWJvbChzcmMpXzEuXCIgKyBuIDogXCJcIjtcbiAgfSgpLCBIID0ga2UudG9TdHJpbmcsIHogPSBOdC5oYXNPd25Qcm9wZXJ0eSwgcnQgPSBOdC50b1N0cmluZywgY3QgPSBSZWdFeHAoXG4gICAgXCJeXCIgKyBILmNhbGwoeikucmVwbGFjZShWLCBcIlxcXFwkJlwiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCBcIiQxLio/XCIpICsgXCIkXCJcbiAgKSwgQiA9IGV0ID8gYXQuQnVmZmVyIDogdm9pZCAwLCB1dCA9IGF0LlN5bWJvbCwgcSA9IGF0LlVpbnQ4QXJyYXksIGh0ID0gWHQoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLCBTZSA9IE9iamVjdC5jcmVhdGUsIHNlID0gTnQucHJvcGVydHlJc0VudW1lcmFibGUsIFBlID0gX2Uuc3BsaWNlLCBZID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgbXQgPSBCID8gQi5pc0J1ZmZlciA6IHZvaWQgMCwgVnQgPSBYdChPYmplY3Qua2V5cywgT2JqZWN0KSwgcXQgPSB4dChhdCwgXCJEYXRhVmlld1wiKSwgVHQgPSB4dChhdCwgXCJNYXBcIiksIEF0ID0geHQoYXQsIFwiUHJvbWlzZVwiKSwgd2UgPSB4dChhdCwgXCJTZXRcIiksIFJlID0geHQoYXQsIFwiV2Vha01hcFwiKSwgaWUgPSB4dChPYmplY3QsIFwiY3JlYXRlXCIpLCB6ZSA9IHl0KHF0KSwgYWUgPSB5dChUdCksIEZlID0geXQoQXQpLCAkZSA9IHl0KHdlKSwgTmUgPSB5dChSZSksIEp0ID0gdXQgPyB1dC5wcm90b3R5cGUgOiB2b2lkIDAsIHJyID0gSnQgPyBKdC52YWx1ZU9mIDogdm9pZCAwO1xuICBmdW5jdGlvbiBqdChuKSB7XG4gICAgdmFyIGkgPSAtMSwgbyA9IG4gPyBuLmxlbmd0aCA6IDA7XG4gICAgZm9yICh0aGlzLmNsZWFyKCk7ICsraSA8IG87ICkge1xuICAgICAgdmFyIHAgPSBuW2ldO1xuICAgICAgdGhpcy5zZXQocFswXSwgcFsxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIEVyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBpZSA/IGllKG51bGwpIDoge307XG4gIH1cbiAgZnVuY3Rpb24gVHIobikge1xuICAgIHJldHVybiB0aGlzLmhhcyhuKSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1tuXTtcbiAgfVxuICBmdW5jdGlvbiBBcihuKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9fZGF0YV9fO1xuICAgIGlmIChpZSkge1xuICAgICAgdmFyIG8gPSBpW25dO1xuICAgICAgcmV0dXJuIG8gPT09IHMgPyB2b2lkIDAgOiBvO1xuICAgIH1cbiAgICByZXR1cm4gei5jYWxsKGksIG4pID8gaVtuXSA6IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBucihuKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9fZGF0YV9fO1xuICAgIHJldHVybiBpZSA/IGlbbl0gIT09IHZvaWQgMCA6IHouY2FsbChpLCBuKTtcbiAgfVxuICBmdW5jdGlvbiBqZShuLCBpKSB7XG4gICAgdmFyIG8gPSB0aGlzLl9fZGF0YV9fO1xuICAgIHJldHVybiBvW25dID0gaWUgJiYgaSA9PT0gdm9pZCAwID8gcyA6IGksIHRoaXM7XG4gIH1cbiAganQucHJvdG90eXBlLmNsZWFyID0gRXIsIGp0LnByb3RvdHlwZS5kZWxldGUgPSBUciwganQucHJvdG90eXBlLmdldCA9IEFyLCBqdC5wcm90b3R5cGUuaGFzID0gbnIsIGp0LnByb3RvdHlwZS5zZXQgPSBqZTtcbiAgZnVuY3Rpb24gbnQobikge1xuICAgIHZhciBpID0gLTEsIG8gPSBuID8gbi5sZW5ndGggOiAwO1xuICAgIGZvciAodGhpcy5jbGVhcigpOyArK2kgPCBvOyApIHtcbiAgICAgIHZhciBwID0gbltpXTtcbiAgICAgIHRoaXMuc2V0KHBbMF0sIHBbMV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB4cigpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gIH1cbiAgZnVuY3Rpb24gRHIobikge1xuICAgIHZhciBpID0gdGhpcy5fX2RhdGFfXywgbyA9IEVlKGksIG4pO1xuICAgIGlmIChvIDwgMClcbiAgICAgIHJldHVybiAhMTtcbiAgICB2YXIgcCA9IGkubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gbyA9PSBwID8gaS5wb3AoKSA6IFBlLmNhbGwoaSwgbywgMSksICEwO1xuICB9XG4gIGZ1bmN0aW9uIE9yKG4pIHtcbiAgICB2YXIgaSA9IHRoaXMuX19kYXRhX18sIG8gPSBFZShpLCBuKTtcbiAgICByZXR1cm4gbyA8IDAgPyB2b2lkIDAgOiBpW29dWzFdO1xuICB9XG4gIGZ1bmN0aW9uIENyKG4pIHtcbiAgICByZXR1cm4gRWUodGhpcy5fX2RhdGFfXywgbikgPiAtMTtcbiAgfVxuICBmdW5jdGlvbiBQcihuLCBpKSB7XG4gICAgdmFyIG8gPSB0aGlzLl9fZGF0YV9fLCBwID0gRWUobywgbik7XG4gICAgcmV0dXJuIHAgPCAwID8gby5wdXNoKFtuLCBpXSkgOiBvW3BdWzFdID0gaSwgdGhpcztcbiAgfVxuICBudC5wcm90b3R5cGUuY2xlYXIgPSB4ciwgbnQucHJvdG90eXBlLmRlbGV0ZSA9IERyLCBudC5wcm90b3R5cGUuZ2V0ID0gT3IsIG50LnByb3RvdHlwZS5oYXMgPSBDciwgbnQucHJvdG90eXBlLnNldCA9IFByO1xuICBmdW5jdGlvbiBsdChuKSB7XG4gICAgdmFyIGkgPSAtMSwgbyA9IG4gPyBuLmxlbmd0aCA6IDA7XG4gICAgZm9yICh0aGlzLmNsZWFyKCk7ICsraSA8IG87ICkge1xuICAgICAgdmFyIHAgPSBuW2ldO1xuICAgICAgdGhpcy5zZXQocFswXSwgcFsxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFJyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICBoYXNoOiBuZXcganQoKSxcbiAgICAgIG1hcDogbmV3IChUdCB8fCBudCkoKSxcbiAgICAgIHN0cmluZzogbmV3IGp0KClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHpyKG4pIHtcbiAgICByZXR1cm4gY2UodGhpcywgbikuZGVsZXRlKG4pO1xuICB9XG4gIGZ1bmN0aW9uIEZyKG4pIHtcbiAgICByZXR1cm4gY2UodGhpcywgbikuZ2V0KG4pO1xuICB9XG4gIGZ1bmN0aW9uICRyKG4pIHtcbiAgICByZXR1cm4gY2UodGhpcywgbikuaGFzKG4pO1xuICB9XG4gIGZ1bmN0aW9uIE5yKG4sIGkpIHtcbiAgICByZXR1cm4gY2UodGhpcywgbikuc2V0KG4sIGkpLCB0aGlzO1xuICB9XG4gIGx0LnByb3RvdHlwZS5jbGVhciA9IFJyLCBsdC5wcm90b3R5cGUuZGVsZXRlID0genIsIGx0LnByb3RvdHlwZS5nZXQgPSBGciwgbHQucHJvdG90eXBlLmhhcyA9ICRyLCBsdC5wcm90b3R5cGUuc2V0ID0gTnI7XG4gIGZ1bmN0aW9uIEl0KG4pIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gbmV3IG50KG4pO1xuICB9XG4gIGZ1bmN0aW9uIGpyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBuZXcgbnQoKTtcbiAgfVxuICBmdW5jdGlvbiBIcihuKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZGVsZXRlKG4pO1xuICB9XG4gIGZ1bmN0aW9uIExyKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQobik7XG4gIH1cbiAgZnVuY3Rpb24gVXIobikge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhuKTtcbiAgfVxuICBmdW5jdGlvbiBXcihuLCBpKSB7XG4gICAgdmFyIG8gPSB0aGlzLl9fZGF0YV9fO1xuICAgIGlmIChvIGluc3RhbmNlb2YgbnQpIHtcbiAgICAgIHZhciBwID0gby5fX2RhdGFfXztcbiAgICAgIGlmICghVHQgfHwgcC5sZW5ndGggPCByIC0gMSlcbiAgICAgICAgcmV0dXJuIHAucHVzaChbbiwgaV0pLCB0aGlzO1xuICAgICAgbyA9IHRoaXMuX19kYXRhX18gPSBuZXcgbHQocCk7XG4gICAgfVxuICAgIHJldHVybiBvLnNldChuLCBpKSwgdGhpcztcbiAgfVxuICBJdC5wcm90b3R5cGUuY2xlYXIgPSBqciwgSXQucHJvdG90eXBlLmRlbGV0ZSA9IEhyLCBJdC5wcm90b3R5cGUuZ2V0ID0gTHIsIEl0LnByb3RvdHlwZS5oYXMgPSBVciwgSXQucHJvdG90eXBlLnNldCA9IFdyO1xuICBmdW5jdGlvbiBNZShuLCBpKSB7XG4gICAgdmFyIG8gPSBXZShuKSB8fCBBZShuKSA/IFl0KG4ubGVuZ3RoLCBTdHJpbmcpIDogW10sIHAgPSBvLmxlbmd0aCwgTiA9ICEhcDtcbiAgICBmb3IgKHZhciBQIGluIG4pXG4gICAgICB6LmNhbGwobiwgUCkgJiYgIShOICYmIChQID09IFwibGVuZ3RoXCIgfHwgbm4oUCwgcCkpKSAmJiBvLnB1c2goUCk7XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgZnVuY3Rpb24gc3IobiwgaSwgbykge1xuICAgIHZhciBwID0gbltpXTtcbiAgICAoISh6LmNhbGwobiwgaSkgJiYgdXIocCwgbykpIHx8IG8gPT09IHZvaWQgMCAmJiAhKGkgaW4gbikpICYmIChuW2ldID0gbyk7XG4gIH1cbiAgZnVuY3Rpb24gRWUobiwgaSkge1xuICAgIGZvciAodmFyIG8gPSBuLmxlbmd0aDsgby0tOyApXG4gICAgICBpZiAodXIobltvXVswXSwgaSkpXG4gICAgICAgIHJldHVybiBvO1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBmdW5jdGlvbiBDdChuLCBpKSB7XG4gICAgcmV0dXJuIG4gJiYgVWUoaSwgWWUoaSksIG4pO1xuICB9XG4gIGZ1bmN0aW9uIEhlKG4sIGksIG8sIHAsIE4sIFAsIEcpIHtcbiAgICB2YXIgVztcbiAgICBpZiAocCAmJiAoVyA9IFAgPyBwKG4sIE4sIFAsIEcpIDogcChuKSksIFcgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBXO1xuICAgIGlmICghUnQobikpXG4gICAgICByZXR1cm4gbjtcbiAgICB2YXIgSiA9IFdlKG4pO1xuICAgIGlmIChKKSB7XG4gICAgICBpZiAoVyA9IGVuKG4pLCAhaSlcbiAgICAgICAgcmV0dXJuIFpyKG4sIFcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgWCA9IEx0KG4pLCBkdCA9IFggPT0gTSB8fCBYID09IEU7XG4gICAgICBpZiAobHIobikpXG4gICAgICAgIHJldHVybiBUZShuLCBpKTtcbiAgICAgIGlmIChYID09IEMgfHwgWCA9PSBjIHx8IGR0ICYmICFQKSB7XG4gICAgICAgIGlmIChCdChuKSlcbiAgICAgICAgICByZXR1cm4gUCA/IG4gOiB7fTtcbiAgICAgICAgaWYgKFcgPSBQdChkdCA/IHt9IDogbiksICFpKVxuICAgICAgICAgIHJldHVybiBRcihuLCBDdChXLCBuKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIVVbWF0pXG4gICAgICAgICAgcmV0dXJuIFAgPyBuIDoge307XG4gICAgICAgIFcgPSBybihuLCBYLCBIZSwgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIEcgfHwgKEcgPSBuZXcgSXQoKSk7XG4gICAgdmFyIGJ0ID0gRy5nZXQobik7XG4gICAgaWYgKGJ0KVxuICAgICAgcmV0dXJuIGJ0O1xuICAgIGlmIChHLnNldChuLCBXKSwgIUopXG4gICAgICB2YXIgWiA9IG8gPyB0bihuKSA6IFllKG4pO1xuICAgIHJldHVybiAkdChaIHx8IG4sIGZ1bmN0aW9uKGZ0LCBzdCkge1xuICAgICAgWiAmJiAoc3QgPSBmdCwgZnQgPSBuW3N0XSksIHNyKFcsIHN0LCBIZShmdCwgaSwgbywgcCwgc3QsIG4sIEcpKTtcbiAgICB9KSwgVztcbiAgfVxuICBmdW5jdGlvbiBHcihuKSB7XG4gICAgcmV0dXJuIFJ0KG4pID8gU2UobikgOiB7fTtcbiAgfVxuICBmdW5jdGlvbiBZcihuLCBpLCBvKSB7XG4gICAgdmFyIHAgPSBpKG4pO1xuICAgIHJldHVybiBXZShuKSA/IHAgOiBFdChwLCBvKG4pKTtcbiAgfVxuICBmdW5jdGlvbiBCcihuKSB7XG4gICAgcmV0dXJuIHJ0LmNhbGwobik7XG4gIH1cbiAgZnVuY3Rpb24gWHIobikge1xuICAgIGlmICghUnQobikgfHwgYW4obikpXG4gICAgICByZXR1cm4gITE7XG4gICAgdmFyIGkgPSBHZShuKSB8fCBCdChuKSA/IGN0IDogRHQ7XG4gICAgcmV0dXJuIGkudGVzdCh5dChuKSk7XG4gIH1cbiAgZnVuY3Rpb24gS3Iobikge1xuICAgIGlmICghb3IobikpXG4gICAgICByZXR1cm4gVnQobik7XG4gICAgdmFyIGkgPSBbXTtcbiAgICBmb3IgKHZhciBvIGluIE9iamVjdChuKSlcbiAgICAgIHouY2FsbChuLCBvKSAmJiBvICE9IFwiY29uc3RydWN0b3JcIiAmJiBpLnB1c2gobyk7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgZnVuY3Rpb24gVGUobiwgaSkge1xuICAgIGlmIChpKVxuICAgICAgcmV0dXJuIG4uc2xpY2UoKTtcbiAgICB2YXIgbyA9IG5ldyBuLmNvbnN0cnVjdG9yKG4ubGVuZ3RoKTtcbiAgICByZXR1cm4gbi5jb3B5KG8pLCBvO1xuICB9XG4gIGZ1bmN0aW9uIExlKG4pIHtcbiAgICB2YXIgaSA9IG5ldyBuLmNvbnN0cnVjdG9yKG4uYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIG5ldyBxKGkpLnNldChuZXcgcShuKSksIGk7XG4gIH1cbiAgZnVuY3Rpb24gb2UobiwgaSkge1xuICAgIHZhciBvID0gaSA/IExlKG4uYnVmZmVyKSA6IG4uYnVmZmVyO1xuICAgIHJldHVybiBuZXcgbi5jb25zdHJ1Y3RvcihvLCBuLmJ5dGVPZmZzZXQsIG4uYnl0ZUxlbmd0aCk7XG4gIH1cbiAgZnVuY3Rpb24gaXIobiwgaSwgbykge1xuICAgIHZhciBwID0gaSA/IG8ocmUobiksICEwKSA6IHJlKG4pO1xuICAgIHJldHVybiBHdChwLCBNdCwgbmV3IG4uY29uc3RydWN0b3IoKSk7XG4gIH1cbiAgZnVuY3Rpb24gYXIobikge1xuICAgIHZhciBpID0gbmV3IG4uY29uc3RydWN0b3Iobi5zb3VyY2UsIGt0LmV4ZWMobikpO1xuICAgIHJldHVybiBpLmxhc3RJbmRleCA9IG4ubGFzdEluZGV4LCBpO1xuICB9XG4gIGZ1bmN0aW9uIFZyKG4sIGksIG8pIHtcbiAgICB2YXIgcCA9IGkgPyBvKG5lKG4pLCAhMCkgOiBuZShuKTtcbiAgICByZXR1cm4gR3QocCwgb3QsIG5ldyBuLmNvbnN0cnVjdG9yKCkpO1xuICB9XG4gIGZ1bmN0aW9uIHFyKG4pIHtcbiAgICByZXR1cm4gcnIgPyBPYmplY3QocnIuY2FsbChuKSkgOiB7fTtcbiAgfVxuICBmdW5jdGlvbiBKcihuLCBpKSB7XG4gICAgdmFyIG8gPSBpID8gTGUobi5idWZmZXIpIDogbi5idWZmZXI7XG4gICAgcmV0dXJuIG5ldyBuLmNvbnN0cnVjdG9yKG8sIG4uYnl0ZU9mZnNldCwgbi5sZW5ndGgpO1xuICB9XG4gIGZ1bmN0aW9uIFpyKG4sIGkpIHtcbiAgICB2YXIgbyA9IC0xLCBwID0gbi5sZW5ndGg7XG4gICAgZm9yIChpIHx8IChpID0gQXJyYXkocCkpOyArK28gPCBwOyApXG4gICAgICBpW29dID0gbltvXTtcbiAgICByZXR1cm4gaTtcbiAgfVxuICBmdW5jdGlvbiBVZShuLCBpLCBvLCBwKSB7XG4gICAgbyB8fCAobyA9IHt9KTtcbiAgICBmb3IgKHZhciBOID0gLTEsIFAgPSBpLmxlbmd0aDsgKytOIDwgUDsgKSB7XG4gICAgICB2YXIgRyA9IGlbTl0sIFcgPSB2b2lkIDA7XG4gICAgICBzcihvLCBHLCBXID09PSB2b2lkIDAgPyBuW0ddIDogVyk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIGZ1bmN0aW9uIFFyKG4sIGkpIHtcbiAgICByZXR1cm4gVWUobiwgSHQobiksIGkpO1xuICB9XG4gIGZ1bmN0aW9uIHRuKG4pIHtcbiAgICByZXR1cm4gWXIobiwgWWUsIEh0KTtcbiAgfVxuICBmdW5jdGlvbiBjZShuLCBpKSB7XG4gICAgdmFyIG8gPSBuLl9fZGF0YV9fO1xuICAgIHJldHVybiBzbihpKSA/IG9bdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IFwic3RyaW5nXCIgOiBcImhhc2hcIl0gOiBvLm1hcDtcbiAgfVxuICBmdW5jdGlvbiB4dChuLCBpKSB7XG4gICAgdmFyIG8gPSBlZShuLCBpKTtcbiAgICByZXR1cm4gWHIobykgPyBvIDogdm9pZCAwO1xuICB9XG4gIHZhciBIdCA9IFkgPyBYdChZLCBPYmplY3QpIDogY24sIEx0ID0gQnI7XG4gIChxdCAmJiBMdChuZXcgcXQobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gdiB8fCBUdCAmJiBMdChuZXcgVHQoKSkgIT0gbSB8fCBBdCAmJiBMdChBdC5yZXNvbHZlKCkpICE9IHUgfHwgd2UgJiYgTHQobmV3IHdlKCkpICE9IFMgfHwgUmUgJiYgTHQobmV3IFJlKCkpICE9IGgpICYmIChMdCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgaSA9IHJ0LmNhbGwobiksIG8gPSBpID09IEMgPyBuLmNvbnN0cnVjdG9yIDogdm9pZCAwLCBwID0gbyA/IHl0KG8pIDogdm9pZCAwO1xuICAgIGlmIChwKVxuICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgIGNhc2UgemU6XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgYWU6XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIGNhc2UgRmU6XG4gICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgIGNhc2UgJGU6XG4gICAgICAgICAgcmV0dXJuIFM7XG4gICAgICAgIGNhc2UgTmU6XG4gICAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0pO1xuICBmdW5jdGlvbiBlbihuKSB7XG4gICAgdmFyIGkgPSBuLmxlbmd0aCwgbyA9IG4uY29uc3RydWN0b3IoaSk7XG4gICAgcmV0dXJuIGkgJiYgdHlwZW9mIG5bMF0gPT0gXCJzdHJpbmdcIiAmJiB6LmNhbGwobiwgXCJpbmRleFwiKSAmJiAoby5pbmRleCA9IG4uaW5kZXgsIG8uaW5wdXQgPSBuLmlucHV0KSwgbztcbiAgfVxuICBmdW5jdGlvbiBQdChuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuLmNvbnN0cnVjdG9yID09IFwiZnVuY3Rpb25cIiAmJiAhb3IobikgPyBHcihodChuKSkgOiB7fTtcbiAgfVxuICBmdW5jdGlvbiBybihuLCBpLCBvLCBwKSB7XG4gICAgdmFyIE4gPSBuLmNvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAoaSkge1xuICAgICAgY2FzZSB5OlxuICAgICAgICByZXR1cm4gTGUobik7XG4gICAgICBjYXNlIGY6XG4gICAgICBjYXNlIGI6XG4gICAgICAgIHJldHVybiBuZXcgTigrbik7XG4gICAgICBjYXNlIHY6XG4gICAgICAgIHJldHVybiBvZShuLCBwKTtcbiAgICAgIGNhc2UgSTpcbiAgICAgIGNhc2UgeDpcbiAgICAgIGNhc2UgZzpcbiAgICAgIGNhc2UgTzpcbiAgICAgIGNhc2UgRDpcbiAgICAgIGNhc2UgajpcbiAgICAgIGNhc2UgTDpcbiAgICAgIGNhc2UgUjpcbiAgICAgIGNhc2UgRjpcbiAgICAgICAgcmV0dXJuIEpyKG4sIHApO1xuICAgICAgY2FzZSBtOlxuICAgICAgICByZXR1cm4gaXIobiwgcCwgbyk7XG4gICAgICBjYXNlIFQ6XG4gICAgICBjYXNlIHc6XG4gICAgICAgIHJldHVybiBuZXcgTihuKTtcbiAgICAgIGNhc2UgbDpcbiAgICAgICAgcmV0dXJuIGFyKG4pO1xuICAgICAgY2FzZSBTOlxuICAgICAgICByZXR1cm4gVnIobiwgcCwgbyk7XG4gICAgICBjYXNlIGs6XG4gICAgICAgIHJldHVybiBxcihuKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm4obiwgaSkge1xuICAgIHJldHVybiBpID0gaSA/PyBhLCAhIWkgJiYgKHR5cGVvZiBuID09IFwibnVtYmVyXCIgfHwgT3QudGVzdChuKSkgJiYgbiA+IC0xICYmIG4gJSAxID09IDAgJiYgbiA8IGk7XG4gIH1cbiAgZnVuY3Rpb24gc24obikge1xuICAgIHZhciBpID0gdHlwZW9mIG47XG4gICAgcmV0dXJuIGkgPT0gXCJzdHJpbmdcIiB8fCBpID09IFwibnVtYmVyXCIgfHwgaSA9PSBcInN5bWJvbFwiIHx8IGkgPT0gXCJib29sZWFuXCIgPyBuICE9PSBcIl9fcHJvdG9fX1wiIDogbiA9PT0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBhbihuKSB7XG4gICAgcmV0dXJuICEhJCAmJiAkIGluIG47XG4gIH1cbiAgZnVuY3Rpb24gb3Iobikge1xuICAgIHZhciBpID0gbiAmJiBuLmNvbnN0cnVjdG9yLCBvID0gdHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiICYmIGkucHJvdG90eXBlIHx8IE50O1xuICAgIHJldHVybiBuID09PSBvO1xuICB9XG4gIGZ1bmN0aW9uIHl0KG4pIHtcbiAgICBpZiAobiAhPSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSC5jYWxsKG4pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbiArIFwiXCI7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gY3Iobikge1xuICAgIHJldHVybiBIZShuLCAhMCwgITApO1xuICB9XG4gIGZ1bmN0aW9uIHVyKG4sIGkpIHtcbiAgICByZXR1cm4gbiA9PT0gaSB8fCBuICE9PSBuICYmIGkgIT09IGk7XG4gIH1cbiAgZnVuY3Rpb24gQWUobikge1xuICAgIHJldHVybiBvbihuKSAmJiB6LmNhbGwobiwgXCJjYWxsZWVcIikgJiYgKCFzZS5jYWxsKG4sIFwiY2FsbGVlXCIpIHx8IHJ0LmNhbGwobikgPT0gYyk7XG4gIH1cbiAgdmFyIFdlID0gQXJyYXkuaXNBcnJheTtcbiAgZnVuY3Rpb24geGUobikge1xuICAgIHJldHVybiBuICE9IG51bGwgJiYgZHIobi5sZW5ndGgpICYmICFHZShuKTtcbiAgfVxuICBmdW5jdGlvbiBvbihuKSB7XG4gICAgcmV0dXJuIGZyKG4pICYmIHhlKG4pO1xuICB9XG4gIHZhciBsciA9IG10IHx8IHVuO1xuICBmdW5jdGlvbiBHZShuKSB7XG4gICAgdmFyIGkgPSBSdChuKSA/IHJ0LmNhbGwobikgOiBcIlwiO1xuICAgIHJldHVybiBpID09IE0gfHwgaSA9PSBFO1xuICB9XG4gIGZ1bmN0aW9uIGRyKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT0gXCJudW1iZXJcIiAmJiBuID4gLTEgJiYgbiAlIDEgPT0gMCAmJiBuIDw9IGE7XG4gIH1cbiAgZnVuY3Rpb24gUnQobikge1xuICAgIHZhciBpID0gdHlwZW9mIG47XG4gICAgcmV0dXJuICEhbiAmJiAoaSA9PSBcIm9iamVjdFwiIHx8IGkgPT0gXCJmdW5jdGlvblwiKTtcbiAgfVxuICBmdW5jdGlvbiBmcihuKSB7XG4gICAgcmV0dXJuICEhbiAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiO1xuICB9XG4gIGZ1bmN0aW9uIFllKG4pIHtcbiAgICByZXR1cm4geGUobikgPyBNZShuKSA6IEtyKG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNuKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBmdW5jdGlvbiB1bigpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgdC5leHBvcnRzID0gY3I7XG59KShJciwgSXIuZXhwb3J0cyk7XG52YXIgZ2kgPSBJci5leHBvcnRzO1xuY29uc3QgSyA9IC8qIEBfX1BVUkVfXyAqLyB4bihnaSksIE9lID0gKHQpID0+IG5ldyBQcm9taXNlKChlLCByKSA9PiB7XG4gIGNvbnN0IHMgPSBuZXcgSW1hZ2UoKTtcbiAgY29uc29sZS53YXJuKFwidXBkYXRlIGNkbiBjb25maWcgZm9yIGNvcnM/XCIpLCBzLm9ubG9hZCA9ICgpID0+IHtcbiAgICBjb25zdCBhID0gcy53aWR0aCwgYyA9IHMuaGVpZ2h0O1xuICAgIGUoeyB3aWR0aDogYSwgaGVpZ2h0OiBjIH0pO1xuICB9LCBzLm9uZXJyb3IgPSAoYSkgPT4ge1xuICAgIHIoYSk7XG4gIH0sIHMuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiLCBzLnNyYyA9IHQ7XG59KSwgbHMgPSAodCkgPT4gbmV3IFByb21pc2UoKGUsIHIpID0+IHtcbiAgY29uc3QgcyA9IG5ldyBBdWRpbygpO1xuICBzLnByZWxvYWQgPSBcImF1dG9cIiwgcy5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgKCkgPT4ge1xuICAgIGNvbnN0IGEgPSBzLmR1cmF0aW9uICogMWUzO1xuICAgIGUoeyBkdXJhdGlvbjogYSB9KTtcbiAgfSksIHMuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChhKSA9PiB7XG4gICAgcihhKTtcbiAgfSksIHMuc3JjID0gdCwgcy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCIsIHMubG9hZCgpO1xufSksIF9uID0gKHQpID0+IG5ldyBQcm9taXNlKChlLCByKSA9PiB7XG4gIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gIHMucHJlbG9hZCA9IFwiYXV0b1wiLCBzLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCAoKSA9PiB7XG4gICAgY29uc3QgYSA9IHMuZHVyYXRpb24gKiAxZTMsIGMgPSBzLnZpZGVvV2lkdGgsIGQgPSBzLnZpZGVvSGVpZ2h0O1xuICAgIGUoeyBkdXJhdGlvbjogYSwgd2lkdGg6IGMsIGhlaWdodDogZCB9KTtcbiAgfSksIHMuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChhKSA9PiB7XG4gICAgcihhKTtcbiAgfSksIHMuc3JjID0gdCwgcy5sb2FkKCk7XG59KSwgSWkgPSBhc3luYyAodCkgPT4ge1xuICB2YXIgYSwgYztcbiAgY29uc3QgZSA9IHQuZHVyYXRpb24sIHIgPSAoYSA9IHQuZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IGEud2lkdGgsIHMgPSAoYyA9IHQuZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IGMuaGVpZ2h0O1xuICByZXR1cm4gZSAmJiByICYmIHMgPyB7IGR1cmF0aW9uOiBlLCB3aWR0aDogciwgaGVpZ2h0OiBzIH0gOiBfbih0LmRldGFpbHMuc3JjKTtcbn0sIGRzID0gKHQsIGUpID0+IHtcbiAgY29uc3QgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGEpID0+IHtcbiAgICBhICE9PSBcImhlaWdodFwiICYmIChyLnN0eWxlW2FdID0gZVthXSk7XG4gIH0pLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHIpLCByLnRleHRDb250ZW50ID0gdCwgci5zdHlsZS53aGl0ZVNwYWNlID0gXCJub3JtYWxcIiwgci5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgci5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIiwgci5zdHlsZS53aWR0aCA9IGUud2lkdGggKyBcInB4XCIsIHIuc3R5bGUuZm9udFNpemUgPSBlLmZvbnRTaXplICsgXCJweFwiO1xuICBjb25zdCBzID0gZ2V0Q29tcHV0ZWRTdHlsZShyKS5oZWlnaHQ7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIpLCBwYXJzZUZsb2F0KHMpO1xufSwgYnIgPSAodCkgPT4ge1xuICBjb25zdCBlID0gdC5tYXAoKHIpID0+IG5ldyBGb250RmFjZShyLmZvbnRGYW1pbHksIGB1cmwoJHtyLnVybH0pYCkubG9hZCgpLmNhdGNoKChzKSA9PiBzKSk7XG4gIHJldHVybiBlLmxlbmd0aCA9PT0gMCA/IFByb21pc2UucmVzb2x2ZSghMCkgOiBuZXcgUHJvbWlzZSgociwgcykgPT4ge1xuICAgIFByb21pc2UuYWxsKGUpLnRoZW4oKGEpID0+IHtcbiAgICAgIGEuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjICYmIGMuZmFtaWx5ICYmIChkb2N1bWVudC5mb250cy5hZGQoYyksIHIoITApKTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKChhKSA9PiBzKGEpKTtcbiAgfSk7XG59LCBiaSA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xubGV0IFhlID0gKHQgPSAyMSkgPT4ge1xuICBsZXQgZSA9IFwiXCIsIHIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHQgfD0gMCkpO1xuICBmb3IgKDsgdC0tOyApXG4gICAgZSArPSBiaVtyW3RdICYgNjNdO1xuICByZXR1cm4gZTtcbn07XG5mdW5jdGlvbiBEZSh0ID0gMTYpIHtcbiAgY29uc3QgZSA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiLCByID0gZS5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZS5sZW5ndGgpKTtcbiAgbGV0IHMgPSBYZSh0IC0gMSk7XG4gIHJldHVybiBzID0gcy5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgXCJcIikuc2xpY2UoMCwgdCAtIDEpLCByICsgcztcbn1cbmZ1bmN0aW9uIHZpKHQpIHtcbiAgY29uc3QgZSA9IC8jKFswLTlhLWZBLUZdezMsNn0pXFxiL2csIHIgPSAvcmdiXFwoXFxzKihcXGQrKSxcXHMqKFxcZCspLFxccyooXFxkKylcXHMqXFwpL2csIHMgPSAvcmdiYVxcKFxccyooXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspLFxccyooWzAtOS5dKylcXHMqXFwpL2c7XG4gIGZ1bmN0aW9uIGEoZCkge1xuICAgIHJldHVybiBkLmxlbmd0aCA9PT0gMyA/IGAjJHtkWzBdfSR7ZFswXX0ke2RbMV19JHtkWzFdfSR7ZFsyXX0ke2RbMl19YC50b1VwcGVyQ2FzZSgpIDogYCMke2QudG9VcHBlckNhc2UoKX1gO1xuICB9XG4gIGZ1bmN0aW9uIGMoZCwgZiwgYikge1xuICAgIHJldHVybiBgIyR7KDEgPDwgMjQgfCBkIDw8IDE2IHwgZiA8PCA4IHwgYikudG9TdHJpbmcoMTYpLnNsaWNlKDEpLnRvVXBwZXJDYXNlKCl9YDtcbiAgfVxuICByZXR1cm4gdCA9IHQucmVwbGFjZShlLCAoZCwgZikgPT4gYShmKSksIHQgPSB0LnJlcGxhY2UoXG4gICAgcixcbiAgICAoZCwgZiwgYiwgXykgPT4gYygrZiwgK2IsICtfKVxuICApLCB0ID0gdC5yZXBsYWNlKFxuICAgIHMsXG4gICAgKGQsIGYsIGIsIF8pID0+IGMoK2YsICtiLCArXylcbiAgKSwgdDtcbn1cbmZ1bmN0aW9uIGl0KHQpIHtcbiAgcmV0dXJuIC9eI1swLTlhLWZBLUZdezN9JC8udGVzdCh0KSA/IFwiI1wiICsgdFsxXSArIHRbMV0gKyB0WzJdICsgdFsyXSArIHRbM10gKyB0WzNdIDogdDtcbn1cbmZ1bmN0aW9uIFduKHQsIGUpIHtcbiAgbGV0IHIgPSB0O1xuICBmb3IgKGNvbnN0IHMgaW4gZSlcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHMpKSB7XG4gICAgICBjb25zdCBhID0gbmV3IFJlZ0V4cChzLCBcImdcIik7XG4gICAgICByID0gci5yZXBsYWNlKGEsIGVbc10pO1xuICAgIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBmcyh0KSB7XG4gIGNvbnN0IGUgPSB0LmdldEF0dHJpYnV0ZShcImZpbGxcIik7XG4gIGlmIChlICYmIGUudHJpbSgpICE9PSBcIlwiICYmIGUudHJpbSgpICE9PSBcIm5vbmVcIilcbiAgICByZXR1cm4gZS50cmltKCk7XG4gIGNvbnN0IHIgPSB0LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICBpZiAocikge1xuICAgIGNvbnN0IGEgPSAvZmlsbFxccyo6XFxzKihbXjtdKyk7Py8uZXhlYyhyKTtcbiAgICBpZiAoYSkge1xuICAgICAgY29uc3QgYyA9IGFbMV0udHJpbSgpO1xuICAgICAgaWYgKGMgIT09IFwiXCIgJiYgYyAhPT0gXCJub25lXCIpXG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgfVxuICBjb25zdCBzID0gdC5wYXJlbnRFbGVtZW50O1xuICByZXR1cm4gcyA/IGZzKHMpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIEJlKHQpIHtcbiAgcmV0dXJuIC9eIyhbMC05QS1GYS1mXXszfXxbMC05QS1GYS1mXXs2fSkkLy50ZXN0KHQpO1xufVxuY29uc3QgX2kgPSAodCkgPT4ge1xuICBjb25zdCBlID0gYC4ke3Quc3BsaXQoXCIuXCIpLmZpbHRlcigoYykgPT4gYy5pbmNsdWRlcyhcImZpbGw6XCIpKS5qb2luKFwiLlwiKX1gLCByID0ge30sIHMgPSAvXFwuKFtcXHctXSspXFxzKlxce1xccyooW159XSspXFxzKlxcfS9nO1xuICBsZXQgYTtcbiAgZm9yICg7IChhID0gcy5leGVjKGUpKSAhPT0gbnVsbDsgKSB7XG4gICAgY29uc3QgYyA9IGFbMV0sIGQgPSBhWzJdLCBmID0ge30sIGIgPSAvZmlsbFxccyo6XFxzKihbXjtdKyk7Py8uZXhlYyhkKSwgXyA9IC9zdHJva2VcXHMqOlxccyooW147XSspOz8vLmV4ZWMoZCk7XG4gICAgYiAmJiAoZi5maWxsID0gaXQoYlsxXS50cmltKCkpKSwgXyAmJiAoZi5zdHJva2UgPSBpdChfWzFdLnRyaW0oKSkpLCByW2NdID0gZjtcbiAgfVxuICByZXR1cm4gcjtcbn07XG5mdW5jdGlvbiBkbih0KSB7XG4gIGxldCBlID0gdC5wYXJlbnRFbGVtZW50O1xuICBmb3IgKDsgZTsgKSB7XG4gICAgaWYgKGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcIm1hc2tcIilcbiAgICAgIHJldHVybiAhMDtcbiAgICBlID0gZS5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGtpKHQsIGUsIHIgPSAzMDAsIHMgPSAzMDApIHtcbiAgY29uc3QgYSA9IFtdLCBkID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh0LCBcImltYWdlL3N2Zyt4bWxcIiksIGYgPSBkLmRvY3VtZW50RWxlbWVudDtcbiAgZi5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHtyfWApLCBmLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgJHtzfWApO1xuICBjb25zdCBiID0gZi5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVcIiksIF8gPSB7fTtcbiAgYi5mb3JFYWNoKCh1KSA9PiB7XG4gICAgY29uc3QgbCA9IHUudGV4dENvbnRlbnQgfHwgXCJcIiwgUyA9IF9pKGwpO1xuICAgIE9iamVjdC5hc3NpZ24oXywgUyk7XG4gICAgY29uc3QgdyA9IGwucmVwbGFjZSgvXFwuKHN0W1xcdy1dKykvZywgYC4ke2V9LSQxYCkucmVwbGFjZSgvdXJsXFwoIyguKj8pXFwpL2csIGB1cmwoIyR7ZX0tJDEpYCk7XG4gICAgdS50ZXh0Q29udGVudCA9IHc7XG4gICAgY29uc3QgayA9IEFycmF5LmZyb20oZC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSksIGggPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGsuZm9yRWFjaCgoeSkgPT4ge1xuICAgICAgaWYgKGRuKHkpKSByZXR1cm47XG4gICAgICBbXCJmaWxsXCIsIFwic3Ryb2tlXCIsIFwic3RvcC1jb2xvclwiXS5mb3JFYWNoKCh4KSA9PiB7XG4gICAgICAgIGNvbnN0IGcgPSB5LmdldEF0dHJpYnV0ZSh4KTtcbiAgICAgICAgZyAmJiAhW1wibm9uZVwiLCBcInRyYW5zcGFyZW50XCJdLmluY2x1ZGVzKGcpICYmIGguYWRkKGl0KGcpKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdiA9IHkuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgICBpZiAodikge1xuICAgICAgICBjb25zdCB4ID0gL2ZpbGxcXHMqOlxccyooW147XSspOz8vLmV4ZWModiksIGcgPSAvc3Ryb2tlXFxzKjpcXHMqKFteO10rKTs/Ly5leGVjKHYpLCBPID0gL3N0b3AtY29sb3JcXHMqOlxccyooW147XSspOz8vLmV4ZWModik7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgY29uc3QgRCA9IHhbMV0udHJpbSgpO1xuICAgICAgICAgIEQgJiYgIVtcIm5vbmVcIiwgXCJ0cmFuc3BhcmVudFwiXS5pbmNsdWRlcyhEKSAmJiBCZShpdChEKSkgJiYgaC5hZGQoaXQoRCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgY29uc3QgRCA9IGdbMV0udHJpbSgpO1xuICAgICAgICAgIEQgJiYgIVtcIm5vbmVcIiwgXCJ0cmFuc3BhcmVudFwiXS5pbmNsdWRlcyhEKSAmJiBCZShpdChEKSkgJiYgaC5hZGQoaXQoRCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPKSB7XG4gICAgICAgICAgY29uc3QgRCA9IE9bMV0udHJpbSgpO1xuICAgICAgICAgIEQgJiYgIVtcIm5vbmVcIiwgXCJ0cmFuc3BhcmVudFwiXS5pbmNsdWRlcyhEKSAmJiBCZShpdChEKSkgJiYgaC5hZGQoaXQoRCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBJID0geS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgIEkgJiYgSS5zcGxpdChcIiBcIikuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgICBjb25zdCBnID0gX1t4XTtcbiAgICAgICAgZyAhPSBudWxsICYmIGcuZmlsbCAmJiAhW1wibm9uZVwiLCBcInRyYW5zcGFyZW50XCJdLmluY2x1ZGVzKGcuZmlsbCkgJiYgaC5hZGQoaXQoZy5maWxsKSksIGcgIT0gbnVsbCAmJiBnLnN0cm9rZSAmJiAhW1wibm9uZVwiLCBcInRyYW5zcGFyZW50XCJdLmluY2x1ZGVzKGcuc3Ryb2tlKSAmJiBoLmFkZChpdChnLnN0cm9rZSkpO1xuICAgICAgfSk7XG4gICAgfSksIEFycmF5LmZyb20oaCkuZm9yRWFjaCgoeSkgPT4ge1xuICAgICAgQmUoeSkgJiYgYS5wdXNoKHkpO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgTSA9IEFycmF5LmZyb20oZC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSksIEUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICByZXR1cm4gTS5mb3JFYWNoKCh1KSA9PiB7XG4gICAgaWYgKGRuKHUpKSByZXR1cm47XG4gICAgY29uc3QgbCA9IHUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgaWYgKGwpIHtcbiAgICAgIGNvbnN0IHcgPSBsLnNwbGl0KFwiIFwiKS5tYXAoKGspID0+IGAke2V9LSR7a31gKS5qb2luKFwiIFwiKTtcbiAgICAgIHUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdyksIHcuc3BsaXQoXCIgXCIpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgY29uc3QgaCA9IF9ba107XG4gICAgICAgIGggIT0gbnVsbCAmJiBoLmZpbGwgJiYgIVtcIm5vbmVcIiwgXCJ0cmFuc3BhcmVudFwiXS5pbmNsdWRlcyhoLmZpbGwpICYmIEUuYWRkKGl0KGguZmlsbCkpLCBoICE9IG51bGwgJiYgaC5zdHJva2UgJiYgIVtcIm5vbmVcIiwgXCJ0cmFuc3BhcmVudFwiXS5pbmNsdWRlcyhoLnN0cm9rZSkgJiYgRS5hZGQoaXQoaC5zdHJva2UpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBbXCJmaWxsXCIsIFwic3Ryb2tlXCIsIFwic3RvcC1jb2xvclwiXS5mb3JFYWNoKCh3KSA9PiB7XG4gICAgICBjb25zdCBrID0gdS5nZXRBdHRyaWJ1dGUodyk7XG4gICAgICBrICYmICFbXCJub25lXCIsIFwidHJhbnNwYXJlbnRcIl0uaW5jbHVkZXMoaykgJiYgRS5hZGQoaXQoaykpO1xuICAgIH0pO1xuICAgIGNvbnN0IFMgPSB1LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIGlmIChTKSB7XG4gICAgICBjb25zdCB3ID0gL2ZpbGxcXHMqOlxccyooW147XSspOz8vLmV4ZWMoUyksIGsgPSAvc3Ryb2tlXFxzKjpcXHMqKFteO10rKTs/Ly5leGVjKFMpLCBoID0gL3N0b3AtY29sb3JcXHMqOlxccyooW147XSspOz8vLmV4ZWMoUyk7XG4gICAgICBpZiAodykge1xuICAgICAgICBjb25zdCB5ID0gd1sxXS50cmltKCk7XG4gICAgICAgIHkgJiYgIVtcIm5vbmVcIiwgXCJ0cmFuc3BhcmVudFwiXS5pbmNsdWRlcyh5KSAmJiBFLmFkZChpdCh5KSk7XG4gICAgICB9XG4gICAgICBpZiAoaykge1xuICAgICAgICBjb25zdCB5ID0ga1sxXS50cmltKCk7XG4gICAgICAgIHkgJiYgIVtcIm5vbmVcIiwgXCJ0cmFuc3BhcmVudFwiXS5pbmNsdWRlcyh5KSAmJiBFLmFkZChpdCh5KSk7XG4gICAgICB9XG4gICAgICBpZiAoaCkge1xuICAgICAgICBjb25zdCB5ID0gaFsxXS50cmltKCk7XG4gICAgICAgIHkgJiYgIVtcIm5vbmVcIiwgXCJ0cmFuc3BhcmVudFwiXS5pbmNsdWRlcyh5KSAmJiBFLmFkZChpdCh5KSk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgRS5mb3JFYWNoKFxuICAgICh1KSA9PiAhYS5pbmNsdWRlcyh1KSAmJiBCZSh1KSAmJiBhLnB1c2godSlcbiAgKSwgQXJyYXkuZnJvbShkLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKS5mb3JFYWNoKCh1KSA9PiB7XG4gICAgaWYgKHUuaGFzQXR0cmlidXRlKFwiaWRcIikpIHtcbiAgICAgIGNvbnN0IGwgPSB1LmdldEF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgdS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtlfS0ke2x9YCk7XG4gICAgfVxuICAgIGlmIChbXCJmaWxsXCIsIFwic3Ryb2tlXCIsIFwic3RvcC1jb2xvclwiLCBcImZpbHRlclwiLCBcImNsaXAtcGF0aFwiLCBcIm1hc2tcIl0uZm9yRWFjaChcbiAgICAgIChsKSA9PiB7XG4gICAgICAgIGNvbnN0IFMgPSB1LmdldEF0dHJpYnV0ZShsKTtcbiAgICAgICAgUyAmJiBTLmluY2x1ZGVzKFwidXJsKCNcIikgJiYgdS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgbCxcbiAgICAgICAgICBTLnJlcGxhY2UoL3VybFxcKCMoLio/KVxcKS9nLCBgdXJsKCMke2V9LSQxKWApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwgdS5oYXNBdHRyaWJ1dGUoXCJzdHlsZVwiKSkge1xuICAgICAgY29uc3QgbCA9IHUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgICBsLmluY2x1ZGVzKFwidXJsKCNcIikgJiYgdS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgbC5yZXBsYWNlKC91cmxcXCgjKC4qPylcXCkvZywgYHVybCgjJHtlfS0kMSlgKVxuICAgICAgKTtcbiAgICB9XG4gIH0pLCBBcnJheS5mcm9tKGQucXVlcnlTZWxlY3RvckFsbChcInBhdGhcIikpLmZvckVhY2goKHUpID0+IHtcbiAgICBpZiAoZG4odSkpIHJldHVybjtcbiAgICAhZnModSkgJiYgIXUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgJiYgKHUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIiMwMDAwMDBcIiksIGEuaW5jbHVkZXMoXCIjMDAwMDAwXCIpIHx8IGEucHVzaChcIiMwMDAwMDBcIikpO1xuICB9KSwgeyBzZXJpYWxpemVyOiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKGQpLCBjb2xvcnM6IGEgfTtcbn1cbmNvbnN0IHdyID0ge1xuICBjb2xvcjogXCIjMDAwMDAwXCIsXG4gIHg6IDAsXG4gIHk6IDAsXG4gIGJsdXI6IDBcbn0sIHZlID0gKHQsIGUpID0+IHtcbiAgbGV0IHIgPSBlICE9IG51bGwgJiYgZS50cmltID8gZS50cmltLnRvIC0gZS50cmltLmZyb20gOiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5kdXJhdGlvbikgfHwgNWUzO1xuICBjb25zdCBzID0ge1xuICAgIGZyb206IDAsXG4gICAgdG86IHJcbiAgfTtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBzO1xuICBpZiAodC5mcm9tIDwgMClcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcbiAgICAgIFwiJ2Zyb20nIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZXR1cm5pbmcgZGVmYXVsdCBkaXNwbGF5LlwiXG4gICAgKSwgcztcbiAgaWYgKHQuZnJvbSAhPT0gdm9pZCAwICYmIHQudG8gPT09IHZvaWQgMClcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbTogdC5mcm9tLFxuICAgICAgdG86IHQuZnJvbSArIHJcbiAgICB9O1xuICBpZiAodC50byAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKHQudG8gPCAwKVxuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiJ3RvJyBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmV0dXJuaW5nIGRlZmF1bHQgZGlzcGxheS5cIlxuICAgICAgKSwgcztcbiAgICBpZiAodC50byA8IHQuZnJvbSlcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIid0bycgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJ2Zyb20nLiBSZXR1cm5pbmcgZGVmYXVsdCBkaXNwbGF5LlwiXG4gICAgICApLCBzO1xuICB9XG4gIHJldHVybiB0O1xufSwgcHMgPSAodCwgZSkgPT4gdCA/IHQuZnJvbSAmJiAhdC50byA/IHtcbiAgZnJvbTogdC5mcm9tLFxuICB0bzogZS5kdXJhdGlvblxufSA6IHQgOiB7XG4gIGZyb206IDAsXG4gIHRvOiBlLmR1cmF0aW9uXG59O1xuZnVuY3Rpb24gdGUodCwgZSkge1xuICBjb25zdCByID0gdC5zY2FsZU1vZGUsIHMgPSB7XG4gICAgeDogdC5zaXplLndpZHRoIC8gMixcbiAgICB5OiB0LnNpemUuaGVpZ2h0IC8gMlxuICB9LCBhID0geyB4OiBlLndpZHRoIC8gMiwgeTogZS5oZWlnaHQgLyAyIH07XG4gIGxldCBjO1xuICByID09PSBcImZpbGxcIiA/IGMgPSBNYXRoLm1heChcbiAgICB0LnNpemUud2lkdGggLyBlLndpZHRoLFxuICAgIHQuc2l6ZS5oZWlnaHQgLyBlLmhlaWdodFxuICApIDogYyA9IE1hdGgubWluKFxuICAgIHQuc2l6ZS53aWR0aCAvIGUud2lkdGgsXG4gICAgdC5zaXplLmhlaWdodCAvIGUuaGVpZ2h0XG4gICk7XG4gIGNvbnN0IGQgPSBzLnggLSBhLng7XG4gIHJldHVybiB7XG4gICAgdG9wOiBgJHtzLnkgLSBhLnl9cHhgLFxuICAgIGxlZnQ6IGAke2R9cHhgLFxuICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7Y30pYFxuICB9O1xufVxuY29uc3QgaHMgPSBhc3luYyAodCwgZSkgPT4ge1xuICBjb25zdCByID0gdC5kZXRhaWxzLnNyYywgcyA9IGF3YWl0IElpKHQpLCBhID0gdGUoZSwge1xuICAgIC4uLnNcbiAgfSksIGMgPSBwcyh0LnRyaW0sIHsgZHVyYXRpb246IHMuZHVyYXRpb24gfSksIGQgPSB7XG4gICAgd2lkdGg6IHMud2lkdGgsXG4gICAgaGVpZ2h0OiBzLmhlaWdodCxcbiAgICBvcGFjaXR5OiAxMDAsXG4gICAgc3JjOiByLFxuICAgIHZvbHVtZTogdC5kZXRhaWxzLnZvbHVtZSA/PyAxMDAsXG4gICAgLy8gRGVmYXVsdCB2b2x1bWVcbiAgICBib3JkZXJSYWRpdXM6IHQuZGV0YWlscy5ib3JkZXJSYWRpdXMgPz8gMCxcbiAgICAvLyBEZWZhdWx0IGJvcmRlciByYWRpdXNcbiAgICBib3JkZXJXaWR0aDogdC5kZXRhaWxzLmJvcmRlcldpZHRoID8/IDAsXG4gICAgLy8gRGVmYXVsdCBib3JkZXIgd2lkdGhcbiAgICBib3JkZXJDb2xvcjogdC5kZXRhaWxzLmJvcmRlckNvbG9yIHx8IFwiIzAwMDAwMFwiLFxuICAgIC8vIERlZmF1bHQgYm9yZGVyIGNvbG9yXG4gICAgYm94U2hhZG93OiB0LmRldGFpbHMuYm94U2hhZG93IHx8IHdyLFxuICAgIHRvcDogdC5kZXRhaWxzLnRvcCB8fCBhLnRvcCB8fCBcIjBweFwiLFxuICAgIC8vIERlZmF1bHQgdG9wXG4gICAgbGVmdDogdC5kZXRhaWxzLmxlZnQgfHwgYS5sZWZ0IHx8IFwiMHB4XCIsXG4gICAgLy8gRGVmYXVsdCBsZWZ0XG4gICAgdHJhbnNmb3JtOiB0LmRldGFpbHMudHJhbnNmb3JtIHx8IGEudHJhbnNmb3JtLFxuICAgIC8vIERlZmF1bHQgdHJhbnNmb3JtXG4gICAgYmx1cjogdC5kZXRhaWxzLmJsdXIgfHwgMCxcbiAgICBicmlnaHRuZXNzOiB0LmRldGFpbHMuYnJpZ2h0bmVzcyB8fCAxMDAsXG4gICAgZmxpcFg6IHQuZGV0YWlscy5mbGlwWCB8fCAhMSxcbiAgICBmbGlwWTogdC5kZXRhaWxzLmZsaXBZIHx8ICExLFxuICAgIHJvdGF0ZTogdC5kZXRhaWxzLnJvdGF0ZSB8fCBcIjBkZWdcIixcbiAgICB2aXNpYmlsaXR5OiB0LmRldGFpbHMudmlzaWJpbGl0eSB8fCBcInZpc2libGVcIlxuICB9O1xuICByZXR1cm4ge1xuICAgIC4uLnQsXG4gICAgdHJpbTogYyxcbiAgICB0eXBlOiBcInZpZGVvXCIsXG4gICAgbmFtZTogXCJ2aWRlb1wiLFxuICAgIGRldGFpbHM6IGQsXG4gICAgcGxheWJhY2tSYXRlOiB0LnBsYXliYWNrUmF0ZSB8fCAxLFxuICAgIGRpc3BsYXk6IHZlKHQuZGlzcGxheSwgeyBkdXJhdGlvbjogcy5kdXJhdGlvbiwgdHJpbTogYyB9KSxcbiAgICBkdXJhdGlvbjogcy5kdXJhdGlvblxuICB9O1xufSwgbXMgPSBhc3luYyAodCkgPT4ge1xuICBjb25zdCBlID0gdC5pZCwgciA9IHQuZGV0YWlscywgYSA9IChhd2FpdCBscyhyLnNyYykpLmR1cmF0aW9uLCBjID0gcHModC50cmltLCB7IGR1cmF0aW9uOiBhIH0pO1xuICByZXR1cm4ge1xuICAgIGlkOiBlLFxuICAgIG5hbWU6IHQubmFtZSB8fCBcImF1ZGlvXCIsXG4gICAgdHlwZTogXCJhdWRpb1wiLFxuICAgIGRpc3BsYXk6IHZlKHQuZGlzcGxheSwgeyBkdXJhdGlvbjogYSwgdHJpbTogYyB9KSxcbiAgICB0cmltOiBjLFxuICAgIHBsYXliYWNrUmF0ZTogdC5wbGF5YmFja1JhdGUgfHwgMSxcbiAgICBkZXRhaWxzOiB7XG4gICAgICBzcmM6IHIuc3JjLFxuICAgICAgdm9sdW1lOiByLnZvbHVtZSA/PyAxMDBcbiAgICAgIC8vIERlZmF1bHQgdm9sdW1lXG4gICAgfSxcbiAgICBtZXRhZGF0YTogeyAuLi50Lm1ldGFkYXRhIH0sXG4gICAgZHVyYXRpb246IGFcbiAgfTtcbn0sIHlzID0gYXN5bmMgKHQsIGUpID0+IHtcbiAgdmFyIEU7XG4gIGNvbnN0IHIgPSB0LnRyYWNrSXRlbUlkcywgcyA9IHQuc2l6ZSB8fCB7XG4gICAgd2lkdGg6IHQuZGV0YWlscy53aWR0aCxcbiAgICBoZWlnaHQ6IHQuZGV0YWlscy5oZWlnaHRcbiAgfSwgYSA9IE1hdGgubWluKFxuICAgIGUuc2l6ZS53aWR0aCAvIHMud2lkdGgsXG4gICAgZS5zaXplLmhlaWdodCAvIHMuaGVpZ2h0XG4gICksIGMgPSAoKEUgPSB0LmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBFLnJvdGF0ZSkgfHwgMCwgZCA9IHRlKGUsIHMpLCBmID0gdC5kaXNwbGF5O1xuICBsZXQgYiA9IDEgLyAwLCBfID0gMDtcbiAgci5mb3JFYWNoKChtKSA9PiB7XG4gICAgY29uc3QgVCA9IHQudHJhY2tJdGVtc01hcFttXTtcbiAgICBULmRpc3BsYXkuZnJvbSA8IGIgJiYgKGIgPSBULmRpc3BsYXkuZnJvbSksIFQuZGlzcGxheS50byA+IF8gJiYgKF8gPSBULmRpc3BsYXkudG8pO1xuICB9KTtcbiAgY29uc3QgTSA9IHQudHJpbSB8fCB0LmRpc3BsYXkgfHwgeyBmcm9tOiBiLCB0bzogXyB9O1xuICByZXR1cm4ge1xuICAgIGlkOiB0LmlkLFxuICAgIHR5cGU6IFwidGVtcGxhdGVcIixcbiAgICBkZXRhaWxzOiB7XG4gICAgICAuLi5zLFxuICAgICAgdG9wOiB0LmRldGFpbHMudG9wIHx8IGQudG9wLFxuICAgICAgbGVmdDogdC5kZXRhaWxzLmxlZnQgfHwgZC5sZWZ0LFxuICAgICAgc2NhbGU6IGEsXG4gICAgICByb3RhdGU6IGNcbiAgICB9LFxuICAgIHRyaW06IE0sXG4gICAgZGlzcGxheTogZiB8fCB7IGZyb206IGIsIHRvOiBfIH0sXG4gICAgYWN0aXZlRWRpdDogITFcbiAgfTtcbn0sIFNpID0gYXN5bmMgKHQsIGUpID0+IHtcbiAgdmFyIE07XG4gIGNvbnN0IHIgPSB0LnRyYWNrSXRlbUlkcywgcyA9IHQuc2l6ZSB8fCB7XG4gICAgd2lkdGg6IHQuZGV0YWlscy53aWR0aCxcbiAgICBoZWlnaHQ6IHQuZGV0YWlscy5oZWlnaHRcbiAgfSwgYSA9IE1hdGgubWluKFxuICAgIGUuc2l6ZS53aWR0aCAvIHMud2lkdGgsXG4gICAgZS5zaXplLmhlaWdodCAvIHMuaGVpZ2h0XG4gICksIGMgPSAoKE0gPSB0LmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBNLnJvdGF0ZSkgfHwgMCwgZCA9IHRlKGUsIHMpLCBmID0gdC5kaXNwbGF5O1xuICBsZXQgYiA9IDEgLyAwLCBfID0gMDtcbiAgcmV0dXJuIHIuZm9yRWFjaCgoRSkgPT4ge1xuICAgIGNvbnN0IG0gPSB0LnRyYWNrSXRlbXNNYXBbRV07XG4gICAgbS5kaXNwbGF5LmZyb20gPCBiICYmIChiID0gbS5kaXNwbGF5LmZyb20pLCBtLmRpc3BsYXkudG8gPiBfICYmIChfID0gbS5kaXNwbGF5LnRvKTtcbiAgfSksIHtcbiAgICBpZDogdC5pZCxcbiAgICB0eXBlOiBcImNvbXBvc2l0aW9uXCIsXG4gICAgZGV0YWlsczoge1xuICAgICAgLi4ucyxcbiAgICAgIHRvcDogdC5kZXRhaWxzLnRvcCB8fCBkLnRvcCxcbiAgICAgIGxlZnQ6IHQuZGV0YWlscy5sZWZ0IHx8IGQubGVmdCxcbiAgICAgIHNjYWxlOiBhLFxuICAgICAgcm90YXRlOiBjXG4gICAgfSxcbiAgICBkaXNwbGF5OiBmIHx8IHsgZnJvbTogYiwgdG86IF8gfVxuICB9O1xufSwgR24gPSBhc3luYyAodCwgZSkgPT4ge1xuICBjb25zdCByID0gdC5kZXRhaWxzLCBzID0gT2Uoci5zcmMpLCBhID0gZmV0Y2goci5zcmMpLCBbYywgZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgcyxcbiAgICBhXG4gIF0pLCBmID0gYXdhaXQgZC50ZXh0KCksIGIgPSB0ZShlLCBjKSwgeyBzZXJpYWxpemVyOiBfLCBjb2xvcnM6IE0gfSA9IGtpKFxuICAgIHZpKGYpLFxuICAgIHQuaWQsXG4gICAgcGFyc2VGbG9hdChyLndpZHRoIHx8IGMud2lkdGgpLFxuICAgIHBhcnNlRmxvYXQoci5oZWlnaHQgfHwgYy5oZWlnaHQpXG4gICksIEUgPSB0LmRldGFpbHMuY29sb3JNYXAgfHwgT2JqZWN0LmZyb21FbnRyaWVzKE0ubWFwKChtKSA9PiBbbSwgbV0pKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogdC5pZCxcbiAgICBuYW1lOiBcImlsbHVzdHJhdGlvblwiLFxuICAgIHR5cGU6IHQudHlwZSxcbiAgICBkaXNwbGF5OiB2ZSh0LmRpc3BsYXkpLFxuICAgIHBsYXliYWNrUmF0ZTogdC5wbGF5YmFja1JhdGUgfHwgMSxcbiAgICBkZXRhaWxzOiB7XG4gICAgICBzcmM6IHIuc3JjIHx8IFwiXCIsXG4gICAgICAvLyBEZWZhdWx0IHNvdXJjZSBVUkxcbiAgICAgIHdpZHRoOiByLndpZHRoIHx8IGMud2lkdGggfHwgMTAwLFxuICAgICAgLy8gRGVmYXVsdCB3aWR0aFxuICAgICAgaGVpZ2h0OiByLmhlaWdodCB8fCBjLmhlaWdodCB8fCAxMDAsXG4gICAgICAvLyBEZWZhdWx0IGhlaWdodFxuICAgICAgb3BhY2l0eTogci5vcGFjaXR5ID8/IDEwMCxcbiAgICAgIC8vIERlZmF1bHQgb3BhY2l0eVxuICAgICAgdHJhbnNmb3JtOiByLnRyYW5zZm9ybSB8fCBiLnRyYW5zZm9ybSxcbiAgICAgIC8vIERlZmF1bHQgdHJhbnNmb3JtXG4gICAgICBib3JkZXI6IHIuYm9yZGVyIHx8IFwibm9uZVwiLFxuICAgICAgLy8gRGVmYXVsdCBib3JkZXJcbiAgICAgIGJvcmRlclJhZGl1czogci5ib3JkZXJSYWRpdXMgfHwgMCxcbiAgICAgIC8vIERlZmF1bHQgYm9yZGVyIHJhZGl1c1xuICAgICAgdG9wOiByLnRvcCB8fCBiLnRvcCB8fCBcIjBweFwiLFxuICAgICAgLy8gRGVmYXVsdCB0b3BcbiAgICAgIGxlZnQ6IHIubGVmdCB8fCBiLmxlZnQgfHwgXCIwcHhcIixcbiAgICAgIC8vIERlZmF1bHQgbGVmdFxuICAgICAgYm9yZGVyV2lkdGg6IHIuYm9yZGVyV2lkdGggPz8gMCxcbiAgICAgIC8vIERlZmF1bHQgYm9yZGVyIHdpZHRoXG4gICAgICBib3JkZXJDb2xvcjogci5ib3JkZXJDb2xvciB8fCBcIiMwMDAwMDBcIixcbiAgICAgIC8vIERlZmF1bHQgYm9yZGVyIGNvbG9yXG4gICAgICBmbGlwWDogci5mbGlwWCB8fCAhMSxcbiAgICAgIGZsaXBZOiByLmZsaXBZIHx8ICExLFxuICAgICAgcm90YXRlOiByLnJvdGF0ZSB8fCBcIjBkZWdcIixcbiAgICAgIHZpc2liaWxpdHk6IHIudmlzaWJpbGl0eSB8fCBcInZpc2libGVcIixcbiAgICAgIHN2Z1N0cmluZzogXyxcbiAgICAgIGluaXRpYWxTdmdTdHJpbmc6IEsoXyksXG4gICAgICBjb2xvck1hcDogRVxuICAgIH0sXG4gICAgbWV0YWRhdGE6IHQubWV0YWRhdGEgfHwge31cbiAgfTtcbn0sIHdpID0gYXN5bmMgKHQsIGUpID0+IHtcbiAgY29uc3QgciA9IHQuZGV0YWlscywgcyA9IE9lKHIuc3JjKSwgW2FdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3NdKSwgYyA9IHRlKGUsIGEpO1xuICByZXR1cm4ge1xuICAgIGlkOiB0LmlkLFxuICAgIG5hbWU6IFwic2hhcGVcIixcbiAgICB0eXBlOiB0LnR5cGUsXG4gICAgZGlzcGxheTogdmUodC5kaXNwbGF5KSxcbiAgICBwbGF5YmFja1JhdGU6IHQucGxheWJhY2tSYXRlIHx8IDEsXG4gICAgZGV0YWlsczoge1xuICAgICAgc3JjOiByLnNyYyB8fCBcIlwiLFxuICAgICAgLy8gRGVmYXVsdCBzb3VyY2UgVVJMXG4gICAgICB3aWR0aDogci53aWR0aCB8fCBhLndpZHRoIHx8IDEwMCxcbiAgICAgIC8vIERlZmF1bHQgd2lkdGhcbiAgICAgIGhlaWdodDogci5oZWlnaHQgfHwgYS5oZWlnaHQgfHwgMTAwLFxuICAgICAgLy8gRGVmYXVsdCBoZWlnaHRcbiAgICAgIG9wYWNpdHk6IHIub3BhY2l0eSA/PyAxMDAsXG4gICAgICAvLyBEZWZhdWx0IG9wYWNpdHlcbiAgICAgIHRyYW5zZm9ybTogci50cmFuc2Zvcm0gfHwgYy50cmFuc2Zvcm0sXG4gICAgICAvLyBEZWZhdWx0IHRyYW5zZm9ybVxuICAgICAgYm9yZGVyOiByLmJvcmRlciB8fCBcIm5vbmVcIixcbiAgICAgIC8vIERlZmF1bHQgYm9yZGVyXG4gICAgICBib3JkZXJSYWRpdXM6IHIuYm9yZGVyUmFkaXVzIHx8IDAsXG4gICAgICAvLyBEZWZhdWx0IGJvcmRlciByYWRpdXNcbiAgICAgIHRvcDogci50b3AgfHwgYy50b3AgfHwgXCIwcHhcIixcbiAgICAgIC8vIERlZmF1bHQgdG9wXG4gICAgICBsZWZ0OiByLmxlZnQgfHwgYy5sZWZ0IHx8IFwiMHB4XCIsXG4gICAgICAvLyBEZWZhdWx0IGxlZnRcbiAgICAgIGJvcmRlcldpZHRoOiByLmJvcmRlcldpZHRoID8/IDAsXG4gICAgICAvLyBEZWZhdWx0IGJvcmRlciB3aWR0aFxuICAgICAgYm9yZGVyQ29sb3I6IHIuYm9yZGVyQ29sb3IgfHwgXCIjMDAwMDAwXCIsXG4gICAgICAvLyBEZWZhdWx0IGJvcmRlciBjb2xvclxuICAgICAgZmxpcFg6IHIuZmxpcFggfHwgITEsXG4gICAgICBmbGlwWTogci5mbGlwWSB8fCAhMSxcbiAgICAgIHJvdGF0ZTogci5yb3RhdGUgfHwgXCIwZGVnXCIsXG4gICAgICB2aXNpYmlsaXR5OiByLnZpc2liaWxpdHkgfHwgXCJ2aXNpYmxlXCIsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHIuYmFja2dyb3VuZENvbG9yIHx8IFwiIzgwODA4MFwiXG4gICAgfSxcbiAgICBtZXRhZGF0YTogdC5tZXRhZGF0YSB8fCB7fVxuICB9O1xufSwgZ3MgPSBhc3luYyAodCwgZSkgPT4ge1xuICBjb25zdCByID0gdC5kZXRhaWxzLCBzID0gYXdhaXQgT2Uoci5zcmMpLCBhID0gdGUoZSwgcyk7XG4gIHJldHVybiB7XG4gICAgaWQ6IHQuaWQsXG4gICAgdHlwZTogXCJpbWFnZVwiLFxuICAgIG5hbWU6IFwiaW1hZ2VcIixcbiAgICBkaXNwbGF5OiB2ZSh0LmRpc3BsYXkpLFxuICAgIHBsYXliYWNrUmF0ZTogdC5wbGF5YmFja1JhdGUgfHwgMSxcbiAgICBkZXRhaWxzOiB7XG4gICAgICBzcmM6IHIuc3JjIHx8IFwiXCIsXG4gICAgICAvLyBEZWZhdWx0IHNvdXJjZSBVUkxcbiAgICAgIHdpZHRoOiByLndpZHRoIHx8IHMud2lkdGggfHwgMTAwLFxuICAgICAgLy8gRGVmYXVsdCB3aWR0aFxuICAgICAgaGVpZ2h0OiByLmhlaWdodCB8fCBzLmhlaWdodCB8fCAxMDAsXG4gICAgICAvLyBEZWZhdWx0IGhlaWdodFxuICAgICAgb3BhY2l0eTogci5vcGFjaXR5ID8/IDEwMCxcbiAgICAgIC8vIERlZmF1bHQgb3BhY2l0eVxuICAgICAgdHJhbnNmb3JtOiByLnRyYW5zZm9ybSB8fCBhLnRyYW5zZm9ybSxcbiAgICAgIC8vIERlZmF1bHQgdHJhbnNmb3JtXG4gICAgICBib3JkZXI6IHIuYm9yZGVyIHx8IFwibm9uZVwiLFxuICAgICAgLy8gRGVmYXVsdCBib3JkZXJcbiAgICAgIGJvcmRlclJhZGl1czogci5ib3JkZXJSYWRpdXMgfHwgMCxcbiAgICAgIC8vIERlZmF1bHQgYm9yZGVyIHJhZGl1c1xuICAgICAgYm94U2hhZG93OiByLmJveFNoYWRvdyB8fCB3cixcbiAgICAgIC8vIERlZmF1bHQgYm94IHNoYWRvd1xuICAgICAgdG9wOiByLnRvcCB8fCBhLnRvcCB8fCBcIjBweFwiLFxuICAgICAgLy8gRGVmYXVsdCB0b3BcbiAgICAgIGxlZnQ6IHIubGVmdCB8fCBhLmxlZnQgfHwgXCIwcHhcIixcbiAgICAgIC8vIERlZmF1bHQgbGVmdFxuICAgICAgYm9yZGVyV2lkdGg6IHIuYm9yZGVyV2lkdGggPz8gMCxcbiAgICAgIC8vIERlZmF1bHQgYm9yZGVyIHdpZHRoXG4gICAgICBib3JkZXJDb2xvcjogci5ib3JkZXJDb2xvciB8fCBcIiMwMDAwMDBcIixcbiAgICAgIC8vIERlZmF1bHQgYm9yZGVyIGNvbG9yXG4gICAgICBibHVyOiByLmJsdXIgfHwgMCxcbiAgICAgIGJyaWdodG5lc3M6IHIuYnJpZ2h0bmVzcyB8fCAxMDAsXG4gICAgICBmbGlwWDogci5mbGlwWCB8fCAhMSxcbiAgICAgIGZsaXBZOiByLmZsaXBZIHx8ICExLFxuICAgICAgcm90YXRlOiByLnJvdGF0ZSB8fCBcIjBkZWdcIixcbiAgICAgIHZpc2liaWxpdHk6IHIudmlzaWJpbGl0eSB8fCBcInZpc2libGVcIlxuICAgIH0sXG4gICAgbWV0YWRhdGE6IHQubWV0YWRhdGEgfHwge31cbiAgfTtcbn0sIElzID0gYXN5bmMgKHQsIGUpID0+IHtcbiAgY29uc3QgciA9IHQ7XG4gIHIuZGV0YWlscy5mb250VXJsICYmIGF3YWl0IGJyKFtcbiAgICB7XG4gICAgICBmb250RmFtaWx5OiByLmRldGFpbHMuZm9udEZhbWlseSxcbiAgICAgIHVybDogci5kZXRhaWxzLmZvbnRVcmxcbiAgICB9XG4gIF0pO1xuICBjb25zdCBzID0gci5pZCwgYSA9IHIuZGV0YWlscywgYyA9IHZzKGEpLCBkID0gZHMoci5kZXRhaWxzLnRleHQsIGMpLCBmID0gdGUoZSwge1xuICAgIHdpZHRoOiBjLndpZHRoLFxuICAgIGhlaWdodDogZFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpZDogcyxcbiAgICBuYW1lOiBcImNhcHRpb25cIixcbiAgICB0eXBlOiBcImNhcHRpb25cIixcbiAgICBkaXNwbGF5OiB2ZShyLmRpc3BsYXkpLFxuICAgIGRldGFpbHM6IHtcbiAgICAgIC4uLmMsXG4gICAgICB0ZXh0OiBhLnRleHQgfHwgXCJcIixcbiAgICAgIC8vIERlZmF1bHQgdGV4dCBjb250ZW50XG4gICAgICBoZWlnaHQ6IGQsXG4gICAgICAvLyBEZWZhdWx0IGhlaWdodFxuICAgICAgZm9udFVybDogYS5mb250VXJsLFxuICAgICAgdG9wOiBjLnRvcCB8fCBmLnRvcCxcbiAgICAgIGxlZnQ6IGMubGVmdCB8fCBmLmxlZnQsXG4gICAgICBib3JkZXJXaWR0aDogYS5ib3JkZXJXaWR0aCB8fCAwLFxuICAgICAgYm9yZGVyQ29sb3I6IGEuYm9yZGVyQ29sb3IgfHwgXCIjMDAwMDAwXCIsXG4gICAgICBib3hTaGFkb3c6IGEuYm94U2hhZG93IHx8IHdyLFxuICAgICAgd29yZHM6IGEud29yZHMgfHwgW10sXG4gICAgICBhcHBlYXJlZENvbG9yOiBhLmFwcGVhcmVkQ29sb3IgfHwgYS5jb2xvcixcbiAgICAgIGFjdGl2ZUNvbG9yOiBhLmFjdGl2ZUNvbG9yIHx8IGEuY29sb3IsXG4gICAgICBhY3RpdmVGaWxsQ29sb3I6IGEuYWN0aXZlRmlsbENvbG9yIHx8IFwidHJhbnNwYXJlbnRcIlxuICAgIH0sXG4gICAgbWV0YWRhdGE6IHQubWV0YWRhdGEgfHwge31cbiAgfTtcbn0sIGJzID0gYXN5bmMgKHQsIGUpID0+IHtcbiAgdC5kZXRhaWxzLmZvbnRVcmwgJiYgYXdhaXQgYnIoW1xuICAgIHtcbiAgICAgIGZvbnRGYW1pbHk6IHQuZGV0YWlscy5mb250RmFtaWx5LFxuICAgICAgdXJsOiB0LmRldGFpbHMuZm9udFVybFxuICAgIH1cbiAgXSk7XG4gIGNvbnN0IHIgPSB0LmlkLCBzID0gdC5kZXRhaWxzLCBhID0gdnMocyksIGMgPSBkcyh0LmRldGFpbHMudGV4dCwgYSksIGQgPSB0ZShlLCB7XG4gICAgd2lkdGg6IGEud2lkdGgsXG4gICAgaGVpZ2h0OiBjXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlkOiByLFxuICAgIG5hbWU6IFwidGV4dFwiLFxuICAgIHR5cGU6IFwidGV4dFwiLFxuICAgIGRpc3BsYXk6IHZlKHQuZGlzcGxheSksXG4gICAgZGV0YWlsczoge1xuICAgICAgLi4uYSxcbiAgICAgIHRleHQ6IHMudGV4dCB8fCBcIlwiLFxuICAgICAgLy8gRGVmYXVsdCB0ZXh0IGNvbnRlbnRcbiAgICAgIGhlaWdodDogYyxcbiAgICAgIC8vIERlZmF1bHQgaGVpZ2h0XG4gICAgICBmb250VXJsOiBzLmZvbnRVcmwsXG4gICAgICB0b3A6IGEudG9wIHx8IGQudG9wLFxuICAgICAgbGVmdDogYS5sZWZ0IHx8IGQubGVmdCxcbiAgICAgIGJvcmRlcldpZHRoOiBzLmJvcmRlcldpZHRoIHx8IDAsXG4gICAgICBib3JkZXJDb2xvcjogcy5ib3JkZXJDb2xvciB8fCBcIiMwMDAwMDBcIixcbiAgICAgIGJveFNoYWRvdzogcy5ib3hTaGFkb3cgfHwgd3JcbiAgICB9LFxuICAgIG1ldGFkYXRhOiB7fVxuICB9O1xufSwgdnMgPSAodCkgPT4gKHtcbiAgZm9udEZhbWlseTogdC5mb250RmFtaWx5IHx8IFwiQXJpYWxcIixcbiAgLy8gRGVmYXVsdCBmb250IGZhbWlseVxuICBmb250U2l6ZTogdC5mb250U2l6ZSB8fCBcIjE2cHhcIixcbiAgLy8gRGVmYXVsdCBmb250IHNpemVcbiAgZm9udFdlaWdodDogdC5mb250V2VpZ2h0IHx8IFwibm9ybWFsXCIsXG4gIC8vIERlZmF1bHQgZm9udCB3ZWlnaHRcbiAgZm9udFN0eWxlOiB0LmZvbnRTdHlsZSB8fCBcIm5vcm1hbFwiLFxuICAvLyBEZWZhdWx0IGZvbnQgc3R5bGVcbiAgdGV4dERlY29yYXRpb246IHQudGV4dERlY29yYXRpb24gfHwgXCJub25lXCIsXG4gIC8vIERlZmF1bHQgdGV4dCBkZWNvcmF0aW9uXG4gIHRleHRBbGlnbjogdC50ZXh0QWxpZ24gfHwgXCJsZWZ0XCIsXG4gIC8vIERlZmF1bHQgdGV4dCBhbGlnbm1lbnRcbiAgbGluZUhlaWdodDogdC5saW5lSGVpZ2h0IHx8IFwibm9ybWFsXCIsXG4gIC8vIERlZmF1bHQgbGluZSBoZWlnaHRcbiAgbGV0dGVyU3BhY2luZzogdC5sZXR0ZXJTcGFjaW5nIHx8IFwibm9ybWFsXCIsXG4gIC8vIERlZmF1bHQgbGV0dGVyIHNwYWNpbmdcbiAgd29yZFNwYWNpbmc6IHQud29yZFNwYWNpbmcgfHwgXCJub3JtYWxcIixcbiAgLy8gRGVmYXVsdCB3b3JkIHNwYWNpbmdcbiAgY29sb3I6IHQuY29sb3IgfHwgXCIjZmZmZmZmXCIsXG4gIC8vIERlZmF1bHQgdGV4dCBjb2xvciAoYmxhY2spXG4gIGJhY2tncm91bmRDb2xvcjogdC5iYWNrZ3JvdW5kQ29sb3IgfHwgXCJ0cmFuc3BhcmVudFwiLFxuICAvLyBEZWZhdWx0IGJhY2tncm91bmQgY29sb3JcbiAgYm9yZGVyOiB0LmJvcmRlciB8fCBcIm5vbmVcIixcbiAgLy8gRGVmYXVsdCBib3JkZXJcbiAgdGV4dFNoYWRvdzogdC50ZXh0U2hhZG93IHx8IFwibm9uZVwiLFxuICAvLyBEZWZhdWx0IHRleHQgc2hhZG93XG4gIHRleHQ6IHQudGV4dCB8fCBcIlwiLFxuICAvLyBEZWZhdWx0IHRleHQgY29udGVudFxuICBvcGFjaXR5OiB0Lm9wYWNpdHkgPz8gMTAwLFxuICAvLyBEZWZhdWx0IG9wYWNpdHlcbiAgd2lkdGg6IHQud2lkdGggfHwgMzAwLFxuICB3b3JkV3JhcDogdC53b3JkV3JhcCB8fCBcIm5vcm1hbFwiLFxuICAvLydicmVhay13b3JkJ1xuICB3b3JkQnJlYWs6IHQud29yZEJyZWFrIHx8IFwibm9ybWFsXCIsXG4gIC8vJ2JyZWFrLWFsbCcsXG4gIFdlYmtpdFRleHRTdHJva2VDb2xvcjogdC5XZWJraXRUZXh0U3Ryb2tlQ29sb3IgfHwgXCIjZmZmZmZmXCIsXG4gIFdlYmtpdFRleHRTdHJva2VXaWR0aDogdC5XZWJraXRUZXh0U3Ryb2tlV2lkdGggfHwgXCIwcHhcIixcbiAgdG9wOiB0LnRvcCxcbiAgbGVmdDogdC5sZWZ0LFxuICB0ZXh0VHJhbnNmb3JtOiB0LnRleHRUcmFuc2Zvcm0gfHwgXCJub25lXCIsXG4gIHRyYW5zZm9ybTogdC50cmFuc2Zvcm0gfHwgXCJub25lXCIsXG4gIHNrZXdYOiB0LnNrZXdYIHx8IDAsXG4gIHNrZXdZOiB0LnNrZXdZIHx8IDBcbn0pLCBNaSA9IGFzeW5jICh0LCBlKSA9PiB7XG4gIHN3aXRjaCAodC50eXBlKSB7XG4gICAgY2FzZSBcInZpZGVvXCI6XG4gICAgICByZXR1cm4gaHModCwgZSB8fCB7fSk7XG4gICAgY2FzZSBcImF1ZGlvXCI6XG4gICAgICByZXR1cm4gbXModCk7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICByZXR1cm4gZ3ModCwgZSB8fCB7fSk7XG4gICAgY2FzZSBcInRleHRcIjpcbiAgICAgIHJldHVybiBicyh0LCBlIHx8IHt9KTtcbiAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgcmV0dXJuIElzKHQsIGUgfHwge30pO1xuICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxuICAgICAgcmV0dXJuIHlzKHQsIHtcbiAgICAgICAgc2l6ZTogZSA9PSBudWxsID8gdm9pZCAwIDogZS5zaXplXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdHJhY2sgaXRlbVwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIEVpKHQsIGUpIHtcbiAgcmV0dXJuIGUuc29tZShcbiAgICAocikgPT4gdC5zb21lKChzKSA9PiBzLmlkID09PSByLmlkKVxuICApO1xufVxuY29uc3QgVGkgPSAodCA9IFtdLCBlID0gW10pID0+IHQubGVuZ3RoID09PSAwID8gZS5tYXAoKHMpID0+ICh7XG4gIGlkOiBEZSgpLFxuICBpdGVtczogW3MuaWRdLFxuICB0eXBlOiBzLnR5cGUsXG4gIGFjY2VwdHM6IFtcInRleHRcIiwgXCJpbWFnZVwiLCBcInZpZGVvXCIsIFwiYXVkaW9cIiwgXCJjYXB0aW9uXCIsIFwidGVtcGxhdGVcIl1cbn0pKSA6IHQubWFwKChyKSA9PiAoe1xuICAuLi5yLFxuICBpdGVtczogci5pdGVtcyB8fCBbXSxcbiAgYWNjZXB0czogW1wiYXVkaW9cIiwgXCJ2aWRlb1wiLCBcImltYWdlXCIsIFwidGV4dFwiLCBcImNhcHRpb25cIiwgXCJ0ZW1wbGF0ZVwiXSxcbiAgdHlwZTogci50eXBlIHx8IFwidGV4dFwiLFxuICBtYWduZXRpYzogci5tYWduZXRpYyB8fCAhMSxcbiAgc3RhdGljOiByLnN0YXRpYyB8fCAhMSxcbiAgaWQ6IHIuaWQgfHwgRGUoKVxufSkpO1xuZnVuY3Rpb24gQWkodCwgZSkge1xuICByZXR1cm4gdC5maWx0ZXIoKHMpID0+IHtcbiAgICBpZiAoZS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBzLml0ZW1zLmluY2x1ZGVzKGEpICYmIChzLml0ZW1zID0gcy5pdGVtcy5maWx0ZXIoKGMpID0+IGMgIT09IGEpKTtcbiAgICB9KSwgcy5pdGVtcy5sZW5ndGggIT09IDAgfHwgcy5zdGF0aWMpXG4gICAgICByZXR1cm4gcztcbiAgfSk7XG59XG5jb25zdCBoZSA9ICh0KSA9PiBPYmplY3Qua2V5cyh0KS5yZWR1Y2UoKGUsIHIpID0+IHtcbiAgY29uc3QgeyBkaXNwbGF5OiBzLCBwbGF5YmFja1JhdGU6IGEgfSA9IHRbcl07XG4gIHJldHVybiBNYXRoLm1heChlLCBzLnRvIC8gKGEgfHwgMSkpO1xufSwgMCk7XG5mdW5jdGlvbiBrbih0LCBlLCByKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh0LCBlKSwgcik7XG59XG5jb25zdCB4aSA9ICh0LCBlLCByLCBzLCBhKSA9PiB7XG4gIGlmIChzID09PSB2b2lkIDAgJiYgYSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB7IHRyYWNrSWQ6IHZvaWQgMCwgdHJhY2tJbmRleDogdm9pZCAwIH07XG4gIGNvbnN0IGMgPSBhICE9PSB2b2lkIDAgPyBlW2tuKGEsIDAsIGUubGVuZ3RoKV0gOiBlLmZpbmQoKGIpID0+IGIuaWQgPT09IHMpO1xuICBpZiAoIWMpXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNrSWQ6IHZvaWQgMCxcbiAgICAgIHRyYWNrSW5kZXg6IGEgIT09IHZvaWQgMCA/IGtuKGEsIDAsIGUubGVuZ3RoKSA6IHZvaWQgMFxuICAgIH07XG4gIGNvbnN0IGQgPSBjLml0ZW1zLm1hcCgoYikgPT4gcltiXSksIGYgPSB0Lm1hcCgoYikgPT4gcltiXSk7XG4gIGZvciAoY29uc3QgYiBvZiBkKSB7XG4gICAgY29uc3QgXyA9IGIuZGlzcGxheS5mcm9tLCBNID0gYi5kaXNwbGF5LnRvO1xuICAgIGZvciAoY29uc3QgRSBvZiBmKSB7XG4gICAgICBjb25zdCBtID0gRS5kaXNwbGF5LmZyb207XG4gICAgICBpZiAoIShFLmRpc3BsYXkudG8gPD0gXyB8fCBtID49IE0pKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYWNrSWQ6IHZvaWQgMCxcbiAgICAgICAgICB0cmFja0luZGV4OiBlLmluZGV4T2YoYylcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0cmFja0lkOiBjLmlkLFxuICAgIHRyYWNrSW5kZXg6IGUuaW5kZXhPZihjKVxuICB9O1xufSwgWW4gPSAodCwgZSkgPT4ge1xuICB2YXIgZiwgYjtcbiAgY29uc3QgciA9ICgoZiA9IHQuZGV0YWlscy5jcm9wKSA9PSBudWxsID8gdm9pZCAwIDogZi53aWR0aCkgfHwgdC5kZXRhaWxzLndpZHRoIHx8IDAsIHMgPSAoKGIgPSB0LmRldGFpbHMuY3JvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IGIuaGVpZ2h0KSB8fCB0LmRldGFpbHMuaGVpZ2h0IHx8IDA7XG4gIGxldCBhID0gZS53aWR0aCwgYyA9IGUuaGVpZ2h0O1xuICBjb25zdCBkID0gZS53aWR0aCAvIGUuaGVpZ2h0O1xuICByZXR1cm4gciAvIHMgPiBkID8gKGEgPSByLCBjID0gciAvIGQpIDogKGMgPSBzLCBhID0gcyAqIGQpLCB7XG4gICAgbmV3V2lkdGg6IGEsXG4gICAgbmV3SGVpZ2h0OiBjLFxuICAgIGNyb3A6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgaGVpZ2h0OiBzLFxuICAgICAgd2lkdGg6IHJcbiAgICB9XG4gIH07XG59LCBCbiA9ICh0LCBlKSA9PiB7XG4gIGNvbnN0IHIgPSBLKHQudHJpbSksIHMgPSBLKHQuZGlzcGxheSk7XG4gIHJldHVybiBlLmR1cmF0aW9uIDwgdC5kaXNwbGF5LnRvICYmIChzLnRvID0gZS5kdXJhdGlvbiwgciAmJiAoci50byA9IGUuZHVyYXRpb24pKSwge1xuICAgIGR1cmF0aW9uOiBlLmR1cmF0aW9uLFxuICAgIHRyaW06IHIsXG4gICAgZGlzcGxheTogc1xuICB9O1xufSwgRGkgPSAodCkgPT4ge1xuICBjb25zdCB7IHRyYWNrSXRlbUlkczogZSwgdHJhbnNpdGlvbnNNYXA6IHIsIHRyYWNrSXRlbXNNYXA6IHMgfSA9IHQsIGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBPYmplY3QudmFsdWVzKHIpLmZvckVhY2goKF8pID0+IHtcbiAgICB2YXIgVCwgQztcbiAgICBjb25zdCB7IGZyb21JZDogTSwgdG9JZDogRSwga2luZDogbSB9ID0gXztcbiAgICBtICE9PSBcIm5vbmVcIiAmJiAoYS5oYXMoTSkgfHwgYS5zZXQoTSwgW10pLCBhLmhhcyhFKSB8fCBhLnNldChFLCBbXSksIChUID0gYS5nZXQoTSkpID09IG51bGwgfHwgVC5wdXNoKF8pLCAoQyA9IGEuZ2V0KEUpKSA9PSBudWxsIHx8IEMucHVzaChfKSk7XG4gIH0pO1xuICBjb25zdCBjID0gW10sIGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBmID0gKF8pID0+IHtcbiAgICBjb25zdCBNID0gW107XG4gICAgbGV0IEUgPSBfO1xuICAgIGZvciAoOyBFICYmICFkLmhhcyhFKTsgKSB7XG4gICAgICBkLmFkZChFKTtcbiAgICAgIGNvbnN0IG0gPSBzW0VdO1xuICAgICAgTS5wdXNoKG0pO1xuICAgICAgY29uc3QgVCA9IE9iamVjdC52YWx1ZXMocikuZmluZChcbiAgICAgICAgKEMpID0+IEMuZnJvbUlkID09PSBFICYmIEMua2luZCAhPT0gXCJub25lXCJcbiAgICAgICAgLy8gRmlsdGVyIGhlcmVcbiAgICAgICk7XG4gICAgICBpZiAoIVQpIGJyZWFrO1xuICAgICAgTS5wdXNoKFQpLCBFID0gVC50b0lkO1xuICAgIH1cbiAgICByZXR1cm4gTTtcbiAgfSwgYiA9IE9iamVjdC52YWx1ZXMocikuZmlsdGVyKFxuICAgIChfKSA9PiBfLmtpbmQgIT09IFwibm9uZVwiXG4gICk7XG4gIGZvciAoY29uc3QgXyBvZiBlKVxuICAgIGlmICghZC5oYXMoXykgJiYgKCFhLmhhcyhfKSB8fCAhYi5zb21lKChNKSA9PiBNLnRvSWQgPT09IF8pKSkge1xuICAgICAgY29uc3QgTSA9IGYoXyk7XG4gICAgICBNLmxlbmd0aCA+IDAgJiYgYy5wdXNoKE0pO1xuICAgIH1cbiAgcmV0dXJuIGMuZm9yRWFjaCgoXykgPT4ge1xuICAgIF8uc29ydCgoTSwgRSkgPT4gXCJkaXNwbGF5XCIgaW4gTSAmJiBcImRpc3BsYXlcIiBpbiBFID8gTS5kaXNwbGF5LmZyb20gLSBFLmRpc3BsYXkuZnJvbSA6IDApO1xuICB9KSwgYy5maWx0ZXIoKF8pID0+IF8uZmlsdGVyKChFKSA9PiBFICE9PSB2b2lkIDApLmxlbmd0aCA+IDApO1xufTtcbmZ1bmN0aW9uIFhuKHQsIGUsIHIpIHtcbiAgdC5mb3JFYWNoKChzKSA9PiB7XG4gICAgY29uc3QgZCA9IE9iamVjdC52YWx1ZXMoZSkuZmlsdGVyKFxuICAgICAgKF8pID0+IHMuaXRlbXMuaW5jbHVkZXMoXy5pZClcbiAgICApLnNvcnQoXG4gICAgICAoXywgTSkgPT4gXy5kaXNwbGF5LmZyb20gLSBNLmRpc3BsYXkuZnJvbVxuICAgICkubWFwKChfKSA9PiBfLmlkKSwgZiA9IERpKHtcbiAgICAgIHRyYWNrSXRlbUlkczogZCxcbiAgICAgIHRyYW5zaXRpb25zTWFwOiByLFxuICAgICAgdHJhY2tJdGVtc01hcDogZVxuICAgIH0pO1xuICAgIGxldCBiID0gMDtcbiAgICBkLmZvckVhY2goKF8pID0+IHtcbiAgICAgIGNvbnN0IE0gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBmKVxuICAgICAgICBpZiAobS5maW5kKChUKSA9PiBULmlkID09PSBfKSkge1xuICAgICAgICAgIGNvbnN0IFQgPSBmLmZpbmRJbmRleChcbiAgICAgICAgICAgIChDKSA9PiBDLmZpbmQoKHUpID0+IHUuaWQgPT09IF8pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoVCAtIDEgPj0gMClcbiAgICAgICAgICAgIGZvciAobGV0IEMgPSBUIC0gMTsgQyA+PSAwOyBDLS0pIHtcbiAgICAgICAgICAgICAgY29uc3QgdSA9IGZbQ107XG4gICAgICAgICAgICAgIE0ucHVzaCh1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgbGV0IEUgPSAwO1xuICAgICAgaWYgKE0uZm9yRWFjaCgobSkgPT4ge1xuICAgICAgICBtLmZvckVhY2goKFQpID0+IHtcbiAgICAgICAgICBULnR5cGUgPT09IFwidHJhbnNpdGlvblwiICYmIChFICs9IFQuZHVyYXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0pLCBlW19dKSB7XG4gICAgICAgIGNvbnN0IG0gPSBlW19dLmRpc3BsYXkudG8gLSBlW19dLmRpc3BsYXkuZnJvbTtcbiAgICAgICAgZVtfXS5kaXNwbGF5ID0ge1xuICAgICAgICAgIGZyb206IGIgLSBFLFxuICAgICAgICAgIHRvOiBiICsgbSAtIEVcbiAgICAgICAgfSwgYiArPSBtO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIE9pKHQsIGUpIHtcbiAgbGV0IHMgPSBlLnJlZHVjZShcbiAgICAoYSwgYykgPT4gYy5kaXNwbGF5LnRvID4gYS5kaXNwbGF5LnRvID8gYyA6IGEsXG4gICAgeyBkaXNwbGF5OiB7IHRvOiAwIH0gfVxuICApLmRpc3BsYXkudG87XG4gIHQuZm9yRWFjaCgoYSkgPT4ge1xuICAgIGNvbnN0IGMgPSBhLmRpc3BsYXkuZnJvbSwgZiA9IGEuZGlzcGxheS50byAtIGM7XG4gICAgYS5kaXNwbGF5LmZyb20gPSBzLCBhLmRpc3BsYXkudG8gPSBhLmRpc3BsYXkuZnJvbSArIGYsIHMgPSBhLmRpc3BsYXkudG87XG4gIH0pO1xufVxuZnVuY3Rpb24gQ2kodCkge1xuICBjb25zdCBlID0gdCwgciA9IGUudHJhY2tzLCBzID0gZS50cmFja0l0ZW1zTWFwLCBhID0gW10sIGMgPSB7fSwgZCA9IGUuc3RydWN0dXJlO1xuICByZXR1cm4gci5mb3JFYWNoKChmKSA9PiB7XG4gICAgdmFyIF87XG4gICAgY29uc3QgYiA9IGYuaXRlbXMubWFwKChNKSA9PiBzW01dKS5zb3J0KChNLCBFKSA9PiBNLmRpc3BsYXkuZnJvbSAtIEUuZGlzcGxheS5mcm9tKTtcbiAgICBmb3IgKGxldCBNID0gMDsgTSA8IGIubGVuZ3RoIC0gMTsgTSsrKSB7XG4gICAgICBjb25zdCBFID0gYltNXSwgbSA9IGJbTSArIDFdO1xuICAgICAgaWYgKE1hdGguYWJzKEUuZGlzcGxheS50byAtIG0uZGlzcGxheS5mcm9tKSA8PSAxKSB7XG4gICAgICAgIGNvbnN0IFQgPSBgJHtFLmlkfS0ke20uaWR9YDtcbiAgICAgICAgaWYgKChfID0gZS50cmFuc2l0aW9uSWRzKSA9PSBudWxsID8gdm9pZCAwIDogXy5pbmNsdWRlcyhUKSlcbiAgICAgICAgICBjW1RdID0gZS50cmFuc2l0aW9uc01hcFtUXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgdSA9IHtcbiAgICAgICAgICAgIGlkOiBULFxuICAgICAgICAgICAgZHVyYXRpb246IDE1MDAsXG4gICAgICAgICAgICBmcm9tSWQ6IEUuaWQsXG4gICAgICAgICAgICB0b0lkOiBtLmlkLFxuICAgICAgICAgICAga2luZDogXCJub25lXCIsXG4gICAgICAgICAgICB0cmFja0lkOiBmLmlkLFxuICAgICAgICAgICAgdHlwZTogXCJ0cmFuc2l0aW9uXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNbVF0gPSB1O1xuICAgICAgICB9XG4gICAgICAgIGEucHVzaChUKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBkLmZvckVhY2goKGYpID0+IHtcbiAgICBmLnRyYW5zaXRpb25zLmZvckVhY2goKGIpID0+IHtcbiAgICAgIGNbYl0gPSB7XG4gICAgICAgIC4uLmUudHJhbnNpdGlvbnNNYXBbYl0sXG4gICAgICAgIHRyYWNrSWQ6IGYuaWRcbiAgICAgIH07XG4gICAgfSk7XG4gIH0pLCBlLnRyYW5zaXRpb25JZHMgPSBhLCBlLnRyYW5zaXRpb25zTWFwID0gYywge1xuICAgIHRyYW5zaXRpb25JZHM6IGEsXG4gICAgdHJhbnNpdGlvbnNNYXA6IGNcbiAgfTtcbn1cbmZ1bmN0aW9uIFBpKHQsIGUsIHIpIHtcbiAgY29uc3QgcyA9IHQudG9JZCwgYSA9IHJbc10sIGMgPSBlLmZpbmQoKGQpID0+IGQuaXRlbXMuaW5jbHVkZXMocykpO1xuICBjICYmIChjLm1hZ25ldGljIHx8IGMuaXRlbXMuZm9yRWFjaCgoZCkgPT4ge1xuICAgIGNvbnN0IGYgPSByW2RdO1xuICAgIGYuZGlzcGxheS5mcm9tID4gYS5kaXNwbGF5LmZyb20gJiYgKGYuZGlzcGxheS5mcm9tID0gZi5kaXNwbGF5LmZyb20gKyB0LmR1cmF0aW9uLCBmLmRpc3BsYXkudG8gPSBmLmRpc3BsYXkudG8gKyB0LmR1cmF0aW9uKTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gUmkodCkge1xuICBjb25zdCBlID0gZGUucGlwZShcbiAgICBmZSgoeyBrZXk6IHUgfSkgPT4gdS5zdGFydHNXaXRoKERuKSlcbiAgKSwgciA9IGRlLnBpcGUoXG4gICAgZmUoKHsga2V5OiB1IH0pID0+IHUuc3RhcnRzV2l0aChndCkpXG4gICksIHMgPSBkZS5waXBlKFxuICAgIGZlKCh7IGtleTogdSB9KSA9PiB1LnN0YXJ0c1dpdGgocHQpKVxuICApLCBhID0gZGUucGlwZShcbiAgICBmZSgoeyBrZXk6IHUgfSkgPT4gdS5zdGFydHNXaXRoKFNyKSlcbiAgKSwgYyA9IGRlLnBpcGUoXG4gICAgZmUoKHsga2V5OiB1IH0pID0+IHUuc3RhcnRzV2l0aChDZSkpXG4gICksIGQgPSBkZS5waXBlKFxuICAgIGZlKCh7IGtleTogdSB9KSA9PiB1LnN0YXJ0c1dpdGgoYmUpKVxuICApLCBmID0gZGUucGlwZShcbiAgICBmZSgoeyBrZXk6IHUgfSkgPT4gdS5zdGFydHNXaXRoKHVzKSlcbiAgKSwgYiA9IGUuc3Vic2NyaWJlKGFzeW5jICh1KSA9PiB7XG4gICAgdmFyIGwsIFM7XG4gICAgaWYgKHUua2V5ID09PSBYcykge1xuICAgICAgY29uc3QgdyA9IChsID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGwucGF5bG9hZCwgayA9IHcudHJhY2tJdGVtc01hcCwgaCA9IHcudHJhY2tJdGVtRGV0YWlsc01hcDtcbiAgICAgIGNvbnNvbGUud2FybihcIklNUFJPVkUgRk9OVFMgTE9BRElOR1wiKTtcbiAgICAgIGZvciAoY29uc3QgdiBpbiBoKVxuICAgICAgICBpZiAoaFt2XS50eXBlID09PSBcInRleHRcIiB8fCBoW3ZdLnR5cGUgPT09IFwiY2FwdGlvblwiKSB7XG4gICAgICAgICAgY29uc3QgSSA9IGhbdl0uZGV0YWlscztcbiAgICAgICAgICBhd2FpdCBicihbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IEkuZm9udEZhbWlseSxcbiAgICAgICAgICAgICAgdXJsOiBJLmZvbnRVcmxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChoW3ZdLnR5cGUgPT09IFwiaWxsdXN0cmF0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBJID0ga1t2XSwgeCA9IGhbdl0uZGV0YWlscywgZyA9IGF3YWl0IEduKFxuICAgICAgICAgICAgeyAuLi5JLCBkZXRhaWxzOiB4IH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNpemU6IHsgd2lkdGg6IHgud2lkdGgsIGhlaWdodDogeC5oZWlnaHQgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICksIE8gPSBXbihcbiAgICAgICAgICAgIGcuZGV0YWlscy5zdmdTdHJpbmcsXG4gICAgICAgICAgICB4LmNvbG9yTWFwXG4gICAgICAgICAgKTtcbiAgICAgICAgICBnLmRldGFpbHMuc3ZnU3RyaW5nID0gTywgaFt2XS5kZXRhaWxzID0gZy5kZXRhaWxzLCBrW3ZdID0gZztcbiAgICAgICAgfVxuICAgICAgY29uc3QgeSA9IGhlKGspO1xuICAgICAgdC51cGRhdGVTdGF0ZShcbiAgICAgICAge1xuICAgICAgICAgIC4uLncsXG4gICAgICAgICAgZHVyYXRpb246IHlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtpbmQ6IFwiZGVzaWduOmxvYWRcIixcbiAgICAgICAgICB1cGRhdGVIaXN0b3J5OiAhMVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodS5rZXkgPT09IEtzKSB7XG4gICAgICBjb25zdCB3ID0gKFMgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogUy5wYXlsb2FkO1xuICAgICAgdC51cGRhdGVTdGF0ZShcbiAgICAgICAge1xuICAgICAgICAgIHNpemU6IHdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtpbmQ6IFwiZGVzaWduOnJlc2l6ZVwiLFxuICAgICAgICAgIHVwZGF0ZUhpc3Rvcnk6ICExXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9KSwgXyA9IGEuc3Vic2NyaWJlKCh1KSA9PiB7XG4gICAgaWYgKHUua2V5ID09PSBoaSkgcmV0dXJuIHQudW5kbygpO1xuICAgIGlmICh1LmtleSA9PT0gbWkpIHJldHVybiB0LnJlZG8oKTtcbiAgfSksIE0gPSBmLnN1YnNjcmliZSgodSkgPT4ge1xuICAgIHZhciBsO1xuICAgIGlmICh1LmtleSA9PT0geWkpIHtcbiAgICAgIGNvbnN0IFMgPSAobCA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBsLnBheWxvYWQuc2NhbGU7XG4gICAgICB0LnVwZGF0ZVN0YXRlKFxuICAgICAgICB7XG4gICAgICAgICAgc2NhbGU6IFNcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtpbmQ6IFwidXBkYXRlXCIsXG4gICAgICAgICAgdXBkYXRlSGlzdG9yeTogITFcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH0pLCBFID0gcy5zdWJzY3JpYmUoYXN5bmMgKHUpID0+IHtcbiAgICB2YXIgUywgdywgaywgaCwgeTtcbiAgICBjb25zdCBsID0gW107XG4gICAgaWYgKChTID0gdS52YWx1ZSkgIT0gbnVsbCAmJiBTLnBheWxvYWQudHJhY2tJdGVtSWRzICYmIChsLnB1c2goKHcgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogdy5wYXlsb2FkLnRyYWNrSXRlbUlkcyksIHQudXBkYXRlU3RhdGUoXG4gICAgICB7IGFjdGl2ZUlkczogbCB9LFxuICAgICAge1xuICAgICAgICBraW5kOiBcInVwZGF0ZVwiLFxuICAgICAgICB1cGRhdGVIaXN0b3J5OiAhMVxuICAgICAgfVxuICAgICkpLCB1LmtleSA9PT0gZmkpIHtcbiAgICAgIGNvbnN0IHYgPSAoayA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBrLnBheWxvYWQudHJhY2tJdGVtSWRzLCBJID0gSyh0LmdldFN0YXRlKCkpLCB4ID0gdiAmJiB2Lmxlbmd0aCA/IHYgOiBJLmFjdGl2ZUlkcywgZyA9IHgubWFwKChBKSA9PiBJLnRyYWNrSXRlbXNNYXBbQV0pLmZpbHRlcigoQSkgPT4gISFBKS5tYXAoKEEpID0+IEEuaWQpLCBPID0gSS50cmFuc2l0aW9uSWRzLmZpbHRlcihcbiAgICAgICAgKEEpID0+IHtcbiAgICAgICAgICBjb25zdCBldCA9IEkudHJhbnNpdGlvbnNNYXBbQV07XG4gICAgICAgICAgcmV0dXJuIGcuaW5jbHVkZXMoZXQuZnJvbUlkKSB8fCBnLmluY2x1ZGVzKGV0LnRvSWQpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgZy5wdXNoKC4uLk8pO1xuICAgICAgY29uc3QgRCA9IHt9LCBqID0gSS50cmFja0l0ZW1JZHMsIEwgPSBJLnRyYW5zaXRpb25JZHMsIFIgPSBJLnRyYWNrSXRlbURldGFpbHNNYXAsIEYgPSBLKEkudHJhY2tzKSwgViA9IEsoSS5zdHJ1Y3R1cmUpO1xuICAgICAgZy5mb3JFYWNoKChBKSA9PiB7XG4gICAgICAgIHZhciBNdDtcbiAgICAgICAgY29uc3QgZXQgPSBJLnRyYWNrSXRlbXNNYXBbQV0gfHwgSS50cmFuc2l0aW9uc01hcFtBXTtcbiAgICAgICAgaWYgKGV0LnR5cGUgPT09IFwidGVtcGxhdGVcIikge1xuICAgICAgICAgIGNvbnN0IG90ID0gKE10ID0gSS5zdHJ1Y3R1cmUuZmluZChcbiAgICAgICAgICAgIChFdCkgPT4gRXQuaWQgPT09IGV0LmlkXG4gICAgICAgICAgKSkgPT0gbnVsbCA/IHZvaWQgMCA6IE10Lml0ZW1zO1xuICAgICAgICAgIGcucHVzaCguLi5vdCk7XG4gICAgICAgICAgY29uc3QgJHQgPSBWLmZpbmRJbmRleChcbiAgICAgICAgICAgIChFdCkgPT4gRXQuaWQgPT09IGV0LmlkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBWLnNwbGljZSgkdCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBnLmZvckVhY2goKEEpID0+IHtcbiAgICAgICAgVi5mb3JFYWNoKChldCkgPT4ge1xuICAgICAgICAgIGV0Lml0ZW1zLmluY2x1ZGVzKEEpICYmIChldC5pdGVtcyA9IGV0Lml0ZW1zLmZpbHRlcigoTXQpID0+IE10ICE9PSBBKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBrdCA9IGouZmlsdGVyKFxuICAgICAgICAoQSkgPT4gIWcuaW5jbHVkZXMoQSlcbiAgICAgICk7XG4gICAgICBMLmZvckVhY2goKEEpID0+IHtcbiAgICAgICAgeC5pbmNsdWRlcyhBKSAmJiB4Lmxlbmd0aCA9PT0gMSAmJiAoRFtBXSA9IEsoSS50cmFuc2l0aW9uc01hcFtBXSkpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBEdCA9IEwuZmlsdGVyKFxuICAgICAgICAoQSkgPT4gIWcuaW5jbHVkZXMoQSkgJiYgIXguaW5jbHVkZXMoQSlcbiAgICAgICksIE90ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhSKS5maWx0ZXIoXG4gICAgICAgICAgKFtBXSkgPT4gIWcuaW5jbHVkZXMoQSlcbiAgICAgICAgKVxuICAgICAgKSwgVSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoSS50cmFuc2l0aW9uc01hcCkuZmlsdGVyKFxuICAgICAgICAgIChbQV0pID0+ICFnLmluY2x1ZGVzKEEpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBPYmplY3Qua2V5cyhVKS5mb3JFYWNoKChBKSA9PiB7XG4gICAgICAgIHguaW5jbHVkZXMoQSkgJiYgKFVbQV0ua2luZCA9IFwibm9uZVwiKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgenQgPSBBaShcbiAgICAgICAgSS50cmFja3MsXG4gICAgICAgIGdcbiAgICAgICksIHd0ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhJLnRyYWNrSXRlbXNNYXApLmZpbHRlcihcbiAgICAgICAgICAoW0FdKSA9PiAhZy5pbmNsdWRlcyhBKVxuICAgICAgICApXG4gICAgICApLCBhdCA9IEYuZmlsdGVyKChBKSA9PiBBLm1hZ25ldGljKTtcbiAgICAgIFhuKFxuICAgICAgICBhdCxcbiAgICAgICAgd3QsXG4gICAgICAgIEkudHJhbnNpdGlvbnNNYXBcbiAgICAgICk7XG4gICAgICBjb25zdCBGdCA9IGhlKHd0KTtcbiAgICAgIE9iamVjdC5rZXlzKEQpLmZvckVhY2goKEEpID0+IHtcbiAgICAgICAgUGkoXG4gICAgICAgICAgRFtBXSxcbiAgICAgICAgICB6dCxcbiAgICAgICAgICB3dFxuICAgICAgICApO1xuICAgICAgfSksIHQudXBkYXRlU3RhdGUoXG4gICAgICAgIHtcbiAgICAgICAgICB0cmFja0l0ZW1JZHM6IGt0LFxuICAgICAgICAgIHRyYWNrSXRlbURldGFpbHNNYXA6IE90LFxuICAgICAgICAgIGFjdGl2ZUlkczogW10sXG4gICAgICAgICAgdHJhY2tJdGVtc01hcDogd3QsXG4gICAgICAgICAgdHJhY2tzOiB6dCxcbiAgICAgICAgICBkdXJhdGlvbjogRnQsXG4gICAgICAgICAgc3RydWN0dXJlOiBWLFxuICAgICAgICAgIHRyYW5zaXRpb25JZHM6IER0LFxuICAgICAgICAgIHRyYW5zaXRpb25zTWFwOiBVXG4gICAgICAgIH0sXG4gICAgICAgIHsgdXBkYXRlSGlzdG9yeTogITAsIGtpbmQ6IFwicmVtb3ZlXCIgfVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHUua2V5ID09PSBkaSkge1xuICAgICAgY29uc3QgdiA9IEsodC5nZXRTdGF0ZSgpKSwgSSA9IHt9LCB4ID0gKChoID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGgucGF5bG9hZC50cmFja0l0ZW1JZHMpIHx8IHYuYWN0aXZlSWRzO1xuICAgICAgaWYgKHgubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB4LmZvckVhY2goKE8pID0+IHtcbiAgICAgICAgY29uc3QgRCA9IHYudHJhY2tJdGVtc01hcFtPXSwgaiA9IHYudHJhY2tJdGVtRGV0YWlsc01hcFtPXSwgTCA9IERlKCk7XG4gICAgICAgIHYudHJhY2tJdGVtc01hcFtMXSA9IHtcbiAgICAgICAgICAuLi5LKEQpLFxuICAgICAgICAgIGlkOiBMXG4gICAgICAgIH0sIHYudHJhY2tJdGVtRGV0YWlsc01hcFtMXSA9IHtcbiAgICAgICAgICAuLi5LKGopXG4gICAgICAgIH0sIHYudHJhY2tJdGVtSWRzLnB1c2goTCk7XG4gICAgICAgIGNvbnN0IFIgPSB2LnRyYWNrcy5maW5kKFxuICAgICAgICAgIChGKSA9PiBGLml0ZW1zLmluY2x1ZGVzKE8pXG4gICAgICAgICk7XG4gICAgICAgIElbUi5pZF0gPyBJW1IuaWRdLml0ZW1zLnB1c2goTCkgOiBJW1IuaWRdID0ge1xuICAgICAgICAgIC4uLlIsXG4gICAgICAgICAgaWQ6IERlKCksXG4gICAgICAgICAgaXRlbXM6IFtMXSxcbiAgICAgICAgICBzdGF0aWM6ICExLFxuICAgICAgICAgIG1hZ25ldGljOiAhMVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBnID0gT2JqZWN0LnZhbHVlcyhJKTtcbiAgICAgIHYudHJhY2tzID0gWy4uLmcsIC4uLnYudHJhY2tzXSwgdC51cGRhdGVTdGF0ZShcbiAgICAgICAge1xuICAgICAgICAgIHRyYWNrSXRlbURldGFpbHNNYXA6IHYudHJhY2tJdGVtRGV0YWlsc01hcCxcbiAgICAgICAgICB0cmFja3M6IHYudHJhY2tzLFxuICAgICAgICAgIHRyYWNrSXRlbUlkczogdi50cmFja0l0ZW1JZHMsXG4gICAgICAgICAgdHJhY2tJdGVtc01hcDogdi50cmFja0l0ZW1zTWFwXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB1cGRhdGVIaXN0b3J5OiAhMCxcbiAgICAgICAgICBraW5kOiBcInVwZGF0ZVwiXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh1LmtleSA9PT0gcGkpIHtcbiAgICAgIGNvbnN0IHYgPSAoeSA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiB5LnBheWxvYWQsIEkgPSBPYmplY3Qua2V5cyh2KVswXSwgeCA9IE9iamVjdC52YWx1ZXModilbMF0sIGcgPSBLKHQuZ2V0U3RhdGUoKSksIE8gPSBnLnRyYWNrSXRlbURldGFpbHNNYXBbSV0sIEQgPSBLKGcudHJhY2tJdGVtc01hcFtJXSksIGogPSBPLmRldGFpbHM7XG4gICAgICBpZiAoIXguZGV0YWlscy5zcmMpIHJldHVybjtcbiAgICAgIGlmIChPLnR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBjb25zdCBMID0gYXdhaXQgT2UoeC5kZXRhaWxzLnNyYyksIHsgY3JvcDogUiwgbmV3SGVpZ2h0OiBGLCBuZXdXaWR0aDogViB9ID0gWW4oXG4gICAgICAgICAgTyxcbiAgICAgICAgICBMXG4gICAgICAgICk7XG4gICAgICAgIHguZGV0YWlscy5jcm9wID0gUiwgeC5kZXRhaWxzLmhlaWdodCA9IEYsIHguZGV0YWlscy53aWR0aCA9IFY7XG4gICAgICB9IGVsc2UgaWYgKE8udHlwZSA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgICAgIGNvbnN0IEwgPSBhd2FpdCBfbih4LmRldGFpbHMuc3JjKSwgUiA9IGcudHJhY2tJdGVtc01hcFtJXSwgeyBkaXNwbGF5OiBGLCBkdXJhdGlvbjogViwgdHJpbToga3QgfSA9IEJuKFIsIEwpLCB7IGNyb3A6IER0LCBuZXdIZWlnaHQ6IE90LCBuZXdXaWR0aDogVSB9ID0gWW4oXG4gICAgICAgICAgTyxcbiAgICAgICAgICBMXG4gICAgICAgICk7XG4gICAgICAgIHguZGV0YWlscy5jcm9wID0gRHQsIHguZGV0YWlscy5oZWlnaHQgPSBPdCwgeC5kZXRhaWxzLndpZHRoID0gVSwgRC5kaXNwbGF5ID0gRiwgRC5kdXJhdGlvbiA9IFYsIEQudHJpbSA9IGt0O1xuICAgICAgfSBlbHNlIGlmIChPLnR5cGUgPT09IFwiYXVkaW9cIikge1xuICAgICAgICBjb25zdCBMID0gYXdhaXQgbHMoeC5kZXRhaWxzLnNyYyksIFIgPSBnLnRyYWNrSXRlbXNNYXBbSV0sIHsgZGlzcGxheTogRiwgZHVyYXRpb246IFYsIHRyaW06IGt0IH0gPSBCbihSLCBMKTtcbiAgICAgICAgRC5kaXNwbGF5ID0gRiwgRC5kdXJhdGlvbiA9IFYsIEQudHJpbSA9IGt0O1xuICAgICAgfVxuICAgICAgTy5kZXRhaWxzID0geyAuLi5qLCAuLi54LmRldGFpbHMgfSwgZy50cmFja0l0ZW1EZXRhaWxzTWFwW0ldID0geyAuLi5PIH0sIGcudHJhY2tJdGVtc01hcFtJXSA9IHsgLi4uRCB9LCB0LnVwZGF0ZVN0YXRlKFxuICAgICAgICB7XG4gICAgICAgICAgdHJhY2tJdGVtRGV0YWlsc01hcDogZy50cmFja0l0ZW1EZXRhaWxzTWFwLFxuICAgICAgICAgIHRyYWNrSXRlbXNNYXA6IGcudHJhY2tJdGVtc01hcFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdXBkYXRlSGlzdG9yeTogITAsXG4gICAgICAgICAga2luZDogXCJ1cGRhdGU6ZGV0YWlsc1wiXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9KSwgbSA9IHIuc3Vic2NyaWJlKGFzeW5jICh1KSA9PiB7XG4gICAgdmFyIGcsIE8sIEQsIGosIEwsIFIsIEYsIFYsIGt0LCBEdCwgT3QsIFUsIHp0LCB3dCwgYXQsIEZ0LCBBLCBldCwgTXQsIG90LCAkdCwgRXQsIEd0LCBZdCwgZWUsIEJ0LCByZSwgWHQsIG5lLCBfZSwga2UsIE50LCBLdDtcbiAgICBjb25zdCBsID0gSyh0LmdldFN0YXRlKCkpLCBTID0gKChPID0gKGcgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogZy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogTy5pc1NlbGVjdGVkKSB8fCAhMSwgdyA9IChqID0gKEQgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogRC5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogai5zY2FsZU1vZGUsIGsgPSAoUiA9IChMID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IEwub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IFIuaXNOZXdUcmFjaztcbiAgICBsZXQgaCA9IFtdLCB5ID0gXCJ0ZXh0XCI7XG4gICAgY29uc3QgdiA9IChWID0gKEYgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogRi5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogVi50cmFja0lkO1xuICAgIGxldCBJID0gKER0ID0gKGt0ID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGt0Lm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBEdC50cmFja0luZGV4O1xuICAgIGlmICh1LmtleSA9PT0gZWkpIHtcbiAgICAgIGNvbnN0ICQgPSAoT3QgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogT3QucGF5bG9hZDtcbiAgICAgIGxldCBIID0gbC50cmFja0l0ZW1zTWFwWyQuaWRdLmFuaW1hdGlvbnM7XG4gICAgICBIID8gSC5pbiAmJiAkLmFuaW1hdGlvbnMuaW4gPyBILmluID0gJC5hbmltYXRpb25zLmluIDogSC5vdXQgJiYgJC5hbmltYXRpb25zLm91dCB8fCAhSC5vdXQgJiYgJC5hbmltYXRpb25zLm91dCA/IEgub3V0ID0gJC5hbmltYXRpb25zLm91dCA6ICFILmluICYmICQuYW5pbWF0aW9ucy5pbiA/IEguaW4gPSAkLmFuaW1hdGlvbnMuaW4gOiBIID0gJC5hbmltYXRpb25zIDogbC50cmFja0l0ZW1zTWFwWyQuaWRdLmFuaW1hdGlvbnMgPSAkLmFuaW1hdGlvbnM7XG4gICAgfVxuICAgIGlmICh1LmtleSA9PT0gc2kpIHtcbiAgICAgIGNvbnN0ICQgPSAoVSA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBVLnBheWxvYWQsIEggPSAkLnRyYWNrSXRlbXMubWFwKFxuICAgICAgICAoWSkgPT4gTWkoWSwge1xuICAgICAgICAgIHNpemU6IGwuc2l6ZVxuICAgICAgICB9KVxuICAgICAgKSwgeiA9IGF3YWl0IFByb21pc2UuYWxsKEgpLCBydCA9IFRpKCQudHJhY2tzLCAkLnRyYWNrSXRlbXMpLCBjdCA9IFtdO1xuICAgICAgJC50cmFja0l0ZW1zLmZvckVhY2goKFkpID0+IHtcbiAgICAgICAgaWYgKFkudHlwZSAhPT0gXCJ0ZW1wbGF0ZVwiKSByZXR1cm47XG4gICAgICAgIGwudHJhY2tJdGVtc01hcCA9IHtcbiAgICAgICAgICAuLi5sLnRyYWNrSXRlbXNNYXAsXG4gICAgICAgICAgLi4uWS50cmFja0l0ZW1zTWFwXG4gICAgICAgIH0sIGwudHJhY2tJdGVtRGV0YWlsc01hcCA9IHtcbiAgICAgICAgICAuLi5sLnRyYWNrSXRlbURldGFpbHNNYXAsXG4gICAgICAgICAgLi4uWS50cmFja0l0ZW1EZXRhaWxzTWFwXG4gICAgICAgIH0sIGwudHJhbnNpdGlvbnNNYXAgPSB7XG4gICAgICAgICAgLi4ubC50cmFuc2l0aW9uc01hcCxcbiAgICAgICAgICAuLi5ZLnRyYW5zaXRpb25zTWFwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG10ID0ge1xuICAgICAgICAgIGlkOiBZLmlkLFxuICAgICAgICAgIGl0ZW1zOiBZLnRyYWNrSXRlbUlkcyxcbiAgICAgICAgICB0cmFuc2l0aW9uczogWS50cmFuc2l0aW9uc0lkcyB8fCBbXSxcbiAgICAgICAgICB0cmFja3M6IFkudHJhY2tzXG4gICAgICAgIH07XG4gICAgICAgIGN0LnB1c2gobXQpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBCID0gW10sIHV0ID0ge30sIHEgPSB7fTtcbiAgICAgIGlmICh6LmZvckVhY2goKFkpID0+IHtcbiAgICAgICAgY29uc3QgeyBkZXRhaWxzOiBtdCwgLi4uVnQgfSA9IFk7XG4gICAgICAgIEIucHVzaChZLmlkKSwgdXRbWS5pZF0gPSB7XG4gICAgICAgICAgdHlwZTogWS50eXBlLFxuICAgICAgICAgIGRldGFpbHM6IG10XG4gICAgICAgIH0sIHFbWS5pZF0gPSBWdDtcbiAgICAgIH0pLCBFaShcbiAgICAgICAgbC50cmFja3MsXG4gICAgICAgIHJ0XG4gICAgICApKVxuICAgICAgICBsLnRyYWNrcy5mb3JFYWNoKChZKSA9PiB7XG4gICAgICAgICAgcnQuZm9yRWFjaCgobXQpID0+IHtcbiAgICAgICAgICAgIGlmIChZLmlkID09PSBtdC5pZCkge1xuICAgICAgICAgICAgICBpZiAoWS5tYWduZXRpYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFZ0ID0gbXQuaXRlbXMubWFwKChUdCkgPT4gcVtUdF0pLCBxdCA9IFkuaXRlbXMubWFwKFxuICAgICAgICAgICAgICAgICAgKFR0KSA9PiBsLnRyYWNrSXRlbXNNYXBbVHRdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBPaShcbiAgICAgICAgICAgICAgICAgIFZ0LFxuICAgICAgICAgICAgICAgICAgcXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFkuaXRlbXMucHVzaCguLi5CKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgWSA9ICgod3QgPSAoenQgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogenQub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IHd0LnRyYWNrSW5kZXgpIHx8IDAsIG10ID0ga24oXG4gICAgICAgICAgWSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGwudHJhY2tzLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICBsLnRyYWNrcy5zcGxpY2UobXQsIDAsIC4uLnJ0KTtcbiAgICAgIH1cbiAgICAgIGwudHJhY2tJdGVtRGV0YWlsc01hcCA9IHtcbiAgICAgICAgLi4ubC50cmFja0l0ZW1EZXRhaWxzTWFwLFxuICAgICAgICAuLi51dFxuICAgICAgfSwgbC50cmFja0l0ZW1zTWFwID0ge1xuICAgICAgICAuLi5sLnRyYWNrSXRlbXNNYXAsXG4gICAgICAgIC4uLnFcbiAgICAgIH0sIGwudHJhY2tJdGVtSWRzID0gW1xuICAgICAgICAuLi5sLnRyYWNrSXRlbUlkcyxcbiAgICAgICAgLi4uQlxuICAgICAgXSwgbC5zdHJ1Y3R1cmUgPSBbLi4ubC5zdHJ1Y3R1cmUsIC4uLmN0XSwgbC5kdXJhdGlvbiA9IGhlKGwudHJhY2tJdGVtc01hcCk7XG4gICAgICBjb25zdCB7IHRyYW5zaXRpb25JZHM6IFNlLCB0cmFuc2l0aW9uc01hcDogc2UgfSA9IENpKFxuICAgICAgICBsXG4gICAgICApLCBQZSA9IGwudHJhY2tzLmZpbHRlcigoWSkgPT4gWS5tYWduZXRpYyk7XG4gICAgICBYbihcbiAgICAgICAgUGUsXG4gICAgICAgIGwudHJhY2tJdGVtc01hcCxcbiAgICAgICAgc2VcbiAgICAgICksIHQudXBkYXRlU3RhdGUoXG4gICAgICAgIHtcbiAgICAgICAgICB0cmFja0l0ZW1JZHM6IGwudHJhY2tJdGVtSWRzLFxuICAgICAgICAgIHRyYWNrSXRlbURldGFpbHNNYXA6IGwudHJhY2tJdGVtRGV0YWlsc01hcCxcbiAgICAgICAgICB0cmFja0l0ZW1zTWFwOiBsLnRyYWNrSXRlbXNNYXAsXG4gICAgICAgICAgdHJhY2tzOiBsLnRyYWNrcyxcbiAgICAgICAgICBkdXJhdGlvbjogbC5kdXJhdGlvbixcbiAgICAgICAgICBzdHJ1Y3R1cmU6IGwuc3RydWN0dXJlLFxuICAgICAgICAgIHRyYW5zaXRpb25JZHM6IFNlLFxuICAgICAgICAgIHRyYW5zaXRpb25zTWFwOiBzZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdXBkYXRlSGlzdG9yeTogITAsXG4gICAgICAgICAga2luZDogXCJhZGRcIlxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodS5rZXkgPT09IHJpKSB7XG4gICAgICB5ID0gXCJjYXB0aW9uXCI7XG4gICAgICBjb25zdCAkID0gKGF0ID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGF0LnBheWxvYWQsIEggPSBbXTtcbiAgICAgIGZvciAoY29uc3QgY3Qgb2YgJCkge1xuICAgICAgICBjb25zdCBCID0gSXMoY3QsIHtcbiAgICAgICAgICBzaXplOiBsLnNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIEgucHVzaChCKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHogPSBhd2FpdCBQcm9taXNlLmFsbChIKSwgcnQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgY3Qgb2Ygeikge1xuICAgICAgICBjb25zdCBCID0gY3QuaWQ7XG4gICAgICAgIHJ0LnB1c2goQik7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsczogdXQsIC4uLnEgfSA9IGN0O1xuICAgICAgICBsLnRyYWNrSXRlbURldGFpbHNNYXBbQl0gPSB7XG4gICAgICAgICAgdHlwZTogeSxcbiAgICAgICAgICBkZXRhaWxzOiB1dFxuICAgICAgICB9LCBsLnRyYWNrSXRlbXNNYXBbQl0gPSBxLCBsLnRyYWNrSXRlbUlkcy5wdXNoKEIpO1xuICAgICAgfVxuICAgICAgaCA9IHJ0O1xuICAgIH1cbiAgICBpZiAodS5rZXkgPT09IFZzKSB7XG4gICAgICB5ID0gXCJ0ZXh0XCI7XG4gICAgICBjb25zdCAkID0gYXdhaXQgYnMoKEZ0ID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IEZ0LnBheWxvYWQsIHtcbiAgICAgICAgc2l6ZTogbC5zaXplXG4gICAgICB9KSwgeyBkZXRhaWxzOiBILCAuLi56IH0gPSAkO1xuICAgICAgbC50cmFja0l0ZW1EZXRhaWxzTWFwW3ouaWRdID0ge1xuICAgICAgICB0eXBlOiB5LFxuICAgICAgICBkZXRhaWxzOiBIXG4gICAgICB9LCBsLnRyYWNrSXRlbXNNYXBbei5pZF0gPSB6LCBsLnRyYWNrSXRlbUlkcy5wdXNoKHouaWQpLCBoID0gW3ouaWRdO1xuICAgIH1cbiAgICBpZiAodS5rZXkgPT09IG5pKSB7XG4gICAgICB5ID0gXCJ0ZW1wbGF0ZVwiO1xuICAgICAgY29uc3QgJCA9IChBID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IEEucGF5bG9hZC50cmFja0l0ZW1zTWFwLCBIID0gKGV0ID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGV0LnBheWxvYWQudHJhY2tJdGVtRGV0YWlsc01hcCwgeiA9IChNdCA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBNdC5wYXlsb2FkLnRyYW5zaXRpb25zTWFwLCBydCA9ICgob3QgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogb3QucGF5bG9hZC50cmFuc2l0aW9uSWRzKSB8fCBbXSwgY3QgPSAoJHQgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogJHQucGF5bG9hZC50cmFja0l0ZW1JZHMsIEIgPSAoKEV0ID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IEV0LnBheWxvYWQudHJhY2tzKSB8fCBbXSwgeyBkZXRhaWxzOiB1dCwgLi4ucSB9ID0gYXdhaXQgeXMoKEd0ID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IEd0LnBheWxvYWQsIHtcbiAgICAgICAgc2l6ZTogbC5zaXplXG4gICAgICB9KSwgaHQgPSB7XG4gICAgICAgIGlkOiBxLmlkLFxuICAgICAgICBpdGVtczogY3QsXG4gICAgICAgIHRyYW5zaXRpb25zOiBydCxcbiAgICAgICAgdHJhY2tzOiBCXG4gICAgICB9O1xuICAgICAgbC50cmFja0l0ZW1EZXRhaWxzTWFwW3EuaWRdID0ge1xuICAgICAgICB0eXBlOiB5LFxuICAgICAgICBkZXRhaWxzOiB1dFxuICAgICAgfSwgbC50cmFja0l0ZW1zTWFwW3EuaWRdID0gcSwgbC50cmFja0l0ZW1JZHMucHVzaChxLmlkKSwgaCA9IFtxLmlkXSwgbC50cmFja0l0ZW1zTWFwID0ge1xuICAgICAgICAuLi5sLnRyYWNrSXRlbXNNYXAsXG4gICAgICAgIC4uLiQsXG4gICAgICAgIFtxLmlkXToge1xuICAgICAgICAgIC4uLnFcbiAgICAgICAgfVxuICAgICAgfSwgbC50cmFja0l0ZW1EZXRhaWxzTWFwID0ge1xuICAgICAgICAuLi5sLnRyYWNrSXRlbURldGFpbHNNYXAsXG4gICAgICAgIC4uLkgsXG4gICAgICAgIFtxLmlkXToge1xuICAgICAgICAgIHR5cGU6IFwidGVtcGxhdGVcIixcbiAgICAgICAgICBkZXRhaWxzOiB1dFxuICAgICAgICB9XG4gICAgICB9LCBsLnRyYW5zaXRpb25zTWFwID0ge1xuICAgICAgICAuLi5sLnRyYW5zaXRpb25zTWFwLFxuICAgICAgICAuLi56XG4gICAgICB9LCBsLnN0cnVjdHVyZSA9IFsuLi5sLnN0cnVjdHVyZSwgaHRdO1xuICAgIH1cbiAgICBpZiAodS5rZXkgPT09IFFzKSB7XG4gICAgICB5ID0gXCJpbGx1c3RyYXRpb25cIjtcbiAgICAgIGNvbnN0ICQgPSBhd2FpdCBHbigoWXQgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogWXQucGF5bG9hZCwge1xuICAgICAgICBzaXplOiBsLnNpemVcbiAgICAgIH0pLCB7IGRldGFpbHM6IEgsIC4uLnogfSA9ICQ7XG4gICAgICBsLnRyYWNrSXRlbURldGFpbHNNYXBbei5pZF0gPSB7XG4gICAgICAgIHR5cGU6IHksXG4gICAgICAgIGRldGFpbHM6IEhcbiAgICAgIH0sIGwudHJhY2tJdGVtc01hcFt6LmlkXSA9IHosIGwudHJhY2tJdGVtSWRzLnB1c2goei5pZCksIGggPSBbei5pZF07XG4gICAgfVxuICAgIGlmICh1LmtleSA9PT0gdGkpIHtcbiAgICAgIHkgPSBcInNoYXBlXCI7XG4gICAgICBjb25zdCAkID0gYXdhaXQgd2koKGVlID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGVlLnBheWxvYWQsIHtcbiAgICAgICAgc2l6ZTogbC5zaXplXG4gICAgICB9KSwgeyBkZXRhaWxzOiBILCAuLi56IH0gPSAkO1xuICAgICAgbC50cmFja0l0ZW1EZXRhaWxzTWFwW3ouaWRdID0ge1xuICAgICAgICB0eXBlOiB5LFxuICAgICAgICBkZXRhaWxzOiBIXG4gICAgICB9LCBsLnRyYWNrSXRlbXNNYXBbei5pZF0gPSB6LCBsLnRyYWNrSXRlbUlkcy5wdXNoKHouaWQpLCBoID0gW3ouaWRdO1xuICAgIH1cbiAgICBpZiAodS5rZXkgPT09IFpzKSB7XG4gICAgICB5ID0gXCJpbWFnZVwiO1xuICAgICAgY29uc3QgJCA9IGF3YWl0IGdzKChCdCA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBCdC5wYXlsb2FkLCB7XG4gICAgICAgIHNpemU6IGwuc2l6ZSxcbiAgICAgICAgc2NhbGVNb2RlOiB3XG4gICAgICB9KSwgeyBkZXRhaWxzOiBILCAuLi56IH0gPSAkO1xuICAgICAgbC50cmFja0l0ZW1EZXRhaWxzTWFwW3ouaWRdID0ge1xuICAgICAgICB0eXBlOiB5LFxuICAgICAgICBkZXRhaWxzOiBIXG4gICAgICB9LCBsLnRyYWNrSXRlbXNNYXBbei5pZF0gPSB6LCBsLnRyYWNrSXRlbUlkcy5wdXNoKHouaWQpLCBoID0gW3ouaWRdO1xuICAgIH1cbiAgICBpZiAodS5rZXkgPT09IEpzKSB7XG4gICAgICB5ID0gXCJhdWRpb1wiO1xuICAgICAgY29uc3QgJCA9IGF3YWl0IG1zKChyZSA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiByZS5wYXlsb2FkKSwgeyBkZXRhaWxzOiBILCAuLi56IH0gPSAkO1xuICAgICAgbC50cmFja0l0ZW1EZXRhaWxzTWFwW3ouaWRdID0ge1xuICAgICAgICB0eXBlOiB5LFxuICAgICAgICBkZXRhaWxzOiBIXG4gICAgICB9LCBsLnRyYWNrSXRlbXNNYXBbei5pZF0gPSB6LCBsLnRyYWNrSXRlbUlkcy5wdXNoKHouaWQpLCBoID0gW3ouaWRdO1xuICAgIH1cbiAgICBpZiAodS5rZXkgPT09IHFzKSB7XG4gICAgICB5ID0gXCJ2aWRlb1wiO1xuICAgICAgY29uc3QgJCA9IGF3YWl0IGhzKChYdCA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBYdC5wYXlsb2FkLCB7XG4gICAgICAgIHNpemU6IGwuc2l6ZSxcbiAgICAgICAgc2NhbGVNb2RlOiB3XG4gICAgICB9KSwgeyBkZXRhaWxzOiBILCAuLi56IH0gPSAkO1xuICAgICAgbC50cmFja0l0ZW1EZXRhaWxzTWFwW3ouaWRdID0ge1xuICAgICAgICB0eXBlOiB5LFxuICAgICAgICBkZXRhaWxzOiBILFxuICAgICAgICBtZXRhZGF0YTogei5tZXRhZGF0YVxuICAgICAgfSwgbC50cmFja0l0ZW1zTWFwW3ouaWRdID0geiwgbC50cmFja0l0ZW1JZHMucHVzaCh6LmlkKSwgaCA9IFt6LmlkXTtcbiAgICB9XG4gICAgaWYgKHUua2V5ID09PSBpaSkge1xuICAgICAgeSA9IFwiY29tcG9zaXRpb25cIjtcbiAgICAgIGNvbnN0ICQgPSAobmUgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogbmUucGF5bG9hZC50cmFja0l0ZW1zTWFwLCBIID0gKF9lID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnBheWxvYWQudHJhY2tJdGVtRGV0YWlsc01hcCwgeiA9IChrZSA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBrZS5wYXlsb2FkLnRyYWNrSXRlbUlkcywgcnQgPSAoKE50ID0gdS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IE50LnBheWxvYWQudHJhY2tzKSB8fCBbXSwgeyBkZXRhaWxzOiBjdCwgLi4uQiB9ID0gYXdhaXQgU2koXG4gICAgICAgIChLdCA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBLdC5wYXlsb2FkLFxuICAgICAgICB7XG4gICAgICAgICAgc2l6ZTogbC5zaXplXG4gICAgICAgIH1cbiAgICAgICksIHV0ID0ge1xuICAgICAgICBpZDogQi5pZCxcbiAgICAgICAgaXRlbXM6IHosXG4gICAgICAgIHRyYW5zaXRpb25zOiBbXSxcbiAgICAgICAgdHJhY2tzOiBydFxuICAgICAgfTtcbiAgICAgIGwudHJhY2tJdGVtRGV0YWlsc01hcFtCLmlkXSA9IHtcbiAgICAgICAgdHlwZTogeSxcbiAgICAgICAgZGV0YWlsczogY3RcbiAgICAgIH0sIGwudHJhY2tJdGVtc01hcFtCLmlkXSA9IEIsIGwudHJhY2tJdGVtSWRzLnB1c2goQi5pZCksIGggPSBbQi5pZF0sIGwudHJhY2tJdGVtc01hcCA9IHtcbiAgICAgICAgLi4ubC50cmFja0l0ZW1zTWFwLFxuICAgICAgICAuLi4kLFxuICAgICAgICBbQi5pZF06IHtcbiAgICAgICAgICAuLi5CXG4gICAgICAgIH1cbiAgICAgIH0sIGwudHJhY2tJdGVtRGV0YWlsc01hcCA9IHtcbiAgICAgICAgLi4ubC50cmFja0l0ZW1EZXRhaWxzTWFwLFxuICAgICAgICAuLi5ILFxuICAgICAgICBbQi5pZF06IHtcbiAgICAgICAgICB0eXBlOiB5LFxuICAgICAgICAgIGRldGFpbHM6IGN0XG4gICAgICAgIH1cbiAgICAgIH0sIGwuc3RydWN0dXJlID0gWy4uLmwuc3RydWN0dXJlLCB1dF07XG4gICAgfVxuICAgIGNvbnN0IHggPSB4aShcbiAgICAgIGgsXG4gICAgICBsLnRyYWNrcyxcbiAgICAgIGwudHJhY2tJdGVtc01hcCxcbiAgICAgIHYsXG4gICAgICBJXG4gICAgKTtcbiAgICBpZiAoaykge1xuICAgICAgY29uc3QgJCA9IFhlKCk7XG4gICAgICB4LnRyYWNrSWQgPSAkO1xuICAgICAgY29uc3QgSCA9IHtcbiAgICAgICAgaWQ6IHgudHJhY2tJZCxcbiAgICAgICAgYWNjZXB0czogW1xuICAgICAgICAgIFwidGV4dFwiLFxuICAgICAgICAgIFwiYXVkaW9cIixcbiAgICAgICAgICBcImhlbHBlclwiLFxuICAgICAgICAgIFwidmlkZW9cIixcbiAgICAgICAgICBcImltYWdlXCIsXG4gICAgICAgICAgXCJjYXB0aW9uXCIsXG4gICAgICAgICAgXCJ0ZW1wbGF0ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIHR5cGU6IHksXG4gICAgICAgIGl0ZW1zOiBoLFxuICAgICAgICBtYWduZXRpYzogITEsXG4gICAgICAgIHN0YXRpYzogITFcbiAgICAgIH07XG4gICAgICBsLnRyYWNrcy5zcGxpY2UoeC50cmFja0luZGV4LCAwLCBIKTtcbiAgICB9IGVsc2UgaWYgKHgudHJhY2tJZCkge1xuICAgICAgY29uc3QgJCA9IGwudHJhY2tzLmZpbmQoXG4gICAgICAgIChIKSA9PiBILmlkID09PSB4LnRyYWNrSWRcbiAgICAgICk7XG4gICAgICAkICYmICQuaXRlbXMucHVzaCguLi5oKTtcbiAgICB9IGVsc2UgaWYgKHgudHJhY2tJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCAkID0ge1xuICAgICAgICBpZDogWGUoKSxcbiAgICAgICAgYWNjZXB0czogW1xuICAgICAgICAgIFwidGV4dFwiLFxuICAgICAgICAgIFwiYXVkaW9cIixcbiAgICAgICAgICBcImhlbHBlclwiLFxuICAgICAgICAgIFwidmlkZW9cIixcbiAgICAgICAgICBcImltYWdlXCIsXG4gICAgICAgICAgXCJjYXB0aW9uXCIsXG4gICAgICAgICAgXCJ0ZW1wbGF0ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIHR5cGU6IHksXG4gICAgICAgIGl0ZW1zOiBoLFxuICAgICAgICBtYWduZXRpYzogITEsXG4gICAgICAgIHN0YXRpYzogITFcbiAgICAgIH07XG4gICAgICBsLnRyYWNrcy5zcGxpY2UoeC50cmFja0luZGV4LCAwLCAkKTtcbiAgICB9IGVsc2VcbiAgICAgIGwudHJhY2tzLnVuc2hpZnQoe1xuICAgICAgICBpZDogWGUoKSxcbiAgICAgICAgYWNjZXB0czogW1xuICAgICAgICAgIFwidGV4dFwiLFxuICAgICAgICAgIFwiYXVkaW9cIixcbiAgICAgICAgICBcImhlbHBlclwiLFxuICAgICAgICAgIFwidmlkZW9cIixcbiAgICAgICAgICBcImltYWdlXCIsXG4gICAgICAgICAgXCJjYXB0aW9uXCIsXG4gICAgICAgICAgXCJ0ZW1wbGF0ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIHR5cGU6IHksXG4gICAgICAgIGl0ZW1zOiBoLFxuICAgICAgICBtYWduZXRpYzogITEsXG4gICAgICAgIHN0YXRpYzogITFcbiAgICAgIH0pO1xuICAgIFMgJiYgKGwuYWN0aXZlSWRzID0gaCksIGwuZHVyYXRpb24gPSBoZShsLnRyYWNrSXRlbXNNYXApLCB0LnVwZGF0ZVN0YXRlKFxuICAgICAge1xuICAgICAgICBhY3RpdmVJZHM6IGwuYWN0aXZlSWRzLFxuICAgICAgICB0cmFja0l0ZW1JZHM6IGwudHJhY2tJdGVtSWRzLFxuICAgICAgICB0cmFja0l0ZW1EZXRhaWxzTWFwOiBsLnRyYWNrSXRlbURldGFpbHNNYXAsXG4gICAgICAgIHRyYWNrSXRlbXNNYXA6IGwudHJhY2tJdGVtc01hcCxcbiAgICAgICAgdHJhbnNpdGlvbnNNYXA6IGwudHJhbnNpdGlvbnNNYXAsXG4gICAgICAgIHRyYWNrczogbC50cmFja3MsXG4gICAgICAgIGR1cmF0aW9uOiBsLmR1cmF0aW9uLFxuICAgICAgICBzdHJ1Y3R1cmU6IGwuc3RydWN0dXJlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cGRhdGVIaXN0b3J5OiAhMCxcbiAgICAgICAga2luZDogXCJhZGRcIlxuICAgICAgfVxuICAgICk7XG4gIH0pLCBUID0gYy5zdWJzY3JpYmUoYXN5bmMgKHUpID0+IHtcbiAgICB2YXIgbDtcbiAgICBpZiAodS5rZXkgPT09IGxpKSB7XG4gICAgICBjb25zdCBTID0gSyh0LmdldFN0YXRlKCkpLCB3ID0gKGwgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogbC5vcHRpb25zLnRpbWU7XG4gICAgICBpZiAoUy5hY3RpdmVJZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGsgPSBTLmFjdGl2ZUlkc1swXSwgaCA9IEsoUy50cmFja0l0ZW1zTWFwW2tdKTtcbiAgICAgICAgaWYgKHcgPj0gaC5kaXNwbGF5LnRvIHx8IHcgPD0gaC5kaXNwbGF5LmZyb20pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB5ID0gSyhTLnRyYWNrSXRlbURldGFpbHNNYXBba10pLCB2ID0gRGUoKSwgSSA9IEsoe1xuICAgICAgICAgIC4uLmgsXG4gICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgZnJvbTogaC5kaXNwbGF5LmZyb20sXG4gICAgICAgICAgICB0bzogd1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIHggPSBLKHtcbiAgICAgICAgICAuLi5oLFxuICAgICAgICAgIGlkOiB2LFxuICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgIGZyb206IHcsXG4gICAgICAgICAgICB0bzogaC5kaXNwbGF5LnRvXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGgudHlwZSA9PT0gXCJ2aWRlb1wiIHx8IGgudHlwZSA9PT0gXCJhdWRpb1wiKSB7XG4gICAgICAgICAgY29uc3QgZyA9IHcgLSBJLmRpc3BsYXkuZnJvbTtcbiAgICAgICAgICBJLnRyaW0gPSB7XG4gICAgICAgICAgICBmcm9tOiBoLnRyaW0uZnJvbSxcbiAgICAgICAgICAgIHRvOiBoLnRyaW0uZnJvbSArIGdcbiAgICAgICAgICB9LCB4LnRyaW0gPSB7XG4gICAgICAgICAgICBmcm9tOiBoLnRyaW0uZnJvbSArIGcsXG4gICAgICAgICAgICB0bzogaC50cmltLnRvXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBTLnRyYWNrSXRlbXNNYXBba10gPSBJLCBTLnRyYWNrSXRlbXNNYXBbdl0gPSB4LCBTLnRyYWNrSXRlbUlkcy5wdXNoKHYpLCBTLnRyYWNrSXRlbURldGFpbHNNYXBbdl0gPSB5LCBTLnRyYWNrcy5mb3JFYWNoKChnKSA9PiB7XG4gICAgICAgICAgZy5pdGVtcy5pbmNsdWRlcyhrKSAmJiBnLml0ZW1zLnB1c2godik7XG4gICAgICAgIH0pLCB0LnVwZGF0ZVN0YXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRyYWNrSXRlbURldGFpbHNNYXA6IFMudHJhY2tJdGVtRGV0YWlsc01hcCxcbiAgICAgICAgICAgIHRyYWNrczogUy50cmFja3MsXG4gICAgICAgICAgICB0cmFja0l0ZW1JZHM6IFMudHJhY2tJdGVtSWRzLFxuICAgICAgICAgICAgdHJhY2tJdGVtc01hcDogUy50cmFja0l0ZW1zTWFwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB1cGRhdGVIaXN0b3J5OiAhMCxcbiAgICAgICAgICAgIGtpbmQ6IFwidXBkYXRlXCJcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1LmtleSA9PT0gdWkpIHtcbiAgICAgIGNvbnN0IFMgPSBLKHQuZ2V0U3RhdGUoKSk7XG4gICAgICBpZiAoUy5hY3RpdmVJZHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHcgPSBTLmFjdGl2ZUlkcywgayA9IFtdLCBoID0ge1xuICAgICAgICAgIGFjdGl2ZUlkczogdyxcbiAgICAgICAgICB0cmFja0l0ZW1EZXRhaWxzTWFwOiB7fSxcbiAgICAgICAgICB0cmFja0l0ZW1zTWFwOiB7fSxcbiAgICAgICAgICB0cmFja3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHcuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgIGgudHJhY2tJdGVtRGV0YWlsc01hcFt2XSA9IFMudHJhY2tJdGVtRGV0YWlsc01hcFt2XSwgaC50cmFja0l0ZW1zTWFwW3ZdID0gUy50cmFja0l0ZW1zTWFwW3ZdLCBrLnB1c2goXG4gICAgICAgICAgICBTLnRyYWNrcy5maW5kKChJKSA9PiBJLml0ZW1zLmluY2x1ZGVzKHYpKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB5ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgay5maWx0ZXIoKHYpID0+IHkuaGFzKHYuaWQpID8gITEgOiAoeS5hZGQodiksICEwKSksIGgudHJhY2tzID0gQXJyYXkuZnJvbSh5LmtleXMoKSksIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiRGVzaWduQ29tYm9UZW1wXCIsIEpTT04uc3RyaW5naWZ5KGgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHUua2V5ID09PSBjaSkge1xuICAgICAgY29uc3QgUyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiRGVzaWduQ29tYm9UZW1wXCIpO1xuICAgICAgaWYgKCFTKSByZXR1cm47XG4gICAgICBjb25zdCB3ID0gSyh0LmdldFN0YXRlKCkpLCBrID0gSlNPTi5wYXJzZShTKSwgaCA9IHt9LCB5ID0gay50cmFja0l0ZW1zTWFwLCB2ID0gay50cmFja0l0ZW1EZXRhaWxzTWFwLCBJID0gay50cmFja3MsIHggPSBbXSwgZyA9IGsuYWN0aXZlSWRzLm1hcChhc3luYyAoTykgPT4ge1xuICAgICAgICBjb25zdCBEID0gdltPXTtcbiAgICAgICAgKEQudHlwZSA9PT0gXCJjYXB0aW9uXCIgfHwgRC50eXBlID09PSBcInRleHRcIikgJiYgRC5kZXRhaWxzLmZvbnRVcmwgJiYgYXdhaXQgYnIoW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IEQuZGV0YWlscy5mb250RmFtaWx5LFxuICAgICAgICAgICAgdXJsOiBELmRldGFpbHMuZm9udFVybFxuICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGogPSBEZSgpO1xuICAgICAgICByZXR1cm4gaFtPXSA9IGosIHcudHJhY2tJdGVtc01hcFtqXSA9IHtcbiAgICAgICAgICAuLi55W09dLFxuICAgICAgICAgIGlkOiBqXG4gICAgICAgIH0sIHcudHJhY2tJdGVtRGV0YWlsc01hcFtqXSA9IEQsIHcudHJhY2tJdGVtSWRzLnB1c2goaiksICEwO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChnKSwgSS5mb3JFYWNoKChPKSA9PiB7XG4gICAgICAgIGNvbnN0IEQgPSBPLml0ZW1zLm1hcCgoTCkgPT4gaFtMXSksIGogPSB7XG4gICAgICAgICAgLi4uTyxcbiAgICAgICAgICBtYWduZXRpYzogITEsXG4gICAgICAgICAgc3RhdGljOiAhMSxcbiAgICAgICAgICBpdGVtczogRCxcbiAgICAgICAgICBpZDogWGUoKVxuICAgICAgICB9O1xuICAgICAgICB4LnB1c2goaik7XG4gICAgICB9KSwgdy50cmFja3MgPSBbLi4ueCwgLi4udy50cmFja3NdLCB0LnVwZGF0ZVN0YXRlKFxuICAgICAgICB7XG4gICAgICAgICAgdHJhY2tJdGVtRGV0YWlsc01hcDogdy50cmFja0l0ZW1EZXRhaWxzTWFwLFxuICAgICAgICAgIHRyYWNrczogdy50cmFja3MsXG4gICAgICAgICAgdHJhY2tJdGVtSWRzOiB3LnRyYWNrSXRlbUlkcyxcbiAgICAgICAgICB0cmFja0l0ZW1zTWFwOiB3LnRyYWNrSXRlbXNNYXBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHVwZGF0ZUhpc3Rvcnk6ICEwLFxuICAgICAgICAgIGtpbmQ6IFwidXBkYXRlXCJcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH0pLCBDID0gZC5zdWJzY3JpYmUoYXN5bmMgKHUpID0+IHtcbiAgICB2YXIgbCwgUywgdztcbiAgICBpZiAodS5rZXkgPT09IGFpKSB7XG4gICAgICBjb25zdCBrID0gSyh0LmdldFN0YXRlKCkpLCBoID0gay50cmFja0l0ZW1EZXRhaWxzTWFwLCB5ID0gay50cmFja0l0ZW1zTWFwLCB2ID0gT2JqZWN0LmtleXMoKGwgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogbC5wYXlsb2FkKTtcbiAgICAgIGlmICghdi5sZW5ndGgpIHJldHVybjtcbiAgICAgIGNvbnN0IEkgPSAoUyA9IHUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBTLnBheWxvYWQ7XG4gICAgICB2LmZvckVhY2goKGcpID0+IHtcbiAgICAgICAgY29uc3QgTyA9IElbZ107XG4gICAgICAgIGlmIChPLmRldGFpbHMpIHtcbiAgICAgICAgICBpZiAoaFtnXS5kZXRhaWxzID0ge1xuICAgICAgICAgICAgLi4uaFtnXS5kZXRhaWxzLFxuICAgICAgICAgICAgLi4uTy5kZXRhaWxzXG4gICAgICAgICAgfSwgTy5kZXRhaWxzLmNvbG9yTWFwKSB7XG4gICAgICAgICAgICBjb25zdCBEID0gaFtnXS5kZXRhaWxzLmluaXRpYWxTdmdTdHJpbmcsIGogPSBXbihcbiAgICAgICAgICAgICAgRCxcbiAgICAgICAgICAgICAgTy5kZXRhaWxzLmNvbG9yTWFwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaFtnXS5kZXRhaWxzLnN2Z1N0cmluZyA9IGo7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgSVtnXS5wbGF5YmFja1JhdGUgJiYgKHlbZ10ucGxheWJhY2tSYXRlID0gSVtnXS5wbGF5YmFja1JhdGUpO1xuICAgICAgICBJW2ddLm1ldGFkYXRhICYmICh5W2ddLm1ldGFkYXRhID8geVtnXS5tZXRhZGF0YSA9IHtcbiAgICAgICAgICAuLi55W2ddLm1ldGFkYXRhLFxuICAgICAgICAgIC4uLklbZ10ubWV0YWRhdGFcbiAgICAgICAgfSA6IHlbZ10ubWV0YWRhdGEgPSBJW2ddLm1ldGFkYXRhKSwgSVtnXS5kaXNwbGF5ICYmICh5W2ddLmRpc3BsYXkgPSBJW2ddLmRpc3BsYXkpO1xuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IGcgb2Ygdikge1xuICAgICAgICBjb25zdCBPID0gSVtnXTtcbiAgICAgICAgaWYgKHlbZ10udHlwZSA9PT0gXCJzaGFwZVwiICYmIE8uZGV0YWlscy5zcmMpIHtcbiAgICAgICAgICBjb25zdCBEID0gYXdhaXQgT2UoTy5kZXRhaWxzLnNyYyk7XG4gICAgICAgICAgaFtnXS5kZXRhaWxzLndpZHRoID0gRC53aWR0aCwgaFtnXS5kZXRhaWxzLmhlaWdodCA9IEQuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gaGUoeSk7XG4gICAgICB0LnVwZGF0ZVN0YXRlKFxuICAgICAgICB7XG4gICAgICAgICAgdHJhY2tJdGVtRGV0YWlsc01hcDogeyAuLi5oIH0sXG4gICAgICAgICAgdHJhY2tJdGVtc01hcDogeyAuLi55IH0sXG4gICAgICAgICAgZHVyYXRpb246IHhcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHVwZGF0ZUhpc3Rvcnk6ICEwLFxuICAgICAgICAgIGtpbmQ6IFwidXBkYXRlOmRldGFpbHNcIlxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodS5rZXkgPT09IG9pKSB7XG4gICAgICBjb25zdCBrID0gKHcgPSB1LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogdy5wYXlsb2FkLCBoID0gT2JqZWN0LmtleXMoaylbMF0sIHkgPSBPYmplY3QudmFsdWVzKGspWzBdLCB2ID0gSyh0LmdldFN0YXRlKCkpLCBJID0gdi50cmFja0l0ZW1EZXRhaWxzTWFwW2hdLCB4ID0gSS5kZXRhaWxzO1xuICAgICAgaWYgKHkuZGV0YWlscykge1xuICAgICAgICBpZiAoeS50eXBlID09PSBcImltYWdlXCIgJiYgeS5kZXRhaWxzLnNyYykge1xuICAgICAgICAgIGNvbnN0IE8gPSBhd2FpdCBPZSh5LmRldGFpbHMuc3JjKSwgRCA9IEkuZGV0YWlscy53aWR0aCB8fCAwLCBqID0gSS5kZXRhaWxzLmhlaWdodCB8fCAwO1xuICAgICAgICAgIGxldCBMID0gTy53aWR0aCwgUiA9IE8uaGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IEYgPSBPLndpZHRoIC8gTy5oZWlnaHQ7XG4gICAgICAgICAgRCAvIGogPiBGID8gKEwgPSBELCBSID0gRCAvIEYpIDogKFIgPSBqLCBMID0gaiAqIEYpLCB4LmNyb3AgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIGhlaWdodDogeC5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogeC53aWR0aFxuICAgICAgICAgIH0sIHkuZGV0YWlscy53aWR0aCA9IEwsIHkuZGV0YWlscy5oZWlnaHQgPSBSO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5LnR5cGUgPT09IFwidmlkZW9cIiAmJiB5LmRldGFpbHMuc3JjKSB7XG4gICAgICAgICAgY29uc3QgTyA9IGF3YWl0IF9uKHkuZGV0YWlscy5zcmMpLCBEID0gSS5kZXRhaWxzLndpZHRoIHx8IDAsIGogPSBJLmRldGFpbHMuaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgbGV0IEwgPSBPLndpZHRoLCBSID0gTy5oZWlnaHQ7XG4gICAgICAgICAgY29uc3QgRiA9IE8ud2lkdGggLyBPLmhlaWdodDtcbiAgICAgICAgICBEIC8gaiA+IEYgPyAoTCA9IEQsIFIgPSBEIC8gRikgOiAoUiA9IGosIEwgPSBqICogRiksIHguY3JvcCA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiB4LmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB4LndpZHRoXG4gICAgICAgICAgfSwgeS5kZXRhaWxzLndpZHRoID0gTCwgeS5kZXRhaWxzLmhlaWdodCA9IFI7XG4gICAgICAgIH1cbiAgICAgICAgSS5kZXRhaWxzID0geyAuLi54LCAuLi55LmRldGFpbHMgfSwgeS5kZXRhaWxzID0gSS5kZXRhaWxzO1xuICAgICAgfVxuICAgICAgY29uc3QgZyA9IHsgLi4uSSwgLi4ueSB9O1xuICAgICAgdi50cmFja0l0ZW1EZXRhaWxzTWFwW2hdID0gZywgdi50cmFja0l0ZW1zTWFwW2hdID0ge1xuICAgICAgICAuLi52LnRyYWNrSXRlbXNNYXBbaF0sXG4gICAgICAgIHR5cGU6IHkudHlwZVxuICAgICAgfSwgdC51cGRhdGVTdGF0ZShcbiAgICAgICAge1xuICAgICAgICAgIHRyYWNrSXRlbURldGFpbHNNYXA6IHtcbiAgICAgICAgICAgIC4uLnYudHJhY2tJdGVtRGV0YWlsc01hcFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhY2tJdGVtc01hcDoge1xuICAgICAgICAgICAgLi4udi50cmFja0l0ZW1zTWFwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdXBkYXRlSGlzdG9yeTogITAsXG4gICAgICAgICAga2luZDogXCJ1cGRhdGU6ZGV0YWlsc1wiXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgbS51bnN1YnNjcmliZSgpLCBULnVuc3Vic2NyaWJlKCksIEMudW5zdWJzY3JpYmUoKSwgXy51bnN1YnNjcmliZSgpLCBFLnVuc3Vic2NyaWJlKCksIGIudW5zdWJzY3JpYmUoKSwgTS51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHppID0geyBEYXRlOiAhMCwgUmVnRXhwOiAhMCwgU3RyaW5nOiAhMCwgTnVtYmVyOiAhMCB9O1xuZnVuY3Rpb24gX3ModCwgZSwgciA9IHsgY3ljbGVzRml4OiAhMCB9LCBzID0gW10pIHtcbiAgdmFyIGYsIGI7XG4gIGxldCBhID0gW107XG4gIGNvbnN0IGMgPSBBcnJheS5pc0FycmF5KHQpO1xuICBmb3IgKGNvbnN0IF8gaW4gdCkge1xuICAgIGNvbnN0IE0gPSB0W19dLCBFID0gYyA/ICtfIDogXztcbiAgICBpZiAoIShfIGluIGUpKSB7XG4gICAgICBhLnB1c2goe1xuICAgICAgICB0eXBlOiBcIlJFTU9WRVwiLFxuICAgICAgICBwYXRoOiBbRV0sXG4gICAgICAgIG9sZFZhbHVlOiB0W19dXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBtID0gZVtfXSwgVCA9IHR5cGVvZiBNID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG0gPT0gXCJvYmplY3RcIiAmJiBBcnJheS5pc0FycmF5KE0pID09PSBBcnJheS5pc0FycmF5KG0pO1xuICAgIE0gJiYgbSAmJiBUICYmICF6aVsoYiA9IChmID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE0pKSA9PSBudWxsID8gdm9pZCAwIDogZi5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IGIubmFtZV0gJiYgKCFyLmN5Y2xlc0ZpeCB8fCAhcy5pbmNsdWRlcyhNKSkgPyBhLnB1c2guYXBwbHkoYSwgX3MoTSwgbSwgciwgci5jeWNsZXNGaXggPyBzLmNvbmNhdChbTV0pIDogW10pLm1hcCgoQykgPT4gKEMucGF0aC51bnNoaWZ0KEUpLCBDKSkpIDogTSAhPT0gbSAmJiAvLyB0cmVhdCBOYU4gdmFsdWVzIGFzIGVxdWl2YWxlbnRcbiAgICAhKE51bWJlci5pc05hTihNKSAmJiBOdW1iZXIuaXNOYU4obSkpICYmICEoVCAmJiAoaXNOYU4oTSkgPyBNICsgXCJcIiA9PSBtICsgXCJcIiA6ICtNID09ICttKSkgJiYgYS5wdXNoKHtcbiAgICAgIHBhdGg6IFtFXSxcbiAgICAgIHR5cGU6IFwiQ0hBTkdFXCIsXG4gICAgICB2YWx1ZTogbSxcbiAgICAgIG9sZFZhbHVlOiBNXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZCA9IEFycmF5LmlzQXJyYXkoZSk7XG4gIGZvciAoY29uc3QgXyBpbiBlKVxuICAgIF8gaW4gdCB8fCBhLnB1c2goe1xuICAgICAgdHlwZTogXCJDUkVBVEVcIixcbiAgICAgIHBhdGg6IFtkID8gK18gOiBfXSxcbiAgICAgIHZhbHVlOiBlW19dXG4gICAgfSk7XG4gIHJldHVybiBhO1xufVxudmFyIE9uID0gU3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIiksIEtlID0gU3ltYm9sLmZvcihcImltbWVyLWRyYWZ0YWJsZVwiKSwgdnQgPSBTeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIiksIGtzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gW1xuICAvLyBBbGwgZXJyb3IgY29kZXMsIHN0YXJ0aW5nIGJ5IDA6XG4gIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYFRoZSBwbHVnaW4gZm9yICcke3R9JyBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gSW1tZXIuIFRvIGVuYWJsZSB0aGUgcGx1Z2luLCBpbXBvcnQgYW5kIGNhbGwgXFxgZW5hYmxlJHt0fSgpXFxgIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXIgYXBwbGljYXRpb24uYDtcbiAgfSxcbiAgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBgcHJvZHVjZSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhpbmdzIHRoYXQgYXJlIGRyYWZ0YWJsZTogcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBNYXAsIFNldCBvciBjbGFzc2VzIHRoYXQgYXJlIG1hcmtlZCB3aXRoICdbaW1tZXJhYmxlXTogdHJ1ZScuIEdvdCAnJHt0fSdgO1xuICB9LFxuICBcIlRoaXMgb2JqZWN0IGhhcyBiZWVuIGZyb3plbiBhbmQgc2hvdWxkIG5vdCBiZSBtdXRhdGVkXCIsXG4gIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICsgdDtcbiAgfSxcbiAgXCJBbiBpbW1lciBwcm9kdWNlciByZXR1cm5lZCBhIG5ldyB2YWx1ZSAqYW5kKiBtb2RpZmllZCBpdHMgZHJhZnQuIEVpdGhlciByZXR1cm4gYSBuZXcgdmFsdWUgKm9yKiBtb2RpZnkgdGhlIGRyYWZ0LlwiLFxuICBcIkltbWVyIGZvcmJpZHMgY2lyY3VsYXIgcmVmZXJlbmNlc1wiLFxuICBcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLFxuICBcIlRoZSB0aGlyZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiLFxuICBcIkZpcnN0IGFyZ3VtZW50IHRvIGBjcmVhdGVEcmFmdGAgbXVzdCBiZSBhIHBsYWluIG9iamVjdCwgYW4gYXJyYXksIG9yIGFuIGltbWVyYWJsZSBvYmplY3RcIixcbiAgXCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsXG4gIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYCdjdXJyZW50JyBleHBlY3RzIGEgZHJhZnQsIGdvdDogJHt0fWA7XG4gIH0sXG4gIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgXCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgZGVsZXRpbmcgYXJyYXkgaW5kaWNlc1wiLFxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcbiAgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBgJ29yaWdpbmFsJyBleHBlY3RzIGEgZHJhZnQsIGdvdDogJHt0fWA7XG4gIH1cbiAgLy8gTm90ZTogaWYgbW9yZSBlcnJvcnMgYXJlIGFkZGVkLCB0aGUgZXJyb3JPZmZzZXQgaW4gUGF0Y2hlcy50cyBzaG91bGQgYmUgaW5jcmVhc2VkXG4gIC8vIFNlZSBQYXRjaGVzLnRzIGZvciBhZGRpdGlvbmFsIGVycm9yc1xuXSA6IFtdO1xuZnVuY3Rpb24gdHQodCwgLi4uZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgciA9IGtzW3RdLCBzID0gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gci5hcHBseShudWxsLCBlKSA6IHI7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBbSW1tZXJdICR7c31gKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFtJbW1lcl0gbWluaWZpZWQgZXJyb3IgbnI6ICR7dH0uIEZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vYml0Lmx5LzNjWEVLV2ZgXG4gICk7XG59XG52YXIgbWUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5mdW5jdGlvbiB5ZSh0KSB7XG4gIHJldHVybiAhIXQgJiYgISF0W3Z0XTtcbn1cbmZ1bmN0aW9uIFF0KHQpIHtcbiAgdmFyIGU7XG4gIHJldHVybiB0ID8gU3ModCkgfHwgQXJyYXkuaXNBcnJheSh0KSB8fCAhIXRbS2VdIHx8ICEhKChlID0gdC5jb25zdHJ1Y3RvcikgIT0gbnVsbCAmJiBlW0tlXSkgfHwgdHIodCkgfHwgZXIodCkgOiAhMTtcbn1cbnZhciBGaSA9IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIFNzKHQpIHtcbiAgaWYgKCF0IHx8IHR5cGVvZiB0ICE9IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlID0gbWUodCk7XG4gIGlmIChlID09PSBudWxsKVxuICAgIHJldHVybiAhMDtcbiAgY29uc3QgciA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIFwiY29uc3RydWN0b3JcIikgJiYgZS5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHIgPT09IE9iamVjdCA/ICEwIDogdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiICYmIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwocikgPT09IEZpO1xufVxuZnVuY3Rpb24gVmUodCwgZSkge1xuICBnZSh0KSA9PT0gMCA/IFJlZmxlY3Qub3duS2V5cyh0KS5mb3JFYWNoKChyKSA9PiB7XG4gICAgZShyLCB0W3JdLCB0KTtcbiAgfSkgOiB0LmZvckVhY2goKHIsIHMpID0+IGUocywgciwgdCkpO1xufVxuZnVuY3Rpb24gZ2UodCkge1xuICBjb25zdCBlID0gdFt2dF07XG4gIHJldHVybiBlID8gZS50eXBlXyA6IEFycmF5LmlzQXJyYXkodCkgPyAxIDogdHIodCkgPyAyIDogZXIodCkgPyAzIDogMDtcbn1cbmZ1bmN0aW9uIHFlKHQsIGUpIHtcbiAgcmV0dXJuIGdlKHQpID09PSAyID8gdC5oYXMoZSkgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgZSk7XG59XG5mdW5jdGlvbiBmbih0LCBlKSB7XG4gIHJldHVybiBnZSh0KSA9PT0gMiA/IHQuZ2V0KGUpIDogdFtlXTtcbn1cbmZ1bmN0aW9uIHdzKHQsIGUsIHIpIHtcbiAgY29uc3QgcyA9IGdlKHQpO1xuICBzID09PSAyID8gdC5zZXQoZSwgcikgOiBzID09PSAzID8gdC5hZGQocikgOiB0W2VdID0gcjtcbn1cbmZ1bmN0aW9uICRpKHQsIGUpIHtcbiAgcmV0dXJuIHQgPT09IGUgPyB0ICE9PSAwIHx8IDEgLyB0ID09PSAxIC8gZSA6IHQgIT09IHQgJiYgZSAhPT0gZTtcbn1cbmZ1bmN0aW9uIHRyKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBNYXA7XG59XG5mdW5jdGlvbiBlcih0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgU2V0O1xufVxuZnVuY3Rpb24gcGUodCkge1xuICByZXR1cm4gdC5jb3B5XyB8fCB0LmJhc2VfO1xufVxuZnVuY3Rpb24gU24odCwgZSkge1xuICBpZiAodHIodCkpXG4gICAgcmV0dXJuIG5ldyBNYXAodCk7XG4gIGlmIChlcih0KSlcbiAgICByZXR1cm4gbmV3IFNldCh0KTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodCkpXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQpO1xuICBjb25zdCByID0gU3ModCk7XG4gIGlmIChlID09PSAhMCB8fCBlID09PSBcImNsYXNzX29ubHlcIiAmJiAhcikge1xuICAgIGNvbnN0IHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KTtcbiAgICBkZWxldGUgc1t2dF07XG4gICAgbGV0IGEgPSBSZWZsZWN0Lm93bktleXMocyk7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBhLmxlbmd0aDsgYysrKSB7XG4gICAgICBjb25zdCBkID0gYVtjXSwgZiA9IHNbZF07XG4gICAgICBmLndyaXRhYmxlID09PSAhMSAmJiAoZi53cml0YWJsZSA9ICEwLCBmLmNvbmZpZ3VyYWJsZSA9ICEwKSwgKGYuZ2V0IHx8IGYuc2V0KSAmJiAoc1tkXSA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAvLyBjb3VsZCBsaXZlIHdpdGggISFkZXNjLnNldCBhcyB3ZWxsIGhlcmUuLi5cbiAgICAgICAgZW51bWVyYWJsZTogZi5lbnVtZXJhYmxlLFxuICAgICAgICB2YWx1ZTogdFtkXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG1lKHQpLCBzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzID0gbWUodCk7XG4gICAgaWYgKHMgIT09IG51bGwgJiYgcilcbiAgICAgIHJldHVybiB7IC4uLnQgfTtcbiAgICBjb25zdCBhID0gT2JqZWN0LmNyZWF0ZShzKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhLCB0KTtcbiAgfVxufVxuZnVuY3Rpb24gQ24odCwgZSA9ICExKSB7XG4gIHJldHVybiBNcih0KSB8fCB5ZSh0KSB8fCAhUXQodCkgfHwgKGdlKHQpID4gMSAmJiAodC5zZXQgPSB0LmFkZCA9IHQuY2xlYXIgPSB0LmRlbGV0ZSA9IE5pKSwgT2JqZWN0LmZyZWV6ZSh0KSwgZSAmJiBPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKChbciwgc10pID0+IENuKHMsICEwKSkpLCB0O1xufVxuZnVuY3Rpb24gTmkoKSB7XG4gIHR0KDIpO1xufVxuZnVuY3Rpb24gTXIodCkge1xuICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKHQpO1xufVxudmFyIHduID0ge307XG5mdW5jdGlvbiBJZSh0KSB7XG4gIGNvbnN0IGUgPSB3blt0XTtcbiAgcmV0dXJuIGUgfHwgdHQoMCwgdCksIGU7XG59XG5mdW5jdGlvbiBqaSh0LCBlKSB7XG4gIHduW3RdIHx8ICh3blt0XSA9IGUpO1xufVxudmFyIEplO1xuZnVuY3Rpb24gTXMoKSB7XG4gIHJldHVybiBKZTtcbn1cbmZ1bmN0aW9uIEhpKHQsIGUpIHtcbiAgcmV0dXJuIHtcbiAgICBkcmFmdHNfOiBbXSxcbiAgICBwYXJlbnRfOiB0LFxuICAgIGltbWVyXzogZSxcbiAgICAvLyBXaGVuZXZlciB0aGUgbW9kaWZpZWQgZHJhZnQgY29udGFpbnMgYSBkcmFmdCBmcm9tIGFub3RoZXIgc2NvcGUsIHdlXG4gICAgLy8gbmVlZCB0byBwcmV2ZW50IGF1dG8tZnJlZXppbmcgc28gdGhlIHVub3duZWQgZHJhZnQgY2FuIGJlIGZpbmFsaXplZC5cbiAgICBjYW5BdXRvRnJlZXplXzogITAsXG4gICAgdW5maW5hbGl6ZWREcmFmdHNfOiAwXG4gIH07XG59XG5mdW5jdGlvbiBLbih0LCBlKSB7XG4gIGUgJiYgKEllKFwiUGF0Y2hlc1wiKSwgdC5wYXRjaGVzXyA9IFtdLCB0LmludmVyc2VQYXRjaGVzXyA9IFtdLCB0LnBhdGNoTGlzdGVuZXJfID0gZSk7XG59XG5mdW5jdGlvbiBNbih0KSB7XG4gIEVuKHQpLCB0LmRyYWZ0c18uZm9yRWFjaChMaSksIHQuZHJhZnRzXyA9IG51bGw7XG59XG5mdW5jdGlvbiBFbih0KSB7XG4gIHQgPT09IEplICYmIChKZSA9IHQucGFyZW50Xyk7XG59XG5mdW5jdGlvbiBWbih0KSB7XG4gIHJldHVybiBKZSA9IEhpKEplLCB0KTtcbn1cbmZ1bmN0aW9uIExpKHQpIHtcbiAgY29uc3QgZSA9IHRbdnRdO1xuICBlLnR5cGVfID09PSAwIHx8IGUudHlwZV8gPT09IDEgPyBlLnJldm9rZV8oKSA6IGUucmV2b2tlZF8gPSAhMDtcbn1cbmZ1bmN0aW9uIHFuKHQsIGUpIHtcbiAgZS51bmZpbmFsaXplZERyYWZ0c18gPSBlLmRyYWZ0c18ubGVuZ3RoO1xuICBjb25zdCByID0gZS5kcmFmdHNfWzBdO1xuICByZXR1cm4gdCAhPT0gdm9pZCAwICYmIHQgIT09IHIgPyAoclt2dF0ubW9kaWZpZWRfICYmIChNbihlKSwgdHQoNCkpLCBRdCh0KSAmJiAodCA9IHZyKGUsIHQpLCBlLnBhcmVudF8gfHwgX3IoZSwgdCkpLCBlLnBhdGNoZXNfICYmIEllKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG4gICAgclt2dF0uYmFzZV8sXG4gICAgdCxcbiAgICBlLnBhdGNoZXNfLFxuICAgIGUuaW52ZXJzZVBhdGNoZXNfXG4gICkpIDogdCA9IHZyKGUsIHIsIFtdKSwgTW4oZSksIGUucGF0Y2hlc18gJiYgZS5wYXRjaExpc3RlbmVyXyhlLnBhdGNoZXNfLCBlLmludmVyc2VQYXRjaGVzXyksIHQgIT09IE9uID8gdCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHZyKHQsIGUsIHIpIHtcbiAgaWYgKE1yKGUpKVxuICAgIHJldHVybiBlO1xuICBjb25zdCBzID0gZVt2dF07XG4gIGlmICghcylcbiAgICByZXR1cm4gVmUoXG4gICAgICBlLFxuICAgICAgKGEsIGMpID0+IEpuKHQsIHMsIGUsIGEsIGMsIHIpXG4gICAgKSwgZTtcbiAgaWYgKHMuc2NvcGVfICE9PSB0KVxuICAgIHJldHVybiBlO1xuICBpZiAoIXMubW9kaWZpZWRfKVxuICAgIHJldHVybiBfcih0LCBzLmJhc2VfLCAhMCksIHMuYmFzZV87XG4gIGlmICghcy5maW5hbGl6ZWRfKSB7XG4gICAgcy5maW5hbGl6ZWRfID0gITAsIHMuc2NvcGVfLnVuZmluYWxpemVkRHJhZnRzXy0tO1xuICAgIGNvbnN0IGEgPSBzLmNvcHlfO1xuICAgIGxldCBjID0gYSwgZCA9ICExO1xuICAgIHMudHlwZV8gPT09IDMgJiYgKGMgPSBuZXcgU2V0KGEpLCBhLmNsZWFyKCksIGQgPSAhMCksIFZlKFxuICAgICAgYyxcbiAgICAgIChmLCBiKSA9PiBKbih0LCBzLCBhLCBmLCBiLCByLCBkKVxuICAgICksIF9yKHQsIGEsICExKSwgciAmJiB0LnBhdGNoZXNfICYmIEllKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVBhdGNoZXNfKFxuICAgICAgcyxcbiAgICAgIHIsXG4gICAgICB0LnBhdGNoZXNfLFxuICAgICAgdC5pbnZlcnNlUGF0Y2hlc19cbiAgICApO1xuICB9XG4gIHJldHVybiBzLmNvcHlfO1xufVxuZnVuY3Rpb24gSm4odCwgZSwgciwgcywgYSwgYywgZCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGEgPT09IHIgJiYgdHQoNSksIHllKGEpKSB7XG4gICAgY29uc3QgZiA9IGMgJiYgZSAmJiBlLnR5cGVfICE9PSAzICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG4gICAgIXFlKGUuYXNzaWduZWRfLCBzKSA/IGMuY29uY2F0KHMpIDogdm9pZCAwLCBiID0gdnIodCwgYSwgZik7XG4gICAgaWYgKHdzKHIsIHMsIGIpLCB5ZShiKSlcbiAgICAgIHQuY2FuQXV0b0ZyZWV6ZV8gPSAhMTtcbiAgICBlbHNlXG4gICAgICByZXR1cm47XG4gIH0gZWxzZSBkICYmIHIuYWRkKGEpO1xuICBpZiAoUXQoYSkgJiYgIU1yKGEpKSB7XG4gICAgaWYgKCF0LmltbWVyXy5hdXRvRnJlZXplXyAmJiB0LnVuZmluYWxpemVkRHJhZnRzXyA8IDEpXG4gICAgICByZXR1cm47XG4gICAgdnIodCwgYSksICghZSB8fCAhZS5zY29wZV8ucGFyZW50XykgJiYgdHlwZW9mIHMgIT0gXCJzeW1ib2xcIiAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwociwgcykgJiYgX3IodCwgYSk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9yKHQsIGUsIHIgPSAhMSkge1xuICAhdC5wYXJlbnRfICYmIHQuaW1tZXJfLmF1dG9GcmVlemVfICYmIHQuY2FuQXV0b0ZyZWV6ZV8gJiYgQ24oZSwgcik7XG59XG5mdW5jdGlvbiBVaSh0LCBlKSB7XG4gIGNvbnN0IHIgPSBBcnJheS5pc0FycmF5KHQpLCBzID0ge1xuICAgIHR5cGVfOiByID8gMSA6IDAsXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvZHVjZSBjYWxsIHRoaXMgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgIHNjb3BlXzogZSA/IGUuc2NvcGVfIDogTXMoKSxcbiAgICAvLyBUcnVlIGZvciBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2hhbmdlcy5cbiAgICBtb2RpZmllZF86ICExLFxuICAgIC8vIFVzZWQgZHVyaW5nIGZpbmFsaXphdGlvbi5cbiAgICBmaW5hbGl6ZWRfOiAhMSxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBhc3NpZ25lZCAodHJ1ZSkgb3IgZGVsZXRlZCAoZmFsc2UpLlxuICAgIGFzc2lnbmVkXzoge30sXG4gICAgLy8gVGhlIHBhcmVudCBkcmFmdCBzdGF0ZS5cbiAgICBwYXJlbnRfOiBlLFxuICAgIC8vIFRoZSBiYXNlIHN0YXRlLlxuICAgIGJhc2VfOiB0LFxuICAgIC8vIFRoZSBiYXNlIHByb3h5LlxuICAgIGRyYWZ0XzogbnVsbCxcbiAgICAvLyBzZXQgYmVsb3dcbiAgICAvLyBUaGUgYmFzZSBjb3B5IHdpdGggYW55IHVwZGF0ZWQgdmFsdWVzLlxuICAgIGNvcHlfOiBudWxsLFxuICAgIC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuICAgIHJldm9rZV86IG51bGwsXG4gICAgaXNNYW51YWxfOiAhMVxuICB9O1xuICBsZXQgYSA9IHMsIGMgPSBQbjtcbiAgciAmJiAoYSA9IFtzXSwgYyA9IFplKTtcbiAgY29uc3QgeyByZXZva2U6IGQsIHByb3h5OiBmIH0gPSBQcm94eS5yZXZvY2FibGUoYSwgYyk7XG4gIHJldHVybiBzLmRyYWZ0XyA9IGYsIHMucmV2b2tlXyA9IGQsIGY7XG59XG52YXIgUG4gPSB7XG4gIGdldCh0LCBlKSB7XG4gICAgaWYgKGUgPT09IHZ0KVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgciA9IHBlKHQpO1xuICAgIGlmICghcWUociwgZSkpXG4gICAgICByZXR1cm4gV2kodCwgciwgZSk7XG4gICAgY29uc3QgcyA9IHJbZV07XG4gICAgcmV0dXJuIHQuZmluYWxpemVkXyB8fCAhUXQocykgPyBzIDogcyA9PT0gcG4odC5iYXNlXywgZSkgPyAoaG4odCksIHQuY29weV9bZV0gPSBBbihzLCB0KSkgOiBzO1xuICB9LFxuICBoYXModCwgZSkge1xuICAgIHJldHVybiBlIGluIHBlKHQpO1xuICB9LFxuICBvd25LZXlzKHQpIHtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHBlKHQpKTtcbiAgfSxcbiAgc2V0KHQsIGUsIHIpIHtcbiAgICBjb25zdCBzID0gRXMocGUodCksIGUpO1xuICAgIGlmIChzICE9IG51bGwgJiYgcy5zZXQpXG4gICAgICByZXR1cm4gcy5zZXQuY2FsbCh0LmRyYWZ0XywgciksICEwO1xuICAgIGlmICghdC5tb2RpZmllZF8pIHtcbiAgICAgIGNvbnN0IGEgPSBwbihwZSh0KSwgZSksIGMgPSBhID09IG51bGwgPyB2b2lkIDAgOiBhW3Z0XTtcbiAgICAgIGlmIChjICYmIGMuYmFzZV8gPT09IHIpXG4gICAgICAgIHJldHVybiB0LmNvcHlfW2VdID0gciwgdC5hc3NpZ25lZF9bZV0gPSAhMSwgITA7XG4gICAgICBpZiAoJGkociwgYSkgJiYgKHIgIT09IHZvaWQgMCB8fCBxZSh0LmJhc2VfLCBlKSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGhuKHQpLCBUbih0KTtcbiAgICB9XG4gICAgcmV0dXJuIHQuY29weV9bZV0gPT09IHIgJiYgLy8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgbmV3IHByb3BzIHdpdGggdmFsdWUgJ3VuZGVmaW5lZCdcbiAgICAociAhPT0gdm9pZCAwIHx8IGUgaW4gdC5jb3B5XykgfHwgLy8gc3BlY2lhbCBjYXNlOiBOYU5cbiAgICBOdW1iZXIuaXNOYU4ocikgJiYgTnVtYmVyLmlzTmFOKHQuY29weV9bZV0pIHx8ICh0LmNvcHlfW2VdID0gciwgdC5hc3NpZ25lZF9bZV0gPSAhMCksICEwO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eSh0LCBlKSB7XG4gICAgcmV0dXJuIHBuKHQuYmFzZV8sIGUpICE9PSB2b2lkIDAgfHwgZSBpbiB0LmJhc2VfID8gKHQuYXNzaWduZWRfW2VdID0gITEsIGhuKHQpLCBUbih0KSkgOiBkZWxldGUgdC5hc3NpZ25lZF9bZV0sIHQuY29weV8gJiYgZGVsZXRlIHQuY29weV9bZV0sICEwO1xuICB9LFxuICAvLyBOb3RlOiBXZSBuZXZlciBjb2VyY2UgYGRlc2MudmFsdWVgIGludG8gYW4gSW1tZXIgZHJhZnQsIGJlY2F1c2Ugd2UgY2FuJ3QgbWFrZVxuICAvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCBlKSB7XG4gICAgY29uc3QgciA9IHBlKHQpLCBzID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IociwgZSk7XG4gICAgcmV0dXJuIHMgJiYge1xuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiB0LnR5cGVfICE9PSAxIHx8IGUgIT09IFwibGVuZ3RoXCIsXG4gICAgICBlbnVtZXJhYmxlOiBzLmVudW1lcmFibGUsXG4gICAgICB2YWx1ZTogcltlXVxuICAgIH07XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5KCkge1xuICAgIHR0KDExKTtcbiAgfSxcbiAgZ2V0UHJvdG90eXBlT2YodCkge1xuICAgIHJldHVybiBtZSh0LmJhc2VfKTtcbiAgfSxcbiAgc2V0UHJvdG90eXBlT2YoKSB7XG4gICAgdHQoMTIpO1xuICB9XG59LCBaZSA9IHt9O1xuVmUoUG4sICh0LCBlKSA9PiB7XG4gIFplW3RdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50c1swXSA9IGFyZ3VtZW50c1swXVswXSwgZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5aZS5kZWxldGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc05hTihwYXJzZUludChlKSkgJiYgdHQoMTMpLCBaZS5zZXQuY2FsbCh0aGlzLCB0LCBlLCB2b2lkIDApO1xufTtcblplLnNldCA9IGZ1bmN0aW9uKHQsIGUsIHIpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlICE9PSBcImxlbmd0aFwiICYmIGlzTmFOKHBhcnNlSW50KGUpKSAmJiB0dCgxNCksIFBuLnNldC5jYWxsKHRoaXMsIHRbMF0sIGUsIHIsIHRbMF0pO1xufTtcbmZ1bmN0aW9uIHBuKHQsIGUpIHtcbiAgY29uc3QgciA9IHRbdnRdO1xuICByZXR1cm4gKHIgPyBwZShyKSA6IHQpW2VdO1xufVxuZnVuY3Rpb24gV2kodCwgZSwgcikge1xuICB2YXIgYTtcbiAgY29uc3QgcyA9IEVzKGUsIHIpO1xuICByZXR1cm4gcyA/IFwidmFsdWVcIiBpbiBzID8gcy52YWx1ZSA6IChcbiAgICAvLyBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsIGNhc2UsIGlmIHRoZSBwcm9wIGlzIGEgZ2V0dGVyIGRlZmluZWQgYnkgdGhlXG4gICAgLy8gcHJvdG90eXBlLCB3ZSBzaG91bGQgaW52b2tlIGl0IHdpdGggdGhlIGRyYWZ0IGFzIGNvbnRleHQhXG4gICAgKGEgPSBzLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2FsbCh0LmRyYWZ0XylcbiAgKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIEVzKHQsIGUpIHtcbiAgaWYgKCEoZSBpbiB0KSlcbiAgICByZXR1cm47XG4gIGxldCByID0gbWUodCk7XG4gIGZvciAoOyByOyApIHtcbiAgICBjb25zdCBzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLCBlKTtcbiAgICBpZiAocylcbiAgICAgIHJldHVybiBzO1xuICAgIHIgPSBtZShyKTtcbiAgfVxufVxuZnVuY3Rpb24gVG4odCkge1xuICB0Lm1vZGlmaWVkXyB8fCAodC5tb2RpZmllZF8gPSAhMCwgdC5wYXJlbnRfICYmIFRuKHQucGFyZW50XykpO1xufVxuZnVuY3Rpb24gaG4odCkge1xuICB0LmNvcHlfIHx8ICh0LmNvcHlfID0gU24oXG4gICAgdC5iYXNlXyxcbiAgICB0LnNjb3BlXy5pbW1lcl8udXNlU3RyaWN0U2hhbGxvd0NvcHlfXG4gICkpO1xufVxudmFyIEdpID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9ICEwLCB0aGlzLnVzZVN0cmljdFNoYWxsb3dDb3B5XyA9ICExLCB0aGlzLnByb2R1Y2UgPSAoZSwgciwgcykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgciAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgYyA9IHI7XG4gICAgICAgIHIgPSBlO1xuICAgICAgICBjb25zdCBkID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGIgPSBjLCAuLi5fKSB7XG4gICAgICAgICAgcmV0dXJuIGQucHJvZHVjZShiLCAoTSkgPT4gci5jYWxsKHRoaXMsIE0sIC4uLl8pKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHR5cGVvZiByICE9IFwiZnVuY3Rpb25cIiAmJiB0dCg2KSwgcyAhPT0gdm9pZCAwICYmIHR5cGVvZiBzICE9IFwiZnVuY3Rpb25cIiAmJiB0dCg3KTtcbiAgICAgIGxldCBhO1xuICAgICAgaWYgKFF0KGUpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBWbih0aGlzKSwgZCA9IEFuKGUsIHZvaWQgMCk7XG4gICAgICAgIGxldCBmID0gITA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYSA9IHIoZCksIGYgPSAhMTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBmID8gTW4oYykgOiBFbihjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gS24oYywgcyksIHFuKGEsIGMpO1xuICAgICAgfSBlbHNlIGlmICghZSB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChhID0gcihlKSwgYSA9PT0gdm9pZCAwICYmIChhID0gZSksIGEgPT09IE9uICYmIChhID0gdm9pZCAwKSwgdGhpcy5hdXRvRnJlZXplXyAmJiBDbihhLCAhMCksIHMpIHtcbiAgICAgICAgICBjb25zdCBjID0gW10sIGQgPSBbXTtcbiAgICAgICAgICBJZShcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGUsIGEsIGMsIGQpLCBzKGMsIGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHR0KDEsIGUpO1xuICAgIH0sIHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzID0gKGUsIHIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiAoZCwgLi4uZikgPT4gdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoZCwgKGIpID0+IGUoYiwgLi4uZikpO1xuICAgICAgbGV0IHMsIGE7XG4gICAgICByZXR1cm4gW3RoaXMucHJvZHVjZShlLCByLCAoZCwgZikgPT4ge1xuICAgICAgICBzID0gZCwgYSA9IGY7XG4gICAgICB9KSwgcywgYV07XG4gICAgfSwgdHlwZW9mICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmF1dG9GcmVlemUpID09IFwiYm9vbGVhblwiICYmIHRoaXMuc2V0QXV0b0ZyZWV6ZSh0LmF1dG9GcmVlemUpLCB0eXBlb2YgKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQudXNlU3RyaWN0U2hhbGxvd0NvcHkpID09IFwiYm9vbGVhblwiICYmIHRoaXMuc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkodC51c2VTdHJpY3RTaGFsbG93Q29weSk7XG4gIH1cbiAgY3JlYXRlRHJhZnQodCkge1xuICAgIFF0KHQpIHx8IHR0KDgpLCB5ZSh0KSAmJiAodCA9IFlpKHQpKTtcbiAgICBjb25zdCBlID0gVm4odGhpcyksIHIgPSBBbih0LCB2b2lkIDApO1xuICAgIHJldHVybiByW3Z0XS5pc01hbnVhbF8gPSAhMCwgRW4oZSksIHI7XG4gIH1cbiAgZmluaXNoRHJhZnQodCwgZSkge1xuICAgIGNvbnN0IHIgPSB0ICYmIHRbdnRdO1xuICAgICghciB8fCAhci5pc01hbnVhbF8pICYmIHR0KDkpO1xuICAgIGNvbnN0IHsgc2NvcGVfOiBzIH0gPSByO1xuICAgIHJldHVybiBLbihzLCBlKSwgcW4odm9pZCAwLCBzKTtcbiAgfVxuICAvKipcbiAgICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYXV0by1mcmVlemluZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgc2V0QXV0b0ZyZWV6ZSh0KSB7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3MgdHJ1ZSB0byBlbmFibGUgc3RyaWN0IHNoYWxsb3cgY29weS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaW1tZXIgZG9lcyBub3QgY29weSB0aGUgb2JqZWN0IGRlc2NyaXB0b3JzIHN1Y2ggYXMgZ2V0dGVyLCBzZXR0ZXIgYW5kIG5vbi1lbnVtcmFibGUgcHJvcGVydGllcy5cbiAgICovXG4gIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5KHQpIHtcbiAgICB0aGlzLnVzZVN0cmljdFNoYWxsb3dDb3B5XyA9IHQ7XG4gIH1cbiAgYXBwbHlQYXRjaGVzKHQsIGUpIHtcbiAgICBsZXQgcjtcbiAgICBmb3IgKHIgPSBlLmxlbmd0aCAtIDE7IHIgPj0gMDsgci0tKSB7XG4gICAgICBjb25zdCBhID0gZVtyXTtcbiAgICAgIGlmIChhLnBhdGgubGVuZ3RoID09PSAwICYmIGEub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIHQgPSBhLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgciA+IC0xICYmIChlID0gZS5zbGljZShyICsgMSkpO1xuICAgIGNvbnN0IHMgPSBJZShcIlBhdGNoZXNcIikuYXBwbHlQYXRjaGVzXztcbiAgICByZXR1cm4geWUodCkgPyBzKHQsIGUpIDogdGhpcy5wcm9kdWNlKFxuICAgICAgdCxcbiAgICAgIChhKSA9PiBzKGEsIGUpXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIEFuKHQsIGUpIHtcbiAgY29uc3QgciA9IHRyKHQpID8gSWUoXCJNYXBTZXRcIikucHJveHlNYXBfKHQsIGUpIDogZXIodCkgPyBJZShcIk1hcFNldFwiKS5wcm94eVNldF8odCwgZSkgOiBVaSh0LCBlKTtcbiAgcmV0dXJuIChlID8gZS5zY29wZV8gOiBNcygpKS5kcmFmdHNfLnB1c2gociksIHI7XG59XG5mdW5jdGlvbiBZaSh0KSB7XG4gIHJldHVybiB5ZSh0KSB8fCB0dCgxMCwgdCksIFRzKHQpO1xufVxuZnVuY3Rpb24gVHModCkge1xuICBpZiAoIVF0KHQpIHx8IE1yKHQpKVxuICAgIHJldHVybiB0O1xuICBjb25zdCBlID0gdFt2dF07XG4gIGxldCByO1xuICBpZiAoZSkge1xuICAgIGlmICghZS5tb2RpZmllZF8pXG4gICAgICByZXR1cm4gZS5iYXNlXztcbiAgICBlLmZpbmFsaXplZF8gPSAhMCwgciA9IFNuKHQsIGUuc2NvcGVfLmltbWVyXy51c2VTdHJpY3RTaGFsbG93Q29weV8pO1xuICB9IGVsc2VcbiAgICByID0gU24odCwgITApO1xuICByZXR1cm4gVmUociwgKHMsIGEpID0+IHtcbiAgICB3cyhyLCBzLCBUcyhhKSk7XG4gIH0pLCBlICYmIChlLmZpbmFsaXplZF8gPSAhMSksIHI7XG59XG5mdW5jdGlvbiBabigpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGtzLnB1c2goXG4gICAgJ1NldHMgY2Fubm90IGhhdmUgXCJyZXBsYWNlXCIgcGF0Y2hlcy4nLFxuICAgIGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBcIlVuc3VwcG9ydGVkIHBhdGNoIG9wZXJhdGlvbjogXCIgKyBtO1xuICAgIH0sXG4gICAgZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBtO1xuICAgIH0sXG4gICAgXCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcbiAgKTtcbiAgY29uc3QgZSA9IFwicmVwbGFjZVwiLCByID0gXCJhZGRcIiwgcyA9IFwicmVtb3ZlXCI7XG4gIGZ1bmN0aW9uIGEobSwgVCwgQywgdSkge1xuICAgIHN3aXRjaCAobS50eXBlXykge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gZChcbiAgICAgICAgICBtLFxuICAgICAgICAgIFQsXG4gICAgICAgICAgQyxcbiAgICAgICAgICB1XG4gICAgICAgICk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBjKG0sIFQsIEMsIHUpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gZihcbiAgICAgICAgICBtLFxuICAgICAgICAgIFQsXG4gICAgICAgICAgQyxcbiAgICAgICAgICB1XG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGMobSwgVCwgQywgdSkge1xuICAgIGxldCB7IGJhc2VfOiBsLCBhc3NpZ25lZF86IFMgfSA9IG0sIHcgPSBtLmNvcHlfO1xuICAgIHcubGVuZ3RoIDwgbC5sZW5ndGggJiYgKFtsLCB3XSA9IFt3LCBsXSwgW0MsIHVdID0gW3UsIENdKTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGwubGVuZ3RoOyBrKyspXG4gICAgICBpZiAoU1trXSAmJiB3W2tdICE9PSBsW2tdKSB7XG4gICAgICAgIGNvbnN0IGggPSBULmNvbmNhdChba10pO1xuICAgICAgICBDLnB1c2goe1xuICAgICAgICAgIG9wOiBlLFxuICAgICAgICAgIHBhdGg6IGgsXG4gICAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFsdWU6IEUod1trXSlcbiAgICAgICAgfSksIHUucHVzaCh7XG4gICAgICAgICAgb3A6IGUsXG4gICAgICAgICAgcGF0aDogaCxcbiAgICAgICAgICB2YWx1ZTogRShsW2tdKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBmb3IgKGxldCBrID0gbC5sZW5ndGg7IGsgPCB3Lmxlbmd0aDsgaysrKSB7XG4gICAgICBjb25zdCBoID0gVC5jb25jYXQoW2tdKTtcbiAgICAgIEMucHVzaCh7XG4gICAgICAgIG9wOiByLFxuICAgICAgICBwYXRoOiBoLFxuICAgICAgICAvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIHZhbHVlOiBFKHdba10pXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgayA9IHcubGVuZ3RoIC0gMTsgbC5sZW5ndGggPD0gazsgLS1rKSB7XG4gICAgICBjb25zdCBoID0gVC5jb25jYXQoW2tdKTtcbiAgICAgIHUucHVzaCh7XG4gICAgICAgIG9wOiBzLFxuICAgICAgICBwYXRoOiBoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZChtLCBULCBDLCB1KSB7XG4gICAgY29uc3QgeyBiYXNlXzogbCwgY29weV86IFMgfSA9IG07XG4gICAgVmUobS5hc3NpZ25lZF8sICh3LCBrKSA9PiB7XG4gICAgICBjb25zdCBoID0gZm4obCwgdyksIHkgPSBmbihTLCB3KSwgdiA9IGsgPyBxZShsLCB3KSA/IGUgOiByIDogcztcbiAgICAgIGlmIChoID09PSB5ICYmIHYgPT09IGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IEkgPSBULmNvbmNhdCh3KTtcbiAgICAgIEMucHVzaCh2ID09PSBzID8geyBvcDogdiwgcGF0aDogSSB9IDogeyBvcDogdiwgcGF0aDogSSwgdmFsdWU6IHkgfSksIHUucHVzaChcbiAgICAgICAgdiA9PT0gciA/IHsgb3A6IHMsIHBhdGg6IEkgfSA6IHYgPT09IHMgPyB7IG9wOiByLCBwYXRoOiBJLCB2YWx1ZTogRShoKSB9IDogeyBvcDogZSwgcGF0aDogSSwgdmFsdWU6IEUoaCkgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmKG0sIFQsIEMsIHUpIHtcbiAgICBsZXQgeyBiYXNlXzogbCwgY29weV86IFMgfSA9IG0sIHcgPSAwO1xuICAgIGwuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgaWYgKCFTLmhhcyhrKSkge1xuICAgICAgICBjb25zdCBoID0gVC5jb25jYXQoW3ddKTtcbiAgICAgICAgQy5wdXNoKHtcbiAgICAgICAgICBvcDogcyxcbiAgICAgICAgICBwYXRoOiBoLFxuICAgICAgICAgIHZhbHVlOiBrXG4gICAgICAgIH0pLCB1LnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiByLFxuICAgICAgICAgIHBhdGg6IGgsXG4gICAgICAgICAgdmFsdWU6IGtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB3Kys7XG4gICAgfSksIHcgPSAwLCBTLmZvckVhY2goKGspID0+IHtcbiAgICAgIGlmICghbC5oYXMoaykpIHtcbiAgICAgICAgY29uc3QgaCA9IFQuY29uY2F0KFt3XSk7XG4gICAgICAgIEMucHVzaCh7XG4gICAgICAgICAgb3A6IHIsXG4gICAgICAgICAgcGF0aDogaCxcbiAgICAgICAgICB2YWx1ZToga1xuICAgICAgICB9KSwgdS51bnNoaWZ0KHtcbiAgICAgICAgICBvcDogcyxcbiAgICAgICAgICBwYXRoOiBoLFxuICAgICAgICAgIHZhbHVlOiBrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdysrO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGIobSwgVCwgQywgdSkge1xuICAgIEMucHVzaCh7XG4gICAgICBvcDogZSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgdmFsdWU6IFQgPT09IE9uID8gdm9pZCAwIDogVFxuICAgIH0pLCB1LnB1c2goe1xuICAgICAgb3A6IGUsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiBtXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gXyhtLCBUKSB7XG4gICAgcmV0dXJuIFQuZm9yRWFjaCgoQykgPT4ge1xuICAgICAgY29uc3QgeyBwYXRoOiB1LCBvcDogbCB9ID0gQztcbiAgICAgIGxldCBTID0gbTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdS5sZW5ndGggLSAxOyB5KyspIHtcbiAgICAgICAgY29uc3QgdiA9IGdlKFMpO1xuICAgICAgICBsZXQgSSA9IHVbeV07XG4gICAgICAgIHR5cGVvZiBJICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIEkgIT0gXCJudW1iZXJcIiAmJiAoSSA9IFwiXCIgKyBJKSwgKHYgPT09IDAgfHwgdiA9PT0gMSkgJiYgKEkgPT09IFwiX19wcm90b19fXCIgfHwgSSA9PT0gXCJjb25zdHJ1Y3RvclwiKSAmJiB0dCgxOSksIHR5cGVvZiBTID09IFwiZnVuY3Rpb25cIiAmJiBJID09PSBcInByb3RvdHlwZVwiICYmIHR0KDE5KSwgUyA9IGZuKFMsIEkpLCB0eXBlb2YgUyAhPSBcIm9iamVjdFwiICYmIHR0KDE4LCB1LmpvaW4oXCIvXCIpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHcgPSBnZShTKSwgayA9IE0oQy52YWx1ZSksIGggPSB1W3UubGVuZ3RoIC0gMV07XG4gICAgICBzd2l0Y2ggKGwpIHtcbiAgICAgICAgY2FzZSBlOlxuICAgICAgICAgIHN3aXRjaCAodykge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXR1cm4gUy5zZXQoaCwgayk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHR0KDE2KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBTW2hdID0gaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgcjpcbiAgICAgICAgICBzd2l0Y2ggKHcpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcmV0dXJuIGggPT09IFwiLVwiID8gUy5wdXNoKGspIDogUy5zcGxpY2UoaCwgMCwgayk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiBTLnNldChoLCBrKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIFMuYWRkKGspO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIFNbaF0gPSBrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBzOlxuICAgICAgICAgIHN3aXRjaCAodykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByZXR1cm4gUy5zcGxpY2UoaCwgMSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiBTLmRlbGV0ZShoKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIFMuZGVsZXRlKEMudmFsdWUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBTW2hdO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0dCgxNywgbCk7XG4gICAgICB9XG4gICAgfSksIG07XG4gIH1cbiAgZnVuY3Rpb24gTShtKSB7XG4gICAgaWYgKCFRdChtKSlcbiAgICAgIHJldHVybiBtO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG0pKVxuICAgICAgcmV0dXJuIG0ubWFwKE0pO1xuICAgIGlmICh0cihtKSlcbiAgICAgIHJldHVybiBuZXcgTWFwKFxuICAgICAgICBBcnJheS5mcm9tKG0uZW50cmllcygpKS5tYXAoKFtDLCB1XSkgPT4gW0MsIE0odSldKVxuICAgICAgKTtcbiAgICBpZiAoZXIobSkpXG4gICAgICByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKG0pLm1hcChNKSk7XG4gICAgY29uc3QgVCA9IE9iamVjdC5jcmVhdGUobWUobSkpO1xuICAgIGZvciAoY29uc3QgQyBpbiBtKVxuICAgICAgVFtDXSA9IE0obVtDXSk7XG4gICAgcmV0dXJuIHFlKG0sIEtlKSAmJiAoVFtLZV0gPSBtW0tlXSksIFQ7XG4gIH1cbiAgZnVuY3Rpb24gRShtKSB7XG4gICAgcmV0dXJuIHllKG0pID8gTShtKSA6IG07XG4gIH1cbiAgamkoXCJQYXRjaGVzXCIsIHtcbiAgICBhcHBseVBhdGNoZXNfOiBfLFxuICAgIGdlbmVyYXRlUGF0Y2hlc186IGEsXG4gICAgZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfOiBiXG4gIH0pO1xufVxudmFyIF90ID0gbmV3IEdpKCksIEJpID0gX3QucHJvZHVjZTtcbl90LnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKFxuICBfdFxuKTtcbl90LnNldEF1dG9GcmVlemUuYmluZChfdCk7XG5fdC5zZXRVc2VTdHJpY3RTaGFsbG93Q29weS5iaW5kKF90KTtcbnZhciBYaSA9IF90LmFwcGx5UGF0Y2hlcy5iaW5kKF90KTtcbl90LmNyZWF0ZURyYWZ0LmJpbmQoX3QpO1xuX3QuZmluaXNoRHJhZnQuYmluZChfdCk7XG52YXIgS2kgPSA5MDA3MTk5MjU0NzQwOTkxLCBWaSA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIHFpID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLCBKaSA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiwgWmkgPSBcIltvYmplY3QgU3ltYm9sXVwiLCBRaSA9IHR5cGVvZiBTdCA9PSBcIm9iamVjdFwiICYmIFN0ICYmIFN0Lk9iamVjdCA9PT0gT2JqZWN0ICYmIFN0LCB0YSA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGYsIGVhID0gUWkgfHwgdGEgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuZnVuY3Rpb24gcmEodCwgZSwgcikge1xuICBzd2l0Y2ggKHIubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHQuY2FsbChlKTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gdC5jYWxsKGUsIHJbMF0pO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB0LmNhbGwoZSwgclswXSwgclsxXSk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHQuY2FsbChlLCByWzBdLCByWzFdLCByWzJdKTtcbiAgfVxuICByZXR1cm4gdC5hcHBseShlLCByKTtcbn1cbmZ1bmN0aW9uIG5hKHQsIGUpIHtcbiAgZm9yICh2YXIgciA9IC0xLCBzID0gdCA/IHQubGVuZ3RoIDogMCwgYSA9IEFycmF5KHMpOyArK3IgPCBzOyApXG4gICAgYVtyXSA9IGUodFtyXSwgciwgdCk7XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gc2EodCwgZSkge1xuICBmb3IgKHZhciByID0gLTEsIHMgPSBlLmxlbmd0aCwgYSA9IHQubGVuZ3RoOyArK3IgPCBzOyApXG4gICAgdFthICsgcl0gPSBlW3JdO1xuICByZXR1cm4gdDtcbn1cbnZhciBSbiA9IE9iamVjdC5wcm90b3R5cGUsIGlhID0gUm4uaGFzT3duUHJvcGVydHksIHpuID0gUm4udG9TdHJpbmcsIFFuID0gZWEuU3ltYm9sLCBhYSA9IFJuLnByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cyA9IFFuID8gUW4uaXNDb25jYXRTcHJlYWRhYmxlIDogdm9pZCAwLCBlcyA9IE1hdGgubWF4O1xuZnVuY3Rpb24gb2EodCwgZSwgciwgcywgYSkge1xuICB2YXIgYyA9IC0xLCBkID0gdC5sZW5ndGg7XG4gIGZvciAociB8fCAociA9IGRhKSwgYSB8fCAoYSA9IFtdKTsgKytjIDwgZDsgKSB7XG4gICAgdmFyIGYgPSB0W2NdO1xuICAgIHIoZikgPyBzYShhLCBmKSA6IGFbYS5sZW5ndGhdID0gZjtcbiAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGNhKHQsIGUpIHtcbiAgcmV0dXJuIHQgPSBPYmplY3QodCksIHVhKHQsIGUsIGZ1bmN0aW9uKHIsIHMpIHtcbiAgICByZXR1cm4gcyBpbiB0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVhKHQsIGUsIHIpIHtcbiAgZm9yICh2YXIgcyA9IC0xLCBhID0gZS5sZW5ndGgsIGMgPSB7fTsgKytzIDwgYTsgKSB7XG4gICAgdmFyIGQgPSBlW3NdLCBmID0gdFtkXTtcbiAgICByKGYsIGQpICYmIChjW2RdID0gZik7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5mdW5jdGlvbiBsYSh0LCBlKSB7XG4gIHJldHVybiBlID0gZXMoZSA9PT0gdm9pZCAwID8gdC5sZW5ndGggLSAxIDogZSwgMCksIGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHIgPSBhcmd1bWVudHMsIHMgPSAtMSwgYSA9IGVzKHIubGVuZ3RoIC0gZSwgMCksIGMgPSBBcnJheShhKTsgKytzIDwgYTsgKVxuICAgICAgY1tzXSA9IHJbZSArIHNdO1xuICAgIHMgPSAtMTtcbiAgICBmb3IgKHZhciBkID0gQXJyYXkoZSArIDEpOyArK3MgPCBlOyApXG4gICAgICBkW3NdID0gcltzXTtcbiAgICByZXR1cm4gZFtlXSA9IGMsIHJhKHQsIHRoaXMsIGQpO1xuICB9O1xufVxuZnVuY3Rpb24gZGEodCkge1xuICByZXR1cm4gaGEodCkgfHwgcGEodCkgfHwgISEodHMgJiYgdCAmJiB0W3RzXSk7XG59XG5mdW5jdGlvbiBmYSh0KSB7XG4gIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiIHx8IHZhKHQpKVxuICAgIHJldHVybiB0O1xuICB2YXIgZSA9IHQgKyBcIlwiO1xuICByZXR1cm4gZSA9PSBcIjBcIiAmJiAxIC8gdCA9PSAtMSAvIDAgPyBcIi0wXCIgOiBlO1xufVxuZnVuY3Rpb24gcGEodCkge1xuICByZXR1cm4geWEodCkgJiYgaWEuY2FsbCh0LCBcImNhbGxlZVwiKSAmJiAoIWFhLmNhbGwodCwgXCJjYWxsZWVcIikgfHwgem4uY2FsbCh0KSA9PSBWaSk7XG59XG52YXIgaGEgPSBBcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gbWEodCkge1xuICByZXR1cm4gdCAhPSBudWxsICYmIElhKHQubGVuZ3RoKSAmJiAhZ2EodCk7XG59XG5mdW5jdGlvbiB5YSh0KSB7XG4gIHJldHVybiBBcyh0KSAmJiBtYSh0KTtcbn1cbmZ1bmN0aW9uIGdhKHQpIHtcbiAgdmFyIGUgPSBiYSh0KSA/IHpuLmNhbGwodCkgOiBcIlwiO1xuICByZXR1cm4gZSA9PSBxaSB8fCBlID09IEppO1xufVxuZnVuY3Rpb24gSWEodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJudW1iZXJcIiAmJiB0ID4gLTEgJiYgdCAlIDEgPT0gMCAmJiB0IDw9IEtpO1xufVxuZnVuY3Rpb24gYmEodCkge1xuICB2YXIgZSA9IHR5cGVvZiB0O1xuICByZXR1cm4gISF0ICYmIChlID09IFwib2JqZWN0XCIgfHwgZSA9PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gQXModCkge1xuICByZXR1cm4gISF0ICYmIHR5cGVvZiB0ID09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiB2YSh0KSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcInN5bWJvbFwiIHx8IEFzKHQpICYmIHpuLmNhbGwodCkgPT0gWmk7XG59XG52YXIgX2EgPSBsYShmdW5jdGlvbih0LCBlKSB7XG4gIHJldHVybiB0ID09IG51bGwgPyB7fSA6IGNhKHQsIG5hKG9hKGUpLCBmYSkpO1xufSksIGthID0gX2E7XG5jb25zdCBycyA9IC8qIEBfX1BVUkVfXyAqLyB4bihrYSksIFNhID0ge1xuICB3aWR0aDogMTA4MCxcbiAgaGVpZ2h0OiAxOTIwXG59LCB3YSA9IDMwLCBNYSA9IHtcbiAgc2l6ZTogU2EsXG4gIGZwczogd2EsXG4gIHRyYWNrczogW10sXG4gIHRyYWNrSXRlbUlkczogW10sXG4gIHRyYWNrSXRlbXNNYXA6IHt9LFxuICB0cmFuc2l0aW9uSWRzOiBbXSxcbiAgdHJhbnNpdGlvbnNNYXA6IHt9LFxuICBzY2FsZToge1xuICAgIHVuaXQ6IDEsXG4gICAgem9vbTogMSxcbiAgICBzZWdtZW50czogMSxcbiAgICBpbmRleDogMVxuICB9LFxuICBkdXJhdGlvbjogMCxcbiAgYWN0aXZlSWRzOiBbXSxcbiAgdHJhY2tJdGVtRGV0YWlsc01hcDoge30sXG4gIHN0cnVjdHVyZTogW11cbn0sIG5zID0gW1xuICBcInRyYWNrc1wiLFxuICBcInRyYWNrSXRlbXNNYXBcIixcbiAgXCJ0cmFja0l0ZW1EZXRhaWxzTWFwXCIsXG4gIFwidHJhbnNpdGlvbklkc1wiLFxuICBcInRyYW5zaXRpb25zTWFwXCIsXG4gIFwidHJhY2tJdGVtSWRzXCIsXG4gIFwic3RydWN0dXJlXCJcbl07XG5jbGFzcyBlbyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBsZSh0aGlzLCBcInN0YXRlU3ViamVjdFwiKTtcbiAgICBsZSh0aGlzLCBcInN0YXRlSGlzdG9yeVN1YmplY3RcIik7XG4gICAgbGUodGhpcywgXCJwcmV2U3RhdGVcIik7XG4gICAgbGUodGhpcywgXCJ1bmRvc1wiLCBbXSk7XG4gICAgbGUodGhpcywgXCJyZWRvc1wiLCBbXSk7XG4gICAgbGUodGhpcywgXCJsaXN0ZW5lclwiKTtcbiAgICBjb25zdCByID0gT2JqZWN0LmFzc2lnbih7fSwgTWEsIGUpO1xuICAgIHRoaXMuc3RhdGVTdWJqZWN0ID0gbmV3IFVuKHIpLCB0aGlzLnN0YXRlSGlzdG9yeVN1YmplY3QgPSBuZXcgVW4oe1xuICAgICAgaGFuZGxlUmVkbzogITEsXG4gICAgICBoYW5kbGVVbmRvOiAhMVxuICAgIH0pLCB0aGlzLnByZXZTdGF0ZSA9IHIsIHRoaXMuaW5pdExpc3RlbmVycygpO1xuICB9XG4gIGluaXRMaXN0ZW5lcnMoKSB7XG4gICAgUmkodGhpcyk7XG4gIH1cbiAgZGVzdHJveUxpc3RlbmVycygpIHtcbiAgICB0aGlzLmxpc3RlbmVyICYmIHRoaXMubGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgfVxuICBwdXJnZSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lMaXN0ZW5lcnMoKTtcbiAgfVxuICB1cGRhdGVIaXN0b3J5KGUsIHIpIHtcbiAgICBjb25zdCBzID0gcnMoZSwgbnMpLCBhID0gcnModGhpcy5nZXRTdGF0ZSgpLCBucyksIGMgPSBfcyhhLCBzKTtcbiAgICBjLmxlbmd0aCAmJiAodGhpcy51bmRvcy5wdXNoKHsgdW5kb3M6IGMsIHR5cGU6IHIgfSksIHRoaXMucmVkb3MgPSBbXSk7XG4gIH1cbiAgZ2V0U3RhdGVIaXN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlSGlzdG9yeVN1YmplY3QuZ2V0VmFsdWUoKTtcbiAgfVxuICBzdWJzY3JpYmVIaXN0b3J5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZUhpc3RvcnlTdWJqZWN0LnN1YnNjcmliZShlKTtcbiAgfVxuICAvLyBHZXQgdGhlIGN1cnJlbnQgc3RhdGVcbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVTdWJqZWN0LmdldFZhbHVlKCk7XG4gIH1cbiAgLy8gU3Vic2NyaWJlIHRvIHN0YXRlIGNoYW5nZXNcbiAgc3Vic2NyaWJlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVN1YmplY3Quc3Vic2NyaWJlKGUpO1xuICB9XG4gIC8vIFVwZGF0ZSB0aGUgc3RhdGUsIGVtaXR0aW5nIG9ubHkgaWYgdGhlIHBhcnQgb2YgdGhlIHN0YXRlIGhhcyBjaGFuZ2VkXG4gIHVwZGF0ZVN0YXRlKGUsIHIgPSB7IHVwZGF0ZUhpc3Rvcnk6ICExIH0pIHtcbiAgICBjb25zdCBzID0gdGhpcy5nZXRTdGF0ZSgpLCBhID0ge1xuICAgICAgLi4uSyhzKSxcbiAgICAgIC4uLksoZSlcbiAgICB9O1xuICAgIFEocywgYSkgfHwgKHIudXBkYXRlSGlzdG9yeSAmJiB0aGlzLnVwZGF0ZUhpc3RvcnkoYSwgci5raW5kKSwgdGhpcy5wcmV2U3RhdGUgPSBzLCB0aGlzLnN0YXRlU3ViamVjdC5uZXh0KGEpKTtcbiAgfVxuICAvLyBlbWl0IGNoYW5nZXMgZm9yIGRlc2lnbiBzaXplXG4gIHN1YnNjcmliZVRvU2l6ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgocikgPT4ge1xuICAgICAgUShyLnNpemUsIHRoaXMucHJldlN0YXRlLnNpemUpIHx8IGUoeyBzaXplOiByLnNpemUgfSk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU2VsZWN0aXZlbHkgc3Vic2NyaWJlIHRvIHNjYWxlIGNoYW5nZXNcbiAgc3Vic2NyaWJlVG9TY2FsZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgocikgPT4ge1xuICAgICAgUShyLnNjYWxlLCB0aGlzLnByZXZTdGF0ZS5zY2FsZSkgfHwgZSh7IHNjYWxlOiByLnNjYWxlIH0pO1xuICAgIH0pO1xuICB9XG4gIC8vIFNlbGVjdGl2ZWx5IHN1YnNjcmliZSB0byBmcHMgY2hhbmdlc1xuICBzdWJzY3JpYmVUb0ZwcyhlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgocikgPT4ge1xuICAgICAgci5mcHMgIT09IHRoaXMucHJldlN0YXRlLmZwcyAmJiBlKHsgZnBzOiByLmZwcyB9KTtcbiAgICB9KTtcbiAgfVxuICBzdWJzY3JpYmVUb1VwZGF0ZVRyYWNrSXRlbShlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgocikgPT4ge1xuICAgICAgUShyLnRyYWNrSXRlbXNNYXAsIHRoaXMucHJldlN0YXRlLnRyYWNrSXRlbXNNYXApIHx8IGUoeyB0cmFja0l0ZW1zTWFwOiByLnRyYWNrSXRlbXNNYXAgfSk7XG4gICAgfSk7XG4gIH1cbiAgc3Vic2NyaWJlVG9VcGRhdGVBbmltYXRpb25zKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVN1YmplY3QuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKChyKSA9PiB7XG4gICAgICBjb25zdCBzID0gT2JqZWN0LmtleXMoci50cmFja0l0ZW1zTWFwKS5maWx0ZXIoXG4gICAgICAgIChhKSA9PiB7XG4gICAgICAgICAgY29uc3QgYyA9IHRoaXMucHJldlN0YXRlLnRyYWNrSXRlbXNNYXBbYV0sIGQgPSByLnRyYWNrSXRlbXNNYXBbYV07XG4gICAgICAgICAgcmV0dXJuIGMgJiYgZCAmJiAhUShjLmFuaW1hdGlvbnMsIGQuYW5pbWF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBlKHsgdHJhY2tJdGVtc01hcDogci50cmFja0l0ZW1zTWFwLCBjaGFuZ2VkQW5pbWF0aW9uSWRzOiBzIH0pO1xuICAgIH0pO1xuICB9XG4gIHN1YnNjcmliZVRvVXBkYXRlVHJhY2tJdGVtVGltaW5nKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVN1YmplY3QuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKChyKSA9PiB7XG4gICAgICBpZiAoIVEoci50cmFja0l0ZW1zTWFwLCB0aGlzLnByZXZTdGF0ZS50cmFja0l0ZW1zTWFwKSkge1xuICAgICAgICBjb25zdCBzID0gT2JqZWN0LmtleXMoci50cmFja0l0ZW1zTWFwKS5maWx0ZXIoKGMpID0+IHtcbiAgICAgICAgICBjb25zdCBkID0gdGhpcy5wcmV2U3RhdGUudHJhY2tJdGVtc01hcFtjXSwgZiA9IHIudHJhY2tJdGVtc01hcFtjXTtcbiAgICAgICAgICByZXR1cm4gZCAmJiBmICYmICFRKGQudHJpbSwgZi50cmltKTtcbiAgICAgICAgfSksIGEgPSBPYmplY3Qua2V5cyhyLnRyYWNrSXRlbXNNYXApLmZpbHRlcihcbiAgICAgICAgICAoYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMucHJldlN0YXRlLnRyYWNrSXRlbXNNYXBbY10sIGYgPSByLnRyYWNrSXRlbXNNYXBbY107XG4gICAgICAgICAgICByZXR1cm4gZCAmJiBmICYmICFRKGQuZGlzcGxheSwgZi5kaXNwbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGUoe1xuICAgICAgICAgIHRyYWNrSXRlbXNNYXA6IHIudHJhY2tJdGVtc01hcCxcbiAgICAgICAgICBjaGFuZ2VkVHJpbUlkczogcy5sZW5ndGggPiAwID8gcyA6IHZvaWQgMCxcbiAgICAgICAgICBjaGFuZ2VkRGlzcGxheUlkczogYS5sZW5ndGggPiAwID8gYSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdWJzY3JpYmVUb1VwZGF0ZUl0ZW1EZXRhaWxzKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVN1YmplY3QuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKChyKSA9PiB7XG4gICAgICBRKHIudHJhY2tJdGVtRGV0YWlsc01hcCwgdGhpcy5wcmV2U3RhdGUudHJhY2tJdGVtRGV0YWlsc01hcCkgfHwgZSh7IHRyYWNrSXRlbURldGFpbHNNYXA6IHIudHJhY2tJdGVtRGV0YWlsc01hcCB9KTtcbiAgICB9KTtcbiAgfVxuICAvLyBTZWxlY3RpdmVseSBzdWJzY3JpYmUgdG8gZHVyYXRpb24gY2hhbmdlc1xuICBzdWJzY3JpYmVUb0R1cmF0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVN1YmplY3QuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKChyKSA9PiB7XG4gICAgICByLmR1cmF0aW9uICE9PSB0aGlzLnByZXZTdGF0ZS5kdXJhdGlvbiAmJiBlKHsgZHVyYXRpb246IHIuZHVyYXRpb24gfSk7XG4gICAgfSk7XG4gIH1cbiAgc3Vic2NyaWJlVG9IaXN0b3J5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZUhpc3RvcnlTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgocikgPT4ge1xuICAgICAgaWYgKHIuaGFuZGxlUmVkbykge1xuICAgICAgICBjb25zdCBzID0gdGhpcy51bmRvc1t0aGlzLnVuZG9zLmxlbmd0aCAtIDFdLnR5cGU7XG4gICAgICAgIGUoeyAuLi50aGlzLmdldFN0YXRlKCksIHR5cGU6IHMgfSksIHRoaXMuc3RhdGVIaXN0b3J5U3ViamVjdC5uZXh0KHsgaGFuZGxlUmVkbzogITEsIGhhbmRsZVVuZG86ICExIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHIuaGFuZGxlVW5kbykge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5yZWRvc1t0aGlzLnJlZG9zLmxlbmd0aCAtIDFdLnR5cGU7XG4gICAgICAgIGUoeyAuLi50aGlzLmdldFN0YXRlKCksIHR5cGU6IHMgfSksIHRoaXMuc3RhdGVIaXN0b3J5U3ViamVjdC5uZXh0KHsgaGFuZGxlUmVkbzogITEsIGhhbmRsZVVuZG86ICExIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN1YnNjcmliZVRvQWRkT3JSZW1vdmVJdGVtcyhlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgocikgPT4ge1xuICAgICAgY29uc3QgcyA9IFsuLi5yLnRyYWNrSXRlbUlkc10uc29ydCgpLCBhID0gWy4uLnRoaXMucHJldlN0YXRlLnRyYWNrSXRlbUlkc10uc29ydCgpLCBjID0gWy4uLnIudHJhbnNpdGlvbklkc10uc29ydCgpLCBkID0gWy4uLnRoaXMucHJldlN0YXRlLnRyYW5zaXRpb25JZHNdLnNvcnQoKTtcbiAgICAgICghUShzLCBhKSB8fCAhUShjLCBkKSkgJiYgZSh7IHRyYWNrSXRlbUlkczogci50cmFja0l0ZW1JZHMgfSk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU2VsZWN0aXZlbHkgc3Vic2NyaWJlIHRvIGFjdGl2ZUlkcyBjaGFuZ2VzXG4gIHN1YnNjcmliZVRvQWN0aXZlSWRzKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVN1YmplY3QuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKChyKSA9PiB7XG4gICAgICBRKHIuYWN0aXZlSWRzLCB0aGlzLnByZXZTdGF0ZS5hY3RpdmVJZHMpIHx8IGUoeyBhY3RpdmVJZHM6IHIuYWN0aXZlSWRzIH0pO1xuICAgIH0pO1xuICB9XG4gIHN1YnNjcmliZVRvVHJhY2tzKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVN1YmplY3QuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKChyKSA9PiB7XG4gICAgICBjb25zdCBzID0gci50cmFja3MsIGMgPSB0aGlzLnByZXZTdGF0ZS50cmFja3MubWFwKChmKSA9PiBmLmlkKSwgZCA9IHMuZmlsdGVyKFxuICAgICAgICAoZikgPT4gIWMuaW5jbHVkZXMoZi5pZClcbiAgICAgICk7XG4gICAgICBkLmxlbmd0aCAmJiBlKHtcbiAgICAgICAgdHJhY2tzOiByLnRyYWNrcyxcbiAgICAgICAgY2hhbmdlZFRyYWNrczogZC5tYXAoKGYpID0+IGYuaWQpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvLyBTZWxlY3RpdmVseSBzdWJzY3JpYmUgdG8gbXVsdGlwbGUgdHJhY2stcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIHN1YnNjcmliZVRvU3RhdGUoZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlU3ViamVjdC5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoKHIpID0+IHtcbiAgICAgICghUShyLnRyYWNrcywgdGhpcy5wcmV2U3RhdGUudHJhY2tzKSB8fCAhUShyLnRyYWNrSXRlbUlkcywgdGhpcy5wcmV2U3RhdGUudHJhY2tJdGVtSWRzKSB8fCAhUShyLnRyYWNrSXRlbXNNYXAsIHRoaXMucHJldlN0YXRlLnRyYWNrSXRlbXNNYXApIHx8ICFRKHIudHJhbnNpdGlvbklkcywgdGhpcy5wcmV2U3RhdGUudHJhbnNpdGlvbklkcykgfHwgIVEoci50cmFuc2l0aW9uc01hcCwgdGhpcy5wcmV2U3RhdGUudHJhbnNpdGlvbnNNYXApIHx8ICFRKFxuICAgICAgICByLnRyYWNrSXRlbURldGFpbHNNYXAsXG4gICAgICAgIHRoaXMucHJldlN0YXRlLnRyYWNrSXRlbURldGFpbHNNYXBcbiAgICAgICkgfHwgIVEoci5zdHJ1Y3R1cmUsIHRoaXMucHJldlN0YXRlLnN0cnVjdHVyZSkpICYmIGUoe1xuICAgICAgICB0cmFja3M6IHIudHJhY2tzLFxuICAgICAgICB0cmFja0l0ZW1JZHM6IHIudHJhY2tJdGVtSWRzLFxuICAgICAgICB0cmFja0l0ZW1zTWFwOiByLnRyYWNrSXRlbXNNYXAsXG4gICAgICAgIHRyYW5zaXRpb25JZHM6IHIudHJhbnNpdGlvbklkcyxcbiAgICAgICAgdHJhbnNpdGlvbnNNYXA6IHIudHJhbnNpdGlvbnNNYXAsXG4gICAgICAgIHRyYWNrSXRlbURldGFpbHNNYXA6IHIudHJhY2tJdGVtRGV0YWlsc01hcCxcbiAgICAgICAgc3RydWN0dXJlOiByLnN0cnVjdHVyZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdW5kbygpIHtcbiAgICBjb25zdCBlID0gdGhpcy51bmRvcy5wb3AoKSwgciA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudW5kb3MsIHMgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLnR5cGU7XG4gICAgaWYgKCFyIHx8ICFzKSByZXR1cm47XG4gICAgWm4oKTtcbiAgICBjb25zdCB7XG4gICAgICB0cmFja0l0ZW1EZXRhaWxzTWFwOiBhLFxuICAgICAgdHJhY2tJdGVtSWRzOiBjLFxuICAgICAgdHJhY2tzOiBkLFxuICAgICAgdHJhbnNpdGlvbklkczogZixcbiAgICAgIHRyYW5zaXRpb25zTWFwOiBiLFxuICAgICAgdHJhY2tJdGVtc01hcDogXyxcbiAgICAgIHN0cnVjdHVyZTogTVxuICAgIH0gPSB0aGlzLmdldFN0YXRlKCksIEUgPSBLKHtcbiAgICAgIHRyYWNrSXRlbURldGFpbHNNYXA6IGEsXG4gICAgICB0cmFja0l0ZW1JZHM6IGMsXG4gICAgICB0cmFja3M6IGQsXG4gICAgICB0cmFuc2l0aW9uSWRzOiBmLFxuICAgICAgdHJhbnNpdGlvbnNNYXA6IGIsXG4gICAgICB0cmFja0l0ZW1zTWFwOiBfLFxuICAgICAgc3RydWN0dXJlOiBNXG4gICAgfSksIG0gPSBbXSwgVCA9IFtdLCBDID0gW10sIHUgPSBbXSwgbCA9IFtdLCBTID0gW10sIHcgPSBbXTtcbiAgICByLmZvckVhY2goKFIpID0+IHtcbiAgICAgIGxldCBGO1xuICAgICAgY29uc3QgViA9IFIucGF0aC5zbGljZSgxKTtcbiAgICAgIFIudHlwZSA9PT0gXCJDUkVBVEVcIiA/IEYgPSB7XG4gICAgICAgIHBhdGg6IFYsXG4gICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICB2YWx1ZTogUi52YWx1ZVxuICAgICAgfSA6IFIudHlwZSA9PT0gXCJDSEFOR0VcIiA/IEYgPSB7XG4gICAgICAgIHBhdGg6IFYsXG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgdmFsdWU6IFIub2xkVmFsdWVcbiAgICAgIH0gOiBGID0ge1xuICAgICAgICBwYXRoOiBWLFxuICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgdmFsdWU6IFIub2xkVmFsdWVcbiAgICAgIH0sIFIucGF0aC5pbmNsdWRlcyhcInRyYWNrSXRlbUlkc1wiKSA/IEMucHVzaChGKSA6IFIucGF0aC5pbmNsdWRlcyhcInRyYW5zaXRpb25JZHNcIikgPyBULnB1c2goRikgOiBSLnBhdGguaW5jbHVkZXMoXCJ0cmFja0l0ZW1zTWFwXCIpID8gbC5wdXNoKEYpIDogUi5wYXRoLmluY2x1ZGVzKFwidHJhbnNpdGlvbnNNYXBcIikgPyB1LnB1c2goRikgOiBSLnBhdGguaW5jbHVkZXMoXCJ0cmFja3NcIikgPyBtLnB1c2goRikgOiBSLnBhdGguaW5jbHVkZXMoXCJ0cmFja0l0ZW1EZXRhaWxzTWFwXCIpID8gUy5wdXNoKEYpIDogUi5wYXRoLmluY2x1ZGVzKFwic3RydWN0dXJlXCIpICYmIHcucHVzaChGKTtcbiAgICB9KTtcbiAgICBjb25zdCBrID0gdGhpcy5hcHBseVBhdGNoKFxuICAgICAgRS50cmFja3MsXG4gICAgICBtXG4gICAgKSwgaCA9IHRoaXMuYXBwbHlQYXRjaChcbiAgICAgIEUudHJhbnNpdGlvbklkcyxcbiAgICAgIFRcbiAgICApLCB5ID0gdGhpcy5hcHBseVBhdGNoKFxuICAgICAgRS50cmFja0l0ZW1JZHMsXG4gICAgICBDXG4gICAgKSwgdiA9IHRoaXMuYXBwbHlQYXRjaChcbiAgICAgIEUudHJhbnNpdGlvbnNNYXAsXG4gICAgICB1XG4gICAgKSwgSSA9IHRoaXMuYXBwbHlQYXRjaChcbiAgICAgIEUudHJhY2tJdGVtc01hcCxcbiAgICAgIGxcbiAgICApLCB4ID0gdGhpcy5hcHBseVBhdGNoKFxuICAgICAgRS50cmFja0l0ZW1EZXRhaWxzTWFwLFxuICAgICAgU1xuICAgICksIGcgPSB0aGlzLmFwcGx5UGF0Y2goXG4gICAgICBFLnN0cnVjdHVyZSxcbiAgICAgIHdcbiAgICApLCBPID0gSyh7XG4gICAgICB0cmFja3M6IGssXG4gICAgICB0cmFuc2l0aW9uSWRzOiBoLFxuICAgICAgdHJhY2tJdGVtSWRzOiB5LFxuICAgICAgdHJhbnNpdGlvbnNNYXA6IHYsXG4gICAgICB0cmFja0l0ZW1zTWFwOiBJLFxuICAgICAgdHJhY2tJdGVtRGV0YWlsc01hcDogeCxcbiAgICAgIHN0cnVjdHVyZTogZ1xuICAgIH0pLCBEID0gSyh0aGlzLmdldFN0YXRlKCkpLCBqID0geyAuLi5ELCAuLi5PIH07XG4gICAgdGhpcy5wcmV2U3RhdGUgPSBELCB0aGlzLnJlZG9zLnB1c2goeyByZWRvczogciwgdHlwZTogcyB9KTtcbiAgICBjb25zdCBMID0gaGUoai50cmFja0l0ZW1zTWFwKTtcbiAgICB0aGlzLnN0YXRlU3ViamVjdC5uZXh0KHsgLi4uaiwgZHVyYXRpb246IEwgfSksIHRoaXMuc3RhdGVIaXN0b3J5U3ViamVjdC5uZXh0KHsgaGFuZGxlUmVkbzogITEsIGhhbmRsZVVuZG86ICEwIH0pLCB0aGlzLnVwZGF0ZVN0YXRlKGosIHsgdXBkYXRlSGlzdG9yeTogITEgfSk7XG4gIH1cbiAgYXBwbHlQYXRjaChlLCByKSB7XG4gICAgcmV0dXJuIHIucmV2ZXJzZSgpLnJlZHVjZSgocywgYSkgPT4gQmkocywgKGMpID0+IHtcbiAgICAgIFhpKGMsIFthXSk7XG4gICAgfSksIGUpO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgY29uc3QgZSA9IHRoaXMucmVkb3MucG9wKCksIHIgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLnJlZG9zLCBzID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS50eXBlO1xuICAgIGlmICghciB8fCAhcykgcmV0dXJuO1xuICAgIFpuKCk7XG4gICAgY29uc3Qge1xuICAgICAgdHJhY2tJdGVtRGV0YWlsc01hcDogYSxcbiAgICAgIHRyYWNrSXRlbUlkczogYyxcbiAgICAgIHRyYWNrczogZCxcbiAgICAgIHRyYW5zaXRpb25JZHM6IGYsXG4gICAgICB0cmFuc2l0aW9uc01hcDogYixcbiAgICAgIHRyYWNrSXRlbXNNYXA6IF8sXG4gICAgICBzdHJ1Y3R1cmU6IE1cbiAgICB9ID0gdGhpcy5nZXRTdGF0ZSgpLCBFID0gSyh7XG4gICAgICB0cmFja0l0ZW1EZXRhaWxzTWFwOiBhLFxuICAgICAgdHJhY2tJdGVtSWRzOiBjLFxuICAgICAgdHJhY2tzOiBkLFxuICAgICAgdHJhbnNpdGlvbklkczogZixcbiAgICAgIHRyYW5zaXRpb25zTWFwOiBiLFxuICAgICAgdHJhY2tJdGVtc01hcDogXyxcbiAgICAgIHN0cnVjdHVyZTogTVxuICAgIH0pLCBtID0gW10sIFQgPSBbXSwgQyA9IFtdLCB1ID0gW10sIGwgPSBbXSwgUyA9IFtdLCB3ID0gW107XG4gICAgci5mb3JFYWNoKChSKSA9PiB7XG4gICAgICBsZXQgRjtcbiAgICAgIGNvbnN0IFYgPSBSLnBhdGguc2xpY2UoMSk7XG4gICAgICBSLnR5cGUgPT09IFwiQ1JFQVRFXCIgPyBGID0ge1xuICAgICAgICBwYXRoOiBWLFxuICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgdmFsdWU6IFIudmFsdWVcbiAgICAgIH0gOiBSLnR5cGUgPT09IFwiQ0hBTkdFXCIgPyBGID0ge1xuICAgICAgICBwYXRoOiBWLFxuICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgIHZhbHVlOiBSLnZhbHVlXG4gICAgICB9IDogRiA9IHtcbiAgICAgICAgcGF0aDogVixcbiAgICAgICAgb3A6IFwicmVtb3ZlXCIsXG4gICAgICAgIHZhbHVlOiBSLm9sZFZhbHVlXG4gICAgICB9LCBSLnBhdGguaW5jbHVkZXMoXCJ0cmFja0l0ZW1JZHNcIikgPyBDLnB1c2goRikgOiBSLnBhdGguaW5jbHVkZXMoXCJ0cmFuc2l0aW9uSWRzXCIpID8gVC5wdXNoKEYpIDogUi5wYXRoLmluY2x1ZGVzKFwidHJhY2tJdGVtc01hcFwiKSA/IGwucHVzaChGKSA6IFIucGF0aC5pbmNsdWRlcyhcInRyYW5zaXRpb25zTWFwXCIpID8gdS5wdXNoKEYpIDogUi5wYXRoLmluY2x1ZGVzKFwidHJhY2tJdGVtRGV0YWlsc01hcFwiKSA/IFMucHVzaChGKSA6IFIucGF0aC5pbmNsdWRlcyhcInN0cnVjdHVyZVwiKSA/IHcucHVzaChGKSA6IG0ucHVzaChGKTtcbiAgICB9KTtcbiAgICBjb25zdCBrID0gdGhpcy5hcHBseVBhdGNoKFxuICAgICAgRS50cmFja3MsXG4gICAgICBtXG4gICAgKSwgaCA9IHRoaXMuYXBwbHlQYXRjaChcbiAgICAgIEUudHJhbnNpdGlvbklkcyxcbiAgICAgIFRcbiAgICApLCB5ID0gdGhpcy5hcHBseVBhdGNoKFxuICAgICAgRS50cmFja0l0ZW1JZHMsXG4gICAgICBDXG4gICAgKSwgdiA9IHRoaXMuYXBwbHlQYXRjaChcbiAgICAgIEUudHJhbnNpdGlvbnNNYXAsXG4gICAgICB1XG4gICAgKSwgSSA9IHRoaXMuYXBwbHlQYXRjaChcbiAgICAgIEUudHJhY2tJdGVtc01hcCxcbiAgICAgIGxcbiAgICApLCB4ID0gdGhpcy5hcHBseVBhdGNoKFxuICAgICAgRS50cmFja0l0ZW1EZXRhaWxzTWFwLFxuICAgICAgU1xuICAgICksIGcgPSB0aGlzLmFwcGx5UGF0Y2goXG4gICAgICBFLnN0cnVjdHVyZSxcbiAgICAgIHdcbiAgICApLCBPID0gSyh7XG4gICAgICB0cmFja3M6IGssXG4gICAgICB0cmFuc2l0aW9uSWRzOiBoLFxuICAgICAgdHJhY2tJdGVtSWRzOiB5LFxuICAgICAgdHJhbnNpdGlvbnNNYXA6IHYsXG4gICAgICB0cmFja0l0ZW1zTWFwOiBJLFxuICAgICAgdHJhY2tJdGVtRGV0YWlsc01hcDogeCxcbiAgICAgIHN0cnVjdHVyZTogZ1xuICAgIH0pLCBEID0gSyh0aGlzLmdldFN0YXRlKCkpLCBqID0geyAuLi5ELCAuLi5PIH07XG4gICAgdGhpcy5wcmV2U3RhdGUgPSBELCB0aGlzLnVuZG9zLnB1c2goeyB1bmRvczogciwgdHlwZTogcyB9KTtcbiAgICBjb25zdCBMID0gaGUoai50cmFja0l0ZW1zTWFwKTtcbiAgICB0aGlzLnN0YXRlU3ViamVjdC5uZXh0KHsgLi4uaiwgZHVyYXRpb246IEwgfSksIHRoaXMuc3RhdGVIaXN0b3J5U3ViamVjdC5uZXh0KHsgaGFuZGxlUmVkbzogITAsIGhhbmRsZVVuZG86ICExIH0pLCB0aGlzLnVwZGF0ZVN0YXRlKGosIHsgdXBkYXRlSGlzdG9yeTogITEgfSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZwczogZSxcbiAgICAgIHRyYWNrczogcixcbiAgICAgIHNpemU6IHMsXG4gICAgICB0cmFja0l0ZW1EZXRhaWxzTWFwOiBhLFxuICAgICAgdHJhY2tJdGVtSWRzOiBjLFxuICAgICAgdHJhbnNpdGlvbnNNYXA6IGQsXG4gICAgICB0cmFja0l0ZW1zTWFwOiBmLFxuICAgICAgdHJhbnNpdGlvbklkczogYlxuICAgIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZwczogZSxcbiAgICAgIHRyYWNrczogcixcbiAgICAgIHNpemU6IHMsXG4gICAgICB0cmFja0l0ZW1EZXRhaWxzTWFwOiBhLFxuICAgICAgdHJhY2tJdGVtSWRzOiBjLFxuICAgICAgdHJhbnNpdGlvbnNNYXA6IGQsXG4gICAgICB0cmFja0l0ZW1zTWFwOiBmLFxuICAgICAgdHJhbnNpdGlvbklkczogYlxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB7XG4gIHVpIGFzIEFDVElWRV9DTE9ORSxcbiAgTGEgYXMgQUNUSVZFX0RFTEVURSxcbiAgY2kgYXMgQUNUSVZFX1BBU1RFLFxuICBDZSBhcyBBQ1RJVkVfUFJFRklYLFxuICBIYSBhcyBBQ1RJVkVfU0VULFxuICBsaSBhcyBBQ1RJVkVfU1BMSVQsXG4gIGVpIGFzIEFERF9BTklNQVRJT04sXG4gIEpzIGFzIEFERF9BVURJTyxcbiAgcmkgYXMgQUREX0NBUFRJT05TLFxuICBpaSBhcyBBRERfQ09NUE9TSVRJT04sXG4gIFFzIGFzIEFERF9JTExVU1RSQVRJT04sXG4gIFpzIGFzIEFERF9JTUFHRSxcbiAgc2kgYXMgQUREX0lURU1TLFxuICBQYSBhcyBBRERfTUFTSyxcbiAgQ2EgYXMgQUREX1BMQUNFSE9MREVSLFxuICBndCBhcyBBRERfUFJFRklYLFxuICB0aSBhcyBBRERfU0hBUEUsXG4gIEFhIGFzIEFERF9TVUZGSVgsXG4gIG5pIGFzIEFERF9URU1QTEFURSxcbiAgVnMgYXMgQUREX1RFWFQsXG4gIFJhIGFzIEFERF9UUkFOU0lUSU9OLFxuICBxcyBhcyBBRERfVklERU8sXG4gIE5hIGFzIERFTEVURV9URU1QTEFURV9JVEVNLFxuICBYcyBhcyBERVNJR05fTE9BRCxcbiAgRG4gYXMgREVTSUdOX1BSRUZJWCxcbiAgS3MgYXMgREVTSUdOX1JFU0laRSxcbiAgYWkgYXMgRURJVF9PQkpFQ1QsXG4gIGJlIGFzIEVESVRfUFJFRklYLFxuICBGYSBhcyBFRElUX1NIQVBFLFxuICAkYSBhcyBFRElUX1RFTVBMQVRFX0lURU0sXG4gIHphIGFzIEVESVRfVEVYVCxcbiAgamEgYXMgRU5URVJfRURJVF9NT0RFLFxuICBTciBhcyBISVNUT1JZX1BSRUZJWCxcbiAgbWkgYXMgSElTVE9SWV9SRURPLFxuICB0byBhcyBISVNUT1JZX1JFU0VULFxuICBoaSBhcyBISVNUT1JZX1VORE8sXG4gIGRpIGFzIExBWUVSX0NMT05FLFxuICBxYSBhcyBMQVlFUl9DT1BZLFxuICBRYSBhcyBMQVlFUl9DVVQsXG4gIGZpIGFzIExBWUVSX0RFTEVURSxcbiAgVmEgYXMgTEFZRVJfRURJVElOR19OQU1FLFxuICBXYSBhcyBMQVlFUl9ISURERU4sXG4gIFVhIGFzIExBWUVSX0xPQ0tFRCxcbiAgR2EgYXMgTEFZRVJfTU9WRSxcbiAgSmEgYXMgTEFZRVJfUEFTVEUsXG4gIHB0IGFzIExBWUVSX1BSRUZJWCxcbiAgS2EgYXMgTEFZRVJfUkVOQU1FLFxuICBwaSBhcyBMQVlFUl9SRVBMQUNFLFxuICBZYSBhcyBMQVlFUl9TRUxFQ1QsXG4gIEJhIGFzIExBWUVSX1NFTEVDVElPTixcbiAgWGEgYXMgTEFZRVJfU0VORF9UTyxcbiAgWmEgYXMgTEFZRVJfU1BMSVQsXG4gIG9pIGFzIFJFUExBQ0VfTUVESUEsXG4gIE9hIGFzIFNUQVRFX0NIQU5HRUQsXG4gIEJzIGFzIFNUQVRFX1BSRUZJWCxcbiAgeWkgYXMgVElNRUxJTkVfU0NBTEVfQ0hBTkdFRCxcbiAgdXMgYXMgVElNRUxJTkVfU0NBTEVfUFJFRklYLFxuICB4YSBhcyBUUkFDS1NfQ0hBTkdFRCxcbiAgRGEgYXMgVFJBQ0tfSVRFTVNfQ0hBTkdFRCxcbiAgWXMgYXMgVFJBQ0tfSVRFTVNfUFJFRklYLFxuICBHcyBhcyBUUkFDS19QUkVGSVgsXG4gIGVvIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@designcombo/state/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@designcombo/timeline/dist/index.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/@designcombo/timeline/dist/index.es.js ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACCEPTS_MAP: () => (/* binding */ H0),\n/* harmony export */   Audio: () => (/* binding */ ft),\n/* harmony export */   BOTTOM: () => (/* binding */ tb),\n/* harmony export */   CENTER: () => (/* binding */ He),\n/* harmony export */   Caption: () => (/* binding */ sr),\n/* harmony export */   Control: () => (/* binding */ U),\n/* harmony export */   DRAG_END: () => (/* binding */ ih),\n/* harmony export */   DRAG_PREFIX: () => (/* binding */ rh),\n/* harmony export */   DRAG_START: () => (/* binding */ g0),\n/* harmony export */   FabricObject: () => (/* binding */ nt),\n/* harmony export */   Helper: () => (/* binding */ Ss),\n/* harmony export */   Image: () => (/* binding */ Qs),\n/* harmony export */   LEFT: () => (/* binding */ ur),\n/* harmony export */   NONE: () => (/* binding */ eb),\n/* harmony export */   Pattern: () => (/* binding */ Yi),\n/* harmony export */   Placeholder: () => (/* binding */ er),\n/* harmony export */   PreviewTrackItem: () => (/* binding */ Oe),\n/* harmony export */   RIGHT: () => (/* binding */ dr),\n/* harmony export */   Rect: () => (/* binding */ X),\n/* harmony export */   SIZES_MAP: () => (/* binding */ Y0),\n/* harmony export */   TIMELINE_BOUNDING_CHANGED: () => (/* binding */ p0),\n/* harmony export */   TIMELINE_PREFIX: () => (/* binding */ nh),\n/* harmony export */   TIMELINE_SEEK: () => (/* binding */ m0),\n/* harmony export */   TOP: () => (/* binding */ Q0),\n/* harmony export */   Template: () => (/* binding */ Vt),\n/* harmony export */   Text: () => (/* binding */ tr),\n/* harmony export */   Track: () => (/* binding */ ue),\n/* harmony export */   Transition: () => (/* binding */ Jt),\n/* harmony export */   Video: () => (/* binding */ _t),\n/* harmony export */   calculateTimelineWidth: () => (/* binding */ sb),\n/* harmony export */   changeWidth: () => (/* binding */ Sn),\n/* harmony export */   classRegistry: () => (/* binding */ C),\n/* harmony export */   controlsUtils: () => (/* binding */ Ds),\n/* harmony export */   createAudioControls: () => (/* binding */ pf),\n/* harmony export */   createMediaControls: () => (/* binding */ mf),\n/* harmony export */   createResizeControls: () => (/* binding */ js),\n/* harmony export */   createTemplateControls: () => (/* binding */ gf),\n/* harmony export */   createTransitionControls: () => (/* binding */ ml),\n/* harmony export */   \"default\": () => (/* binding */ K0),\n/* harmony export */   drawVerticalLine: () => (/* binding */ qt),\n/* harmony export */   generateId: () => (/* binding */ Ws),\n/* harmony export */   getDuration: () => (/* binding */ pl),\n/* harmony export */   isTransformCentered: () => (/* binding */ fr),\n/* harmony export */   resize: () => (/* binding */ rb),\n/* harmony export */   resolveOrigin: () => (/* binding */ P),\n/* harmony export */   timeMsToUnits: () => (/* binding */ D),\n/* harmony export */   unitsToTimeMs: () => (/* binding */ Y),\n/* harmony export */   util: () => (/* binding */ sd),\n/* harmony export */   wrapWithFixedAnchor: () => (/* binding */ Mi)\n/* harmony export */ });\n/* harmony import */ var _designcombo_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @designcombo/events */ \"(ssr)/./node_modules/@designcombo/events/dist/index.es.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\nvar Fh = Object.defineProperty;\nvar Rh = (i, t, e) => t in i ? Fh(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;\nvar T = (i, t, e) => Rh(i, typeof t != \"symbol\" ? t + \"\" : t, e);\n\nfunction y(i, t, e) {\n  return (t = function(s) {\n    var r = function(n, o) {\n      if (typeof n != \"object\" || !n) return n;\n      var a = n[Symbol.toPrimitive];\n      if (a !== void 0) {\n        var c = a.call(n, o);\n        if (typeof c != \"object\") return c;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return (o === \"string\" ? String : Number)(n);\n    }(s, \"string\");\n    return typeof r == \"symbol\" ? r : r + \"\";\n  }(t)) in i ? Object.defineProperty(i, t, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : i[t] = e, i;\n}\nfunction fo(i, t) {\n  var e = Object.keys(i);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(i);\n    t && (s = s.filter(function(r) {\n      return Object.getOwnPropertyDescriptor(i, r).enumerable;\n    })), e.push.apply(e, s);\n  }\n  return e;\n}\nfunction v(i) {\n  for (var t = 1; t < arguments.length; t++) {\n    var e = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? fo(Object(e), !0).forEach(function(s) {\n      y(i, s, e[s]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : fo(Object(e)).forEach(function(s) {\n      Object.defineProperty(i, s, Object.getOwnPropertyDescriptor(e, s));\n    });\n  }\n  return i;\n}\nfunction G(i, t) {\n  if (i == null) return {};\n  var e, s, r = function(o, a) {\n    if (o == null) return {};\n    var c = {};\n    for (var l in o) if ({}.hasOwnProperty.call(o, l)) {\n      if (a.indexOf(l) >= 0) continue;\n      c[l] = o[l];\n    }\n    return c;\n  }(i, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(i);\n    for (s = 0; s < n.length; s++) e = n[s], t.indexOf(e) >= 0 || {}.propertyIsEnumerable.call(i, e) && (r[e] = i[e]);\n  }\n  return r;\n}\nfunction Me(i, t) {\n  return t || (t = i.slice(0)), Object.freeze(Object.defineProperties(i, { raw: { value: Object.freeze(t) } }));\n}\nclass go {\n  constructor() {\n    y(this, \"browserShadowBlurConstant\", 1), y(this, \"DPI\", 96), y(this, \"devicePixelRatio\", typeof window < \"u\" ? window.devicePixelRatio : 1), y(this, \"perfLimitSizeTotal\", 2097152), y(this, \"maxCacheSideLimit\", 4096), y(this, \"minCacheSideLimit\", 256), y(this, \"disableStyleCopyPaste\", !1), y(this, \"enableGLFiltering\", !0), y(this, \"textureSize\", 4096), y(this, \"forceGLPutImageData\", !1), y(this, \"cachesBoundsOfCurve\", !1), y(this, \"fontPaths\", {}), y(this, \"NUM_FRACTION_DIGITS\", 4);\n  }\n}\nconst A = new class extends go {\n  constructor(i) {\n    super(), this.configure(i);\n  }\n  configure() {\n    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    Object.assign(this, i);\n  }\n  addFonts() {\n    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.fontPaths = v(v({}, this.fontPaths), i);\n  }\n  removeFonts() {\n    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((i) => {\n      delete this.fontPaths[i];\n    });\n  }\n  clearFonts() {\n    this.fontPaths = {};\n  }\n  restoreDefaults(i) {\n    const t = new go(), e = (i == null ? void 0 : i.reduce((s, r) => (s[r] = t[r], s), {})) || t;\n    this.configure(e);\n  }\n}(), Te = function(i) {\n  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) e[s - 1] = arguments[s];\n  return console[i](\"fabric\", ...e);\n};\nclass Yt extends Error {\n  constructor(t, e) {\n    super(\"fabric: \".concat(t), e);\n  }\n}\nclass Fa extends Yt {\n  constructor(t) {\n    super(\"\".concat(t, \" 'options.signal' is in 'aborted' state\"));\n  }\n}\nclass Lh {\n}\nclass Bh extends Lh {\n  testPrecision(t, e) {\n    const s = \"precision \".concat(e, ` float;\nvoid main(){}`), r = t.createShader(t.FRAGMENT_SHADER);\n    return !!r && (t.shaderSource(r, s), t.compileShader(r), !!t.getShaderParameter(r, t.COMPILE_STATUS));\n  }\n  queryWebGL(t) {\n    const e = t.getContext(\"webgl\");\n    e && (this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.GLPrecision = [\"highp\", \"mediump\", \"lowp\"].find((s) => this.testPrecision(e, s)), e.getExtension(\"WEBGL_lose_context\").loseContext(), Te(\"log\", \"WebGL: max texture size \".concat(this.maxTextureSize)));\n  }\n  isSupported(t) {\n    return !!this.maxTextureSize && this.maxTextureSize >= t;\n  }\n}\nconst Wh = {};\nlet po;\nconst $t = () => po || (po = { document, window, isTouchSupported: \"ontouchstart\" in window || \"ontouchstart\" in document || window && window.navigator && window.navigator.maxTouchPoints > 0, WebGLProbe: new Bh(), dispose() {\n}, copyPasteData: Wh }), Cs = () => $t().document, fi = () => $t().window, Ra = () => {\n  var i;\n  return Math.max((i = A.devicePixelRatio) !== null && i !== void 0 ? i : fi().devicePixelRatio, 1);\n}, zs = new class {\n  constructor() {\n    y(this, \"charWidthsCache\", {}), y(this, \"boundsOfCurveCache\", {});\n  }\n  getFontCache(i) {\n    let { fontFamily: t, fontStyle: e, fontWeight: s } = i;\n    t = t.toLowerCase(), this.charWidthsCache[t] || (this.charWidthsCache[t] = {});\n    const r = this.charWidthsCache[t], n = \"\".concat(e.toLowerCase(), \"_\").concat((s + \"\").toLowerCase());\n    return r[n] || (r[n] = {}), r[n];\n  }\n  clearFontCache(i) {\n    (i = (i || \"\").toLowerCase()) ? this.charWidthsCache[i] && delete this.charWidthsCache[i] : this.charWidthsCache = {};\n  }\n  limitDimsByArea(i) {\n    const { perfLimitSizeTotal: t } = A, e = Math.sqrt(t * i);\n    return [Math.floor(e), Math.floor(t / e)];\n  }\n}(), sn = \"6.6.1\";\nfunction Be() {\n}\nconst xe = Math.PI / 2, he = 2 * Math.PI, jn = Math.PI / 180, ht = Object.freeze([1, 0, 0, 1, 0, 0]), En = 16, ye = 0.4477152502, j = \"center\", L = \"left\", gt = \"top\", rn = \"bottom\", Z = \"right\", pt = \"none\", Pn = /\\r?\\n/, La = \"moving\", gi = \"scaling\", Ba = \"rotating\", An = \"rotate\", Wa = \"skewing\", $s = \"resizing\", Xa = \"modifyPoly\", Xh = \"modifyPath\", Ur = \"changed\", pi = \"scale\", ut = \"scaleX\", Tt = \"scaleY\", Os = \"skewX\", ks = \"skewY\", rt = \"fill\", mt = \"stroke\", $r = \"modified\", qe = \"json\", Ri = \"svg\", C = new class {\n  constructor() {\n    this[qe] = /* @__PURE__ */ new Map(), this[Ri] = /* @__PURE__ */ new Map();\n  }\n  has(i) {\n    return this[qe].has(i);\n  }\n  getClass(i) {\n    const t = this[qe].get(i);\n    if (!t) throw new Yt(\"No class registered for \".concat(i));\n    return t;\n  }\n  setClass(i, t) {\n    t ? this[qe].set(t, i) : (this[qe].set(i.type, i), this[qe].set(i.type.toLowerCase(), i));\n  }\n  getSVGClass(i) {\n    return this[Ri].get(i);\n  }\n  setSVGClass(i, t) {\n    this[Ri].set(t ?? i.type.toLowerCase(), i);\n  }\n}(), qr = new class extends Array {\n  remove(i) {\n    const t = this.indexOf(i);\n    t > -1 && this.splice(t, 1);\n  }\n  cancelAll() {\n    const i = this.splice(0);\n    return i.forEach((t) => t.abort()), i;\n  }\n  cancelByCanvas(i) {\n    if (!i) return [];\n    const t = this.filter((e) => {\n      var s;\n      return e.target === i || typeof e.target == \"object\" && ((s = e.target) === null || s === void 0 ? void 0 : s.canvas) === i;\n    });\n    return t.forEach((e) => e.abort()), t;\n  }\n  cancelByTarget(i) {\n    if (!i) return [];\n    const t = this.filter((e) => e.target === i);\n    return t.forEach((e) => e.abort()), t;\n  }\n}();\nclass zh {\n  constructor() {\n    y(this, \"__eventListeners\", {});\n  }\n  on(t, e) {\n    if (this.__eventListeners || (this.__eventListeners = {}), typeof t == \"object\") return Object.entries(t).forEach((s) => {\n      let [r, n] = s;\n      this.on(r, n);\n    }), () => this.off(t);\n    if (e) {\n      const s = t;\n      return this.__eventListeners[s] || (this.__eventListeners[s] = []), this.__eventListeners[s].push(e), () => this.off(s, e);\n    }\n    return () => !1;\n  }\n  once(t, e) {\n    if (typeof t == \"object\") {\n      const s = [];\n      return Object.entries(t).forEach((r) => {\n        let [n, o] = r;\n        s.push(this.once(n, o));\n      }), () => s.forEach((r) => r());\n    }\n    if (e) {\n      const s = this.on(t, function() {\n        for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++) n[o] = arguments[o];\n        e.call(this, ...n), s();\n      });\n      return s;\n    }\n    return () => !1;\n  }\n  _removeEventListener(t, e) {\n    if (this.__eventListeners[t]) if (e) {\n      const s = this.__eventListeners[t], r = s.indexOf(e);\n      r > -1 && s.splice(r, 1);\n    } else this.__eventListeners[t] = [];\n  }\n  off(t, e) {\n    if (this.__eventListeners) if (t === void 0) for (const s in this.__eventListeners) this._removeEventListener(s);\n    else typeof t == \"object\" ? Object.entries(t).forEach((s) => {\n      let [r, n] = s;\n      this._removeEventListener(r, n);\n    }) : this._removeEventListener(t, e);\n  }\n  fire(t, e) {\n    var s;\n    if (!this.__eventListeners) return;\n    const r = (s = this.__eventListeners[t]) === null || s === void 0 ? void 0 : s.concat();\n    if (r) for (let n = 0; n < r.length; n++) r[n].call(this, e || {});\n  }\n}\nconst Ee = (i, t) => {\n  const e = i.indexOf(t);\n  return e !== -1 && i.splice(e, 1), i;\n}, Lt = (i) => {\n  if (i === 0) return 1;\n  switch (Math.abs(i) / xe) {\n    case 1:\n    case 3:\n      return 0;\n    case 2:\n      return -1;\n  }\n  return Math.cos(i);\n}, Bt = (i) => {\n  if (i === 0) return 0;\n  const t = i / xe, e = Math.sign(i);\n  switch (t) {\n    case 1:\n      return e;\n    case 2:\n      return 0;\n    case 3:\n      return -e;\n  }\n  return Math.sin(i);\n};\nclass _ {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    typeof t == \"object\" ? (this.x = t.x, this.y = t.y) : (this.x = t, this.y = e);\n  }\n  add(t) {\n    return new _(this.x + t.x, this.y + t.y);\n  }\n  addEquals(t) {\n    return this.x += t.x, this.y += t.y, this;\n  }\n  scalarAdd(t) {\n    return new _(this.x + t, this.y + t);\n  }\n  scalarAddEquals(t) {\n    return this.x += t, this.y += t, this;\n  }\n  subtract(t) {\n    return new _(this.x - t.x, this.y - t.y);\n  }\n  subtractEquals(t) {\n    return this.x -= t.x, this.y -= t.y, this;\n  }\n  scalarSubtract(t) {\n    return new _(this.x - t, this.y - t);\n  }\n  scalarSubtractEquals(t) {\n    return this.x -= t, this.y -= t, this;\n  }\n  multiply(t) {\n    return new _(this.x * t.x, this.y * t.y);\n  }\n  scalarMultiply(t) {\n    return new _(this.x * t, this.y * t);\n  }\n  scalarMultiplyEquals(t) {\n    return this.x *= t, this.y *= t, this;\n  }\n  divide(t) {\n    return new _(this.x / t.x, this.y / t.y);\n  }\n  scalarDivide(t) {\n    return new _(this.x / t, this.y / t);\n  }\n  scalarDivideEquals(t) {\n    return this.x /= t, this.y /= t, this;\n  }\n  eq(t) {\n    return this.x === t.x && this.y === t.y;\n  }\n  lt(t) {\n    return this.x < t.x && this.y < t.y;\n  }\n  lte(t) {\n    return this.x <= t.x && this.y <= t.y;\n  }\n  gt(t) {\n    return this.x > t.x && this.y > t.y;\n  }\n  gte(t) {\n    return this.x >= t.x && this.y >= t.y;\n  }\n  lerp(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;\n    return e = Math.max(Math.min(1, e), 0), new _(this.x + (t.x - this.x) * e, this.y + (t.y - this.y) * e);\n  }\n  distanceFrom(t) {\n    const e = this.x - t.x, s = this.y - t.y;\n    return Math.sqrt(e * e + s * s);\n  }\n  midPointFrom(t) {\n    return this.lerp(t);\n  }\n  min(t) {\n    return new _(Math.min(this.x, t.x), Math.min(this.y, t.y));\n  }\n  max(t) {\n    return new _(Math.max(this.x, t.x), Math.max(this.y, t.y));\n  }\n  toString() {\n    return \"\".concat(this.x, \",\").concat(this.y);\n  }\n  setXY(t, e) {\n    return this.x = t, this.y = e, this;\n  }\n  setX(t) {\n    return this.x = t, this;\n  }\n  setY(t) {\n    return this.y = t, this;\n  }\n  setFromPoint(t) {\n    return this.x = t.x, this.y = t.y, this;\n  }\n  swap(t) {\n    const e = this.x, s = this.y;\n    this.x = t.x, this.y = t.y, t.x = e, t.y = s;\n  }\n  clone() {\n    return new _(this.x, this.y);\n  }\n  rotate(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Fn;\n    const s = Bt(t), r = Lt(t), n = this.subtract(e);\n    return new _(n.x * r - n.y * s, n.x * s + n.y * r).add(e);\n  }\n  transform(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];\n    return new _(t[0] * this.x + t[2] * this.y + (e ? 0 : t[4]), t[1] * this.x + t[3] * this.y + (e ? 0 : t[5]));\n  }\n}\nconst Fn = new _(0, 0), Vr = (i) => !!i && Array.isArray(i._objects);\nfunction za(i) {\n  class t extends i {\n    constructor() {\n      super(...arguments), y(this, \"_objects\", []);\n    }\n    _onObjectAdded(s) {\n    }\n    _onObjectRemoved(s) {\n    }\n    _onStackOrderChanged(s) {\n    }\n    add() {\n      for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];\n      const o = this._objects.push(...r);\n      return r.forEach((a) => this._onObjectAdded(a)), o;\n    }\n    insertAt(s) {\n      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++) n[o - 1] = arguments[o];\n      return this._objects.splice(s, 0, ...n), n.forEach((a) => this._onObjectAdded(a)), this._objects.length;\n    }\n    remove() {\n      const s = this._objects, r = [];\n      for (var n = arguments.length, o = new Array(n), a = 0; a < n; a++) o[a] = arguments[a];\n      return o.forEach((c) => {\n        const l = s.indexOf(c);\n        l !== -1 && (s.splice(l, 1), r.push(c), this._onObjectRemoved(c));\n      }), r;\n    }\n    forEachObject(s) {\n      this.getObjects().forEach((r, n, o) => s(r, n, o));\n    }\n    getObjects() {\n      for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];\n      return r.length === 0 ? [...this._objects] : this._objects.filter((o) => o.isType(...r));\n    }\n    item(s) {\n      return this._objects[s];\n    }\n    isEmpty() {\n      return this._objects.length === 0;\n    }\n    size() {\n      return this._objects.length;\n    }\n    contains(s, r) {\n      return !!this._objects.includes(s) || !!r && this._objects.some((n) => n instanceof t && n.contains(s, !0));\n    }\n    complexity() {\n      return this._objects.reduce((s, r) => s += r.complexity ? r.complexity() : 0, 0);\n    }\n    sendObjectToBack(s) {\n      return !(!s || s === this._objects[0]) && (Ee(this._objects, s), this._objects.unshift(s), this._onStackOrderChanged(s), !0);\n    }\n    bringObjectToFront(s) {\n      return !(!s || s === this._objects[this._objects.length - 1]) && (Ee(this._objects, s), this._objects.push(s), this._onStackOrderChanged(s), !0);\n    }\n    sendObjectBackwards(s, r) {\n      if (!s) return !1;\n      const n = this._objects.indexOf(s);\n      if (n !== 0) {\n        const o = this.findNewLowerIndex(s, n, r);\n        return Ee(this._objects, s), this._objects.splice(o, 0, s), this._onStackOrderChanged(s), !0;\n      }\n      return !1;\n    }\n    bringObjectForward(s, r) {\n      if (!s) return !1;\n      const n = this._objects.indexOf(s);\n      if (n !== this._objects.length - 1) {\n        const o = this.findNewUpperIndex(s, n, r);\n        return Ee(this._objects, s), this._objects.splice(o, 0, s), this._onStackOrderChanged(s), !0;\n      }\n      return !1;\n    }\n    moveObjectTo(s, r) {\n      return s !== this._objects[r] && (Ee(this._objects, s), this._objects.splice(r, 0, s), this._onStackOrderChanged(s), !0);\n    }\n    findNewLowerIndex(s, r, n) {\n      let o;\n      if (n) {\n        o = r;\n        for (let a = r - 1; a >= 0; --a) if (s.isOverlapping(this._objects[a])) {\n          o = a;\n          break;\n        }\n      } else o = r - 1;\n      return o;\n    }\n    findNewUpperIndex(s, r, n) {\n      let o;\n      if (n) {\n        o = r;\n        for (let a = r + 1; a < this._objects.length; ++a) if (s.isOverlapping(this._objects[a])) {\n          o = a;\n          break;\n        }\n      } else o = r + 1;\n      return o;\n    }\n    collectObjects(s) {\n      let { left: r, top: n, width: o, height: a } = s, { includeIntersecting: c = !0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n      const l = [], h = new _(r, n), u = h.add(new _(o, a));\n      for (let d = this._objects.length - 1; d >= 0; d--) {\n        const f = this._objects[d];\n        f.selectable && f.visible && (c && f.intersectsWithRect(h, u) || f.isContainedWithinRect(h, u) || c && f.containsPoint(h) || c && f.containsPoint(u)) && l.push(f);\n      }\n      return l;\n    }\n  }\n  return t;\n}\nclass Ha extends zh {\n  _setOptions() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    for (const e in t) this.set(e, t[e]);\n  }\n  _setObject(t) {\n    for (const e in t) this._set(e, t[e]);\n  }\n  set(t, e) {\n    return typeof t == \"object\" ? this._setObject(t) : this._set(t, e), this;\n  }\n  _set(t, e) {\n    this[t] = e;\n  }\n  toggle(t) {\n    const e = this.get(t);\n    return typeof e == \"boolean\" && this.set(t, !e), this;\n  }\n  get(t) {\n    return this[t];\n  }\n}\nfunction Hs(i) {\n  return fi().requestAnimationFrame(i);\n}\nfunction Ya(i) {\n  return fi().cancelAnimationFrame(i);\n}\nlet Hh = 0;\nconst we = () => Hh++, kt = () => {\n  const i = Cs().createElement(\"canvas\");\n  if (!i || i.getContext === void 0) throw new Yt(\"Failed to create `canvas` element\");\n  return i;\n}, Va = () => Cs().createElement(\"img\"), Wt = (i) => {\n  const t = kt();\n  return t.width = i.width, t.height = i.height, t;\n}, Rn = (i, t, e) => i.toDataURL(\"image/\".concat(t), e), Ln = (i, t, e) => new Promise((s, r) => {\n  i.toBlob(s, \"image/\".concat(t), e);\n}), K = (i) => i * jn, Ce = (i) => i / jn, Ga = (i) => i.every((t, e) => t === ht[e]), ot = (i, t, e) => new _(i).transform(t, e), St = (i) => {\n  const t = 1 / (i[0] * i[3] - i[1] * i[2]), e = [t * i[3], -t * i[1], -t * i[2], t * i[0], 0, 0], { x: s, y: r } = new _(i[4], i[5]).transform(e, !0);\n  return e[4] = -s, e[5] = -r, e;\n}, J = (i, t, e) => [i[0] * t[0] + i[2] * t[1], i[1] * t[0] + i[3] * t[1], i[0] * t[2] + i[2] * t[3], i[1] * t[2] + i[3] * t[3], e ? 0 : i[0] * t[4] + i[2] * t[5] + i[4], e ? 0 : i[1] * t[4] + i[3] * t[5] + i[5]], mi = (i, t) => i.reduceRight((e, s) => s && e ? J(s, e, t) : s || e, void 0) || ht.concat(), Na = (i) => {\n  let [t, e] = i;\n  return Math.atan2(e, t);\n}, ys = (i) => {\n  const t = Na(i), e = Math.pow(i[0], 2) + Math.pow(i[1], 2), s = Math.sqrt(e), r = (i[0] * i[3] - i[2] * i[1]) / s, n = Math.atan2(i[0] * i[2] + i[1] * i[3], e);\n  return { angle: Ce(t), scaleX: s, scaleY: r, skewX: Ce(n), skewY: 0, translateX: i[4] || 0, translateY: i[5] || 0 };\n}, Ms = function(i) {\n  return [1, 0, 0, 1, i, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0];\n};\nfunction Is() {\n  let { angle: i = 0 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { x: t = 0, y: e = 0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const s = K(i), r = Lt(s), n = Bt(s);\n  return [r, n, -n, r, t ? t - (r * t - n * e) : 0, e ? e - (n * t + r * e) : 0];\n}\nconst vi = function(i) {\n  return [i, 0, 0, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : i, 0, 0];\n}, Ua = (i) => Math.tan(K(i)), Bn = (i) => [1, 0, Ua(i), 1, 0, 0], Wn = (i) => [1, Ua(i), 0, 1, 0, 0], ar = (i) => {\n  let { scaleX: t = 1, scaleY: e = 1, flipX: s = !1, flipY: r = !1, skewX: n = 0, skewY: o = 0 } = i, a = vi(s ? -t : t, r ? -e : e);\n  return n && (a = J(a, Bn(n), !0)), o && (a = J(a, Wn(o), !0)), a;\n}, $a = (i) => {\n  const { translateX: t = 0, translateY: e = 0, angle: s = 0 } = i;\n  let r = Ms(t, e);\n  s && (r = J(r, Is({ angle: s })));\n  const n = ar(i);\n  return Ga(n) || (r = J(r, n)), r;\n}, Ys = function(i) {\n  let { signal: t, crossOrigin: e = null } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return new Promise(function(s, r) {\n    if (t && t.aborted) return r(new Fa(\"loadImage\"));\n    const n = Va();\n    let o;\n    t && (o = function(c) {\n      n.src = \"\", r(c);\n    }, t.addEventListener(\"abort\", o, { once: !0 }));\n    const a = function() {\n      n.onload = n.onerror = null, o && (t == null || t.removeEventListener(\"abort\", o)), s(n);\n    };\n    i ? (n.onload = a, n.onerror = function() {\n      o && (t == null || t.removeEventListener(\"abort\", o)), r(new Yt(\"Error loading \".concat(n.src)));\n    }, e && (n.crossOrigin = e), n.src = i) : a();\n  });\n}, bs = function(i) {\n  let { signal: t, reviver: e = Be } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return new Promise((s, r) => {\n    const n = [];\n    t && t.addEventListener(\"abort\", r, { once: !0 }), Promise.all(i.map((o) => C.getClass(o.type).fromObject(o, { signal: t }).then((a) => (e(o, a), n.push(a), a)))).then(s).catch((o) => {\n      n.forEach((a) => {\n        a.dispose && a.dispose();\n      }), r(o);\n    }).finally(() => {\n      t && t.removeEventListener(\"abort\", r);\n    });\n  });\n}, cr = function(i) {\n  let { signal: t } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return new Promise((e, s) => {\n    const r = [];\n    t && t.addEventListener(\"abort\", s, { once: !0 });\n    const n = Object.values(i).map((a) => a && a.type && C.has(a.type) ? bs([a], { signal: t }).then((c) => {\n      let [l] = c;\n      return r.push(l), l;\n    }) : a), o = Object.keys(i);\n    Promise.all(n).then((a) => a.reduce((c, l, h) => (c[o[h]] = l, c), {})).then(e).catch((a) => {\n      r.forEach((c) => {\n        c.dispose && c.dispose();\n      }), s(a);\n    }).finally(() => {\n      t && t.removeEventListener(\"abort\", s);\n    });\n  });\n}, Ve = function(i) {\n  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []).reduce((t, e) => (e in i && (t[e] = i[e]), t), {});\n}, Xn = (i, t) => Object.keys(i).reduce((e, s) => (t(i[s], s, i) && (e[s] = i[s]), e), {}), mo = { aliceblue: \"#F0F8FF\", antiquewhite: \"#FAEBD7\", aqua: \"#0FF\", aquamarine: \"#7FFFD4\", azure: \"#F0FFFF\", beige: \"#F5F5DC\", bisque: \"#FFE4C4\", black: \"#000\", blanchedalmond: \"#FFEBCD\", blue: \"#00F\", blueviolet: \"#8A2BE2\", brown: \"#A52A2A\", burlywood: \"#DEB887\", cadetblue: \"#5F9EA0\", chartreuse: \"#7FFF00\", chocolate: \"#D2691E\", coral: \"#FF7F50\", cornflowerblue: \"#6495ED\", cornsilk: \"#FFF8DC\", crimson: \"#DC143C\", cyan: \"#0FF\", darkblue: \"#00008B\", darkcyan: \"#008B8B\", darkgoldenrod: \"#B8860B\", darkgray: \"#A9A9A9\", darkgrey: \"#A9A9A9\", darkgreen: \"#006400\", darkkhaki: \"#BDB76B\", darkmagenta: \"#8B008B\", darkolivegreen: \"#556B2F\", darkorange: \"#FF8C00\", darkorchid: \"#9932CC\", darkred: \"#8B0000\", darksalmon: \"#E9967A\", darkseagreen: \"#8FBC8F\", darkslateblue: \"#483D8B\", darkslategray: \"#2F4F4F\", darkslategrey: \"#2F4F4F\", darkturquoise: \"#00CED1\", darkviolet: \"#9400D3\", deeppink: \"#FF1493\", deepskyblue: \"#00BFFF\", dimgray: \"#696969\", dimgrey: \"#696969\", dodgerblue: \"#1E90FF\", firebrick: \"#B22222\", floralwhite: \"#FFFAF0\", forestgreen: \"#228B22\", fuchsia: \"#F0F\", gainsboro: \"#DCDCDC\", ghostwhite: \"#F8F8FF\", gold: \"#FFD700\", goldenrod: \"#DAA520\", gray: \"#808080\", grey: \"#808080\", green: \"#008000\", greenyellow: \"#ADFF2F\", honeydew: \"#F0FFF0\", hotpink: \"#FF69B4\", indianred: \"#CD5C5C\", indigo: \"#4B0082\", ivory: \"#FFFFF0\", khaki: \"#F0E68C\", lavender: \"#E6E6FA\", lavenderblush: \"#FFF0F5\", lawngreen: \"#7CFC00\", lemonchiffon: \"#FFFACD\", lightblue: \"#ADD8E6\", lightcoral: \"#F08080\", lightcyan: \"#E0FFFF\", lightgoldenrodyellow: \"#FAFAD2\", lightgray: \"#D3D3D3\", lightgrey: \"#D3D3D3\", lightgreen: \"#90EE90\", lightpink: \"#FFB6C1\", lightsalmon: \"#FFA07A\", lightseagreen: \"#20B2AA\", lightskyblue: \"#87CEFA\", lightslategray: \"#789\", lightslategrey: \"#789\", lightsteelblue: \"#B0C4DE\", lightyellow: \"#FFFFE0\", lime: \"#0F0\", limegreen: \"#32CD32\", linen: \"#FAF0E6\", magenta: \"#F0F\", maroon: \"#800000\", mediumaquamarine: \"#66CDAA\", mediumblue: \"#0000CD\", mediumorchid: \"#BA55D3\", mediumpurple: \"#9370DB\", mediumseagreen: \"#3CB371\", mediumslateblue: \"#7B68EE\", mediumspringgreen: \"#00FA9A\", mediumturquoise: \"#48D1CC\", mediumvioletred: \"#C71585\", midnightblue: \"#191970\", mintcream: \"#F5FFFA\", mistyrose: \"#FFE4E1\", moccasin: \"#FFE4B5\", navajowhite: \"#FFDEAD\", navy: \"#000080\", oldlace: \"#FDF5E6\", olive: \"#808000\", olivedrab: \"#6B8E23\", orange: \"#FFA500\", orangered: \"#FF4500\", orchid: \"#DA70D6\", palegoldenrod: \"#EEE8AA\", palegreen: \"#98FB98\", paleturquoise: \"#AFEEEE\", palevioletred: \"#DB7093\", papayawhip: \"#FFEFD5\", peachpuff: \"#FFDAB9\", peru: \"#CD853F\", pink: \"#FFC0CB\", plum: \"#DDA0DD\", powderblue: \"#B0E0E6\", purple: \"#800080\", rebeccapurple: \"#639\", red: \"#F00\", rosybrown: \"#BC8F8F\", royalblue: \"#4169E1\", saddlebrown: \"#8B4513\", salmon: \"#FA8072\", sandybrown: \"#F4A460\", seagreen: \"#2E8B57\", seashell: \"#FFF5EE\", sienna: \"#A0522D\", silver: \"#C0C0C0\", skyblue: \"#87CEEB\", slateblue: \"#6A5ACD\", slategray: \"#708090\", slategrey: \"#708090\", snow: \"#FFFAFA\", springgreen: \"#00FF7F\", steelblue: \"#4682B4\", tan: \"#D2B48C\", teal: \"#008080\", thistle: \"#D8BFD8\", tomato: \"#FF6347\", turquoise: \"#40E0D0\", violet: \"#EE82EE\", wheat: \"#F5DEB3\", white: \"#FFF\", whitesmoke: \"#F5F5F5\", yellow: \"#FF0\", yellowgreen: \"#9ACD32\" }, Li = (i, t, e) => (e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? i + 6 * (t - i) * e : e < 0.5 ? t : e < 2 / 3 ? i + (t - i) * (2 / 3 - e) * 6 : i), vo = (i, t, e, s) => {\n  i /= 255, t /= 255, e /= 255;\n  const r = Math.max(i, t, e), n = Math.min(i, t, e);\n  let o, a;\n  const c = (r + n) / 2;\n  if (r === n) o = a = 0;\n  else {\n    const l = r - n;\n    switch (a = c > 0.5 ? l / (2 - r - n) : l / (r + n), r) {\n      case i:\n        o = (t - e) / l + (t < e ? 6 : 0);\n        break;\n      case t:\n        o = (e - i) / l + 2;\n        break;\n      case e:\n        o = (i - t) / l + 4;\n    }\n    o /= 6;\n  }\n  return [Math.round(360 * o), Math.round(100 * a), Math.round(100 * c), s];\n}, yo = function() {\n  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"1\";\n  return parseFloat(i) / (i.endsWith(\"%\") ? 100 : 1);\n}, vr = (i) => Math.min(Math.round(i), 255).toString(16).toUpperCase().padStart(2, \"0\"), bo = (i) => {\n  let [t, e, s, r = 1] = i;\n  const n = Math.round(0.3 * t + 0.59 * e + 0.11 * s);\n  return [n, n, n, r];\n};\nclass W {\n  constructor(t) {\n    if (y(this, \"isUnrecognised\", !1), t) if (t instanceof W) this.setSource([...t._source]);\n    else if (Array.isArray(t)) {\n      const [e, s, r, n = 1] = t;\n      this.setSource([e, s, r, n]);\n    } else this.setSource(this._tryParsingColor(t));\n    else this.setSource([0, 0, 0, 1]);\n  }\n  _tryParsingColor(t) {\n    return (t = t.toLowerCase()) in mo && (t = mo[t]), t === \"transparent\" ? [255, 255, 255, 0] : W.sourceFromHex(t) || W.sourceFromRgb(t) || W.sourceFromHsl(t) || (this.isUnrecognised = !0) && [0, 0, 0, 1];\n  }\n  getSource() {\n    return this._source;\n  }\n  setSource(t) {\n    this._source = t;\n  }\n  toRgb() {\n    const [t, e, s] = this.getSource();\n    return \"rgb(\".concat(t, \",\").concat(e, \",\").concat(s, \")\");\n  }\n  toRgba() {\n    return \"rgba(\".concat(this.getSource().join(\",\"), \")\");\n  }\n  toHsl() {\n    const [t, e, s] = vo(...this.getSource());\n    return \"hsl(\".concat(t, \",\").concat(e, \"%,\").concat(s, \"%)\");\n  }\n  toHsla() {\n    const [t, e, s, r] = vo(...this.getSource());\n    return \"hsla(\".concat(t, \",\").concat(e, \"%,\").concat(s, \"%,\").concat(r, \")\");\n  }\n  toHex() {\n    return this.toHexa().slice(0, 6);\n  }\n  toHexa() {\n    const [t, e, s, r] = this.getSource();\n    return \"\".concat(vr(t)).concat(vr(e)).concat(vr(s)).concat(vr(Math.round(255 * r)));\n  }\n  getAlpha() {\n    return this.getSource()[3];\n  }\n  setAlpha(t) {\n    return this._source[3] = t, this;\n  }\n  toGrayscale() {\n    return this.setSource(bo(this.getSource())), this;\n  }\n  toBlackWhite(t) {\n    const [e, , , s] = bo(this.getSource()), r = e < (t || 127) ? 0 : 255;\n    return this.setSource([r, r, r, s]), this;\n  }\n  overlayWith(t) {\n    t instanceof W || (t = new W(t));\n    const e = this.getSource(), s = t.getSource(), [r, n, o] = e.map((a, c) => Math.round(0.5 * a + 0.5 * s[c]));\n    return this.setSource([r, n, o, e[3]]), this;\n  }\n  static fromRgb(t) {\n    return W.fromRgba(t);\n  }\n  static fromRgba(t) {\n    return new W(W.sourceFromRgb(t));\n  }\n  static sourceFromRgb(t) {\n    const e = t.match(/^rgba?\\(\\s*(\\d{0,3}(?:\\.\\d+)?%?)\\s*[\\s|,]\\s*(\\d{0,3}(?:\\.\\d+)?%?)\\s*[\\s|,]\\s*(\\d{0,3}(?:\\.\\d+)?%?)\\s*(?:\\s*[,/]\\s*(\\d{0,3}(?:\\.\\d+)?%?)\\s*)?\\)$/i);\n    if (e) {\n      const [s, r, n] = e.slice(1, 4).map((o) => {\n        const a = parseFloat(o);\n        return o.endsWith(\"%\") ? Math.round(2.55 * a) : a;\n      });\n      return [s, r, n, yo(e[4])];\n    }\n  }\n  static fromHsl(t) {\n    return W.fromHsla(t);\n  }\n  static fromHsla(t) {\n    return new W(W.sourceFromHsl(t));\n  }\n  static sourceFromHsl(t) {\n    const e = t.match(/^hsla?\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?(?:deg|turn|rad)?)\\s*[\\s|,]\\s*(\\d{0,3}(?:\\.\\d+)?%?)\\s*[\\s|,]\\s*(\\d{0,3}(?:\\.\\d+)?%?)\\s*(?:\\s*[,/]\\s*(\\d*(?:\\.\\d+)?%?)\\s*)?\\)$/i);\n    if (!e) return;\n    const s = (W.parseAngletoDegrees(e[1]) % 360 + 360) % 360 / 360, r = parseFloat(e[2]) / 100, n = parseFloat(e[3]) / 100;\n    let o, a, c;\n    if (r === 0) o = a = c = n;\n    else {\n      const l = n <= 0.5 ? n * (r + 1) : n + r - n * r, h = 2 * n - l;\n      o = Li(h, l, s + 1 / 3), a = Li(h, l, s), c = Li(h, l, s - 1 / 3);\n    }\n    return [Math.round(255 * o), Math.round(255 * a), Math.round(255 * c), yo(e[4])];\n  }\n  static fromHex(t) {\n    return new W(W.sourceFromHex(t));\n  }\n  static sourceFromHex(t) {\n    if (t.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {\n      const e = t.slice(t.indexOf(\"#\") + 1);\n      let s;\n      s = e.length <= 4 ? e.split(\"\").map((c) => c + c) : e.match(/.{2}/g);\n      const [r, n, o, a = 255] = s.map((c) => parseInt(c, 16));\n      return [r, n, o, a / 255];\n    }\n  }\n  static parseAngletoDegrees(t) {\n    const e = t.toLowerCase(), s = parseFloat(e);\n    return e.includes(\"rad\") ? Ce(s) : e.includes(\"turn\") ? 360 * s : s;\n  }\n}\nconst V = (i, t) => parseFloat(Number(i).toFixed(t)), We = function(i) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : En;\n  const e = /\\D{0,2}$/.exec(i), s = parseFloat(i), r = A.DPI;\n  switch (e == null ? void 0 : e[0]) {\n    case \"mm\":\n      return s * r / 25.4;\n    case \"cm\":\n      return s * r / 2.54;\n    case \"in\":\n      return s * r;\n    case \"pt\":\n      return s * r / 72;\n    case \"pc\":\n      return s * r / 72 * 12;\n    case \"em\":\n      return s * t;\n    default:\n      return s;\n  }\n}, qa = (i) => {\n  const [t, e] = i.trim().split(\" \"), [s, r] = (n = t) && n !== pt ? [n.slice(1, 4), n.slice(5, 8)] : n === pt ? [n, n] : [\"Mid\", \"Mid\"];\n  var n;\n  return { meetOrSlice: e || \"meet\", alignX: s, alignY: r };\n}, qs = (i) => \"matrix(\" + i.map((t) => V(t, A.NUM_FRACTION_DIGITS)).join(\" \") + \")\", Ks = function(i, t) {\n  let e, s, r = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];\n  if (t) if (t.toLive) e = \"url(#SVGID_\".concat(t.id, \")\");\n  else {\n    const n = new W(t), o = n.getAlpha();\n    e = n.toRgb(), o !== 1 && (s = o.toString());\n  }\n  else e = \"none\";\n  return r ? \"\".concat(i, \": \").concat(e, \"; \").concat(s ? \"\".concat(i, \"-opacity: \").concat(s, \"; \") : \"\") : \"\".concat(i, '=\"').concat(e, '\" ').concat(s ? \"\".concat(i, '-opacity=\"').concat(s, '\" ') : \"\");\n}, Ct = (i) => !!i && i.toLive !== void 0, _o = (i) => !!i && typeof i.toObject == \"function\", So = (i) => !!i && i.offsetX !== void 0 && \"source\" in i, Pe = (i) => !!i && \"multiSelectionStacking\" in i;\nfunction Ka(i) {\n  const t = i && At(i);\n  let e = 0, s = 0;\n  if (!i || !t) return { left: e, top: s };\n  let r = i;\n  const n = t.documentElement, o = t.body || { scrollLeft: 0, scrollTop: 0 };\n  for (; r && (r.parentNode || r.host) && (r = r.parentNode || r.host, r === t ? (e = o.scrollLeft || n.scrollLeft || 0, s = o.scrollTop || n.scrollTop || 0) : (e += r.scrollLeft || 0, s += r.scrollTop || 0), r.nodeType !== 1 || r.style.position !== \"fixed\"); ) ;\n  return { left: e, top: s };\n}\nconst At = (i) => i.ownerDocument || null, Ja = (i) => {\n  var t;\n  return ((t = i.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView) || null;\n}, Za = function(i, t, e) {\n  let { width: s, height: r } = e, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  i.width = s, i.height = r, n > 1 && (i.setAttribute(\"width\", (s * n).toString()), i.setAttribute(\"height\", (r * n).toString()), t.scale(n, n));\n}, nn = (i, t) => {\n  let { width: e, height: s } = t;\n  e && (i.style.width = typeof e == \"number\" ? \"\".concat(e, \"px\") : e), s && (i.style.height = typeof s == \"number\" ? \"\".concat(s, \"px\") : s);\n};\nfunction To(i) {\n  return i.onselectstart !== void 0 && (i.onselectstart = () => !1), i.style.userSelect = pt, i;\n}\nclass Qa {\n  constructor(t) {\n    y(this, \"_originalCanvasStyle\", void 0), y(this, \"lower\", void 0);\n    const e = this.createLowerCanvas(t);\n    this.lower = { el: e, ctx: e.getContext(\"2d\") };\n  }\n  createLowerCanvas(t) {\n    const e = (s = t) && s.getContext !== void 0 ? t : t && Cs().getElementById(t) || kt();\n    var s;\n    if (e.hasAttribute(\"data-fabric\")) throw new Yt(\"Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?\");\n    return this._originalCanvasStyle = e.style.cssText, e.setAttribute(\"data-fabric\", \"main\"), e.classList.add(\"lower-canvas\"), e;\n  }\n  cleanupDOM(t) {\n    let { width: e, height: s } = t;\n    const { el: r } = this.lower;\n    r.classList.remove(\"lower-canvas\"), r.removeAttribute(\"data-fabric\"), r.setAttribute(\"width\", \"\".concat(e)), r.setAttribute(\"height\", \"\".concat(s)), r.style.cssText = this._originalCanvasStyle || \"\", this._originalCanvasStyle = void 0;\n  }\n  setDimensions(t, e) {\n    const { el: s, ctx: r } = this.lower;\n    Za(s, r, t, e);\n  }\n  setCSSDimensions(t) {\n    nn(this.lower.el, t);\n  }\n  calcOffset() {\n    return function(t) {\n      var e;\n      const s = t && At(t), r = { left: 0, top: 0 };\n      if (!s) return r;\n      const n = ((e = Ja(t)) === null || e === void 0 ? void 0 : e.getComputedStyle(t, null)) || {};\n      r.left += parseInt(n.borderLeftWidth, 10) || 0, r.top += parseInt(n.borderTopWidth, 10) || 0, r.left += parseInt(n.paddingLeft, 10) || 0, r.top += parseInt(n.paddingTop, 10) || 0;\n      let o = { left: 0, top: 0 };\n      const a = s.documentElement;\n      t.getBoundingClientRect !== void 0 && (o = t.getBoundingClientRect());\n      const c = Ka(t);\n      return { left: o.left + c.left - (a.clientLeft || 0) + r.left, top: o.top + c.top - (a.clientTop || 0) + r.top };\n    }(this.lower.el);\n  }\n  dispose() {\n    $t().dispose(this.lower.el), delete this.lower;\n  }\n}\nconst Yh = { backgroundVpt: !0, backgroundColor: \"\", overlayVpt: !0, overlayColor: \"\", includeDefaultValues: !0, svgViewportTransformation: !0, renderOnAddRemove: !0, skipOffscreen: !0, enableRetinaScaling: !0, imageSmoothingEnabled: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, viewportTransform: [...ht] };\nclass lr extends za(Ha) {\n  get lowerCanvasEl() {\n    var t;\n    return (t = this.elements.lower) === null || t === void 0 ? void 0 : t.el;\n  }\n  get contextContainer() {\n    var t;\n    return (t = this.elements.lower) === null || t === void 0 ? void 0 : t.ctx;\n  }\n  static getDefaults() {\n    return lr.ownDefaults;\n  }\n  constructor(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    super(), Object.assign(this, this.constructor.getDefaults()), this.set(e), this.initElements(t), this._setDimensionsImpl({ width: this.width || this.elements.lower.el.width || 0, height: this.height || this.elements.lower.el.height || 0 }), this.skipControlsDrawing = !1, this.viewportTransform = [...this.viewportTransform], this.calcViewportBoundaries();\n  }\n  initElements(t) {\n    this.elements = new Qa(t);\n  }\n  add() {\n    const t = super.add(...arguments);\n    return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), t;\n  }\n  insertAt(t) {\n    for (var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) s[r - 1] = arguments[r];\n    const n = super.insertAt(t, ...s);\n    return s.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), n;\n  }\n  remove() {\n    const t = super.remove(...arguments);\n    return t.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), t;\n  }\n  _onObjectAdded(t) {\n    t.canvas && t.canvas !== this && (Te(\"warn\", `Canvas is trying to add an object that belongs to a different canvas.\nResulting to default behavior: removing object from previous canvas and adding to new canvas`), t.canvas.remove(t)), t._set(\"canvas\", this), t.setCoords(), this.fire(\"object:added\", { target: t }), t.fire(\"added\", { target: this });\n  }\n  _onObjectRemoved(t) {\n    t._set(\"canvas\", void 0), this.fire(\"object:removed\", { target: t }), t.fire(\"removed\", { target: this });\n  }\n  _onStackOrderChanged() {\n    this.renderOnAddRemove && this.requestRenderAll();\n  }\n  getRetinaScaling() {\n    return this.enableRetinaScaling ? Ra() : 1;\n  }\n  calcOffset() {\n    return this._offset = this.elements.calcOffset();\n  }\n  getWidth() {\n    return this.width;\n  }\n  getHeight() {\n    return this.height;\n  }\n  setWidth(t, e) {\n    return this.setDimensions({ width: t }, e);\n  }\n  setHeight(t, e) {\n    return this.setDimensions({ height: t }, e);\n  }\n  _setDimensionsImpl(t) {\n    let { cssOnly: e = !1, backstoreOnly: s = !1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (!e) {\n      const r = v({ width: this.width, height: this.height }, t);\n      this.elements.setDimensions(r, this.getRetinaScaling()), this.hasLostContext = !0, this.width = r.width, this.height = r.height;\n    }\n    s || this.elements.setCSSDimensions(t), this.calcOffset();\n  }\n  setDimensions(t, e) {\n    this._setDimensionsImpl(t, e), e && e.cssOnly || this.requestRenderAll();\n  }\n  getZoom() {\n    return this.viewportTransform[0];\n  }\n  setViewportTransform(t) {\n    this.viewportTransform = t, this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();\n  }\n  zoomToPoint(t, e) {\n    const s = t, r = [...this.viewportTransform], n = ot(t, St(r));\n    r[0] = e, r[3] = e;\n    const o = ot(n, r);\n    r[4] += s.x - o.x, r[5] += s.y - o.y, this.setViewportTransform(r);\n  }\n  setZoom(t) {\n    this.zoomToPoint(new _(0, 0), t);\n  }\n  absolutePan(t) {\n    const e = [...this.viewportTransform];\n    return e[4] = -t.x, e[5] = -t.y, this.setViewportTransform(e);\n  }\n  relativePan(t) {\n    return this.absolutePan(new _(-t.x - this.viewportTransform[4], -t.y - this.viewportTransform[5]));\n  }\n  getElement() {\n    return this.elements.lower.el;\n  }\n  clearContext(t) {\n    t.clearRect(0, 0, this.width, this.height);\n  }\n  getContext() {\n    return this.elements.lower.ctx;\n  }\n  clear() {\n    this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = \"\", this.overlayColor = \"\", this.clearContext(this.getContext()), this.fire(\"canvas:cleared\"), this.renderOnAddRemove && this.requestRenderAll();\n  }\n  renderAll() {\n    this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);\n  }\n  renderAndReset() {\n    this.nextRenderHandle = 0, this.renderAll();\n  }\n  requestRenderAll() {\n    this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = Hs(() => this.renderAndReset()));\n  }\n  calcViewportBoundaries() {\n    const t = this.width, e = this.height, s = St(this.viewportTransform), r = ot({ x: 0, y: 0 }, s), n = ot({ x: t, y: e }, s), o = r.min(n), a = r.max(n);\n    return this.vptCoords = { tl: o, tr: new _(a.x, o.y), bl: new _(o.x, a.y), br: a };\n  }\n  cancelRequestedRender() {\n    this.nextRenderHandle && (Ya(this.nextRenderHandle), this.nextRenderHandle = 0);\n  }\n  drawControls(t) {\n  }\n  renderCanvas(t, e) {\n    if (this.destroyed) return;\n    const s = this.viewportTransform, r = this.clipPath;\n    this.calcViewportBoundaries(), this.clearContext(t), t.imageSmoothingEnabled = this.imageSmoothingEnabled, t.patternQuality = \"best\", this.fire(\"before:render\", { ctx: t }), this._renderBackground(t), t.save(), t.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this._renderObjects(t, e), t.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(t), r && (r._set(\"canvas\", this), r.shouldCache(), r._transformDone = !0, r.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(t, r)), this._renderOverlay(t), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(t), this.fire(\"after:render\", { ctx: t }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);\n  }\n  drawClipPathOnCanvas(t, e) {\n    const s = this.viewportTransform;\n    t.save(), t.transform(...s), t.globalCompositeOperation = \"destination-in\", e.transform(t), t.scale(1 / e.zoomX, 1 / e.zoomY), t.drawImage(e._cacheCanvas, -e.cacheTranslationX, -e.cacheTranslationY), t.restore();\n  }\n  _renderObjects(t, e) {\n    for (let s = 0, r = e.length; s < r; ++s) e[s] && e[s].render(t);\n  }\n  _renderBackgroundOrOverlay(t, e) {\n    const s = this[\"\".concat(e, \"Color\")], r = this[\"\".concat(e, \"Image\")], n = this.viewportTransform, o = this[\"\".concat(e, \"Vpt\")];\n    if (!s && !r) return;\n    const a = Ct(s);\n    if (s) {\n      if (t.save(), t.beginPath(), t.moveTo(0, 0), t.lineTo(this.width, 0), t.lineTo(this.width, this.height), t.lineTo(0, this.height), t.closePath(), t.fillStyle = a ? s.toLive(t) : s, o && t.transform(...n), a) {\n        t.transform(1, 0, 0, 1, s.offsetX || 0, s.offsetY || 0);\n        const c = s.gradientTransform || s.patternTransform;\n        c && t.transform(...c);\n      }\n      t.fill(), t.restore();\n    }\n    if (r) {\n      t.save();\n      const { skipOffscreen: c } = this;\n      this.skipOffscreen = o, o && t.transform(...n), r.render(t), this.skipOffscreen = c, t.restore();\n    }\n  }\n  _renderBackground(t) {\n    this._renderBackgroundOrOverlay(t, \"background\");\n  }\n  _renderOverlay(t) {\n    this._renderBackgroundOrOverlay(t, \"overlay\");\n  }\n  getCenter() {\n    return { top: this.height / 2, left: this.width / 2 };\n  }\n  getCenterPoint() {\n    return new _(this.width / 2, this.height / 2);\n  }\n  centerObjectH(t) {\n    return this._centerObject(t, new _(this.getCenterPoint().x, t.getCenterPoint().y));\n  }\n  centerObjectV(t) {\n    return this._centerObject(t, new _(t.getCenterPoint().x, this.getCenterPoint().y));\n  }\n  centerObject(t) {\n    return this._centerObject(t, this.getCenterPoint());\n  }\n  viewportCenterObject(t) {\n    return this._centerObject(t, this.getVpCenter());\n  }\n  viewportCenterObjectH(t) {\n    return this._centerObject(t, new _(this.getVpCenter().x, t.getCenterPoint().y));\n  }\n  viewportCenterObjectV(t) {\n    return this._centerObject(t, new _(t.getCenterPoint().x, this.getVpCenter().y));\n  }\n  getVpCenter() {\n    return ot(this.getCenterPoint(), St(this.viewportTransform));\n  }\n  _centerObject(t, e) {\n    t.setXY(e, j, j), t.setCoords(), this.renderOnAddRemove && this.requestRenderAll();\n  }\n  toDatalessJSON(t) {\n    return this.toDatalessObject(t);\n  }\n  toObject(t) {\n    return this._toObjectMethod(\"toObject\", t);\n  }\n  toJSON() {\n    return this.toObject();\n  }\n  toDatalessObject(t) {\n    return this._toObjectMethod(\"toDatalessObject\", t);\n  }\n  _toObjectMethod(t, e) {\n    const s = this.clipPath, r = s && !s.excludeFromExport ? this._toObject(s, t, e) : null;\n    return v(v(v({ version: sn }, Ve(this, e)), {}, { objects: this._objects.filter((n) => !n.excludeFromExport).map((n) => this._toObject(n, t, e)) }, this.__serializeBgOverlay(t, e)), r ? { clipPath: r } : null);\n  }\n  _toObject(t, e, s) {\n    let r;\n    this.includeDefaultValues || (r = t.includeDefaultValues, t.includeDefaultValues = !1);\n    const n = t[e](s);\n    return this.includeDefaultValues || (t.includeDefaultValues = !!r), n;\n  }\n  __serializeBgOverlay(t, e) {\n    const s = {}, r = this.backgroundImage, n = this.overlayImage, o = this.backgroundColor, a = this.overlayColor;\n    return Ct(o) ? o.excludeFromExport || (s.background = o.toObject(e)) : o && (s.background = o), Ct(a) ? a.excludeFromExport || (s.overlay = a.toObject(e)) : a && (s.overlay = a), r && !r.excludeFromExport && (s.backgroundImage = this._toObject(r, t, e)), n && !n.excludeFromExport && (s.overlayImage = this._toObject(n, t, e)), s;\n  }\n  toSVG() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0;\n    t.reviver = e;\n    const s = [];\n    return this._setSVGPreamble(s, t), this._setSVGHeader(s, t), this.clipPath && s.push('<g clip-path=\"url(#'.concat(this.clipPath.clipPathId, `)\" >\n`)), this._setSVGBgOverlayColor(s, \"background\"), this._setSVGBgOverlayImage(s, \"backgroundImage\", e), this._setSVGObjects(s, e), this.clipPath && s.push(`</g>\n`), this._setSVGBgOverlayColor(s, \"overlay\"), this._setSVGBgOverlayImage(s, \"overlayImage\", e), s.push(\"</svg>\"), s.join(\"\");\n  }\n  _setSVGPreamble(t, e) {\n    e.suppressPreamble || t.push('<?xml version=\"1.0\" encoding=\"', e.encoding || \"UTF-8\", `\" standalone=\"no\" ?>\n`, '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ', `\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n`);\n  }\n  _setSVGHeader(t, e) {\n    const s = e.width || \"\".concat(this.width), r = e.height || \"\".concat(this.height), n = A.NUM_FRACTION_DIGITS, o = e.viewBox;\n    let a;\n    if (o) a = 'viewBox=\"'.concat(o.x, \" \").concat(o.y, \" \").concat(o.width, \" \").concat(o.height, '\" ');\n    else if (this.svgViewportTransformation) {\n      const c = this.viewportTransform;\n      a = 'viewBox=\"'.concat(V(-c[4] / c[0], n), \" \").concat(V(-c[5] / c[3], n), \" \").concat(V(this.width / c[0], n), \" \").concat(V(this.height / c[3], n), '\" ');\n    } else a = 'viewBox=\"0 0 '.concat(this.width, \" \").concat(this.height, '\" ');\n    t.push(\"<svg \", 'xmlns=\"http://www.w3.org/2000/svg\" ', 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ', 'version=\"1.1\" ', 'width=\"', s, '\" ', 'height=\"', r, '\" ', a, `xml:space=\"preserve\">\n`, \"<desc>Created with Fabric.js \", sn, `</desc>\n`, `<defs>\n`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(e), `</defs>\n`);\n  }\n  createSVGClipPathMarkup(t) {\n    const e = this.clipPath;\n    return e ? (e.clipPathId = \"CLIPPATH_\".concat(we()), '<clipPath id=\"'.concat(e.clipPathId, `\" >\n`).concat(e.toClipPathSVG(t.reviver), `</clipPath>\n`)) : \"\";\n  }\n  createSVGRefElementsMarkup() {\n    return [\"background\", \"overlay\"].map((t) => {\n      const e = this[\"\".concat(t, \"Color\")];\n      if (Ct(e)) {\n        const s = this[\"\".concat(t, \"Vpt\")], r = this.viewportTransform, n = { isType: () => !1, width: this.width / (s ? r[0] : 1), height: this.height / (s ? r[3] : 1) };\n        return e.toSVG(n, { additionalTransform: s ? qs(r) : \"\" });\n      }\n    }).join(\"\");\n  }\n  createSVGFontFacesMarkup() {\n    const t = [], e = {}, s = A.fontPaths;\n    this._objects.forEach(function n(o) {\n      t.push(o), Vr(o) && o._objects.forEach(n);\n    }), t.forEach((n) => {\n      if (!(o = n) || typeof o._renderText != \"function\") return;\n      var o;\n      const { styles: a, fontFamily: c } = n;\n      !e[c] && s[c] && (e[c] = !0, a && Object.values(a).forEach((l) => {\n        Object.values(l).forEach((h) => {\n          let { fontFamily: u = \"\" } = h;\n          !e[u] && s[u] && (e[u] = !0);\n        });\n      }));\n    });\n    const r = Object.keys(e).map((n) => `\t\t@font-face {\n\t\t\tfont-family: '`.concat(n, `';\n\t\t\tsrc: url('`).concat(s[n], `');\n\t\t}\n`)).join(\"\");\n    return r ? `\t<style type=\"text/css\"><![CDATA[\n`.concat(r, `]]></style>\n`) : \"\";\n  }\n  _setSVGObjects(t, e) {\n    this.forEachObject((s) => {\n      s.excludeFromExport || this._setSVGObject(t, s, e);\n    });\n  }\n  _setSVGObject(t, e, s) {\n    t.push(e.toSVG(s));\n  }\n  _setSVGBgOverlayImage(t, e, s) {\n    const r = this[e];\n    r && !r.excludeFromExport && r.toSVG && t.push(r.toSVG(s));\n  }\n  _setSVGBgOverlayColor(t, e) {\n    const s = this[\"\".concat(e, \"Color\")];\n    if (s) if (Ct(s)) {\n      const r = s.repeat || \"\", n = this.width, o = this.height, a = this[\"\".concat(e, \"Vpt\")] ? qs(St(this.viewportTransform)) : \"\";\n      t.push('<rect transform=\"'.concat(a, \" translate(\").concat(n / 2, \",\").concat(o / 2, ')\" x=\"').concat(s.offsetX - n / 2, '\" y=\"').concat(s.offsetY - o / 2, '\" width=\"').concat(r !== \"repeat-y\" && r !== \"no-repeat\" || !So(s) ? n : s.source.width, '\" height=\"').concat(r !== \"repeat-x\" && r !== \"no-repeat\" || !So(s) ? o : s.source.height, '\" fill=\"url(#SVGID_').concat(s.id, `)\"></rect>\n`));\n    } else t.push('<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" ', 'fill=\"', s, '\"', `></rect>\n`);\n  }\n  loadFromJSON(t, e) {\n    let { signal: s } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    if (!t) return Promise.reject(new Yt(\"`json` is undefined\"));\n    const r = typeof t == \"string\" ? JSON.parse(t) : t, { objects: n = [], backgroundImage: o, background: a, overlayImage: c, overlay: l, clipPath: h } = r, u = this.renderOnAddRemove;\n    return this.renderOnAddRemove = !1, Promise.all([bs(n, { reviver: e, signal: s }), cr({ backgroundImage: o, backgroundColor: a, overlayImage: c, overlayColor: l, clipPath: h }, { signal: s })]).then((d) => {\n      let [f, g] = d;\n      return this.clear(), this.add(...f), this.set(r), this.set(g), this.renderOnAddRemove = u, this;\n    });\n  }\n  clone(t) {\n    const e = this.toObject(t);\n    return this.cloneWithoutData().loadFromJSON(e);\n  }\n  cloneWithoutData() {\n    const t = Wt(this);\n    return new this.constructor(t);\n  }\n  toDataURL() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const { format: e = \"png\", quality: s = 1, multiplier: r = 1, enableRetinaScaling: n = !1 } = t, o = r * (n ? this.getRetinaScaling() : 1);\n    return Rn(this.toCanvasElement(o, t), e, s);\n  }\n  toBlob() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const { format: e = \"png\", quality: s = 1, multiplier: r = 1, enableRetinaScaling: n = !1 } = t, o = r * (n ? this.getRetinaScaling() : 1);\n    return Ln(this.toCanvasElement(o, t), e, s);\n  }\n  toCanvasElement() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, { width: e, height: s, left: r, top: n, filter: o } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const a = (e || this.width) * t, c = (s || this.height) * t, l = this.getZoom(), h = this.width, u = this.height, d = this.skipControlsDrawing, f = l * t, g = this.viewportTransform, p = [f, 0, 0, f, (g[4] - (r || 0)) * t, (g[5] - (n || 0)) * t], m = this.enableRetinaScaling, b = Wt({ width: a, height: c }), S = o ? this._objects.filter((w) => o(w)) : this._objects;\n    return this.enableRetinaScaling = !1, this.viewportTransform = p, this.width = a, this.height = c, this.skipControlsDrawing = !0, this.calcViewportBoundaries(), this.renderCanvas(b.getContext(\"2d\"), S), this.viewportTransform = g, this.width = h, this.height = u, this.calcViewportBoundaries(), this.enableRetinaScaling = m, this.skipControlsDrawing = d, b;\n  }\n  dispose() {\n    return !this.disposed && this.elements.cleanupDOM({ width: this.width, height: this.height }), qr.cancelByCanvas(this), this.disposed = !0, new Promise((t, e) => {\n      const s = () => {\n        this.destroy(), t(!0);\n      };\n      s.kill = e, this.__cleanupTask && this.__cleanupTask.kill(\"aborted\"), this.destroyed ? t(!1) : this.nextRenderHandle ? this.__cleanupTask = s : s();\n    });\n  }\n  destroy() {\n    this.destroyed = !0, this.cancelRequestedRender(), this.forEachObject((t) => t.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();\n  }\n  toString() {\n    return \"#<Canvas (\".concat(this.complexity(), \"): { objects: \").concat(this._objects.length, \" }>\");\n  }\n}\ny(lr, \"ownDefaults\", Yh);\nconst Vh = [\"touchstart\", \"touchmove\", \"touchend\"], tc = (i) => {\n  const t = Ka(i.target), e = function(s) {\n    const r = s.changedTouches;\n    return r && r[0] ? r[0] : s;\n  }(i);\n  return new _(e.clientX + t.left, e.clientY + t.top);\n}, Kr = (i) => Vh.includes(i.type) || i.pointerType === \"touch\", on = (i) => {\n  i.preventDefault(), i.stopPropagation();\n}, Gt = (i) => {\n  let t = 0, e = 0, s = 0, r = 0;\n  for (let n = 0, o = i.length; n < o; n++) {\n    const { x: a, y: c } = i[n];\n    (a > s || !n) && (s = a), (a < t || !n) && (t = a), (c > r || !n) && (r = c), (c < e || !n) && (e = c);\n  }\n  return { left: t, top: e, width: s - t, height: r - e };\n}, Gh = [\"translateX\", \"translateY\", \"scaleX\", \"scaleY\"], ec = (i, t) => _s(i, J(t, i.calcOwnMatrix())), _s = (i, t) => {\n  const e = ys(t), { translateX: s, translateY: r, scaleX: n, scaleY: o } = e, a = G(e, Gh), c = new _(s, r);\n  i.flipX = !1, i.flipY = !1, Object.assign(i, a), i.set({ scaleX: n, scaleY: o }), i.setPositionByOrigin(c, j, j);\n}, sc = (i) => {\n  i.scaleX = 1, i.scaleY = 1, i.skewX = 0, i.skewY = 0, i.flipX = !1, i.flipY = !1, i.rotate(0);\n}, zn = (i) => ({ scaleX: i.scaleX, scaleY: i.scaleY, skewX: i.skewX, skewY: i.skewY, angle: i.angle, left: i.left, flipX: i.flipX, flipY: i.flipY, top: i.top }), yi = (i, t, e) => {\n  const s = i / 2, r = t / 2, n = [new _(-s, -r), new _(s, -r), new _(-s, r), new _(s, r)].map((a) => a.transform(e)), o = Gt(n);\n  return new _(o.width, o.height);\n}, hr = function() {\n  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ht;\n  return J(St(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ht), i);\n}, ae = function(i) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ht, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ht;\n  return i.transform(hr(t, e));\n}, rc = function(i) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ht, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ht;\n  return i.transform(hr(t, e), !0);\n}, an = (i, t, e) => {\n  const s = hr(t, e);\n  return _s(i, J(s, i.calcOwnMatrix())), s;\n}, Hn = (i, t) => {\n  var e;\n  const { transform: { target: s } } = t;\n  (e = s.canvas) === null || e === void 0 || e.fire(\"object:\".concat(i), v(v({}, t), {}, { target: s })), s.fire(i, t);\n}, Nh = { left: -0.5, top: -0.5, center: 0, bottom: 0.5, right: 0.5 }, st = (i) => typeof i == \"string\" ? Nh[i] : i - 0.5, Jr = \"not-allowed\";\nfunction ic(i) {\n  return st(i.originX) === st(j) && st(i.originY) === st(j);\n}\nfunction xo(i) {\n  return 0.5 - st(i);\n}\nconst Rt = (i, t) => i[t], Yn = (i, t, e, s) => ({ e: i, transform: t, pointer: new _(e, s) });\nfunction nc(i, t) {\n  const e = i.getTotalAngle() + Ce(Math.atan2(t.y, t.x)) + 360;\n  return Math.round(e % 360 / 45);\n}\nfunction bi(i, t, e, s, r) {\n  var n;\n  let { target: o, corner: a } = i;\n  const c = o.controls[a], l = ((n = o.canvas) === null || n === void 0 ? void 0 : n.getZoom()) || 1, h = o.padding / l, u = function(d, f, g, p) {\n    const m = d.getRelativeCenterPoint(), b = g !== void 0 && p !== void 0 ? d.translateToGivenOrigin(m, j, j, g, p) : new _(d.left, d.top);\n    return (d.angle ? f.rotate(-K(d.angle), m) : f).subtract(b);\n  }(o, new _(s, r), t, e);\n  return u.x >= h && (u.x -= h), u.x <= -h && (u.x += h), u.y >= h && (u.y -= h), u.y <= h && (u.y += h), u.x -= c.offsetX, u.y -= c.offsetY, u;\n}\nconst oc = (i, t, e, s) => {\n  const { target: r, offsetX: n, offsetY: o } = t, a = e - n, c = s - o, l = !Rt(r, \"lockMovementX\") && r.left !== a, h = !Rt(r, \"lockMovementY\") && r.top !== c;\n  return l && r.set(L, a), h && r.set(gt, c), (l || h) && Hn(La, Yn(i, t, e, s)), l || h;\n};\nclass ac {\n  getSvgStyles(t) {\n    const e = this.fillRule ? this.fillRule : \"nonzero\", s = this.strokeWidth ? this.strokeWidth : \"0\", r = this.strokeDashArray ? this.strokeDashArray.join(\" \") : pt, n = this.strokeDashOffset ? this.strokeDashOffset : \"0\", o = this.strokeLineCap ? this.strokeLineCap : \"butt\", a = this.strokeLineJoin ? this.strokeLineJoin : \"miter\", c = this.strokeMiterLimit ? this.strokeMiterLimit : \"4\", l = this.opacity !== void 0 ? this.opacity : \"1\", h = this.visible ? \"\" : \" visibility: hidden;\", u = t ? \"\" : this.getSvgFilter(), d = Ks(rt, this.fill);\n    return [Ks(mt, this.stroke), \"stroke-width: \", s, \"; \", \"stroke-dasharray: \", r, \"; \", \"stroke-linecap: \", o, \"; \", \"stroke-dashoffset: \", n, \"; \", \"stroke-linejoin: \", a, \"; \", \"stroke-miterlimit: \", c, \"; \", d, \"fill-rule: \", e, \"; \", \"opacity: \", l, \";\", u, h].join(\"\");\n  }\n  getSvgFilter() {\n    return this.shadow ? \"filter: url(#SVGID_\".concat(this.shadow.id, \");\") : \"\";\n  }\n  getSvgCommons() {\n    return [this.id ? 'id=\"'.concat(this.id, '\" ') : \"\", this.clipPath ? 'clip-path=\"url(#'.concat(this.clipPath.clipPathId, ')\" ') : \"\"].join(\"\");\n  }\n  getSvgTransform(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    const s = t ? this.calcTransformMatrix() : this.calcOwnMatrix(), r = 'transform=\"'.concat(qs(s));\n    return \"\".concat(r).concat(e, '\" ');\n  }\n  _toSVG(t) {\n    return [\"\"];\n  }\n  toSVG(t) {\n    return this._createBaseSVGMarkup(this._toSVG(t), { reviver: t });\n  }\n  toClipPathSVG(t) {\n    return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(t), { reviver: t });\n  }\n  _createBaseClipPathSVGMarkup(t) {\n    let { reviver: e, additionalTransform: s = \"\" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const r = [this.getSvgTransform(!0, s), this.getSvgCommons()].join(\"\"), n = t.indexOf(\"COMMON_PARTS\");\n    return t[n] = r, e ? e(t.join(\"\")) : t.join(\"\");\n  }\n  _createBaseSVGMarkup(t) {\n    let { noStyle: e, reviver: s, withShadow: r, additionalTransform: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const o = e ? \"\" : 'style=\"'.concat(this.getSvgStyles(), '\" '), a = r ? 'style=\"'.concat(this.getSvgFilter(), '\" ') : \"\", c = this.clipPath, l = this.strokeUniform ? 'vector-effect=\"non-scaling-stroke\" ' : \"\", h = c && c.absolutePositioned, u = this.stroke, d = this.fill, f = this.shadow, g = [], p = t.indexOf(\"COMMON_PARTS\");\n    let m;\n    c && (c.clipPathId = \"CLIPPATH_\".concat(we()), m = '<clipPath id=\"'.concat(c.clipPathId, `\" >\n`).concat(c.toClipPathSVG(s), `</clipPath>\n`)), h && g.push(\"<g \", a, this.getSvgCommons(), ` >\n`), g.push(\"<g \", this.getSvgTransform(!1), h ? \"\" : a + this.getSvgCommons(), ` >\n`);\n    const b = [o, l, e ? \"\" : this.addPaintOrder(), \" \", n ? 'transform=\"'.concat(n, '\" ') : \"\"].join(\"\");\n    return t[p] = b, Ct(d) && g.push(d.toSVG(this)), Ct(u) && g.push(u.toSVG(this)), f && g.push(f.toSVG(this)), c && g.push(m), g.push(t.join(\"\")), g.push(`</g>\n`), h && g.push(`</g>\n`), s ? s(g.join(\"\")) : g.join(\"\");\n  }\n  addPaintOrder() {\n    return this.paintFirst !== rt ? ' paint-order=\"'.concat(this.paintFirst, '\" ') : \"\";\n  }\n}\nfunction _i(i) {\n  return new RegExp(\"^(\" + i.join(\"|\") + \")\\\\b\", \"i\");\n}\nvar wo;\nconst Xe = String.raw(wo || (wo = Me([\"(?:[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?)\"], [\"(?:[-+]?(?:\\\\d*\\\\.\\\\d+|\\\\d+\\\\.?)(?:[eE][-+]?\\\\d+)?)\"]))), Uh = new RegExp(\"(normal|italic)?\\\\s*(normal|small-caps)?\\\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\s*(\" + Xe + \"(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\/(normal|\" + Xe + \"))?\\\\s+(.*)\"), $h = { cx: L, x: L, r: \"radius\", cy: gt, y: gt, display: \"visible\", visibility: \"visible\", transform: \"transformMatrix\", \"fill-opacity\": \"fillOpacity\", \"fill-rule\": \"fillRule\", \"font-family\": \"fontFamily\", \"font-size\": \"fontSize\", \"font-style\": \"fontStyle\", \"font-weight\": \"fontWeight\", \"letter-spacing\": \"charSpacing\", \"paint-order\": \"paintFirst\", \"stroke-dasharray\": \"strokeDashArray\", \"stroke-dashoffset\": \"strokeDashOffset\", \"stroke-linecap\": \"strokeLineCap\", \"stroke-linejoin\": \"strokeLineJoin\", \"stroke-miterlimit\": \"strokeMiterLimit\", \"stroke-opacity\": \"strokeOpacity\", \"stroke-width\": \"strokeWidth\", \"text-decoration\": \"textDecoration\", \"text-anchor\": \"textAnchor\", opacity: \"opacity\", \"clip-path\": \"clipPath\", \"clip-rule\": \"clipRule\", \"vector-effect\": \"strokeUniform\", \"image-rendering\": \"imageSmoothing\" }, Bi = \"font-size\", Wi = \"clip-path\";\n_i([\"path\", \"circle\", \"polygon\", \"polyline\", \"ellipse\", \"rect\", \"line\", \"image\", \"text\"]);\n_i([\"symbol\", \"image\", \"marker\", \"pattern\", \"view\", \"svg\"]);\nconst Co = _i([\"symbol\", \"g\", \"a\", \"svg\", \"clipPath\", \"defs\"]), qh = new _(1, 0), cc = new _(), Vn = (i, t) => i.rotate(t), Zr = (i, t) => new _(t).subtract(i), Qr = (i) => i.distanceFrom(cc), ti = (i, t) => Math.atan2(ps(i, t), hc(i, t)), lc = (i) => ti(qh, i), Si = (i) => i.eq(cc) ? i : i.scalarDivide(Qr(i)), Gn = function(i) {\n  let t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];\n  return Si(new _(-i.y, i.x).scalarMultiply(t ? 1 : -1));\n}, ps = (i, t) => i.x * t.y - i.y * t.x, hc = (i, t) => i.x * t.x + i.y * t.y, cn = (i, t, e) => {\n  if (i.eq(t) || i.eq(e)) return !0;\n  const s = ps(t, e), r = ps(t, i), n = ps(e, i);\n  return s >= 0 ? r >= 0 && n <= 0 : !(r <= 0 && n >= 0);\n}, Oo = \"(-?\\\\d+(?:\\\\.\\\\d*)?(?:px)?(?:\\\\s?|$))?\", ko = new RegExp(\"(?:\\\\s|^)\" + Oo + Oo + \"(\" + Xe + \"?(?:px)?)?(?:\\\\s?|$)(?:$|\\\\s)\");\nclass ce {\n  constructor(t) {\n    const e = typeof t == \"string\" ? ce.parseShadow(t) : t;\n    Object.assign(this, ce.ownDefaults, e), this.id = we();\n  }\n  static parseShadow(t) {\n    const e = t.trim(), [, s = 0, r = 0, n = 0] = (ko.exec(e) || []).map((o) => parseFloat(o) || 0);\n    return { color: (e.replace(ko, \"\") || \"rgb(0,0,0)\").trim(), offsetX: s, offsetY: r, blur: n };\n  }\n  toString() {\n    return [this.offsetX, this.offsetY, this.blur, this.color].join(\"px \");\n  }\n  toSVG(t) {\n    const e = Vn(new _(this.offsetX, this.offsetY), K(-t.angle)), s = new W(this.color);\n    let r = 40, n = 40;\n    return t.width && t.height && (r = 100 * V((Math.abs(e.x) + this.blur) / t.width, A.NUM_FRACTION_DIGITS) + 20, n = 100 * V((Math.abs(e.y) + this.blur) / t.height, A.NUM_FRACTION_DIGITS) + 20), t.flipX && (e.x *= -1), t.flipY && (e.y *= -1), '<filter id=\"SVGID_'.concat(this.id, '\" y=\"-').concat(n, '%\" height=\"').concat(100 + 2 * n, '%\" x=\"-').concat(r, '%\" width=\"').concat(100 + 2 * r, `%\" >\n\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"`).concat(V(this.blur ? this.blur / 2 : 0, A.NUM_FRACTION_DIGITS), `\"></feGaussianBlur>\n\t<feOffset dx=\"`).concat(V(e.x, A.NUM_FRACTION_DIGITS), '\" dy=\"').concat(V(e.y, A.NUM_FRACTION_DIGITS), `\" result=\"oBlur\" ></feOffset>\n\t<feFlood flood-color=\"`).concat(s.toRgb(), '\" flood-opacity=\"').concat(s.getAlpha(), `\"/>\n\t<feComposite in2=\"oBlur\" operator=\"in\" />\n\t<feMerge>\n\t\t<feMergeNode></feMergeNode>\n\t\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\n\t</feMerge>\n</filter>\n`);\n  }\n  toObject() {\n    const t = { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling, type: this.constructor.type }, e = ce.ownDefaults;\n    return this.includeDefaultValues ? t : Xn(t, (s, r) => s !== e[r]);\n  }\n  static async fromObject(t) {\n    return new this(t);\n  }\n}\ny(ce, \"ownDefaults\", { color: \"rgb(0,0,0)\", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1 }), y(ce, \"type\", \"shadow\"), C.setClass(ce, \"shadow\");\nconst ze = (i, t, e) => Math.max(i, Math.min(t, e)), Kh = [gt, L, ut, Tt, \"flipX\", \"flipY\", \"originX\", \"originY\", \"angle\", \"opacity\", \"globalCompositeOperation\", \"shadow\", \"visible\", Os, ks], de = [rt, mt, \"strokeWidth\", \"strokeDashArray\", \"width\", \"height\", \"paintFirst\", \"strokeUniform\", \"strokeLineCap\", \"strokeDashOffset\", \"strokeLineJoin\", \"strokeMiterLimit\", \"backgroundColor\", \"clipPath\"], Jh = { top: 0, left: 0, width: 0, height: 0, angle: 0, flipX: !1, flipY: !1, scaleX: 1, scaleY: 1, minScaleLimit: 0, skewX: 0, skewY: 0, originX: L, originY: gt, strokeWidth: 1, strokeUniform: !1, padding: 0, opacity: 1, paintFirst: rt, fill: \"rgb(0,0,0)\", fillRule: \"nonzero\", stroke: null, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: \"butt\", strokeLineJoin: \"miter\", strokeMiterLimit: 4, globalCompositeOperation: \"source-over\", backgroundColor: \"\", shadow: null, visible: !0, includeDefaultValues: !0, excludeFromExport: !1, objectCaching: !0, clipPath: void 0, inverted: !1, absolutePositioned: !1, centeredRotation: !0, centeredScaling: !1, dirty: !0 }, Xi = (i, t, e, s) => (i < Math.abs(t) ? (i = t, s = e / 4) : s = t === 0 && i === 0 ? e / he * Math.asin(1) : e / he * Math.asin(t / i), { a: i, c: t, p: e, s }), Mo = (i, t, e, s, r) => i * Math.pow(2, 10 * (s -= 1)) * Math.sin((s * r - t) * he / e), uc = (i, t, e, s) => -e * Math.cos(i / s * xe) + e + t, ln = (i, t, e, s) => (i /= s) < 1 / 2.75 ? e * (7.5625 * i * i) + t : i < 2 / 2.75 ? e * (7.5625 * (i -= 1.5 / 2.75) * i + 0.75) + t : i < 2.5 / 2.75 ? e * (7.5625 * (i -= 2.25 / 2.75) * i + 0.9375) + t : e * (7.5625 * (i -= 2.625 / 2.75) * i + 0.984375) + t, Io = (i, t, e, s) => e - ln(s - i, 0, e, s) + t;\nvar Zh = Object.freeze({ __proto__: null, defaultEasing: uc, easeInBack: function(i, t, e, s) {\n  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;\n  return e * (i /= s) * i * ((r + 1) * i - r) + t;\n}, easeInBounce: Io, easeInCirc: (i, t, e, s) => -e * (Math.sqrt(1 - (i /= s) * i) - 1) + t, easeInCubic: (i, t, e, s) => e * (i / s) ** 3 + t, easeInElastic: (i, t, e, s) => {\n  const r = e;\n  let n = 0;\n  if (i === 0) return t;\n  if ((i /= s) === 1) return t + e;\n  n || (n = 0.3 * s);\n  const { a: o, s: a, p: c } = Xi(r, e, n, 1.70158);\n  return -Mo(o, a, c, i, s) + t;\n}, easeInExpo: (i, t, e, s) => i === 0 ? t : e * 2 ** (10 * (i / s - 1)) + t, easeInOutBack: function(i, t, e, s) {\n  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;\n  return (i /= s / 2) < 1 ? e / 2 * (i * i * ((1 + (r *= 1.525)) * i - r)) + t : e / 2 * ((i -= 2) * i * ((1 + (r *= 1.525)) * i + r) + 2) + t;\n}, easeInOutBounce: (i, t, e, s) => i < s / 2 ? 0.5 * Io(2 * i, 0, e, s) + t : 0.5 * ln(2 * i - s, 0, e, s) + 0.5 * e + t, easeInOutCirc: (i, t, e, s) => (i /= s / 2) < 1 ? -e / 2 * (Math.sqrt(1 - i ** 2) - 1) + t : e / 2 * (Math.sqrt(1 - (i -= 2) * i) + 1) + t, easeInOutCubic: (i, t, e, s) => (i /= s / 2) < 1 ? e / 2 * i ** 3 + t : e / 2 * ((i - 2) ** 3 + 2) + t, easeInOutElastic: (i, t, e, s) => {\n  const r = e;\n  let n = 0;\n  if (i === 0) return t;\n  if ((i /= s / 2) === 2) return t + e;\n  n || (n = s * (0.3 * 1.5));\n  const { a: o, s: a, p: c, c: l } = Xi(r, e, n, 1.70158);\n  return i < 1 ? -0.5 * Mo(o, a, c, i, s) + t : o * Math.pow(2, -10 * (i -= 1)) * Math.sin((i * s - a) * he / c) * 0.5 + l + t;\n}, easeInOutExpo: (i, t, e, s) => i === 0 ? t : i === s ? t + e : (i /= s / 2) < 1 ? e / 2 * 2 ** (10 * (i - 1)) + t : e / 2 * -(2 ** (-10 * --i) + 2) + t, easeInOutQuad: (i, t, e, s) => (i /= s / 2) < 1 ? e / 2 * i ** 2 + t : -e / 2 * (--i * (i - 2) - 1) + t, easeInOutQuart: (i, t, e, s) => (i /= s / 2) < 1 ? e / 2 * i ** 4 + t : -e / 2 * ((i -= 2) * i ** 3 - 2) + t, easeInOutQuint: (i, t, e, s) => (i /= s / 2) < 1 ? e / 2 * i ** 5 + t : e / 2 * ((i - 2) ** 5 + 2) + t, easeInOutSine: (i, t, e, s) => -e / 2 * (Math.cos(Math.PI * i / s) - 1) + t, easeInQuad: (i, t, e, s) => e * (i /= s) * i + t, easeInQuart: (i, t, e, s) => e * (i /= s) * i ** 3 + t, easeInQuint: (i, t, e, s) => e * (i / s) ** 5 + t, easeInSine: (i, t, e, s) => -e * Math.cos(i / s * xe) + e + t, easeOutBack: function(i, t, e, s) {\n  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;\n  return e * ((i = i / s - 1) * i * ((r + 1) * i + r) + 1) + t;\n}, easeOutBounce: ln, easeOutCirc: (i, t, e, s) => e * Math.sqrt(1 - (i = i / s - 1) * i) + t, easeOutCubic: (i, t, e, s) => e * ((i / s - 1) ** 3 + 1) + t, easeOutElastic: (i, t, e, s) => {\n  const r = e;\n  let n = 0;\n  if (i === 0) return t;\n  if ((i /= s) === 1) return t + e;\n  n || (n = 0.3 * s);\n  const { a: o, s: a, p: c, c: l } = Xi(r, e, n, 1.70158);\n  return o * 2 ** (-10 * i) * Math.sin((i * s - a) * he / c) + l + t;\n}, easeOutExpo: (i, t, e, s) => i === s ? t + e : e * -(2 ** (-10 * i / s) + 1) + t, easeOutQuad: (i, t, e, s) => -e * (i /= s) * (i - 2) + t, easeOutQuart: (i, t, e, s) => -e * ((i = i / s - 1) * i ** 3 - 1) + t, easeOutQuint: (i, t, e, s) => e * ((i / s - 1) ** 5 + 1) + t, easeOutSine: (i, t, e, s) => e * Math.sin(i / s * xe) + t });\nconst Qh = () => !1;\nclass Nn {\n  constructor(t) {\n    let { startValue: e, byValue: s, duration: r = 500, delay: n = 0, easing: o = uc, onStart: a = Be, onChange: c = Be, onComplete: l = Be, abort: h = Qh, target: u } = t;\n    y(this, \"_state\", \"pending\"), y(this, \"durationProgress\", 0), y(this, \"valueProgress\", 0), this.tick = this.tick.bind(this), this.duration = r, this.delay = n, this.easing = o, this._onStart = a, this._onChange = c, this._onComplete = l, this._abort = h, this.target = u, this.startValue = e, this.byValue = s, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);\n  }\n  get state() {\n    return this._state;\n  }\n  isDone() {\n    return this._state === \"aborted\" || this._state === \"completed\";\n  }\n  start() {\n    const t = (e) => {\n      this._state === \"pending\" && (this.startTime = e || +/* @__PURE__ */ new Date(), this._state = \"running\", this._onStart(), this.tick(this.startTime));\n    };\n    this.register(), this.delay > 0 ? setTimeout(() => Hs(t), this.delay) : Hs(t);\n  }\n  tick(t) {\n    const e = (t || +/* @__PURE__ */ new Date()) - this.startTime, s = Math.min(e, this.duration);\n    this.durationProgress = s / this.duration;\n    const { value: r, valueProgress: n } = this.calculate(s);\n    this.value = Object.freeze(r), this.valueProgress = n, this._state !== \"aborted\" && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = \"aborted\", this.unregister()) : e >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = \"completed\", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), Hs(this.tick)));\n  }\n  register() {\n    qr.push(this);\n  }\n  unregister() {\n    qr.remove(this);\n  }\n  abort() {\n    this._state = \"aborted\", this.unregister();\n  }\n}\nconst tu = [\"startValue\", \"endValue\"];\nclass eu extends Nn {\n  constructor(t) {\n    let { startValue: e = 0, endValue: s = 100 } = t;\n    super(v(v({}, G(t, tu)), {}, { startValue: e, byValue: s - e }));\n  }\n  calculate(t) {\n    const e = this.easing(t, this.startValue, this.byValue, this.duration);\n    return { value: e, valueProgress: Math.abs((e - this.startValue) / this.byValue) };\n  }\n}\nconst su = [\"startValue\", \"endValue\"];\nclass ru extends Nn {\n  constructor(t) {\n    let { startValue: e = [0], endValue: s = [100] } = t;\n    super(v(v({}, G(t, su)), {}, { startValue: e, byValue: s.map((r, n) => r - e[n]) }));\n  }\n  calculate(t) {\n    const e = this.startValue.map((s, r) => this.easing(t, s, this.byValue[r], this.duration, r));\n    return { value: e, valueProgress: Math.abs((e[0] - this.startValue[0]) / this.byValue[0]) };\n  }\n}\nconst iu = [\"startValue\", \"endValue\", \"easing\", \"onChange\", \"onComplete\", \"abort\"], nu = (i, t, e, s) => t + e * (1 - Math.cos(i / s * xe)), zi = (i) => i && ((t, e, s) => i(new W(t).toRgba(), e, s));\nclass ou extends Nn {\n  constructor(t) {\n    let { startValue: e, endValue: s, easing: r = nu, onChange: n, onComplete: o, abort: a } = t, c = G(t, iu);\n    const l = new W(e).getSource(), h = new W(s).getSource();\n    super(v(v({}, c), {}, { startValue: l, byValue: h.map((u, d) => u - l[d]), easing: r, onChange: zi(n), onComplete: zi(o), abort: zi(a) }));\n  }\n  calculate(t) {\n    const [e, s, r, n] = this.startValue.map((a, c) => this.easing(t, a, this.byValue[c], this.duration, c)), o = [...[e, s, r].map(Math.round), ze(0, n, 1)];\n    return { value: o, valueProgress: o.map((a, c) => this.byValue[c] !== 0 ? Math.abs((a - this.startValue[c]) / this.byValue[c]) : 0).find((a) => a !== 0) || 0 };\n  }\n}\nfunction Un(i) {\n  const t = ((e) => Array.isArray(e.startValue) || Array.isArray(e.endValue))(i) ? new ru(i) : new eu(i);\n  return t.start(), t;\n}\nfunction dc(i) {\n  const t = new ou(i);\n  return t.start(), t;\n}\nclass N {\n  constructor(t) {\n    this.status = t, this.points = [];\n  }\n  includes(t) {\n    return this.points.some((e) => e.eq(t));\n  }\n  append() {\n    for (var t = arguments.length, e = new Array(t), s = 0; s < t; s++) e[s] = arguments[s];\n    return this.points = this.points.concat(e.filter((r) => !this.includes(r))), this;\n  }\n  static isPointContained(t, e, s) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];\n    if (e.eq(s)) return t.eq(e);\n    if (e.x === s.x) return t.x === e.x && (r || t.y >= Math.min(e.y, s.y) && t.y <= Math.max(e.y, s.y));\n    if (e.y === s.y) return t.y === e.y && (r || t.x >= Math.min(e.x, s.x) && t.x <= Math.max(e.x, s.x));\n    {\n      const n = Zr(e, s), o = Zr(e, t).divide(n);\n      return r ? Math.abs(o.x) === Math.abs(o.y) : o.x === o.y && o.x >= 0 && o.x <= 1;\n    }\n  }\n  static isPointInPolygon(t, e) {\n    const s = new _(t).setX(Math.min(t.x - 1, ...e.map((n) => n.x)));\n    let r = 0;\n    for (let n = 0; n < e.length; n++) {\n      const o = this.intersectSegmentSegment(e[n], e[(n + 1) % e.length], t, s);\n      if (o.includes(t)) return !0;\n      r += +(o.status === \"Intersection\");\n    }\n    return r % 2 == 1;\n  }\n  static intersectLineLine(t, e, s, r) {\n    let n = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], o = !(arguments.length > 5 && arguments[5] !== void 0) || arguments[5];\n    const a = e.x - t.x, c = e.y - t.y, l = r.x - s.x, h = r.y - s.y, u = t.x - s.x, d = t.y - s.y, f = l * d - h * u, g = a * d - c * u, p = h * a - l * c;\n    if (p !== 0) {\n      const m = f / p, b = g / p;\n      return (n || 0 <= m && m <= 1) && (o || 0 <= b && b <= 1) ? new N(\"Intersection\").append(new _(t.x + m * a, t.y + m * c)) : new N();\n    }\n    if (f === 0 || g === 0) {\n      const m = n || o || N.isPointContained(t, s, r) || N.isPointContained(e, s, r) || N.isPointContained(s, t, e) || N.isPointContained(r, t, e);\n      return new N(m ? \"Coincident\" : void 0);\n    }\n    return new N(\"Parallel\");\n  }\n  static intersectSegmentLine(t, e, s, r) {\n    return N.intersectLineLine(t, e, s, r, !1, !0);\n  }\n  static intersectSegmentSegment(t, e, s, r) {\n    return N.intersectLineLine(t, e, s, r, !1, !1);\n  }\n  static intersectLinePolygon(t, e, s) {\n    let r = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];\n    const n = new N(), o = s.length;\n    for (let a, c, l, h = 0; h < o; h++) {\n      if (a = s[h], c = s[(h + 1) % o], l = N.intersectLineLine(t, e, a, c, r, !1), l.status === \"Coincident\") return l;\n      n.append(...l.points);\n    }\n    return n.points.length > 0 && (n.status = \"Intersection\"), n;\n  }\n  static intersectSegmentPolygon(t, e, s) {\n    return N.intersectLinePolygon(t, e, s, !1);\n  }\n  static intersectPolygonPolygon(t, e) {\n    const s = new N(), r = t.length, n = [];\n    for (let o = 0; o < r; o++) {\n      const a = t[o], c = t[(o + 1) % r], l = N.intersectSegmentPolygon(a, c, e);\n      l.status === \"Coincident\" ? (n.push(l), s.append(a, c)) : s.append(...l.points);\n    }\n    return n.length > 0 && n.length === t.length ? new N(\"Coincident\") : (s.points.length > 0 && (s.status = \"Intersection\"), s);\n  }\n  static intersectPolygonRectangle(t, e, s) {\n    const r = e.min(s), n = e.max(s), o = new _(n.x, r.y), a = new _(r.x, n.y);\n    return N.intersectPolygonPolygon(t, [r, o, n, a]);\n  }\n}\nclass au extends Ha {\n  getX() {\n    return this.getXY().x;\n  }\n  setX(t) {\n    this.setXY(this.getXY().setX(t));\n  }\n  getY() {\n    return this.getXY().y;\n  }\n  setY(t) {\n    this.setXY(this.getXY().setY(t));\n  }\n  getRelativeX() {\n    return this.left;\n  }\n  setRelativeX(t) {\n    this.left = t;\n  }\n  getRelativeY() {\n    return this.top;\n  }\n  setRelativeY(t) {\n    this.top = t;\n  }\n  getXY() {\n    const t = this.getRelativeXY();\n    return this.group ? ot(t, this.group.calcTransformMatrix()) : t;\n  }\n  setXY(t, e, s) {\n    this.group && (t = ot(t, St(this.group.calcTransformMatrix()))), this.setRelativeXY(t, e, s);\n  }\n  getRelativeXY() {\n    return new _(this.left, this.top);\n  }\n  setRelativeXY(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.originX, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.originY;\n    this.setPositionByOrigin(t, e, s);\n  }\n  isStrokeAccountedForInDimensions() {\n    return !1;\n  }\n  getCoords() {\n    const { tl: t, tr: e, br: s, bl: r } = this.aCoords || (this.aCoords = this.calcACoords()), n = [t, e, s, r];\n    if (this.group) {\n      const o = this.group.calcTransformMatrix();\n      return n.map((a) => ot(a, o));\n    }\n    return n;\n  }\n  intersectsWithRect(t, e) {\n    return N.intersectPolygonRectangle(this.getCoords(), t, e).status === \"Intersection\";\n  }\n  intersectsWithObject(t) {\n    const e = N.intersectPolygonPolygon(this.getCoords(), t.getCoords());\n    return e.status === \"Intersection\" || e.status === \"Coincident\" || t.isContainedWithinObject(this) || this.isContainedWithinObject(t);\n  }\n  isContainedWithinObject(t) {\n    return this.getCoords().every((e) => t.containsPoint(e));\n  }\n  isContainedWithinRect(t, e) {\n    const { left: s, top: r, width: n, height: o } = this.getBoundingRect();\n    return s >= t.x && s + n <= e.x && r >= t.y && r + o <= e.y;\n  }\n  isOverlapping(t) {\n    return this.intersectsWithObject(t) || this.isContainedWithinObject(t) || t.isContainedWithinObject(this);\n  }\n  containsPoint(t) {\n    return N.isPointInPolygon(t, this.getCoords());\n  }\n  isOnScreen() {\n    if (!this.canvas) return !1;\n    const { tl: t, br: e } = this.canvas.vptCoords;\n    return !!this.getCoords().some((s) => s.x <= e.x && s.x >= t.x && s.y <= e.y && s.y >= t.y) || !!this.intersectsWithRect(t, e) || this.containsPoint(t.midPointFrom(e));\n  }\n  isPartiallyOnScreen() {\n    if (!this.canvas) return !1;\n    const { tl: t, br: e } = this.canvas.vptCoords;\n    return this.intersectsWithRect(t, e) ? !0 : this.getCoords().every((s) => (s.x >= e.x || s.x <= t.x) && (s.y >= e.y || s.y <= t.y)) && this.containsPoint(t.midPointFrom(e));\n  }\n  getBoundingRect() {\n    return Gt(this.getCoords());\n  }\n  getScaledWidth() {\n    return this._getTransformedDimensions().x;\n  }\n  getScaledHeight() {\n    return this._getTransformedDimensions().y;\n  }\n  scale(t) {\n    this._set(ut, t), this._set(Tt, t), this.setCoords();\n  }\n  scaleToWidth(t) {\n    const e = this.getBoundingRect().width / this.getScaledWidth();\n    return this.scale(t / this.width / e);\n  }\n  scaleToHeight(t) {\n    const e = this.getBoundingRect().height / this.getScaledHeight();\n    return this.scale(t / this.height / e);\n  }\n  getCanvasRetinaScaling() {\n    var t;\n    return ((t = this.canvas) === null || t === void 0 ? void 0 : t.getRetinaScaling()) || 1;\n  }\n  getTotalAngle() {\n    return this.group ? Ce(Na(this.calcTransformMatrix())) : this.angle;\n  }\n  getViewportTransform() {\n    var t;\n    return ((t = this.canvas) === null || t === void 0 ? void 0 : t.viewportTransform) || ht.concat();\n  }\n  calcACoords() {\n    const t = Is({ angle: this.angle }), { x: e, y: s } = this.getRelativeCenterPoint(), r = Ms(e, s), n = J(r, t), o = this._getTransformedDimensions(), a = o.x / 2, c = o.y / 2;\n    return { tl: ot({ x: -a, y: -c }, n), tr: ot({ x: a, y: -c }, n), bl: ot({ x: -a, y: c }, n), br: ot({ x: a, y: c }, n) };\n  }\n  setCoords() {\n    this.aCoords = this.calcACoords();\n  }\n  transformMatrixKey() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], e = [];\n    return !t && this.group && (e = this.group.transformMatrixKey(t)), e.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, st(this.originX), st(this.originY)), e;\n  }\n  calcTransformMatrix() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], e = this.calcOwnMatrix();\n    if (t || !this.group) return e;\n    const s = this.transformMatrixKey(t), r = this.matrixCache;\n    return r && r.key.every((n, o) => n === s[o]) ? r.value : (this.group && (e = J(this.group.calcTransformMatrix(!1), e)), this.matrixCache = { key: s, value: e }, e);\n  }\n  calcOwnMatrix() {\n    const t = this.transformMatrixKey(!0), e = this.ownMatrixCache;\n    if (e && e.key === t) return e.value;\n    const s = this.getRelativeCenterPoint(), r = { angle: this.angle, translateX: s.x, translateY: s.y, scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }, n = $a(r);\n    return this.ownMatrixCache = { key: t, value: n }, n;\n  }\n  _getNonTransformedDimensions() {\n    return new _(this.width, this.height).scalarAdd(this.strokeWidth);\n  }\n  _calculateCurrentDimensions(t) {\n    return this._getTransformedDimensions(t).transform(this.getViewportTransform(), !0).scalarAdd(2 * this.padding);\n  }\n  _getTransformedDimensions() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const e = v({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, width: this.width, height: this.height, strokeWidth: this.strokeWidth }, t), s = e.strokeWidth;\n    let r = s, n = 0;\n    this.strokeUniform && (r = 0, n = s);\n    const o = e.width + r, a = e.height + r;\n    let c;\n    return c = e.skewX === 0 && e.skewY === 0 ? new _(o * e.scaleX, a * e.scaleY) : yi(o, a, ar(e)), c.scalarAdd(n);\n  }\n  translateToGivenOrigin(t, e, s, r, n) {\n    let o = t.x, a = t.y;\n    const c = st(r) - st(e), l = st(n) - st(s);\n    if (c || l) {\n      const h = this._getTransformedDimensions();\n      o += c * h.x, a += l * h.y;\n    }\n    return new _(o, a);\n  }\n  translateToCenterPoint(t, e, s) {\n    if (e === j && s === j) return t;\n    const r = this.translateToGivenOrigin(t, e, s, j, j);\n    return this.angle ? r.rotate(K(this.angle), t) : r;\n  }\n  translateToOriginPoint(t, e, s) {\n    const r = this.translateToGivenOrigin(t, j, j, e, s);\n    return this.angle ? r.rotate(K(this.angle), t) : r;\n  }\n  getCenterPoint() {\n    const t = this.getRelativeCenterPoint();\n    return this.group ? ot(t, this.group.calcTransformMatrix()) : t;\n  }\n  getRelativeCenterPoint() {\n    return this.translateToCenterPoint(new _(this.left, this.top), this.originX, this.originY);\n  }\n  getPointByOrigin(t, e) {\n    return this.translateToOriginPoint(this.getRelativeCenterPoint(), t, e);\n  }\n  setPositionByOrigin(t, e, s) {\n    const r = this.translateToCenterPoint(t, e, s), n = this.translateToOriginPoint(r, this.originX, this.originY);\n    this.set({ left: n.x, top: n.y });\n  }\n  _getLeftTopCoords() {\n    return this.translateToOriginPoint(this.getRelativeCenterPoint(), L, gt);\n  }\n}\nconst cu = [\"type\"], lu = [\"extraParam\"];\nlet ee = class Gr extends au {\n  static getDefaults() {\n    return Gr.ownDefaults;\n  }\n  get type() {\n    const t = this.constructor.type;\n    return t === \"FabricObject\" ? \"object\" : t.toLowerCase();\n  }\n  set type(t) {\n    Te(\"warn\", \"Setting type has no effect\", t);\n  }\n  constructor(t) {\n    super(), y(this, \"_cacheContext\", null), Object.assign(this, Gr.ownDefaults), this.setOptions(t);\n  }\n  _createCacheCanvas() {\n    this._cacheCanvas = kt(), this._cacheContext = this._cacheCanvas.getContext(\"2d\"), this._updateCacheCanvas(), this.dirty = !0;\n  }\n  _limitCacheSize(t) {\n    const e = t.width, s = t.height, r = A.maxCacheSideLimit, n = A.minCacheSideLimit;\n    if (e <= r && s <= r && e * s <= A.perfLimitSizeTotal) return e < n && (t.width = n), s < n && (t.height = n), t;\n    const o = e / s, [a, c] = zs.limitDimsByArea(o), l = ze(n, a, r), h = ze(n, c, r);\n    return e > l && (t.zoomX /= e / l, t.width = l, t.capped = !0), s > h && (t.zoomY /= s / h, t.height = h, t.capped = !0), t;\n  }\n  _getCacheCanvasDimensions() {\n    const t = this.getTotalObjectScaling(), e = this._getTransformedDimensions({ skewX: 0, skewY: 0 }), s = e.x * t.x / this.scaleX, r = e.y * t.y / this.scaleY;\n    return { width: Math.ceil(s + 2), height: Math.ceil(r + 2), zoomX: t.x, zoomY: t.y, x: s, y: r };\n  }\n  _updateCacheCanvas() {\n    const t = this._cacheCanvas, e = this._cacheContext, { width: s, height: r, zoomX: n, zoomY: o, x: a, y: c } = this._limitCacheSize(this._getCacheCanvasDimensions()), l = s !== t.width || r !== t.height, h = this.zoomX !== n || this.zoomY !== o;\n    if (!t || !e) return !1;\n    if (l || h) {\n      s !== t.width || r !== t.height ? (t.width = s, t.height = r) : (e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, t.width, t.height));\n      const u = a / 2, d = c / 2;\n      return this.cacheTranslationX = Math.round(t.width / 2 - u) + u, this.cacheTranslationY = Math.round(t.height / 2 - d) + d, e.translate(this.cacheTranslationX, this.cacheTranslationY), e.scale(n, o), this.zoomX = n, this.zoomY = o, !0;\n    }\n    return !1;\n  }\n  setOptions() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this._setOptions(t);\n  }\n  transform(t) {\n    const e = this.group && !this.group._transformDone || this.group && this.canvas && t === this.canvas.contextTop, s = this.calcTransformMatrix(!e);\n    t.transform(s[0], s[1], s[2], s[3], s[4], s[5]);\n  }\n  getObjectScaling() {\n    if (!this.group) return new _(Math.abs(this.scaleX), Math.abs(this.scaleY));\n    const t = ys(this.calcTransformMatrix());\n    return new _(Math.abs(t.scaleX), Math.abs(t.scaleY));\n  }\n  getTotalObjectScaling() {\n    const t = this.getObjectScaling();\n    if (this.canvas) {\n      const e = this.canvas.getZoom(), s = this.getCanvasRetinaScaling();\n      return t.scalarMultiply(e * s);\n    }\n    return t;\n  }\n  getObjectOpacity() {\n    let t = this.opacity;\n    return this.group && (t *= this.group.getObjectOpacity()), t;\n  }\n  _constrainScale(t) {\n    return Math.abs(t) < this.minScaleLimit ? t < 0 ? -this.minScaleLimit : this.minScaleLimit : t === 0 ? 1e-4 : t;\n  }\n  _set(t, e) {\n    t !== ut && t !== Tt || (e = this._constrainScale(e)), t === ut && e < 0 ? (this.flipX = !this.flipX, e *= -1) : t === \"scaleY\" && e < 0 ? (this.flipY = !this.flipY, e *= -1) : t !== \"shadow\" || !e || e instanceof ce || (e = new ce(e));\n    const s = this[t] !== e;\n    return this[t] = e, s && this.constructor.cacheProperties.includes(t) && (this.dirty = !0), this.parent && (this.dirty || s && this.constructor.stateProperties.includes(t)) && this.parent._set(\"dirty\", !0), this;\n  }\n  isNotVisible() {\n    return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;\n  }\n  render(t) {\n    this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (t.save(), this._setupCompositeOperation(t), this.drawSelectionBackground(t), this.transform(t), this._setOpacity(t), this._setShadow(t), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(t)) : (this._removeCacheCanvas(), this.drawObject(t, !1, {}), this.dirty = !1), t.restore());\n  }\n  drawSelectionBackground(t) {\n  }\n  renderCache(t) {\n    if (t = t || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext) {\n      const { zoomX: e, zoomY: s, cacheTranslationX: r, cacheTranslationY: n } = this, { width: o, height: a } = this._cacheCanvas;\n      this.drawObject(this._cacheContext, t.forClipping, { zoomX: e, zoomY: s, cacheTranslationX: r, cacheTranslationY: n, width: o, height: a, parentClipPaths: [] }), this.dirty = !1;\n    }\n  }\n  _removeCacheCanvas() {\n    this._cacheCanvas = void 0, this._cacheContext = null;\n  }\n  hasStroke() {\n    return this.stroke && this.stroke !== \"transparent\" && this.strokeWidth !== 0;\n  }\n  hasFill() {\n    return this.fill && this.fill !== \"transparent\";\n  }\n  needsItsOwnCache() {\n    return !!(this.paintFirst === mt && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;\n  }\n  shouldCache() {\n    return this.ownCaching = this.objectCaching && (!this.parent || !this.parent.isOnACache()) || this.needsItsOwnCache(), this.ownCaching;\n  }\n  willDrawShadow() {\n    return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);\n  }\n  drawClipPathOnCache(t, e, s) {\n    t.save(), e.inverted ? t.globalCompositeOperation = \"destination-out\" : t.globalCompositeOperation = \"destination-in\", t.setTransform(1, 0, 0, 1, 0, 0), t.drawImage(s, 0, 0), t.restore();\n  }\n  drawObject(t, e, s) {\n    const r = this.fill, n = this.stroke;\n    e ? (this.fill = \"black\", this.stroke = \"\", this._setClippingProperties(t)) : this._renderBackground(t), this._render(t), this._drawClipPath(t, this.clipPath, s), this.fill = r, this.stroke = n;\n  }\n  createClipPathLayer(t, e) {\n    const s = Wt(e), r = s.getContext(\"2d\");\n    if (r.translate(e.cacheTranslationX, e.cacheTranslationY), r.scale(e.zoomX, e.zoomY), t._cacheCanvas = s, e.parentClipPaths.forEach((n) => {\n      n.transform(r);\n    }), e.parentClipPaths.push(t), t.absolutePositioned) {\n      const n = St(this.calcTransformMatrix());\n      r.transform(n[0], n[1], n[2], n[3], n[4], n[5]);\n    }\n    return t.transform(r), t.drawObject(r, !0, e), s;\n  }\n  _drawClipPath(t, e, s) {\n    if (!e) return;\n    e._transformDone = !0;\n    const r = this.createClipPathLayer(e, s);\n    this.drawClipPathOnCache(t, e, r);\n  }\n  drawCacheOnCanvas(t) {\n    t.scale(1 / this.zoomX, 1 / this.zoomY), t.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);\n  }\n  isCacheDirty() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];\n    if (this.isNotVisible()) return !1;\n    const e = this._cacheCanvas, s = this._cacheContext;\n    return !(!e || !s || t || !this._updateCacheCanvas()) || !!(this.dirty || this.clipPath && this.clipPath.absolutePositioned) && (e && s && !t && (s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, e.width, e.height), s.restore()), !0);\n  }\n  _renderBackground(t) {\n    if (!this.backgroundColor) return;\n    const e = this._getNonTransformedDimensions();\n    t.fillStyle = this.backgroundColor, t.fillRect(-e.x / 2, -e.y / 2, e.x, e.y), this._removeShadow(t);\n  }\n  _setOpacity(t) {\n    this.group && !this.group._transformDone ? t.globalAlpha = this.getObjectOpacity() : t.globalAlpha *= this.opacity;\n  }\n  _setStrokeStyles(t, e) {\n    const s = e.stroke;\n    s && (t.lineWidth = e.strokeWidth, t.lineCap = e.strokeLineCap, t.lineDashOffset = e.strokeDashOffset, t.lineJoin = e.strokeLineJoin, t.miterLimit = e.strokeMiterLimit, Ct(s) ? s.gradientUnits === \"percentage\" || s.gradientTransform || s.patternTransform ? this._applyPatternForTransformedGradient(t, s) : (t.strokeStyle = s.toLive(t), this._applyPatternGradientTransform(t, s)) : t.strokeStyle = e.stroke);\n  }\n  _setFillStyles(t, e) {\n    let { fill: s } = e;\n    s && (Ct(s) ? (t.fillStyle = s.toLive(t), this._applyPatternGradientTransform(t, s)) : t.fillStyle = s);\n  }\n  _setClippingProperties(t) {\n    t.globalAlpha = 1, t.strokeStyle = \"transparent\", t.fillStyle = \"#000000\";\n  }\n  _setLineDash(t, e) {\n    e && e.length !== 0 && t.setLineDash(e);\n  }\n  _setShadow(t) {\n    if (!this.shadow) return;\n    const e = this.shadow, s = this.canvas, r = this.getCanvasRetinaScaling(), [n, , , o] = (s == null ? void 0 : s.viewportTransform) || ht, a = n * r, c = o * r, l = e.nonScaling ? new _(1, 1) : this.getObjectScaling();\n    t.shadowColor = e.color, t.shadowBlur = e.blur * A.browserShadowBlurConstant * (a + c) * (l.x + l.y) / 4, t.shadowOffsetX = e.offsetX * a * l.x, t.shadowOffsetY = e.offsetY * c * l.y;\n  }\n  _removeShadow(t) {\n    this.shadow && (t.shadowColor = \"\", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0);\n  }\n  _applyPatternGradientTransform(t, e) {\n    if (!Ct(e)) return { offsetX: 0, offsetY: 0 };\n    const s = e.gradientTransform || e.patternTransform, r = -this.width / 2 + e.offsetX || 0, n = -this.height / 2 + e.offsetY || 0;\n    return e.gradientUnits === \"percentage\" ? t.transform(this.width, 0, 0, this.height, r, n) : t.transform(1, 0, 0, 1, r, n), s && t.transform(s[0], s[1], s[2], s[3], s[4], s[5]), { offsetX: r, offsetY: n };\n  }\n  _renderPaintInOrder(t) {\n    this.paintFirst === mt ? (this._renderStroke(t), this._renderFill(t)) : (this._renderFill(t), this._renderStroke(t));\n  }\n  _render(t) {\n  }\n  _renderFill(t) {\n    this.fill && (t.save(), this._setFillStyles(t, this), this.fillRule === \"evenodd\" ? t.fill(\"evenodd\") : t.fill(), t.restore());\n  }\n  _renderStroke(t) {\n    if (this.stroke && this.strokeWidth !== 0) {\n      if (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this.strokeUniform) {\n        const e = this.getObjectScaling();\n        t.scale(1 / e.x, 1 / e.y);\n      }\n      this._setLineDash(t, this.strokeDashArray), this._setStrokeStyles(t, this), t.stroke(), t.restore();\n    }\n  }\n  _applyPatternForTransformedGradient(t, e) {\n    var s;\n    const r = this._limitCacheSize(this._getCacheCanvasDimensions()), n = this.getCanvasRetinaScaling(), o = r.x / this.scaleX / n, a = r.y / this.scaleY / n, c = Wt({ width: Math.ceil(o), height: Math.ceil(a) }), l = c.getContext(\"2d\");\n    l && (l.beginPath(), l.moveTo(0, 0), l.lineTo(o, 0), l.lineTo(o, a), l.lineTo(0, a), l.closePath(), l.translate(o / 2, a / 2), l.scale(r.zoomX / this.scaleX / n, r.zoomY / this.scaleY / n), this._applyPatternGradientTransform(l, e), l.fillStyle = e.toLive(t), l.fill(), t.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), t.scale(n * this.scaleX / r.zoomX, n * this.scaleY / r.zoomY), t.strokeStyle = (s = l.createPattern(c, \"no-repeat\")) !== null && s !== void 0 ? s : \"\");\n  }\n  _findCenterFromElement() {\n    return new _(this.left + this.width / 2, this.top + this.height / 2);\n  }\n  clone(t) {\n    const e = this.toObject(t);\n    return this.constructor.fromObject(e);\n  }\n  cloneAsImage(t) {\n    const e = this.toCanvasElement(t);\n    return new (C.getClass(\"image\"))(e);\n  }\n  toCanvasElement() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const e = zn(this), s = this.group, r = this.shadow, n = Math.abs, o = t.enableRetinaScaling ? Ra() : 1, a = (t.multiplier || 1) * o, c = t.canvasProvider || ((S) => new lr(S, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }));\n    delete this.group, t.withoutTransform && sc(this), t.withoutShadow && (this.shadow = null), t.viewportTransform && an(this, this.getViewportTransform()), this.setCoords();\n    const l = kt(), h = this.getBoundingRect(), u = this.shadow, d = new _();\n    if (u) {\n      const S = u.blur, w = u.nonScaling ? new _(1, 1) : this.getObjectScaling();\n      d.x = 2 * Math.round(n(u.offsetX) + S) * n(w.x), d.y = 2 * Math.round(n(u.offsetY) + S) * n(w.y);\n    }\n    const f = h.width + d.x, g = h.height + d.y;\n    l.width = Math.ceil(f), l.height = Math.ceil(g);\n    const p = c(l);\n    t.format === \"jpeg\" && (p.backgroundColor = \"#fff\"), this.setPositionByOrigin(new _(p.width / 2, p.height / 2), j, j);\n    const m = this.canvas;\n    p._objects = [this], this.set(\"canvas\", p), this.setCoords();\n    const b = p.toCanvasElement(a || 1, t);\n    return this.set(\"canvas\", m), this.shadow = r, s && (this.group = s), this.set(e), this.setCoords(), p._objects = [], p.destroy(), b;\n  }\n  toDataURL() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return Rn(this.toCanvasElement(t), t.format || \"png\", t.quality || 1);\n  }\n  toBlob() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return Ln(this.toCanvasElement(t), t.format || \"png\", t.quality || 1);\n  }\n  isType() {\n    for (var t = arguments.length, e = new Array(t), s = 0; s < t; s++) e[s] = arguments[s];\n    return e.includes(this.constructor.type) || e.includes(this.type);\n  }\n  complexity() {\n    return 1;\n  }\n  toJSON() {\n    return this.toObject();\n  }\n  rotate(t) {\n    const { centeredRotation: e, originX: s, originY: r } = this;\n    if (e) {\n      const { x: n, y: o } = this.getRelativeCenterPoint();\n      this.originX = j, this.originY = j, this.left = n, this.top = o;\n    }\n    if (this.set(\"angle\", t), e) {\n      const { x: n, y: o } = this.translateToOriginPoint(this.getRelativeCenterPoint(), s, r);\n      this.left = n, this.top = o, this.originX = s, this.originY = r;\n    }\n  }\n  setOnGroup() {\n  }\n  _setupCompositeOperation(t) {\n    this.globalCompositeOperation && (t.globalCompositeOperation = this.globalCompositeOperation);\n  }\n  dispose() {\n    qr.cancelByTarget(this), this.off(), this._set(\"canvas\", void 0), this._cacheCanvas && $t().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;\n  }\n  animate(t, e) {\n    return Object.entries(t).reduce((s, r) => {\n      let [n, o] = r;\n      return s[n] = this._animate(n, o, e), s;\n    }, {});\n  }\n  _animate(t, e) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const r = t.split(\".\"), n = this.constructor.colorProperties.includes(r[r.length - 1]), { abort: o, startValue: a, onChange: c, onComplete: l } = s, h = v(v({}, s), {}, { target: this, startValue: a ?? r.reduce((u, d) => u[d], this), endValue: e, abort: o == null ? void 0 : o.bind(this), onChange: (u, d, f) => {\n      r.reduce((g, p, m) => (m === r.length - 1 && (g[p] = u), g[p]), this), c && c(u, d, f);\n    }, onComplete: (u, d, f) => {\n      this.setCoords(), l && l(u, d, f);\n    } });\n    return n ? dc(h) : Un(h);\n  }\n  isDescendantOf(t) {\n    const { parent: e, group: s } = this;\n    return e === t || s === t || !!e && e.isDescendantOf(t) || !!s && s !== e && s.isDescendantOf(t);\n  }\n  getAncestors() {\n    const t = [];\n    let e = this;\n    do\n      e = e.parent, e && t.push(e);\n    while (e);\n    return t;\n  }\n  findCommonAncestors(t) {\n    if (this === t) return { fork: [], otherFork: [], common: [this, ...this.getAncestors()] };\n    const e = this.getAncestors(), s = t.getAncestors();\n    if (e.length === 0 && s.length > 0 && this === s[s.length - 1]) return { fork: [], otherFork: [t, ...s.slice(0, s.length - 1)], common: [this] };\n    for (let r, n = 0; n < e.length; n++) {\n      if (r = e[n], r === t) return { fork: [this, ...e.slice(0, n)], otherFork: [], common: e.slice(n) };\n      for (let o = 0; o < s.length; o++) {\n        if (this === s[o]) return { fork: [], otherFork: [t, ...s.slice(0, o)], common: [this, ...e] };\n        if (r === s[o]) return { fork: [this, ...e.slice(0, n)], otherFork: [t, ...s.slice(0, o)], common: e.slice(n) };\n      }\n    }\n    return { fork: [this, ...e], otherFork: [t, ...s], common: [] };\n  }\n  hasCommonAncestors(t) {\n    const e = this.findCommonAncestors(t);\n    return e && !!e.common.length;\n  }\n  isInFrontOf(t) {\n    if (this === t) return;\n    const e = this.findCommonAncestors(t);\n    if (e.fork.includes(t)) return !0;\n    if (e.otherFork.includes(this)) return !1;\n    const s = e.common[0] || this.canvas;\n    if (!s) return;\n    const r = e.fork.pop(), n = e.otherFork.pop(), o = s._objects.indexOf(r), a = s._objects.indexOf(n);\n    return o > -1 && o > a;\n  }\n  toObject() {\n    const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).concat(Gr.customProperties, this.constructor.customProperties || []);\n    let e;\n    const s = A.NUM_FRACTION_DIGITS, { clipPath: r, fill: n, stroke: o, shadow: a, strokeDashArray: c, left: l, top: h, originX: u, originY: d, width: f, height: g, strokeWidth: p, strokeLineCap: m, strokeDashOffset: b, strokeLineJoin: S, strokeUniform: w, strokeMiterLimit: k, scaleX: O, scaleY: x, angle: I, flipX: M, flipY: E, opacity: R, visible: tt, backgroundColor: F, fillRule: B, paintFirst: $, globalCompositeOperation: yt, skewX: dt, skewY: Dt } = this;\n    r && !r.excludeFromExport && (e = r.toObject(t.concat(\"inverted\", \"absolutePositioned\")));\n    const q = (te) => V(te, s), zt = v(v({}, Ve(this, t)), {}, { type: this.constructor.type, version: sn, originX: u, originY: d, left: q(l), top: q(h), width: q(f), height: q(g), fill: _o(n) ? n.toObject() : n, stroke: _o(o) ? o.toObject() : o, strokeWidth: q(p), strokeDashArray: c && c.concat(), strokeLineCap: m, strokeDashOffset: b, strokeLineJoin: S, strokeUniform: w, strokeMiterLimit: q(k), scaleX: q(O), scaleY: q(x), angle: q(I), flipX: M, flipY: E, opacity: q(R), shadow: a && a.toObject(), visible: tt, backgroundColor: F, fillRule: B, paintFirst: $, globalCompositeOperation: yt, skewX: q(dt), skewY: q(Dt) }, e ? { clipPath: e } : null);\n    return this.includeDefaultValues ? zt : this._removeDefaultValues(zt);\n  }\n  toDatalessObject(t) {\n    return this.toObject(t);\n  }\n  _removeDefaultValues(t) {\n    const e = this.constructor.getDefaults(), s = Object.keys(e).length > 0 ? e : Object.getPrototypeOf(this);\n    return Xn(t, (r, n) => {\n      if (n === L || n === gt || n === \"type\") return !0;\n      const o = s[n];\n      return r !== o && !(Array.isArray(r) && Array.isArray(o) && r.length === 0 && o.length === 0);\n    });\n  }\n  toString() {\n    return \"#<\".concat(this.constructor.type, \">\");\n  }\n  static _fromObject(t) {\n    let e = G(t, cu), s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { extraParam: r } = s, n = G(s, lu);\n    return cr(e, n).then((o) => r ? (delete o[r], new this(e[r], o)) : new this(o));\n  }\n  static fromObject(t, e) {\n    return this._fromObject(t, e);\n  }\n};\ny(ee, \"stateProperties\", Kh), y(ee, \"cacheProperties\", de), y(ee, \"ownDefaults\", Jh), y(ee, \"type\", \"FabricObject\"), y(ee, \"colorProperties\", [rt, mt, \"backgroundColor\"]), y(ee, \"customProperties\", []), C.setClass(ee), C.setClass(ee, \"object\");\nconst Ie = (i, t, e) => (s, r, n, o) => {\n  const a = t(s, r, n, o);\n  return a && Hn(i, v(v({}, Yn(s, r, n, o)), e)), a;\n};\nfunction Ge(i) {\n  return (t, e, s, r) => {\n    const { target: n, originX: o, originY: a } = e, c = n.getRelativeCenterPoint(), l = n.translateToOriginPoint(c, o, a), h = i(t, e, s, r);\n    return n.setPositionByOrigin(l, e.originX, e.originY), h;\n  };\n}\nconst hn = Ie($s, Ge((i, t, e, s) => {\n  const r = bi(t, t.originX, t.originY, e, s);\n  if (st(t.originX) === st(j) || st(t.originX) === st(Z) && r.x < 0 || st(t.originX) === st(L) && r.x > 0) {\n    const { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = ic(t) ? 2 : 1, c = n.width, l = Math.abs(r.x * a / n.scaleX) - o;\n    return n.set(\"width\", Math.max(l, 1)), c !== n.width;\n  }\n  return !1;\n}));\nfunction fc(i, t, e, s, r) {\n  s = s || {};\n  const n = this.sizeX || s.cornerSize || r.cornerSize, o = this.sizeY || s.cornerSize || r.cornerSize, a = s.transparentCorners !== void 0 ? s.transparentCorners : r.transparentCorners, c = a ? mt : rt, l = !a && (s.cornerStrokeColor || r.cornerStrokeColor);\n  let h, u = t, d = e;\n  i.save(), i.fillStyle = s.cornerColor || r.cornerColor || \"\", i.strokeStyle = s.cornerStrokeColor || r.cornerStrokeColor || \"\", n > o ? (h = n, i.scale(1, o / n), d = e * n / o) : o > n ? (h = o, i.scale(n / o, 1), u = t * o / n) : h = n, i.beginPath(), i.arc(u, d, h / 2, 0, he, !1), i[c](), l && i.stroke(), i.restore();\n}\nfunction gc(i, t, e, s, r) {\n  s = s || {};\n  const n = this.sizeX || s.cornerSize || r.cornerSize, o = this.sizeY || s.cornerSize || r.cornerSize, a = s.transparentCorners !== void 0 ? s.transparentCorners : r.transparentCorners, c = a ? mt : rt, l = !a && (s.cornerStrokeColor || r.cornerStrokeColor), h = n / 2, u = o / 2;\n  i.save(), i.fillStyle = s.cornerColor || r.cornerColor || \"\", i.strokeStyle = s.cornerStrokeColor || r.cornerStrokeColor || \"\", i.translate(t, e);\n  const d = r.getTotalAngle();\n  i.rotate(K(d)), i[\"\".concat(c, \"Rect\")](-h, -u, n, o), l && i.strokeRect(-h, -u, n, o), i.restore();\n}\nclass U {\n  constructor(t) {\n    y(this, \"visible\", !0), y(this, \"actionName\", pi), y(this, \"angle\", 0), y(this, \"x\", 0), y(this, \"y\", 0), y(this, \"offsetX\", 0), y(this, \"offsetY\", 0), y(this, \"sizeX\", 0), y(this, \"sizeY\", 0), y(this, \"touchSizeX\", 0), y(this, \"touchSizeY\", 0), y(this, \"cursorStyle\", \"crosshair\"), y(this, \"withConnection\", !1), Object.assign(this, t);\n  }\n  shouldActivate(t, e, s, r) {\n    var n;\n    let { tl: o, tr: a, br: c, bl: l } = r;\n    return ((n = e.canvas) === null || n === void 0 ? void 0 : n.getActiveObject()) === e && e.isControlVisible(t) && N.isPointInPolygon(s, [o, a, c, l]);\n  }\n  getActionHandler(t, e, s) {\n    return this.actionHandler;\n  }\n  getMouseDownHandler(t, e, s) {\n    return this.mouseDownHandler;\n  }\n  getMouseUpHandler(t, e, s) {\n    return this.mouseUpHandler;\n  }\n  cursorStyleHandler(t, e, s) {\n    return e.cursorStyle;\n  }\n  getActionName(t, e, s) {\n    return e.actionName;\n  }\n  getVisibility(t, e) {\n    var s, r;\n    return (s = (r = t._controlsVisibility) === null || r === void 0 ? void 0 : r[e]) !== null && s !== void 0 ? s : this.visible;\n  }\n  setVisibility(t, e, s) {\n    this.visible = t;\n  }\n  positionHandler(t, e, s, r) {\n    return new _(this.x * t.x + this.offsetX, this.y * t.y + this.offsetY).transform(e);\n  }\n  calcCornerCoords(t, e, s, r, n, o) {\n    const a = mi([Ms(s, r), Is({ angle: t }), vi((n ? this.touchSizeX : this.sizeX) || e, (n ? this.touchSizeY : this.sizeY) || e)]);\n    return { tl: new _(-0.5, -0.5).transform(a), tr: new _(0.5, -0.5).transform(a), br: new _(0.5, 0.5).transform(a), bl: new _(-0.5, 0.5).transform(a) };\n  }\n  render(t, e, s, r, n) {\n    ((r = r || {}).cornerStyle || n.cornerStyle) === \"circle\" ? fc.call(this, t, e, s, r, n) : gc.call(this, t, e, s, r, n);\n  }\n}\nconst pc = (i, t, e) => e.lockRotation ? Jr : t.cursorStyle, mc = Ie(Ba, Ge((i, t, e, s) => {\n  let { target: r, ex: n, ey: o, theta: a, originX: c, originY: l } = t;\n  const h = r.translateToOriginPoint(r.getRelativeCenterPoint(), c, l);\n  if (Rt(r, \"lockRotation\")) return !1;\n  const u = Math.atan2(o - h.y, n - h.x), d = Math.atan2(s - h.y, e - h.x);\n  let f = Ce(d - u + a);\n  if (r.snapAngle && r.snapAngle > 0) {\n    const p = r.snapAngle, m = r.snapThreshold || p, b = Math.ceil(f / p) * p, S = Math.floor(f / p) * p;\n    Math.abs(f - S) < m ? f = S : Math.abs(f - b) < m && (f = b);\n  }\n  f < 0 && (f = 360 + f), f %= 360;\n  const g = r.angle !== f;\n  return r.angle = f, g;\n}));\nfunction vc(i, t) {\n  const e = t.canvas, s = i[e.uniScaleKey];\n  return e.uniformScaling && !s || !e.uniformScaling && s;\n}\nfunction yc(i, t, e) {\n  const s = Rt(i, \"lockScalingX\"), r = Rt(i, \"lockScalingY\");\n  if (s && r || !t && (s || r) && e || s && t === \"x\" || r && t === \"y\") return !0;\n  const { width: n, height: o, strokeWidth: a } = i;\n  return n === 0 && a === 0 && t !== \"y\" || o === 0 && a === 0 && t !== \"x\";\n}\nconst hu = [\"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", \"n\", \"ne\", \"e\"], Ze = (i, t, e) => {\n  const s = vc(i, e);\n  if (yc(e, t.x !== 0 && t.y === 0 ? \"x\" : t.x === 0 && t.y !== 0 ? \"y\" : \"\", s)) return Jr;\n  const r = nc(e, t);\n  return \"\".concat(hu[r], \"-resize\");\n};\nfunction $n(i, t, e, s) {\n  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};\n  const n = t.target, o = r.by, a = vc(i, n);\n  let c, l, h, u, d, f;\n  if (yc(n, o, a)) return !1;\n  if (t.gestureScale) l = t.scaleX * t.gestureScale, h = t.scaleY * t.gestureScale;\n  else {\n    if (c = bi(t, t.originX, t.originY, e, s), d = o !== \"y\" ? Math.sign(c.x || t.signX || 1) : 1, f = o !== \"x\" ? Math.sign(c.y || t.signY || 1) : 1, t.signX || (t.signX = d), t.signY || (t.signY = f), Rt(n, \"lockScalingFlip\") && (t.signX !== d || t.signY !== f)) return !1;\n    if (u = n._getTransformedDimensions(), a && !o) {\n      const m = Math.abs(c.x) + Math.abs(c.y), { original: b } = t, S = m / (Math.abs(u.x * b.scaleX / n.scaleX) + Math.abs(u.y * b.scaleY / n.scaleY));\n      l = b.scaleX * S, h = b.scaleY * S;\n    } else l = Math.abs(c.x * n.scaleX / u.x), h = Math.abs(c.y * n.scaleY / u.y);\n    ic(t) && (l *= 2, h *= 2), t.signX !== d && o !== \"y\" && (t.originX = xo(t.originX), l *= -1, t.signX = d), t.signY !== f && o !== \"x\" && (t.originY = xo(t.originY), h *= -1, t.signY = f);\n  }\n  const g = n.scaleX, p = n.scaleY;\n  return o ? (o === \"x\" && n.set(ut, l), o === \"y\" && n.set(Tt, h)) : (!Rt(n, \"lockScalingX\") && n.set(ut, l), !Rt(n, \"lockScalingY\") && n.set(Tt, h)), g !== n.scaleX || p !== n.scaleY;\n}\nconst Ls = Ie(gi, Ge((i, t, e, s) => $n(i, t, e, s))), bc = Ie(gi, Ge((i, t, e, s) => $n(i, t, e, s, { by: \"x\" }))), _c = Ie(gi, Ge((i, t, e, s) => $n(i, t, e, s, { by: \"y\" }))), uu = [\"target\", \"ex\", \"ey\", \"skewingSide\"], Hi = { x: { counterAxis: \"y\", scale: ut, skew: Os, lockSkewing: \"lockSkewingX\", origin: \"originX\", flip: \"flipX\" }, y: { counterAxis: \"x\", scale: Tt, skew: ks, lockSkewing: \"lockSkewingY\", origin: \"originY\", flip: \"flipY\" } }, du = [\"ns\", \"nesw\", \"ew\", \"nwse\"], Sc = (i, t, e) => {\n  if (t.x !== 0 && Rt(e, \"lockSkewingY\") || t.y !== 0 && Rt(e, \"lockSkewingX\")) return Jr;\n  const s = nc(e, t) % 4;\n  return \"\".concat(du[s], \"-resize\");\n};\nfunction Tc(i, t, e, s, r) {\n  const { target: n } = e, { counterAxis: o, origin: a, lockSkewing: c, skew: l, flip: h } = Hi[i];\n  if (Rt(n, c)) return !1;\n  const { origin: u, flip: d } = Hi[o], f = st(e[u]) * (n[d] ? -1 : 1), g = -Math.sign(f) * (n[h] ? -1 : 1), p = 0.5 * -((n[l] === 0 && bi(e, j, j, s, r)[i] > 0 || n[l] > 0 ? 1 : -1) * g) + 0.5;\n  return Ie(Wa, Ge((b, S, w, k) => function(O, x, I) {\n    let { target: M, ex: E, ey: R, skewingSide: tt } = x, F = G(x, uu);\n    const { skew: B } = Hi[O], $ = I.subtract(new _(E, R)).divide(new _(M.scaleX, M.scaleY))[O], yt = M[B], dt = F[B], Dt = Math.tan(K(dt)), q = O === \"y\" ? M._getTransformedDimensions({ scaleX: 1, scaleY: 1, skewX: 0 }).x : M._getTransformedDimensions({ scaleX: 1, scaleY: 1 }).y, zt = 2 * $ * tt / Math.max(q, 1) + Dt, te = Ce(Math.atan(zt));\n    M.set(B, te);\n    const pr = yt !== M[B];\n    if (pr && O === \"y\") {\n      const { skewX: Ai, scaleX: Ps } = M, me = M._getTransformedDimensions({ skewY: yt }), mr = M._getTransformedDimensions(), je = Ai !== 0 ? me.x / mr.x : 1;\n      je !== 1 && M.set(ut, je * Ps);\n    }\n    return pr;\n  }(i, S, new _(w, k))))(t, v(v({}, e), {}, { [a]: p, skewingSide: g }), s, r);\n}\nconst xc = (i, t, e, s) => Tc(\"x\", i, t, e, s), wc = (i, t, e, s) => Tc(\"y\", i, t, e, s);\nfunction Ti(i, t) {\n  return i[t.canvas.altActionKey];\n}\nconst Bs = (i, t, e) => {\n  const s = Ti(i, e);\n  return t.x === 0 ? s ? Os : Tt : t.y === 0 ? s ? ks : ut : \"\";\n}, Fe = (i, t, e) => Ti(i, e) ? Sc(0, t, e) : Ze(i, t, e), un = (i, t, e, s) => Ti(i, t.target) ? wc(i, t, e, s) : bc(i, t, e, s), dn = (i, t, e, s) => Ti(i, t.target) ? xc(i, t, e, s) : _c(i, t, e, s), qn = () => ({ ml: new U({ x: -0.5, y: 0, cursorStyleHandler: Fe, actionHandler: un, getActionName: Bs }), mr: new U({ x: 0.5, y: 0, cursorStyleHandler: Fe, actionHandler: un, getActionName: Bs }), mb: new U({ x: 0, y: 0.5, cursorStyleHandler: Fe, actionHandler: dn, getActionName: Bs }), mt: new U({ x: 0, y: -0.5, cursorStyleHandler: Fe, actionHandler: dn, getActionName: Bs }), tl: new U({ x: -0.5, y: -0.5, cursorStyleHandler: Ze, actionHandler: Ls }), tr: new U({ x: 0.5, y: -0.5, cursorStyleHandler: Ze, actionHandler: Ls }), bl: new U({ x: -0.5, y: 0.5, cursorStyleHandler: Ze, actionHandler: Ls }), br: new U({ x: 0.5, y: 0.5, cursorStyleHandler: Ze, actionHandler: Ls }), mtr: new U({ x: 0, y: -0.5, actionHandler: mc, cursorStyleHandler: pc, offsetY: -40, withConnection: !0, actionName: An }) }), Cc = () => ({ mr: new U({ x: 0.5, y: 0, actionHandler: hn, cursorStyleHandler: Fe, actionName: $s }), ml: new U({ x: -0.5, y: 0, actionHandler: hn, cursorStyleHandler: Fe, actionName: $s }) }), Oc = () => v(v({}, qn()), Cc());\nclass Js extends ee {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), Js.ownDefaults);\n  }\n  constructor(t) {\n    super(), Object.assign(this, this.constructor.createControls(), Js.ownDefaults), this.setOptions(t);\n  }\n  static createControls() {\n    return { controls: qn() };\n  }\n  _updateCacheCanvas() {\n    const t = this.canvas;\n    if (this.noScaleCache && t && t._currentTransform) {\n      const e = t._currentTransform, s = e.target, r = e.action;\n      if (this === s && r && r.startsWith(pi)) return !1;\n    }\n    return super._updateCacheCanvas();\n  }\n  getActiveControl() {\n    const t = this.__corner;\n    return t ? { key: t, control: this.controls[t], coord: this.oCoords[t] } : void 0;\n  }\n  findControl(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];\n    if (!this.hasControls || !this.canvas) return;\n    this.__corner = void 0;\n    const s = Object.entries(this.oCoords);\n    for (let r = s.length - 1; r >= 0; r--) {\n      const [n, o] = s[r], a = this.controls[n];\n      if (a.shouldActivate(n, this, t, e ? o.touchCorner : o.corner)) return this.__corner = n, { key: n, control: a, coord: this.oCoords[n] };\n    }\n  }\n  calcOCoords() {\n    const t = this.getViewportTransform(), e = this.getCenterPoint(), s = Ms(e.x, e.y), r = Is({ angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0) }), n = J(s, r), o = J(t, n), a = J(o, [1 / t[0], 0, 0, 1 / t[3], 0, 0]), c = this.group ? ys(this.calcTransformMatrix()) : void 0;\n    c && (c.scaleX = Math.abs(c.scaleX), c.scaleY = Math.abs(c.scaleY));\n    const l = this._calculateCurrentDimensions(c), h = {};\n    return this.forEachControl((u, d) => {\n      const f = u.positionHandler(l, a, this, u);\n      h[d] = Object.assign(f, this._calcCornerCoords(u, f));\n    }), h;\n  }\n  _calcCornerCoords(t, e) {\n    const s = this.getTotalAngle();\n    return { corner: t.calcCornerCoords(s, this.cornerSize, e.x, e.y, !1, this), touchCorner: t.calcCornerCoords(s, this.touchCornerSize, e.x, e.y, !0, this) };\n  }\n  setCoords() {\n    super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());\n  }\n  forEachControl(t) {\n    for (const e in this.controls) t(this.controls[e], e, this);\n  }\n  drawSelectionBackground(t) {\n    if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this) return;\n    t.save();\n    const e = this.getRelativeCenterPoint(), s = this._calculateCurrentDimensions(), r = this.getViewportTransform();\n    t.translate(e.x, e.y), t.scale(1 / r[0], 1 / r[3]), t.rotate(K(this.angle)), t.fillStyle = this.selectionBackgroundColor, t.fillRect(-s.x / 2, -s.y / 2, s.x, s.y), t.restore();\n  }\n  strokeBorders(t, e) {\n    t.strokeRect(-e.x / 2, -e.y / 2, e.x, e.y);\n  }\n  _drawBorders(t, e) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const r = v({ hasControls: this.hasControls, borderColor: this.borderColor, borderDashArray: this.borderDashArray }, s);\n    t.save(), t.strokeStyle = r.borderColor, this._setLineDash(t, r.borderDashArray), this.strokeBorders(t, e), r.hasControls && this.drawControlsConnectingLines(t, e), t.restore();\n  }\n  _renderControls(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { hasBorders: s, hasControls: r } = this, n = v({ hasBorders: s, hasControls: r }, e), o = this.getViewportTransform(), a = n.hasBorders, c = n.hasControls, l = J(o, this.calcTransformMatrix()), h = ys(l);\n    t.save(), t.translate(h.translateX, h.translateY), t.lineWidth = this.borderScaleFactor, this.group === this.parent && (t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (h.angle -= 180), t.rotate(K(this.group ? h.angle : this.angle)), a && this.drawBorders(t, h, e), c && this.drawControls(t, e), t.restore();\n  }\n  drawBorders(t, e, s) {\n    let r;\n    if (s && s.forActiveSelection || this.group) {\n      const n = yi(this.width, this.height, ar(e)), o = this.isStrokeAccountedForInDimensions() ? Fn : (this.strokeUniform ? new _().scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new _(e.scaleX, e.scaleY)).scalarMultiply(this.strokeWidth);\n      r = n.add(o).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);\n    } else r = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);\n    this._drawBorders(t, r, s);\n  }\n  drawControlsConnectingLines(t, e) {\n    let s = !1;\n    t.beginPath(), this.forEachControl((r, n) => {\n      r.withConnection && r.getVisibility(this, n) && (s = !0, t.moveTo(r.x * e.x, r.y * e.y), t.lineTo(r.x * e.x + r.offsetX, r.y * e.y + r.offsetY));\n    }), s && t.stroke();\n  }\n  drawControls(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    t.save();\n    const s = this.getCanvasRetinaScaling(), { cornerStrokeColor: r, cornerDashArray: n, cornerColor: o } = this, a = v({ cornerStrokeColor: r, cornerDashArray: n, cornerColor: o }, e);\n    t.setTransform(s, 0, 0, s, 0, 0), t.strokeStyle = t.fillStyle = a.cornerColor, this.transparentCorners || (t.strokeStyle = a.cornerStrokeColor), this._setLineDash(t, a.cornerDashArray), this.forEachControl((c, l) => {\n      if (c.getVisibility(this, l)) {\n        const h = this.oCoords[l];\n        c.render(t, h.x, h.y, a, this);\n      }\n    }), t.restore();\n  }\n  isControlVisible(t) {\n    return this.controls[t] && this.controls[t].getVisibility(this, t);\n  }\n  setControlVisible(t, e) {\n    this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[t] = e;\n  }\n  setControlsVisibility() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    Object.entries(t).forEach((e) => {\n      let [s, r] = e;\n      return this.setControlVisible(s, r);\n    });\n  }\n  clearContextTop(t) {\n    if (!this.canvas) return;\n    const e = this.canvas.contextTop;\n    if (!e) return;\n    const s = this.canvas.viewportTransform;\n    e.save(), e.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this.transform(e);\n    const r = this.width + 4, n = this.height + 4;\n    return e.clearRect(-r / 2, -n / 2, r, n), t || e.restore(), e;\n  }\n  onDeselect(t) {\n    return !1;\n  }\n  onSelect(t) {\n    return !1;\n  }\n  shouldStartDragging(t) {\n    return !1;\n  }\n  onDragStart(t) {\n    return !1;\n  }\n  canDrop(t) {\n    return !1;\n  }\n  renderDragSourceEffect(t) {\n  }\n  renderDropTargetEffect(t) {\n  }\n}\nfunction kc(i, t) {\n  return t.forEach((e) => {\n    Object.getOwnPropertyNames(e.prototype).forEach((s) => {\n      s !== \"constructor\" && Object.defineProperty(i.prototype, s, Object.getOwnPropertyDescriptor(e.prototype, s) || /* @__PURE__ */ Object.create(null));\n    });\n  }), i;\n}\ny(Js, \"ownDefaults\", { noScaleCache: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, cornerColor: \"rgb(178,204,255)\", cornerStrokeColor: \"\", cornerStyle: \"rect\", cornerDashArray: null, hasControls: !0, borderColor: \"rgb(178,204,255)\", borderDashArray: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, hasBorders: !0, selectionBackgroundColor: \"\", selectable: !0, evented: !0, perPixelTargetFind: !1, activeOn: \"down\", hoverCursor: null, moveCursor: null });\nclass nt extends Js {\n}\nkc(nt, [ac]), C.setClass(nt), C.setClass(nt, \"object\");\nconst Mc = (i, t, e, s) => {\n  const r = 2 * (s = Math.round(s)) + 1, { data: n } = i.getImageData(t - s, e - s, r, r);\n  for (let o = 3; o < n.length; o += 4)\n    if (n[o] > 0) return !1;\n  return !0;\n};\nclass Ic {\n  constructor(t) {\n    this.options = t, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new _(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new _(1 / this.options.scaleX, 1 / this.options.scaleY) : new _(1, 1);\n  }\n  createSideVector(t, e) {\n    const s = Zr(t, e);\n    return this.options.strokeUniform ? s.multiply(this.scale) : s;\n  }\n  projectOrthogonally(t, e, s) {\n    return this.applySkew(t.add(this.calcOrthogonalProjection(t, e, s)));\n  }\n  isSkewed() {\n    return this.options.skewX !== 0 || this.options.skewY !== 0;\n  }\n  applySkew(t) {\n    const e = new _(t);\n    return e.y += e.x * Math.tan(K(this.options.skewY)), e.x += e.y * Math.tan(K(this.options.skewX)), e;\n  }\n  scaleUnitVector(t, e) {\n    return t.multiply(this.strokeUniformScalar).scalarMultiply(e);\n  }\n}\nconst fu = new _();\nclass ms extends Ic {\n  static getOrthogonalRotationFactor(t, e) {\n    const s = e ? ti(t, e) : lc(t);\n    return Math.abs(s) < xe ? -1 : 1;\n  }\n  constructor(t, e, s, r) {\n    super(r), y(this, \"AB\", void 0), y(this, \"AC\", void 0), y(this, \"alpha\", void 0), y(this, \"bisector\", void 0), this.A = new _(t), this.B = new _(e), this.C = new _(s), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = ti(this.AB, this.AC), this.bisector = Si(Vn(this.AB.eq(fu) ? this.AC : this.AB, this.alpha / 2));\n  }\n  calcOrthogonalProjection(t, e) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;\n    const r = this.createSideVector(t, e), n = Gn(r), o = ms.getOrthogonalRotationFactor(n, this.bisector);\n    return this.scaleUnitVector(n, s * o);\n  }\n  projectBevel() {\n    const t = [];\n    return (this.alpha % he == 0 ? [this.B] : [this.B, this.C]).forEach((e) => {\n      t.push(this.projectOrthogonally(this.A, e)), t.push(this.projectOrthogonally(this.A, e, -this.strokeProjectionMagnitude));\n    }), t;\n  }\n  projectMiter() {\n    const t = [], e = Math.abs(this.alpha), s = 1 / Math.sin(e / 2), r = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * s), n = this.options.strokeUniform ? Qr(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;\n    return Qr(r) / this.strokeProjectionMagnitude <= n && t.push(this.applySkew(this.A.add(r))), t.push(...this.projectBevel()), t;\n  }\n  projectRoundNoSkew(t, e) {\n    const s = [], r = new _(ms.getOrthogonalRotationFactor(this.bisector), ms.getOrthogonalRotationFactor(new _(this.bisector.y, this.bisector.x)));\n    return [new _(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(r), new _(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(r)].forEach((n) => {\n      cn(n, t, e) && s.push(this.A.add(n));\n    }), s;\n  }\n  projectRoundWithSkew(t, e) {\n    const s = [], { skewX: r, skewY: n, scaleX: o, scaleY: a, strokeUniform: c } = this.options, l = new _(Math.tan(K(r)), Math.tan(K(n))), h = this.strokeProjectionMagnitude, u = c ? h / a / Math.sqrt(1 / a ** 2 + 1 / o ** 2 * l.y ** 2) : h / Math.sqrt(1 + l.y ** 2), d = new _(Math.sqrt(Math.max(h ** 2 - u ** 2, 0)), u), f = c ? h / Math.sqrt(1 + l.x ** 2 * (1 / a) ** 2 / (1 / o + 1 / o * l.x * l.y) ** 2) : h / Math.sqrt(1 + l.x ** 2 / (1 + l.x * l.y) ** 2), g = new _(f, Math.sqrt(Math.max(h ** 2 - f ** 2, 0)));\n    return [g, g.scalarMultiply(-1), d, d.scalarMultiply(-1)].map((p) => this.applySkew(c ? p.multiply(this.strokeUniformScalar) : p)).forEach((p) => {\n      cn(p, t, e) && s.push(this.applySkew(this.A).add(p));\n    }), s;\n  }\n  projectRound() {\n    const t = [];\n    t.push(...this.projectBevel());\n    const e = this.alpha % he == 0, s = this.applySkew(this.A), r = t[e ? 0 : 2].subtract(s), n = t[e ? 1 : 0].subtract(s), o = e ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), a = ps(r, o) > 0, c = a ? r : n, l = a ? n : r;\n    return this.isSkewed() ? t.push(...this.projectRoundWithSkew(c, l)) : t.push(...this.projectRoundNoSkew(c, l)), t;\n  }\n  projectPoints() {\n    switch (this.options.strokeLineJoin) {\n      case \"miter\":\n        return this.projectMiter();\n      case \"round\":\n        return this.projectRound();\n      default:\n        return this.projectBevel();\n    }\n  }\n  project() {\n    return this.projectPoints().map((t) => ({ originPoint: this.A, projectedPoint: t, angle: this.alpha, bisector: this.bisector }));\n  }\n}\nclass Do extends Ic {\n  constructor(t, e, s) {\n    super(s), this.A = new _(t), this.T = new _(e);\n  }\n  calcOrthogonalProjection(t, e) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;\n    const r = this.createSideVector(t, e);\n    return this.scaleUnitVector(Gn(r), s);\n  }\n  projectButt() {\n    return [this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude), this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)];\n  }\n  projectRound() {\n    const t = [];\n    if (!this.isSkewed() && this.A.eq(this.T)) {\n      const e = new _(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);\n      t.push(this.applySkew(this.A.add(e)), this.applySkew(this.A.subtract(e)));\n    } else t.push(...new ms(this.A, this.T, this.T, this.options).projectRound());\n    return t;\n  }\n  projectSquare() {\n    const t = [];\n    if (this.A.eq(this.T)) {\n      const e = new _(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);\n      t.push(this.A.add(e), this.A.subtract(e));\n    } else {\n      const e = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), s = this.scaleUnitVector(Si(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), r = this.A.add(s);\n      t.push(r.add(e), r.subtract(e));\n    }\n    return t.map((e) => this.applySkew(e));\n  }\n  projectPoints() {\n    switch (this.options.strokeLineCap) {\n      case \"round\":\n        return this.projectRound();\n      case \"square\":\n        return this.projectSquare();\n      default:\n        return this.projectButt();\n    }\n  }\n  project() {\n    return this.projectPoints().map((t) => ({ originPoint: this.A, projectedPoint: t }));\n  }\n}\nconst Dc = function(i, t) {\n  let e = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];\n  const s = [];\n  if (i.length === 0) return s;\n  const r = i.reduce((n, o) => (n[n.length - 1].eq(o) || n.push(new _(o)), n), [new _(i[0])]);\n  if (r.length === 1) e = !0;\n  else if (!e) {\n    const n = r[0], o = ((a, c) => {\n      for (let l = a.length - 1; l >= 0; l--) if (c(a[l], l, a)) return l;\n      return -1;\n    })(r, (a) => !a.eq(n));\n    r.splice(o + 1);\n  }\n  return r.forEach((n, o, a) => {\n    let c, l;\n    o === 0 ? (l = a[1], c = e ? n : a[a.length - 1]) : o === a.length - 1 ? (c = a[o - 1], l = e ? n : a[0]) : (c = a[o - 1], l = a[o + 1]), e && a.length === 1 ? s.push(...new Do(n, n, t).project()) : !e || o !== 0 && o !== a.length - 1 ? s.push(...new ms(n, c, l, t).project()) : s.push(...new Do(n, o === 0 ? l : c, t).project());\n  }), s;\n}, Kn = (i) => {\n  const t = {};\n  return Object.keys(i).forEach((e) => {\n    t[e] = {}, Object.keys(i[e]).forEach((s) => {\n      t[e][s] = v({}, i[e][s]);\n    });\n  }), t;\n}, jc = (i) => i.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\"), xi = (i) => {\n  const t = [];\n  for (let e, s = 0; s < i.length; s++) (e = gu(i, s)) !== !1 && t.push(e);\n  return t;\n}, gu = (i, t) => {\n  const e = i.charCodeAt(t);\n  if (isNaN(e)) return \"\";\n  if (e < 55296 || e > 57343) return i.charAt(t);\n  if (55296 <= e && e <= 56319) {\n    if (i.length <= t + 1) throw \"High surrogate without following low surrogate\";\n    const r = i.charCodeAt(t + 1);\n    if (56320 > r || r > 57343) throw \"High surrogate without following low surrogate\";\n    return i.charAt(t) + i.charAt(t + 1);\n  }\n  if (t === 0) throw \"Low surrogate without preceding high surrogate\";\n  const s = i.charCodeAt(t - 1);\n  if (55296 > s || s > 56319) throw \"Low surrogate without preceding high surrogate\";\n  return !1;\n};\nvar pu = Object.freeze({ __proto__: null, capitalize: function(i) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];\n  return \"\".concat(i.charAt(0).toUpperCase()).concat(t ? i.slice(1) : i.slice(1).toLowerCase());\n}, escapeXml: jc, graphemeSplit: xi });\nconst wi = function(i, t) {\n  let e = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];\n  return i.fill !== t.fill || i.stroke !== t.stroke || i.strokeWidth !== t.strokeWidth || i.fontSize !== t.fontSize || i.fontFamily !== t.fontFamily || i.fontWeight !== t.fontWeight || i.fontStyle !== t.fontStyle || i.textBackgroundColor !== t.textBackgroundColor || i.deltaY !== t.deltaY || e && (i.overline !== t.overline || i.underline !== t.underline || i.linethrough !== t.linethrough);\n}, Ec = (i, t) => {\n  const e = t.split(`\n`), s = [];\n  let r = -1, n = {};\n  i = Kn(i);\n  for (let o = 0; o < e.length; o++) {\n    const a = xi(e[o]);\n    if (i[o]) for (let c = 0; c < a.length; c++) {\n      r++;\n      const l = i[o][c];\n      l && Object.keys(l).length > 0 && (wi(n, l, !0) ? s.push({ start: r, end: r + 1, style: l }) : s[s.length - 1].end++), n = l || {};\n    }\n    else r += a.length, n = {};\n  }\n  return s;\n}, Pc = (i, t) => {\n  if (!Array.isArray(i)) return Kn(i);\n  const e = t.split(Pn), s = {};\n  let r = -1, n = 0;\n  for (let o = 0; o < e.length; o++) {\n    const a = xi(e[o]);\n    for (let c = 0; c < a.length; c++) r++, i[n] && i[n].start <= r && r < i[n].end && (s[o] = s[o] || {}, s[o][c] = v({}, i[n].style), r === i[n].end - 1 && n++);\n  }\n  return s;\n}, De = [\"display\", \"transform\", rt, \"fill-opacity\", \"fill-rule\", \"opacity\", mt, \"stroke-dasharray\", \"stroke-linecap\", \"stroke-dashoffset\", \"stroke-linejoin\", \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"id\", \"paint-order\", \"vector-effect\", \"instantiated_by_use\", \"clip-path\"];\nfunction jo(i, t) {\n  const e = i.nodeName, s = i.getAttribute(\"class\"), r = i.getAttribute(\"id\"), n = \"(?![a-zA-Z\\\\-]+)\";\n  let o;\n  if (o = new RegExp(\"^\" + e, \"i\"), t = t.replace(o, \"\"), r && t.length && (o = new RegExp(\"#\" + r + n, \"i\"), t = t.replace(o, \"\")), s && t.length) {\n    const a = s.split(\" \");\n    for (let c = a.length; c--; ) o = new RegExp(\"\\\\.\" + a[c] + n, \"i\"), t = t.replace(o, \"\");\n  }\n  return t.length === 0;\n}\nfunction mu(i, t) {\n  let e = !0;\n  const s = jo(i, t.pop());\n  return s && t.length && (e = function(r, n) {\n    let o, a = !0;\n    for (; r.parentElement && r.parentElement.nodeType === 1 && n.length; ) a && (o = n.pop()), a = jo(r = r.parentElement, o);\n    return n.length === 0;\n  }(i, t)), s && e && t.length === 0;\n}\nconst vu = (i) => {\n  var t;\n  return (t = $h[i]) !== null && t !== void 0 ? t : i;\n}, yu = new RegExp(\"(\".concat(Xe, \")\"), \"gi\"), bu = (i) => i.replace(yu, \" $1 \").replace(/,/gi, \" \").replace(/\\s+/gi, \" \");\nvar Eo, Po, Ao, Fo, Ro, Lo, Bo;\nconst lt = \"(\".concat(Xe, \")\"), _u = String.raw(Eo || (Eo = Me([\"(skewX)(\", \")\"], [\"(skewX)\\\\(\", \"\\\\)\"])), lt), Su = String.raw(Po || (Po = Me([\"(skewY)(\", \")\"], [\"(skewY)\\\\(\", \"\\\\)\"])), lt), Tu = String.raw(Ao || (Ao = Me([\"(rotate)(\", \"(?: \", \" \", \")?)\"], [\"(rotate)\\\\(\", \"(?: \", \" \", \")?\\\\)\"])), lt, lt, lt), xu = String.raw(Fo || (Fo = Me([\"(scale)(\", \"(?: \", \")?)\"], [\"(scale)\\\\(\", \"(?: \", \")?\\\\)\"])), lt, lt), wu = String.raw(Ro || (Ro = Me([\"(translate)(\", \"(?: \", \")?)\"], [\"(translate)\\\\(\", \"(?: \", \")?\\\\)\"])), lt, lt), Cu = String.raw(Lo || (Lo = Me([\"(matrix)(\", \" \", \" \", \" \", \" \", \" \", \")\"], [\"(matrix)\\\\(\", \" \", \" \", \" \", \" \", \" \", \"\\\\)\"])), lt, lt, lt, lt, lt, lt), Jn = \"(?:\".concat(Cu, \"|\").concat(wu, \"|\").concat(Tu, \"|\").concat(xu, \"|\").concat(_u, \"|\").concat(Su, \")\"), Ou = \"(?:\".concat(Jn, \"*)\"), ku = String.raw(Bo || (Bo = Me([\"^s*(?:\", \"?)s*$\"], [\"^\\\\s*(?:\", \"?)\\\\s*$\"])), Ou), Mu = new RegExp(ku), Iu = new RegExp(Jn), Du = new RegExp(Jn, \"g\");\nfunction fn(i) {\n  const t = [];\n  if (!(i = bu(i).replace(/\\s*([()])\\s*/gi, \"$1\")) || i && !Mu.test(i)) return [...ht];\n  for (const e of i.matchAll(Du)) {\n    const s = Iu.exec(e[0]);\n    if (!s) continue;\n    let r = ht;\n    const n = s.filter((g) => !!g), [, o, ...a] = n, [c, l, h, u, d, f] = a.map((g) => parseFloat(g));\n    switch (o) {\n      case \"translate\":\n        r = Ms(c, l);\n        break;\n      case An:\n        r = Is({ angle: c }, { x: l, y: h });\n        break;\n      case pi:\n        r = vi(c, l);\n        break;\n      case Os:\n        r = Bn(c);\n        break;\n      case ks:\n        r = Wn(c);\n        break;\n      case \"matrix\":\n        r = [c, l, h, u, d, f];\n    }\n    t.push(r);\n  }\n  return mi(t);\n}\nfunction ju(i, t, e, s) {\n  const r = Array.isArray(t);\n  let n, o = t;\n  if (i !== rt && i !== mt || t !== pt) {\n    if (i === \"strokeUniform\") return t === \"non-scaling-stroke\";\n    if (i === \"strokeDashArray\") o = t === pt ? null : t.replace(/,/g, \" \").split(/\\s+/).map(parseFloat);\n    else if (i === \"transformMatrix\") o = e && e.transformMatrix ? J(e.transformMatrix, fn(t)) : fn(t);\n    else if (i === \"visible\") o = t !== pt && t !== \"hidden\", e && e.visible === !1 && (o = !1);\n    else if (i === \"opacity\") o = parseFloat(t), e && e.opacity !== void 0 && (o *= e.opacity);\n    else if (i === \"textAnchor\") o = t === \"start\" ? L : t === \"end\" ? Z : j;\n    else if (i === \"charSpacing\") n = We(t, s) / s * 1e3;\n    else if (i === \"paintFirst\") {\n      const a = t.indexOf(rt), c = t.indexOf(mt);\n      o = rt, (a > -1 && c > -1 && c < a || a === -1 && c > -1) && (o = mt);\n    } else {\n      if (i === \"href\" || i === \"xlink:href\" || i === \"font\" || i === \"id\") return t;\n      if (i === \"imageSmoothing\") return t === \"optimizeQuality\";\n      n = r ? t.map(We) : We(t, s);\n    }\n  } else o = \"\";\n  return !r && isNaN(n) ? o : n;\n}\nfunction Eu(i, t) {\n  const e = i.match(Uh);\n  if (!e) return;\n  const s = e[1], r = e[3], n = e[4], o = e[5], a = e[6];\n  s && (t.fontStyle = s), r && (t.fontWeight = isNaN(parseFloat(r)) ? r : parseFloat(r)), n && (t.fontSize = We(n)), a && (t.fontFamily = a), o && (t.lineHeight = o === \"normal\" ? 1 : o);\n}\nfunction Pu(i, t) {\n  i.replace(/;\\s*$/, \"\").split(\";\").forEach((e) => {\n    if (!e) return;\n    const [s, r] = e.split(\":\");\n    t[s.trim().toLowerCase()] = r.trim();\n  });\n}\nfunction Au(i) {\n  const t = {}, e = i.getAttribute(\"style\");\n  return e && (typeof e == \"string\" ? Pu(e, t) : function(s, r) {\n    Object.entries(s).forEach((n) => {\n      let [o, a] = n;\n      a !== void 0 && (r[o.toLowerCase()] = a);\n    });\n  }(e, t)), t;\n}\nconst Fu = { stroke: \"strokeOpacity\", fill: \"fillOpacity\" };\nfunction fe(i, t, e) {\n  if (!i) return {};\n  let s, r = {}, n = En;\n  i.parentNode && Co.test(i.parentNode.nodeName) && (r = fe(i.parentElement, t, e), r.fontSize && (s = n = We(r.fontSize)));\n  const o = v(v(v({}, t.reduce((l, h) => {\n    const u = i.getAttribute(h);\n    return u && (l[h] = u), l;\n  }, {})), function(l) {\n    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, u = {};\n    for (const d in h) mu(l, d.split(\" \")) && (u = v(v({}, u), h[d]));\n    return u;\n  }(i, e)), Au(i));\n  o[Wi] && i.setAttribute(Wi, o[Wi]), o[Bi] && (s = We(o[Bi], n), o[Bi] = \"\".concat(s));\n  const a = {};\n  for (const l in o) {\n    const h = vu(l), u = ju(h, o[l], r, s);\n    a[h] = u;\n  }\n  a && a.font && Eu(a.font, a);\n  const c = v(v({}, r), a);\n  return Co.test(i.nodeName) ? c : function(l) {\n    const h = nt.getDefaults();\n    return Object.entries(Fu).forEach((u) => {\n      let [d, f] = u;\n      if (l[f] === void 0 || l[d] === \"\") return;\n      if (l[d] === void 0) {\n        if (!h[d]) return;\n        l[d] = h[d];\n      }\n      if (l[d].indexOf(\"url(\") === 0) return;\n      const g = new W(l[d]);\n      l[d] = g.setAlpha(V(g.getAlpha() * l[f], 2)).toRgba();\n    }), l;\n  }(c);\n}\nconst Ru = [\"left\", \"top\", \"width\", \"height\", \"visible\"], Ac = [\"rx\", \"ry\"];\nclass X extends nt {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), X.ownDefaults);\n  }\n  constructor(t) {\n    super(), Object.assign(this, X.ownDefaults), this.setOptions(t), this._initRxRy();\n  }\n  _initRxRy() {\n    const { rx: t, ry: e } = this;\n    t && !e ? this.ry = t : e && !t && (this.rx = e);\n  }\n  _render(t) {\n    const { width: e, height: s } = this, r = -e / 2, n = -s / 2, o = this.rx ? Math.min(this.rx, e / 2) : 0, a = this.ry ? Math.min(this.ry, s / 2) : 0, c = o !== 0 || a !== 0;\n    t.beginPath(), t.moveTo(r + o, n), t.lineTo(r + e - o, n), c && t.bezierCurveTo(r + e - ye * o, n, r + e, n + ye * a, r + e, n + a), t.lineTo(r + e, n + s - a), c && t.bezierCurveTo(r + e, n + s - ye * a, r + e - ye * o, n + s, r + e - o, n + s), t.lineTo(r + o, n + s), c && t.bezierCurveTo(r + ye * o, n + s, r, n + s - ye * a, r, n + s - a), t.lineTo(r, n + a), c && t.bezierCurveTo(r, n + ye * a, r + ye * o, n, r + o, n), t.closePath(), this._renderPaintInOrder(t);\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return super.toObject([...Ac, ...t]);\n  }\n  _toSVG() {\n    const { width: t, height: e, rx: s, ry: r } = this;\n    return [\"<rect \", \"COMMON_PARTS\", 'x=\"'.concat(-t / 2, '\" y=\"').concat(-e / 2, '\" rx=\"').concat(s, '\" ry=\"').concat(r, '\" width=\"').concat(t, '\" height=\"').concat(e, `\" />\n`)];\n  }\n  static async fromElement(t, e, s) {\n    const r = fe(t, this.ATTRIBUTE_NAMES, s), { left: n = 0, top: o = 0, width: a = 0, height: c = 0, visible: l = !0 } = r, h = G(r, Ru);\n    return new this(v(v(v({}, e), h), {}, { left: n, top: o, width: a, height: c, visible: !!(l && a && c) }));\n  }\n}\ny(X, \"type\", \"Rect\"), y(X, \"cacheProperties\", [...de, ...Ac]), y(X, \"ownDefaults\", { rx: 0, ry: 0 }), y(X, \"ATTRIBUTE_NAMES\", [...De, \"x\", \"y\", \"rx\", \"ry\", \"width\", \"height\"]), C.setClass(X), C.setSVGClass(X);\nconst ne = \"initialization\", ei = \"added\", Zn = \"removed\", si = \"imperative\", Fc = (i, t) => {\n  const { strokeUniform: e, strokeWidth: s, width: r, height: n, group: o } = t, a = o && o !== i ? hr(o.calcTransformMatrix(), i.calcTransformMatrix()) : null, c = a ? t.getRelativeCenterPoint().transform(a) : t.getRelativeCenterPoint(), l = !t.isStrokeAccountedForInDimensions(), h = e && l ? rc(new _(s, s), void 0, i.calcTransformMatrix()) : Fn, u = !e && l ? s : 0, d = yi(r + u, n + u, mi([a, t.calcOwnMatrix()], !0)).add(h).scalarDivide(2);\n  return [c.subtract(d), c.add(d)];\n};\nclass Ci {\n  calcLayoutResult(t, e) {\n    if (this.shouldPerformLayout(t)) return this.calcBoundingBox(e, t);\n  }\n  shouldPerformLayout(t) {\n    let { type: e, prevStrategy: s, strategy: r } = t;\n    return e === ne || e === si || !!s && r !== s;\n  }\n  shouldLayoutClipPath(t) {\n    let { type: e, target: { clipPath: s } } = t;\n    return e !== ne && s && !s.absolutePositioned;\n  }\n  getInitialSize(t, e) {\n    return e.size;\n  }\n  calcBoundingBox(t, e) {\n    const { type: s, target: r } = e;\n    if (s === si && e.overrides) return e.overrides;\n    if (t.length === 0) return;\n    const { left: n, top: o, width: a, height: c } = Gt(t.map((u) => Fc(r, u)).reduce((u, d) => u.concat(d), [])), l = new _(a, c), h = new _(n, o).add(l.scalarDivide(2));\n    if (s === ne) {\n      const u = this.getInitialSize(e, { size: l, center: h });\n      return { center: h, relativeCorrection: new _(0, 0), size: u };\n    }\n    return { center: h.transform(r.calcOwnMatrix()), size: l };\n  }\n}\ny(Ci, \"type\", \"strategy\");\nclass gn extends Ci {\n  shouldPerformLayout(t) {\n    return !0;\n  }\n}\ny(gn, \"type\", \"fit-content\"), C.setClass(gn);\nconst Lu = [\"strategy\"], Bu = [\"target\", \"strategy\", \"bubbles\", \"prevStrategy\"], Rc = \"layoutManager\";\nclass Zs {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new gn();\n    y(this, \"strategy\", void 0), this.strategy = t, this._subscriptions = /* @__PURE__ */ new Map();\n  }\n  performLayout(t) {\n    const e = v(v({ bubbles: !0, strategy: this.strategy }, t), {}, { prevStrategy: this._prevLayoutStrategy, stopPropagation() {\n      this.bubbles = !1;\n    } });\n    this.onBeforeLayout(e);\n    const s = this.getLayoutResult(e);\n    s && this.commitLayout(e, s), this.onAfterLayout(e, s), this._prevLayoutStrategy = e.strategy;\n  }\n  attachHandlers(t, e) {\n    const { target: s } = e;\n    return [$r, La, $s, Ba, gi, Wa, Ur, Xa, Xh].map((r) => t.on(r, (n) => this.performLayout(r === $r ? { type: \"object_modified\", trigger: r, e: n, target: s } : { type: \"object_modifying\", trigger: r, e: n, target: s })));\n  }\n  subscribe(t, e) {\n    this.unsubscribe(t, e);\n    const s = this.attachHandlers(t, e);\n    this._subscriptions.set(t, s);\n  }\n  unsubscribe(t, e) {\n    (this._subscriptions.get(t) || []).forEach((s) => s()), this._subscriptions.delete(t);\n  }\n  unsubscribeTargets(t) {\n    t.targets.forEach((e) => this.unsubscribe(e, t));\n  }\n  subscribeTargets(t) {\n    t.targets.forEach((e) => this.subscribe(e, t));\n  }\n  onBeforeLayout(t) {\n    const { target: e, type: s } = t, { canvas: r } = e;\n    if (s === ne || s === ei ? this.subscribeTargets(t) : s === Zn && this.unsubscribeTargets(t), e.fire(\"layout:before\", { context: t }), r && r.fire(\"object:layout:before\", { target: e, context: t }), s === si && t.deep) {\n      const n = G(t, Lu);\n      e.forEachObject((o) => o.layoutManager && o.layoutManager.performLayout(v(v({}, n), {}, { bubbles: !1, target: o })));\n    }\n  }\n  getLayoutResult(t) {\n    const { target: e, strategy: s, type: r } = t, n = s.calcLayoutResult(t, e.getObjects());\n    if (!n) return;\n    const o = r === ne ? new _() : e.getRelativeCenterPoint(), { center: a, correction: c = new _(), relativeCorrection: l = new _() } = n, h = o.subtract(a).add(c).transform(r === ne ? ht : St(e.calcOwnMatrix()), !0).add(l);\n    return { result: n, prevCenter: o, nextCenter: a, offset: h };\n  }\n  commitLayout(t, e) {\n    const { target: s } = t, { result: { size: r }, nextCenter: n } = e;\n    var o, a;\n    s.set({ width: r.x, height: r.y }), this.layoutObjects(t, e), t.type === ne ? s.set({ left: (o = t.x) !== null && o !== void 0 ? o : n.x + r.x * st(s.originX), top: (a = t.y) !== null && a !== void 0 ? a : n.y + r.y * st(s.originY) }) : (s.setPositionByOrigin(n, j, j), s.setCoords(), s.set(\"dirty\", !0));\n  }\n  layoutObjects(t, e) {\n    const { target: s } = t;\n    s.forEachObject((r) => {\n      r.group === s && this.layoutObject(t, e, r);\n    }), t.strategy.shouldLayoutClipPath(t) && this.layoutObject(t, e, s.clipPath);\n  }\n  layoutObject(t, e, s) {\n    let { offset: r } = e;\n    s.set({ left: s.left + r.x, top: s.top + r.y });\n  }\n  onAfterLayout(t, e) {\n    const { target: s, strategy: r, bubbles: n, prevStrategy: o } = t, a = G(t, Bu), { canvas: c } = s;\n    s.fire(\"layout:after\", { context: t, result: e }), c && c.fire(\"object:layout:after\", { context: t, result: e, target: s });\n    const l = s.parent;\n    n && l != null && l.layoutManager && ((a.path || (a.path = [])).push(s), l.layoutManager.performLayout(v(v({}, a), {}, { target: l }))), s.set(\"dirty\", !0);\n  }\n  dispose() {\n    const { _subscriptions: t } = this;\n    t.forEach((e) => e.forEach((s) => s())), t.clear();\n  }\n  toObject() {\n    return { type: Rc, strategy: this.strategy.constructor.type };\n  }\n  toJSON() {\n    return this.toObject();\n  }\n}\nC.setClass(Zs, Rc);\nconst Wu = [\"type\", \"objects\", \"layoutManager\"];\nclass Xu extends Zs {\n  performLayout() {\n  }\n}\nclass Nt extends za(nt) {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), Nt.ownDefaults);\n  }\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    super(), y(this, \"_activeObjects\", []), y(this, \"__objectSelectionTracker\", void 0), y(this, \"__objectSelectionDisposer\", void 0), Object.assign(this, Nt.ownDefaults), this.setOptions(e), this.groupInit(t, e);\n  }\n  groupInit(t, e) {\n    var s;\n    this._objects = [...t], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, !0), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, !1), this.forEachObject((r) => {\n      this.enterGroup(r, !1);\n    }), this.layoutManager = (s = e.layoutManager) !== null && s !== void 0 ? s : new Zs(), this.layoutManager.performLayout({ type: ne, target: this, targets: [...t], x: e.left, y: e.top });\n  }\n  canEnterGroup(t) {\n    return t === this || this.isDescendantOf(t) ? (Te(\"error\", \"Group: circular object trees are not supported, this call has no effect\"), !1) : this._objects.indexOf(t) === -1 || (Te(\"error\", \"Group: duplicate objects are not supported inside group, this call has no effect\"), !1);\n  }\n  _filterObjectsBeforeEnteringGroup(t) {\n    return t.filter((e, s, r) => this.canEnterGroup(e) && r.indexOf(e) === s);\n  }\n  add() {\n    for (var t = arguments.length, e = new Array(t), s = 0; s < t; s++) e[s] = arguments[s];\n    const r = this._filterObjectsBeforeEnteringGroup(e), n = super.add(...r);\n    return this._onAfterObjectsChange(ei, r), n;\n  }\n  insertAt(t) {\n    for (var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) s[r - 1] = arguments[r];\n    const n = this._filterObjectsBeforeEnteringGroup(s), o = super.insertAt(t, ...n);\n    return this._onAfterObjectsChange(ei, n), o;\n  }\n  remove() {\n    const t = super.remove(...arguments);\n    return this._onAfterObjectsChange(Zn, t), t;\n  }\n  _onObjectAdded(t) {\n    this.enterGroup(t, !0), this.fire(\"object:added\", { target: t }), t.fire(\"added\", { target: this });\n  }\n  _onObjectRemoved(t, e) {\n    this.exitGroup(t, e), this.fire(\"object:removed\", { target: t }), t.fire(\"removed\", { target: this });\n  }\n  _onAfterObjectsChange(t, e) {\n    this.layoutManager.performLayout({ type: t, targets: e, target: this });\n  }\n  _onStackOrderChanged() {\n    this._set(\"dirty\", !0);\n  }\n  _set(t, e) {\n    const s = this[t];\n    return super._set(t, e), t === \"canvas\" && s !== e && (this._objects || []).forEach((r) => {\n      r._set(t, e);\n    }), this;\n  }\n  _shouldSetNestedCoords() {\n    return this.subTargetCheck;\n  }\n  removeAll() {\n    return this._activeObjects = [], this.remove(...this._objects);\n  }\n  __objectSelectionMonitor(t, e) {\n    let { target: s } = e;\n    const r = this._activeObjects;\n    if (t) r.push(s), this._set(\"dirty\", !0);\n    else if (r.length > 0) {\n      const n = r.indexOf(s);\n      n > -1 && (r.splice(n, 1), this._set(\"dirty\", !0));\n    }\n  }\n  _watchObject(t, e) {\n    t && this._watchObject(!1, e), t ? (e.on(\"selected\", this.__objectSelectionTracker), e.on(\"deselected\", this.__objectSelectionDisposer)) : (e.off(\"selected\", this.__objectSelectionTracker), e.off(\"deselected\", this.__objectSelectionDisposer));\n  }\n  enterGroup(t, e) {\n    t.group && t.group.remove(t), t._set(\"parent\", this), this._enterGroup(t, e);\n  }\n  _enterGroup(t, e) {\n    e && _s(t, J(St(this.calcTransformMatrix()), t.calcTransformMatrix())), this._shouldSetNestedCoords() && t.setCoords(), t._set(\"group\", this), t._set(\"canvas\", this.canvas), this._watchObject(!0, t);\n    const s = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();\n    s && (s === t || t.isDescendantOf(s)) && this._activeObjects.push(t);\n  }\n  exitGroup(t, e) {\n    this._exitGroup(t, e), t._set(\"parent\", void 0), t._set(\"canvas\", void 0);\n  }\n  _exitGroup(t, e) {\n    t._set(\"group\", void 0), e || (_s(t, J(this.calcTransformMatrix(), t.calcTransformMatrix())), t.setCoords()), this._watchObject(!1, t);\n    const s = this._activeObjects.length > 0 ? this._activeObjects.indexOf(t) : -1;\n    s > -1 && this._activeObjects.splice(s, 1);\n  }\n  shouldCache() {\n    const t = nt.prototype.shouldCache.call(this);\n    if (t) {\n      for (let e = 0; e < this._objects.length; e++) if (this._objects[e].willDrawShadow()) return this.ownCaching = !1, !1;\n    }\n    return t;\n  }\n  willDrawShadow() {\n    if (super.willDrawShadow()) return !0;\n    for (let t = 0; t < this._objects.length; t++) if (this._objects[t].willDrawShadow()) return !0;\n    return !1;\n  }\n  isOnACache() {\n    return this.ownCaching || !!this.parent && this.parent.isOnACache();\n  }\n  drawObject(t, e, s) {\n    this._renderBackground(t);\n    for (let n = 0; n < this._objects.length; n++) {\n      var r;\n      const o = this._objects[n];\n      (r = this.canvas) !== null && r !== void 0 && r.preserveObjectStacking && o.group !== this ? (t.save(), t.transform(...St(this.calcTransformMatrix())), o.render(t), t.restore()) : o.group === this && o.render(t);\n    }\n    this._drawClipPath(t, this.clipPath, s);\n  }\n  setCoords() {\n    super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((t) => t.setCoords());\n  }\n  triggerLayout() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.layoutManager.performLayout(v({ target: this, type: si }, t));\n  }\n  render(t) {\n    this._transformDone = !0, super.render(t), this._transformDone = !1;\n  }\n  __serializeObjects(t, e) {\n    const s = this.includeDefaultValues;\n    return this._objects.filter(function(r) {\n      return !r.excludeFromExport;\n    }).map(function(r) {\n      const n = r.includeDefaultValues;\n      r.includeDefaultValues = s;\n      const o = r[t || \"toObject\"](e);\n      return r.includeDefaultValues = n, o;\n    });\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    const e = this.layoutManager.toObject();\n    return v(v(v({}, super.toObject([\"subTargetCheck\", \"interactive\", ...t])), e.strategy !== \"fit-content\" || this.includeDefaultValues ? { layoutManager: e } : {}), {}, { objects: this.__serializeObjects(\"toObject\", t) });\n  }\n  toString() {\n    return \"#<Group: (\".concat(this.complexity(), \")>\");\n  }\n  dispose() {\n    this.layoutManager.unsubscribeTargets({ targets: this.getObjects(), target: this }), this._activeObjects = [], this.forEachObject((t) => {\n      this._watchObject(!1, t), t.dispose();\n    }), super.dispose();\n  }\n  _createSVGBgRect(t) {\n    if (!this.backgroundColor) return \"\";\n    const e = X.prototype._toSVG.call(this), s = e.indexOf(\"COMMON_PARTS\");\n    e[s] = 'for=\"group\" ';\n    const r = e.join(\"\");\n    return t ? t(r) : r;\n  }\n  _toSVG(t) {\n    const e = [\"<g \", \"COMMON_PARTS\", ` >\n`], s = this._createSVGBgRect(t);\n    s && e.push(\"\t\t\", s);\n    for (let r = 0; r < this._objects.length; r++) e.push(\"\t\t\", this._objects[r].toSVG(t));\n    return e.push(`</g>\n`), e;\n  }\n  getSvgStyles() {\n    const t = this.opacity !== void 0 && this.opacity !== 1 ? \"opacity: \".concat(this.opacity, \";\") : \"\", e = this.visible ? \"\" : \" visibility: hidden;\";\n    return [t, this.getSvgFilter(), e].join(\"\");\n  }\n  toClipPathSVG(t) {\n    const e = [], s = this._createSVGBgRect(t);\n    s && e.push(\"\t\", s);\n    for (let r = 0; r < this._objects.length; r++) e.push(\"\t\", this._objects[r].toClipPathSVG(t));\n    return this._createBaseClipPathSVGMarkup(e, { reviver: t });\n  }\n  static fromObject(t, e) {\n    let { type: s, objects: r = [], layoutManager: n } = t, o = G(t, Wu);\n    return Promise.all([bs(r, e), cr(o, e)]).then((a) => {\n      let [c, l] = a;\n      const h = new this(c, v(v(v({}, o), l), {}, { layoutManager: new Xu() }));\n      if (n) {\n        const u = C.getClass(n.type), d = C.getClass(n.strategy);\n        h.layoutManager = new u(new d());\n      } else h.layoutManager = new Zs();\n      return h.layoutManager.subscribeTargets({ type: ne, target: h, targets: h.getObjects() }), h.setCoords(), h;\n    });\n  }\n}\ny(Nt, \"type\", \"Group\"), y(Nt, \"ownDefaults\", { strokeWidth: 0, subTargetCheck: !1, interactive: !1 }), C.setClass(Nt);\nconst Lc = (i, t) => Math.min(t.width / i.width, t.height / i.height), Bc = (i, t) => Math.max(t.width / i.width, t.height / i.height), pn = \"\\\\s*,?\\\\s*\", Fs = \"\".concat(pn, \"(\").concat(Xe, \")\"), zu = \"\".concat(Fs).concat(Fs).concat(Fs).concat(pn, \"([01])\").concat(pn, \"([01])\").concat(Fs).concat(Fs), Hu = { m: \"l\", M: \"L\" }, Yu = (i, t, e, s, r, n, o, a, c, l, h) => {\n  const u = Lt(i), d = Bt(i), f = Lt(t), g = Bt(t), p = e * r * f - s * n * g + o, m = s * r * f + e * n * g + a;\n  return [\"C\", l + c * (-e * r * d - s * n * u), h + c * (-s * r * d + e * n * u), p + c * (e * r * g + s * n * f), m + c * (s * r * g - e * n * f), p, m];\n}, Wo = (i, t, e, s) => {\n  const r = Math.atan2(t, i), n = Math.atan2(s, e);\n  return n >= r ? n - r : 2 * Math.PI - (r - n);\n};\nfunction mn(i, t, e, s, r, n, o, a) {\n  let c;\n  if (A.cachesBoundsOfCurve && (c = [...arguments].join(), zs.boundsOfCurveCache[c])) return zs.boundsOfCurveCache[c];\n  const l = Math.sqrt, h = Math.abs, u = [], d = [[0, 0], [0, 0]];\n  let f = 6 * i - 12 * e + 6 * r, g = -3 * i + 9 * e - 9 * r + 3 * o, p = 3 * e - 3 * i;\n  for (let k = 0; k < 2; ++k) {\n    if (k > 0 && (f = 6 * t - 12 * s + 6 * n, g = -3 * t + 9 * s - 9 * n + 3 * a, p = 3 * s - 3 * t), h(g) < 1e-12) {\n      if (h(f) < 1e-12) continue;\n      const E = -p / f;\n      0 < E && E < 1 && u.push(E);\n      continue;\n    }\n    const O = f * f - 4 * p * g;\n    if (O < 0) continue;\n    const x = l(O), I = (-f + x) / (2 * g);\n    0 < I && I < 1 && u.push(I);\n    const M = (-f - x) / (2 * g);\n    0 < M && M < 1 && u.push(M);\n  }\n  let m = u.length;\n  const b = m, S = Xc(i, t, e, s, r, n, o, a);\n  for (; m--; ) {\n    const { x: k, y: O } = S(u[m]);\n    d[0][m] = k, d[1][m] = O;\n  }\n  d[0][b] = i, d[1][b] = t, d[0][b + 1] = o, d[1][b + 1] = a;\n  const w = [new _(Math.min(...d[0]), Math.min(...d[1])), new _(Math.max(...d[0]), Math.max(...d[1]))];\n  return A.cachesBoundsOfCurve && (zs.boundsOfCurveCache[c] = w), w;\n}\nconst Vu = (i, t, e) => {\n  let [s, r, n, o, a, c, l, h] = e;\n  const u = ((d, f, g, p, m, b, S) => {\n    if (g === 0 || p === 0) return [];\n    let w = 0, k = 0, O = 0;\n    const x = Math.PI, I = S * jn, M = Bt(I), E = Lt(I), R = 0.5 * (-E * d - M * f), tt = 0.5 * (-E * f + M * d), F = g ** 2, B = p ** 2, $ = tt ** 2, yt = R ** 2, dt = F * B - F * $ - B * yt;\n    let Dt = Math.abs(g), q = Math.abs(p);\n    if (dt < 0) {\n      const ve = Math.sqrt(1 - dt / (F * B));\n      Dt *= ve, q *= ve;\n    } else O = (m === b ? -1 : 1) * Math.sqrt(dt / (F * $ + B * yt));\n    const zt = O * Dt * tt / q, te = -O * q * R / Dt, pr = E * zt - M * te + 0.5 * d, Ai = M * zt + E * te + 0.5 * f;\n    let Ps = Wo(1, 0, (R - zt) / Dt, (tt - te) / q), me = Wo((R - zt) / Dt, (tt - te) / q, (-R - zt) / Dt, (-tt - te) / q);\n    b === 0 && me > 0 ? me -= 2 * x : b === 1 && me < 0 && (me += 2 * x);\n    const mr = Math.ceil(Math.abs(me / x * 2)), je = [], As = me / mr, Ah = 8 / 3 * Math.sin(As / 4) * Math.sin(As / 4) / Math.sin(As / 2);\n    let Fi = Ps + As;\n    for (let ve = 0; ve < mr; ve++) je[ve] = Yu(Ps, Fi, E, M, Dt, q, pr, Ai, Ah, w, k), w = je[ve][5], k = je[ve][6], Ps = Fi, Fi += As;\n    return je;\n  })(l - i, h - t, r, n, a, c, o);\n  for (let d = 0, f = u.length; d < f; d++) u[d][1] += i, u[d][2] += t, u[d][3] += i, u[d][4] += t, u[d][5] += i, u[d][6] += t;\n  return u;\n}, Wc = (i) => {\n  let t = 0, e = 0, s = 0, r = 0;\n  const n = [];\n  let o, a = 0, c = 0;\n  for (const l of i) {\n    const h = [...l];\n    let u;\n    switch (h[0]) {\n      case \"l\":\n        h[1] += t, h[2] += e;\n      case \"L\":\n        t = h[1], e = h[2], u = [\"L\", t, e];\n        break;\n      case \"h\":\n        h[1] += t;\n      case \"H\":\n        t = h[1], u = [\"L\", t, e];\n        break;\n      case \"v\":\n        h[1] += e;\n      case \"V\":\n        e = h[1], u = [\"L\", t, e];\n        break;\n      case \"m\":\n        h[1] += t, h[2] += e;\n      case \"M\":\n        t = h[1], e = h[2], s = h[1], r = h[2], u = [\"M\", t, e];\n        break;\n      case \"c\":\n        h[1] += t, h[2] += e, h[3] += t, h[4] += e, h[5] += t, h[6] += e;\n      case \"C\":\n        a = h[3], c = h[4], t = h[5], e = h[6], u = [\"C\", h[1], h[2], a, c, t, e];\n        break;\n      case \"s\":\n        h[1] += t, h[2] += e, h[3] += t, h[4] += e;\n      case \"S\":\n        o === \"C\" ? (a = 2 * t - a, c = 2 * e - c) : (a = t, c = e), t = h[3], e = h[4], u = [\"C\", a, c, h[1], h[2], t, e], a = u[3], c = u[4];\n        break;\n      case \"q\":\n        h[1] += t, h[2] += e, h[3] += t, h[4] += e;\n      case \"Q\":\n        a = h[1], c = h[2], t = h[3], e = h[4], u = [\"Q\", a, c, t, e];\n        break;\n      case \"t\":\n        h[1] += t, h[2] += e;\n      case \"T\":\n        o === \"Q\" ? (a = 2 * t - a, c = 2 * e - c) : (a = t, c = e), t = h[1], e = h[2], u = [\"Q\", a, c, t, e];\n        break;\n      case \"a\":\n        h[6] += t, h[7] += e;\n      case \"A\":\n        Vu(t, e, h).forEach((d) => n.push(d)), t = h[6], e = h[7];\n        break;\n      case \"z\":\n      case \"Z\":\n        t = s, e = r, u = [\"Z\"];\n    }\n    u ? (n.push(u), o = u[0]) : o = \"\";\n  }\n  return n;\n}, ri = (i, t, e, s) => Math.sqrt((e - i) ** 2 + (s - t) ** 2), Xc = (i, t, e, s, r, n, o, a) => (c) => {\n  const l = c ** 3, h = ((f) => 3 * f ** 2 * (1 - f))(c), u = ((f) => 3 * f * (1 - f) ** 2)(c), d = ((f) => (1 - f) ** 3)(c);\n  return new _(o * l + r * h + e * u + i * d, a * l + n * h + s * u + t * d);\n}, zc = (i) => i ** 2, Hc = (i) => 2 * i * (1 - i), Yc = (i) => (1 - i) ** 2, Gu = (i, t, e, s, r, n, o, a) => (c) => {\n  const l = zc(c), h = Hc(c), u = Yc(c), d = 3 * (u * (e - i) + h * (r - e) + l * (o - r)), f = 3 * (u * (s - t) + h * (n - s) + l * (a - n));\n  return Math.atan2(f, d);\n}, Nu = (i, t, e, s, r, n) => (o) => {\n  const a = zc(o), c = Hc(o), l = Yc(o);\n  return new _(r * a + e * c + i * l, n * a + s * c + t * l);\n}, Uu = (i, t, e, s, r, n) => (o) => {\n  const a = 1 - o, c = 2 * (a * (e - i) + o * (r - e)), l = 2 * (a * (s - t) + o * (n - s));\n  return Math.atan2(l, c);\n}, Xo = (i, t, e) => {\n  let s = new _(t, e), r = 0;\n  for (let n = 1; n <= 100; n += 1) {\n    const o = i(n / 100);\n    r += ri(s.x, s.y, o.x, o.y), s = o;\n  }\n  return r;\n}, $u = (i, t) => {\n  let e, s = 0, r = 0, n = { x: i.x, y: i.y }, o = v({}, n), a = 0.01, c = 0;\n  const l = i.iterator, h = i.angleFinder;\n  for (; r < t && a > 1e-4; ) o = l(s), c = s, e = ri(n.x, n.y, o.x, o.y), e + r > t ? (s -= a, a /= 2) : (n = o, s += a, r += e);\n  return v(v({}, o), {}, { angle: h(c) });\n}, Qn = (i) => {\n  let t, e, s = 0, r = 0, n = 0, o = 0, a = 0;\n  const c = [];\n  for (const l of i) {\n    const h = { x: r, y: n, command: l[0], length: 0 };\n    switch (l[0]) {\n      case \"M\":\n        e = h, e.x = o = r = l[1], e.y = a = n = l[2];\n        break;\n      case \"L\":\n        e = h, e.length = ri(r, n, l[1], l[2]), r = l[1], n = l[2];\n        break;\n      case \"C\":\n        t = Xc(r, n, l[1], l[2], l[3], l[4], l[5], l[6]), e = h, e.iterator = t, e.angleFinder = Gu(r, n, l[1], l[2], l[3], l[4], l[5], l[6]), e.length = Xo(t, r, n), r = l[5], n = l[6];\n        break;\n      case \"Q\":\n        t = Nu(r, n, l[1], l[2], l[3], l[4]), e = h, e.iterator = t, e.angleFinder = Uu(r, n, l[1], l[2], l[3], l[4]), e.length = Xo(t, r, n), r = l[3], n = l[4];\n        break;\n      case \"Z\":\n        e = h, e.destX = o, e.destY = a, e.length = ri(r, n, o, a), r = o, n = a;\n    }\n    s += e.length, c.push(e);\n  }\n  return c.push({ length: s, x: r, y: n }), c;\n}, Vc = function(i, t) {\n  let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Qn(i), s = 0;\n  for (; t - e[s].length > 0 && s < e.length - 2; ) t -= e[s].length, s++;\n  const r = e[s], n = t / r.length, o = i[s];\n  switch (r.command) {\n    case \"M\":\n      return { x: r.x, y: r.y, angle: 0 };\n    case \"Z\":\n      return v(v({}, new _(r.x, r.y).lerp(new _(r.destX, r.destY), n)), {}, { angle: Math.atan2(r.destY - r.y, r.destX - r.x) });\n    case \"L\":\n      return v(v({}, new _(r.x, r.y).lerp(new _(o[1], o[2]), n)), {}, { angle: Math.atan2(o[2] - r.y, o[1] - r.x) });\n    case \"C\":\n    case \"Q\":\n      return $u(r, t);\n  }\n}, qu = new RegExp(\"[mzlhvcsqta][^mzlhvcsqta]*\", \"gi\"), zo = new RegExp(zu, \"g\"), Ku = new RegExp(Xe, \"gi\"), Ju = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, Gc = (i) => {\n  var t;\n  const e = [], s = (t = i.match(qu)) !== null && t !== void 0 ? t : [];\n  for (const r of s) {\n    const n = r[0];\n    if (n === \"z\" || n === \"Z\") {\n      e.push([n]);\n      continue;\n    }\n    const o = Ju[n.toLowerCase()];\n    let a = [];\n    if (n === \"a\" || n === \"A\") {\n      zo.lastIndex = 0;\n      for (let c = null; c = zo.exec(r); ) a.push(...c.slice(1));\n    } else a = r.match(Ku) || [];\n    for (let c = 0; c < a.length; c += o) {\n      const l = new Array(o), h = Hu[n];\n      l[0] = c > 0 && h ? h : n;\n      for (let u = 0; u < o; u++) l[u + 1] = parseFloat(a[c + u]);\n      e.push(l);\n    }\n  }\n  return e;\n}, Zu = function(i) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, e = new _(i[0]), s = new _(i[1]), r = 1, n = 0;\n  const o = [], a = i.length, c = a > 2;\n  let l;\n  for (c && (r = i[2].x < s.x ? -1 : i[2].x === s.x ? 0 : 1, n = i[2].y < s.y ? -1 : i[2].y === s.y ? 0 : 1), o.push([\"M\", e.x - r * t, e.y - n * t]), l = 1; l < a; l++) {\n    if (!e.eq(s)) {\n      const h = e.midPointFrom(s);\n      o.push([\"Q\", e.x, e.y, h.x, h.y]);\n    }\n    e = i[l], l + 1 < i.length && (s = i[l + 1]);\n  }\n  return c && (r = e.x > i[l - 2].x ? 1 : e.x === i[l - 2].x ? 0 : -1, n = e.y > i[l - 2].y ? 1 : e.y === i[l - 2].y ? 0 : -1), o.push([\"L\", e.x + r * t, e.y + n * t]), o;\n}, Nc = (i, t) => i.map((e) => e.map((s, r) => r === 0 || t === void 0 ? s : V(s, t)).join(\" \")).join(\" \");\nfunction ii(i, t) {\n  const e = i.style;\n  e && t && (typeof t == \"string\" ? e.cssText += \";\" + t : Object.entries(t).forEach((s) => {\n    let [r, n] = s;\n    return e.setProperty(r, n);\n  }));\n}\nconst Qu = (i, t) => Math.floor(Math.random() * (t - i + 1)) + i;\nfunction td(i) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const e = t.onComplete || Be, s = new (fi()).XMLHttpRequest(), r = t.signal, n = function() {\n    s.abort();\n  }, o = function() {\n    r && r.removeEventListener(\"abort\", n), s.onerror = s.ontimeout = Be;\n  };\n  if (r && r.aborted) throw new Fa(\"request\");\n  return r && r.addEventListener(\"abort\", n, { once: !0 }), s.onreadystatechange = function() {\n    s.readyState === 4 && (o(), e(s), s.onreadystatechange = Be);\n  }, s.onerror = s.ontimeout = o, s.open(\"get\", i, !0), s.send(), s;\n}\nconst ed = (i, t) => {\n  let e = i._findCenterFromElement();\n  i.transformMatrix && (((s) => {\n    if (s.transformMatrix) {\n      const { scaleX: r, scaleY: n, angle: o, skewX: a } = ys(s.transformMatrix);\n      s.flipX = !1, s.flipY = !1, s.set(ut, r), s.set(Tt, n), s.angle = o, s.skewX = a, s.skewY = 0;\n    }\n  })(i), e = e.transform(i.transformMatrix)), delete i.transformMatrix, t && (i.scaleX *= t.scaleX, i.scaleY *= t.scaleY, i.cropX = t.cropX, i.cropY = t.cropY, e.x += t.offsetLeft, e.y += t.offsetTop, i.width = t.width, i.height = t.height), i.setPositionByOrigin(e, j, j);\n};\nvar sd = Object.freeze({ __proto__: null, addTransformToObject: ec, animate: Un, animateColor: dc, applyTransformToObject: _s, calcAngleBetweenVectors: ti, calcDimensionsMatrix: ar, calcPlaneChangeMatrix: hr, calcVectorRotation: lc, cancelAnimFrame: Ya, capValue: ze, composeMatrix: $a, copyCanvasElement: (i) => {\n  var t;\n  const e = Wt(i);\n  return (t = e.getContext(\"2d\")) === null || t === void 0 || t.drawImage(i, 0, 0), e;\n}, cos: Lt, createCanvasElement: kt, createImage: Va, createRotateMatrix: Is, createScaleMatrix: vi, createSkewXMatrix: Bn, createSkewYMatrix: Wn, createTranslateMatrix: Ms, createVector: Zr, crossProduct: ps, degreesToRadians: K, dotProduct: hc, ease: Zh, enlivenObjectEnlivables: cr, enlivenObjects: bs, findScaleToCover: Bc, findScaleToFit: Lc, getBoundsOfCurve: mn, getOrthonormalVector: Gn, getPathSegmentsInfo: Qn, getPointOnPath: Vc, getPointer: tc, getRandomInt: Qu, getRegularPolygonPath: (i, t) => {\n  const e = 2 * Math.PI / i;\n  let s = -xe;\n  i % 2 == 0 && (s += e / 2);\n  const r = new Array(i + 1);\n  for (let n = 0; n < i; n++) {\n    const o = n * e + s, { x: a, y: c } = new _(Lt(o), Bt(o)).scalarMultiply(t);\n    r[n] = [n === 0 ? \"M\" : \"L\", a, c];\n  }\n  return r[i] = [\"Z\"], r;\n}, getSmoothPathFromPoints: Zu, getSvgAttributes: (i) => {\n  const t = [\"instantiated_by_use\", \"style\", \"id\", \"class\"];\n  switch (i) {\n    case \"linearGradient\":\n      return t.concat([\"x1\", \"y1\", \"x2\", \"y2\", \"gradientUnits\", \"gradientTransform\"]);\n    case \"radialGradient\":\n      return t.concat([\"gradientUnits\", \"gradientTransform\", \"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\"]);\n    case \"stop\":\n      return t.concat([\"offset\", \"stop-color\", \"stop-opacity\"]);\n  }\n  return t;\n}, getUnitVector: Si, groupSVGElements: (i, t) => i && i.length === 1 ? i[0] : new Nt(i, t), hasStyleChanged: wi, invertTransform: St, isBetweenVectors: cn, isIdentityMatrix: Ga, isTouchEvent: Kr, isTransparent: Mc, joinPath: Nc, loadImage: Ys, magnitude: Qr, makeBoundingBoxFromPoints: Gt, makePathSimpler: Wc, matrixToSVG: qs, mergeClipPaths: (i, t) => {\n  var e;\n  let s = i, r = t;\n  s.inverted && !r.inverted && (s = t, r = i), an(r, (e = r.group) === null || e === void 0 ? void 0 : e.calcTransformMatrix(), s.calcTransformMatrix());\n  const n = s.inverted && r.inverted;\n  return n && (s.inverted = r.inverted = !1), new Nt([s], { clipPath: r, inverted: n });\n}, multiplyTransformMatrices: J, multiplyTransformMatrixArray: mi, parsePath: Gc, parsePreserveAspectRatioAttribute: qa, parseUnit: We, pick: Ve, projectStrokeOnPoints: Dc, qrDecompose: ys, radiansToDegrees: Ce, removeFromArray: Ee, removeTransformFromObject: (i, t) => {\n  const e = St(t), s = J(e, i.calcOwnMatrix());\n  _s(i, s);\n}, removeTransformMatrixForSvgParsing: ed, request: td, requestAnimFrame: Hs, resetObjectTransform: sc, rotatePoint: (i, t, e) => i.rotate(e, t), rotateVector: Vn, saveObjectTransform: zn, sendObjectToPlane: an, sendPointToPlane: ae, sendVectorToPlane: rc, setStyle: ii, sin: Bt, sizeAfterTransform: yi, string: pu, stylesFromArray: Pc, stylesToArray: Ec, toBlob: Ln, toDataURL: Rn, toFixed: V, transformPath: (i, t, e) => (e && (t = J(t, [1, 0, 0, 1, -e.x, -e.y])), i.map((s) => {\n  const r = [...s];\n  for (let n = 1; n < s.length - 1; n += 2) {\n    const { x: o, y: a } = ot({ x: s[n], y: s[n + 1] }, t);\n    r[n] = o, r[n + 1] = a;\n  }\n  return r;\n})), transformPoint: ot });\nclass rd extends Qa {\n  constructor(t) {\n    let { allowTouchScrolling: e = !1, containerClass: s = \"\" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    super(t), y(this, \"upper\", void 0), y(this, \"container\", void 0);\n    const { el: r } = this.lower, n = this.createUpperCanvas();\n    this.upper = { el: n, ctx: n.getContext(\"2d\") }, this.applyCanvasStyle(r, { allowTouchScrolling: e }), this.applyCanvasStyle(n, { allowTouchScrolling: e, styles: { position: \"absolute\", left: \"0\", top: \"0\" } });\n    const o = this.createContainerElement();\n    o.classList.add(s), r.parentNode && r.parentNode.replaceChild(o, r), o.append(r, n), this.container = o;\n  }\n  createUpperCanvas() {\n    const { el: t } = this.lower, e = kt();\n    return e.className = t.className, e.classList.remove(\"lower-canvas\"), e.classList.add(\"upper-canvas\"), e.setAttribute(\"data-fabric\", \"top\"), e.style.cssText = t.style.cssText, e.setAttribute(\"draggable\", \"true\"), e;\n  }\n  createContainerElement() {\n    const t = Cs().createElement(\"div\");\n    return t.setAttribute(\"data-fabric\", \"wrapper\"), ii(t, { position: \"relative\" }), To(t), t;\n  }\n  applyCanvasStyle(t, e) {\n    const { styles: s, allowTouchScrolling: r } = e;\n    ii(t, v(v({}, s), {}, { \"touch-action\": r ? \"manipulation\" : pt })), To(t);\n  }\n  setDimensions(t, e) {\n    super.setDimensions(t, e);\n    const { el: s, ctx: r } = this.upper;\n    Za(s, r, t, e);\n  }\n  setCSSDimensions(t) {\n    super.setCSSDimensions(t), nn(this.upper.el, t), nn(this.container, t);\n  }\n  cleanupDOM(t) {\n    const e = this.container, { el: s } = this.lower, { el: r } = this.upper;\n    super.cleanupDOM(t), e.removeChild(r), e.removeChild(s), e.parentNode && e.parentNode.replaceChild(s, e);\n  }\n  dispose() {\n    super.dispose(), $t().dispose(this.upper.el), delete this.upper, delete this.container;\n  }\n}\nclass Oi extends lr {\n  constructor() {\n    super(...arguments), y(this, \"targets\", []), y(this, \"_hoveredTargets\", []), y(this, \"_objectsToRender\", void 0), y(this, \"_currentTransform\", null), y(this, \"_groupSelector\", null), y(this, \"contextTopDirty\", !1);\n  }\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), Oi.ownDefaults);\n  }\n  get upperCanvasEl() {\n    var t;\n    return (t = this.elements.upper) === null || t === void 0 ? void 0 : t.el;\n  }\n  get contextTop() {\n    var t;\n    return (t = this.elements.upper) === null || t === void 0 ? void 0 : t.ctx;\n  }\n  get wrapperEl() {\n    return this.elements.container;\n  }\n  initElements(t) {\n    this.elements = new rd(t, { allowTouchScrolling: this.allowTouchScrolling, containerClass: this.containerClass }), this._createCacheCanvas();\n  }\n  _onObjectAdded(t) {\n    this._objectsToRender = void 0, super._onObjectAdded(t);\n  }\n  _onObjectRemoved(t) {\n    this._objectsToRender = void 0, t === this._activeObject && (this.fire(\"before:selection:cleared\", { deselected: [t] }), this._discardActiveObject(), this.fire(\"selection:cleared\", { deselected: [t] }), t.fire(\"deselected\", { target: t })), t === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(t);\n  }\n  _onStackOrderChanged() {\n    this._objectsToRender = void 0, super._onStackOrderChanged();\n  }\n  _chooseObjectsToRender() {\n    const t = this._activeObject;\n    return !this.preserveObjectStacking && t ? this._objects.filter((e) => !e.group && e !== t).concat(t) : this._objects;\n  }\n  renderAll() {\n    this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));\n  }\n  renderTopLayer(t) {\n    t.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(t), this.contextTopDirty = !0), t.restore();\n  }\n  renderTop() {\n    const t = this.contextTop;\n    this.clearContext(t), this.renderTopLayer(t), this.fire(\"after:render\", { ctx: t });\n  }\n  setTargetFindTolerance(t) {\n    t = Math.round(t), this.targetFindTolerance = t;\n    const e = this.getRetinaScaling(), s = Math.ceil((2 * t + 1) * e);\n    this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = s, this.pixelFindContext.scale(e, e);\n  }\n  isTargetTransparent(t, e, s) {\n    const r = this.targetFindTolerance, n = this.pixelFindContext;\n    this.clearContext(n), n.save(), n.translate(-e + r, -s + r), n.transform(...this.viewportTransform);\n    const o = t.selectionBackgroundColor;\n    t.selectionBackgroundColor = \"\", t.render(n), t.selectionBackgroundColor = o, n.restore();\n    const a = Math.round(r * this.getRetinaScaling());\n    return Mc(n, a, a, a);\n  }\n  _isSelectionKeyPressed(t) {\n    const e = this.selectionKey;\n    return !!e && (Array.isArray(e) ? !!e.find((s) => !!s && t[s] === !0) : t[e]);\n  }\n  _shouldClearSelection(t, e) {\n    const s = this.getActiveObjects(), r = this._activeObject;\n    return !!(!e || e && r && s.length > 1 && s.indexOf(e) === -1 && r !== e && !this._isSelectionKeyPressed(t) || e && !e.evented || e && !e.selectable && r && r !== e);\n  }\n  _shouldCenterTransform(t, e, s) {\n    if (!t) return;\n    let r;\n    return e === pi || e === ut || e === Tt || e === $s ? r = this.centeredScaling || t.centeredScaling : e === An && (r = this.centeredRotation || t.centeredRotation), r ? !s : s;\n  }\n  _getOriginFromCorner(t, e) {\n    const s = { x: t.originX, y: t.originY };\n    return e && ([\"ml\", \"tl\", \"bl\"].includes(e) ? s.x = Z : [\"mr\", \"tr\", \"br\"].includes(e) && (s.x = L), [\"tl\", \"mt\", \"tr\"].includes(e) ? s.y = rn : [\"bl\", \"mb\", \"br\"].includes(e) && (s.y = gt)), s;\n  }\n  _setupCurrentTransform(t, e, s) {\n    var r;\n    const n = e.group ? ae(this.getScenePoint(t), void 0, e.group.calcTransformMatrix()) : this.getScenePoint(t), { key: o = \"\", control: a } = e.getActiveControl() || {}, c = s && a ? (r = a.getActionHandler(t, e, a)) === null || r === void 0 ? void 0 : r.bind(a) : oc, l = ((f, g, p, m) => {\n      if (!g || !f) return \"drag\";\n      const b = m.controls[g];\n      return b.getActionName(p, b, m);\n    })(s, o, t, e), h = t[this.centeredKey], u = this._shouldCenterTransform(e, l, h) ? { x: j, y: j } : this._getOriginFromCorner(e, o), d = { target: e, action: l, actionHandler: c, actionPerformed: !1, corner: o, scaleX: e.scaleX, scaleY: e.scaleY, skewX: e.skewX, skewY: e.skewY, offsetX: n.x - e.left, offsetY: n.y - e.top, originX: u.x, originY: u.y, ex: n.x, ey: n.y, lastX: n.x, lastY: n.y, theta: K(e.angle), width: e.width, height: e.height, shiftKey: t.shiftKey, altKey: h, original: v(v({}, zn(e)), {}, { originX: u.x, originY: u.y }) };\n    this._currentTransform = d, this.fire(\"before:transform\", { e: t, transform: d });\n  }\n  setCursor(t) {\n    this.upperCanvasEl.style.cursor = t;\n  }\n  _drawSelection(t) {\n    const { x: e, y: s, deltaX: r, deltaY: n } = this._groupSelector, o = new _(e, s).transform(this.viewportTransform), a = new _(e + r, s + n).transform(this.viewportTransform), c = this.selectionLineWidth / 2;\n    let l = Math.min(o.x, a.x), h = Math.min(o.y, a.y), u = Math.max(o.x, a.x), d = Math.max(o.y, a.y);\n    this.selectionColor && (t.fillStyle = this.selectionColor, t.fillRect(l, h, u - l, d - h)), this.selectionLineWidth && this.selectionBorderColor && (t.lineWidth = this.selectionLineWidth, t.strokeStyle = this.selectionBorderColor, l += c, h += c, u -= c, d -= c, nt.prototype._setLineDash.call(this, t, this.selectionDashArray), t.strokeRect(l, h, u - l, d - h));\n  }\n  findTarget(t) {\n    if (this.skipTargetFind) return;\n    const e = this.getViewportPoint(t), s = this._activeObject, r = this.getActiveObjects();\n    if (this.targets = [], s && r.length >= 1) {\n      if (s.findControl(e, Kr(t)) || r.length > 1 && this.searchPossibleTargets([s], e)) return s;\n      if (s === this.searchPossibleTargets([s], e)) {\n        if (this.preserveObjectStacking) {\n          const n = this.targets;\n          this.targets = [];\n          const o = this.searchPossibleTargets(this._objects, e);\n          return t[this.altSelectionKey] && o && o !== s ? (this.targets = n, s) : o;\n        }\n        return s;\n      }\n    }\n    return this.searchPossibleTargets(this._objects, e);\n  }\n  _pointIsInObjectSelectionArea(t, e) {\n    let s = t.getCoords();\n    const r = this.getZoom(), n = t.padding / r;\n    if (n) {\n      const [o, a, c, l] = s, h = Math.atan2(a.y - o.y, a.x - o.x), u = Lt(h) * n, d = Bt(h) * n, f = u + d, g = u - d;\n      s = [new _(o.x - g, o.y - f), new _(a.x + f, a.y - g), new _(c.x + g, c.y + f), new _(l.x - f, l.y + g)];\n    }\n    return N.isPointInPolygon(e, s);\n  }\n  _checkTarget(t, e) {\n    return !!(t && t.visible && t.evented && this._pointIsInObjectSelectionArea(t, ae(e, void 0, this.viewportTransform)) && (!this.perPixelTargetFind && !t.perPixelTargetFind || t.isEditing || !this.isTargetTransparent(t, e.x, e.y)));\n  }\n  _searchPossibleTargets(t, e) {\n    let s = t.length;\n    for (; s--; ) {\n      const r = t[s];\n      if (this._checkTarget(r, e)) {\n        if (Vr(r) && r.subTargetCheck) {\n          const n = this._searchPossibleTargets(r._objects, e);\n          n && this.targets.push(n);\n        }\n        return r;\n      }\n    }\n  }\n  searchPossibleTargets(t, e) {\n    const s = this._searchPossibleTargets(t, e);\n    if (s && Vr(s) && s.interactive && this.targets[0]) {\n      const r = this.targets;\n      for (let n = r.length - 1; n > 0; n--) {\n        const o = r[n];\n        if (!Vr(o) || !o.interactive) return o;\n      }\n      return r[0];\n    }\n    return s;\n  }\n  getViewportPoint(t) {\n    return this._pointer ? this._pointer : this.getPointer(t, !0);\n  }\n  getScenePoint(t) {\n    return this._absolutePointer ? this._absolutePointer : this.getPointer(t);\n  }\n  getPointer(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];\n    const s = this.upperCanvasEl, r = s.getBoundingClientRect();\n    let n = tc(t), o = r.width || 0, a = r.height || 0;\n    o && a || (gt in r && rn in r && (a = Math.abs(r.top - r.bottom)), Z in r && L in r && (o = Math.abs(r.right - r.left))), this.calcOffset(), n.x = n.x - this._offset.left, n.y = n.y - this._offset.top, e || (n = ae(n, void 0, this.viewportTransform));\n    const c = this.getRetinaScaling();\n    c !== 1 && (n.x /= c, n.y /= c);\n    const l = o === 0 || a === 0 ? new _(1, 1) : new _(s.width / o, s.height / a);\n    return n.multiply(l);\n  }\n  _setDimensionsImpl(t, e) {\n    this._resetTransformEventData(), super._setDimensionsImpl(t, e), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);\n  }\n  _createCacheCanvas() {\n    this.pixelFindCanvasEl = kt(), this.pixelFindContext = this.pixelFindCanvasEl.getContext(\"2d\", { willReadFrequently: !0 }), this.setTargetFindTolerance(this.targetFindTolerance);\n  }\n  getTopContext() {\n    return this.elements.upper.ctx;\n  }\n  getSelectionContext() {\n    return this.elements.upper.ctx;\n  }\n  getSelectionElement() {\n    return this.elements.upper.el;\n  }\n  getActiveObject() {\n    return this._activeObject;\n  }\n  getActiveObjects() {\n    const t = this._activeObject;\n    return Pe(t) ? t.getObjects() : t ? [t] : [];\n  }\n  _fireSelectionEvents(t, e) {\n    let s = !1, r = !1;\n    const n = this.getActiveObjects(), o = [], a = [];\n    t.forEach((c) => {\n      n.includes(c) || (s = !0, c.fire(\"deselected\", { e, target: c }), a.push(c));\n    }), n.forEach((c) => {\n      t.includes(c) || (s = !0, c.fire(\"selected\", { e, target: c }), o.push(c));\n    }), t.length > 0 && n.length > 0 ? (r = !0, s && this.fire(\"selection:updated\", { e, selected: o, deselected: a })) : n.length > 0 ? (r = !0, this.fire(\"selection:created\", { e, selected: o })) : t.length > 0 && (r = !0, this.fire(\"selection:cleared\", { e, deselected: a })), r && (this._objectsToRender = void 0);\n  }\n  setActiveObject(t, e) {\n    const s = this.getActiveObjects(), r = this._setActiveObject(t, e);\n    return this._fireSelectionEvents(s, e), r;\n  }\n  _setActiveObject(t, e) {\n    const s = this._activeObject;\n    return s !== t && !(!this._discardActiveObject(e, t) && this._activeObject) && !t.onSelect({ e }) && (this._activeObject = t, Pe(t) && s !== t && t.set(\"canvas\", this), t.setCoords(), !0);\n  }\n  _discardActiveObject(t, e) {\n    const s = this._activeObject;\n    return !!s && !s.onDeselect({ e: t, object: e }) && (this._currentTransform && this._currentTransform.target === s && this.endCurrentTransform(t), Pe(s) && s === this._hoveredTarget && (this._hoveredTarget = void 0), this._activeObject = void 0, !0);\n  }\n  discardActiveObject(t) {\n    const e = this.getActiveObjects(), s = this.getActiveObject();\n    e.length && this.fire(\"before:selection:cleared\", { e: t, deselected: [s] });\n    const r = this._discardActiveObject(t);\n    return this._fireSelectionEvents(e, t), r;\n  }\n  endCurrentTransform(t) {\n    const e = this._currentTransform;\n    this._finalizeCurrentTransform(t), e && e.target && (e.target.isMoving = !1), this._currentTransform = null;\n  }\n  _finalizeCurrentTransform(t) {\n    const e = this._currentTransform, s = e.target, r = { e: t, target: s, transform: e, action: e.action };\n    s._scaling && (s._scaling = !1), s.setCoords(), e.actionPerformed && (this.fire(\"object:modified\", r), s.fire($r, r));\n  }\n  setViewportTransform(t) {\n    super.setViewportTransform(t);\n    const e = this._activeObject;\n    e && e.setCoords();\n  }\n  destroy() {\n    const t = this._activeObject;\n    Pe(t) && (t.removeAll(), t.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;\n  }\n  clear() {\n    this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();\n  }\n  drawControls(t) {\n    const e = this._activeObject;\n    e && e._renderControls(t);\n  }\n  _toObject(t, e, s) {\n    const r = this._realizeGroupTransformOnObject(t), n = super._toObject(t, e, s);\n    return t.set(r), n;\n  }\n  _realizeGroupTransformOnObject(t) {\n    const { group: e } = t;\n    if (e && Pe(e) && this._activeObject === e) {\n      const s = Ve(t, [\"angle\", \"flipX\", \"flipY\", L, ut, Tt, Os, ks, gt]);\n      return ec(t, e.calcOwnMatrix()), s;\n    }\n    return {};\n  }\n  _setSVGObject(t, e, s) {\n    const r = this._realizeGroupTransformOnObject(e);\n    super._setSVGObject(t, e, s), e.set(r);\n  }\n}\ny(Oi, \"ownDefaults\", { uniformScaling: !0, uniScaleKey: \"shiftKey\", centeredScaling: !1, centeredRotation: !1, centeredKey: \"altKey\", altActionKey: \"shiftKey\", selection: !0, selectionKey: \"shiftKey\", selectionColor: \"rgba(100, 100, 255, 0.3)\", selectionDashArray: [], selectionBorderColor: \"rgba(255, 255, 255, 0.3)\", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: \"move\", moveCursor: \"move\", defaultCursor: \"default\", freeDrawingCursor: \"crosshair\", notAllowedCursor: \"not-allowed\", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, enablePointerEvents: !1, containerClass: \"canvas-container\", preserveObjectStacking: !1 });\nclass id {\n  constructor(t) {\n    y(this, \"targets\", []), y(this, \"__disposer\", void 0);\n    const e = () => {\n      const { hiddenTextarea: r } = t.getActiveObject() || {};\n      r && r.focus();\n    }, s = t.upperCanvasEl;\n    s.addEventListener(\"click\", e), this.__disposer = () => s.removeEventListener(\"click\", e);\n  }\n  exitTextEditing() {\n    this.target = void 0, this.targets.forEach((t) => {\n      t.isEditing && t.exitEditing();\n    });\n  }\n  add(t) {\n    this.targets.push(t);\n  }\n  remove(t) {\n    this.unregister(t), Ee(this.targets, t);\n  }\n  register(t) {\n    this.target = t;\n  }\n  unregister(t) {\n    t === this.target && (this.target = void 0);\n  }\n  onMouseMove(t) {\n    var e;\n    !((e = this.target) === null || e === void 0) && e.isEditing && this.target.updateSelectionOnMouseMove(t);\n  }\n  clear() {\n    this.targets = [], this.target = void 0;\n  }\n  dispose() {\n    this.clear(), this.__disposer(), delete this.__disposer;\n  }\n}\nconst nd = [\"target\", \"oldTarget\", \"fireCanvas\", \"e\"], bt = { passive: !1 }, Ke = (i, t) => {\n  const e = i.getViewportPoint(t), s = i.getScenePoint(t);\n  return { viewportPoint: e, scenePoint: s, pointer: e, absolutePointer: s };\n}, be = function(i) {\n  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) e[s - 1] = arguments[s];\n  return i.addEventListener(...e);\n}, xt = function(i) {\n  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) e[s - 1] = arguments[s];\n  return i.removeEventListener(...e);\n}, od = { mouse: { in: \"over\", out: \"out\", targetIn: \"mouseover\", targetOut: \"mouseout\", canvasIn: \"mouse:over\", canvasOut: \"mouse:out\" }, drag: { in: \"enter\", out: \"leave\", targetIn: \"dragenter\", targetOut: \"dragleave\", canvasIn: \"drag:enter\", canvasOut: \"drag:leave\" } };\nclass vn extends Oi {\n  constructor(t) {\n    super(t, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}), y(this, \"_isClick\", void 0), y(this, \"textEditingManager\", new id(this)), [\"_onMouseDown\", \"_onTouchStart\", \"_onMouseMove\", \"_onMouseUp\", \"_onTouchEnd\", \"_onResize\", \"_onMouseWheel\", \"_onMouseOut\", \"_onMouseEnter\", \"_onContextMenu\", \"_onDoubleClick\", \"_onDragStart\", \"_onDragEnd\", \"_onDragProgress\", \"_onDragOver\", \"_onDragEnter\", \"_onDragLeave\", \"_onDrop\"].forEach((e) => {\n      this[e] = this[e].bind(this);\n    }), this.addOrRemove(be, \"add\");\n  }\n  _getEventPrefix() {\n    return this.enablePointerEvents ? \"pointer\" : \"mouse\";\n  }\n  addOrRemove(t, e) {\n    const s = this.upperCanvasEl, r = this._getEventPrefix();\n    t(Ja(s), \"resize\", this._onResize), t(s, r + \"down\", this._onMouseDown), t(s, \"\".concat(r, \"move\"), this._onMouseMove, bt), t(s, \"\".concat(r, \"out\"), this._onMouseOut), t(s, \"\".concat(r, \"enter\"), this._onMouseEnter), t(s, \"wheel\", this._onMouseWheel), t(s, \"contextmenu\", this._onContextMenu), t(s, \"dblclick\", this._onDoubleClick), t(s, \"dragstart\", this._onDragStart), t(s, \"dragend\", this._onDragEnd), t(s, \"dragover\", this._onDragOver), t(s, \"dragenter\", this._onDragEnter), t(s, \"dragleave\", this._onDragLeave), t(s, \"drop\", this._onDrop), this.enablePointerEvents || t(s, \"touchstart\", this._onTouchStart, bt);\n  }\n  removeListeners() {\n    this.addOrRemove(xt, \"remove\");\n    const t = this._getEventPrefix(), e = At(this.upperCanvasEl);\n    xt(e, \"\".concat(t, \"up\"), this._onMouseUp), xt(e, \"touchend\", this._onTouchEnd, bt), xt(e, \"\".concat(t, \"move\"), this._onMouseMove, bt), xt(e, \"touchmove\", this._onMouseMove, bt), clearTimeout(this._willAddMouseDown);\n  }\n  _onMouseWheel(t) {\n    this.__onMouseWheel(t);\n  }\n  _onMouseOut(t) {\n    const e = this._hoveredTarget, s = v({ e: t }, Ke(this, t));\n    this.fire(\"mouse:out\", v(v({}, s), {}, { target: e })), this._hoveredTarget = void 0, e && e.fire(\"mouseout\", v({}, s)), this._hoveredTargets.forEach((r) => {\n      this.fire(\"mouse:out\", v(v({}, s), {}, { target: r })), r && r.fire(\"mouseout\", v({}, s));\n    }), this._hoveredTargets = [];\n  }\n  _onMouseEnter(t) {\n    this._currentTransform || this.findTarget(t) || (this.fire(\"mouse:over\", v({ e: t }, Ke(this, t))), this._hoveredTarget = void 0, this._hoveredTargets = []);\n  }\n  _onDragStart(t) {\n    this._isClick = !1;\n    const e = this.getActiveObject();\n    if (e && e.onDragStart(t)) {\n      this._dragSource = e;\n      const s = { e: t, target: e };\n      return this.fire(\"dragstart\", s), e.fire(\"dragstart\", s), void be(this.upperCanvasEl, \"drag\", this._onDragProgress);\n    }\n    on(t);\n  }\n  _renderDragEffects(t, e, s) {\n    let r = !1;\n    const n = this._dropTarget;\n    n && n !== e && n !== s && (n.clearContextTop(), r = !0), e == null || e.clearContextTop(), s !== e && (s == null || s.clearContextTop());\n    const o = this.contextTop;\n    o.save(), o.transform(...this.viewportTransform), e && (o.save(), e.transform(o), e.renderDragSourceEffect(t), o.restore(), r = !0), s && (o.save(), s.transform(o), s.renderDropTargetEffect(t), o.restore(), r = !0), o.restore(), r && (this.contextTopDirty = !0);\n  }\n  _onDragEnd(t) {\n    const e = !!t.dataTransfer && t.dataTransfer.dropEffect !== pt, s = e ? this._activeObject : void 0, r = { e: t, target: this._dragSource, subTargets: this.targets, dragSource: this._dragSource, didDrop: e, dropTarget: s };\n    xt(this.upperCanvasEl, \"drag\", this._onDragProgress), this.fire(\"dragend\", r), this._dragSource && this._dragSource.fire(\"dragend\", r), delete this._dragSource, this._onMouseUp(t);\n  }\n  _onDragProgress(t) {\n    const e = { e: t, target: this._dragSource, dragSource: this._dragSource, dropTarget: this._draggedoverTarget };\n    this.fire(\"drag\", e), this._dragSource && this._dragSource.fire(\"drag\", e);\n  }\n  findDragTargets(t) {\n    return this.targets = [], { target: this._searchPossibleTargets(this._objects, this.getViewportPoint(t)), targets: [...this.targets] };\n  }\n  _onDragOver(t) {\n    const e = \"dragover\", { target: s, targets: r } = this.findDragTargets(t), n = this._dragSource, o = { e: t, target: s, subTargets: r, dragSource: n, canDrop: !1, dropTarget: void 0 };\n    let a;\n    this.fire(e, o), this._fireEnterLeaveEvents(s, o), s && (s.canDrop(t) && (a = s), s.fire(e, o));\n    for (let c = 0; c < r.length; c++) {\n      const l = r[c];\n      l.canDrop(t) && (a = l), l.fire(e, o);\n    }\n    this._renderDragEffects(t, n, a), this._dropTarget = a;\n  }\n  _onDragEnter(t) {\n    const { target: e, targets: s } = this.findDragTargets(t), r = { e: t, target: e, subTargets: s, dragSource: this._dragSource };\n    this.fire(\"dragenter\", r), this._fireEnterLeaveEvents(e, r);\n  }\n  _onDragLeave(t) {\n    const e = { e: t, target: this._draggedoverTarget, subTargets: this.targets, dragSource: this._dragSource };\n    this.fire(\"dragleave\", e), this._fireEnterLeaveEvents(void 0, e), this._renderDragEffects(t, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];\n  }\n  _onDrop(t) {\n    const { target: e, targets: s } = this.findDragTargets(t), r = this._basicEventHandler(\"drop:before\", v({ e: t, target: e, subTargets: s, dragSource: this._dragSource }, Ke(this, t)));\n    r.didDrop = !1, r.dropTarget = void 0, this._basicEventHandler(\"drop\", r), this.fire(\"drop:after\", r);\n  }\n  _onContextMenu(t) {\n    const e = this.findTarget(t), s = this.targets || [], r = this._basicEventHandler(\"contextmenu:before\", { e: t, target: e, subTargets: s });\n    return this.stopContextMenu && on(t), this._basicEventHandler(\"contextmenu\", r), !1;\n  }\n  _onDoubleClick(t) {\n    this._cacheTransformEventData(t), this._handleEvent(t, \"dblclick\"), this._resetTransformEventData();\n  }\n  getPointerId(t) {\n    const e = t.changedTouches;\n    return e ? e[0] && e[0].identifier : this.enablePointerEvents ? t.pointerId : -1;\n  }\n  _isMainEvent(t) {\n    return t.isPrimary === !0 || t.isPrimary !== !1 && (t.type === \"touchend\" && t.touches.length === 0 || !t.changedTouches || t.changedTouches[0].identifier === this.mainTouchId);\n  }\n  _onTouchStart(t) {\n    let e = !this.allowTouchScrolling;\n    const s = this._activeObject;\n    this.mainTouchId === void 0 && (this.mainTouchId = this.getPointerId(t)), this.__onMouseDown(t), (this.isDrawingMode || s && this._target === s) && (e = !0), e && t.preventDefault(), this._resetTransformEventData();\n    const r = this.upperCanvasEl, n = this._getEventPrefix(), o = At(r);\n    be(o, \"touchend\", this._onTouchEnd, bt), e && be(o, \"touchmove\", this._onMouseMove, bt), xt(r, \"\".concat(n, \"down\"), this._onMouseDown);\n  }\n  _onMouseDown(t) {\n    this.__onMouseDown(t), this._resetTransformEventData();\n    const e = this.upperCanvasEl, s = this._getEventPrefix();\n    xt(e, \"\".concat(s, \"move\"), this._onMouseMove, bt);\n    const r = At(e);\n    be(r, \"\".concat(s, \"up\"), this._onMouseUp), be(r, \"\".concat(s, \"move\"), this._onMouseMove, bt);\n  }\n  _onTouchEnd(t) {\n    if (t.touches.length > 0) return;\n    this.__onMouseUp(t), this._resetTransformEventData(), delete this.mainTouchId;\n    const e = this._getEventPrefix(), s = At(this.upperCanvasEl);\n    xt(s, \"touchend\", this._onTouchEnd, bt), xt(s, \"touchmove\", this._onMouseMove, bt), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(() => {\n      be(this.upperCanvasEl, \"\".concat(e, \"down\"), this._onMouseDown), this._willAddMouseDown = 0;\n    }, 400);\n  }\n  _onMouseUp(t) {\n    this.__onMouseUp(t), this._resetTransformEventData();\n    const e = this.upperCanvasEl, s = this._getEventPrefix();\n    if (this._isMainEvent(t)) {\n      const r = At(this.upperCanvasEl);\n      xt(r, \"\".concat(s, \"up\"), this._onMouseUp), xt(r, \"\".concat(s, \"move\"), this._onMouseMove, bt), be(e, \"\".concat(s, \"move\"), this._onMouseMove, bt);\n    }\n  }\n  _onMouseMove(t) {\n    const e = this.getActiveObject();\n    !this.allowTouchScrolling && (!e || !e.shouldStartDragging(t)) && t.preventDefault && t.preventDefault(), this.__onMouseMove(t);\n  }\n  _onResize() {\n    this.calcOffset(), this._resetTransformEventData();\n  }\n  _shouldRender(t) {\n    const e = this.getActiveObject();\n    return !!e != !!t || e && t && e !== t;\n  }\n  __onMouseUp(t) {\n    var e;\n    this._cacheTransformEventData(t), this._handleEvent(t, \"up:before\");\n    const s = this._currentTransform, r = this._isClick, n = this._target, { button: o } = t;\n    if (o) return (this.fireMiddleClick && o === 1 || this.fireRightClick && o === 2) && this._handleEvent(t, \"up\"), void this._resetTransformEventData();\n    if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(t);\n    if (!this._isMainEvent(t)) return;\n    let a, c, l = !1;\n    if (s && (this._finalizeCurrentTransform(t), l = s.actionPerformed), !r) {\n      const h = n === this._activeObject;\n      this.handleSelection(t), l || (l = this._shouldRender(n) || !h && n === this._activeObject);\n    }\n    if (n) {\n      const h = n.findControl(this.getViewportPoint(t), Kr(t)), { key: u, control: d } = h || {};\n      if (c = u, n.selectable && n !== this._activeObject && n.activeOn === \"up\") this.setActiveObject(n, t), l = !0;\n      else if (d) {\n        const f = d.getMouseUpHandler(t, n, d);\n        f && (a = this.getScenePoint(t), f.call(d, t, s, a.x, a.y));\n      }\n      n.isMoving = !1;\n    }\n    if (s && (s.target !== n || s.corner !== c)) {\n      const h = s.target && s.target.controls[s.corner], u = h && h.getMouseUpHandler(t, s.target, h);\n      a = a || this.getScenePoint(t), u && u.call(h, t, s, a.x, a.y);\n    }\n    this._setCursorFromEvent(t, n), this._handleEvent(t, \"up\"), this._groupSelector = null, this._currentTransform = null, n && (n.__corner = void 0), l ? this.requestRenderAll() : r || (e = this._activeObject) !== null && e !== void 0 && e.isEditing || this.renderTop();\n  }\n  _basicEventHandler(t, e) {\n    const { target: s, subTargets: r = [] } = e;\n    this.fire(t, e), s && s.fire(t, e);\n    for (let n = 0; n < r.length; n++) r[n] !== s && r[n].fire(t, e);\n    return e;\n  }\n  _handleEvent(t, e) {\n    const s = this._target, r = this.targets || [], n = v(v({ e: t, target: s, subTargets: r }, Ke(this, t)), {}, { transform: this._currentTransform }, e === \"up:before\" || e === \"up\" ? { isClick: this._isClick, currentTarget: this.findTarget(t), currentSubTargets: this.targets } : {});\n    this.fire(\"mouse:\".concat(e), n), s && s.fire(\"mouse\".concat(e), n);\n    for (let o = 0; o < r.length; o++) r[o] !== s && r[o].fire(\"mouse\".concat(e), n);\n  }\n  _onMouseDownInDrawingMode(t) {\n    this._isCurrentlyDrawing = !0, this.getActiveObject() && (this.discardActiveObject(t), this.requestRenderAll());\n    const e = this.getScenePoint(t);\n    this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(e, { e: t, pointer: e }), this._handleEvent(t, \"down\");\n  }\n  _onMouseMoveInDrawingMode(t) {\n    if (this._isCurrentlyDrawing) {\n      const e = this.getScenePoint(t);\n      this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(e, { e: t, pointer: e });\n    }\n    this.setCursor(this.freeDrawingCursor), this._handleEvent(t, \"move\");\n  }\n  _onMouseUpInDrawingMode(t) {\n    const e = this.getScenePoint(t);\n    this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({ e: t, pointer: e }) : this._isCurrentlyDrawing = !1, this._handleEvent(t, \"up\");\n  }\n  __onMouseDown(t) {\n    this._isClick = !0, this._cacheTransformEventData(t), this._handleEvent(t, \"down:before\");\n    let e = this._target;\n    const { button: s } = t;\n    if (s) return (this.fireMiddleClick && s === 1 || this.fireRightClick && s === 2) && this._handleEvent(t, \"down\"), void this._resetTransformEventData();\n    if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(t);\n    if (!this._isMainEvent(t) || this._currentTransform) return;\n    let r = this._shouldRender(e), n = !1;\n    if (this.handleMultiSelection(t, e) ? (e = this._activeObject, n = !0, r = !0) : this._shouldClearSelection(t, e) && this.discardActiveObject(t), this.selection && (!e || !e.selectable && !e.isEditing && e !== this._activeObject)) {\n      const o = this.getScenePoint(t);\n      this._groupSelector = { x: o.x, y: o.y, deltaY: 0, deltaX: 0 };\n    }\n    if (e) {\n      const o = e === this._activeObject;\n      e.selectable && e.activeOn === \"down\" && this.setActiveObject(e, t);\n      const a = e.findControl(this.getViewportPoint(t), Kr(t));\n      if (e === this._activeObject && (a || !n)) {\n        this._setupCurrentTransform(t, e, o);\n        const c = a ? a.control : void 0, l = this.getScenePoint(t), h = c && c.getMouseDownHandler(t, e, c);\n        h && h.call(c, t, this._currentTransform, l.x, l.y);\n      }\n    }\n    r && (this._objectsToRender = void 0), this._handleEvent(t, \"down\"), r && this.requestRenderAll();\n  }\n  _resetTransformEventData() {\n    this._target = this._pointer = this._absolutePointer = void 0;\n  }\n  _cacheTransformEventData(t) {\n    this._resetTransformEventData(), this._pointer = this.getViewportPoint(t), this._absolutePointer = ae(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(t);\n  }\n  __onMouseMove(t) {\n    if (this._isClick = !1, this._cacheTransformEventData(t), this._handleEvent(t, \"move:before\"), this.isDrawingMode) return void this._onMouseMoveInDrawingMode(t);\n    if (!this._isMainEvent(t)) return;\n    const e = this._groupSelector;\n    if (e) {\n      const s = this.getScenePoint(t);\n      e.deltaX = s.x - e.x, e.deltaY = s.y - e.y, this.renderTop();\n    } else if (this._currentTransform) this._transformObject(t);\n    else {\n      const s = this.findTarget(t);\n      this._setCursorFromEvent(t, s), this._fireOverOutEvents(t, s);\n    }\n    this.textEditingManager.onMouseMove(t), this._handleEvent(t, \"move\"), this._resetTransformEventData();\n  }\n  _fireOverOutEvents(t, e) {\n    const s = this._hoveredTarget, r = this._hoveredTargets, n = this.targets, o = Math.max(r.length, n.length);\n    this.fireSyntheticInOutEvents(\"mouse\", { e: t, target: e, oldTarget: s, fireCanvas: !0 });\n    for (let a = 0; a < o; a++) this.fireSyntheticInOutEvents(\"mouse\", { e: t, target: n[a], oldTarget: r[a] });\n    this._hoveredTarget = e, this._hoveredTargets = this.targets.concat();\n  }\n  _fireEnterLeaveEvents(t, e) {\n    const s = this._draggedoverTarget, r = this._hoveredTargets, n = this.targets, o = Math.max(r.length, n.length);\n    this.fireSyntheticInOutEvents(\"drag\", v(v({}, e), {}, { target: t, oldTarget: s, fireCanvas: !0 }));\n    for (let a = 0; a < o; a++) this.fireSyntheticInOutEvents(\"drag\", v(v({}, e), {}, { target: n[a], oldTarget: r[a] }));\n    this._draggedoverTarget = t;\n  }\n  fireSyntheticInOutEvents(t, e) {\n    let { target: s, oldTarget: r, fireCanvas: n, e: o } = e, a = G(e, nd);\n    const { targetIn: c, targetOut: l, canvasIn: h, canvasOut: u } = od[t], d = r !== s;\n    if (r && d) {\n      const f = v(v({}, a), {}, { e: o, target: r, nextTarget: s }, Ke(this, o));\n      n && this.fire(u, f), r.fire(l, f);\n    }\n    if (s && d) {\n      const f = v(v({}, a), {}, { e: o, target: s, previousTarget: r }, Ke(this, o));\n      n && this.fire(h, f), s.fire(c, f);\n    }\n  }\n  __onMouseWheel(t) {\n    this._cacheTransformEventData(t), this._handleEvent(t, \"wheel\"), this._resetTransformEventData();\n  }\n  _transformObject(t) {\n    const e = this.getScenePoint(t), s = this._currentTransform, r = s.target, n = r.group ? ae(e, void 0, r.group.calcTransformMatrix()) : e;\n    s.shiftKey = t.shiftKey, s.altKey = !!this.centeredKey && t[this.centeredKey], this._performTransformAction(t, s, n), s.actionPerformed && this.requestRenderAll();\n  }\n  _performTransformAction(t, e, s) {\n    const { action: r, actionHandler: n, target: o } = e, a = !!n && n(t, e, s.x, s.y);\n    a && o.setCoords(), r === \"drag\" && a && (e.target.isMoving = !0, this.setCursor(e.target.moveCursor || this.moveCursor)), e.actionPerformed = e.actionPerformed || a;\n  }\n  _setCursorFromEvent(t, e) {\n    if (!e) return void this.setCursor(this.defaultCursor);\n    let s = e.hoverCursor || this.hoverCursor;\n    const r = Pe(this._activeObject) ? this._activeObject : null, n = (!r || e.group !== r) && e.findControl(this.getViewportPoint(t));\n    if (n) {\n      const o = n.control;\n      this.setCursor(o.cursorStyleHandler(t, o, e));\n    } else e.subTargetCheck && this.targets.concat().reverse().map((o) => {\n      s = o.hoverCursor || s;\n    }), this.setCursor(s);\n  }\n  handleMultiSelection(t, e) {\n    const s = this._activeObject, r = Pe(s);\n    if (s && this._isSelectionKeyPressed(t) && this.selection && e && e.selectable && (s !== e || r) && (r || !e.isDescendantOf(s) && !s.isDescendantOf(e)) && !e.onSelect({ e: t }) && !s.getActiveControl()) {\n      if (r) {\n        const n = s.getObjects();\n        if (e === s) {\n          const o = this.getViewportPoint(t);\n          if (!(e = this.searchPossibleTargets(n, o) || this.searchPossibleTargets(this._objects, o)) || !e.selectable) return !1;\n        }\n        e.group === s ? (s.remove(e), this._hoveredTarget = e, this._hoveredTargets = [...this.targets], s.size() === 1 && this._setActiveObject(s.item(0), t)) : (s.multiSelectAdd(e), this._hoveredTarget = s, this._hoveredTargets = [...this.targets]), this._fireSelectionEvents(n, t);\n      } else {\n        s.isEditing && s.exitEditing();\n        const n = new (C.getClass(\"ActiveSelection\"))([], { canvas: this });\n        n.multiSelectAdd(s, e), this._hoveredTarget = n, this._setActiveObject(n, t), this._fireSelectionEvents([s], t);\n      }\n      return !0;\n    }\n    return !1;\n  }\n  handleSelection(t) {\n    if (!this.selection || !this._groupSelector) return !1;\n    const { x: e, y: s, deltaX: r, deltaY: n } = this._groupSelector, o = new _(e, s), a = o.add(new _(r, n)), c = o.min(a), l = o.max(a).subtract(c), h = this.collectObjects({ left: c.x, top: c.y, width: l.x, height: l.y }, { includeIntersecting: !this.selectionFullyContained }), u = o.eq(a) ? h[0] ? [h[0]] : [] : h.length > 1 ? h.filter((d) => !d.onSelect({ e: t })).reverse() : h;\n    if (u.length === 1) this.setActiveObject(u[0], t);\n    else if (u.length > 1) {\n      const d = C.getClass(\"ActiveSelection\");\n      this.setActiveObject(new d(u, { canvas: this }), t);\n    }\n    return this._groupSelector = null, !0;\n  }\n  clear() {\n    this.textEditingManager.clear(), super.clear();\n  }\n  destroy() {\n    this.removeListeners(), this.textEditingManager.dispose(), super.destroy();\n  }\n}\nconst Uc = { x1: 0, y1: 0, x2: 0, y2: 0 }, ad = v(v({}, Uc), {}, { r1: 0, r2: 0 }), Qe = (i, t) => isNaN(i) && typeof t == \"number\" ? t : i, cd = /^(\\d+\\.\\d+)%|(\\d+)%$/;\nfunction $c(i) {\n  return i && cd.test(i);\n}\nfunction qc(i, t) {\n  const e = typeof i == \"number\" ? i : typeof i == \"string\" ? parseFloat(i) / ($c(i) ? 100 : 1) : NaN;\n  return ze(0, Qe(e, t), 1);\n}\nconst ld = /\\s*;\\s*/, hd = /\\s*:\\s*/;\nfunction ud(i, t) {\n  let e, s;\n  const r = i.getAttribute(\"style\");\n  if (r) {\n    const o = r.split(ld);\n    o[o.length - 1] === \"\" && o.pop();\n    for (let a = o.length; a--; ) {\n      const [c, l] = o[a].split(hd).map((h) => h.trim());\n      c === \"stop-color\" ? e = l : c === \"stop-opacity\" && (s = l);\n    }\n  }\n  const n = new W(e || i.getAttribute(\"stop-color\") || \"rgb(0,0,0)\");\n  return { offset: qc(i.getAttribute(\"offset\"), 0), color: n.toRgb(), opacity: Qe(parseFloat(s || i.getAttribute(\"stop-opacity\") || \"\"), 1) * n.getAlpha() * t };\n}\nfunction dd(i, t) {\n  const e = [], s = i.getElementsByTagName(\"stop\"), r = qc(t, 1);\n  for (let n = s.length; n--; ) e.push(ud(s[n], r));\n  return e;\n}\nfunction Kc(i) {\n  return i.nodeName === \"linearGradient\" || i.nodeName === \"LINEARGRADIENT\" ? \"linear\" : \"radial\";\n}\nfunction Jc(i) {\n  return i.getAttribute(\"gradientUnits\") === \"userSpaceOnUse\" ? \"pixels\" : \"percentage\";\n}\nfunction jt(i, t) {\n  return i.getAttribute(t);\n}\nfunction fd(i, t) {\n  return function(e, s) {\n    let r, { width: n, height: o, gradientUnits: a } = s;\n    return Object.keys(e).reduce((c, l) => {\n      const h = e[l];\n      return h === \"Infinity\" ? r = 1 : h === \"-Infinity\" ? r = 0 : (r = typeof h == \"string\" ? parseFloat(h) : h, typeof h == \"string\" && $c(h) && (r *= 0.01, a === \"pixels\" && (l !== \"x1\" && l !== \"x2\" && l !== \"r2\" || (r *= n), l !== \"y1\" && l !== \"y2\" || (r *= o)))), c[l] = r, c;\n    }, {});\n  }(Kc(i) === \"linear\" ? function(e) {\n    return { x1: jt(e, \"x1\") || 0, y1: jt(e, \"y1\") || 0, x2: jt(e, \"x2\") || \"100%\", y2: jt(e, \"y2\") || 0 };\n  }(i) : function(e) {\n    return { x1: jt(e, \"fx\") || jt(e, \"cx\") || \"50%\", y1: jt(e, \"fy\") || jt(e, \"cy\") || \"50%\", r1: 0, x2: jt(e, \"cx\") || \"50%\", y2: jt(e, \"cy\") || \"50%\", r2: jt(e, \"r\") || \"50%\" };\n  }(i), v(v({}, t), {}, { gradientUnits: Jc(i) }));\n}\nclass yr {\n  constructor(t) {\n    const { type: e = \"linear\", gradientUnits: s = \"pixels\", coords: r = {}, colorStops: n = [], offsetX: o = 0, offsetY: a = 0, gradientTransform: c, id: l } = t || {};\n    Object.assign(this, { type: e, gradientUnits: s, coords: v(v({}, e === \"radial\" ? ad : Uc), r), colorStops: n, offsetX: o, offsetY: a, gradientTransform: c, id: l ? \"\".concat(l, \"_\").concat(we()) : we() });\n  }\n  addColorStop(t) {\n    for (const e in t) {\n      const s = new W(t[e]);\n      this.colorStops.push({ offset: parseFloat(e), color: s.toRgb(), opacity: s.getAlpha() });\n    }\n    return this;\n  }\n  toObject(t) {\n    return v(v({}, Ve(this, t)), {}, { type: this.type, coords: v({}, this.coords), colorStops: this.colorStops.map((e) => v({}, e)), offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? [...this.gradientTransform] : void 0 });\n  }\n  toSVG(t) {\n    let { additionalTransform: e } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const s = [], r = this.gradientTransform ? this.gradientTransform.concat() : ht.concat(), n = this.gradientUnits === \"pixels\" ? \"userSpaceOnUse\" : \"objectBoundingBox\", o = this.colorStops.map((u) => v({}, u)).sort((u, d) => u.offset - d.offset);\n    let a = -this.offsetX, c = -this.offsetY;\n    var l;\n    n === \"objectBoundingBox\" ? (a /= t.width, c /= t.height) : (a += t.width / 2, c += t.height / 2), (l = t) && typeof l._renderPathCommands == \"function\" && this.gradientUnits !== \"percentage\" && (a -= t.pathOffset.x, c -= t.pathOffset.y), r[4] -= a, r[5] -= c;\n    const h = ['id=\"SVGID_'.concat(this.id, '\"'), 'gradientUnits=\"'.concat(n, '\"'), 'gradientTransform=\"'.concat(e ? e + \" \" : \"\").concat(qs(r), '\"'), \"\"].join(\" \");\n    if (this.type === \"linear\") {\n      const { x1: u, y1: d, x2: f, y2: g } = this.coords;\n      s.push(\"<linearGradient \", h, ' x1=\"', u, '\" y1=\"', d, '\" x2=\"', f, '\" y2=\"', g, `\">\n`);\n    } else if (this.type === \"radial\") {\n      const { x1: u, y1: d, x2: f, y2: g, r1: p, r2: m } = this.coords, b = p > m;\n      s.push(\"<radialGradient \", h, ' cx=\"', b ? u : f, '\" cy=\"', b ? d : g, '\" r=\"', b ? p : m, '\" fx=\"', b ? f : u, '\" fy=\"', b ? g : d, `\">\n`), b && (o.reverse(), o.forEach((w) => {\n        w.offset = 1 - w.offset;\n      }));\n      const S = Math.min(p, m);\n      if (S > 0) {\n        const w = S / Math.max(p, m);\n        o.forEach((k) => {\n          k.offset += w * (1 - k.offset);\n        });\n      }\n    }\n    return o.forEach((u) => {\n      let { color: d, offset: f, opacity: g } = u;\n      s.push(\"<stop \", 'offset=\"', 100 * f + \"%\", '\" style=\"stop-color:', d, g !== void 0 ? \";stop-opacity: \" + g : \";\", `\"/>\n`);\n    }), s.push(this.type === \"linear\" ? \"</linearGradient>\" : \"</radialGradient>\", `\n`), s.join(\"\");\n  }\n  toLive(t) {\n    const { x1: e, y1: s, x2: r, y2: n, r1: o, r2: a } = this.coords, c = this.type === \"linear\" ? t.createLinearGradient(e, s, r, n) : t.createRadialGradient(e, s, o, r, n, a);\n    return this.colorStops.forEach((l) => {\n      let { color: h, opacity: u, offset: d } = l;\n      c.addColorStop(d, u !== void 0 ? new W(h).setAlpha(u).toRgba() : h);\n    }), c;\n  }\n  static async fromObject(t) {\n    const { colorStops: e, gradientTransform: s } = t;\n    return new this(v(v({}, t), {}, { colorStops: e ? e.map((r) => v({}, r)) : void 0, gradientTransform: s ? [...s] : void 0 }));\n  }\n  static fromElement(t, e, s) {\n    const r = Jc(t), n = e._findCenterFromElement();\n    return new this(v({ id: t.getAttribute(\"id\") || void 0, type: Kc(t), coords: fd(t, { width: s.viewBoxWidth || s.width, height: s.viewBoxHeight || s.height }), colorStops: dd(t, s.opacity), gradientUnits: r, gradientTransform: fn(t.getAttribute(\"gradientTransform\") || \"\") }, r === \"pixels\" ? { offsetX: e.width / 2 - n.x, offsetY: e.height / 2 - n.y } : { offsetX: 0, offsetY: 0 }));\n  }\n}\ny(yr, \"type\", \"Gradient\"), C.setClass(yr, \"gradient\"), C.setClass(yr, \"linear\"), C.setClass(yr, \"radial\");\nconst gd = [\"type\", \"source\", \"patternTransform\"];\nclass Yi {\n  get type() {\n    return \"pattern\";\n  }\n  set type(t) {\n    Te(\"warn\", \"Setting type has no effect\", t);\n  }\n  constructor(t) {\n    y(this, \"repeat\", \"repeat\"), y(this, \"offsetX\", 0), y(this, \"offsetY\", 0), y(this, \"crossOrigin\", \"\"), this.id = we(), Object.assign(this, t);\n  }\n  isImageSource() {\n    return !!this.source && typeof this.source.src == \"string\";\n  }\n  isCanvasSource() {\n    return !!this.source && !!this.source.toDataURL;\n  }\n  sourceToString() {\n    return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : \"\";\n  }\n  toLive(t) {\n    return this.source && (!this.isImageSource() || this.source.complete && this.source.naturalWidth !== 0 && this.source.naturalHeight !== 0) ? t.createPattern(this.source, this.repeat) : null;\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    const { repeat: e, crossOrigin: s } = this;\n    return v(v({}, Ve(this, t)), {}, { type: \"pattern\", source: this.sourceToString(), repeat: e, crossOrigin: s, offsetX: V(this.offsetX, A.NUM_FRACTION_DIGITS), offsetY: V(this.offsetY, A.NUM_FRACTION_DIGITS), patternTransform: this.patternTransform ? [...this.patternTransform] : null });\n  }\n  toSVG(t) {\n    let { width: e, height: s } = t;\n    const { source: r, repeat: n, id: o } = this, a = Qe(this.offsetX / e, 0), c = Qe(this.offsetY / s, 0), l = n === \"repeat-y\" || n === \"no-repeat\" ? 1 + Math.abs(a || 0) : Qe(r.width / e, 0), h = n === \"repeat-x\" || n === \"no-repeat\" ? 1 + Math.abs(c || 0) : Qe(r.height / s, 0);\n    return ['<pattern id=\"SVGID_'.concat(o, '\" x=\"').concat(a, '\" y=\"').concat(c, '\" width=\"').concat(l, '\" height=\"').concat(h, '\">'), '<image x=\"0\" y=\"0\" width=\"'.concat(r.width, '\" height=\"').concat(r.height, '\" xlink:href=\"').concat(this.sourceToString(), '\"></image>'), \"</pattern>\", \"\"].join(`\n`);\n  }\n  static async fromObject(t, e) {\n    let { type: s, source: r, patternTransform: n } = t, o = G(t, gd);\n    const a = await Ys(r, v(v({}, e), {}, { crossOrigin: o.crossOrigin }));\n    return new this(v(v({}, o), {}, { patternTransform: n && n.slice(0), source: a }));\n  }\n}\ny(Yi, \"type\", \"Pattern\"), C.setClass(Yi), C.setClass(Yi, \"pattern\");\nconst pd = [\"path\", \"left\", \"top\"], md = [\"d\"];\nclass Ae extends nt {\n  constructor(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { path: s, left: r, top: n } = e, o = G(e, pd);\n    super(), Object.assign(this, Ae.ownDefaults), this.setOptions(o), this._setPath(t || [], !0), typeof r == \"number\" && this.set(L, r), typeof n == \"number\" && this.set(gt, n);\n  }\n  _setPath(t, e) {\n    this.path = Wc(Array.isArray(t) ? t : Gc(t)), this.setBoundingBox(e);\n  }\n  _findCenterFromElement() {\n    const t = this._calcBoundsFromPath();\n    return new _(t.left + t.width / 2, t.top + t.height / 2);\n  }\n  _renderPathCommands(t) {\n    const e = -this.pathOffset.x, s = -this.pathOffset.y;\n    t.beginPath();\n    for (const r of this.path) switch (r[0]) {\n      case \"L\":\n        t.lineTo(r[1] + e, r[2] + s);\n        break;\n      case \"M\":\n        t.moveTo(r[1] + e, r[2] + s);\n        break;\n      case \"C\":\n        t.bezierCurveTo(r[1] + e, r[2] + s, r[3] + e, r[4] + s, r[5] + e, r[6] + s);\n        break;\n      case \"Q\":\n        t.quadraticCurveTo(r[1] + e, r[2] + s, r[3] + e, r[4] + s);\n        break;\n      case \"Z\":\n        t.closePath();\n    }\n  }\n  _render(t) {\n    this._renderPathCommands(t), this._renderPaintInOrder(t);\n  }\n  toString() {\n    return \"#<Path (\".concat(this.complexity(), '): { \"top\": ').concat(this.top, ', \"left\": ').concat(this.left, \" }>\");\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return v(v({}, super.toObject(t)), {}, { path: this.path.map((e) => e.slice()) });\n  }\n  toDatalessObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    const e = this.toObject(t);\n    return this.sourcePath && (delete e.path, e.sourcePath = this.sourcePath), e;\n  }\n  _toSVG() {\n    const t = Nc(this.path, A.NUM_FRACTION_DIGITS);\n    return [\"<path \", \"COMMON_PARTS\", 'd=\"'.concat(t, `\" stroke-linecap=\"round\" />\n`)];\n  }\n  _getOffsetTransform() {\n    const t = A.NUM_FRACTION_DIGITS;\n    return \" translate(\".concat(V(-this.pathOffset.x, t), \", \").concat(V(-this.pathOffset.y, t), \")\");\n  }\n  toClipPathSVG(t) {\n    const e = this._getOffsetTransform();\n    return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: t, additionalTransform: e });\n  }\n  toSVG(t) {\n    const e = this._getOffsetTransform();\n    return this._createBaseSVGMarkup(this._toSVG(), { reviver: t, additionalTransform: e });\n  }\n  complexity() {\n    return this.path.length;\n  }\n  setDimensions() {\n    this.setBoundingBox();\n  }\n  setBoundingBox(t) {\n    const { width: e, height: s, pathOffset: r } = this._calcDimensions();\n    this.set({ width: e, height: s, pathOffset: r }), t && this.setPositionByOrigin(r, j, j);\n  }\n  _calcBoundsFromPath() {\n    const t = [];\n    let e = 0, s = 0, r = 0, n = 0;\n    for (const o of this.path) switch (o[0]) {\n      case \"L\":\n        r = o[1], n = o[2], t.push({ x: e, y: s }, { x: r, y: n });\n        break;\n      case \"M\":\n        r = o[1], n = o[2], e = r, s = n;\n        break;\n      case \"C\":\n        t.push(...mn(r, n, o[1], o[2], o[3], o[4], o[5], o[6])), r = o[5], n = o[6];\n        break;\n      case \"Q\":\n        t.push(...mn(r, n, o[1], o[2], o[1], o[2], o[3], o[4])), r = o[3], n = o[4];\n        break;\n      case \"Z\":\n        r = e, n = s;\n    }\n    return Gt(t);\n  }\n  _calcDimensions() {\n    const t = this._calcBoundsFromPath();\n    return v(v({}, t), {}, { pathOffset: new _(t.left + t.width / 2, t.top + t.height / 2) });\n  }\n  static fromObject(t) {\n    return this._fromObject(t, { extraParam: \"path\" });\n  }\n  static async fromElement(t, e, s) {\n    const r = fe(t, this.ATTRIBUTE_NAMES, s), { d: n } = r;\n    return new this(n, v(v(v({}, G(r, md)), e), {}, { left: void 0, top: void 0 }));\n  }\n}\ny(Ae, \"type\", \"Path\"), y(Ae, \"cacheProperties\", [...de, \"path\", \"fillRule\"]), y(Ae, \"ATTRIBUTE_NAMES\", [...De, \"d\"]), C.setClass(Ae), C.setSVGClass(Ae);\nconst vd = [\"left\", \"top\", \"radius\"], Zc = [\"radius\", \"startAngle\", \"endAngle\", \"counterClockwise\"];\nclass se extends nt {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), se.ownDefaults);\n  }\n  constructor(t) {\n    super(), Object.assign(this, se.ownDefaults), this.setOptions(t);\n  }\n  _set(t, e) {\n    return super._set(t, e), t === \"radius\" && this.setRadius(e), this;\n  }\n  _render(t) {\n    t.beginPath(), t.arc(0, 0, this.radius, K(this.startAngle), K(this.endAngle), this.counterClockwise), this._renderPaintInOrder(t);\n  }\n  getRadiusX() {\n    return this.get(\"radius\") * this.get(ut);\n  }\n  getRadiusY() {\n    return this.get(\"radius\") * this.get(Tt);\n  }\n  setRadius(t) {\n    this.radius = t, this.set({ width: 2 * t, height: 2 * t });\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return super.toObject([...Zc, ...t]);\n  }\n  _toSVG() {\n    const t = (this.endAngle - this.startAngle) % 360;\n    if (t === 0) return [\"<circle \", \"COMMON_PARTS\", 'cx=\"0\" cy=\"0\" ', 'r=\"', \"\".concat(this.radius), `\" />\n`];\n    {\n      const { radius: e } = this, s = K(this.startAngle), r = K(this.endAngle), n = Lt(s) * e, o = Bt(s) * e, a = Lt(r) * e, c = Bt(r) * e, l = t > 180 ? 1 : 0, h = this.counterClockwise ? 0 : 1;\n      return ['<path d=\"M '.concat(n, \" \").concat(o, \" A \").concat(e, \" \").concat(e, \" 0 \").concat(l, \" \").concat(h, \" \").concat(a, \" \").concat(c, '\" '), \"COMMON_PARTS\", ` />\n`];\n    }\n  }\n  static async fromElement(t, e, s) {\n    const r = fe(t, this.ATTRIBUTE_NAMES, s), { left: n = 0, top: o = 0, radius: a = 0 } = r;\n    return new this(v(v({}, G(r, vd)), {}, { radius: a, left: n - a, top: o - a }));\n  }\n  static fromObject(t) {\n    return super._fromObject(t);\n  }\n}\ny(se, \"type\", \"Circle\"), y(se, \"cacheProperties\", [...de, ...Zc]), y(se, \"ownDefaults\", { radius: 0, startAngle: 0, endAngle: 360, counterClockwise: !1 }), y(se, \"ATTRIBUTE_NAMES\", [\"cx\", \"cy\", \"r\", ...De]), C.setClass(se), C.setSVGClass(se);\nconst yd = [\"x1\", \"y1\", \"x2\", \"y2\"], bd = [\"x1\", \"y1\", \"x2\", \"y2\"], yn = [\"x1\", \"x2\", \"y1\", \"y2\"];\nclass Se extends nt {\n  constructor() {\n    let [t, e, s, r] = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0, 0], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    super(), Object.assign(this, Se.ownDefaults), this.setOptions(n), this.x1 = t, this.x2 = s, this.y1 = e, this.y2 = r, this._setWidthHeight();\n    const { left: o, top: a } = n;\n    typeof o == \"number\" && this.set(L, o), typeof a == \"number\" && this.set(gt, a);\n  }\n  _setWidthHeight() {\n    const { x1: t, y1: e, x2: s, y2: r } = this;\n    this.width = Math.abs(s - t), this.height = Math.abs(r - e);\n    const { left: n, top: o, width: a, height: c } = Gt([{ x: t, y: e }, { x: s, y: r }]), l = new _(n + a / 2, o + c / 2);\n    this.setPositionByOrigin(l, j, j);\n  }\n  _set(t, e) {\n    return super._set(t, e), yn.includes(t) && this._setWidthHeight(), this;\n  }\n  _render(t) {\n    t.beginPath();\n    const e = this.calcLinePoints();\n    t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.lineWidth = this.strokeWidth;\n    const s = t.strokeStyle;\n    var r;\n    Ct(this.stroke) ? t.strokeStyle = this.stroke.toLive(t) : t.strokeStyle = (r = this.stroke) !== null && r !== void 0 ? r : t.fillStyle, this.stroke && this._renderStroke(t), t.strokeStyle = s;\n  }\n  _findCenterFromElement() {\n    return new _((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return v(v({}, super.toObject(t)), this.calcLinePoints());\n  }\n  _getNonTransformedDimensions() {\n    const t = super._getNonTransformedDimensions();\n    return this.strokeLineCap === \"butt\" && (this.width === 0 && (t.y -= this.strokeWidth), this.height === 0 && (t.x -= this.strokeWidth)), t;\n  }\n  calcLinePoints() {\n    const { x1: t, x2: e, y1: s, y2: r, width: n, height: o } = this, a = t <= e ? -1 : 1, c = s <= r ? -1 : 1;\n    return { x1: a * n / 2, x2: a * -n / 2, y1: c * o / 2, y2: c * -o / 2 };\n  }\n  _toSVG() {\n    const { x1: t, x2: e, y1: s, y2: r } = this.calcLinePoints();\n    return [\"<line \", \"COMMON_PARTS\", 'x1=\"'.concat(t, '\" y1=\"').concat(s, '\" x2=\"').concat(e, '\" y2=\"').concat(r, `\" />\n`)];\n  }\n  static async fromElement(t, e, s) {\n    const r = fe(t, this.ATTRIBUTE_NAMES, s), { x1: n = 0, y1: o = 0, x2: a = 0, y2: c = 0 } = r;\n    return new this([n, o, a, c], G(r, yd));\n  }\n  static fromObject(t) {\n    let { x1: e, y1: s, x2: r, y2: n } = t, o = G(t, bd);\n    return this._fromObject(v(v({}, o), {}, { points: [e, s, r, n] }), { extraParam: \"points\" });\n  }\n}\ny(Se, \"type\", \"Line\"), y(Se, \"cacheProperties\", [...de, ...yn]), y(Se, \"ATTRIBUTE_NAMES\", De.concat(yn)), C.setClass(Se), C.setSVGClass(Se);\nclass Re extends nt {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), Re.ownDefaults);\n  }\n  constructor(t) {\n    super(), Object.assign(this, Re.ownDefaults), this.setOptions(t);\n  }\n  _render(t) {\n    const e = this.width / 2, s = this.height / 2;\n    t.beginPath(), t.moveTo(-e, s), t.lineTo(0, -s), t.lineTo(e, s), t.closePath(), this._renderPaintInOrder(t);\n  }\n  _toSVG() {\n    const t = this.width / 2, e = this.height / 2;\n    return [\"<polygon \", \"COMMON_PARTS\", 'points=\"', \"\".concat(-t, \" \").concat(e, \",0 \").concat(-e, \",\").concat(t, \" \").concat(e), '\" />'];\n  }\n}\ny(Re, \"type\", \"Triangle\"), y(Re, \"ownDefaults\", { width: 100, height: 100 }), C.setClass(Re), C.setSVGClass(Re);\nconst Qc = [\"rx\", \"ry\"];\nclass re extends nt {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), re.ownDefaults);\n  }\n  constructor(t) {\n    super(), Object.assign(this, re.ownDefaults), this.setOptions(t);\n  }\n  _set(t, e) {\n    switch (super._set(t, e), t) {\n      case \"rx\":\n        this.rx = e, this.set(\"width\", 2 * e);\n        break;\n      case \"ry\":\n        this.ry = e, this.set(\"height\", 2 * e);\n    }\n    return this;\n  }\n  getRx() {\n    return this.get(\"rx\") * this.get(ut);\n  }\n  getRy() {\n    return this.get(\"ry\") * this.get(Tt);\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return super.toObject([...Qc, ...t]);\n  }\n  _toSVG() {\n    return [\"<ellipse \", \"COMMON_PARTS\", 'cx=\"0\" cy=\"0\" rx=\"'.concat(this.rx, '\" ry=\"').concat(this.ry, `\" />\n`)];\n  }\n  _render(t) {\n    t.beginPath(), t.save(), t.transform(1, 0, 0, this.ry / this.rx, 0, 0), t.arc(0, 0, this.rx, 0, he, !1), t.restore(), this._renderPaintInOrder(t);\n  }\n  static async fromElement(t, e, s) {\n    const r = fe(t, this.ATTRIBUTE_NAMES, s);\n    return r.left = (r.left || 0) - r.rx, r.top = (r.top || 0) - r.ry, new this(r);\n  }\n}\nfunction _d(i) {\n  if (!i) return [];\n  const t = i.replace(/,/g, \" \").trim().split(/\\s+/), e = [];\n  for (let s = 0; s < t.length; s += 2) e.push({ x: parseFloat(t[s]), y: parseFloat(t[s + 1]) });\n  return e;\n}\ny(re, \"type\", \"Ellipse\"), y(re, \"cacheProperties\", [...de, ...Qc]), y(re, \"ownDefaults\", { rx: 0, ry: 0 }), y(re, \"ATTRIBUTE_NAMES\", [...De, \"cx\", \"cy\", \"rx\", \"ry\"]), C.setClass(re), C.setSVGClass(re);\nconst Sd = [\"left\", \"top\"], tl = { exactBoundingBox: !1 };\nclass Et extends nt {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), Et.ownDefaults);\n  }\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    super(), y(this, \"strokeDiff\", void 0), Object.assign(this, Et.ownDefaults), this.setOptions(e), this.points = t;\n    const { left: s, top: r } = e;\n    this.initialized = !0, this.setBoundingBox(!0), typeof s == \"number\" && this.set(L, s), typeof r == \"number\" && this.set(gt, r);\n  }\n  isOpen() {\n    return !0;\n  }\n  _projectStrokeOnPoints(t) {\n    return Dc(this.points, t, this.isOpen());\n  }\n  _calcDimensions(t) {\n    t = v({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: this.strokeMiterLimit, strokeUniform: this.strokeUniform, strokeWidth: this.strokeWidth }, t || {});\n    const e = this.exactBoundingBox ? this._projectStrokeOnPoints(t).map((l) => l.projectedPoint) : this.points;\n    if (e.length === 0) return { left: 0, top: 0, width: 0, height: 0, pathOffset: new _(), strokeOffset: new _(), strokeDiff: new _() };\n    const s = Gt(e), r = ar(v(v({}, t), {}, { scaleX: 1, scaleY: 1 })), n = Gt(this.points.map((l) => ot(l, r, !0))), o = new _(this.scaleX, this.scaleY);\n    let a = s.left + s.width / 2, c = s.top + s.height / 2;\n    return this.exactBoundingBox && (a -= c * Math.tan(K(this.skewX)), c -= a * Math.tan(K(this.skewY))), v(v({}, s), {}, { pathOffset: new _(a, c), strokeOffset: new _(n.left, n.top).subtract(new _(s.left, s.top)).multiply(o), strokeDiff: new _(s.width, s.height).subtract(new _(n.width, n.height)).multiply(o) });\n  }\n  _findCenterFromElement() {\n    const t = Gt(this.points);\n    return new _(t.left + t.width / 2, t.top + t.height / 2);\n  }\n  setDimensions() {\n    this.setBoundingBox();\n  }\n  setBoundingBox(t) {\n    const { left: e, top: s, width: r, height: n, pathOffset: o, strokeOffset: a, strokeDiff: c } = this._calcDimensions();\n    this.set({ width: r, height: n, pathOffset: o, strokeOffset: a, strokeDiff: c }), t && this.setPositionByOrigin(new _(e + r / 2, s + n / 2), j, j);\n  }\n  isStrokeAccountedForInDimensions() {\n    return this.exactBoundingBox;\n  }\n  _getNonTransformedDimensions() {\n    return this.exactBoundingBox ? new _(this.width, this.height) : super._getNonTransformedDimensions();\n  }\n  _getTransformedDimensions() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    if (this.exactBoundingBox) {\n      let o;\n      if (Object.keys(t).some((a) => this.strokeUniform || this.constructor.layoutProperties.includes(a))) {\n        var e, s;\n        const { width: a, height: c } = this._calcDimensions(t);\n        o = new _((e = t.width) !== null && e !== void 0 ? e : a, (s = t.height) !== null && s !== void 0 ? s : c);\n      } else {\n        var r, n;\n        o = new _((r = t.width) !== null && r !== void 0 ? r : this.width, (n = t.height) !== null && n !== void 0 ? n : this.height);\n      }\n      return o.multiply(new _(t.scaleX || this.scaleX, t.scaleY || this.scaleY));\n    }\n    return super._getTransformedDimensions(t);\n  }\n  _set(t, e) {\n    const s = this.initialized && this[t] !== e, r = super._set(t, e);\n    return this.exactBoundingBox && s && ((t === ut || t === Tt) && this.strokeUniform && this.constructor.layoutProperties.includes(\"strokeUniform\") || this.constructor.layoutProperties.includes(t)) && this.setDimensions(), r;\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return v(v({}, super.toObject(t)), {}, { points: this.points.map((e) => {\n      let { x: s, y: r } = e;\n      return { x: s, y: r };\n    }) });\n  }\n  _toSVG() {\n    const t = [], e = this.pathOffset.x, s = this.pathOffset.y, r = A.NUM_FRACTION_DIGITS;\n    for (let n = 0, o = this.points.length; n < o; n++) t.push(V(this.points[n].x - e, r), \",\", V(this.points[n].y - s, r), \" \");\n    return [\"<\".concat(this.constructor.type.toLowerCase(), \" \"), \"COMMON_PARTS\", 'points=\"'.concat(t.join(\"\"), `\" />\n`)];\n  }\n  _render(t) {\n    const e = this.points.length, s = this.pathOffset.x, r = this.pathOffset.y;\n    if (e && !isNaN(this.points[e - 1].y)) {\n      t.beginPath(), t.moveTo(this.points[0].x - s, this.points[0].y - r);\n      for (let n = 0; n < e; n++) {\n        const o = this.points[n];\n        t.lineTo(o.x - s, o.y - r);\n      }\n      !this.isOpen() && t.closePath(), this._renderPaintInOrder(t);\n    }\n  }\n  complexity() {\n    return this.points.length;\n  }\n  static async fromElement(t, e, s) {\n    return new this(_d(t.getAttribute(\"points\")), v(v({}, G(fe(t, this.ATTRIBUTE_NAMES, s), Sd)), e));\n  }\n  static fromObject(t) {\n    return this._fromObject(t, { extraParam: \"points\" });\n  }\n}\ny(Et, \"ownDefaults\", tl), y(Et, \"type\", \"Polyline\"), y(Et, \"layoutProperties\", [Os, ks, \"strokeLineCap\", \"strokeLineJoin\", \"strokeMiterLimit\", \"strokeWidth\", \"strokeUniform\", \"points\"]), y(Et, \"cacheProperties\", [...de, \"points\"]), y(Et, \"ATTRIBUTE_NAMES\", [...De]), C.setClass(Et), C.setSVGClass(Et);\nclass br extends Et {\n  isOpen() {\n    return !1;\n  }\n}\ny(br, \"ownDefaults\", tl), y(br, \"type\", \"Polygon\"), C.setClass(br), C.setSVGClass(br);\nconst el = [\"fontSize\", \"fontWeight\", \"fontFamily\", \"fontStyle\"], sl = [\"underline\", \"overline\", \"linethrough\"], rl = [...el, \"lineHeight\", \"text\", \"charSpacing\", \"textAlign\", \"styles\", \"path\", \"pathStartOffset\", \"pathSide\", \"pathAlign\"], il = [...rl, ...sl, \"textBackgroundColor\", \"direction\"], Td = [...el, ...sl, mt, \"strokeWidth\", rt, \"deltaY\", \"textBackgroundColor\"], xd = { _reNewline: Pn, _reSpacesAndTabs: /[ \\t\\r]/g, _reSpaceAndTab: /[ \\t\\r]/, _reWords: /\\S+/g, fontSize: 40, fontWeight: \"normal\", fontFamily: \"Times New Roman\", underline: !1, overline: !1, linethrough: !1, textAlign: L, fontStyle: \"normal\", lineHeight: 1.16, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, textBackgroundColor: \"\", stroke: null, shadow: null, path: void 0, pathStartOffset: 0, pathSide: L, pathAlign: \"baseline\", _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.315, overline: -0.88 }, _fontSizeMult: 1.13, charSpacing: 0, deltaY: 0, direction: \"ltr\", CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2 }, Ht = \"justify\", ni = \"justify-left\", Vs = \"justify-right\", Gs = \"justify-center\";\nclass nl extends nt {\n  isEmptyStyles(t) {\n    if (!this.styles || t !== void 0 && !this.styles[t]) return !0;\n    const e = t === void 0 ? this.styles : { line: this.styles[t] };\n    for (const s in e) for (const r in e[s]) for (const n in e[s][r]) return !1;\n    return !0;\n  }\n  styleHas(t, e) {\n    if (!this.styles || e !== void 0 && !this.styles[e]) return !1;\n    const s = e === void 0 ? this.styles : { 0: this.styles[e] };\n    for (const r in s) for (const n in s[r]) if (s[r][n][t] !== void 0) return !0;\n    return !1;\n  }\n  cleanStyle(t) {\n    if (!this.styles) return !1;\n    const e = this.styles;\n    let s, r, n = 0, o = !0, a = 0;\n    for (const c in e) {\n      s = 0;\n      for (const l in e[c]) {\n        const h = e[c][l] || {};\n        n++, h[t] !== void 0 ? (r ? h[t] !== r && (o = !1) : r = h[t], h[t] === this[t] && delete h[t]) : o = !1, Object.keys(h).length !== 0 ? s++ : delete e[c][l];\n      }\n      s === 0 && delete e[c];\n    }\n    for (let c = 0; c < this._textLines.length; c++) a += this._textLines[c].length;\n    o && n === a && (this[t] = r, this.removeStyle(t));\n  }\n  removeStyle(t) {\n    if (!this.styles) return;\n    const e = this.styles;\n    let s, r, n;\n    for (r in e) {\n      for (n in s = e[r], s) delete s[n][t], Object.keys(s[n]).length === 0 && delete s[n];\n      Object.keys(s).length === 0 && delete e[r];\n    }\n  }\n  _extendStyles(t, e) {\n    const { lineIndex: s, charIndex: r } = this.get2DCursorLocation(t);\n    this._getLineStyle(s) || this._setLineStyle(s);\n    const n = Xn(v(v({}, this._getStyleDeclaration(s, r)), e), (o) => o !== void 0);\n    this._setStyleDeclaration(s, r, n);\n  }\n  getSelectionStyles(t, e, s) {\n    const r = [];\n    for (let n = t; n < (e || t); n++) r.push(this.getStyleAtPosition(n, s));\n    return r;\n  }\n  getStyleAtPosition(t, e) {\n    const { lineIndex: s, charIndex: r } = this.get2DCursorLocation(t);\n    return e ? this.getCompleteStyleDeclaration(s, r) : this._getStyleDeclaration(s, r);\n  }\n  setSelectionStyles(t, e, s) {\n    for (let r = e; r < (s || e); r++) this._extendStyles(r, t);\n    this._forceClearCache = !0;\n  }\n  _getStyleDeclaration(t, e) {\n    var s;\n    const r = this.styles && this.styles[t];\n    return r && (s = r[e]) !== null && s !== void 0 ? s : {};\n  }\n  getCompleteStyleDeclaration(t, e) {\n    return v(v({}, Ve(this, this.constructor._styleProperties)), this._getStyleDeclaration(t, e));\n  }\n  _setStyleDeclaration(t, e, s) {\n    this.styles[t][e] = s;\n  }\n  _deleteStyleDeclaration(t, e) {\n    delete this.styles[t][e];\n  }\n  _getLineStyle(t) {\n    return !!this.styles[t];\n  }\n  _setLineStyle(t) {\n    this.styles[t] = {};\n  }\n  _deleteLineStyle(t) {\n    delete this.styles[t];\n  }\n}\ny(nl, \"_styleProperties\", Td);\nconst wd = /  +/g, Cd = /\"/g;\nfunction Vi(i, t, e, s, r) {\n  return \"\t\t\".concat(function(n, o) {\n    let { left: a, top: c, width: l, height: h } = o, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : A.NUM_FRACTION_DIGITS;\n    const d = Ks(rt, n, !1), [f, g, p, m] = [a, c, l, h].map((b) => V(b, u));\n    return \"<rect \".concat(d, ' x=\"').concat(f, '\" y=\"').concat(g, '\" width=\"').concat(p, '\" height=\"').concat(m, '\"></rect>');\n  }(i, { left: t, top: e, width: s, height: r }), `\n`);\n}\nconst Od = [\"textAnchor\", \"textDecoration\", \"dx\", \"dy\", \"top\", \"left\", \"fontSize\", \"strokeWidth\"];\nlet Gi;\nclass ct extends nl {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), ct.ownDefaults);\n  }\n  constructor(t, e) {\n    super(), y(this, \"__charBounds\", []), Object.assign(this, ct.ownDefaults), this.setOptions(e), this.styles || (this.styles = {}), this.text = t, this.initialized = !0, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();\n  }\n  setPathInfo() {\n    const t = this.path;\n    t && (t.segmentsInfo = Qn(t.path));\n  }\n  _splitText() {\n    const t = this._splitTextIntoLines(this.text);\n    return this.textLines = t.lines, this._textLines = t.graphemeLines, this._unwrappedTextLines = t._unwrappedLines, this._text = t.graphemeText, t;\n  }\n  initDimensions() {\n    this._splitText(), this._clearCache(), this.dirty = !0, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(Ht) && this.enlargeSpaces();\n  }\n  enlargeSpaces() {\n    let t, e, s, r, n, o, a;\n    for (let c = 0, l = this._textLines.length; c < l; c++) if ((this.textAlign === Ht || c !== l - 1 && !this.isEndOfWrapping(c)) && (r = 0, n = this._textLines[c], e = this.getLineWidth(c), e < this.width && (a = this.textLines[c].match(this._reSpacesAndTabs)))) {\n      s = a.length, t = (this.width - e) / s;\n      for (let h = 0; h <= n.length; h++) o = this.__charBounds[c][h], this._reSpaceAndTab.test(n[h]) ? (o.width += t, o.kernedWidth += t, o.left += r, r += t) : o.left += r;\n    }\n  }\n  isEndOfWrapping(t) {\n    return t === this._textLines.length - 1;\n  }\n  missingNewlineOffset(t) {\n    return 1;\n  }\n  get2DCursorLocation(t, e) {\n    const s = e ? this._unwrappedTextLines : this._textLines;\n    let r;\n    for (r = 0; r < s.length; r++) {\n      if (t <= s[r].length) return { lineIndex: r, charIndex: t };\n      t -= s[r].length + this.missingNewlineOffset(r, e);\n    }\n    return { lineIndex: r - 1, charIndex: s[r - 1].length < t ? s[r - 1].length : t };\n  }\n  toString() {\n    return \"#<Text (\".concat(this.complexity(), '): { \"text\": \"').concat(this.text, '\", \"fontFamily\": \"').concat(this.fontFamily, '\" }>');\n  }\n  _getCacheCanvasDimensions() {\n    const t = super._getCacheCanvasDimensions(), e = this.fontSize;\n    return t.width += e * t.zoomX, t.height += e * t.zoomY, t;\n  }\n  _render(t) {\n    const e = this.path;\n    e && !e.isNotVisible() && e._render(t), this._setTextStyles(t), this._renderTextLinesBackground(t), this._renderTextDecoration(t, \"underline\"), this._renderText(t), this._renderTextDecoration(t, \"overline\"), this._renderTextDecoration(t, \"linethrough\");\n  }\n  _renderText(t) {\n    this.paintFirst === mt ? (this._renderTextStroke(t), this._renderTextFill(t)) : (this._renderTextFill(t), this._renderTextStroke(t));\n  }\n  _setTextStyles(t, e, s) {\n    if (t.textBaseline = \"alphabetic\", this.path) switch (this.pathAlign) {\n      case j:\n        t.textBaseline = \"middle\";\n        break;\n      case \"ascender\":\n        t.textBaseline = gt;\n        break;\n      case \"descender\":\n        t.textBaseline = rn;\n    }\n    t.font = this._getFontDeclaration(e, s);\n  }\n  calcTextWidth() {\n    let t = this.getLineWidth(0);\n    for (let e = 1, s = this._textLines.length; e < s; e++) {\n      const r = this.getLineWidth(e);\n      r > t && (t = r);\n    }\n    return t;\n  }\n  _renderTextLine(t, e, s, r, n, o) {\n    this._renderChars(t, e, s, r, n, o);\n  }\n  _renderTextLinesBackground(t) {\n    if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\")) return;\n    const e = t.fillStyle, s = this._getLeftOffset();\n    let r = this._getTopOffset();\n    for (let n = 0, o = this._textLines.length; n < o; n++) {\n      const a = this.getHeightOfLine(n);\n      if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\", n)) {\n        r += a;\n        continue;\n      }\n      const c = this._textLines[n].length, l = this._getLineLeftOffset(n);\n      let h, u, d = 0, f = 0, g = this.getValueOfPropertyAt(n, 0, \"textBackgroundColor\");\n      for (let p = 0; p < c; p++) {\n        const m = this.__charBounds[n][p];\n        u = this.getValueOfPropertyAt(n, p, \"textBackgroundColor\"), this.path ? (t.save(), t.translate(m.renderLeft, m.renderTop), t.rotate(m.angle), t.fillStyle = u, u && t.fillRect(-m.width / 2, -a / this.lineHeight * (1 - this._fontSizeFraction), m.width, a / this.lineHeight), t.restore()) : u !== g ? (h = s + l + f, this.direction === \"rtl\" && (h = this.width - h - d), t.fillStyle = g, g && t.fillRect(h, r, d, a / this.lineHeight), f = m.left, d = m.width, g = u) : d += m.kernedWidth;\n      }\n      u && !this.path && (h = s + l + f, this.direction === \"rtl\" && (h = this.width - h - d), t.fillStyle = u, t.fillRect(h, r, d, a / this.lineHeight)), r += a;\n    }\n    t.fillStyle = e, this._removeShadow(t);\n  }\n  _measureChar(t, e, s, r) {\n    const n = zs.getFontCache(e), o = this._getFontDeclaration(e), a = s + t, c = s && o === this._getFontDeclaration(r), l = e.fontSize / this.CACHE_FONT_SIZE;\n    let h, u, d, f;\n    if (s && n[s] !== void 0 && (d = n[s]), n[t] !== void 0 && (f = h = n[t]), c && n[a] !== void 0 && (u = n[a], f = u - d), h === void 0 || d === void 0 || u === void 0) {\n      const g = function() {\n        return Gi || (Gi = Wt({ width: 0, height: 0 }).getContext(\"2d\")), Gi;\n      }();\n      this._setTextStyles(g, e, !0), h === void 0 && (f = h = g.measureText(t).width, n[t] = h), d === void 0 && c && s && (d = g.measureText(s).width, n[s] = d), c && u === void 0 && (u = g.measureText(a).width, n[a] = u, f = u - d);\n    }\n    return { width: h * l, kernedWidth: f * l };\n  }\n  getHeightOfChar(t, e) {\n    return this.getValueOfPropertyAt(t, e, \"fontSize\");\n  }\n  measureLine(t) {\n    const e = this._measureLine(t);\n    return this.charSpacing !== 0 && (e.width -= this._getWidthOfCharSpacing()), e.width < 0 && (e.width = 0), e;\n  }\n  _measureLine(t) {\n    let e, s, r = 0;\n    const n = this.pathSide === Z, o = this.path, a = this._textLines[t], c = a.length, l = new Array(c);\n    this.__charBounds[t] = l;\n    for (let h = 0; h < c; h++) {\n      const u = a[h];\n      s = this._getGraphemeBox(u, t, h, e), l[h] = s, r += s.kernedWidth, e = u;\n    }\n    if (l[c] = { left: s ? s.left + s.width : 0, width: 0, kernedWidth: 0, height: this.fontSize, deltaY: 0 }, o && o.segmentsInfo) {\n      let h = 0;\n      const u = o.segmentsInfo[o.segmentsInfo.length - 1].length;\n      switch (this.textAlign) {\n        case L:\n          h = n ? u - r : 0;\n          break;\n        case j:\n          h = (u - r) / 2;\n          break;\n        case Z:\n          h = n ? 0 : u - r;\n      }\n      h += this.pathStartOffset * (n ? -1 : 1);\n      for (let d = n ? c - 1 : 0; n ? d >= 0 : d < c; n ? d-- : d++) s = l[d], h > u ? h %= u : h < 0 && (h += u), this._setGraphemeOnPath(h, s), h += s.kernedWidth;\n    }\n    return { width: r, numOfSpaces: 0 };\n  }\n  _setGraphemeOnPath(t, e) {\n    const s = t + e.kernedWidth / 2, r = this.path, n = Vc(r.path, s, r.segmentsInfo);\n    e.renderLeft = n.x - r.pathOffset.x, e.renderTop = n.y - r.pathOffset.y, e.angle = n.angle + (this.pathSide === Z ? Math.PI : 0);\n  }\n  _getGraphemeBox(t, e, s, r, n) {\n    const o = this.getCompleteStyleDeclaration(e, s), a = r ? this.getCompleteStyleDeclaration(e, s - 1) : {}, c = this._measureChar(t, o, r, a);\n    let l, h = c.kernedWidth, u = c.width;\n    this.charSpacing !== 0 && (l = this._getWidthOfCharSpacing(), u += l, h += l);\n    const d = { width: u, left: 0, height: o.fontSize, kernedWidth: h, deltaY: o.deltaY };\n    if (s > 0 && !n) {\n      const f = this.__charBounds[e][s - 1];\n      d.left = f.left + f.width + c.kernedWidth - c.width;\n    }\n    return d;\n  }\n  getHeightOfLine(t) {\n    if (this.__lineHeights[t]) return this.__lineHeights[t];\n    let e = this.getHeightOfChar(t, 0);\n    for (let s = 1, r = this._textLines[t].length; s < r; s++) e = Math.max(this.getHeightOfChar(t, s), e);\n    return this.__lineHeights[t] = e * this.lineHeight * this._fontSizeMult;\n  }\n  calcTextHeight() {\n    let t, e = 0;\n    for (let s = 0, r = this._textLines.length; s < r; s++) t = this.getHeightOfLine(s), e += s === r - 1 ? t / this.lineHeight : t;\n    return e;\n  }\n  _getLeftOffset() {\n    return this.direction === \"ltr\" ? -this.width / 2 : this.width / 2;\n  }\n  _getTopOffset() {\n    return -this.height / 2;\n  }\n  _renderTextCommon(t, e) {\n    t.save();\n    let s = 0;\n    const r = this._getLeftOffset(), n = this._getTopOffset();\n    for (let o = 0, a = this._textLines.length; o < a; o++) {\n      const c = this.getHeightOfLine(o), l = c / this.lineHeight, h = this._getLineLeftOffset(o);\n      this._renderTextLine(e, t, this._textLines[o], r + h, n + s + l, o), s += c;\n    }\n    t.restore();\n  }\n  _renderTextFill(t) {\n    (this.fill || this.styleHas(rt)) && this._renderTextCommon(t, \"fillText\");\n  }\n  _renderTextStroke(t) {\n    (this.stroke && this.strokeWidth !== 0 || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this._setLineDash(t, this.strokeDashArray), t.beginPath(), this._renderTextCommon(t, \"strokeText\"), t.closePath(), t.restore());\n  }\n  _renderChars(t, e, s, r, n, o) {\n    const a = this.getHeightOfLine(o), c = this.textAlign.includes(Ht), l = this.path, h = !c && this.charSpacing === 0 && this.isEmptyStyles(o) && !l, u = this.direction === \"ltr\", d = this.direction === \"ltr\" ? 1 : -1, f = e.direction;\n    let g, p, m, b, S, w = \"\", k = 0;\n    if (e.save(), f !== this.direction && (e.canvas.setAttribute(\"dir\", u ? \"ltr\" : \"rtl\"), e.direction = u ? \"ltr\" : \"rtl\", e.textAlign = u ? L : Z), n -= a * this._fontSizeFraction / this.lineHeight, h) return this._renderChar(t, e, o, 0, s.join(\"\"), r, n), void e.restore();\n    for (let O = 0, x = s.length - 1; O <= x; O++) b = O === x || this.charSpacing || l, w += s[O], m = this.__charBounds[o][O], k === 0 ? (r += d * (m.kernedWidth - m.width), k += m.width) : k += m.kernedWidth, c && !b && this._reSpaceAndTab.test(s[O]) && (b = !0), b || (g = g || this.getCompleteStyleDeclaration(o, O), p = this.getCompleteStyleDeclaration(o, O + 1), b = wi(g, p, !1)), b && (l ? (e.save(), e.translate(m.renderLeft, m.renderTop), e.rotate(m.angle), this._renderChar(t, e, o, O, w, -k / 2, 0), e.restore()) : (S = r, this._renderChar(t, e, o, O, w, S, n)), w = \"\", g = p, r += d * k, k = 0);\n    e.restore();\n  }\n  _applyPatternGradientTransformText(t) {\n    const e = this.width + this.strokeWidth, s = this.height + this.strokeWidth, r = Wt({ width: e, height: s }), n = r.getContext(\"2d\");\n    return r.width = e, r.height = s, n.beginPath(), n.moveTo(0, 0), n.lineTo(e, 0), n.lineTo(e, s), n.lineTo(0, s), n.closePath(), n.translate(e / 2, s / 2), n.fillStyle = t.toLive(n), this._applyPatternGradientTransform(n, t), n.fill(), n.createPattern(r, \"no-repeat\");\n  }\n  handleFiller(t, e, s) {\n    let r, n;\n    return Ct(s) ? s.gradientUnits === \"percentage\" || s.gradientTransform || s.patternTransform ? (r = -this.width / 2, n = -this.height / 2, t.translate(r, n), t[e] = this._applyPatternGradientTransformText(s), { offsetX: r, offsetY: n }) : (t[e] = s.toLive(t), this._applyPatternGradientTransform(t, s)) : (t[e] = s, { offsetX: 0, offsetY: 0 });\n  }\n  _setStrokeStyles(t, e) {\n    let { stroke: s, strokeWidth: r } = e;\n    return t.lineWidth = r, t.lineCap = this.strokeLineCap, t.lineDashOffset = this.strokeDashOffset, t.lineJoin = this.strokeLineJoin, t.miterLimit = this.strokeMiterLimit, this.handleFiller(t, \"strokeStyle\", s);\n  }\n  _setFillStyles(t, e) {\n    let { fill: s } = e;\n    return this.handleFiller(t, \"fillStyle\", s);\n  }\n  _renderChar(t, e, s, r, n, o, a) {\n    const c = this._getStyleDeclaration(s, r), l = this.getCompleteStyleDeclaration(s, r), h = t === \"fillText\" && l.fill, u = t === \"strokeText\" && l.stroke && l.strokeWidth;\n    if (u || h) {\n      if (e.save(), e.font = this._getFontDeclaration(l), c.textBackgroundColor && this._removeShadow(e), c.deltaY && (a += c.deltaY), h) {\n        const d = this._setFillStyles(e, l);\n        e.fillText(n, o - d.offsetX, a - d.offsetY);\n      }\n      if (u) {\n        const d = this._setStrokeStyles(e, l);\n        e.strokeText(n, o - d.offsetX, a - d.offsetY);\n      }\n      e.restore();\n    }\n  }\n  setSuperscript(t, e) {\n    this._setScript(t, e, this.superscript);\n  }\n  setSubscript(t, e) {\n    this._setScript(t, e, this.subscript);\n  }\n  _setScript(t, e, s) {\n    const r = this.get2DCursorLocation(t, !0), n = this.getValueOfPropertyAt(r.lineIndex, r.charIndex, \"fontSize\"), o = this.getValueOfPropertyAt(r.lineIndex, r.charIndex, \"deltaY\"), a = { fontSize: n * s.size, deltaY: o + n * s.baseline };\n    this.setSelectionStyles(a, t, e);\n  }\n  _getLineLeftOffset(t) {\n    const e = this.getLineWidth(t), s = this.width - e, r = this.textAlign, n = this.direction, o = this.isEndOfWrapping(t);\n    let a = 0;\n    return r === Ht || r === Gs && !o || r === Vs && !o || r === ni && !o ? 0 : (r === j && (a = s / 2), r === Z && (a = s), r === Gs && (a = s / 2), r === Vs && (a = s), n === \"rtl\" && (r === Z || r === Ht || r === Vs ? a = 0 : r === L || r === ni ? a = -s : r !== j && r !== Gs || (a = -s / 2)), a);\n  }\n  _clearCache() {\n    this._forceClearCache = !1, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];\n  }\n  getLineWidth(t) {\n    if (this.__lineWidths[t] !== void 0) return this.__lineWidths[t];\n    const { width: e } = this.measureLine(t);\n    return this.__lineWidths[t] = e, e;\n  }\n  _getWidthOfCharSpacing() {\n    return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0;\n  }\n  getValueOfPropertyAt(t, e, s) {\n    var r;\n    return (r = this._getStyleDeclaration(t, e)[s]) !== null && r !== void 0 ? r : this[s];\n  }\n  _renderTextDecoration(t, e) {\n    if (!this[e] && !this.styleHas(e)) return;\n    let s = this._getTopOffset();\n    const r = this._getLeftOffset(), n = this.path, o = this._getWidthOfCharSpacing(), a = this.offsets[e];\n    for (let c = 0, l = this._textLines.length; c < l; c++) {\n      const h = this.getHeightOfLine(c);\n      if (!this[e] && !this.styleHas(e, c)) {\n        s += h;\n        continue;\n      }\n      const u = this._textLines[c], d = h / this.lineHeight, f = this._getLineLeftOffset(c);\n      let g, p, m = 0, b = 0, S = this.getValueOfPropertyAt(c, 0, e), w = this.getValueOfPropertyAt(c, 0, rt);\n      const k = s + d * (1 - this._fontSizeFraction);\n      let O = this.getHeightOfChar(c, 0), x = this.getValueOfPropertyAt(c, 0, \"deltaY\");\n      for (let M = 0, E = u.length; M < E; M++) {\n        const R = this.__charBounds[c][M];\n        g = this.getValueOfPropertyAt(c, M, e), p = this.getValueOfPropertyAt(c, M, rt);\n        const tt = this.getHeightOfChar(c, M), F = this.getValueOfPropertyAt(c, M, \"deltaY\");\n        if (n && g && p) t.save(), t.fillStyle = w, t.translate(R.renderLeft, R.renderTop), t.rotate(R.angle), t.fillRect(-R.kernedWidth / 2, a * tt + F, R.kernedWidth, this.fontSize / 15), t.restore();\n        else if ((g !== S || p !== w || tt !== O || F !== x) && b > 0) {\n          let B = r + f + m;\n          this.direction === \"rtl\" && (B = this.width - B - b), S && w && (t.fillStyle = w, t.fillRect(B, k + a * O + x, b, this.fontSize / 15)), m = R.left, b = R.width, S = g, w = p, O = tt, x = F;\n        } else b += R.kernedWidth;\n      }\n      let I = r + f + m;\n      this.direction === \"rtl\" && (I = this.width - I - b), t.fillStyle = p, g && p && t.fillRect(I, k + a * O + x, b - o, this.fontSize / 15), s += h;\n    }\n    this._removeShadow(t);\n  }\n  _getFontDeclaration() {\n    let { fontFamily: t = this.fontFamily, fontStyle: e = this.fontStyle, fontWeight: s = this.fontWeight, fontSize: r = this.fontSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;\n    const o = t.includes(\"'\") || t.includes('\"') || t.includes(\",\") || ct.genericFonts.includes(t.toLowerCase()) ? t : '\"'.concat(t, '\"');\n    return [e, s, \"\".concat(n ? this.CACHE_FONT_SIZE : r, \"px\"), o].join(\" \");\n  }\n  render(t) {\n    this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(t)));\n  }\n  graphemeSplit(t) {\n    return xi(t);\n  }\n  _splitTextIntoLines(t) {\n    const e = t.split(this._reNewline), s = new Array(e.length), r = [`\n`];\n    let n = [];\n    for (let o = 0; o < e.length; o++) s[o] = this.graphemeSplit(e[o]), n = n.concat(s[o], r);\n    return n.pop(), { _unwrappedLines: s, lines: e, graphemeText: n, graphemeLines: s };\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return v(v({}, super.toObject([...il, ...t])), {}, { styles: Ec(this.styles, this.text) }, this.path ? { path: this.path.toObject() } : {});\n  }\n  set(t, e) {\n    const { textLayoutProperties: s } = this.constructor;\n    super.set(t, e);\n    let r = !1, n = !1;\n    if (typeof t == \"object\") for (const o in t) o === \"path\" && this.setPathInfo(), r = r || s.includes(o), n = n || o === \"path\";\n    else r = s.includes(t), n = t === \"path\";\n    return n && this.setPathInfo(), r && this.initialized && (this.initDimensions(), this.setCoords()), this;\n  }\n  complexity() {\n    return 1;\n  }\n  static async fromElement(t, e, s) {\n    const r = fe(t, ct.ATTRIBUTE_NAMES, s), n = v(v({}, e), r), { textAnchor: o = L, textDecoration: a = \"\", dx: c = 0, dy: l = 0, top: h = 0, left: u = 0, fontSize: d = En, strokeWidth: f = 1 } = n, g = G(n, Od), p = new this((t.textContent || \"\").replace(/^\\s+|\\s+$|\\n+/g, \"\").replace(/\\s+/g, \" \"), v({ left: u + c, top: h + l, underline: a.includes(\"underline\"), overline: a.includes(\"overline\"), linethrough: a.includes(\"line-through\"), strokeWidth: 0, fontSize: d }, g)), m = p.getScaledHeight() / p.height, b = ((p.height + p.strokeWidth) * p.lineHeight - p.height) * m, S = p.getScaledHeight() + b;\n    let w = 0;\n    return o === j && (w = p.getScaledWidth() / 2), o === Z && (w = p.getScaledWidth()), p.set({ left: p.left - w, top: p.top - (S - p.fontSize * (0.07 + p._fontSizeFraction)) / p.lineHeight, strokeWidth: f }), p;\n  }\n  static fromObject(t) {\n    return this._fromObject(v(v({}, t), {}, { styles: Pc(t.styles || {}, t.text) }), { extraParam: \"text\" });\n  }\n}\ny(ct, \"textLayoutProperties\", rl), y(ct, \"cacheProperties\", [...de, ...il]), y(ct, \"ownDefaults\", xd), y(ct, \"type\", \"Text\"), y(ct, \"genericFonts\", [\"serif\", \"sans-serif\", \"monospace\", \"cursive\", \"fantasy\", \"system-ui\", \"ui-serif\", \"ui-sans-serif\", \"ui-monospace\", \"ui-rounded\", \"math\", \"emoji\", \"fangsong\"]), y(ct, \"ATTRIBUTE_NAMES\", De.concat(\"x\", \"y\", \"dx\", \"dy\", \"font-family\", \"font-style\", \"font-weight\", \"font-size\", \"letter-spacing\", \"text-decoration\", \"text-anchor\")), kc(ct, [class extends ac {\n  _toSVG() {\n    const i = this._getSVGLeftTopOffsets(), t = this._getSVGTextAndBg(i.textTop, i.textLeft);\n    return this._wrapSVGTextAndBg(t);\n  }\n  toSVG(i) {\n    return this._createBaseSVGMarkup(this._toSVG(), { reviver: i, noStyle: !0, withShadow: !0 });\n  }\n  _getSVGLeftTopOffsets() {\n    return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };\n  }\n  _wrapSVGTextAndBg(i) {\n    let { textBgRects: t, textSpans: e } = i;\n    const s = this.getSvgTextDecoration(this);\n    return [t.join(\"\"), '\t\t<text xml:space=\"preserve\" ', this.fontFamily ? 'font-family=\"'.concat(this.fontFamily.replace(Cd, \"'\"), '\" ') : \"\", this.fontSize ? 'font-size=\"'.concat(this.fontSize, '\" ') : \"\", this.fontStyle ? 'font-style=\"'.concat(this.fontStyle, '\" ') : \"\", this.fontWeight ? 'font-weight=\"'.concat(this.fontWeight, '\" ') : \"\", s ? 'text-decoration=\"'.concat(s, '\" ') : \"\", this.direction === \"rtl\" ? 'direction=\"'.concat(this.direction, '\" ') : \"\", 'style=\"', this.getSvgStyles(!0), '\"', this.addPaintOrder(), \" >\", e.join(\"\"), `</text>\n`];\n  }\n  _getSVGTextAndBg(i, t) {\n    const e = [], s = [];\n    let r, n = i;\n    this.backgroundColor && s.push(...Vi(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));\n    for (let o = 0, a = this._textLines.length; o < a; o++) r = this._getLineLeftOffset(o), this.direction === \"rtl\" && (r += this.width), (this.textBackgroundColor || this.styleHas(\"textBackgroundColor\", o)) && this._setSVGTextLineBg(s, o, t + r, n), this._setSVGTextLineText(e, o, t + r, n), n += this.getHeightOfLine(o);\n    return { textSpans: e, textBgRects: s };\n  }\n  _createTextCharSpan(i, t, e, s) {\n    const r = this.getSvgSpanStyles(t, i !== i.trim() || !!i.match(wd)), n = r ? 'style=\"'.concat(r, '\"') : \"\", o = t.deltaY, a = o ? ' dy=\"'.concat(V(o, A.NUM_FRACTION_DIGITS), '\" ') : \"\";\n    return '<tspan x=\"'.concat(V(e, A.NUM_FRACTION_DIGITS), '\" y=\"').concat(V(s, A.NUM_FRACTION_DIGITS), '\" ').concat(a).concat(n, \">\").concat(jc(i), \"</tspan>\");\n  }\n  _setSVGTextLineText(i, t, e, s) {\n    const r = this.getHeightOfLine(t), n = this.textAlign.includes(Ht), o = this._textLines[t];\n    let a, c, l, h, u, d = \"\", f = 0;\n    s += r * (1 - this._fontSizeFraction) / this.lineHeight;\n    for (let g = 0, p = o.length - 1; g <= p; g++) u = g === p || this.charSpacing, d += o[g], l = this.__charBounds[t][g], f === 0 ? (e += l.kernedWidth - l.width, f += l.width) : f += l.kernedWidth, n && !u && this._reSpaceAndTab.test(o[g]) && (u = !0), u || (a = a || this.getCompleteStyleDeclaration(t, g), c = this.getCompleteStyleDeclaration(t, g + 1), u = wi(a, c, !0)), u && (h = this._getStyleDeclaration(t, g), i.push(this._createTextCharSpan(d, h, e, s)), d = \"\", a = c, this.direction === \"rtl\" ? e -= f : e += f, f = 0);\n  }\n  _setSVGTextLineBg(i, t, e, s) {\n    const r = this._textLines[t], n = this.getHeightOfLine(t) / this.lineHeight;\n    let o, a = 0, c = 0, l = this.getValueOfPropertyAt(t, 0, \"textBackgroundColor\");\n    for (let h = 0; h < r.length; h++) {\n      const { left: u, width: d, kernedWidth: f } = this.__charBounds[t][h];\n      o = this.getValueOfPropertyAt(t, h, \"textBackgroundColor\"), o !== l ? (l && i.push(...Vi(l, e + c, s, a, n)), c = u, a = d, l = o) : a += f;\n    }\n    o && i.push(...Vi(l, e + c, s, a, n));\n  }\n  _getSVGLineTopOffset(i) {\n    let t, e = 0;\n    for (t = 0; t < i; t++) e += this.getHeightOfLine(t);\n    const s = this.getHeightOfLine(t);\n    return { lineTop: e, offset: (this._fontSizeMult - this._fontSizeFraction) * s / (this.lineHeight * this._fontSizeMult) };\n  }\n  getSvgStyles(i) {\n    return \"\".concat(super.getSvgStyles(i), \" white-space: pre;\");\n  }\n  getSvgSpanStyles(i, t) {\n    const { fontFamily: e, strokeWidth: s, stroke: r, fill: n, fontSize: o, fontStyle: a, fontWeight: c, deltaY: l } = i, h = this.getSvgTextDecoration(i);\n    return [r ? Ks(mt, r) : \"\", s ? \"stroke-width: \".concat(s, \"; \") : \"\", e ? \"font-family: \".concat(e.includes(\"'\") || e.includes('\"') ? e : \"'\".concat(e, \"'\"), \"; \") : \"\", o ? \"font-size: \".concat(o, \"px; \") : \"\", a ? \"font-style: \".concat(a, \"; \") : \"\", c ? \"font-weight: \".concat(c, \"; \") : \"\", h && \"text-decoration: \".concat(h, \"; \"), n ? Ks(rt, n) : \"\", l ? \"baseline-shift: \".concat(-l, \"; \") : \"\", t ? \"white-space: pre; \" : \"\"].join(\"\");\n  }\n  getSvgTextDecoration(i) {\n    return [\"overline\", \"underline\", \"line-through\"].filter((t) => i[t.replace(\"-\", \"\")]).join(\" \");\n  }\n}]), C.setClass(ct), C.setSVGClass(ct);\nclass kd {\n  constructor(t) {\n    y(this, \"target\", void 0), y(this, \"__mouseDownInPlace\", !1), y(this, \"__dragStartFired\", !1), y(this, \"__isDraggingOver\", !1), y(this, \"__dragStartSelection\", void 0), y(this, \"__dragImageDisposer\", void 0), y(this, \"_dispose\", void 0), this.target = t;\n    const e = [this.target.on(\"dragenter\", this.dragEnterHandler.bind(this)), this.target.on(\"dragover\", this.dragOverHandler.bind(this)), this.target.on(\"dragleave\", this.dragLeaveHandler.bind(this)), this.target.on(\"dragend\", this.dragEndHandler.bind(this)), this.target.on(\"drop\", this.dropHandler.bind(this))];\n    this._dispose = () => {\n      e.forEach((s) => s()), this._dispose = void 0;\n    };\n  }\n  isPointerOverSelection(t) {\n    const e = this.target, s = e.getSelectionStartFromPointer(t);\n    return e.isEditing && s >= e.selectionStart && s <= e.selectionEnd && e.selectionStart < e.selectionEnd;\n  }\n  start(t) {\n    return this.__mouseDownInPlace = this.isPointerOverSelection(t);\n  }\n  isActive() {\n    return this.__mouseDownInPlace;\n  }\n  end(t) {\n    const e = this.isActive();\n    return e && !this.__dragStartFired && (this.target.setCursorByClick(t), this.target.initDelayedCursor(!0)), this.__mouseDownInPlace = !1, this.__dragStartFired = !1, this.__isDraggingOver = !1, e;\n  }\n  getDragStartSelection() {\n    return this.__dragStartSelection;\n  }\n  setDragImage(t, e) {\n    var s;\n    let { selectionStart: r, selectionEnd: n } = e;\n    const o = this.target, a = o.canvas, c = new _(o.flipX ? -1 : 1, o.flipY ? -1 : 1), l = o._getCursorBoundaries(r), h = new _(l.left + l.leftOffset, l.top + l.topOffset).multiply(c).transform(o.calcTransformMatrix()), u = a.getScenePoint(t).subtract(h), d = o.getCanvasRetinaScaling(), f = o.getBoundingRect(), g = h.subtract(new _(f.left, f.top)), p = a.viewportTransform, m = g.add(u).transform(p, !0), b = o.backgroundColor, S = Kn(o.styles);\n    o.backgroundColor = \"\";\n    const w = { stroke: \"transparent\", fill: \"transparent\", textBackgroundColor: \"transparent\" };\n    o.setSelectionStyles(w, 0, r), o.setSelectionStyles(w, n, o.text.length), o.dirty = !0;\n    const k = o.toCanvasElement({ enableRetinaScaling: a.enableRetinaScaling, viewportTransform: !0 });\n    o.backgroundColor = b, o.styles = S, o.dirty = !0, ii(k, { position: \"fixed\", left: \"\".concat(-k.width, \"px\"), border: pt, width: \"\".concat(k.width / d, \"px\"), height: \"\".concat(k.height / d, \"px\") }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = () => {\n      k.remove();\n    }, At(t.target || this.target.hiddenTextarea).body.appendChild(k), (s = t.dataTransfer) === null || s === void 0 || s.setDragImage(k, m.x, m.y);\n  }\n  onDragStart(t) {\n    this.__dragStartFired = !0;\n    const e = this.target, s = this.isActive();\n    if (s && t.dataTransfer) {\n      const r = this.__dragStartSelection = { selectionStart: e.selectionStart, selectionEnd: e.selectionEnd }, n = e._text.slice(r.selectionStart, r.selectionEnd).join(\"\"), o = v({ text: e.text, value: n }, r);\n      t.dataTransfer.setData(\"text/plain\", n), t.dataTransfer.setData(\"application/fabric\", JSON.stringify({ value: n, styles: e.getSelectionStyles(r.selectionStart, r.selectionEnd, !0) })), t.dataTransfer.effectAllowed = \"copyMove\", this.setDragImage(t, o);\n    }\n    return e.abortCursorAnimation(), s;\n  }\n  canDrop(t) {\n    if (this.target.editable && !this.target.getActiveControl() && !t.defaultPrevented) {\n      if (this.isActive() && this.__dragStartSelection) {\n        const e = this.target.getSelectionStartFromPointer(t), s = this.__dragStartSelection;\n        return e < s.selectionStart || e > s.selectionEnd;\n      }\n      return !0;\n    }\n    return !1;\n  }\n  targetCanDrop(t) {\n    return this.target.canDrop(t);\n  }\n  dragEnterHandler(t) {\n    let { e } = t;\n    const s = this.targetCanDrop(e);\n    !this.__isDraggingOver && s && (this.__isDraggingOver = !0);\n  }\n  dragOverHandler(t) {\n    const { e } = t, s = this.targetCanDrop(e);\n    !this.__isDraggingOver && s ? this.__isDraggingOver = !0 : this.__isDraggingOver && !s && (this.__isDraggingOver = !1), this.__isDraggingOver && (e.preventDefault(), t.canDrop = !0, t.dropTarget = this.target);\n  }\n  dragLeaveHandler() {\n    (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = !1);\n  }\n  dropHandler(t) {\n    var e;\n    const { e: s } = t, r = s.defaultPrevented;\n    this.__isDraggingOver = !1, s.preventDefault();\n    let n = (e = s.dataTransfer) === null || e === void 0 ? void 0 : e.getData(\"text/plain\");\n    if (n && !r) {\n      const o = this.target, a = o.canvas;\n      let c = o.getSelectionStartFromPointer(s);\n      const { styles: l } = s.dataTransfer.types.includes(\"application/fabric\") ? JSON.parse(s.dataTransfer.getData(\"application/fabric\")) : {}, h = n[Math.max(0, n.length - 1)], u = 0;\n      if (this.__dragStartSelection) {\n        const d = this.__dragStartSelection.selectionStart, f = this.__dragStartSelection.selectionEnd;\n        c > d && c <= f ? c = d : c > f && (c -= f - d), o.removeChars(d, f), delete this.__dragStartSelection;\n      }\n      o._reNewline.test(h) && (o._reNewline.test(o._text[c]) || c === o._text.length) && (n = n.trimEnd()), t.didDrop = !0, t.dropTarget = o, o.insertChars(n, l, c), a.setActiveObject(o), o.enterEditing(s), o.selectionStart = Math.min(c + u, o._text.length), o.selectionEnd = Math.min(o.selectionStart + n.length, o._text.length), o.hiddenTextarea.value = o.text, o._updateTextarea(), o.hiddenTextarea.focus(), o.fire(Ur, { index: c + u, action: \"drop\" }), a.fire(\"text:changed\", { target: o }), a.contextTopDirty = !0, a.requestRenderAll();\n    }\n  }\n  dragEndHandler(t) {\n    let { e } = t;\n    if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {\n      var s;\n      const r = this.target, n = this.target.canvas, { selectionStart: o, selectionEnd: a } = this.__dragStartSelection, c = ((s = e.dataTransfer) === null || s === void 0 ? void 0 : s.dropEffect) || pt;\n      c === pt ? (r.selectionStart = o, r.selectionEnd = a, r._updateTextarea(), r.hiddenTextarea.focus()) : (r.clearContextTop(), c === \"move\" && (r.removeChars(o, a), r.selectionStart = r.selectionEnd = o, r.hiddenTextarea && (r.hiddenTextarea.value = r.text), r._updateTextarea(), r.fire(Ur, { index: o, action: \"dragend\" }), n.fire(\"text:changed\", { target: r }), n.requestRenderAll()), r.exitEditing());\n    }\n    this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = !1;\n  }\n  dispose() {\n    this._dispose && this._dispose();\n  }\n}\nconst Ho = /[ \\n\\.,;!\\?\\-]/;\nclass Md extends ct {\n  constructor() {\n    super(...arguments), y(this, \"_currentCursorOpacity\", 1);\n  }\n  initBehavior() {\n    this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);\n  }\n  onDeselect(t) {\n    return this.isEditing && this.exitEditing(), this.selected = !1, super.onDeselect(t);\n  }\n  _animateCursor(t) {\n    let { toValue: e, duration: s, delay: r, onComplete: n } = t;\n    return Un({ startValue: this._currentCursorOpacity, endValue: e, duration: s, delay: r, onComplete: n, abort: () => !this.canvas || this.selectionStart !== this.selectionEnd, onChange: (o) => {\n      this._currentCursorOpacity = o, this.renderCursorOrSelection();\n    } });\n  }\n  _tick(t) {\n    this._currentTickState = this._animateCursor({ toValue: 0, duration: this.cursorDuration / 2, delay: Math.max(t || 0, 100), onComplete: this._onTickComplete });\n  }\n  _onTickComplete() {\n    var t;\n    (t = this._currentTickCompleteState) === null || t === void 0 || t.abort(), this._currentTickCompleteState = this._animateCursor({ toValue: 1, duration: this.cursorDuration, onComplete: this._tick });\n  }\n  initDelayedCursor(t) {\n    this.abortCursorAnimation(), this._tick(t ? 0 : this.cursorDelay);\n  }\n  abortCursorAnimation() {\n    let t = !1;\n    [this._currentTickState, this._currentTickCompleteState].forEach((e) => {\n      e && !e.isDone() && (t = !0, e.abort());\n    }), this._currentCursorOpacity = 1, t && this.clearContextTop();\n  }\n  restartCursorIfNeeded() {\n    [this._currentTickState, this._currentTickCompleteState].some((t) => !t || t.isDone()) && this.initDelayedCursor();\n  }\n  selectAll() {\n    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;\n  }\n  getSelectedText() {\n    return this._text.slice(this.selectionStart, this.selectionEnd).join(\"\");\n  }\n  findWordBoundaryLeft(t) {\n    let e = 0, s = t - 1;\n    if (this._reSpace.test(this._text[s])) for (; this._reSpace.test(this._text[s]); ) e++, s--;\n    for (; /\\S/.test(this._text[s]) && s > -1; ) e++, s--;\n    return t - e;\n  }\n  findWordBoundaryRight(t) {\n    let e = 0, s = t;\n    if (this._reSpace.test(this._text[s])) for (; this._reSpace.test(this._text[s]); ) e++, s++;\n    for (; /\\S/.test(this._text[s]) && s < this._text.length; ) e++, s++;\n    return t + e;\n  }\n  findLineBoundaryLeft(t) {\n    let e = 0, s = t - 1;\n    for (; !/\\n/.test(this._text[s]) && s > -1; ) e++, s--;\n    return t - e;\n  }\n  findLineBoundaryRight(t) {\n    let e = 0, s = t;\n    for (; !/\\n/.test(this._text[s]) && s < this._text.length; ) e++, s++;\n    return t + e;\n  }\n  searchWordBoundary(t, e) {\n    const s = this._text;\n    let r = t > 0 && this._reSpace.test(s[t]) && (e === -1 || !Pn.test(s[t - 1])) ? t - 1 : t, n = s[r];\n    for (; r > 0 && r < s.length && !Ho.test(n); ) r += e, n = s[r];\n    return e === -1 && Ho.test(n) && r++, r;\n  }\n  selectWord(t) {\n    t = t || this.selectionStart;\n    const e = this.searchWordBoundary(t, -1), s = Math.max(e, this.searchWordBoundary(t, 1));\n    this.selectionStart = e, this.selectionEnd = s, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();\n  }\n  selectLine(t) {\n    t = t || this.selectionStart;\n    const e = this.findLineBoundaryLeft(t), s = this.findLineBoundaryRight(t);\n    return this.selectionStart = e, this.selectionEnd = s, this._fireSelectionChanged(), this._updateTextarea(), this;\n  }\n  enterEditing(t) {\n    !this.isEditing && this.editable && (this.enterEditingImpl(), this.fire(\"editing:entered\", t ? { e: t } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire(\"text:editing:entered\", { target: this, e: t }), this.canvas.requestRenderAll()));\n  }\n  enterEditingImpl() {\n    this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = !0, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick();\n  }\n  updateSelectionOnMouseMove(t) {\n    if (this.getActiveControl()) return;\n    const e = this.hiddenTextarea;\n    At(e).activeElement !== e && e.focus();\n    const s = this.getSelectionStartFromPointer(t), r = this.selectionStart, n = this.selectionEnd;\n    (s === this.__selectionStartOnMouseDown && r !== n || r !== s && n !== s) && (s > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = s) : (this.selectionStart = s, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === r && this.selectionEnd === n || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));\n  }\n  _setEditingProps() {\n    this.hoverCursor = \"text\", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = \"text\"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;\n  }\n  fromStringToGraphemeSelection(t, e, s) {\n    const r = s.slice(0, t), n = this.graphemeSplit(r).length;\n    if (t === e) return { selectionStart: n, selectionEnd: n };\n    const o = s.slice(t, e);\n    return { selectionStart: n, selectionEnd: n + this.graphemeSplit(o).length };\n  }\n  fromGraphemeToStringSelection(t, e, s) {\n    const r = s.slice(0, t).join(\"\").length;\n    return t === e ? { selectionStart: r, selectionEnd: r } : { selectionStart: r, selectionEnd: r + s.slice(t, e).join(\"\").length };\n  }\n  _updateTextarea() {\n    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {\n      if (!this.inCompositionMode) {\n        const t = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);\n        this.hiddenTextarea.selectionStart = t.selectionStart, this.hiddenTextarea.selectionEnd = t.selectionEnd;\n      }\n      this.updateTextareaPosition();\n    }\n  }\n  updateFromTextArea() {\n    if (!this.hiddenTextarea) return;\n    this.cursorOffsetCache = {};\n    const t = this.hiddenTextarea;\n    this.text = t.value, this.set(\"dirty\", !0), this.initDimensions(), this.setCoords();\n    const e = this.fromStringToGraphemeSelection(t.selectionStart, t.selectionEnd, t.value);\n    this.selectionEnd = this.selectionStart = e.selectionEnd, this.inCompositionMode || (this.selectionStart = e.selectionStart), this.updateTextareaPosition();\n  }\n  updateTextareaPosition() {\n    if (this.selectionStart === this.selectionEnd) {\n      const t = this._calcTextareaPosition();\n      this.hiddenTextarea.style.left = t.left, this.hiddenTextarea.style.top = t.top;\n    }\n  }\n  _calcTextareaPosition() {\n    if (!this.canvas) return { left: \"1px\", top: \"1px\" };\n    const t = this.inCompositionMode ? this.compositionStart : this.selectionStart, e = this._getCursorBoundaries(t), s = this.get2DCursorLocation(t), r = s.lineIndex, n = s.charIndex, o = this.getValueOfPropertyAt(r, n, \"fontSize\") * this.lineHeight, a = e.leftOffset, c = this.getCanvasRetinaScaling(), l = this.canvas.upperCanvasEl, h = l.width / c, u = l.height / c, d = h - o, f = u - o, g = new _(e.left + a, e.top + e.topOffset + o).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new _(l.clientWidth / h, l.clientHeight / u));\n    return g.x < 0 && (g.x = 0), g.x > d && (g.x = d), g.y < 0 && (g.y = 0), g.y > f && (g.y = f), g.x += this.canvas._offset.left, g.y += this.canvas._offset.top, { left: \"\".concat(g.x, \"px\"), top: \"\".concat(g.y, \"px\"), fontSize: \"\".concat(o, \"px\"), charHeight: o };\n  }\n  _saveEditingProps() {\n    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };\n  }\n  _restoreEditingProps() {\n    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);\n  }\n  _exitEditing() {\n    const t = this.hiddenTextarea;\n    this.selected = !1, this.isEditing = !1, t && (t.blur && t.blur(), t.parentNode && t.parentNode.removeChild(t)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();\n  }\n  exitEditingImpl() {\n    this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords());\n  }\n  exitEditing() {\n    const t = this._textBeforeEdit !== this.text;\n    return this.exitEditingImpl(), this.fire(\"editing:exited\"), t && this.fire($r), this.canvas && (this.canvas.fire(\"text:editing:exited\", { target: this }), t && this.canvas.fire(\"object:modified\", { target: this })), this;\n  }\n  _removeExtraneousStyles() {\n    for (const t in this.styles) this._textLines[t] || delete this.styles[t];\n  }\n  removeStyleFromTo(t, e) {\n    const { lineIndex: s, charIndex: r } = this.get2DCursorLocation(t, !0), { lineIndex: n, charIndex: o } = this.get2DCursorLocation(e, !0);\n    if (s !== n) {\n      if (this.styles[s]) for (let a = r; a < this._unwrappedTextLines[s].length; a++) delete this.styles[s][a];\n      if (this.styles[n]) for (let a = o; a < this._unwrappedTextLines[n].length; a++) {\n        const c = this.styles[n][a];\n        c && (this.styles[s] || (this.styles[s] = {}), this.styles[s][r + a - o] = c);\n      }\n      for (let a = s + 1; a <= n; a++) delete this.styles[a];\n      this.shiftLineStyles(n, s - n);\n    } else if (this.styles[s]) {\n      const a = this.styles[s], c = o - r;\n      for (let l = r; l < o; l++) delete a[l];\n      for (const l in this.styles[s]) {\n        const h = parseInt(l, 10);\n        h >= o && (a[h - c] = a[l], delete a[l]);\n      }\n    }\n  }\n  shiftLineStyles(t, e) {\n    const s = Object.assign({}, this.styles);\n    for (const r in this.styles) {\n      const n = parseInt(r, 10);\n      n > t && (this.styles[n + e] = s[n], s[n - e] || delete this.styles[n]);\n    }\n  }\n  insertNewlineStyleObject(t, e, s, r) {\n    const n = {}, o = this._unwrappedTextLines[t].length, a = o === e;\n    let c = !1;\n    s || (s = 1), this.shiftLineStyles(t, s);\n    const l = this.styles[t] ? this.styles[t][e === 0 ? e : e - 1] : void 0;\n    for (const u in this.styles[t]) {\n      const d = parseInt(u, 10);\n      d >= e && (c = !0, n[d - e] = this.styles[t][u], a && e === 0 || delete this.styles[t][u]);\n    }\n    let h = !1;\n    for (c && !a && (this.styles[t + s] = n, h = !0), (h || o > e) && s--; s > 0; ) r && r[s - 1] ? this.styles[t + s] = { 0: v({}, r[s - 1]) } : l ? this.styles[t + s] = { 0: v({}, l) } : delete this.styles[t + s], s--;\n    this._forceClearCache = !0;\n  }\n  insertCharStyleObject(t, e, s, r) {\n    this.styles || (this.styles = {});\n    const n = this.styles[t], o = n ? v({}, n) : {};\n    s || (s = 1);\n    for (const c in o) {\n      const l = parseInt(c, 10);\n      l >= e && (n[l + s] = o[l], o[l - s] || delete n[l]);\n    }\n    if (this._forceClearCache = !0, r) {\n      for (; s--; ) Object.keys(r[s]).length && (this.styles[t] || (this.styles[t] = {}), this.styles[t][e + s] = v({}, r[s]));\n      return;\n    }\n    if (!n) return;\n    const a = n[e ? e - 1 : 1];\n    for (; a && s--; ) this.styles[t][e + s] = v({}, a);\n  }\n  insertNewStyleBlock(t, e, s) {\n    const r = this.get2DCursorLocation(e, !0), n = [0];\n    let o, a = 0;\n    for (let c = 0; c < t.length; c++) t[c] === `\n` ? (a++, n[a] = 0) : n[a]++;\n    for (n[0] > 0 && (this.insertCharStyleObject(r.lineIndex, r.charIndex, n[0], s), s = s && s.slice(n[0] + 1)), a && this.insertNewlineStyleObject(r.lineIndex, r.charIndex + n[0], a), o = 1; o < a; o++) n[o] > 0 ? this.insertCharStyleObject(r.lineIndex + o, 0, n[o], s) : s && this.styles[r.lineIndex + o] && s[0] && (this.styles[r.lineIndex + o][0] = s[0]), s = s && s.slice(n[o] + 1);\n    n[o] > 0 && this.insertCharStyleObject(r.lineIndex + o, 0, n[o], s);\n  }\n  removeChars(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t + 1;\n    this.removeStyleFromTo(t, e), this._text.splice(t, e - t), this.text = this._text.join(\"\"), this.set(\"dirty\", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();\n  }\n  insertChars(t, e, s) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : s;\n    r > s && this.removeStyleFromTo(s, r);\n    const n = this.graphemeSplit(t);\n    this.insertNewStyleBlock(n, s, e), this._text = [...this._text.slice(0, s), ...n, ...this._text.slice(r)], this.text = this._text.join(\"\"), this.set(\"dirty\", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();\n  }\n  setSelectionStartEndWithShift(t, e, s) {\n    s <= t ? (e === t ? this._selectionDirection = L : this._selectionDirection === Z && (this._selectionDirection = L, this.selectionEnd = t), this.selectionStart = s) : s > t && s < e ? this._selectionDirection === Z ? this.selectionEnd = s : this.selectionStart = s : (e === t ? this._selectionDirection = Z : this._selectionDirection === L && (this._selectionDirection = Z, this.selectionStart = e), this.selectionEnd = s);\n  }\n}\nclass Id extends Md {\n  initHiddenTextarea() {\n    const t = this.canvas && At(this.canvas.getElement()) || Cs(), e = t.createElement(\"textarea\");\n    Object.entries({ autocapitalize: \"off\", autocorrect: \"off\", autocomplete: \"off\", spellcheck: \"false\", \"data-fabric\": \"textarea\", wrap: \"off\" }).map((o) => {\n      let [a, c] = o;\n      return e.setAttribute(a, c);\n    });\n    const { top: s, left: r, fontSize: n } = this._calcTextareaPosition();\n    e.style.cssText = \"position: absolute; top: \".concat(s, \"; left: \").concat(r, \"; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: \").concat(n, \";\"), (this.hiddenTextareaContainer || t.body).appendChild(e), Object.entries({ blur: \"blur\", keydown: \"onKeyDown\", keyup: \"onKeyUp\", input: \"onInput\", copy: \"copy\", cut: \"copy\", paste: \"paste\", compositionstart: \"onCompositionStart\", compositionupdate: \"onCompositionUpdate\", compositionend: \"onCompositionEnd\" }).map((o) => {\n      let [a, c] = o;\n      return e.addEventListener(a, this[c].bind(this));\n    }), this.hiddenTextarea = e;\n  }\n  blur() {\n    this.abortCursorAnimation();\n  }\n  onKeyDown(t) {\n    if (!this.isEditing) return;\n    const e = this.direction === \"rtl\" ? this.keysMapRtl : this.keysMap;\n    if (t.keyCode in e) this[e[t.keyCode]](t);\n    else {\n      if (!(t.keyCode in this.ctrlKeysMapDown) || !t.ctrlKey && !t.metaKey) return;\n      this[this.ctrlKeysMapDown[t.keyCode]](t);\n    }\n    t.stopImmediatePropagation(), t.preventDefault(), t.keyCode >= 33 && t.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();\n  }\n  onKeyUp(t) {\n    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : t.keyCode in this.ctrlKeysMapUp && (t.ctrlKey || t.metaKey) && (this[this.ctrlKeysMapUp[t.keyCode]](t), t.stopImmediatePropagation(), t.preventDefault(), this.canvas && this.canvas.requestRenderAll());\n  }\n  onInput(t) {\n    const e = this.fromPaste;\n    if (this.fromPaste = !1, t && t.stopPropagation(), !this.isEditing) return;\n    const s = () => {\n      this.updateFromTextArea(), this.fire(Ur), this.canvas && (this.canvas.fire(\"text:changed\", { target: this }), this.canvas.requestRenderAll());\n    };\n    if (this.hiddenTextarea.value === \"\") return this.styles = {}, void s();\n    const r = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, n = this._text.length, o = r.length, a = this.selectionStart, c = this.selectionEnd, l = a !== c;\n    let h, u, d, f, g = o - n;\n    const p = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), m = a > p.selectionStart;\n    l ? (u = this._text.slice(a, c), g += c - a) : o < n && (u = m ? this._text.slice(c + g, c) : this._text.slice(a, a - g));\n    const b = r.slice(p.selectionEnd - g, p.selectionEnd);\n    if (u && u.length && (b.length && (h = this.getSelectionStyles(a, a + 1, !1), h = b.map(() => h[0])), l ? (d = a, f = c) : m ? (d = c - u.length, f = c) : (d = c, f = c + u.length), this.removeStyleFromTo(d, f)), b.length) {\n      const { copyPasteData: S } = $t();\n      e && b.join(\"\") === S.copiedText && !A.disableStyleCopyPaste && (h = S.copiedTextStyle), this.insertNewStyleBlock(b, a, h);\n    }\n    s();\n  }\n  onCompositionStart() {\n    this.inCompositionMode = !0;\n  }\n  onCompositionEnd() {\n    this.inCompositionMode = !1;\n  }\n  onCompositionUpdate(t) {\n    let { target: e } = t;\n    const { selectionStart: s, selectionEnd: r } = e;\n    this.compositionStart = s, this.compositionEnd = r, this.updateTextareaPosition();\n  }\n  copy() {\n    if (this.selectionStart === this.selectionEnd) return;\n    const { copyPasteData: t } = $t();\n    t.copiedText = this.getSelectedText(), A.disableStyleCopyPaste ? t.copiedTextStyle = void 0 : t.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0;\n  }\n  paste() {\n    this.fromPaste = !0;\n  }\n  _getWidthBeforeCursor(t, e) {\n    let s, r = this._getLineLeftOffset(t);\n    return e > 0 && (s = this.__charBounds[t][e - 1], r += s.left + s.width), r;\n  }\n  getDownCursorOffset(t, e) {\n    const s = this._getSelectionForOffset(t, e), r = this.get2DCursorLocation(s), n = r.lineIndex;\n    if (n === this._textLines.length - 1 || t.metaKey || t.keyCode === 34) return this._text.length - s;\n    const o = r.charIndex, a = this._getWidthBeforeCursor(n, o), c = this._getIndexOnLine(n + 1, a);\n    return this._textLines[n].slice(o).length + c + 1 + this.missingNewlineOffset(n);\n  }\n  _getSelectionForOffset(t, e) {\n    return t.shiftKey && this.selectionStart !== this.selectionEnd && e ? this.selectionEnd : this.selectionStart;\n  }\n  getUpCursorOffset(t, e) {\n    const s = this._getSelectionForOffset(t, e), r = this.get2DCursorLocation(s), n = r.lineIndex;\n    if (n === 0 || t.metaKey || t.keyCode === 33) return -s;\n    const o = r.charIndex, a = this._getWidthBeforeCursor(n, o), c = this._getIndexOnLine(n - 1, a), l = this._textLines[n].slice(0, o), h = this.missingNewlineOffset(n - 1);\n    return -this._textLines[n - 1].length + c - l.length + (1 - h);\n  }\n  _getIndexOnLine(t, e) {\n    const s = this._textLines[t];\n    let r, n, o = this._getLineLeftOffset(t), a = 0;\n    for (let c = 0, l = s.length; c < l; c++) if (r = this.__charBounds[t][c].width, o += r, o > e) {\n      n = !0;\n      const h = o - r, u = o, d = Math.abs(h - e);\n      a = Math.abs(u - e) < d ? c : c - 1;\n      break;\n    }\n    return n || (a = s.length - 1), a;\n  }\n  moveCursorDown(t) {\n    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown(\"Down\", t);\n  }\n  moveCursorUp(t) {\n    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown(\"Up\", t);\n  }\n  _moveCursorUpOrDown(t, e) {\n    const s = this[\"get\".concat(t, \"CursorOffset\")](e, this._selectionDirection === Z);\n    if (e.shiftKey ? this.moveCursorWithShift(s) : this.moveCursorWithoutShift(s), s !== 0) {\n      const r = this.text.length;\n      this.selectionStart = ze(0, this.selectionStart, r), this.selectionEnd = ze(0, this.selectionEnd, r), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();\n    }\n  }\n  moveCursorWithShift(t) {\n    const e = this._selectionDirection === L ? this.selectionStart + t : this.selectionEnd + t;\n    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, e), t !== 0;\n  }\n  moveCursorWithoutShift(t) {\n    return t < 0 ? (this.selectionStart += t, this.selectionEnd = this.selectionStart) : (this.selectionEnd += t, this.selectionStart = this.selectionEnd), t !== 0;\n  }\n  moveCursorLeft(t) {\n    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight(\"Left\", t);\n  }\n  _move(t, e, s) {\n    let r;\n    if (t.altKey) r = this[\"findWordBoundary\".concat(s)](this[e]);\n    else {\n      if (!t.metaKey && t.keyCode !== 35 && t.keyCode !== 36) return this[e] += s === \"Left\" ? -1 : 1, !0;\n      r = this[\"findLineBoundary\".concat(s)](this[e]);\n    }\n    return r !== void 0 && this[e] !== r && (this[e] = r, !0);\n  }\n  _moveLeft(t, e) {\n    return this._move(t, e, \"Left\");\n  }\n  _moveRight(t, e) {\n    return this._move(t, e, \"Right\");\n  }\n  moveCursorLeftWithoutShift(t) {\n    let e = !0;\n    return this._selectionDirection = L, this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (e = this._moveLeft(t, \"selectionStart\")), this.selectionEnd = this.selectionStart, e;\n  }\n  moveCursorLeftWithShift(t) {\n    return this._selectionDirection === Z && this.selectionStart !== this.selectionEnd ? this._moveLeft(t, \"selectionEnd\") : this.selectionStart !== 0 ? (this._selectionDirection = L, this._moveLeft(t, \"selectionStart\")) : void 0;\n  }\n  moveCursorRight(t) {\n    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight(\"Right\", t);\n  }\n  _moveCursorLeftOrRight(t, e) {\n    const s = \"moveCursor\".concat(t).concat(e.shiftKey ? \"WithShift\" : \"WithoutShift\");\n    this._currentCursorOpacity = 1, this[s](e) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());\n  }\n  moveCursorRightWithShift(t) {\n    return this._selectionDirection === L && this.selectionStart !== this.selectionEnd ? this._moveRight(t, \"selectionStart\") : this.selectionEnd !== this._text.length ? (this._selectionDirection = Z, this._moveRight(t, \"selectionEnd\")) : void 0;\n  }\n  moveCursorRightWithoutShift(t) {\n    let e = !0;\n    return this._selectionDirection = Z, this.selectionStart === this.selectionEnd ? (e = this._moveRight(t, \"selectionStart\"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, e;\n  }\n}\nconst Ni = (i) => !!i.button;\nclass Dd extends Id {\n  constructor() {\n    super(...arguments), y(this, \"draggableTextDelegate\", void 0);\n  }\n  initBehavior() {\n    this.on(\"mousedown\", this._mouseDownHandler), this.on(\"mousedown:before\", this._mouseDownHandlerBefore), this.on(\"mouseup\", this.mouseUpHandler), this.on(\"mousedblclick\", this.doubleClickHandler), this.on(\"tripleclick\", this.tripleClickHandler), this.__lastClickTime = +/* @__PURE__ */ new Date(), this.__lastLastClickTime = +/* @__PURE__ */ new Date(), this.__lastPointer = {}, this.on(\"mousedown\", this.onMouseDown), this.draggableTextDelegate = new kd(this), super.initBehavior();\n  }\n  shouldStartDragging() {\n    return this.draggableTextDelegate.isActive();\n  }\n  onDragStart(t) {\n    return this.draggableTextDelegate.onDragStart(t);\n  }\n  canDrop(t) {\n    return this.draggableTextDelegate.canDrop(t);\n  }\n  onMouseDown(t) {\n    if (!this.canvas) return;\n    this.__newClickTime = +/* @__PURE__ */ new Date();\n    const e = t.pointer;\n    this.isTripleClick(e) && (this.fire(\"tripleclick\", t), on(t.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = e, this.__lastSelected = this.selected && !this.getActiveControl();\n  }\n  isTripleClick(t) {\n    return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === t.x && this.__lastPointer.y === t.y;\n  }\n  doubleClickHandler(t) {\n    this.isEditing && this.selectWord(this.getSelectionStartFromPointer(t.e));\n  }\n  tripleClickHandler(t) {\n    this.isEditing && this.selectLine(this.getSelectionStartFromPointer(t.e));\n  }\n  _mouseDownHandler(t) {\n    let { e } = t;\n    this.canvas && this.editable && !Ni(e) && !this.getActiveControl() && (this.draggableTextDelegate.start(e) || (this.canvas.textEditingManager.register(this), this.selected && (this.inCompositionMode = !1, this.setCursorByClick(e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection())));\n  }\n  _mouseDownHandlerBefore(t) {\n    let { e } = t;\n    this.canvas && this.editable && !Ni(e) && (this.selected = this === this.canvas._activeObject);\n  }\n  mouseUpHandler(t) {\n    let { e, transform: s } = t;\n    const r = this.draggableTextDelegate.end(e);\n    if (this.canvas) {\n      this.canvas.textEditingManager.unregister(this);\n      const n = this.canvas._activeObject;\n      if (n && n !== this) return;\n    }\n    !this.editable || this.group && !this.group.interactive || s && s.actionPerformed || Ni(e) || r || (this.__lastSelected && !this.getActiveControl() ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0);\n  }\n  setCursorByClick(t) {\n    const e = this.getSelectionStartFromPointer(t), s = this.selectionStart, r = this.selectionEnd;\n    t.shiftKey ? this.setSelectionStartEndWithShift(s, r, e) : (this.selectionStart = e, this.selectionEnd = e), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());\n  }\n  getSelectionStartFromPointer(t) {\n    const e = this.canvas.getScenePoint(t).transform(St(this.calcTransformMatrix())).add(new _(-this._getLeftOffset(), -this._getTopOffset()));\n    let s = 0, r = 0, n = 0;\n    for (let l = 0; l < this._textLines.length && s <= e.y; l++) s += this.getHeightOfLine(l), n = l, l > 0 && (r += this._textLines[l - 1].length + this.missingNewlineOffset(l - 1));\n    let o = Math.abs(this._getLineLeftOffset(n));\n    const a = this._textLines[n].length, c = this.__charBounds[n];\n    for (let l = 0; l < a; l++) {\n      const h = o + c[l].kernedWidth;\n      if (e.x <= h) {\n        Math.abs(e.x - h) <= Math.abs(e.x - o) && r++;\n        break;\n      }\n      o = h, r++;\n    }\n    return Math.min(this.flipX ? a - r : r, this._text.length);\n  }\n}\nconst _r = \"moveCursorUp\", Sr = \"moveCursorDown\", Tr = \"moveCursorLeft\", xr = \"moveCursorRight\", wr = \"exitEditing\", jd = v({ selectionStart: 0, selectionEnd: 0, selectionColor: \"rgba(17,119,255,0.3)\", isEditing: !1, editable: !0, editingBorderColor: \"rgba(102,153,255,0.25)\", cursorWidth: 2, cursorColor: \"\", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, keysMap: { 9: wr, 27: wr, 33: _r, 34: Sr, 35: xr, 36: Tr, 37: Tr, 38: _r, 39: xr, 40: Sr }, keysMapRtl: { 9: wr, 27: wr, 33: _r, 34: Sr, 35: Tr, 36: xr, 37: xr, 38: _r, 39: Tr, 40: Sr }, ctrlKeysMapDown: { 65: \"selectAll\" }, ctrlKeysMapUp: { 67: \"copy\", 88: \"cut\" } }, { _selectionDirection: null, _reSpace: /\\s|\\r?\\n/, inCompositionMode: !1 });\nclass oe extends Dd {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), oe.ownDefaults);\n  }\n  get type() {\n    const t = super.type;\n    return t === \"itext\" ? \"i-text\" : t;\n  }\n  constructor(t, e) {\n    super(t, v(v({}, oe.ownDefaults), e)), this.initBehavior();\n  }\n  _set(t, e) {\n    return this.isEditing && this._savedProps && t in this._savedProps ? (this._savedProps[t] = e, this) : (t === \"canvas\" && (this.canvas instanceof vn && this.canvas.textEditingManager.remove(this), e instanceof vn && e.textEditingManager.add(this)), super._set(t, e));\n  }\n  setSelectionStart(t) {\n    t = Math.max(t, 0), this._updateAndFire(\"selectionStart\", t);\n  }\n  setSelectionEnd(t) {\n    t = Math.min(t, this.text.length), this._updateAndFire(\"selectionEnd\", t);\n  }\n  _updateAndFire(t, e) {\n    this[t] !== e && (this._fireSelectionChanged(), this[t] = e), this._updateTextarea();\n  }\n  _fireSelectionChanged() {\n    this.fire(\"selection:changed\"), this.canvas && this.canvas.fire(\"text:selection:changed\", { target: this });\n  }\n  initDimensions() {\n    this.isEditing && this.initDelayedCursor(), super.initDimensions();\n  }\n  getSelectionStyles() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart || 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionEnd, s = arguments.length > 2 ? arguments[2] : void 0;\n    return super.getSelectionStyles(t, e, s);\n  }\n  setSelectionStyles(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionStart || 0, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.selectionEnd;\n    return super.setSelectionStyles(t, e, s);\n  }\n  get2DCursorLocation() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, e = arguments.length > 1 ? arguments[1] : void 0;\n    return super.get2DCursorLocation(t, e);\n  }\n  render(t) {\n    super.render(t), this.cursorOffsetCache = {}, this.renderCursorOrSelection();\n  }\n  toCanvasElement(t) {\n    const e = this.isEditing;\n    this.isEditing = !1;\n    const s = super.toCanvasElement(t);\n    return this.isEditing = e, s;\n  }\n  renderCursorOrSelection() {\n    if (!this.isEditing) return;\n    const t = this.clearContextTop(!0);\n    if (!t) return;\n    const e = this._getCursorBoundaries();\n    this.selectionStart !== this.selectionEnd || this.inCompositionMode ? this.renderSelection(t, e) : this.renderCursor(t, e), this.canvas.contextTopDirty = !0, t.restore();\n  }\n  _getCursorBoundaries() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, e = arguments.length > 1 ? arguments[1] : void 0;\n    const s = this._getLeftOffset(), r = this._getTopOffset(), n = this._getCursorBoundariesOffsets(t, e);\n    return { left: s, top: r, leftOffset: n.left, topOffset: n.top };\n  }\n  _getCursorBoundariesOffsets(t, e) {\n    return e ? this.__getCursorBoundariesOffsets(t) : this.cursorOffsetCache && \"top\" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(t);\n  }\n  __getCursorBoundariesOffsets(t) {\n    let e = 0, s = 0;\n    const { charIndex: r, lineIndex: n } = this.get2DCursorLocation(t);\n    for (let l = 0; l < n; l++) e += this.getHeightOfLine(l);\n    const o = this._getLineLeftOffset(n), a = this.__charBounds[n][r];\n    a && (s = a.left), this.charSpacing !== 0 && r === this._textLines[n].length && (s -= this._getWidthOfCharSpacing());\n    const c = { top: e, left: o + (s > 0 ? s : 0) };\n    return this.direction === \"rtl\" && (this.textAlign === Z || this.textAlign === Ht || this.textAlign === Vs ? c.left *= -1 : this.textAlign === L || this.textAlign === ni ? c.left = o - (s > 0 ? s : 0) : this.textAlign !== j && this.textAlign !== Gs || (c.left = o - (s > 0 ? s : 0))), c;\n  }\n  renderCursorAt(t) {\n    this._renderCursor(this.canvas.contextTop, this._getCursorBoundaries(t, !0), t);\n  }\n  renderCursor(t, e) {\n    this._renderCursor(t, e, this.selectionStart);\n  }\n  getCursorRenderingData() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getCursorBoundaries(t);\n    const s = this.get2DCursorLocation(t), r = s.lineIndex, n = s.charIndex > 0 ? s.charIndex - 1 : 0, o = this.getValueOfPropertyAt(r, n, \"fontSize\"), a = this.getObjectScaling().x * this.canvas.getZoom(), c = this.cursorWidth / a, l = this.getValueOfPropertyAt(r, n, \"deltaY\"), h = e.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(r) / this.lineHeight - o * (1 - this._fontSizeFraction);\n    return { color: this.cursorColor || this.getValueOfPropertyAt(r, n, \"fill\"), opacity: this._currentCursorOpacity, left: e.left + e.leftOffset - c / 2, top: h + e.top + l, width: c, height: o };\n  }\n  _renderCursor(t, e, s) {\n    const { color: r, opacity: n, left: o, top: a, width: c, height: l } = this.getCursorRenderingData(s, e);\n    t.fillStyle = r, t.globalAlpha = n, t.fillRect(o, a, c, l);\n  }\n  renderSelection(t, e) {\n    const s = { selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd };\n    this._renderSelection(t, s, e);\n  }\n  renderDragSourceEffect() {\n    const t = this.draggableTextDelegate.getDragStartSelection();\n    this._renderSelection(this.canvas.contextTop, t, this._getCursorBoundaries(t.selectionStart, !0));\n  }\n  renderDropTargetEffect(t) {\n    const e = this.getSelectionStartFromPointer(t);\n    this.renderCursorAt(e);\n  }\n  _renderSelection(t, e, s) {\n    const r = e.selectionStart, n = e.selectionEnd, o = this.textAlign.includes(Ht), a = this.get2DCursorLocation(r), c = this.get2DCursorLocation(n), l = a.lineIndex, h = c.lineIndex, u = a.charIndex < 0 ? 0 : a.charIndex, d = c.charIndex < 0 ? 0 : c.charIndex;\n    for (let f = l; f <= h; f++) {\n      const g = this._getLineLeftOffset(f) || 0;\n      let p = this.getHeightOfLine(f), m = 0, b = 0, S = 0;\n      if (f === l && (b = this.__charBounds[l][u].left), f >= l && f < h) S = o && !this.isEndOfWrapping(f) ? this.width : this.getLineWidth(f) || 5;\n      else if (f === h) if (d === 0) S = this.__charBounds[h][d].left;\n      else {\n        const I = this._getWidthOfCharSpacing();\n        S = this.__charBounds[h][d - 1].left + this.__charBounds[h][d - 1].width - I;\n      }\n      m = p, (this.lineHeight < 1 || f === h && this.lineHeight > 1) && (p /= this.lineHeight);\n      let w = s.left + g + b, k = p, O = 0;\n      const x = S - b;\n      this.inCompositionMode ? (t.fillStyle = this.compositionColor || \"black\", k = 1, O = p) : t.fillStyle = this.selectionColor, this.direction === \"rtl\" && (this.textAlign === Z || this.textAlign === Ht || this.textAlign === Vs ? w = this.width - w - x : this.textAlign === L || this.textAlign === ni ? w = s.left + g - S : this.textAlign !== j && this.textAlign !== Gs || (w = s.left + g - S)), t.fillRect(w, s.top + s.topOffset + O, x, k), s.topOffset += m;\n    }\n  }\n  getCurrentCharFontSize() {\n    const t = this._getCurrentCharIndex();\n    return this.getValueOfPropertyAt(t.l, t.c, \"fontSize\");\n  }\n  getCurrentCharColor() {\n    const t = this._getCurrentCharIndex();\n    return this.getValueOfPropertyAt(t.l, t.c, rt);\n  }\n  _getCurrentCharIndex() {\n    const t = this.get2DCursorLocation(this.selectionStart, !0), e = t.charIndex > 0 ? t.charIndex - 1 : 0;\n    return { l: t.lineIndex, c: e };\n  }\n  dispose() {\n    this.exitEditingImpl(), this.draggableTextDelegate.dispose(), super.dispose();\n  }\n}\ny(oe, \"ownDefaults\", jd), y(oe, \"type\", \"IText\"), C.setClass(oe), C.setClass(oe, \"i-text\");\nclass Le extends oe {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), Le.ownDefaults);\n  }\n  constructor(t, e) {\n    super(t, v(v({}, Le.ownDefaults), e));\n  }\n  static createControls() {\n    return { controls: Oc() };\n  }\n  initDimensions() {\n    this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set(\"width\", this.dynamicMinWidth), this.textAlign.includes(Ht) && this.enlargeSpaces(), this.height = this.calcTextHeight());\n  }\n  _generateStyleMap(t) {\n    let e = 0, s = 0, r = 0;\n    const n = {};\n    for (let o = 0; o < t.graphemeLines.length; o++) t.graphemeText[r] === `\n` && o > 0 ? (s = 0, r++, e++) : !this.splitByGrapheme && this._reSpaceAndTab.test(t.graphemeText[r]) && o > 0 && (s++, r++), n[o] = { line: e, offset: s }, r += t.graphemeLines[o].length, s += t.graphemeLines[o].length;\n    return n;\n  }\n  styleHas(t, e) {\n    if (this._styleMap && !this.isWrapping) {\n      const s = this._styleMap[e];\n      s && (e = s.line);\n    }\n    return super.styleHas(t, e);\n  }\n  isEmptyStyles(t) {\n    if (!this.styles) return !0;\n    let e, s = 0, r = t + 1, n = !1;\n    const o = this._styleMap[t], a = this._styleMap[t + 1];\n    o && (t = o.line, s = o.offset), a && (r = a.line, n = r === t, e = a.offset);\n    const c = t === void 0 ? this.styles : { line: this.styles[t] };\n    for (const l in c) for (const h in c[l]) {\n      const u = parseInt(h, 10);\n      if (u >= s && (!n || u < e)) for (const d in c[l][h]) return !1;\n    }\n    return !0;\n  }\n  _getStyleDeclaration(t, e) {\n    if (this._styleMap && !this.isWrapping) {\n      const s = this._styleMap[t];\n      if (!s) return {};\n      t = s.line, e = s.offset + e;\n    }\n    return super._getStyleDeclaration(t, e);\n  }\n  _setStyleDeclaration(t, e, s) {\n    const r = this._styleMap[t];\n    super._setStyleDeclaration(r.line, r.offset + e, s);\n  }\n  _deleteStyleDeclaration(t, e) {\n    const s = this._styleMap[t];\n    super._deleteStyleDeclaration(s.line, s.offset + e);\n  }\n  _getLineStyle(t) {\n    const e = this._styleMap[t];\n    return !!this.styles[e.line];\n  }\n  _setLineStyle(t) {\n    const e = this._styleMap[t];\n    super._setLineStyle(e.line);\n  }\n  _wrapText(t, e) {\n    this.isWrapping = !0;\n    const s = this.getGraphemeDataForRender(t), r = [];\n    for (let n = 0; n < s.wordsData.length; n++) r.push(...this._wrapLine(n, e, s));\n    return this.isWrapping = !1, r;\n  }\n  getGraphemeDataForRender(t) {\n    const e = this.splitByGrapheme, s = e ? \"\" : \" \";\n    let r = 0;\n    return { wordsData: t.map((n, o) => {\n      let a = 0;\n      const c = e ? this.graphemeSplit(n) : this.wordSplit(n);\n      return c.length === 0 ? [{ word: [], width: 0 }] : c.map((l) => {\n        const h = e ? [l] : this.graphemeSplit(l), u = this._measureWord(h, o, a);\n        return r = Math.max(u, r), a += h.length + s.length, { word: h, width: u };\n      });\n    }), largestWordWidth: r };\n  }\n  _measureWord(t, e) {\n    let s, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = 0;\n    for (let o = 0, a = t.length; o < a; o++)\n      n += this._getGraphemeBox(t[o], e, o + r, s, !0).kernedWidth, s = t[o];\n    return n;\n  }\n  wordSplit(t) {\n    return t.split(this._wordJoiners);\n  }\n  _wrapLine(t, e, s) {\n    let { largestWordWidth: r, wordsData: n } = s, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n    const a = this._getWidthOfCharSpacing(), c = this.splitByGrapheme, l = [], h = c ? \"\" : \" \";\n    let u = 0, d = [], f = 0, g = 0, p = !0;\n    e -= o;\n    const m = Math.max(e, r, this.dynamicMinWidth), b = n[t];\n    let S;\n    for (f = 0, S = 0; S < b.length; S++) {\n      const { word: w, width: k } = b[S];\n      f += w.length, u += g + k - a, u > m && !p ? (l.push(d), d = [], u = k, p = !0) : u += a, p || c || d.push(h), d = d.concat(w), g = c ? 0 : this._measureWord([h], t, f), f++, p = !1;\n    }\n    return S && l.push(d), r + o > this.dynamicMinWidth && (this.dynamicMinWidth = r - a + o), l;\n  }\n  isEndOfWrapping(t) {\n    return !this._styleMap[t + 1] || this._styleMap[t + 1].line !== this._styleMap[t].line;\n  }\n  missingNewlineOffset(t, e) {\n    return this.splitByGrapheme && !e ? this.isEndOfWrapping(t) ? 1 : 0 : 1;\n  }\n  _splitTextIntoLines(t) {\n    const e = super._splitTextIntoLines(t), s = this._wrapText(e.lines, this.width), r = new Array(s.length);\n    for (let n = 0; n < s.length; n++) r[n] = s[n].join(\"\");\n    return e.lines = r, e.graphemeLines = s, e;\n  }\n  getMinWidth() {\n    return Math.max(this.minWidth, this.dynamicMinWidth);\n  }\n  _removeExtraneousStyles() {\n    const t = /* @__PURE__ */ new Map();\n    for (const e in this._styleMap) {\n      const s = parseInt(e, 10);\n      if (this._textLines[s]) {\n        const r = this._styleMap[e].line;\n        t.set(\"\".concat(r), !0);\n      }\n    }\n    for (const e in this.styles) t.has(e) || delete this.styles[e];\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return super.toObject([\"minWidth\", \"splitByGrapheme\", ...t]);\n  }\n}\ny(Le, \"type\", \"Textbox\"), y(Le, \"textLayoutProperties\", [...oe.textLayoutProperties, \"width\"]), y(Le, \"ownDefaults\", { minWidth: 20, dynamicMinWidth: 2, lockScalingFlip: !0, noScaleCache: !1, _wordJoiners: /[ \\t\\r]/, splitByGrapheme: !1 }), C.setClass(Le);\nclass Yo extends Ci {\n  shouldPerformLayout(t) {\n    return !!t.target.clipPath && super.shouldPerformLayout(t);\n  }\n  shouldLayoutClipPath() {\n    return !1;\n  }\n  calcLayoutResult(t, e) {\n    const { target: s } = t, { clipPath: r, group: n } = s;\n    if (!r || !this.shouldPerformLayout(t)) return;\n    const { width: o, height: a } = Gt(Fc(s, r)), c = new _(o, a);\n    if (r.absolutePositioned)\n      return { center: ae(r.getRelativeCenterPoint(), void 0, n ? n.calcTransformMatrix() : void 0), size: c };\n    {\n      const l = r.getRelativeCenterPoint().transform(s.calcOwnMatrix(), !0);\n      if (this.shouldPerformLayout(t)) {\n        const { center: h = new _(), correction: u = new _() } = this.calcBoundingBox(e, t) || {};\n        return { center: h.add(l), correction: u.subtract(l), size: c };\n      }\n      return { center: s.getRelativeCenterPoint().add(l), size: c };\n    }\n  }\n}\ny(Yo, \"type\", \"clip-path\"), C.setClass(Yo);\nclass Vo extends Ci {\n  getInitialSize(t, e) {\n    let { target: s } = t, { size: r } = e;\n    return new _(s.width || r.x, s.height || r.y);\n  }\n}\ny(Vo, \"type\", \"fixed\"), C.setClass(Vo);\nclass Ed extends Zs {\n  subscribeTargets(t) {\n    const e = t.target;\n    t.targets.reduce((s, r) => (r.parent && s.add(r.parent), s), /* @__PURE__ */ new Set()).forEach((s) => {\n      s.layoutManager.subscribeTargets({ target: s, targets: [e] });\n    });\n  }\n  unsubscribeTargets(t) {\n    const e = t.target, s = e.getObjects();\n    t.targets.reduce((r, n) => (n.parent && r.add(n.parent), r), /* @__PURE__ */ new Set()).forEach((r) => {\n      !s.some((n) => n.parent === r) && r.layoutManager.unsubscribeTargets({ target: r, targets: [e] });\n    });\n  }\n}\nclass Ot extends Nt {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), Ot.ownDefaults);\n  }\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    super(), Object.assign(this, Ot.ownDefaults), this.setOptions(e);\n    const { left: s, top: r, layoutManager: n } = e;\n    this.groupInit(t, { left: s, top: r, layoutManager: n ?? new Ed() });\n  }\n  _shouldSetNestedCoords() {\n    return !0;\n  }\n  __objectSelectionMonitor() {\n  }\n  multiSelectAdd() {\n    for (var t = arguments.length, e = new Array(t), s = 0; s < t; s++) e[s] = arguments[s];\n    this.multiSelectionStacking === \"selection-order\" ? this.add(...e) : e.forEach((r) => {\n      const n = this._objects.findIndex((a) => a.isInFrontOf(r)), o = n === -1 ? this.size() : n;\n      this.insertAt(o, r);\n    });\n  }\n  canEnterGroup(t) {\n    return this.getObjects().some((e) => e.isDescendantOf(t) || t.isDescendantOf(e)) ? (Te(\"error\", \"ActiveSelection: circular object trees are not supported, this call has no effect\"), !1) : super.canEnterGroup(t);\n  }\n  enterGroup(t, e) {\n    t.parent && t.parent === t.group ? t.parent._exitGroup(t) : t.group && t.parent !== t.group && t.group.remove(t), this._enterGroup(t, e);\n  }\n  exitGroup(t, e) {\n    this._exitGroup(t, e), t.parent && t.parent._enterGroup(t, !0);\n  }\n  _onAfterObjectsChange(t, e) {\n    super._onAfterObjectsChange(t, e);\n    const s = /* @__PURE__ */ new Set();\n    e.forEach((r) => {\n      const { parent: n } = r;\n      n && s.add(n);\n    }), t === Zn ? s.forEach((r) => {\n      r._onAfterObjectsChange(ei, e);\n    }) : s.forEach((r) => {\n      r._set(\"dirty\", !0);\n    });\n  }\n  onDeselect() {\n    return this.removeAll(), !1;\n  }\n  toString() {\n    return \"#<ActiveSelection: (\".concat(this.complexity(), \")>\");\n  }\n  shouldCache() {\n    return !1;\n  }\n  isOnACache() {\n    return !1;\n  }\n  _renderControls(t, e, s) {\n    t.save(), t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n    const r = v(v({ hasControls: !1 }, s), {}, { forActiveSelection: !0 });\n    for (let n = 0; n < this._objects.length; n++) this._objects[n]._renderControls(t, r);\n    super._renderControls(t, e), t.restore();\n  }\n}\ny(Ot, \"type\", \"ActiveSelection\"), y(Ot, \"ownDefaults\", { multiSelectionStacking: \"canvas-stacking\" }), C.setClass(Ot), C.setClass(Ot, \"activeSelection\");\nclass Pd {\n  constructor() {\n    y(this, \"resources\", {});\n  }\n  applyFilters(t, e, s, r, n) {\n    const o = n.getContext(\"2d\");\n    if (!o) return;\n    o.drawImage(e, 0, 0, s, r);\n    const a = { sourceWidth: s, sourceHeight: r, imageData: o.getImageData(0, 0, s, r), originalEl: e, originalImageData: o.getImageData(0, 0, s, r), canvasEl: n, ctx: o, filterBackend: this };\n    t.forEach((l) => {\n      l.applyTo(a);\n    });\n    const { imageData: c } = a;\n    return c.width === s && c.height === r || (n.width = c.width, n.height = c.height), o.putImageData(c, 0, 0), a;\n  }\n}\nclass ol {\n  constructor() {\n    let { tileSize: t = A.textureSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    y(this, \"aPosition\", new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])), y(this, \"resources\", {}), this.tileSize = t, this.setupGLContext(t, t), this.captureGPUInfo();\n  }\n  setupGLContext(t, e) {\n    this.dispose(), this.createWebGLCanvas(t, e);\n  }\n  createWebGLCanvas(t, e) {\n    const s = Wt({ width: t, height: e }), r = s.getContext(\"webgl\", { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 });\n    r && (r.clearColor(0, 0, 0, 0), this.canvas = s, this.gl = r);\n  }\n  applyFilters(t, e, s, r, n, o) {\n    const a = this.gl, c = n.getContext(\"2d\");\n    if (!a || !c) return;\n    let l;\n    o && (l = this.getCachedTexture(o, e));\n    const h = { originalWidth: e.width || e.naturalWidth || 0, originalHeight: e.height || e.naturalHeight || 0, sourceWidth: s, sourceHeight: r, destinationWidth: s, destinationHeight: r, context: a, sourceTexture: this.createTexture(a, s, r, l ? void 0 : e), targetTexture: this.createTexture(a, s, r), originalTexture: l || this.createTexture(a, s, r, l ? void 0 : e), passes: t.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: n }, u = a.createFramebuffer();\n    return a.bindFramebuffer(a.FRAMEBUFFER, u), t.forEach((d) => {\n      d && d.applyTo(h);\n    }), function(d) {\n      const f = d.targetCanvas, g = f.width, p = f.height, m = d.destinationWidth, b = d.destinationHeight;\n      g === m && p === b || (f.width = m, f.height = b);\n    }(h), this.copyGLTo2D(a, h), a.bindTexture(a.TEXTURE_2D, null), a.deleteTexture(h.sourceTexture), a.deleteTexture(h.targetTexture), a.deleteFramebuffer(u), c.setTransform(1, 0, 0, 1, 0, 0), h;\n  }\n  dispose() {\n    this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();\n  }\n  clearWebGLCaches() {\n    this.programCache = {}, this.textureCache = {};\n  }\n  createTexture(t, e, s, r, n) {\n    const { NEAREST: o, TEXTURE_2D: a, RGBA: c, UNSIGNED_BYTE: l, CLAMP_TO_EDGE: h, TEXTURE_MAG_FILTER: u, TEXTURE_MIN_FILTER: d, TEXTURE_WRAP_S: f, TEXTURE_WRAP_T: g } = t, p = t.createTexture();\n    return t.bindTexture(a, p), t.texParameteri(a, u, n || o), t.texParameteri(a, d, n || o), t.texParameteri(a, f, h), t.texParameteri(a, g, h), r ? t.texImage2D(a, 0, c, c, l, r) : t.texImage2D(a, 0, c, e, s, 0, c, l, null), p;\n  }\n  getCachedTexture(t, e, s) {\n    const { textureCache: r } = this;\n    if (r[t]) return r[t];\n    {\n      const n = this.createTexture(this.gl, e.width, e.height, e, s);\n      return n && (r[t] = n), n;\n    }\n  }\n  evictCachesForKey(t) {\n    this.textureCache[t] && (this.gl.deleteTexture(this.textureCache[t]), delete this.textureCache[t]);\n  }\n  copyGLTo2D(t, e) {\n    const s = t.canvas, r = e.targetCanvas, n = r.getContext(\"2d\");\n    if (!n) return;\n    n.translate(0, r.height), n.scale(1, -1);\n    const o = s.height - r.height;\n    n.drawImage(s, 0, o, r.width, r.height, 0, 0, r.width, r.height);\n  }\n  copyGLTo2DPutImageData(t, e) {\n    const s = e.targetCanvas.getContext(\"2d\"), r = e.destinationWidth, n = e.destinationHeight, o = r * n * 4;\n    if (!s) return;\n    const a = new Uint8Array(this.imageBuffer, 0, o), c = new Uint8ClampedArray(this.imageBuffer, 0, o);\n    t.readPixels(0, 0, r, n, t.RGBA, t.UNSIGNED_BYTE, a);\n    const l = new ImageData(c, r, n);\n    s.putImageData(l, 0, 0);\n  }\n  captureGPUInfo() {\n    if (this.gpuInfo) return this.gpuInfo;\n    const t = this.gl, e = { renderer: \"\", vendor: \"\" };\n    if (!t) return e;\n    const s = t.getExtension(\"WEBGL_debug_renderer_info\");\n    if (s) {\n      const r = t.getParameter(s.UNMASKED_RENDERER_WEBGL), n = t.getParameter(s.UNMASKED_VENDOR_WEBGL);\n      r && (e.renderer = r.toLowerCase()), n && (e.vendor = n.toLowerCase());\n    }\n    return this.gpuInfo = e, e;\n  }\n}\nlet Ui;\nfunction Ad() {\n  const { WebGLProbe: i } = $t();\n  return i.queryWebGL(kt()), A.enableGLFiltering && i.isSupported(A.textureSize) ? new ol({ tileSize: A.textureSize }) : new Pd();\n}\nfunction $i() {\n  return !Ui && (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0]) && (Ui = Ad()), Ui;\n}\nconst Fd = [\"filters\", \"resizeFilter\", \"src\", \"crossOrigin\", \"type\"], al = [\"cropX\", \"cropY\"];\nclass wt extends nt {\n  static getDefaults() {\n    return v(v({}, super.getDefaults()), wt.ownDefaults);\n  }\n  constructor(t, e) {\n    super(), y(this, \"_lastScaleX\", 1), y(this, \"_lastScaleY\", 1), y(this, \"_filterScalingX\", 1), y(this, \"_filterScalingY\", 1), this.filters = [], Object.assign(this, wt.ownDefaults), this.setOptions(e), this.cacheKey = \"texture\".concat(we()), this.setElement(typeof t == \"string\" ? (this.canvas && At(this.canvas.getElement()) || Cs()).getElementById(t) : t, e);\n  }\n  getElement() {\n    return this._element;\n  }\n  setElement(t) {\n    var e;\n    let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    this.removeTexture(this.cacheKey), this.removeTexture(\"\".concat(this.cacheKey, \"_filtered\")), this._element = t, this._originalElement = t, this._setWidthHeight(s), (e = t.classList) === null || e === void 0 || e.add(wt.CSS_CANVAS), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();\n  }\n  removeTexture(t) {\n    const e = $i(!1);\n    e instanceof ol && e.evictCachesForKey(t);\n  }\n  dispose() {\n    super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture(\"\".concat(this.cacheKey, \"_filtered\")), this._cacheContext = null, [\"_originalElement\", \"_element\", \"_filteredEl\", \"_cacheCanvas\"].forEach((t) => {\n      const e = this[t];\n      e && $t().dispose(e), this[t] = void 0;\n    });\n  }\n  getCrossOrigin() {\n    return this._originalElement && (this._originalElement.crossOrigin || null);\n  }\n  getOriginalSize() {\n    const t = this.getElement();\n    return t ? { width: t.naturalWidth || t.width, height: t.naturalHeight || t.height } : { width: 0, height: 0 };\n  }\n  _stroke(t) {\n    if (!this.stroke || this.strokeWidth === 0) return;\n    const e = this.width / 2, s = this.height / 2;\n    t.beginPath(), t.moveTo(-e, -s), t.lineTo(e, -s), t.lineTo(e, s), t.lineTo(-e, s), t.lineTo(-e, -s), t.closePath();\n  }\n  toObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    const e = [];\n    return this.filters.forEach((s) => {\n      s && e.push(s.toObject());\n    }), v(v({}, super.toObject([...al, ...t])), {}, { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: e }, this.resizeFilter ? { resizeFilter: this.resizeFilter.toObject() } : {});\n  }\n  hasCrop() {\n    return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;\n  }\n  _toSVG() {\n    const t = [], e = this._element, s = -this.width / 2, r = -this.height / 2;\n    let n = [], o = [], a = \"\", c = \"\";\n    if (!e) return [];\n    if (this.hasCrop()) {\n      const l = we();\n      n.push('<clipPath id=\"imageCrop_' + l + `\">\n`, '\t<rect x=\"' + s + '\" y=\"' + r + '\" width=\"' + this.width + '\" height=\"' + this.height + `\" />\n`, `</clipPath>\n`), a = ' clip-path=\"url(#imageCrop_' + l + ')\" ';\n    }\n    if (this.imageSmoothing || (c = ' image-rendering=\"optimizeSpeed\"'), t.push(\"\t<image \", \"COMMON_PARTS\", 'xlink:href=\"'.concat(this.getSvgSrc(!0), '\" x=\"').concat(s - this.cropX, '\" y=\"').concat(r - this.cropY, '\" width=\"').concat(e.width || e.naturalWidth, '\" height=\"').concat(e.height || e.naturalHeight, '\"').concat(c).concat(a, `></image>\n`)), this.stroke || this.strokeDashArray) {\n      const l = this.fill;\n      this.fill = null, o = ['\t<rect x=\"'.concat(s, '\" y=\"').concat(r, '\" width=\"').concat(this.width, '\" height=\"').concat(this.height, '\" style=\"').concat(this.getSvgStyles(), `\" />\n`)], this.fill = l;\n    }\n    return n = this.paintFirst !== rt ? n.concat(o, t) : n.concat(t, o), n;\n  }\n  getSrc(t) {\n    const e = t ? this._element : this._originalElement;\n    return e ? e.toDataURL ? e.toDataURL() : this.srcFromAttribute ? e.getAttribute(\"src\") || \"\" : e.src : this.src || \"\";\n  }\n  getSvgSrc(t) {\n    return this.getSrc(t);\n  }\n  setSrc(t) {\n    let { crossOrigin: e, signal: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return Ys(t, { crossOrigin: e, signal: s }).then((r) => {\n      e !== void 0 && this.set({ crossOrigin: e }), this.setElement(r);\n    });\n  }\n  toString() {\n    return '#<Image: { src: \"'.concat(this.getSrc(), '\" }>');\n  }\n  applyResizeFilters() {\n    const t = this.resizeFilter, e = this.minimumScaleTrigger, s = this.getTotalObjectScaling(), r = s.x, n = s.y, o = this._filteredEl || this._originalElement;\n    if (this.group && this.set(\"dirty\", !0), !t || r > e && n > e) return this._element = o, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = r, void (this._lastScaleY = n);\n    const a = Wt(o), { width: c, height: l } = o;\n    this._element = a, this._lastScaleX = t.scaleX = r, this._lastScaleY = t.scaleY = n, $i().applyFilters([t], o, c, l, this._element), this._filterScalingX = a.width / this._originalElement.width, this._filterScalingY = a.height / this._originalElement.height;\n  }\n  applyFilters() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.filters || [];\n    if (t = t.filter((n) => n && !n.isNeutralState()), this.set(\"dirty\", !0), this.removeTexture(\"\".concat(this.cacheKey, \"_filtered\")), t.length === 0) return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);\n    const e = this._originalElement, s = e.naturalWidth || e.width, r = e.naturalHeight || e.height;\n    if (this._element === this._originalElement) {\n      const n = Wt({ width: s, height: r });\n      this._element = n, this._filteredEl = n;\n    } else this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext(\"2d\").clearRect(0, 0, s, r), this._lastScaleX = 1, this._lastScaleY = 1);\n    $i().applyFilters(t, this._originalElement, s, r, this._element, this.cacheKey), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);\n  }\n  _render(t) {\n    t.imageSmoothingEnabled = this.imageSmoothing, this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(t), this._renderPaintInOrder(t);\n  }\n  drawCacheOnCanvas(t) {\n    t.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(t);\n  }\n  shouldCache() {\n    return this.needsItsOwnCache();\n  }\n  _renderFill(t) {\n    const e = this._element;\n    if (!e) return;\n    const s = this._filterScalingX, r = this._filterScalingY, n = this.width, o = this.height, a = Math.max(this.cropX, 0), c = Math.max(this.cropY, 0), l = e.naturalWidth || e.width, h = e.naturalHeight || e.height, u = a * s, d = c * r, f = Math.min(n * s, l - u), g = Math.min(o * r, h - d), p = -n / 2, m = -o / 2, b = Math.min(n, l / s - a), S = Math.min(o, h / r - c);\n    e && t.drawImage(e, u, d, f, g, p, m, b, S);\n  }\n  _needsResize() {\n    const t = this.getTotalObjectScaling();\n    return t.x !== this._lastScaleX || t.y !== this._lastScaleY;\n  }\n  _resetWidthHeight() {\n    this.set(this.getOriginalSize());\n  }\n  _setWidthHeight() {\n    let { width: t, height: e } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const s = this.getOriginalSize();\n    this.width = t || s.width, this.height = e || s.height;\n  }\n  parsePreserveAspectRatioAttribute() {\n    const t = qa(this.preserveAspectRatio || \"\"), e = this.width, s = this.height, r = { width: e, height: s };\n    let n, o = this._element.width, a = this._element.height, c = 1, l = 1, h = 0, u = 0, d = 0, f = 0;\n    return !t || t.alignX === pt && t.alignY === pt ? (c = e / o, l = s / a) : (t.meetOrSlice === \"meet\" && (c = l = Lc(this._element, r), n = (e - o * c) / 2, t.alignX === \"Min\" && (h = -n), t.alignX === \"Max\" && (h = n), n = (s - a * l) / 2, t.alignY === \"Min\" && (u = -n), t.alignY === \"Max\" && (u = n)), t.meetOrSlice === \"slice\" && (c = l = Bc(this._element, r), n = o - e / c, t.alignX === \"Mid\" && (d = n / 2), t.alignX === \"Max\" && (d = n), n = a - s / l, t.alignY === \"Mid\" && (f = n / 2), t.alignY === \"Max\" && (f = n), o = e / c, a = s / l)), { width: o, height: a, scaleX: c, scaleY: l, offsetLeft: h, offsetTop: u, cropX: d, cropY: f };\n  }\n  static fromObject(t, e) {\n    let { filters: s, resizeFilter: r, src: n, crossOrigin: o, type: a } = t, c = G(t, Fd);\n    return Promise.all([Ys(n, v(v({}, e), {}, { crossOrigin: o })), s && bs(s, e), r && bs([r], e), cr(c, e)]).then((l) => {\n      let [h, u = [], [d] = [], f = {}] = l;\n      return new this(h, v(v({}, c), {}, { src: n, filters: u, resizeFilter: d }, f));\n    });\n  }\n  static fromURL(t) {\n    let { crossOrigin: e = null, signal: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0;\n    return Ys(t, { crossOrigin: e, signal: s }).then((n) => new this(n, r));\n  }\n  static async fromElement(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = arguments.length > 2 ? arguments[2] : void 0;\n    const r = fe(t, this.ATTRIBUTE_NAMES, s);\n    return this.fromURL(r[\"xlink:href\"], e, r).catch((n) => (Te(\"log\", \"Unable to parse Image\", n), null));\n  }\n}\ny(wt, \"type\", \"Image\"), y(wt, \"cacheProperties\", [...de, ...al]), y(wt, \"ownDefaults\", { strokeWidth: 0, srcFromAttribute: !1, minimumScaleTrigger: 0.5, cropX: 0, cropY: 0, imageSmoothing: !0 }), y(wt, \"CSS_CANVAS\", \"canvas-img\"), y(wt, \"ATTRIBUTE_NAMES\", [...De, \"x\", \"y\", \"width\", \"height\", \"preserveAspectRatio\", \"xlink:href\", \"crossOrigin\", \"image-rendering\"]), C.setClass(wt), C.setSVGClass(wt);\n_i([\"pattern\", \"defs\", \"symbol\", \"metadata\", \"clipPath\", \"mask\", \"desc\"]);\nconst cl = Xa, Go = (i) => function(t, e, s) {\n  const { points: r, pathOffset: n } = s;\n  return new _(r[i]).subtract(n).transform(J(s.getViewportTransform(), s.calcTransformMatrix()));\n}, ll = (i, t, e, s) => {\n  const { target: r, pointIndex: n } = t, o = r, a = ae(new _(e, s), void 0, o.calcOwnMatrix());\n  return o.points[n] = a.add(o.pathOffset), o.setDimensions(), !0;\n}, hl = (i, t) => function(e, s, r, n) {\n  const o = s.target, a = new _(o.points[(i > 0 ? i : o.points.length) - 1]), c = a.subtract(o.pathOffset).transform(o.calcOwnMatrix()), l = t(e, v(v({}, s), {}, { pointIndex: i }), r, n), h = a.subtract(o.pathOffset).transform(o.calcOwnMatrix()).subtract(c);\n  return o.left -= h.x, o.top -= h.y, l;\n}, No = (i) => Ie(cl, hl(i, ll)), bn = (i, t, e) => {\n  const { path: s, pathOffset: r } = i, n = s[t];\n  return new _(n[e] - r.x, n[e + 1] - r.y).transform(J(i.getViewportTransform(), i.calcTransformMatrix()));\n};\nfunction Rd(i, t, e) {\n  const { commandIndex: s, pointIndex: r } = this;\n  return bn(e, s, r);\n}\nfunction Ld(i, t, e, s) {\n  const { target: r } = t, { commandIndex: n, pointIndex: o } = this, a = ((c, l, h, u, d) => {\n    const { path: f, pathOffset: g } = c, p = f[(u > 0 ? u : f.length) - 1], m = new _(p[d], p[d + 1]), b = m.subtract(g).transform(c.calcOwnMatrix()), S = ae(new _(l, h), void 0, c.calcOwnMatrix());\n    f[u][d] = S.x + g.x, f[u][d + 1] = S.y + g.y, c.setDimensions();\n    const w = m.subtract(c.pathOffset).transform(c.calcOwnMatrix()).subtract(b);\n    return c.left -= w.x, c.top -= w.y, c.set(\"dirty\", !0), !0;\n  })(r, e, s, n, o);\n  return Hn(this.actionName, v(v({}, Yn(i, t, e, s)), {}, { commandIndex: n, pointIndex: o })), a;\n}\nclass ul extends U {\n  constructor(t) {\n    super(t);\n  }\n  render(t, e, s, r, n) {\n    const o = v(v({}, r), {}, { cornerColor: this.controlFill, cornerStrokeColor: this.controlStroke, transparentCorners: !this.controlFill });\n    super.render(t, e, s, o, n);\n  }\n}\nclass Bd extends ul {\n  constructor(t) {\n    super(t);\n  }\n  render(t, e, s, r, n) {\n    const { path: o } = n, { commandIndex: a, pointIndex: c, connectToCommandIndex: l, connectToPointIndex: h } = this;\n    t.save(), t.strokeStyle = this.controlStroke, this.connectionDashArray && t.setLineDash(this.connectionDashArray);\n    const [u] = o[a], d = bn(n, l, h);\n    if (u === \"Q\") {\n      const f = bn(n, a, c + 2);\n      t.moveTo(f.x, f.y), t.lineTo(e, s);\n    } else t.moveTo(e, s);\n    t.lineTo(d.x, d.y), t.stroke(), t.restore(), super.render(t, e, s, r, n);\n  }\n}\nconst Cr = (i, t, e, s, r, n) => new (e ? Bd : ul)(v(v({ commandIndex: i, pointIndex: t, actionName: \"modifyPath\", positionHandler: Rd, actionHandler: Ld, connectToCommandIndex: r, connectToPointIndex: n }, s), e ? s.controlPointStyle : s.pointStyle));\nvar Ds = Object.freeze({ __proto__: null, changeWidth: hn, createObjectDefaultControls: qn, createPathControls: function(i) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const e = {};\n  let s = \"M\";\n  return i.path.forEach((r, n) => {\n    const o = r[0];\n    switch (o !== \"Z\" && (e[\"c_\".concat(n, \"_\").concat(o)] = Cr(n, r.length - 2, !1, t)), o) {\n      case \"C\":\n        e[\"c_\".concat(n, \"_C_CP_1\")] = Cr(n, 1, !0, t, n - 1, /* @__PURE__ */ ((a) => a === \"C\" ? 5 : a === \"Q\" ? 3 : 1)(s)), e[\"c_\".concat(n, \"_C_CP_2\")] = Cr(n, 3, !0, t, n, 5);\n        break;\n      case \"Q\":\n        e[\"c_\".concat(n, \"_Q_CP_1\")] = Cr(n, 1, !0, t, n, 3);\n    }\n    s = o;\n  }), e;\n}, createPolyActionHandler: No, createPolyControls: function(i) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const e = {};\n  for (let s = 0; s < (typeof i == \"number\" ? i : i.points.length); s++) e[\"p\".concat(s)] = new U(v({ actionName: cl, positionHandler: Go(s), actionHandler: No(s) }, t));\n  return e;\n}, createPolyPositionHandler: Go, createResizeControls: Cc, createTextboxDefaultControls: Oc, dragHandler: oc, factoryPolyActionHandler: hl, getLocalPoint: bi, polyActionHandler: ll, renderCircleControl: fc, renderSquareControl: gc, rotationStyleHandler: pc, rotationWithSnapping: mc, scaleCursorStyleHandler: Ze, scaleOrSkewActionName: Bs, scaleSkewCursorStyleHandler: Fe, scalingEqually: Ls, scalingX: bc, scalingXOrSkewingY: un, scalingY: _c, scalingYOrSkewingX: dn, skewCursorStyleHandler: Sc, skewHandlerX: xc, skewHandlerY: wc, wrapWithFireEvent: Ie, wrapWithFixedAnchor: Ge });\nconst ki = (i) => i.webgl !== void 0, to = \"precision highp float\", Wd = `\n    `.concat(to, `;\n    varying vec2 vTexCoord;\n    uniform sampler2D uTexture;\n    void main() {\n      gl_FragColor = texture2D(uTexture, vTexCoord);\n    }`), Xd = [\"type\"], zd = [\"type\"], Hd = new RegExp(to, \"g\");\nclass it {\n  get type() {\n    return this.constructor.type;\n  }\n  constructor() {\n    let t = G(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, Xd);\n    Object.assign(this, this.constructor.defaults, t);\n  }\n  getFragmentSource() {\n    return Wd;\n  }\n  getVertexSource() {\n    return `\n    attribute vec2 aPosition;\n    varying vec2 vTexCoord;\n    void main() {\n      vTexCoord = aPosition;\n      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n    }`;\n  }\n  createProgram(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getFragmentSource(), s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getVertexSource();\n    const { WebGLProbe: { GLPrecision: r = \"highp\" } } = $t();\n    r !== \"highp\" && (e = e.replace(Hd, to.replace(\"highp\", r)));\n    const n = t.createShader(t.VERTEX_SHADER), o = t.createShader(t.FRAGMENT_SHADER), a = t.createProgram();\n    if (!n || !o || !a) throw new Yt(\"Vertex, fragment shader or program creation error\");\n    if (t.shaderSource(n, s), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS)) throw new Yt(\"Vertex shader compile error for \".concat(this.type, \": \").concat(t.getShaderInfoLog(n)));\n    if (t.shaderSource(o, e), t.compileShader(o), !t.getShaderParameter(o, t.COMPILE_STATUS)) throw new Yt(\"Fragment shader compile error for \".concat(this.type, \": \").concat(t.getShaderInfoLog(o)));\n    if (t.attachShader(a, n), t.attachShader(a, o), t.linkProgram(a), !t.getProgramParameter(a, t.LINK_STATUS)) throw new Yt('Shader link error for \"'.concat(this.type, '\" ').concat(t.getProgramInfoLog(a)));\n    const c = this.getUniformLocations(t, a) || {};\n    return c.uStepW = t.getUniformLocation(a, \"uStepW\"), c.uStepH = t.getUniformLocation(a, \"uStepH\"), { program: a, attributeLocations: this.getAttributeLocations(t, a), uniformLocations: c };\n  }\n  getAttributeLocations(t, e) {\n    return { aPosition: t.getAttribLocation(e, \"aPosition\") };\n  }\n  getUniformLocations(t, e) {\n    const s = this.constructor.uniformLocations, r = {};\n    for (let n = 0; n < s.length; n++) r[s[n]] = t.getUniformLocation(e, s[n]);\n    return r;\n  }\n  sendAttributeData(t, e, s) {\n    const r = e.aPosition, n = t.createBuffer();\n    t.bindBuffer(t.ARRAY_BUFFER, n), t.enableVertexAttribArray(r), t.vertexAttribPointer(r, 2, t.FLOAT, !1, 0, 0), t.bufferData(t.ARRAY_BUFFER, s, t.STATIC_DRAW);\n  }\n  _setupFrameBuffer(t) {\n    const e = t.context;\n    if (t.passes > 1) {\n      const s = t.destinationWidth, r = t.destinationHeight;\n      t.sourceWidth === s && t.sourceHeight === r || (e.deleteTexture(t.targetTexture), t.targetTexture = t.filterBackend.createTexture(e, s, r)), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t.targetTexture, 0);\n    } else e.bindFramebuffer(e.FRAMEBUFFER, null), e.finish();\n  }\n  _swapTextures(t) {\n    t.passes--, t.pass++;\n    const e = t.targetTexture;\n    t.targetTexture = t.sourceTexture, t.sourceTexture = e;\n  }\n  isNeutralState(t) {\n    return !1;\n  }\n  applyTo(t) {\n    ki(t) ? (this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t);\n  }\n  applyTo2d(t) {\n  }\n  getCacheKey() {\n    return this.type;\n  }\n  retrieveShader(t) {\n    const e = this.getCacheKey();\n    return t.programCache[e] || (t.programCache[e] = this.createProgram(t.context)), t.programCache[e];\n  }\n  applyToWebGL(t) {\n    const e = t.context, s = this.retrieveShader(t);\n    t.pass === 0 && t.originalTexture ? e.bindTexture(e.TEXTURE_2D, t.originalTexture) : e.bindTexture(e.TEXTURE_2D, t.sourceTexture), e.useProgram(s.program), this.sendAttributeData(e, s.attributeLocations, t.aPosition), e.uniform1f(s.uniformLocations.uStepW, 1 / t.sourceWidth), e.uniform1f(s.uniformLocations.uStepH, 1 / t.sourceHeight), this.sendUniformData(e, s.uniformLocations), e.viewport(0, 0, t.destinationWidth, t.destinationHeight), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);\n  }\n  bindAdditionalTexture(t, e, s) {\n    t.activeTexture(s), t.bindTexture(t.TEXTURE_2D, e), t.activeTexture(t.TEXTURE0);\n  }\n  unbindAdditionalTexture(t, e) {\n    t.activeTexture(e), t.bindTexture(t.TEXTURE_2D, null), t.activeTexture(t.TEXTURE0);\n  }\n  sendUniformData(t, e) {\n  }\n  createHelpLayer(t) {\n    if (!t.helpLayer) {\n      const { sourceWidth: e, sourceHeight: s } = t, r = Wt({ width: e, height: s });\n      t.helpLayer = r;\n    }\n  }\n  toObject() {\n    const t = Object.keys(this.constructor.defaults || {});\n    return v({ type: this.type }, t.reduce((e, s) => (e[s] = this[s], e), {}));\n  }\n  toJSON() {\n    return this.toObject();\n  }\n  static async fromObject(t, e) {\n    return new this(G(t, zd));\n  }\n}\ny(it, \"type\", \"BaseFilter\"), y(it, \"uniformLocations\", []);\nconst Yd = { multiply: `gl_FragColor.rgb *= uColor.rgb;\n`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n`, add: `gl_FragColor.rgb += uColor.rgb;\n`, difference: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n`, subtract: `gl_FragColor.rgb -= uColor.rgb;\n`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n`, overlay: `\n    if (uColor.r < 0.5) {\n      gl_FragColor.r *= 2.0 * uColor.r;\n    } else {\n      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n    }\n    if (uColor.g < 0.5) {\n      gl_FragColor.g *= 2.0 * uColor.g;\n    } else {\n      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n    }\n    if (uColor.b < 0.5) {\n      gl_FragColor.b *= 2.0 * uColor.b;\n    } else {\n      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n    }\n    `, tint: `\n    gl_FragColor.rgb *= (1.0 - uColor.a);\n    gl_FragColor.rgb += uColor.rgb;\n    ` };\nclass Or extends it {\n  getCacheKey() {\n    return \"\".concat(this.type, \"_\").concat(this.mode);\n  }\n  getFragmentSource() {\n    return `\n      precision highp float;\n      uniform sampler2D uTexture;\n      uniform vec4 uColor;\n      varying vec2 vTexCoord;\n      void main() {\n        vec4 color = texture2D(uTexture, vTexCoord);\n        gl_FragColor = color;\n        if (color.a > 0.0) {\n          `.concat(Yd[this.mode], `\n        }\n      }\n      `);\n  }\n  applyTo2d(t) {\n    let { imageData: { data: e } } = t;\n    const s = new W(this.color).getSource(), r = this.alpha, n = s[0] * r, o = s[1] * r, a = s[2] * r, c = 1 - r;\n    for (let l = 0; l < e.length; l += 4) {\n      const h = e[l], u = e[l + 1], d = e[l + 2];\n      let f, g, p;\n      switch (this.mode) {\n        case \"multiply\":\n          f = h * n / 255, g = u * o / 255, p = d * a / 255;\n          break;\n        case \"screen\":\n          f = 255 - (255 - h) * (255 - n) / 255, g = 255 - (255 - u) * (255 - o) / 255, p = 255 - (255 - d) * (255 - a) / 255;\n          break;\n        case \"add\":\n          f = h + n, g = u + o, p = d + a;\n          break;\n        case \"difference\":\n          f = Math.abs(h - n), g = Math.abs(u - o), p = Math.abs(d - a);\n          break;\n        case \"subtract\":\n          f = h - n, g = u - o, p = d - a;\n          break;\n        case \"darken\":\n          f = Math.min(h, n), g = Math.min(u, o), p = Math.min(d, a);\n          break;\n        case \"lighten\":\n          f = Math.max(h, n), g = Math.max(u, o), p = Math.max(d, a);\n          break;\n        case \"overlay\":\n          f = n < 128 ? 2 * h * n / 255 : 255 - 2 * (255 - h) * (255 - n) / 255, g = o < 128 ? 2 * u * o / 255 : 255 - 2 * (255 - u) * (255 - o) / 255, p = a < 128 ? 2 * d * a / 255 : 255 - 2 * (255 - d) * (255 - a) / 255;\n          break;\n        case \"exclusion\":\n          f = n + h - 2 * n * h / 255, g = o + u - 2 * o * u / 255, p = a + d - 2 * a * d / 255;\n          break;\n        case \"tint\":\n          f = n + h * c, g = o + u * c, p = a + d * c;\n      }\n      e[l] = f, e[l + 1] = g, e[l + 2] = p;\n    }\n  }\n  sendUniformData(t, e) {\n    const s = new W(this.color).getSource();\n    s[0] = this.alpha * s[0] / 255, s[1] = this.alpha * s[1] / 255, s[2] = this.alpha * s[2] / 255, s[3] = this.alpha, t.uniform4fv(e.uColor, s);\n  }\n}\ny(Or, \"defaults\", { color: \"#F95C63\", mode: \"multiply\", alpha: 1 }), y(Or, \"type\", \"BlendColor\"), y(Or, \"uniformLocations\", [\"uColor\"]), C.setClass(Or);\nconst Vd = { multiply: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform sampler2D uImage;\n    uniform vec4 uColor;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      vec4 color2 = texture2D(uImage, vTexCoord2);\n      color.rgba *= color2.rgba;\n      gl_FragColor = color;\n    }\n    `, mask: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform sampler2D uImage;\n    uniform vec4 uColor;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      vec4 color2 = texture2D(uImage, vTexCoord2);\n      color.a = color2.a;\n      gl_FragColor = color;\n    }\n    ` }, Gd = [\"type\", \"image\"];\nclass kr extends it {\n  getCacheKey() {\n    return \"\".concat(this.type, \"_\").concat(this.mode);\n  }\n  getFragmentSource() {\n    return Vd[this.mode];\n  }\n  getVertexSource() {\n    return `\n    attribute vec2 aPosition;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    uniform mat3 uTransformMatrix;\n    void main() {\n      vTexCoord = aPosition;\n      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n    }\n    `;\n  }\n  applyToWebGL(t) {\n    const e = t.context, s = this.createTexture(t.filterBackend, this.image);\n    this.bindAdditionalTexture(e, s, e.TEXTURE1), super.applyToWebGL(t), this.unbindAdditionalTexture(e, e.TEXTURE1);\n  }\n  createTexture(t, e) {\n    return t.getCachedTexture(e.cacheKey, e.getElement());\n  }\n  calculateMatrix() {\n    const t = this.image, { width: e, height: s } = t.getElement();\n    return [1 / t.scaleX, 0, 0, 0, 1 / t.scaleY, 0, -t.left / e, -t.top / s, 1];\n  }\n  applyTo2d(t) {\n    let { imageData: { data: e, width: s, height: r }, filterBackend: { resources: n } } = t;\n    const o = this.image;\n    n.blendImage || (n.blendImage = kt());\n    const a = n.blendImage, c = a.getContext(\"2d\");\n    a.width !== s || a.height !== r ? (a.width = s, a.height = r) : c.clearRect(0, 0, s, r), c.setTransform(o.scaleX, 0, 0, o.scaleY, o.left, o.top), c.drawImage(o.getElement(), 0, 0, s, r);\n    const l = c.getImageData(0, 0, s, r).data;\n    for (let h = 0; h < e.length; h += 4) {\n      const u = e[h], d = e[h + 1], f = e[h + 2], g = e[h + 3], p = l[h], m = l[h + 1], b = l[h + 2], S = l[h + 3];\n      switch (this.mode) {\n        case \"multiply\":\n          e[h] = u * p / 255, e[h + 1] = d * m / 255, e[h + 2] = f * b / 255, e[h + 3] = g * S / 255;\n          break;\n        case \"mask\":\n          e[h + 3] = S;\n      }\n    }\n  }\n  sendUniformData(t, e) {\n    const s = this.calculateMatrix();\n    t.uniform1i(e.uImage, 1), t.uniformMatrix3fv(e.uTransformMatrix, !1, s);\n  }\n  toObject() {\n    return v(v({}, super.toObject()), {}, { image: this.image && this.image.toObject() });\n  }\n  static async fromObject(t, e) {\n    let { type: s, image: r } = t, n = G(t, Gd);\n    return wt.fromObject(r, e).then((o) => new this(v(v({}, n), {}, { image: o })));\n  }\n}\ny(kr, \"type\", \"BlendImage\"), y(kr, \"defaults\", { mode: \"multiply\", alpha: 1 }), y(kr, \"uniformLocations\", [\"uTransformMatrix\", \"uImage\"]), C.setClass(kr);\nclass Mr extends it {\n  getFragmentSource() {\n    return `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform vec2 uDelta;\n    varying vec2 vTexCoord;\n    const float nSamples = 15.0;\n    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n    float random(vec3 scale) {\n      /* use the fragment position for a different seed per-pixel */\n      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n    }\n    void main() {\n      vec4 color = vec4(0.0);\n      float total = 0.0;\n      float offset = random(v3offset);\n      for (float t = -nSamples; t <= nSamples; t++) {\n        float percent = (t + offset - 0.5) / nSamples;\n        float weight = 1.0 - abs(percent);\n        color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n        total += weight;\n      }\n      gl_FragColor = color / total;\n    }\n  `;\n  }\n  applyTo(t) {\n    ki(t) ? (this.aspectRatio = t.sourceWidth / t.sourceHeight, t.passes++, this._setupFrameBuffer(t), this.horizontal = !0, this.applyToWebGL(t), this._swapTextures(t), this._setupFrameBuffer(t), this.horizontal = !1, this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t);\n  }\n  applyTo2d(t) {\n    t.imageData = this.simpleBlur(t);\n  }\n  simpleBlur(t) {\n    let { ctx: e, imageData: s, filterBackend: { resources: r } } = t;\n    const { width: n, height: o } = s;\n    r.blurLayer1 || (r.blurLayer1 = kt(), r.blurLayer2 = kt());\n    const a = r.blurLayer1, c = r.blurLayer2;\n    a.width === n && a.height === o || (c.width = a.width = n, c.height = a.height = o);\n    const l = a.getContext(\"2d\"), h = c.getContext(\"2d\"), u = 15, d = 0.06 * this.blur * 0.5;\n    let f, g, p, m;\n    for (l.putImageData(s, 0, 0), h.clearRect(0, 0, n, o), m = -15; m <= u; m++) f = (Math.random() - 0.5) / 4, g = m / u, p = d * g * n + f, h.globalAlpha = 1 - Math.abs(g), h.drawImage(a, p, f), l.drawImage(c, 0, 0), h.globalAlpha = 1, h.clearRect(0, 0, c.width, c.height);\n    for (m = -15; m <= u; m++) f = (Math.random() - 0.5) / 4, g = m / u, p = d * g * o + f, h.globalAlpha = 1 - Math.abs(g), h.drawImage(a, f, p), l.drawImage(c, 0, 0), h.globalAlpha = 1, h.clearRect(0, 0, c.width, c.height);\n    e.drawImage(a, 0, 0);\n    const b = e.getImageData(0, 0, a.width, a.height);\n    return l.globalAlpha = 1, l.clearRect(0, 0, a.width, a.height), b;\n  }\n  sendUniformData(t, e) {\n    const s = this.chooseRightDelta();\n    t.uniform2fv(e.uDelta, s);\n  }\n  isNeutralState() {\n    return this.blur === 0;\n  }\n  chooseRightDelta() {\n    let t = 1;\n    const e = [0, 0];\n    this.horizontal ? this.aspectRatio > 1 && (t = 1 / this.aspectRatio) : this.aspectRatio < 1 && (t = this.aspectRatio);\n    const s = t * this.blur * 0.12;\n    return this.horizontal ? e[0] = s : e[1] = s, e;\n  }\n}\ny(Mr, \"type\", \"Blur\"), y(Mr, \"defaults\", { blur: 0 }), y(Mr, \"uniformLocations\", [\"uDelta\"]), C.setClass(Mr);\nclass Ir extends it {\n  getFragmentSource() {\n    return `\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uBrightness;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color.rgb += uBrightness;\n    gl_FragColor = color;\n  }\n`;\n  }\n  applyTo2d(t) {\n    let { imageData: { data: e } } = t;\n    const s = Math.round(255 * this.brightness);\n    for (let r = 0; r < e.length; r += 4) e[r] += s, e[r + 1] += s, e[r + 2] += s;\n  }\n  isNeutralState() {\n    return this.brightness === 0;\n  }\n  sendUniformData(t, e) {\n    t.uniform1f(e.uBrightness, this.brightness);\n  }\n}\ny(Ir, \"type\", \"Brightness\"), y(Ir, \"defaults\", { brightness: 0 }), y(Ir, \"uniformLocations\", [\"uBrightness\"]), C.setClass(Ir);\nconst dl = { matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], colorsOnly: !0 };\nclass ts extends it {\n  getFragmentSource() {\n    return `\n  precision highp float;\n  uniform sampler2D uTexture;\n  varying vec2 vTexCoord;\n  uniform mat4 uColorMatrix;\n  uniform vec4 uConstants;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color *= uColorMatrix;\n    color += uConstants;\n    gl_FragColor = color;\n  }`;\n  }\n  applyTo2d(t) {\n    const e = t.imageData.data, s = this.matrix, r = this.colorsOnly;\n    for (let n = 0; n < e.length; n += 4) {\n      const o = e[n], a = e[n + 1], c = e[n + 2];\n      if (e[n] = o * s[0] + a * s[1] + c * s[2] + 255 * s[4], e[n + 1] = o * s[5] + a * s[6] + c * s[7] + 255 * s[9], e[n + 2] = o * s[10] + a * s[11] + c * s[12] + 255 * s[14], !r) {\n        const l = e[n + 3];\n        e[n] += l * s[3], e[n + 1] += l * s[8], e[n + 2] += l * s[13], e[n + 3] = o * s[15] + a * s[16] + c * s[17] + l * s[18] + 255 * s[19];\n      }\n    }\n  }\n  sendUniformData(t, e) {\n    const s = this.matrix, r = [s[0], s[1], s[2], s[3], s[5], s[6], s[7], s[8], s[10], s[11], s[12], s[13], s[15], s[16], s[17], s[18]], n = [s[4], s[9], s[14], s[19]];\n    t.uniformMatrix4fv(e.uColorMatrix, !1, r), t.uniform4fv(e.uConstants, n);\n  }\n  toObject() {\n    return v(v({}, super.toObject()), {}, { matrix: [...this.matrix] });\n  }\n}\nfunction Ne(i, t) {\n  var e;\n  const s = (y(e = class extends ts {\n    toObject() {\n      return { type: this.type, colorsOnly: this.colorsOnly };\n    }\n  }, \"type\", i), y(e, \"defaults\", { colorsOnly: !1, matrix: t }), e);\n  return C.setClass(s, i), s;\n}\ny(ts, \"type\", \"ColorMatrix\"), y(ts, \"defaults\", dl), y(ts, \"uniformLocations\", [\"uColorMatrix\", \"uConstants\"]), C.setClass(ts);\nNe(\"Brownie\", [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0]);\nNe(\"Vintage\", [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0]);\nNe(\"Kodachrome\", [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0]);\nNe(\"Technicolor\", [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0]);\nNe(\"Polaroid\", [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);\nNe(\"Sepia\", [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0]);\nNe(\"BlackWhite\", [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]);\nclass Uo extends it {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    super(t), this.subFilters = t.subFilters || [];\n  }\n  applyTo(t) {\n    ki(t) && (t.passes += this.subFilters.length - 1), this.subFilters.forEach((e) => {\n      e.applyTo(t);\n    });\n  }\n  toObject() {\n    return { type: this.type, subFilters: this.subFilters.map((t) => t.toObject()) };\n  }\n  isNeutralState() {\n    return !this.subFilters.some((t) => !t.isNeutralState());\n  }\n  static fromObject(t, e) {\n    return Promise.all((t.subFilters || []).map((s) => C.getClass(s.type).fromObject(s, e))).then((s) => new this({ subFilters: s }));\n  }\n}\ny(Uo, \"type\", \"Composed\"), C.setClass(Uo);\nclass Dr extends it {\n  getFragmentSource() {\n    return `\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uContrast;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n    gl_FragColor = color;\n  }`;\n  }\n  isNeutralState() {\n    return this.contrast === 0;\n  }\n  applyTo2d(t) {\n    let { imageData: { data: e } } = t;\n    const s = Math.floor(255 * this.contrast), r = 259 * (s + 255) / (255 * (259 - s));\n    for (let n = 0; n < e.length; n += 4) e[n] = r * (e[n] - 128) + 128, e[n + 1] = r * (e[n + 1] - 128) + 128, e[n + 2] = r * (e[n + 2] - 128) + 128;\n  }\n  sendUniformData(t, e) {\n    t.uniform1f(e.uContrast, this.contrast);\n  }\n}\ny(Dr, \"type\", \"Contrast\"), y(Dr, \"defaults\", { contrast: 0 }), y(Dr, \"uniformLocations\", [\"uContrast\"]), C.setClass(Dr);\nconst Nd = { Convolute_3_1: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[9];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 3.0; h+=1.0) {\n        for (float w = 0.0; w < 3.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    `, Convolute_3_0: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[9];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 3.0; h+=1.0) {\n        for (float w = 0.0; w < 3.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    `, Convolute_5_1: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[25];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 5.0; h+=1.0) {\n        for (float w = 0.0; w < 5.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    `, Convolute_5_0: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[25];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 5.0; h+=1.0) {\n        for (float w = 0.0; w < 5.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    `, Convolute_7_1: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[49];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 7.0; h+=1.0) {\n        for (float w = 0.0; w < 7.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    `, Convolute_7_0: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[49];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 7.0; h+=1.0) {\n        for (float w = 0.0; w < 7.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    `, Convolute_9_1: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[81];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 9.0; h+=1.0) {\n        for (float w = 0.0; w < 9.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    `, Convolute_9_0: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[81];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 9.0; h+=1.0) {\n        for (float w = 0.0; w < 9.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    ` };\nclass jr extends it {\n  getCacheKey() {\n    return \"\".concat(this.type, \"_\").concat(Math.sqrt(this.matrix.length), \"_\").concat(this.opaque ? 1 : 0);\n  }\n  getFragmentSource() {\n    return Nd[this.getCacheKey()];\n  }\n  applyTo2d(t) {\n    const e = t.imageData, s = e.data, r = this.matrix, n = Math.round(Math.sqrt(r.length)), o = Math.floor(n / 2), a = e.width, c = e.height, l = t.ctx.createImageData(a, c), h = l.data, u = this.opaque ? 1 : 0;\n    let d, f, g, p, m, b, S, w, k, O, x, I, M;\n    for (x = 0; x < c; x++) for (O = 0; O < a; O++) {\n      for (m = 4 * (x * a + O), d = 0, f = 0, g = 0, p = 0, M = 0; M < n; M++) for (I = 0; I < n; I++) S = x + M - o, b = O + I - o, S < 0 || S >= c || b < 0 || b >= a || (w = 4 * (S * a + b), k = r[M * n + I], d += s[w] * k, f += s[w + 1] * k, g += s[w + 2] * k, u || (p += s[w + 3] * k));\n      h[m] = d, h[m + 1] = f, h[m + 2] = g, h[m + 3] = u ? s[m + 3] : p;\n    }\n    t.imageData = l;\n  }\n  sendUniformData(t, e) {\n    t.uniform1fv(e.uMatrix, this.matrix);\n  }\n  toObject() {\n    return v(v({}, super.toObject()), {}, { opaque: this.opaque, matrix: [...this.matrix] });\n  }\n}\ny(jr, \"type\", \"Convolute\"), y(jr, \"defaults\", { opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0] }), y(jr, \"uniformLocations\", [\"uMatrix\", \"uOpaque\", \"uHalfSize\", \"uSize\"]), C.setClass(jr);\nconst fl = \"Gamma\";\nclass Er extends it {\n  getFragmentSource() {\n    return `\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform vec3 uGamma;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    vec3 correction = (1.0 / uGamma);\n    color.r = pow(color.r, correction.r);\n    color.g = pow(color.g, correction.g);\n    color.b = pow(color.b, correction.b);\n    gl_FragColor = color;\n    gl_FragColor.rgb *= color.a;\n  }\n`;\n  }\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    super(t), this.gamma = t.gamma || this.constructor.defaults.gamma.concat();\n  }\n  applyTo2d(t) {\n    let { imageData: { data: e } } = t;\n    const s = this.gamma, r = 1 / s[0], n = 1 / s[1], o = 1 / s[2];\n    this.rgbValues || (this.rgbValues = { r: new Uint8Array(256), g: new Uint8Array(256), b: new Uint8Array(256) });\n    const a = this.rgbValues;\n    for (let c = 0; c < 256; c++) a.r[c] = 255 * Math.pow(c / 255, r), a.g[c] = 255 * Math.pow(c / 255, n), a.b[c] = 255 * Math.pow(c / 255, o);\n    for (let c = 0; c < e.length; c += 4) e[c] = a.r[e[c]], e[c + 1] = a.g[e[c + 1]], e[c + 2] = a.b[e[c + 2]];\n  }\n  sendUniformData(t, e) {\n    t.uniform3fv(e.uGamma, this.gamma);\n  }\n  isNeutralState() {\n    const { gamma: t } = this;\n    return t[0] === 1 && t[1] === 1 && t[2] === 1;\n  }\n  toObject() {\n    return { type: fl, gamma: this.gamma.concat() };\n  }\n}\ny(Er, \"type\", fl), y(Er, \"defaults\", { gamma: [1, 1, 1] }), y(Er, \"uniformLocations\", [\"uGamma\"]), C.setClass(Er);\nconst Ud = { average: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      float average = (color.r + color.b + color.g) / 3.0;\n      gl_FragColor = vec4(average, average, average, color.a);\n    }\n    `, lightness: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform int uMode;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 col = texture2D(uTexture, vTexCoord);\n      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n      gl_FragColor = vec4(average, average, average, col.a);\n    }\n    `, luminosity: `\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform int uMode;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 col = texture2D(uTexture, vTexCoord);\n      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n      gl_FragColor = vec4(average, average, average, col.a);\n    }\n    ` };\nclass Pr extends it {\n  applyTo2d(t) {\n    let { imageData: { data: e } } = t;\n    for (let s, r = 0; r < e.length; r += 4) {\n      const n = e[r], o = e[r + 1], a = e[r + 2];\n      switch (this.mode) {\n        case \"average\":\n          s = (n + o + a) / 3;\n          break;\n        case \"lightness\":\n          s = (Math.min(n, o, a) + Math.max(n, o, a)) / 2;\n          break;\n        case \"luminosity\":\n          s = 0.21 * n + 0.72 * o + 0.07 * a;\n      }\n      e[r + 2] = e[r + 1] = e[r] = s;\n    }\n  }\n  getCacheKey() {\n    return \"\".concat(this.type, \"_\").concat(this.mode);\n  }\n  getFragmentSource() {\n    return Ud[this.mode];\n  }\n  sendUniformData(t, e) {\n    t.uniform1i(e.uMode, 1);\n  }\n  isNeutralState() {\n    return !1;\n  }\n}\ny(Pr, \"type\", \"Grayscale\"), y(Pr, \"defaults\", { mode: \"average\" }), y(Pr, \"uniformLocations\", [\"uMode\"]), C.setClass(Pr);\nconst $d = v(v({}, dl), {}, { rotation: 0 });\nclass qi extends ts {\n  calculateMatrix() {\n    const t = this.rotation * Math.PI, e = Lt(t), s = Bt(t), r = 1 / 3, n = Math.sqrt(r) * s, o = 1 - e;\n    this.matrix = [e + o / 3, r * o - n, r * o + n, 0, 0, r * o + n, e + r * o, r * o - n, 0, 0, r * o - n, r * o + n, e + r * o, 0, 0, 0, 0, 0, 1, 0];\n  }\n  isNeutralState() {\n    return this.rotation === 0;\n  }\n  applyTo(t) {\n    this.calculateMatrix(), super.applyTo(t);\n  }\n  toObject() {\n    return { type: this.type, rotation: this.rotation };\n  }\n}\ny(qi, \"type\", \"HueRotation\"), y(qi, \"defaults\", $d), C.setClass(qi);\nclass Ar extends it {\n  applyTo2d(t) {\n    let { imageData: { data: e } } = t;\n    for (let s = 0; s < e.length; s += 4) e[s] = 255 - e[s], e[s + 1] = 255 - e[s + 1], e[s + 2] = 255 - e[s + 2], this.alpha && (e[s + 3] = 255 - e[s + 3]);\n  }\n  getFragmentSource() {\n    return `\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform int uInvert;\n  uniform int uAlpha;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    if (uInvert == 1) {\n      if (uAlpha == 1) {\n        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);\n      } else {\n        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n      }\n    } else {\n      gl_FragColor = color;\n    }\n  }\n`;\n  }\n  isNeutralState() {\n    return !this.invert;\n  }\n  sendUniformData(t, e) {\n    t.uniform1i(e.uInvert, Number(this.invert)), t.uniform1i(e.uAlpha, Number(this.alpha));\n  }\n}\ny(Ar, \"type\", \"Invert\"), y(Ar, \"defaults\", { alpha: !1, invert: !0 }), y(Ar, \"uniformLocations\", [\"uInvert\", \"uAlpha\"]), C.setClass(Ar);\nclass Fr extends it {\n  getFragmentSource() {\n    return `\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uStepH;\n  uniform float uNoise;\n  uniform float uSeed;\n  varying vec2 vTexCoord;\n  float rand(vec2 co, float seed, float vScale) {\n    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n  }\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n    gl_FragColor = color;\n  }\n`;\n  }\n  applyTo2d(t) {\n    let { imageData: { data: e } } = t;\n    const s = this.noise;\n    for (let r = 0; r < e.length; r += 4) {\n      const n = (0.5 - Math.random()) * s;\n      e[r] += n, e[r + 1] += n, e[r + 2] += n;\n    }\n  }\n  sendUniformData(t, e) {\n    t.uniform1f(e.uNoise, this.noise / 255), t.uniform1f(e.uSeed, Math.random());\n  }\n  isNeutralState() {\n    return this.noise === 0;\n  }\n}\ny(Fr, \"type\", \"Noise\"), y(Fr, \"defaults\", { noise: 0 }), y(Fr, \"uniformLocations\", [\"uNoise\", \"uSeed\"]), C.setClass(Fr);\nclass Rr extends it {\n  applyTo2d(t) {\n    let { imageData: { data: e, width: s, height: r } } = t;\n    for (let n = 0; n < r; n += this.blocksize) for (let o = 0; o < s; o += this.blocksize) {\n      const a = 4 * n * s + 4 * o, c = e[a], l = e[a + 1], h = e[a + 2], u = e[a + 3];\n      for (let d = n; d < Math.min(n + this.blocksize, r); d++) for (let f = o; f < Math.min(o + this.blocksize, s); f++) {\n        const g = 4 * d * s + 4 * f;\n        e[g] = c, e[g + 1] = l, e[g + 2] = h, e[g + 3] = u;\n      }\n    }\n  }\n  isNeutralState() {\n    return this.blocksize === 1;\n  }\n  getFragmentSource() {\n    return `\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uBlocksize;\n  uniform float uStepW;\n  uniform float uStepH;\n  varying vec2 vTexCoord;\n  void main() {\n    float blockW = uBlocksize * uStepW;\n    float blockH = uBlocksize * uStepH;\n    int posX = int(vTexCoord.x / blockW);\n    int posY = int(vTexCoord.y / blockH);\n    float fposX = float(posX);\n    float fposY = float(posY);\n    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n    vec4 color = texture2D(uTexture, squareCoords);\n    gl_FragColor = color;\n  }\n`;\n  }\n  sendUniformData(t, e) {\n    t.uniform1f(e.uBlocksize, this.blocksize);\n  }\n}\ny(Rr, \"type\", \"Pixelate\"), y(Rr, \"defaults\", { blocksize: 4 }), y(Rr, \"uniformLocations\", [\"uBlocksize\"]), C.setClass(Rr);\nclass Lr extends it {\n  getFragmentSource() {\n    return `\nprecision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\n  gl_FragColor = texture2D(uTexture, vTexCoord);\n  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n    gl_FragColor.a = 0.0;\n  }\n}\n`;\n  }\n  applyTo2d(t) {\n    let { imageData: { data: e } } = t;\n    const s = 255 * this.distance, r = new W(this.color).getSource(), n = [r[0] - s, r[1] - s, r[2] - s], o = [r[0] + s, r[1] + s, r[2] + s];\n    for (let a = 0; a < e.length; a += 4) {\n      const c = e[a], l = e[a + 1], h = e[a + 2];\n      c > n[0] && l > n[1] && h > n[2] && c < o[0] && l < o[1] && h < o[2] && (e[a + 3] = 0);\n    }\n  }\n  sendUniformData(t, e) {\n    const s = new W(this.color).getSource(), r = this.distance, n = [0 + s[0] / 255 - r, 0 + s[1] / 255 - r, 0 + s[2] / 255 - r, 1], o = [s[0] / 255 + r, s[1] / 255 + r, s[2] / 255 + r, 1];\n    t.uniform4fv(e.uLow, n), t.uniform4fv(e.uHigh, o);\n  }\n}\ny(Lr, \"type\", \"RemoveColor\"), y(Lr, \"defaults\", { color: \"#FFFFFF\", distance: 0.02, useAlpha: !1 }), y(Lr, \"uniformLocations\", [\"uLow\", \"uHigh\"]), C.setClass(Lr);\nclass Br extends it {\n  sendUniformData(t, e) {\n    t.uniform2fv(e.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), t.uniform1fv(e.uTaps, this.taps);\n  }\n  getFilterWindow() {\n    const t = this.tempScale;\n    return Math.ceil(this.lanczosLobes / t);\n  }\n  getCacheKey() {\n    const t = this.getFilterWindow();\n    return \"\".concat(this.type, \"_\").concat(t);\n  }\n  getFragmentSource() {\n    const t = this.getFilterWindow();\n    return this.generateShader(t);\n  }\n  getTaps() {\n    const t = this.lanczosCreate(this.lanczosLobes), e = this.tempScale, s = this.getFilterWindow(), r = new Array(s);\n    for (let n = 1; n <= s; n++) r[n - 1] = t(n * e);\n    return r;\n  }\n  generateShader(t) {\n    const e = new Array(t);\n    for (let s = 1; s <= t; s++) e[s - 1] = \"\".concat(s, \".0 * uDelta\");\n    return `\n      precision highp float;\n      uniform sampler2D uTexture;\n      uniform vec2 uDelta;\n      varying vec2 vTexCoord;\n      uniform float uTaps[`.concat(t, `];\n      void main() {\n        vec4 color = texture2D(uTexture, vTexCoord);\n        float sum = 1.0;\n        `).concat(e.map((s, r) => `\n              color += texture2D(uTexture, vTexCoord + `.concat(s, \") * uTaps[\").concat(r, \"] + texture2D(uTexture, vTexCoord - \").concat(s, \") * uTaps[\").concat(r, `];\n              sum += 2.0 * uTaps[`).concat(r, `];\n            `)).join(`\n`), `\n        gl_FragColor = color / sum;\n      }\n    `);\n  }\n  applyToForWebgl(t) {\n    t.passes++, this.width = t.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = t.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), t.destinationWidth = this.dW, super.applyTo(t), t.sourceWidth = t.destinationWidth, this.height = t.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), t.destinationHeight = this.dH, super.applyTo(t), t.sourceHeight = t.destinationHeight;\n  }\n  applyTo(t) {\n    ki(t) ? this.applyToForWebgl(t) : this.applyTo2d(t);\n  }\n  isNeutralState() {\n    return this.scaleX === 1 && this.scaleY === 1;\n  }\n  lanczosCreate(t) {\n    return (e) => {\n      if (e >= t || e <= -t) return 0;\n      if (e < 11920929e-14 && e > -11920929e-14) return 1;\n      const s = (e *= Math.PI) / t;\n      return Math.sin(e) / e * Math.sin(s) / s;\n    };\n  }\n  applyTo2d(t) {\n    const e = t.imageData, s = this.scaleX, r = this.scaleY;\n    this.rcpScaleX = 1 / s, this.rcpScaleY = 1 / r;\n    const n = e.width, o = e.height, a = Math.round(n * s), c = Math.round(o * r);\n    let l;\n    l = this.resizeType === \"sliceHack\" ? this.sliceByTwo(t, n, o, a, c) : this.resizeType === \"hermite\" ? this.hermiteFastResize(t, n, o, a, c) : this.resizeType === \"bilinear\" ? this.bilinearFiltering(t, n, o, a, c) : this.resizeType === \"lanczos\" ? this.lanczosResize(t, n, o, a, c) : new ImageData(a, c), t.imageData = l;\n  }\n  sliceByTwo(t, e, s, r, n) {\n    const o = t.imageData, a = 0.5;\n    let c = !1, l = !1, h = e * a, u = s * a;\n    const d = t.filterBackend.resources;\n    let f = 0, g = 0;\n    const p = e;\n    let m = 0;\n    d.sliceByTwo || (d.sliceByTwo = kt());\n    const b = d.sliceByTwo;\n    (b.width < 1.5 * e || b.height < s) && (b.width = 1.5 * e, b.height = s);\n    const S = b.getContext(\"2d\");\n    for (S.clearRect(0, 0, 1.5 * e, s), S.putImageData(o, 0, 0), r = Math.floor(r), n = Math.floor(n); !c || !l; ) e = h, s = u, r < Math.floor(h * a) ? h = Math.floor(h * a) : (h = r, c = !0), n < Math.floor(u * a) ? u = Math.floor(u * a) : (u = n, l = !0), S.drawImage(b, f, g, e, s, p, m, h, u), f = p, g = m, m += u;\n    return S.getImageData(f, g, r, n);\n  }\n  lanczosResize(t, e, s, r, n) {\n    const o = t.imageData.data, a = t.ctx.createImageData(r, n), c = a.data, l = this.lanczosCreate(this.lanczosLobes), h = this.rcpScaleX, u = this.rcpScaleY, d = 2 / this.rcpScaleX, f = 2 / this.rcpScaleY, g = Math.ceil(h * this.lanczosLobes / 2), p = Math.ceil(u * this.lanczosLobes / 2), m = {}, b = { x: 0, y: 0 }, S = { x: 0, y: 0 };\n    return function w(k) {\n      let O, x, I, M, E, R, tt, F, B, $, yt;\n      for (b.x = (k + 0.5) * h, S.x = Math.floor(b.x), O = 0; O < n; O++) {\n        for (b.y = (O + 0.5) * u, S.y = Math.floor(b.y), E = 0, R = 0, tt = 0, F = 0, B = 0, x = S.x - g; x <= S.x + g; x++) if (!(x < 0 || x >= e)) {\n          $ = Math.floor(1e3 * Math.abs(x - b.x)), m[$] || (m[$] = {});\n          for (let dt = S.y - p; dt <= S.y + p; dt++) dt < 0 || dt >= s || (yt = Math.floor(1e3 * Math.abs(dt - b.y)), m[$][yt] || (m[$][yt] = l(Math.sqrt(Math.pow($ * d, 2) + Math.pow(yt * f, 2)) / 1e3)), I = m[$][yt], I > 0 && (M = 4 * (dt * e + x), E += I, R += I * o[M], tt += I * o[M + 1], F += I * o[M + 2], B += I * o[M + 3]));\n        }\n        M = 4 * (O * r + k), c[M] = R / E, c[M + 1] = tt / E, c[M + 2] = F / E, c[M + 3] = B / E;\n      }\n      return ++k < r ? w(k) : a;\n    }(0);\n  }\n  bilinearFiltering(t, e, s, r, n) {\n    let o, a, c, l, h, u, d, f, g, p, m, b, S, w = 0;\n    const k = this.rcpScaleX, O = this.rcpScaleY, x = 4 * (e - 1), I = t.imageData.data, M = t.ctx.createImageData(r, n), E = M.data;\n    for (d = 0; d < n; d++) for (f = 0; f < r; f++) for (h = Math.floor(k * f), u = Math.floor(O * d), g = k * f - h, p = O * d - u, S = 4 * (u * e + h), m = 0; m < 4; m++) o = I[S + m], a = I[S + 4 + m], c = I[S + x + m], l = I[S + x + 4 + m], b = o * (1 - g) * (1 - p) + a * g * (1 - p) + c * p * (1 - g) + l * g * p, E[w++] = b;\n    return M;\n  }\n  hermiteFastResize(t, e, s, r, n) {\n    const o = this.rcpScaleX, a = this.rcpScaleY, c = Math.ceil(o / 2), l = Math.ceil(a / 2), h = t.imageData.data, u = t.ctx.createImageData(r, n), d = u.data;\n    for (let f = 0; f < n; f++) for (let g = 0; g < r; g++) {\n      const p = 4 * (g + f * r);\n      let m = 0, b = 0, S = 0, w = 0, k = 0, O = 0, x = 0;\n      const I = (f + 0.5) * a;\n      for (let M = Math.floor(f * a); M < (f + 1) * a; M++) {\n        const E = Math.abs(I - (M + 0.5)) / l, R = (g + 0.5) * o, tt = E * E;\n        for (let F = Math.floor(g * o); F < (g + 1) * o; F++) {\n          let B = Math.abs(R - (F + 0.5)) / c;\n          const $ = Math.sqrt(tt + B * B);\n          $ > 1 && $ < -1 || (m = 2 * $ * $ * $ - 3 * $ * $ + 1, m > 0 && (B = 4 * (F + M * e), x += m * h[B + 3], S += m, h[B + 3] < 255 && (m = m * h[B + 3] / 250), w += m * h[B], k += m * h[B + 1], O += m * h[B + 2], b += m));\n        }\n      }\n      d[p] = w / b, d[p + 1] = k / b, d[p + 2] = O / b, d[p + 3] = x / S;\n    }\n    return u;\n  }\n}\ny(Br, \"type\", \"Resize\"), y(Br, \"defaults\", { resizeType: \"hermite\", scaleX: 1, scaleY: 1, lanczosLobes: 3 }), y(Br, \"uniformLocations\", [\"uDelta\", \"uTaps\"]), C.setClass(Br);\nclass Wr extends it {\n  getFragmentSource() {\n    return `\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uSaturation;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float rgMax = max(color.r, color.g);\n    float rgbMax = max(rgMax, color.b);\n    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n    gl_FragColor = color;\n  }\n`;\n  }\n  applyTo2d(t) {\n    let { imageData: { data: e } } = t;\n    const s = -this.saturation;\n    for (let r = 0; r < e.length; r += 4) {\n      const n = e[r], o = e[r + 1], a = e[r + 2], c = Math.max(n, o, a);\n      e[r] += c !== n ? (c - n) * s : 0, e[r + 1] += c !== o ? (c - o) * s : 0, e[r + 2] += c !== a ? (c - a) * s : 0;\n    }\n  }\n  sendUniformData(t, e) {\n    t.uniform1f(e.uSaturation, -this.saturation);\n  }\n  isNeutralState() {\n    return this.saturation === 0;\n  }\n}\ny(Wr, \"type\", \"Saturation\"), y(Wr, \"defaults\", { saturation: 0 }), y(Wr, \"uniformLocations\", [\"uSaturation\"]), C.setClass(Wr);\nclass Xr extends it {\n  getFragmentSource() {\n    return `\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uVibrance;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float max = max(color.r, max(color.g, color.b));\n    float avg = (color.r + color.g + color.b) / 3.0;\n    float amt = (abs(max - avg) * 2.0) * uVibrance;\n    color.r += max != color.r ? (max - color.r) * amt : 0.00;\n    color.g += max != color.g ? (max - color.g) * amt : 0.00;\n    color.b += max != color.b ? (max - color.b) * amt : 0.00;\n    gl_FragColor = color;\n  }\n`;\n  }\n  applyTo2d(t) {\n    let { imageData: { data: e } } = t;\n    const s = -this.vibrance;\n    for (let r = 0; r < e.length; r += 4) {\n      const n = e[r], o = e[r + 1], a = e[r + 2], c = Math.max(n, o, a), l = (n + o + a) / 3, h = 2 * Math.abs(c - l) / 255 * s;\n      e[r] += c !== n ? (c - n) * h : 0, e[r + 1] += c !== o ? (c - o) * h : 0, e[r + 2] += c !== a ? (c - a) * h : 0;\n    }\n  }\n  sendUniformData(t, e) {\n    t.uniform1f(e.uVibrance, -this.vibrance);\n  }\n  isNeutralState() {\n    return this.vibrance === 0;\n  }\n}\ny(Xr, \"type\", \"Vibrance\"), y(Xr, \"defaults\", { vibrance: 0 }), y(Xr, \"uniformLocations\", [\"uVibrance\"]), C.setClass(Xr);\nfunction qt(i, t, e, s, r) {\n  const c = r.canvas.viewportTransform;\n  i.save(), this.controlOrientation === \"left\" ? i.translate(\n    r.left + c[4],\n    r.top + c[5] + r.height / 2\n  ) : i.translate(\n    r.left + r.width + c[4],\n    r.top + c[5] + r.height / 2\n  ), i.rotate(sd.degreesToRadians(90 + r.angle)), i.lineWidth = 6, i.lineCap = \"round\", i.strokeStyle = \"white\", i.beginPath(), i.moveTo(-6, 0), i.lineTo(6, 0), i.stroke(), i.lineWidth = 4, i.strokeStyle = \"black\", i.beginPath(), i.moveTo(-6, 0), i.lineTo(6, 0), i.stroke(), i.restore();\n}\nconst It = 1, vt = \"rgba(255, 255, 255,1.0)\", $o = [\n  \"Image\",\n  \"Text\",\n  \"Video\",\n  \"Audio\",\n  \"Caption\",\n  \"Template\",\n  \"Composition\",\n  \"Illustration\",\n  \"Shape\"\n], qd = [\n  \"image\",\n  \"text\",\n  \"video\",\n  \"audio\",\n  \"caption\",\n  \"template\",\n  \"composition\",\n  \"illustration\",\n  \"shape\"\n], Kd = {\n  left: -0.5,\n  top: -0.5,\n  center: 0,\n  bottom: 0.5,\n  right: 0.5\n}, P = (i) => typeof i == \"string\" ? Kd[i] : i - 0.5, He = \"center\", ur = \"left\", Q0 = \"top\", tb = \"bottom\", dr = \"right\", eb = \"none\";\nfunction fr(i) {\n  return P(i.originX) === P(He) && P(i.originY) === P(He);\n}\nfunction Mi(i) {\n  return (t, e, s, r) => {\n    const { target: n, originX: o, originY: a } = e, c = n.getRelativeCenterPoint(), l = n.translateToOriginPoint(c, o, a), h = i(t, e, s, r);\n    return n.setPositionByOrigin(\n      l,\n      e.originX,\n      e.originY\n    ), h;\n  };\n}\nconst qo = 3, Jd = 4, gl = 188, Zd = 60, Qd = 1e3 / Zd;\nfunction D(i, t = 1, e = 1) {\n  const s = gl * t;\n  return i * (60 / 1e3) * s / e;\n}\nfunction Y(i, t = 1, e = 1) {\n  const s = gl * t;\n  return i / s * Qd * e;\n}\nfunction sb(i, t = 1) {\n  return D(i, t);\n}\nconst pl = (i) => Object.keys(i).reduce((t, e) => {\n  const { display: s, playbackRate: r } = i[e];\n  return Math.max(t, s.to / (r || 1));\n}, 0), { wrapWithFireEvent: tf, getLocalPoint: ef } = Ds, sf = (i, t, e, s) => {\n  const r = ef(\n    t,\n    t.originX,\n    t.originY,\n    e,\n    s\n  );\n  if (P(t.originX) === P(He) || P(t.originX) === P(dr) && r.x < 0 || P(t.originX) === P(ur) && r.x > 0) {\n    let { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = fr(t) ? 2 : 1, c = n.width, l = Math.ceil(\n      Math.abs(r.x * a / n.scaleX) - o\n    );\n    if (t.corner === \"mr\") {\n      const u = n.trim.to, d = l - c, f = Y(\n        d,\n        n.tScale,\n        n.playbackRate\n      ), g = u + f;\n      if (g > n.duration) return !1;\n      n.set(\"width\", Math.max(l, 0)), n.trim.to = g;\n    } else {\n      if (n.left < 0) return !1;\n      const u = c - l;\n      if (n.left + u < 0) {\n        const b = D(\n          n.duration,\n          n.tScale,\n          n.playbackRate\n        ), S = n.width + n.left;\n        if (S <= b) {\n          n.set(\"width\", S);\n          const w = Y(\n            b - S,\n            n.tScale,\n            n.playbackRate\n          );\n          return n.trim.from = w, !0;\n        }\n        return !1;\n      }\n      const f = l - c, g = n.trim.from, p = Y(\n        f,\n        n.tScale,\n        n.playbackRate\n      ), m = g - p;\n      if (m < 0) return !1;\n      n.set(\"width\", Math.max(l, 0)), n.trim.from = m, n.onResize && n.onResize();\n    }\n    return c !== n.width;\n  }\n  return !1;\n}, _n = tf(\n  \"resizing\",\n  Mi(sf)\n), { wrapWithFireEvent: rf, getLocalPoint: nf, wrapWithFixedAnchor: of } = Ds, af = (i, t, e, s) => {\n  const r = nf(\n    t,\n    t.originX,\n    t.originY,\n    e,\n    s\n  );\n  if (P(t.originX) === P(He) || P(t.originX) === P(dr) && r.x < 0 || P(t.originX) === P(ur) && r.x > 0) {\n    const { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = fr(t) ? 2 : 1, c = n.width, l = Math.ceil(\n      Math.abs(r.x * a / n.scaleX) - o\n    ), h = t.corner === \"ml\";\n    if (n.left < 0) return !1;\n    if (h) {\n      const u = c - l;\n      if (n.left + u < 0)\n        return n.set(\"width\", n.width + n.left), !0;\n    }\n    return n.set(\"width\", Math.max(l, 0)), c !== n.width;\n  }\n  return !1;\n}, Sn = rf(\n  \"resizing\",\n  of(af)\n), { wrapWithFireEvent: cf, getLocalPoint: lf } = Ds, hf = (i, t, e, s) => {\n  const r = lf(\n    t,\n    t.originX,\n    t.originY,\n    e,\n    s\n  );\n  if (P(t.originX) === P(He) || P(t.originX) === P(dr) && r.x < 0 || P(t.originX) === P(ur) && r.x > 0) {\n    const { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = fr(t) ? 2 : 1, c = n.width, l = Math.ceil(\n      Math.abs(r.x * a / n.scaleX) - o\n    ), h = Y(\n      l,\n      n.tScale,\n      n.playbackRate\n    );\n    return h >= 1500 || h < 500 ? !1 : (n.set(\"width\", Math.max(l, 0)), n.set(\"duration\", h), c !== n.width);\n  }\n  return !1;\n}, Tn = cf(\n  \"resizing\",\n  Mi(hf)\n), { wrapWithFireEvent: uf, getLocalPoint: df } = Ds, ff = (i, t, e, s) => {\n  const r = df(\n    t,\n    t.originX,\n    t.originY,\n    e,\n    s\n  );\n  if (P(t.originX) === P(He) || P(t.originX) === P(dr) && r.x < 0 || P(t.originX) === P(ur) && r.x > 0) {\n    let { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = fr(t) ? 2 : 1, c = n.width, l = Math.ceil(\n      Math.abs(r.x * a / n.scaleX) - o\n    );\n    if (t.corner === \"mr\") {\n      const u = n.trim.to, d = l - c, f = Y(\n        d,\n        n.tScale,\n        n.playbackRate\n      ), g = u + f;\n      if (g > n.duration) return !1;\n      n.set(\"width\", Math.max(l, 0)), n.trim.to = g;\n    } else {\n      if (n.left < 0) return !1;\n      const u = c - l;\n      if (n.left + u < 0) return !1;\n      const f = l - c, g = n.trim.from, p = Y(\n        f,\n        n.tScale,\n        n.playbackRate\n      ), m = g - p;\n      if (m < 0) return !1;\n      n.set(\"width\", Math.max(l, 0)), n.trim.from = m;\n    }\n    return c !== n.width;\n  }\n  return !1;\n}, Ko = uf(\n  \"resizing\",\n  Mi(ff)\n), { scaleSkewCursorStyleHandler: Kt } = Ds, js = () => ({\n  mr: new U({\n    x: 0.5,\n    y: 0,\n    actionHandler: Sn,\n    cursorStyleHandler: Kt,\n    actionName: \"resizing\",\n    render: qt,\n    controlOrientation: \"right\"\n  }),\n  ml: new U({\n    x: -0.5,\n    y: 0,\n    actionHandler: Sn,\n    cursorStyleHandler: Kt,\n    actionName: \"resizing\",\n    render: qt,\n    controlOrientation: \"left\"\n  })\n}), gf = () => ({\n  mr: new U({\n    x: 0.5,\n    y: 0,\n    render: qt,\n    actionHandler: Ko,\n    cursorStyleHandler: Kt,\n    actionName: \"resizing\",\n    controlOrientation: \"right\"\n  }),\n  ml: new U({\n    x: -0.5,\n    y: 0,\n    render: qt,\n    actionHandler: Ko,\n    cursorStyleHandler: Kt,\n    actionName: \"resizing\",\n    controlOrientation: \"left\"\n  })\n}), pf = () => ({\n  mr: new U({\n    x: 0.5,\n    y: 0,\n    render: qt,\n    actionHandler: _n,\n    cursorStyleHandler: Kt,\n    actionName: \"resizing\",\n    controlOrientation: \"right\"\n  }),\n  ml: new U({\n    x: -0.5,\n    y: 0,\n    render: qt,\n    actionHandler: _n,\n    cursorStyleHandler: Kt,\n    actionName: \"resizing\",\n    controlOrientation: \"left\"\n  })\n}), mf = () => ({\n  mr: new U({\n    x: 0.5,\n    y: 0,\n    render: qt,\n    actionHandler: xn,\n    cursorStyleHandler: Kt,\n    actionName: \"resizing\",\n    controlOrientation: \"right\"\n  }),\n  ml: new U({\n    x: -0.5,\n    y: 0,\n    render: qt,\n    actionHandler: xn,\n    cursorStyleHandler: Kt,\n    actionName: \"resizing\",\n    controlOrientation: \"left\"\n  })\n}), ml = () => ({\n  mr: new U({\n    x: 0.5,\n    y: 0,\n    actionHandler: Tn,\n    cursorStyleHandler: Kt,\n    actionName: \"resizing\",\n    render: qt,\n    controlOrientation: \"right\"\n  }),\n  ml: new U({\n    x: -0.5,\n    y: 0,\n    actionHandler: Tn,\n    cursorStyleHandler: Kt,\n    actionName: \"resizing\",\n    render: qt,\n    controlOrientation: \"left\"\n  })\n}), vf = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet gr = (i = 21) => {\n  let t = \"\", e = crypto.getRandomValues(new Uint8Array(i |= 0));\n  for (; i--; )\n    t += vf[e[i] & 63];\n  return t;\n};\nfunction Ws(i = 16) {\n  const t = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", e = t.charAt(Math.floor(Math.random() * t.length));\n  let s = gr(i - 1);\n  return s = s.replace(/[^a-zA-Z0-9]/g, \"\").slice(0, i - 1), e + s;\n}\nconst { wrapWithFireEvent: yf, getLocalPoint: bf } = Ds, _f = (i, t, e, s) => {\n  const r = bf(\n    t,\n    t.originX,\n    t.originY,\n    e,\n    s\n  );\n  if (P(t.originX) === P(He) || P(t.originX) === P(dr) && r.x < 0 || P(t.originX) === P(ur) && r.x > 0) {\n    let { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = fr(t) ? 2 : 1, c = n.width, l = Math.ceil(\n      Math.abs(r.x * a / n.scaleX) - o\n    );\n    if (t.corner === \"mr\") {\n      const u = n.trim.to, d = l - c, f = Y(\n        d,\n        n.tScale,\n        n.playbackRate\n      ), g = u + f;\n      if (g > n.duration) return !1;\n      n.set(\"width\", Math.max(l, 0)), n.trim.to = g;\n    } else {\n      if (n.left < 0) return !1;\n      const u = c - l;\n      if (n.left + u < 0) {\n        const b = D(\n          n.duration,\n          n.tScale,\n          n.playbackRate\n        ), S = n.width + n.left;\n        if (S <= b) {\n          n.set(\"width\", S);\n          const w = Y(\n            b - S,\n            n.tScale,\n            n.playbackRate\n          );\n          return n.trim.from = w, !0;\n        }\n        return !1;\n      }\n      const f = l - c, g = n.trim.from, p = Y(\n        f,\n        n.tScale,\n        n.playbackRate\n      ), m = g - p;\n      if (m < 0) return !1;\n      n.set(\"width\", Math.max(l, 0)), n.trim.from = m, n.onResize && n.onResize();\n    }\n    return c !== n.width;\n  }\n  return !1;\n}, xn = yf(\n  \"resizing\",\n  Mi(_f)\n), es = class es extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"itemType\", \"image\");\n    T(this, \"src\");\n    T(this, \"isSelected\", !1);\n    Object.assign(this, es.ownDefaults), this.id = e.id, this.src = e.src, this.display = e.display, this.tScale = e.tScale;\n  }\n  static createControls() {\n    return { controls: js() };\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...es.ownDefaults\n    };\n  }\n  // add custom text to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  updateSelected(e) {\n    this.isSelected && (e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      this.rx\n    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());\n  }\n  setSrc(e) {\n    this.src = e;\n  }\n};\nT(es, \"type\", \"Image\"), T(es, \"ownDefaults\", {\n  rx: 8,\n  ry: 8,\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 0,\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\",\n  fill: \"#27272a\"\n});\nlet Qs = es;\nC.setClass(Qs, \"Image\");\nclass _t extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"id\");\n    T(this, \"resourceId\", \"\");\n    T(this, \"tScale\");\n    T(this, \"isSelected\", !1);\n    T(this, \"display\");\n    T(this, \"trim\");\n    T(this, \"duration\");\n    T(this, \"src\");\n    this.id = e.id, this.tScale = e.tScale, this.objectCaching = !1, this.rx = 8, this.ry = 8, this.display = e.display, this.trim = e.trim, this.duration = e.duration, this.fill = \"#27272a\";\n  }\n  static createControls() {\n    return { controls: mf() };\n  }\n  // add custom text to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  updateSelected(e) {\n    this.isSelected && (e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      this.rx\n    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());\n  }\n  onResizeSnap() {\n  }\n  setSrc(e) {\n    this.src = e;\n  }\n}\nT(_t, \"type\", \"Video\");\nC.setClass(_t, \"Video\");\nconst ss = class ss extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"itemType\", \"audio\");\n    T(this, \"isSelected\", !1);\n    T(this, \"trim\");\n    T(this, \"src\");\n    T(this, \"duration\");\n    Object.assign(this, ss.ownDefaults), this.id = e.id, this.borderColor = \"transparent\", this.stroke = \"transparent\", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.trim = e.trim, this.src = e.src, this.duration = e.duration;\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...ss.ownDefaults\n    };\n  }\n  static createControls() {\n    return { controls: pf() };\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  // add custom Audio to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  updateSelected(e) {\n    this.isSelected && (e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      6\n    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());\n  }\n  setSrc(e) {\n    this.src = e;\n  }\n};\nT(ss, \"type\", \"Audio\"), T(ss, \"ownDefaults\", {\n  rx: 6,\n  ry: 6,\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 0,\n  fill: \"#27272a\",\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\"\n});\nlet ft = ss;\nC.setClass(ft, \"Audio\");\nconst rs = class rs extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"isSelected\", !1);\n    T(this, \"text\");\n    Object.assign(this, rs.ownDefaults), this.id = e.id, this.borderColor = \"transparent\", this.stroke = \"transparent\", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.text = e.text;\n  }\n  static createControls() {\n    return { controls: js() };\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...rs.ownDefaults\n    };\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  // add custom text to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  updateSelected(e) {\n    this.isSelected && (e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      6\n    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());\n  }\n};\nT(rs, \"type\", \"Text\"), T(rs, \"ownDefaults\", {\n  rx: 6,\n  ry: 6,\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 0,\n  fill: \"#27272a\",\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\"\n});\nlet tr = rs;\nC.setClass(tr, \"Text\");\nconst Sf = {\n  selectable: !1,\n  evented: !1,\n  strokeWidth: 0,\n  stroke: \"transparent\"\n}, is = class is extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"id\");\n    T(this, \"accepts\", [\n      \"audio\",\n      \"video\",\n      \"image\",\n      \"text\",\n      \"caption\",\n      \"template\"\n    ]);\n    T(this, \"metadata\");\n    T(this, \"items\", []);\n    T(this, \"magnetic\");\n    T(this, \"static\");\n    Object.assign(this, is.ownDefaults), this.id = e.id, this.accepts = e.accepts || [], this.items = e.items || [], this.magnetic = e.magnetic, this.static = e.static, this.metadata = e.metadata, this.fill = \"rgba(34, 34, 37, 0.8)\";\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...is.ownDefaults\n    };\n  }\n  updateCoords(e) {\n    this.width = e;\n  }\n};\nT(is, \"ownDefaults\", Sf), T(is, \"type\", \"Track\");\nlet ue = is;\nC.setClass(ue, \"Track\");\nconst Tf = {\n  top: {\n    top: 35,\n    guide: 2,\n    bottom: 3\n  },\n  center: {\n    top: 3,\n    guide: 2,\n    bottom: 3\n  },\n  bottom: {\n    top: 3,\n    guide: 2,\n    bottom: 35\n  }\n}, xf = (i, t) => {\n  const e = Tf[i];\n  return i === \"top\" ? {\n    top: t - (e.guide + e.bottom),\n    guide: e.guide,\n    bottom: e.bottom\n  } : i === \"center\" ? {\n    top: e.top,\n    guide: e.guide,\n    bottom: e.bottom\n  } : {\n    top: e == null ? void 0 : e.top,\n    guide: e == null ? void 0 : e.guide,\n    bottom: t - ((e == null ? void 0 : e.guide) + (e == null ? void 0 : e.top))\n  };\n}, ns = class ns extends Nt {\n  constructor(e) {\n    const s = xf(e.kind, e.height), r = new X({\n      top: 0,\n      left: 0,\n      strokeWidth: 0,\n      fill: \"transparent\",\n      selectable: !0,\n      height: s.top,\n      width: e.width\n    }), n = new X({\n      top: s.top,\n      left: 0,\n      strokeWidth: 0,\n      fill: \"transparent\",\n      selectable: !0,\n      height: s.guide,\n      width: e.width\n    }), o = new X({\n      top: s.top + s.guide,\n      left: 0,\n      strokeWidth: 0,\n      fill: \"transparent\",\n      selectable: !0,\n      height: s.bottom,\n      width: e.width\n    });\n    super([r, n, o], e);\n    T(this, \"guide\");\n    T(this, \"topGuide\");\n    T(this, \"bottomGuide\");\n    T(this, \"metadata\");\n    T(this, \"accepts\", []);\n    T(this, \"kind\");\n    T(this, \"activeGuideFill\");\n    Object.assign(this, ns.ownDefaults), this.guide = n, this.topGuide = r, this.bottomGuide = o, this.id = e.id, this.metadata = e.metadata, this.tScale = e.tScale, this.kind = e.kind, this.activeGuideFill = e.activeGuideFill || vt;\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...ns.ownDefaults\n    };\n  }\n  updateCoords(e) {\n    this.scaleToWidth(e), this.set(\"scaleY\", 1);\n  }\n  setSelected(e) {\n    e ? this.guide.set(\"fill\", this.activeGuideFill) : this.guide.set(\"fill\", \"transparent\");\n  }\n};\nT(ns, \"type\", \"Helper\"), T(ns, \"ownDefaults\", {\n  selectable: !1,\n  evented: !1\n});\nlet Ss = ns;\nC.setClass(Ss, \"Helper\");\nconst os = class os extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"guideItemId\");\n    T(this, \"distXToActCenter\");\n    T(this, \"trackItemType\");\n    T(this, \"defaultPos\");\n    T(this, \"draggedObject\");\n    Object.assign(this, os.ownDefaults), this.id = e.id;\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...os.ownDefaults\n    };\n  }\n  // add custom text to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  updateSelected(e) {\n    e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      this.rx\n    ), e.lineWidth = It, e.setLineDash(this.strokeDashArray), e.strokeStyle = vt, e.stroke(), e.restore();\n  }\n};\nT(os, \"type\", \"Placeholder\"), T(os, \"ownDefaults\", {\n  rx: 6,\n  ry: 6,\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  strokeWidth: 0,\n  fill: \"rgba(255, 211, 42,0.1)\",\n  stroke: \"rgba(255, 211, 42,1.0)\",\n  selectable: !1,\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\",\n  strokeDashArray: [5, 1],\n  evented: !1\n});\nlet er = os;\nC.setClass(er, \"Placeholder\");\nconst as = class as extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"duration\");\n    T(this, \"fromId\");\n    T(this, \"toId\");\n    T(this, \"kind\", \"none\");\n    T(this, \"isSelected\", !1);\n    Object.assign(this, as.ownDefaults), this.id = e.id, this.centeredScaling = !0, this.strokeWidth = 0, this.tScale = e.tScale, this.duration = e.duration, this.fromId = e.fromId, this.toId = e.toId, this.kind = e.kind, this.strokeDashArray = e.strokeDashArray || [];\n  }\n  static createControls() {\n    return { controls: ml() };\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...as.ownDefaults\n    };\n  }\n  updateCoords() {\n  }\n  // add custom text to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  updateSelected(e) {\n    const s = this.isSelected ? vt : \"rgba(255, 255, 255,0.15)\";\n    e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      this.rx\n    ), e.lineWidth = It, e.setLineDash(this.strokeDashArray), e.strokeStyle = s, e.stroke(), e.restore();\n  }\n};\nT(as, \"type\", \"Transition\"), T(as, \"ownDefaults\", {\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 1.5,\n  fill: \"rgba(0,0,0, 0.5)\",\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\",\n  lockMovementX: !0,\n  lockMovementY: !0,\n  duration: 1500,\n  rx: 8,\n  ry: 8\n});\nlet Jt = as;\nC.setClass(Jt, \"Transition\");\nconst cs = class cs extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"isSelected\", !1);\n    T(this, \"text\");\n    Object.assign(this, cs.ownDefaults), this.id = e.id, this.borderColor = \"transparent\", this.stroke = \"transparent\", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.text = e.text;\n  }\n  static createControls() {\n    return { controls: js() };\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...cs.ownDefaults\n    };\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  // add custom text to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  updateSelected(e) {\n    this.isSelected && (e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      6\n    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());\n  }\n};\nT(cs, \"type\", \"Caption\"), T(cs, \"ownDefaults\", {\n  rx: 6,\n  ry: 6,\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 0,\n  fill: \"#27272a\",\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\"\n});\nlet sr = cs;\nC.setClass(sr, \"Caption\");\nconst ls = class ls extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"itemType\", \"template\");\n    T(this, \"isSelected\", !1);\n    T(this, \"trim\");\n    Object.assign(this, ls.ownDefaults), this.id = e.id, this.borderColor = \"transparent\", this.stroke = \"transparent\", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.trim = e.trim;\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...ls.ownDefaults\n    };\n  }\n  static createControls() {\n    return { controls: gf() };\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  // add custom Audio to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  updateSelected(e) {\n    this.isSelected && (e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      6\n    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());\n  }\n};\nT(ls, \"type\", \"Template\"), T(ls, \"ownDefaults\", {\n  rx: 6,\n  ry: 6,\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 0,\n  fill: \"#27272a\",\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\"\n});\nlet Vt = ls;\nC.setClass(Vt, \"Template\");\nfunction wf(i) {\n  const t = Math.floor(i / 1e3), e = Math.floor(t / 60), s = t % 60, r = String(e).padStart(2, \"0\"), n = String(s).padStart(2, \"0\");\n  return `${r}:${n}`;\n}\nconst hs = class hs extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"duration\");\n    T(this, \"fromId\");\n    T(this, \"toId\");\n    T(this, \"isSelected\", !1);\n    T(this, \"name\");\n    T(this, \"durationString\");\n    T(this, \"itemType\");\n    Object.assign(this, hs.ownDefaults), this.id = e.id, this.fill = \"#27272a\", this.name = e.type.toUpperCase(), this.durationString = wf(e.duration), this.itemType = e.type;\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...hs.ownDefaults\n    };\n  }\n  _render(e) {\n    e.save(), super._render(e), e.beginPath(), e.rect(-this.width / 2, -this.height / 2, this.width, this.height), e.clip(), this.drawTextIdentity(e), e.restore();\n  }\n  drawTextIdentity(e) {\n    e.font = \"600 12px 'Geist variable'\", e.textAlign = \"left\";\n    const s = e.measureText(this.name).width, r = e.measureText(this.durationString).width, n = 8, o = 4, a = 4 - this.height / 2, c = 20, l = 4, h = 4 - this.width / 2, u = s + n * 2;\n    this.drawRoundedRect(\n      e,\n      h,\n      a,\n      u,\n      c,\n      l\n    ), e.fillStyle = \"#f4f4f5\", e.fillText(this.name, h + n, a + 14);\n    const d = h + u + o, f = r + n * 2;\n    this.drawRoundedRect(\n      e,\n      d,\n      a,\n      f,\n      c,\n      l\n    ), e.fillStyle = \"#f4f4f5\", e.fillText(this.durationString, d + n, a + 14);\n  }\n  drawRoundedRect(e, s, r, n, o, a) {\n    e.fillStyle = \"rgba(0, 0, 0, 0.5)\", e.roundRect ? (e.beginPath(), e.roundRect(s, r, n, o, a), e.fill()) : e.fillRect(s, r, n, o);\n  }\n};\nT(hs, \"type\", \"PreviewTrackItem\"), T(hs, \"ownDefaults\", {\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 0,\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\",\n  rx: 4,\n  ry: 4\n});\nlet Oe = hs;\nC.setClass(Oe, \"PreviewTrackItem\");\nclass Cf {\n  constructor() {\n    T(this, \"___eventListeners\", {});\n    T(this, \"___activeObjects\", []);\n  }\n  resize(t, { force: e } = { force: !1 }) {\n    var s;\n    this.lowerCanvasEl && (this.setDimensions(t), e && this.renderTracks(), (s = this.onResizeCanvas) == null || s.call(this, {\n      width: this.width,\n      height: this.height\n    }));\n  }\n  pauseEventListeners() {\n    this.___eventListeners = this.__eventListeners, this.__eventListeners = {};\n    const t = this.getActiveObjects();\n    this.discardActiveObject(), this.___activeObjects = t;\n  }\n  resumeEventListeners() {\n    this.__eventListeners = this.___eventListeners, this.___eventListeners = {};\n    const t = this.___activeObjects;\n    if (!t.length)\n      return this.requestRenderAll(), !1;\n    if (t.length === 1)\n      this.setActiveObject(t[0]);\n    else {\n      const e = new Ot(t);\n      this.setActiveObject(e);\n    }\n    this.requestRenderAll();\n  }\n  updateCachingActiveObjects(t) {\n    const e = this.___activeObjects;\n    this.___activeObjects = e.map((s) => {\n      const r = t.find((n) => n.id === s.id);\n      return r || s;\n    });\n  }\n}\nfunction rr(i, t) {\n  return i.map((e) => ({\n    ...e,\n    items: e.items.filter((s) => !t.includes(s))\n  }));\n}\nconst us = class us extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"itemType\", \"composition\");\n    T(this, \"isSelected\", !1);\n    Object.assign(this, us.ownDefaults), this.id = e.id, this.borderColor = \"transparent\", this.stroke = \"transparent\", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display;\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...us.ownDefaults\n    };\n  }\n  static createControls() {\n    return { controls: js() };\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  // add custom text to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  updateSelected(e) {\n    this.isSelected && (e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      6\n    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());\n  }\n};\nT(us, \"type\", \"Composition\"), T(us, \"ownDefaults\", {\n  rx: 6,\n  ry: 6,\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 0,\n  fill: \"#27272a\",\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\"\n});\nlet oi = us;\nC.setClass(oi, \"Composition\");\nconst ds = class ds extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"itemType\", \"illustration\");\n    T(this, \"src\");\n    T(this, \"isSelected\", !1);\n    Object.assign(this, ds.ownDefaults), this.id = e.id, this.borderColor = \"transparent\", this.stroke = \"transparent\", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.src = e.src;\n  }\n  static createControls() {\n    return { controls: js() };\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...ds.ownDefaults\n    };\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  // add custom text to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  updateSelected(e) {\n    this.isSelected && (e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      6\n    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());\n  }\n  setSrc(e) {\n    this.src = e, this.set({ dirty: !0 });\n  }\n};\nT(ds, \"type\", \"Illustration\"), T(ds, \"ownDefaults\", {\n  rx: 6,\n  ry: 6,\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 0,\n  fill: \"#27272a\",\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\"\n});\nlet ai = ds;\nC.setClass(ai, \"Illustration\");\nconst fs = class fs extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"itemType\", \"shape\");\n    T(this, \"src\");\n    T(this, \"isSelected\", !1);\n    Object.assign(this, fs.ownDefaults), this.id = e.id, this.borderColor = \"transparent\", this.stroke = \"transparent\", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.src = e.src;\n  }\n  static createControls() {\n    return { controls: js() };\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...fs.ownDefaults\n    };\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  // add custom text to the track item\n  _render(e) {\n    super._render(e), this.updateSelected(e);\n  }\n  updateSelected(e) {\n    this.isSelected && (e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      6\n    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());\n  }\n  setSrc(e) {\n    this.src = e, this.set({ dirty: !0 });\n  }\n};\nT(fs, \"type\", \"Shape\"), T(fs, \"ownDefaults\", {\n  rx: 6,\n  ry: 6,\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 0,\n  fill: \"#27272a\",\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\"\n});\nlet ci = fs;\nC.setClass(ci, \"Shape\");\nconst Of = (i, t) => {\n  var a;\n  const e = D(i.display.from, t.tScale), s = D(\n    i.duration,\n    t.tScale,\n    i.playbackRate\n  ), r = t.sizesMap.video, n = C.getClass(\"Video\") || _t;\n  return new n({\n    width: s,\n    height: r,\n    id: i.id,\n    tScale: t.tScale,\n    fill: \"#333333\",\n    resourceId: (a = i.metadata) == null ? void 0 : a.resourceId,\n    duration: i.duration,\n    top: 10,\n    left: e,\n    display: i.display,\n    trim: i.trim,\n    src: i.details.src,\n    metadata: i.metadata\n  });\n}, kf = (i, t) => {\n  const e = i.display, s = D(e.from, t.tScale), r = D(e.to - e.from, t.tScale), n = t.sizesMap.text, o = C.getClass(\"Text\") || tr;\n  return new o({\n    width: r,\n    height: n,\n    id: i.id,\n    display: e,\n    top: 10,\n    left: s,\n    text: i.details.text,\n    tScale: t.tScale\n  });\n}, Mf = (i, t) => {\n  const e = i.display, s = D(e.from, t.tScale), r = D(e.to - e.from, t.tScale), n = t.sizesMap.caption, o = C.getClass(\"Caption\") || sr;\n  return new o({\n    width: r,\n    height: n,\n    id: i.id,\n    display: e,\n    top: 10,\n    left: s,\n    text: i.details.text,\n    tScale: t.tScale\n  });\n}, If = (i, t) => {\n  const e = D(i.display.from, t.tScale), s = D(\n    i.display.to - (i.display.from || 5e3),\n    t.tScale\n  ), r = t.sizesMap.image, n = C.getClass(\"Image\") || Qs;\n  return new n({\n    width: s,\n    height: r,\n    id: i.id,\n    src: i.details.src,\n    tScale: t.tScale,\n    top: 10,\n    left: e,\n    display: i.display\n  });\n}, Df = (i, t) => {\n  const e = i.display, s = D(e.from, t.tScale), r = D(\n    e.to - e.from,\n    t.tScale,\n    i.playbackRate\n  ), n = t.sizesMap.audio, o = C.getClass(\"Audio\") || ft;\n  return new o({\n    width: r,\n    height: n,\n    top: 10,\n    left: s,\n    id: i.id,\n    display: e,\n    trim: i.trim || { from: 0, to: i.duration },\n    duration: i.duration,\n    src: i.details.src,\n    tScale: t.tScale\n  });\n}, jf = (i, t) => {\n  const e = i.display, s = D(e.from, t.tScale), r = D(e.to - e.from, t.tScale), n = 42, o = C.getClass(\"Template\") || Vt;\n  return new o({\n    width: r,\n    height: n,\n    top: 10,\n    left: s,\n    id: i.id,\n    display: e,\n    duration: e.to - e.from,\n    tScale: t.tScale,\n    trim: i.trim || i.display\n  });\n}, Ef = (i, t) => {\n  const e = i.display, s = D(e.from, t.tScale), r = D(e.to - e.from, t.tScale), n = 32, o = C.getClass(\"Composition\") || oi;\n  return new o({\n    width: r,\n    height: n,\n    id: i.id,\n    display: e,\n    top: 10,\n    left: s,\n    duration: e.to - e.from,\n    tScale: t.tScale\n  });\n}, Pf = (i, t) => {\n  const e = D(i.display.from, t.tScale), s = D(\n    i.display.to - (i.display.from || 5e3),\n    t.tScale\n  ), r = t.sizesMap.illustration, n = C.getClass(\"Illustration\") || ai;\n  return new n({\n    width: s,\n    height: r,\n    id: i.id,\n    src: i.details.src,\n    tScale: t.tScale,\n    top: 10,\n    left: e,\n    display: i.display\n  });\n}, Af = (i, t) => {\n  const e = D(i.display.from, t.tScale), s = D(\n    i.display.to - (i.display.from || 5e3),\n    t.tScale\n  ), r = t.sizesMap.shape, n = C.getClass(\"Shape\") || ci;\n  return new n({\n    width: s,\n    height: r,\n    id: i.id,\n    src: i.details.src,\n    tScale: t.tScale,\n    top: 10,\n    left: e,\n    display: i.display\n  });\n}, Ff = (i, t) => {\n  if (i.type === \"caption\") return Mf(i, t);\n  if (i.type === \"text\") return kf(i, t);\n  if (i.type === \"image\") return If(i, t);\n  if (i.type === \"video\") return Of(i, t);\n  if (i.type === \"audio\") return Df(i, t);\n  if (i.type === \"template\") return jf(i, t);\n  if (i.type === \"shape\") return Af(i, t);\n  if (i.type === \"illustration\")\n    return Pf(i, t);\n  if (i.type === \"composition\")\n    return Ef(i, t);\n};\nvar vl = typeof global == \"object\" && global && global.Object === Object && global, Rf = typeof self == \"object\" && self && self.Object === Object && self, Xt = vl || Rf || Function(\"return this\")(), Mt = Xt.Symbol, yl = Object.prototype, Lf = yl.hasOwnProperty, Bf = yl.toString, Rs = Mt ? Mt.toStringTag : void 0;\nfunction Wf(i) {\n  var t = Lf.call(i, Rs), e = i[Rs];\n  try {\n    i[Rs] = void 0;\n    var s = !0;\n  } catch {\n  }\n  var r = Bf.call(i);\n  return s && (t ? i[Rs] = e : delete i[Rs]), r;\n}\nvar Xf = Object.prototype, zf = Xf.toString;\nfunction Hf(i) {\n  return zf.call(i);\n}\nvar Yf = \"[object Null]\", Vf = \"[object Undefined]\", Jo = Mt ? Mt.toStringTag : void 0;\nfunction Es(i) {\n  return i == null ? i === void 0 ? Vf : Yf : Jo && Jo in Object(i) ? Wf(i) : Hf(i);\n}\nfunction ke(i) {\n  return i != null && typeof i == \"object\";\n}\nvar Gf = \"[object Symbol]\";\nfunction Ii(i) {\n  return typeof i == \"symbol\" || ke(i) && Es(i) == Gf;\n}\nfunction Nf(i, t) {\n  for (var e = -1, s = i == null ? 0 : i.length, r = Array(s); ++e < s; )\n    r[e] = t(i[e], e, i);\n  return r;\n}\nvar Zt = Array.isArray, Zo = Mt ? Mt.prototype : void 0, Qo = Zo ? Zo.toString : void 0;\nfunction bl(i) {\n  if (typeof i == \"string\")\n    return i;\n  if (Zt(i))\n    return Nf(i, bl) + \"\";\n  if (Ii(i))\n    return Qo ? Qo.call(i) : \"\";\n  var t = i + \"\";\n  return t == \"0\" && 1 / i == -1 / 0 ? \"-0\" : t;\n}\nvar Uf = /\\s/;\nfunction $f(i) {\n  for (var t = i.length; t-- && Uf.test(i.charAt(t)); )\n    ;\n  return t;\n}\nvar qf = /^\\s+/;\nfunction Kf(i) {\n  return i && i.slice(0, $f(i) + 1).replace(qf, \"\");\n}\nfunction Qt(i) {\n  var t = typeof i;\n  return i != null && (t == \"object\" || t == \"function\");\n}\nvar ta = NaN, Jf = /^[-+]0x[0-9a-f]+$/i, Zf = /^0b[01]+$/i, Qf = /^0o[0-7]+$/i, tg = parseInt;\nfunction ea(i) {\n  if (typeof i == \"number\")\n    return i;\n  if (Ii(i))\n    return ta;\n  if (Qt(i)) {\n    var t = typeof i.valueOf == \"function\" ? i.valueOf() : i;\n    i = Qt(t) ? t + \"\" : t;\n  }\n  if (typeof i != \"string\")\n    return i === 0 ? i : +i;\n  i = Kf(i);\n  var e = Zf.test(i);\n  return e || Qf.test(i) ? tg(i.slice(2), e ? 2 : 8) : Jf.test(i) ? ta : +i;\n}\nfunction eg(i) {\n  return i;\n}\nvar sg = \"[object AsyncFunction]\", rg = \"[object Function]\", ig = \"[object GeneratorFunction]\", ng = \"[object Proxy]\";\nfunction _l(i) {\n  if (!Qt(i))\n    return !1;\n  var t = Es(i);\n  return t == rg || t == ig || t == sg || t == ng;\n}\nvar Ki = Xt[\"__core-js_shared__\"], sa = function() {\n  var i = /[^.]+$/.exec(Ki && Ki.keys && Ki.keys.IE_PROTO || \"\");\n  return i ? \"Symbol(src)_1.\" + i : \"\";\n}();\nfunction og(i) {\n  return !!sa && sa in i;\n}\nvar ag = Function.prototype, cg = ag.toString;\nfunction Ue(i) {\n  if (i != null) {\n    try {\n      return cg.call(i);\n    } catch {\n    }\n    try {\n      return i + \"\";\n    } catch {\n    }\n  }\n  return \"\";\n}\nvar lg = /[\\\\^$.*+?()[\\]{}|]/g, hg = /^\\[object .+?Constructor\\]$/, ug = Function.prototype, dg = Object.prototype, fg = ug.toString, gg = dg.hasOwnProperty, pg = RegExp(\n  \"^\" + fg.call(gg).replace(lg, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n);\nfunction mg(i) {\n  if (!Qt(i) || og(i))\n    return !1;\n  var t = _l(i) ? pg : hg;\n  return t.test(Ue(i));\n}\nfunction vg(i, t) {\n  return i == null ? void 0 : i[t];\n}\nfunction $e(i, t) {\n  var e = vg(i, t);\n  return mg(e) ? e : void 0;\n}\nvar wn = $e(Xt, \"WeakMap\"), ra = Object.create, yg = /* @__PURE__ */ function() {\n  function i() {\n  }\n  return function(t) {\n    if (!Qt(t))\n      return {};\n    if (ra)\n      return ra(t);\n    i.prototype = t;\n    var e = new i();\n    return i.prototype = void 0, e;\n  };\n}();\nfunction bg(i, t, e) {\n  switch (e.length) {\n    case 0:\n      return i.call(t);\n    case 1:\n      return i.call(t, e[0]);\n    case 2:\n      return i.call(t, e[0], e[1]);\n    case 3:\n      return i.call(t, e[0], e[1], e[2]);\n  }\n  return i.apply(t, e);\n}\nvar _g = 800, Sg = 16, Tg = Date.now;\nfunction xg(i) {\n  var t = 0, e = 0;\n  return function() {\n    var s = Tg(), r = Sg - (s - e);\n    if (e = s, r > 0) {\n      if (++t >= _g)\n        return arguments[0];\n    } else\n      t = 0;\n    return i.apply(void 0, arguments);\n  };\n}\nfunction wg(i) {\n  return function() {\n    return i;\n  };\n}\nvar li = function() {\n  try {\n    var i = $e(Object, \"defineProperty\");\n    return i({}, \"\", {}), i;\n  } catch {\n  }\n}(), Cg = li ? function(i, t) {\n  return li(i, \"toString\", {\n    configurable: !0,\n    enumerable: !1,\n    value: wg(t),\n    writable: !0\n  });\n} : eg, Og = xg(Cg);\nfunction kg(i, t) {\n  for (var e = -1, s = i == null ? 0 : i.length; ++e < s && t(i[e], e, i) !== !1; )\n    ;\n  return i;\n}\nvar Mg = 9007199254740991, Ig = /^(?:0|[1-9]\\d*)$/;\nfunction eo(i, t) {\n  var e = typeof i;\n  return t = t ?? Mg, !!t && (e == \"number\" || e != \"symbol\" && Ig.test(i)) && i > -1 && i % 1 == 0 && i < t;\n}\nfunction Dg(i, t, e) {\n  t == \"__proto__\" && li ? li(i, t, {\n    configurable: !0,\n    enumerable: !0,\n    value: e,\n    writable: !0\n  }) : i[t] = e;\n}\nfunction so(i, t) {\n  return i === t || i !== i && t !== t;\n}\nvar jg = Object.prototype, Eg = jg.hasOwnProperty;\nfunction Sl(i, t, e) {\n  var s = i[t];\n  (!(Eg.call(i, t) && so(s, e)) || e === void 0 && !(t in i)) && Dg(i, t, e);\n}\nvar ia = Math.max;\nfunction Pg(i, t, e) {\n  return t = ia(t === void 0 ? i.length - 1 : t, 0), function() {\n    for (var s = arguments, r = -1, n = ia(s.length - t, 0), o = Array(n); ++r < n; )\n      o[r] = s[t + r];\n    r = -1;\n    for (var a = Array(t + 1); ++r < t; )\n      a[r] = s[r];\n    return a[t] = e(o), bg(i, this, a);\n  };\n}\nvar Ag = 9007199254740991;\nfunction ro(i) {\n  return typeof i == \"number\" && i > -1 && i % 1 == 0 && i <= Ag;\n}\nfunction Fg(i) {\n  return i != null && ro(i.length) && !_l(i);\n}\nvar Rg = Object.prototype;\nfunction Tl(i) {\n  var t = i && i.constructor, e = typeof t == \"function\" && t.prototype || Rg;\n  return i === e;\n}\nfunction Lg(i, t) {\n  for (var e = -1, s = Array(i); ++e < i; )\n    s[e] = t(e);\n  return s;\n}\nvar Bg = \"[object Arguments]\";\nfunction na(i) {\n  return ke(i) && Es(i) == Bg;\n}\nvar xl = Object.prototype, Wg = xl.hasOwnProperty, Xg = xl.propertyIsEnumerable, io = na(/* @__PURE__ */ function() {\n  return arguments;\n}()) ? na : function(i) {\n  return ke(i) && Wg.call(i, \"callee\") && !Xg.call(i, \"callee\");\n};\nfunction zg() {\n  return !1;\n}\nvar wl = typeof exports == \"object\" && exports && !exports.nodeType && exports, oa = wl && \"object\" == \"object\" && module && !module.nodeType && module, Hg = oa && oa.exports === wl, aa = Hg ? Xt.Buffer : void 0, Yg = aa ? aa.isBuffer : void 0, hi = Yg || zg, Vg = \"[object Arguments]\", Gg = \"[object Array]\", Ng = \"[object Boolean]\", Ug = \"[object Date]\", $g = \"[object Error]\", qg = \"[object Function]\", Kg = \"[object Map]\", Jg = \"[object Number]\", Zg = \"[object Object]\", Qg = \"[object RegExp]\", tp = \"[object Set]\", ep = \"[object String]\", sp = \"[object WeakMap]\", rp = \"[object ArrayBuffer]\", ip = \"[object DataView]\", np = \"[object Float32Array]\", op = \"[object Float64Array]\", ap = \"[object Int8Array]\", cp = \"[object Int16Array]\", lp = \"[object Int32Array]\", hp = \"[object Uint8Array]\", up = \"[object Uint8ClampedArray]\", dp = \"[object Uint16Array]\", fp = \"[object Uint32Array]\", H = {};\nH[np] = H[op] = H[ap] = H[cp] = H[lp] = H[hp] = H[up] = H[dp] = H[fp] = !0;\nH[Vg] = H[Gg] = H[rp] = H[Ng] = H[ip] = H[Ug] = H[$g] = H[qg] = H[Kg] = H[Jg] = H[Zg] = H[Qg] = H[tp] = H[ep] = H[sp] = !1;\nfunction gp(i) {\n  return ke(i) && ro(i.length) && !!H[Es(i)];\n}\nfunction no(i) {\n  return function(t) {\n    return i(t);\n  };\n}\nvar Cl = typeof exports == \"object\" && exports && !exports.nodeType && exports, Ns = Cl && \"object\" == \"object\" && module && !module.nodeType && module, pp = Ns && Ns.exports === Cl, Ji = pp && vl.process, Ts = function() {\n  try {\n    var i = Ns && Ns.require && Ns.require(\"util\").types;\n    return i || Ji && Ji.binding && Ji.binding(\"util\");\n  } catch {\n  }\n}(), ca = Ts && Ts.isTypedArray, Ol = ca ? no(ca) : gp, mp = Object.prototype, vp = mp.hasOwnProperty;\nfunction yp(i, t) {\n  var e = Zt(i), s = !e && io(i), r = !e && !s && hi(i), n = !e && !s && !r && Ol(i), o = e || s || r || n, a = o ? Lg(i.length, String) : [], c = a.length;\n  for (var l in i)\n    vp.call(i, l) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (l == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n    r && (l == \"offset\" || l == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    n && (l == \"buffer\" || l == \"byteLength\" || l == \"byteOffset\") || // Skip index properties.\n    eo(l, c))) && a.push(l);\n  return a;\n}\nfunction kl(i, t) {\n  return function(e) {\n    return i(t(e));\n  };\n}\nvar bp = kl(Object.keys, Object), _p = Object.prototype, Sp = _p.hasOwnProperty;\nfunction Tp(i) {\n  if (!Tl(i))\n    return bp(i);\n  var t = [];\n  for (var e in Object(i))\n    Sp.call(i, e) && e != \"constructor\" && t.push(e);\n  return t;\n}\nfunction xp(i) {\n  return Fg(i) ? yp(i) : Tp(i);\n}\nvar wp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, Cp = /^\\w*$/;\nfunction Op(i, t) {\n  if (Zt(i))\n    return !1;\n  var e = typeof i;\n  return e == \"number\" || e == \"symbol\" || e == \"boolean\" || i == null || Ii(i) ? !0 : Cp.test(i) || !wp.test(i) || t != null && i in Object(t);\n}\nvar ir = $e(Object, \"create\");\nfunction kp() {\n  this.__data__ = ir ? ir(null) : {}, this.size = 0;\n}\nfunction Mp(i) {\n  var t = this.has(i) && delete this.__data__[i];\n  return this.size -= t ? 1 : 0, t;\n}\nvar Ip = \"__lodash_hash_undefined__\", Dp = Object.prototype, jp = Dp.hasOwnProperty;\nfunction Ep(i) {\n  var t = this.__data__;\n  if (ir) {\n    var e = t[i];\n    return e === Ip ? void 0 : e;\n  }\n  return jp.call(t, i) ? t[i] : void 0;\n}\nvar Pp = Object.prototype, Ap = Pp.hasOwnProperty;\nfunction Fp(i) {\n  var t = this.__data__;\n  return ir ? t[i] !== void 0 : Ap.call(t, i);\n}\nvar Rp = \"__lodash_hash_undefined__\";\nfunction Lp(i, t) {\n  var e = this.__data__;\n  return this.size += this.has(i) ? 0 : 1, e[i] = ir && t === void 0 ? Rp : t, this;\n}\nfunction Ye(i) {\n  var t = -1, e = i == null ? 0 : i.length;\n  for (this.clear(); ++t < e; ) {\n    var s = i[t];\n    this.set(s[0], s[1]);\n  }\n}\nYe.prototype.clear = kp;\nYe.prototype.delete = Mp;\nYe.prototype.get = Ep;\nYe.prototype.has = Fp;\nYe.prototype.set = Lp;\nfunction Bp() {\n  this.__data__ = [], this.size = 0;\n}\nfunction Di(i, t) {\n  for (var e = i.length; e--; )\n    if (so(i[e][0], t))\n      return e;\n  return -1;\n}\nvar Wp = Array.prototype, Xp = Wp.splice;\nfunction zp(i) {\n  var t = this.__data__, e = Di(t, i);\n  if (e < 0)\n    return !1;\n  var s = t.length - 1;\n  return e == s ? t.pop() : Xp.call(t, e, 1), --this.size, !0;\n}\nfunction Hp(i) {\n  var t = this.__data__, e = Di(t, i);\n  return e < 0 ? void 0 : t[e][1];\n}\nfunction Yp(i) {\n  return Di(this.__data__, i) > -1;\n}\nfunction Vp(i, t) {\n  var e = this.__data__, s = Di(e, i);\n  return s < 0 ? (++this.size, e.push([i, t])) : e[s][1] = t, this;\n}\nfunction ge(i) {\n  var t = -1, e = i == null ? 0 : i.length;\n  for (this.clear(); ++t < e; ) {\n    var s = i[t];\n    this.set(s[0], s[1]);\n  }\n}\nge.prototype.clear = Bp;\nge.prototype.delete = zp;\nge.prototype.get = Hp;\nge.prototype.has = Yp;\nge.prototype.set = Vp;\nvar nr = $e(Xt, \"Map\");\nfunction Gp() {\n  this.size = 0, this.__data__ = {\n    hash: new Ye(),\n    map: new (nr || ge)(),\n    string: new Ye()\n  };\n}\nfunction Np(i) {\n  var t = typeof i;\n  return t == \"string\" || t == \"number\" || t == \"symbol\" || t == \"boolean\" ? i !== \"__proto__\" : i === null;\n}\nfunction ji(i, t) {\n  var e = i.__data__;\n  return Np(t) ? e[typeof t == \"string\" ? \"string\" : \"hash\"] : e.map;\n}\nfunction Up(i) {\n  var t = ji(this, i).delete(i);\n  return this.size -= t ? 1 : 0, t;\n}\nfunction $p(i) {\n  return ji(this, i).get(i);\n}\nfunction qp(i) {\n  return ji(this, i).has(i);\n}\nfunction Kp(i, t) {\n  var e = ji(this, i), s = e.size;\n  return e.set(i, t), this.size += e.size == s ? 0 : 1, this;\n}\nfunction pe(i) {\n  var t = -1, e = i == null ? 0 : i.length;\n  for (this.clear(); ++t < e; ) {\n    var s = i[t];\n    this.set(s[0], s[1]);\n  }\n}\npe.prototype.clear = Gp;\npe.prototype.delete = Up;\npe.prototype.get = $p;\npe.prototype.has = qp;\npe.prototype.set = Kp;\nvar Jp = \"Expected a function\";\nfunction oo(i, t) {\n  if (typeof i != \"function\" || t != null && typeof t != \"function\")\n    throw new TypeError(Jp);\n  var e = function() {\n    var s = arguments, r = t ? t.apply(this, s) : s[0], n = e.cache;\n    if (n.has(r))\n      return n.get(r);\n    var o = i.apply(this, s);\n    return e.cache = n.set(r, o) || n, o;\n  };\n  return e.cache = new (oo.Cache || pe)(), e;\n}\noo.Cache = pe;\nvar Zp = 500;\nfunction Qp(i) {\n  var t = oo(i, function(s) {\n    return e.size === Zp && e.clear(), s;\n  }), e = t.cache;\n  return t;\n}\nvar tm = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, em = /\\\\(\\\\)?/g, sm = Qp(function(i) {\n  var t = [];\n  return i.charCodeAt(0) === 46 && t.push(\"\"), i.replace(tm, function(e, s, r, n) {\n    t.push(r ? n.replace(em, \"$1\") : s || e);\n  }), t;\n});\nfunction rm(i) {\n  return i == null ? \"\" : bl(i);\n}\nfunction Ei(i, t) {\n  return Zt(i) ? i : Op(i, t) ? [i] : sm(rm(i));\n}\nfunction ao(i) {\n  if (typeof i == \"string\" || Ii(i))\n    return i;\n  var t = i + \"\";\n  return t == \"0\" && 1 / i == -1 / 0 ? \"-0\" : t;\n}\nfunction im(i, t) {\n  t = Ei(t, i);\n  for (var e = 0, s = t.length; i != null && e < s; )\n    i = i[ao(t[e++])];\n  return e && e == s ? i : void 0;\n}\nfunction Ml(i, t) {\n  for (var e = -1, s = t.length, r = i.length; ++e < s; )\n    i[r + e] = t[e];\n  return i;\n}\nvar la = Mt ? Mt.isConcatSpreadable : void 0;\nfunction nm(i) {\n  return Zt(i) || io(i) || !!(la && i && i[la]);\n}\nfunction om(i, t, e, s, r) {\n  var n = -1, o = i.length;\n  for (e || (e = nm), r || (r = []); ++n < o; ) {\n    var a = i[n];\n    e(a) ? Ml(r, a) : r[r.length] = a;\n  }\n  return r;\n}\nfunction co(i) {\n  var t = i == null ? 0 : i.length;\n  return t ? om(i) : [];\n}\nfunction am(i) {\n  return Og(Pg(i, void 0, co), i + \"\");\n}\nvar cm = kl(Object.getPrototypeOf, Object);\nfunction lm() {\n  this.__data__ = new ge(), this.size = 0;\n}\nfunction hm(i) {\n  var t = this.__data__, e = t.delete(i);\n  return this.size = t.size, e;\n}\nfunction um(i) {\n  return this.__data__.get(i);\n}\nfunction dm(i) {\n  return this.__data__.has(i);\n}\nvar fm = 200;\nfunction gm(i, t) {\n  var e = this.__data__;\n  if (e instanceof ge) {\n    var s = e.__data__;\n    if (!nr || s.length < fm - 1)\n      return s.push([i, t]), this.size = ++e.size, this;\n    e = this.__data__ = new pe(s);\n  }\n  return e.set(i, t), this.size = e.size, this;\n}\nfunction le(i) {\n  var t = this.__data__ = new ge(i);\n  this.size = t.size;\n}\nle.prototype.clear = lm;\nle.prototype.delete = hm;\nle.prototype.get = um;\nle.prototype.has = dm;\nle.prototype.set = gm;\nvar Il = typeof exports == \"object\" && exports && !exports.nodeType && exports, ha = Il && \"object\" == \"object\" && module && !module.nodeType && module, pm = ha && ha.exports === Il, ua = pm ? Xt.Buffer : void 0;\nua && ua.allocUnsafe;\nfunction mm(i, t) {\n  return i.slice();\n}\nfunction vm(i, t) {\n  for (var e = -1, s = i == null ? 0 : i.length, r = 0, n = []; ++e < s; ) {\n    var o = i[e];\n    t(o, e, i) && (n[r++] = o);\n  }\n  return n;\n}\nfunction ym() {\n  return [];\n}\nvar bm = Object.prototype, _m = bm.propertyIsEnumerable, da = Object.getOwnPropertySymbols, Sm = da ? function(i) {\n  return i == null ? [] : (i = Object(i), vm(da(i), function(t) {\n    return _m.call(i, t);\n  }));\n} : ym;\nfunction Tm(i, t, e) {\n  var s = t(i);\n  return Zt(i) ? s : Ml(s, e(i));\n}\nfunction Cn(i) {\n  return Tm(i, xp, Sm);\n}\nvar On = $e(Xt, \"DataView\"), kn = $e(Xt, \"Promise\"), Mn = $e(Xt, \"Set\"), fa = \"[object Map]\", xm = \"[object Object]\", ga = \"[object Promise]\", pa = \"[object Set]\", ma = \"[object WeakMap]\", va = \"[object DataView]\", wm = Ue(On), Cm = Ue(nr), Om = Ue(kn), km = Ue(Mn), Mm = Ue(wn), Pt = Es;\n(On && Pt(new On(new ArrayBuffer(1))) != va || nr && Pt(new nr()) != fa || kn && Pt(kn.resolve()) != ga || Mn && Pt(new Mn()) != pa || wn && Pt(new wn()) != ma) && (Pt = function(i) {\n  var t = Es(i), e = t == xm ? i.constructor : void 0, s = e ? Ue(e) : \"\";\n  if (s)\n    switch (s) {\n      case wm:\n        return va;\n      case Cm:\n        return fa;\n      case Om:\n        return ga;\n      case km:\n        return pa;\n      case Mm:\n        return ma;\n    }\n  return t;\n});\nvar Im = Object.prototype, Dm = Im.hasOwnProperty;\nfunction jm(i) {\n  var t = i.length, e = new i.constructor(t);\n  return t && typeof i[0] == \"string\" && Dm.call(i, \"index\") && (e.index = i.index, e.input = i.input), e;\n}\nvar ui = Xt.Uint8Array;\nfunction lo(i) {\n  var t = new i.constructor(i.byteLength);\n  return new ui(t).set(new ui(i)), t;\n}\nfunction Em(i, t) {\n  var e = lo(i.buffer);\n  return new i.constructor(e, i.byteOffset, i.byteLength);\n}\nvar Pm = /\\w*$/;\nfunction Am(i) {\n  var t = new i.constructor(i.source, Pm.exec(i));\n  return t.lastIndex = i.lastIndex, t;\n}\nvar ya = Mt ? Mt.prototype : void 0, ba = ya ? ya.valueOf : void 0;\nfunction Fm(i) {\n  return ba ? Object(ba.call(i)) : {};\n}\nfunction Rm(i, t) {\n  var e = lo(i.buffer);\n  return new i.constructor(e, i.byteOffset, i.length);\n}\nvar Lm = \"[object Boolean]\", Bm = \"[object Date]\", Wm = \"[object Map]\", Xm = \"[object Number]\", zm = \"[object RegExp]\", Hm = \"[object Set]\", Ym = \"[object String]\", Vm = \"[object Symbol]\", Gm = \"[object ArrayBuffer]\", Nm = \"[object DataView]\", Um = \"[object Float32Array]\", $m = \"[object Float64Array]\", qm = \"[object Int8Array]\", Km = \"[object Int16Array]\", Jm = \"[object Int32Array]\", Zm = \"[object Uint8Array]\", Qm = \"[object Uint8ClampedArray]\", tv = \"[object Uint16Array]\", ev = \"[object Uint32Array]\";\nfunction sv(i, t, e) {\n  var s = i.constructor;\n  switch (t) {\n    case Gm:\n      return lo(i);\n    case Lm:\n    case Bm:\n      return new s(+i);\n    case Nm:\n      return Em(i);\n    case Um:\n    case $m:\n    case qm:\n    case Km:\n    case Jm:\n    case Zm:\n    case Qm:\n    case tv:\n    case ev:\n      return Rm(i);\n    case Wm:\n      return new s();\n    case Xm:\n    case Ym:\n      return new s(i);\n    case zm:\n      return Am(i);\n    case Hm:\n      return new s();\n    case Vm:\n      return Fm(i);\n  }\n}\nfunction rv(i) {\n  return typeof i.constructor == \"function\" && !Tl(i) ? yg(cm(i)) : {};\n}\nvar iv = \"[object Map]\";\nfunction nv(i) {\n  return ke(i) && Pt(i) == iv;\n}\nvar _a = Ts && Ts.isMap, ov = _a ? no(_a) : nv, av = \"[object Set]\";\nfunction cv(i) {\n  return ke(i) && Pt(i) == av;\n}\nvar Sa = Ts && Ts.isSet, lv = Sa ? no(Sa) : cv, Dl = \"[object Arguments]\", hv = \"[object Array]\", uv = \"[object Boolean]\", dv = \"[object Date]\", fv = \"[object Error]\", jl = \"[object Function]\", gv = \"[object GeneratorFunction]\", pv = \"[object Map]\", mv = \"[object Number]\", El = \"[object Object]\", vv = \"[object RegExp]\", yv = \"[object Set]\", bv = \"[object String]\", _v = \"[object Symbol]\", Sv = \"[object WeakMap]\", Tv = \"[object ArrayBuffer]\", xv = \"[object DataView]\", wv = \"[object Float32Array]\", Cv = \"[object Float64Array]\", Ov = \"[object Int8Array]\", kv = \"[object Int16Array]\", Mv = \"[object Int32Array]\", Iv = \"[object Uint8Array]\", Dv = \"[object Uint8ClampedArray]\", jv = \"[object Uint16Array]\", Ev = \"[object Uint32Array]\", z = {};\nz[Dl] = z[hv] = z[Tv] = z[xv] = z[uv] = z[dv] = z[wv] = z[Cv] = z[Ov] = z[kv] = z[Mv] = z[pv] = z[mv] = z[El] = z[vv] = z[yv] = z[bv] = z[_v] = z[Iv] = z[Dv] = z[jv] = z[Ev] = !0;\nz[fv] = z[jl] = z[Sv] = !1;\nfunction Nr(i, t, e, s, r, n) {\n  var o;\n  if (o !== void 0)\n    return o;\n  if (!Qt(i))\n    return i;\n  var a = Zt(i);\n  if (a)\n    o = jm(i);\n  else {\n    var c = Pt(i), l = c == jl || c == gv;\n    if (hi(i))\n      return mm(i);\n    if (c == El || c == Dl || l && !r)\n      o = l ? {} : rv(i);\n    else {\n      if (!z[c])\n        return r ? i : {};\n      o = sv(i, c);\n    }\n  }\n  n || (n = new le());\n  var h = n.get(i);\n  if (h)\n    return h;\n  n.set(i, o), lv(i) ? i.forEach(function(f) {\n    o.add(Nr(f, t, e, f, i, n));\n  }) : ov(i) && i.forEach(function(f, g) {\n    o.set(g, Nr(f, t, e, g, i, n));\n  });\n  var u = Cn, d = a ? void 0 : u(i);\n  return kg(d || i, function(f, g) {\n    d && (g = f, f = i[g]), Sl(o, g, Nr(f, t, e, g, i, n));\n  }), o;\n}\nvar Pv = 1, Av = 4;\nfunction Ut(i) {\n  return Nr(i, Pv | Av);\n}\nvar Fv = \"__lodash_hash_undefined__\";\nfunction Rv(i) {\n  return this.__data__.set(i, Fv), this;\n}\nfunction Lv(i) {\n  return this.__data__.has(i);\n}\nfunction di(i) {\n  var t = -1, e = i == null ? 0 : i.length;\n  for (this.__data__ = new pe(); ++t < e; )\n    this.add(i[t]);\n}\ndi.prototype.add = di.prototype.push = Rv;\ndi.prototype.has = Lv;\nfunction Bv(i, t) {\n  for (var e = -1, s = i == null ? 0 : i.length; ++e < s; )\n    if (t(i[e], e, i))\n      return !0;\n  return !1;\n}\nfunction Wv(i, t) {\n  return i.has(t);\n}\nvar Xv = 1, zv = 2;\nfunction Pl(i, t, e, s, r, n) {\n  var o = e & Xv, a = i.length, c = t.length;\n  if (a != c && !(o && c > a))\n    return !1;\n  var l = n.get(i), h = n.get(t);\n  if (l && h)\n    return l == t && h == i;\n  var u = -1, d = !0, f = e & zv ? new di() : void 0;\n  for (n.set(i, t), n.set(t, i); ++u < a; ) {\n    var g = i[u], p = t[u];\n    if (s)\n      var m = o ? s(p, g, u, t, i, n) : s(g, p, u, i, t, n);\n    if (m !== void 0) {\n      if (m)\n        continue;\n      d = !1;\n      break;\n    }\n    if (f) {\n      if (!Bv(t, function(b, S) {\n        if (!Wv(f, S) && (g === b || r(g, b, e, s, n)))\n          return f.push(S);\n      })) {\n        d = !1;\n        break;\n      }\n    } else if (!(g === p || r(g, p, e, s, n))) {\n      d = !1;\n      break;\n    }\n  }\n  return n.delete(i), n.delete(t), d;\n}\nfunction Hv(i) {\n  var t = -1, e = Array(i.size);\n  return i.forEach(function(s, r) {\n    e[++t] = [r, s];\n  }), e;\n}\nfunction Yv(i) {\n  var t = -1, e = Array(i.size);\n  return i.forEach(function(s) {\n    e[++t] = s;\n  }), e;\n}\nvar Vv = 1, Gv = 2, Nv = \"[object Boolean]\", Uv = \"[object Date]\", $v = \"[object Error]\", qv = \"[object Map]\", Kv = \"[object Number]\", Jv = \"[object RegExp]\", Zv = \"[object Set]\", Qv = \"[object String]\", ty = \"[object Symbol]\", ey = \"[object ArrayBuffer]\", sy = \"[object DataView]\", Ta = Mt ? Mt.prototype : void 0, Zi = Ta ? Ta.valueOf : void 0;\nfunction ry(i, t, e, s, r, n, o) {\n  switch (e) {\n    case sy:\n      if (i.byteLength != t.byteLength || i.byteOffset != t.byteOffset)\n        return !1;\n      i = i.buffer, t = t.buffer;\n    case ey:\n      return !(i.byteLength != t.byteLength || !n(new ui(i), new ui(t)));\n    case Nv:\n    case Uv:\n    case Kv:\n      return so(+i, +t);\n    case $v:\n      return i.name == t.name && i.message == t.message;\n    case Jv:\n    case Qv:\n      return i == t + \"\";\n    case qv:\n      var a = Hv;\n    case Zv:\n      var c = s & Vv;\n      if (a || (a = Yv), i.size != t.size && !c)\n        return !1;\n      var l = o.get(i);\n      if (l)\n        return l == t;\n      s |= Gv, o.set(i, t);\n      var h = Pl(a(i), a(t), s, r, n, o);\n      return o.delete(i), h;\n    case ty:\n      if (Zi)\n        return Zi.call(i) == Zi.call(t);\n  }\n  return !1;\n}\nvar iy = 1, ny = Object.prototype, oy = ny.hasOwnProperty;\nfunction ay(i, t, e, s, r, n) {\n  var o = e & iy, a = Cn(i), c = a.length, l = Cn(t), h = l.length;\n  if (c != h && !o)\n    return !1;\n  for (var u = c; u--; ) {\n    var d = a[u];\n    if (!(o ? d in t : oy.call(t, d)))\n      return !1;\n  }\n  var f = n.get(i), g = n.get(t);\n  if (f && g)\n    return f == t && g == i;\n  var p = !0;\n  n.set(i, t), n.set(t, i);\n  for (var m = o; ++u < c; ) {\n    d = a[u];\n    var b = i[d], S = t[d];\n    if (s)\n      var w = o ? s(S, b, d, t, i, n) : s(b, S, d, i, t, n);\n    if (!(w === void 0 ? b === S || r(b, S, e, s, n) : w)) {\n      p = !1;\n      break;\n    }\n    m || (m = d == \"constructor\");\n  }\n  if (p && !m) {\n    var k = i.constructor, O = t.constructor;\n    k != O && \"constructor\" in i && \"constructor\" in t && !(typeof k == \"function\" && k instanceof k && typeof O == \"function\" && O instanceof O) && (p = !1);\n  }\n  return n.delete(i), n.delete(t), p;\n}\nvar cy = 1, xa = \"[object Arguments]\", wa = \"[object Array]\", zr = \"[object Object]\", ly = Object.prototype, Ca = ly.hasOwnProperty;\nfunction hy(i, t, e, s, r, n) {\n  var o = Zt(i), a = Zt(t), c = o ? wa : Pt(i), l = a ? wa : Pt(t);\n  c = c == xa ? zr : c, l = l == xa ? zr : l;\n  var h = c == zr, u = l == zr, d = c == l;\n  if (d && hi(i)) {\n    if (!hi(t))\n      return !1;\n    o = !0, h = !1;\n  }\n  if (d && !h)\n    return n || (n = new le()), o || Ol(i) ? Pl(i, t, e, s, r, n) : ry(i, t, c, e, s, r, n);\n  if (!(e & cy)) {\n    var f = h && Ca.call(i, \"__wrapped__\"), g = u && Ca.call(t, \"__wrapped__\");\n    if (f || g) {\n      var p = f ? i.value() : i, m = g ? t.value() : t;\n      return n || (n = new le()), r(p, m, e, s, n);\n    }\n  }\n  return d ? (n || (n = new le()), ay(i, t, e, s, r, n)) : !1;\n}\nfunction Al(i, t, e, s, r) {\n  return i === t ? !0 : i == null || t == null || !ke(i) && !ke(t) ? i !== i && t !== t : hy(i, t, e, s, Al, r);\n}\nfunction uy(i, t) {\n  return i != null && t in Object(i);\n}\nfunction dy(i, t, e) {\n  t = Ei(t, i);\n  for (var s = -1, r = t.length, n = !1; ++s < r; ) {\n    var o = ao(t[s]);\n    if (!(n = i != null && e(i, o)))\n      break;\n    i = i[o];\n  }\n  return n || ++s != r ? n : (r = i == null ? 0 : i.length, !!r && ro(r) && eo(o, r) && (Zt(i) || io(i)));\n}\nfunction fy(i, t) {\n  return i != null && dy(i, t, uy);\n}\nvar Qi = function() {\n  return Xt.Date.now();\n}, gy = \"Expected a function\", py = Math.max, my = Math.min;\nfunction vy(i, t, e) {\n  var s, r, n, o, a, c, l = 0, h = !1, u = !1, d = !0;\n  if (typeof i != \"function\")\n    throw new TypeError(gy);\n  t = ea(t) || 0, Qt(e) && (h = !!e.leading, u = \"maxWait\" in e, n = u ? py(ea(e.maxWait) || 0, t) : n, d = \"trailing\" in e ? !!e.trailing : d);\n  function f(x) {\n    var I = s, M = r;\n    return s = r = void 0, l = x, o = i.apply(M, I), o;\n  }\n  function g(x) {\n    return l = x, a = setTimeout(b, t), h ? f(x) : o;\n  }\n  function p(x) {\n    var I = x - c, M = x - l, E = t - I;\n    return u ? my(E, n - M) : E;\n  }\n  function m(x) {\n    var I = x - c, M = x - l;\n    return c === void 0 || I >= t || I < 0 || u && M >= n;\n  }\n  function b() {\n    var x = Qi();\n    if (m(x))\n      return S(x);\n    a = setTimeout(b, p(x));\n  }\n  function S(x) {\n    return a = void 0, d && s ? f(x) : (s = r = void 0, o);\n  }\n  function w() {\n    a !== void 0 && clearTimeout(a), l = 0, s = c = r = a = void 0;\n  }\n  function k() {\n    return a === void 0 ? o : S(Qi());\n  }\n  function O() {\n    var x = Qi(), I = m(x);\n    if (s = arguments, r = this, c = x, I) {\n      if (a === void 0)\n        return g(c);\n      if (u)\n        return clearTimeout(a), a = setTimeout(b, t), f(c);\n    }\n    return a === void 0 && (a = setTimeout(b, t)), o;\n  }\n  return O.cancel = w, O.flush = k, O;\n}\nfunction yy(i, t) {\n  return Al(i, t);\n}\nfunction by(i, t, e, s) {\n  if (!Qt(i))\n    return i;\n  t = Ei(t, i);\n  for (var r = -1, n = t.length, o = n - 1, a = i; a != null && ++r < n; ) {\n    var c = ao(t[r]), l = e;\n    if (c === \"__proto__\" || c === \"constructor\" || c === \"prototype\")\n      return i;\n    if (r != o) {\n      var h = a[c];\n      l = void 0, l === void 0 && (l = Qt(h) ? h : eo(t[r + 1]) ? [] : {});\n    }\n    Sl(a, c, l), a = a[c];\n  }\n  return i;\n}\nfunction _y(i, t, e) {\n  for (var s = -1, r = t.length, n = {}; ++s < r; ) {\n    var o = t[s], a = im(i, o);\n    e(a, o) && by(n, Ei(o, i), a);\n  }\n  return n;\n}\nfunction Sy(i, t) {\n  return _y(i, t, function(e, s) {\n    return fy(i, s);\n  });\n}\nvar Ty = am(function(i, t) {\n  return i == null ? {} : Sy(i, t);\n}), xy = \"Expected a function\";\nfunction wy(i, t, e) {\n  var s = !0, r = !0;\n  if (typeof i != \"function\")\n    throw new TypeError(xy);\n  return Qt(e) && (s = \"leading\" in e ? !!e.leading : s, r = \"trailing\" in e ? !!e.trailing : r), vy(i, t, {\n    leading: s,\n    maxWait: t,\n    trailing: r\n  });\n}\nconst Cy = (i, t) => {\n  if (i.length !== t.length)\n    return !1;\n  const e = new Set(i.map((r) => r.id)), s = new Set(t.map((r) => r.id));\n  if (e.size !== s.size)\n    return !1;\n  for (const r of e)\n    if (!s.has(r))\n      return !1;\n  return !0;\n}, xs = (i) => {\n  const { trackItemIds: t, transitionsMap: e, trackItemsMap: s } = i, r = /* @__PURE__ */ new Map();\n  Object.values(e).forEach((c) => {\n    var u, d;\n    if (c.kind === \"none\") return;\n    const { fromId: l, toId: h } = c;\n    r.has(l) || r.set(l, []), r.has(h) || r.set(h, []), (u = r.get(l)) == null || u.push(c), (d = r.get(h)) == null || d.push(c);\n  });\n  const n = [], o = /* @__PURE__ */ new Set(), a = (c) => {\n    const l = [];\n    let h = c;\n    for (; h && !o.has(h); ) {\n      o.add(h);\n      const u = s[h];\n      l.push(u);\n      const d = Object.values(e).find(\n        (f) => f.fromId === h && f.kind !== \"none\"\n      );\n      if (!d) break;\n      l.push(d), h = d.toId;\n    }\n    return l;\n  };\n  for (const c of t)\n    if (!o.has(c) && (!r.has(c) || !Object.values(e).some(\n      (l) => l.toId === c && l.kind !== \"none\"\n    ))) {\n      const l = a(c);\n      l.length > 0 && n.push(l);\n    }\n  return n.forEach((c) => {\n    c.sort((l, h) => \"display\" in l && \"display\" in h ? l.display.from - h.display.from : 0);\n  }), n;\n};\nfunction Oy(i, t, e, s, r) {\n  const n = i[0].canvas, o = Object.keys(s), a = {}, c = [];\n  return i.forEach((l) => {\n    const h = t.filter((u) => l.items.includes(u.id)).map((u) => {\n      if (r.includes(u.id)) {\n        const d = n.getObjects().find((f) => f.id === `${u.id}-placeholder`);\n        return (d == null ? void 0 : d.opacity) === 1 && (u.left = (d == null ? void 0 : d.left) || u.left), u;\n      } else\n        return u;\n    }).sort((u, d) => u.left - d.left);\n    for (let u = 0; u < h.length - 1; u++) {\n      const d = h[u];\n      let f = d.left;\n      const g = h[u + 1];\n      let p = g.left;\n      if (o.includes(d.id) && (f = s[d.id].left), o.includes(g.id) && (p = s[g.id].left), Math.abs(f + d.width - p) <= 1) {\n        const m = `${d.id}-${g.id}`;\n        if (e.hasOwnProperty(m)) {\n          const S = e[m];\n          a[m] = S;\n        } else {\n          const S = {\n            id: m,\n            duration: 1500,\n            fromId: d.id,\n            toId: g.id,\n            kind: \"none\",\n            trackId: l.id,\n            type: \"transition\"\n          };\n          a[m] = S;\n        }\n        c.push(m);\n      }\n    }\n  }), {\n    newTransitionIds: c,\n    newTransitionsMap: a\n  };\n}\nconst _e = (i, t) => {\n  const e = t.findIndex((h) => h.id === i), s = t[e - 1], r = t[e + 1], n = t.filter(\n    (h) => h.type === \"transition\"\n  ), o = n.indexOf(s), c = n.slice(\n    0,\n    o\n  ).reduce((h, u) => h + (u.duration || 0), 0);\n  let l = 0;\n  return s && !r ? l = (s.duration || 0) / 2 : r && !s ? l = (r.duration || 0) / 2 : s && r && (l = (r.duration || 0) / 2 + (s.duration || 0) / 2), {\n    durationDiff: l,\n    offsetTransitions: c\n  };\n}, ho = (i) => {\n  const { trackItemIds: t, transitionsMap: e, trackItemsMap: s } = i, r = /* @__PURE__ */ new Map();\n  Object.values(e).forEach((l) => {\n    var f, g;\n    const { fromId: h, toId: u, kind: d } = l;\n    d !== \"none\" && (r.has(h) || r.set(h, []), r.has(u) || r.set(u, []), (f = r.get(h)) == null || f.push(l), (g = r.get(u)) == null || g.push(l));\n  });\n  const n = [], o = /* @__PURE__ */ new Set(), a = (l) => {\n    const h = [];\n    let u = l;\n    for (; u && !o.has(u); ) {\n      o.add(u);\n      const d = s[u];\n      h.push(d);\n      const f = Object.values(e).find(\n        (g) => g.fromId === u && g.kind !== \"none\"\n        // Filter here\n      );\n      if (!f) break;\n      h.push(f), u = f.toId;\n    }\n    return h;\n  }, c = Object.values(e).filter(\n    (l) => l.kind !== \"none\"\n  );\n  for (const l of t)\n    if (!o.has(l) && (!r.has(l) || !c.some((h) => h.toId === l))) {\n      const h = a(l);\n      h.length > 0 && n.push(h);\n    }\n  return n.forEach((l) => {\n    l.sort((h, u) => \"display\" in h && \"display\" in u ? h.display.from - u.display.from : 0);\n  }), n;\n};\nclass ky {\n  addTrackItem(t) {\n    const e = Ff(t, {\n      tScale: this.tScale,\n      sizesMap: this.sizesMap\n    });\n    this.add(e);\n  }\n  alignItemsToTrack() {\n    this.pauseEventListeners();\n    const t = new Map(\n      this.getObjects(\"Track\").map((r) => [r.id, r])\n    ), e = this.getTrackItems(), s = this.getObjects(\"Transition\");\n    this.trackItemIds.forEach((r) => {\n      const n = this.tracks.find(\n        (c) => c.items.includes(r)\n      );\n      if (!n) return;\n      const o = t.get(n.id), a = this.getTrackItems().find((c) => c.id === r);\n      a && o && (a.isMain = o.magnetic, this.trackItemsMap[r].isMain = o.magnetic, a.set({ top: o.top }), a.setCoords());\n    }), t.forEach((r) => {\n      r.items = e.filter((n) => n.top === r.top).map((n) => n.id);\n    }), s.forEach((r) => {\n      const n = r.fromId, o = e.find((a) => a.id === n);\n      o && (r.set({ top: o.top }), r.setCoords());\n    }), this.resumeEventListeners();\n  }\n  updateTrackItemsToHistory() {\n    this.pauseEventListeners(), this.trackItemIds.forEach((t) => {\n      const e = this.tracks.find((c) => c.items.includes(t)), s = this.getObjects().find((c) => c.id === (e == null ? void 0 : e.id)).top, r = this.trackItemsMap[t], n = this.getObjects().find((c) => c.id === t), o = D(r.display.from, this.tScale), a = D(\n        r.display.to - r.display.from,\n        this.tScale,\n        r.playbackRate\n      );\n      if (n.set({ left: o, width: a, top: s }), n instanceof _t || n instanceof ft) {\n        const c = n.display.to - n.display.from;\n        n.setDuration ? n.setDuration(c) : n.set({ duration: c }), r.trim = n.trim, r.display = n.display;\n      }\n      n.setCoords();\n    }), this.requestRenderAll(), this.resumeEventListeners();\n  }\n  deleteTrackItemToHistory(t) {\n    this.getObjects().filter((e) => t.includes(e.id)).map((e) => this.remove(e)), this.alignItemsToTrack(), this.requestRenderAll();\n  }\n  uodateTrackItemIdsOrdering() {\n    const t = this.getTrackItems();\n    t.sort((e, s) => e.top - s.top), this.trackItemIds = t.map((e) => e.id).reverse();\n  }\n  selectTrackItemByIds(t) {\n    const e = this.getActiveObjects().map((n) => n.id);\n    if (yy(e, t)) return;\n    const r = this.getObjects(...$o, \"Transition\").filter((n) => t.includes(n.id));\n    if (!r.length)\n      this.discardActiveObject();\n    else if (r.length === 1)\n      this.setActiveObject(r[0]);\n    else {\n      const n = new Ot(r);\n      this.setActiveObject(n);\n    }\n    this.requestRenderAll();\n  }\n  synchronizeTrackItemsState() {\n    this.pauseEventListeners();\n    const t = this.getTrackItems(), e = {}, s = ho({\n      trackItemIds: this.trackItemIds,\n      transitionsMap: this.transitionsMap,\n      trackItemsMap: this.trackItemsMap\n    });\n    t.forEach((r) => {\n      const { id: n, left: o, width: a } = r, c = this.trackItemsMap[n], l = this.transitionGroups.find((h) => h.find((u) => u.id === n)) || [];\n      if (l.length === 1) {\n        const h = Y(o, this.tScale), u = Y(a, this.tScale, r.playbackRate), d = {\n          from: h,\n          to: h + u\n        }, f = {\n          display: d\n        };\n        (r instanceof _t || r instanceof ft || r instanceof Vt) && (f.trim = r.trim, f.duration = d.to - d.from), r.display = d, e[n] = {\n          ...c,\n          ...f\n        };\n      } else {\n        const h = l.findIndex((f) => f.id === n), u = l[h - 1], d = l[h + 1];\n        if (u && !d) {\n          const f = _e(n, l), g = Y(o, this.tScale) + u.duration / 2 + f.offsetTransitions, p = Y(a, this.tScale, r.playbackRate) + (u.duration || 0) / 2, m = {\n            from: g,\n            to: g + p\n          }, b = {\n            display: m\n          };\n          (r instanceof _t || r instanceof ft || r instanceof Vt) && (b.trim = r.trim), r.display = m, e[n] = {\n            ...c,\n            ...b\n          };\n        } else if (d && !u) {\n          const f = Y(o, this.tScale), g = Y(\n            a,\n            this.tScale,\n            r.playbackRate\n          ), p = {\n            from: f,\n            to: f + g + (d.duration || 0) / 2\n          }, m = {\n            display: p\n          };\n          (r instanceof _t || r instanceof ft || r instanceof Vt) && (m.trim = r.trim), r.display = p, e[n] = {\n            ...c,\n            ...m\n          };\n        } else if (u && d) {\n          const f = Y(o, this.tScale), g = s.find(\n            (O) => O.find((x) => x.id === r.id)\n          ), b = (g == null ? void 0 : g.filter((O) => O.type === \"transition\").map(\n            (O) => this.getObjects().find((x) => x.id === O.id)\n          )).filter((O) => O.top === r.top).filter((O) => O.left + O.width <= r.left).reduce((O, x) => O + (x.duration || 0), 0), S = Y(\n            a,\n            this.tScale,\n            r.playbackRate\n          ), w = {\n            from: f + b + (u.duration || 0) / 2,\n            to: f + b + S + (d.duration || 0) / 2 + (u.duration || 0)\n          }, k = {\n            display: w\n          };\n          (r instanceof _t || r instanceof ft || r instanceof Vt) && (k.trim = r.trim), r.display = w, e[n] = {\n            ...c,\n            ...k\n          };\n        }\n      }\n    }), this.trackItemsMap = {\n      ...this.trackItemsMap,\n      ...e\n    }, this.resumeEventListeners();\n  }\n  deleteTrackItemById(t) {\n    const e = t, s = this.getObjects().filter(\n      (a) => t.includes(a.id)\n    ), r = rr(this.tracks, e), n = {};\n    Object.keys(this.trackItemsMap).forEach((a) => {\n      e.includes(a) || (n[a] = this.trackItemsMap[a]);\n    });\n    const o = this.trackItemIds.filter(\n      (a) => !e.includes(a)\n    );\n    this.tracks = r, this.trackItemsMap = n, this.trackItemIds = o, this.discardActiveObject(), this.remove(...s), this.renderTracks(), this.alignItemsToTrack();\n  }\n  deleteActiveTrackItem() {\n    const t = this.getActiveObjects();\n    if (!t.length) return !1;\n    const e = t.map((o) => o.id), s = rr(this.tracks, e), r = {};\n    Object.keys(this.trackItemsMap).forEach((o) => {\n      e.includes(o) || (r[o] = this.trackItemsMap[o]);\n    });\n    const n = this.trackItemIds.filter(\n      (o) => !e.includes(o)\n    );\n    this.tracks = s, this.trackItemsMap = r, this.trackItemIds = n, this.discardActiveObject(), this.remove(...t), this.setActiveIds([]), this.renderTracks(), this.alignItemsToTrack(), this.updateState({ updateHistory: !0, kind: \"remove\" });\n  }\n  /*\n   * This method updates the coordinates of all track items in the timeline.\n   */\n  updateTrackItemCoords(t) {\n    const e = t ? this.getActiveObjects().map((s) => s.id) : [];\n    this.trackItemIds.forEach((s) => {\n      if (e.includes(s)) return;\n      const r = this.transitionGroups.find((c) => c.find((l) => l.id === s)) || [];\n      if ((r == null ? void 0 : r.length) === 1) {\n        const c = this.getObjects().find((d) => d.id === s), l = this.trackItemsMap[s], h = D(l.display.from, this.tScale), u = D(\n          l.display.to - l.display.from,\n          this.tScale,\n          l.playbackRate\n        );\n        c.set({\n          left: h,\n          width: u\n        }), c.setCoords();\n        return;\n      }\n      const n = r.findIndex((c) => c.id === s), o = r[n - 1], a = r[n + 1];\n      if (o && !a) {\n        const c = this.getObjects().find((f) => f.id === s), l = this.trackItemsMap[s], h = _e(s, r), u = D(\n          l.display.from - (o.duration || 0) / 2 - h.offsetTransitions,\n          this.tScale\n        ), d = D(\n          l.display.to - l.display.from - (o.duration || 0) / 2,\n          this.tScale,\n          l.playbackRate\n        );\n        c.set({\n          left: u,\n          width: d\n        }), c.setCoords();\n        return;\n      }\n      if (a && !o) {\n        const c = this.getObjects().find((d) => d.id === s), l = this.trackItemsMap[s], h = D(l.display.from, this.tScale), u = D(\n          l.display.to - l.display.from - (a.duration || 0) / 2,\n          this.tScale,\n          l.playbackRate\n        );\n        c.set({\n          left: h,\n          width: u\n        }), c.setCoords();\n        return;\n      }\n      if (o && a) {\n        const c = this.getObjects().find((f) => f.id === s), l = this.trackItemsMap[s], h = _e(s, r), u = D(\n          l.display.from - (o.duration || 0) / 2 - h.offsetTransitions,\n          this.tScale\n        ), d = D(\n          l.display.to - l.display.from - (a.duration || 0) / 2 - (o.duration || 0) / 2,\n          this.tScale,\n          l.playbackRate\n        );\n        c.set({\n          left: u,\n          width: d\n        }), c.setCoords();\n        return;\n      }\n    });\n  }\n  // Restore track items sizes that are not affected by transitions\n  refreshTrackItemsForTransitions() {\n    const t = this.getActiveObjects().map((l) => l.id);\n    this.pauseEventListeners();\n    const e = this.getObjects(\"Track\"), s = this.getObjects(\"Video\", \"Image\"), r = this.getObjects(\"Transition\"), n = s.concat(r), o = Object.keys(this.positionAfterTransform);\n    e.forEach((l) => {\n      o.forEach((h) => {\n        if (l.items.includes(h)) {\n          const u = this.getObjects().find((d) => d.id === h);\n          t.includes(h) || (this.positionAfterTransform[h].left = u.left);\n        }\n      });\n    });\n    const { newTransitionsMap: a } = Oy(\n      e,\n      s,\n      this.transitionsMap,\n      this.positionAfterTransform,\n      t\n    ), c = xs({\n      trackItemIds: this.trackItemIds,\n      transitionsMap: a,\n      trackItemsMap: this.trackItemsMap\n    });\n    s.forEach((l) => {\n      const h = l.id, u = c.find((m) => m.find((b) => b.id === h)) || [], d = this.transitionGroups.find((m) => m.find((b) => b.id === h)) || [];\n      if (Cy(d, u))\n        return;\n      const f = u.findIndex((m) => m.id === h), g = u[f - 1], p = u[f + 1];\n      if (g && !p) {\n        const m = _e(\n          h,\n          d\n        ), b = _e(\n          h,\n          u\n        ), S = D(\n          m.durationDiff - b.durationDiff,\n          this.tScale\n        );\n        l.set({\n          width: l.width + S\n        });\n      } else if (p && !g) {\n        const m = _e(\n          h,\n          d\n        ), b = _e(\n          h,\n          u\n        );\n        if (m.durationDiff > 0) {\n          const S = D(\n            m.durationDiff - b.durationDiff,\n            this.tScale\n          );\n          l.set({\n            width: l.width + S\n          }), u.forEach((w) => {\n            if (w.id !== l.id) {\n              const k = n.find(\n                (O) => O.id === w.id\n              );\n              k == null || k.set({\n                left: k.left + S\n              }), k == null || k.setCoords();\n            }\n          });\n        }\n      } else if (g && p)\n        console.warn(\"invalid spot\");\n      else {\n        const m = _e(\n          h,\n          d\n        ), b = D(m.durationDiff, this.tScale);\n        l.set({\n          width: l.width + b\n        });\n      }\n    }), this.resumeEventListeners();\n  }\n  getTrackItems() {\n    return this.getObjects(...$o);\n  }\n  setTrackItemCoords() {\n    this.getTrackItems().forEach((t) => {\n      t.setCoords();\n    });\n  }\n  setActiveTrackItemCoords() {\n    this.getActiveObjects().forEach((e) => e.setCoords());\n  }\n}\nconst Je = {\n  text: 32,\n  image: 40,\n  video: 40,\n  audio: 32,\n  main: 40\n}, Oa = (i) => {\n  switch (i) {\n    case \"text\":\n      return Je.text;\n    case \"image\":\n      return Je.image;\n    case \"video\":\n      return Je.video;\n    case \"audio\":\n      return Je.audio;\n    case \"helperTop\":\n      return 1e3;\n    case \"helperBottom\":\n      return 1e3;\n    case \"helperCenter\":\n      return 8;\n    case \"main\":\n      return Je.main;\n    default:\n      return Je.text;\n  }\n};\nclass My {\n  findOrCreateTrack(t, { trackId: e, trackIndex: s }) {\n    if (e) {\n      const n = this.tracks.find((o) => o.id === e);\n      if (n)\n        return n.items.push(t.id), e;\n    }\n    const r = {\n      id: gr(),\n      items: [t.id],\n      type: t.type,\n      accepts: this.acceptsMap[t.type],\n      magnetic: !1,\n      static: !1\n    };\n    return s !== void 0 ? this.tracks.splice(s, 0, r) : this.tracks.push(r), this.renderTracks(), r.id;\n  }\n  removeTracks() {\n    this.getObjects(\"Track\", \"Helper\").forEach((e) => this.remove(e));\n  }\n  renderTracks() {\n    this.filterEmptyTracks(), this.removeTracks();\n    const t = this.width, e = this.tracks.flatMap(\n      (a) => [\n        a,\n        {\n          id: `helper-${a.id}`,\n          type: \"helper\",\n          items: [],\n          accepts: []\n        }\n      ]\n    ).slice(0, -1);\n    let s = -970;\n    const r = C.getClass(\"Helper\") || Ss, n = new r({\n      top: s,\n      selectable: !1,\n      evented: !1,\n      tScale: this.tScale,\n      id: \"helper-line-top\",\n      width: t,\n      kind: \"top\",\n      height: 1e3,\n      metadata: {}\n    });\n    s += Oa(\"helperTop\"), this.insertAt(0, n), e.forEach((a, c) => {\n      if (a.type === \"helper\") {\n        const l = Oa(\"helperCenter\"), h = new r({\n          id: a.id,\n          top: s,\n          tScale: this.tScale,\n          width: t,\n          height: l,\n          metadata: {\n            order: (c + 1) / 2\n          },\n          kind: \"center\"\n        });\n        s += l, this.insertAt(0, h);\n      } else {\n        const l = this.sizesMap[a.type], h = C.getClass(\"Track\") || ue, u = new h({\n          id: a.id,\n          top: s,\n          left: 0,\n          height: l,\n          width: t,\n          tScale: this.tScale,\n          accepts: this.acceptsMap[a.type] || [],\n          items: a.items,\n          magnetic: a.magnetic,\n          static: a.static\n        });\n        s += l, this.insertAt(0, u);\n      }\n    });\n    const o = new r({\n      id: \"helper-line-bottom\",\n      top: s,\n      selectable: !1,\n      evented: !1,\n      tScale: this.tScale,\n      width: t,\n      kind: \"bottom\",\n      height: 1e3,\n      metadata: {}\n    });\n    this.insertAt(0, o);\n  }\n  filterEmptyTracks() {\n    const t = /* @__PURE__ */ new Set();\n    this.tracks = this.tracks.filter((e) => (e.items.length || e.static) && !t.has(e.id) ? (t.add(e.id), !0) : !1);\n  }\n  refreshTrackLayout() {\n    const t = this.bounding.width + this.spacing.right;\n    this.getObjects(\"Track\", \"Helper\").forEach((e) => {\n      e.updateCoords(t), e.setCoords();\n    });\n  }\n  adjustMagneticTrack() {\n    this.pauseEventListeners();\n    const t = this.tracks.filter((e) => e.magnetic);\n    t.length > 0 && t.forEach((e) => {\n      const s = e.accepts || [], r = this.getObjects(...s).filter((o) => e.items.includes(o.id)).sort((o, a) => o.left - a.left);\n      let n = 0;\n      r.forEach((o) => {\n        o.left = n, n += o.width;\n      });\n    }), this.resumeEventListeners();\n  }\n}\nfunction Fl(i) {\n  const t = this, e = i.target, s = i.transform;\n  if (s.action === \"resizing\") {\n    const r = t.getObjects().filter((h) => h !== e && ![\"Track\", \"Helper\", \"Transition\", \"Placeholder\"].includes(h.type)), n = 10, o = e.left, a = e.width * e.scaleX, c = o + a;\n    let l = !1;\n    r.forEach((h) => {\n      if (l) return;\n      const u = h.getBoundingRect(), d = u.left, f = u.left + u.width;\n      if (s.corner === \"mr\") {\n        const g = Math.abs(c - f), p = Math.abs(c - d);\n        if (g < n)\n          if (e instanceof _t || e instanceof ft) {\n            const m = f - e.left, b = m - a, S = Y(\n              b,\n              e.tScale,\n              e.playbackRate\n            ), w = e.trim.to + S;\n            w <= e.duration && (e.set({\n              width: m,\n              scaleX: 1\n            }), e.trim.to = w, e.onResizeSnap && e.onResizeSnap(), l = !0);\n          } else\n            e.set({\n              width: f - e.left,\n              scaleX: 1\n            }), e.onResizeSnap && e.onResizeSnap(), l = !0;\n        else if (p < n)\n          if (e instanceof _t || e instanceof ft) {\n            const m = d - e.left, b = m - a, S = Y(\n              b,\n              e.tScale,\n              e.playbackRate\n            ), w = e.trim.to + S;\n            w <= e.duration && (e.set({\n              width: m,\n              scaleX: 1\n            }), e.trim.to = w, e.onResizeSnap && e.onResizeSnap(), l = !0);\n          } else\n            e.set({\n              width: d - e.left,\n              scaleX: 1\n            }), e.onResizeSnap && e.onResizeSnap(), l = !0;\n      } else if (s.corner === \"ml\") {\n        const g = Math.abs(o - d), p = Math.abs(o - f);\n        if (g < n)\n          if (e instanceof _t || e instanceof ft || e instanceof Vt) {\n            const m = c - d, b = m - a, S = Y(\n              b,\n              e.tScale,\n              e.playbackRate\n            ), w = e.trim.from - S;\n            w >= 0 && (e.set({\n              left: d,\n              width: m,\n              scaleX: 1\n            }), e.trim.from = w, e.onResizeSnap && e.onResizeSnap(), l = !0);\n          } else\n            e.set({\n              left: d,\n              width: c - d,\n              scaleX: 1\n            }), e.onResizeSnap && e.onResizeSnap(), l = !0;\n        else if (p < n)\n          if (e instanceof _t || e instanceof ft || e instanceof Vt) {\n            const m = c - f, b = m - a, S = Y(\n              b,\n              e.tScale,\n              e.playbackRate\n            ), w = e.trim.from - S;\n            w >= 0 && (e.set({\n              left: f,\n              width: m,\n              scaleX: 1\n            }), e.trim.from = w, e.onResizeSnap && e.onResizeSnap(), l = !0);\n          } else\n            e.set({\n              left: f,\n              width: c - f,\n              scaleX: 1\n            }), e.onResizeSnap && e.onResizeSnap(), l = !0;\n      }\n    }), l && (e.setCoords(), t.requestRenderAll());\n  }\n}\nfunction Iy(i) {\n  i.on(\"object:resizing\", Fl.bind(i));\n}\nfunction Dy(i) {\n  i.off(\"object:resizing\", Fl.bind(i));\n}\nconst Us = 100, tn = 0, Hr = 5, ka = 3, jy = 25, vs = {\n  scrollInterval: null\n};\nfunction Ma(i) {\n  const t = jy - ka, e = (Us - i) / Us;\n  return ka + t * e;\n}\nfunction Ey(i, t) {\n  vs.scrollInterval && clearInterval(vs.scrollInterval);\n  const e = t.target, s = e.getBoundingRect();\n  vs.scrollInterval = setInterval(() => {\n    const r = i.viewportTransform, n = i.getViewportPoint(t.e);\n    if (n.x > i.width - Us && e.left + s.width < i.bounding.width) {\n      const o = Ma(i.width - n.x);\n      e.set(\"left\", e.left + o), i.setViewportPos(r[4] - o, r[5]);\n    }\n    if (n.x < Us && e.left > 0 && r[4] < Us) {\n      const o = Ma(n.x);\n      e.set(\"left\", e.left - o), i.setViewportPos(r[4] + o, r[5]);\n    }\n    n.y > i.height - tn && e.top + s.height < i.bounding.height + 80 && (e.set(\"top\", e.top + Hr), i.setViewportPos(r[4], r[5] - Hr)), n.y < tn && e.top > -80 && -r[5] > tn && (e.set(\"top\", e.top - Hr), i.setViewportPos(r[4], r[5] + Hr)), e.setCoords(), i.requestRenderAll();\n  }, 16);\n}\nfunction Py() {\n  vs.scrollInterval && (clearInterval(vs.scrollInterval), vs.scrollInterval = null);\n}\nfunction Rl() {\n  Py();\n}\nfunction Ll(i) {\n  Ey(this, i);\n}\nfunction Ay(i) {\n  i.on(\"mouse:up\", Rl), i.on(\"object:moving\", Ll.bind(i));\n}\nfunction Fy(i) {\n  i.off(\"mouse:up\", Rl), i.off(\"object:moving\", Ll.bind(i));\n}\nfunction Bl(i) {\n  const t = i.target, e = i.target.canvas;\n  if (i.action === \"resizing\" && t instanceof Jt && e) {\n    const s = t.id, r = e.getObjects(\"Transition\").find((n) => n.id === s);\n    if (r && r instanceof Jt) {\n      const n = Ut(this.transitionsMap), o = {\n        ...n,\n        [s]: {\n          ...n[s],\n          width: r.width,\n          duration: r.duration\n        }\n      };\n      this.transitionsMap = o, this.updateState();\n    }\n  }\n}\nfunction Ry(i) {\n  i.on(\"object:modified\", Bl);\n}\nfunction Ly(i) {\n  i.off(\"object:modified\", Bl);\n}\nconst Wl = {\n  canvas: null,\n  enableGuideRedraw: !0,\n  isPointerOverHelperTrack: !1,\n  draggingOverTrack: null,\n  placeholderMovingObjects: [],\n  primaryMovingObjects: [],\n  secondaryMovingObjects: [],\n  objectInitialPositions: {},\n  originTrack: {},\n  trackToItemsMap: {},\n  activeTrackToItemsMap: {},\n  trackTopToIdMap: {},\n  trackTops: [],\n  activeObjects: [],\n  primaryTracks: {},\n  secondaryTracks: {},\n  isDragOver: !1,\n  initialTrackPoints: [],\n  updateItemsInTrack: null,\n  orderNormalTrack: !1\n}, Q = () => Wl, at = (i) => {\n  Object.assign(Wl, i);\n}, Ia = 10, Pi = (i, t) => {\n  t.forEach((e) => e.isAlignmentAuxiliary && i.remove(e));\n}, Xl = (i, t) => {\n  const e = [], s = [];\n  return t.getObjects().filter((r) => r.visible).forEach((r) => {\n    if (i.find((o) => o.id === r.id) || r.isAlignmentAuxiliary)\n      return;\n    const n = r.getBoundingRect();\n    e.push(\n      ja(n.left, n.width, n.top, n.height)\n    ), s.push(\n      ja(n.top, n.height, n.left, n.width)\n    );\n  }), {\n    vertical: e.flat(),\n    horizontal: []\n  };\n}, zl = (i, t) => {\n  const e = [], s = [];\n  i.vertical.forEach((a) => {\n    t.vertical.forEach((c) => {\n      const l = Math.abs(a.val - c.guide);\n      l < Ia && e.push({\n        lineGuide: a.val,\n        diff: l,\n        orientation: \"V\",\n        snap: c.snap,\n        offset: c.offset,\n        targetDim: { start: a.start, end: a.end }\n      });\n    });\n  }), i.horizontal.forEach((a) => {\n    t.horizontal.forEach((c) => {\n      const l = Math.abs(a.val - c.guide);\n      l < Ia && s.push({\n        lineGuide: a.val,\n        diff: l,\n        orientation: \"H\",\n        snap: c.snap,\n        offset: c.offset,\n        targetDim: { start: a.start, end: a.end }\n      });\n    });\n  });\n  const r = [], n = e.sort((a, c) => a.diff - c.diff)[0], o = s.sort((a, c) => a.diff - c.diff)[0];\n  return n && r.push({\n    lineGuide: n.lineGuide,\n    offset: n.offset,\n    orientation: \"V\",\n    snap: n.snap,\n    targetDim: n.targetDim\n  }), o && r.push({\n    lineGuide: o.lineGuide,\n    offset: o.offset,\n    orientation: \"H\",\n    snap: o.snap,\n    targetDim: o.targetDim\n  }), r;\n}, Hl = (i, t, e) => {\n  i.forEach((s) => {\n    const r = By(e.getZoom());\n    s.orientation === \"H\" ? e.add(\n      Da(\n        [\n          0,\n          s.lineGuide - r.strokeWidth / 2,\n          2e3,\n          s.lineGuide - r.strokeWidth / 2\n        ],\n        { ...r, stroke: e.guideLineColor }\n      )\n    ) : s.orientation === \"V\" && e.add(\n      Da(\n        [\n          s.lineGuide - r.strokeWidth / 2,\n          0,\n          s.lineGuide - r.strokeWidth / 2,\n          2e3\n        ],\n        { ...r, stroke: e.guideLineColor }\n      )\n    );\n  });\n}, By = (i) => ({\n  strokeWidth: 2 / i\n}), Da = (i, t) => new Se(i, {\n  ...t,\n  strokeLineCap: \"square\",\n  excludeFromExport: !0,\n  isAlignmentAuxiliary: !0,\n  selectable: !1,\n  objectCaching: !1\n}), Yl = (i) => {\n  const t = i.getBoundingRect();\n  return {\n    vertical: [\n      {\n        guide: Math.round(t.left),\n        offset: Math.round(i.left - t.left),\n        snap: \"start\"\n      },\n      {\n        guide: Math.round(t.left + t.width),\n        offset: Math.round(i.left - t.left - t.width),\n        snap: \"end\"\n      }\n    ],\n    horizontal: [\n      {\n        guide: Math.round(t.top),\n        offset: Math.round(i.top - t.top),\n        snap: \"start\"\n      },\n      {\n        guide: Math.round(t.top + t.height),\n        offset: Math.round(i.top - t.top - t.height),\n        snap: \"end\"\n      }\n    ]\n  };\n}, ja = (i, t, e, s) => [i, i + t].map((n) => ({\n  val: n,\n  start: e,\n  end: e + s\n})), Vl = (i, t) => {\n  i.remove(...t), t = [];\n}, Gl = (i) => {\n  i.forEach((t) => t.setSelected(!1));\n}, Ea = (i) => i instanceof Ss, Wy = (i) => Object.assign({}, {\n  left: 16,\n  right: 80\n}, i), Xy = [\"touchstart\", \"touchmove\", \"touchend\"], zy = (i) => Xy.includes(i.type) || i.pointerType === \"touch\";\nfunction Nl(i) {\n  const t = this;\n  if (!t) return;\n  const s = Q().enableGuideRedraw, r = t.getScenePoint(i.e), n = t.getObjects(\"Helper\", \"Track\"), o = n.find((g) => {\n    const p = g.getBoundingRect();\n    return r.x >= p.left && r.x <= p.left + p.width && r.y >= p.top && r.y <= p.top + p.height;\n  });\n  at({ draggingOverTrack: o }), n.forEach((g) => {\n    Ea(g) && (g === o ? g.setSelected(!0) : g.setSelected(!1));\n  }), Ea(o) ? at({ isPointerOverHelperTrack: !0 }) : at({ isPointerOverHelperTrack: !1 });\n  const a = t.getObjects(), c = i.target, l = c.getBoundingRect();\n  c.setCoords();\n  const h = [\n    c,\n    ...t.getActiveObjects(),\n    ...t.getObjects(\"Track\", \"Helper\", \"Transition\", \"Placeholder\")\n  ], u = Xl(h, t), d = Yl(c), f = zl(u, d);\n  s && (Pi(t, a), f.length && Hl(f, l, t), at({ enableGuideRedraw: !1 }), setTimeout(() => at({ enableGuideRedraw: !0 }), 50)), f.forEach((g) => {\n    g.orientation === \"V\" ? c.left = g.lineGuide + g.offset : c.top = g.lineGuide + g.offset;\n  });\n}\nfunction Ul(i) {\n  const t = i.target.canvas;\n  t && (Pi(t, t.getObjects()), Gl(t.getObjects(\"Helper\")), at({ draggingOverTrack: null, isPointerOverHelperTrack: !1 }));\n}\nfunction $l(i) {\n  var a;\n  const t = this, e = t.getObjects(), s = i.target, r = i.transform, n = (a = t._currentTransform) == null ? void 0 : a.corner, o = s.getBoundingRect();\n  if (r.action === \"resizing\") {\n    const c = [\n      s,\n      ...t.getActiveObjects(),\n      ...t.getObjects(\"Track\", \"Helper\", \"Transition\", \"Placeholder\")\n    ], l = Xl(c, t), h = l.vertical.filter(\n      (f) => {\n        const g = f.val;\n        if (n === \"ml\")\n          return g <= o.left;\n        if (n === \"mr\")\n          return g >= o.left + o.width;\n      }\n    );\n    l.vertical = h;\n    const u = Yl(s), d = zl(l, u);\n    Pi(t, e), d.length && Hl(d, o, t);\n  }\n}\nfunction Hy(i) {\n  i.on(\"object:moving\", Nl.bind(i)), i.on(\"object:modified\", Ul.bind(i)), i.on(\"object:resizing\", $l.bind(i));\n}\nfunction Yy(i) {\n  i.off(\"object:moving\", Nl.bind(i)), i.off(\"object:modified\", Ul.bind(i)), i.off(\"object:resizing\", $l.bind(i));\n}\nfunction In(i, t, e) {\n  const s = i.indexOf(t), r = i.indexOf(e);\n  return s === -1 || r === -1 ? null : r - s;\n}\nfunction ql(i, t) {\n  const e = t.sort((r, n) => r.tempIndex - n.tempIndex), s = [];\n  for (const r of e)\n    r.tempIndex < 0 && s.push(r);\n  s.push(i);\n  for (const r of e)\n    r.tempIndex >= 0 && s.push(r);\n  return s;\n}\nfunction Kl(i) {\n  const t = Q(), e = t.canvas;\n  at({\n    activeTrackToItemsMap: {},\n    primaryTracks: {},\n    secondaryTracks: {},\n    trackTops: [],\n    trackToItemsMap: {},\n    activeObjects: [],\n    trackTopToIdMap: {},\n    isDragOver: !1,\n    initialTrackPoints: [],\n    updateItemsInTrack: null\n  }), e.trackIdAfterTransform = \"\", e.positionAfterTransform = {};\n  const s = e.getActiveObject(), r = s instanceof Ot ? s.getObjects() : [s];\n  at({ activeObjects: r });\n  const n = e.getScenePoint(i.e), o = e.getObjects(\"Track\"), a = e.getActiveObjects().map((u) => u.id);\n  let l = o.filter((u) => {\n    const d = u.items;\n    return a.some((f) => d.includes(f));\n  }).find((u) => {\n    const d = u.getBoundingRect();\n    return n.x >= d.left && n.x <= d.left + d.width && n.y >= d.top && n.y <= d.top + d.height;\n  });\n  at({ originTrack: l });\n  const h = e.getObjects(\n    \"Video\",\n    \"Image\",\n    \"Audio\",\n    \"Text\",\n    \"Element\",\n    \"Template\"\n  );\n  o.forEach((u) => {\n    const d = h.filter((f) => u.items.includes(f.id));\n    t.trackToItemsMap[u.id] = d, t.trackTopToIdMap[u.top] = u.id, t.trackTops.push(u.top);\n  }), t.trackTops.sort((u, d) => u - d), r.forEach((u) => {\n    const d = o.find((g) => g.items.includes(u.id));\n    if (!d) return;\n    const f = d.id;\n    t.activeTrackToItemsMap[f] ? t.activeTrackToItemsMap[f].push(u) : t.activeTrackToItemsMap[f] = [u];\n  }), t.primaryMovingObjects = r.filter((u) => {\n    const d = u.getBoundingRect();\n    return n.y >= d.top && n.y <= d.top + d.height && !(u instanceof Jt);\n  }), t.primaryMovingObjects.length !== 0 && (t.primaryMovingObjects.forEach((u) => {\n    const d = u.getBoundingRect().top, f = t.trackTopToIdMap[d];\n    if (t.primaryTracks[f])\n      t.primaryTracks[f].objects.push(u);\n    else {\n      const g = In(\n        t.trackTops,\n        l == null ? void 0 : l.top,\n        d\n      );\n      t.primaryTracks[f] = {\n        objects: [u],\n        index: g\n      };\n    }\n  }), t.primaryMovingObjects = t.primaryMovingObjects.sort(\n    (u, d) => u.left - d.left\n  ), t.secondaryMovingObjects = r.filter(\n    (u) => !t.primaryMovingObjects.includes(u)\n  ), t.secondaryMovingObjects.forEach((u) => {\n    const d = u.getBoundingRect().top, f = t.trackTopToIdMap[u.getBoundingRect().top];\n    if (t.secondaryTracks[f])\n      t.secondaryTracks[f].objects.push(u);\n    else {\n      const g = In(\n        t.trackTops,\n        l.top,\n        d\n      );\n      t.secondaryTracks[f] = {\n        objects: [u],\n        index: g\n      };\n    }\n  }), l && (e.trackOriginBeforeTransform = l.id), s && (e.positionBeforeTransform = {\n    top: s.top,\n    left: s.left\n  }), i.transform.action === \"drag\" && (t.placeholderMovingObjects = t.primaryMovingObjects.map((u) => {\n    const d = u.getBoundingRect();\n    t.objectInitialPositions[u.id] = {\n      top: d.top,\n      left: d.left\n    };\n    const f = new er({\n      id: `${u.id}-placeholder`,\n      left: d.left,\n      top: d.top,\n      width: d.width,\n      height: d.height\n    });\n    return f.draggedObject = u, f;\n  }), e.add(...t.placeholderMovingObjects)));\n}\nfunction Vy(i) {\n  i.on(\"before:transform\", Kl.bind(i));\n}\nfunction Gy(i) {\n  i.off(\"before:transform\", Kl.bind(i));\n}\nconst gs = class gs extends X {\n  constructor(e) {\n    super(e);\n    T(this, \"duration\");\n    T(this, \"fromId\");\n    T(this, \"toId\");\n    T(this, \"itemType\", \"none\");\n    T(this, \"isSelected\", !1);\n    Object.assign(this, gs.ownDefaults), this.id = e.id;\n  }\n  static createControls() {\n    return { controls: ml() };\n  }\n  static getDefaults() {\n    return {\n      ...super.getDefaults(),\n      ...gs.ownDefaults\n    };\n  }\n  updateCoords() {\n    const e = this.canvas;\n    if (!e) return;\n    const s = e.getObjects().find((o) => o.id === this.fromId);\n    if (!s) return;\n    const r = D(this.duration, this.tScale), n = s.left + s.width - r / 2;\n    this.set({\n      width: r,\n      left: n\n    });\n  }\n  // add custom text to the track item\n  _render(e) {\n    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);\n  }\n  drawTextIdentity(e) {\n    const s = new Path2D(\n      \"M3 5.30359C3 3.93159 4.659 3.24359 5.629 4.21359L11.997 10.5826L10.583 11.9966L5 6.41359V17.5856L10.586 11.9996L10.583 11.9966L11.997 10.5826L12 10.5856L18.371 4.21459C19.341 3.24459 21 3.93159 21 5.30359V18.6956C21 20.0676 19.341 20.7556 18.371 19.7856L12 13.5L13.414 11.9996L19 17.5866V6.41359L13.414 11.9996L13.421 12.0056L12.006 13.4206L12 13.4136L5.629 19.7846C4.659 20.7546 3 20.0676 3 18.6956V5.30359Z\"\n    );\n    e.save(), e.translate(-12, -12), e.fillStyle = \"#ffffff\", e.fill(s), e.restore();\n  }\n  setSelected(e) {\n    this.isSelected = e, this.set({ dirty: !0 });\n  }\n  updateSelected(e) {\n    this.isSelected && (e.save(), e.beginPath(), e.roundRect(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      this.rx\n    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());\n  }\n};\nT(gs, \"type\", \"TransitionGuide\"), T(gs, \"ownDefaults\", {\n  objectCaching: !1,\n  borderColor: \"transparent\",\n  stroke: \"transparent\",\n  strokeWidth: 1.5,\n  fill: \"rgba(0,0,0, 0.85)\",\n  borderOpacityWhenMoving: 1,\n  hoverCursor: \"default\",\n  lockMovementX: !0,\n  lockMovementY: !0,\n  duration: 1500,\n  rx: 8,\n  ry: 8\n});\nlet or = gs;\nconst Ny = [\n  \"text\",\n  \"image\",\n  \"video\",\n  \"audio\",\n  \"caption\",\n  \"template\"\n];\nfunction Jl() {\n  const i = Q();\n  Vl(this, i.placeholderMovingObjects);\n}\nfunction Uy(i) {\n  const t = i.target.left;\n  i.target.left = Math.max(t, 0);\n}\nfunction Zl(i, t) {\n  return i.find((s) => {\n    const r = s.getBoundingRect();\n    return t.left < r.left + r.width && t.left + t.width - 1 > r.left && t.top < r.top + r.height && t.top + t.height > r.top;\n  });\n}\nfunction $y(i, t) {\n  const s = i.canvas.getActiveObject(), r = s.left + s.width / 2, n = t.left + t.width / 2;\n  return r < n ? t.left - s.width : (r > n, t.left + t.width);\n}\nconst qy = (i, t, e) => !(e < 0 || Zl(i, {\n  ...t.getBoundingRect(),\n  left: e\n})), Ql = (i) => {\n  const e = Q().draggingOverTrack;\n  return i instanceof Oe ? e && e.accepts.includes(i.itemType) : e && e.accepts.includes(i.type);\n};\nfunction Ky(i) {\n  Q().isPointerOverHelperTrack ? i.opacity = 0 : i.opacity = 1;\n}\nfunction Jy() {\n  const i = Q(), t = i.primaryMovingObjects[0];\n  return {\n    top: i.objectInitialPositions[t.id].top,\n    left: i.objectInitialPositions[t.id].left\n  };\n}\nfunction Zy(i) {\n  const t = i.getBoundingRect(), e = Q(), s = e.draggingOverTrack;\n  if (e.primaryMovingObjects.map((n) => n.id).includes(i.id)) {\n    const o = e.primaryMovingObjects[0].getBoundingRect();\n    return {\n      top: s.top,\n      left: o.left\n    };\n  }\n  return {\n    top: s.top,\n    left: t.left\n  };\n}\nfunction Qy(i, t, e, s) {\n  const n = i.canvas.getActiveObjects().map((h) => h.id), o = $y(i, t), a = e.filter(\n    (h) => !n.includes(h.id)\n  ), c = qy(\n    a,\n    i,\n    o\n  ), l = Q();\n  if (l.orderNormalTrack = !0, !c || s.x - 20 < 0) {\n    const h = l.draggingOverTrack;\n    return {\n      left: l.initialTrackPoints.reduce(\n        (d, f) => Math.abs(f - s.x) < Math.abs(d - s.x) ? f : d\n      ),\n      top: h.top\n    };\n  }\n  return {\n    left: o,\n    top: t.top\n  };\n}\nconst t0 = (i, t) => {\n  i.forEach((e, s) => {\n    e.set({ left: t[s] });\n  });\n}, th = wy(\n  (i) => {\n    const t = i.target.canvas;\n    Uy(i);\n    const e = Q(), s = e.draggingOverTrack;\n    if (s) {\n      const a = e.primaryMovingObjects[0];\n      Ny.includes(a.type) && e.placeholderMovingObjects.forEach((c) => {\n        c.visible = !0;\n      });\n    } else {\n      e.placeholderMovingObjects.forEach((a) => {\n        a.visible = !1;\n      });\n      return;\n    }\n    const r = e.placeholderMovingObjects.map(\n      (a) => a.draggedObject\n    ), n = (e.trackToItemsMap[s.id] || []).filter((a) => !r.includes(a)), o = Ql(e.primaryMovingObjects[0]);\n    if (s.magnetic && o) {\n      e.updateItemsInTrack ? e.updateItemsInTrack !== s.id && (e.updateItemsInTrack = s.id, e.initialTrackPoints = []) : (e.updateItemsInTrack = s.id, e.initialTrackPoints = []), e.initialTrackPoints.length === 0 && (e.updateItemsInTrack = s.id, e.initialTrackPoints = Pa(\n        e,\n        s\n      ));\n      let a = 0;\n      for (const [c, l] of e.initialTrackPoints.entries()) {\n        const h = l, u = e.initialTrackPoints[c + 1], d = e.initialTrackPoints[c - 1], f = u - h, g = h - d;\n        if (!u)\n          a = h;\n        else if (h <= i.pointer.x && h + f / 2 >= i.pointer.x) {\n          a = h;\n          break;\n        } else if (h - g / 2 <= i.pointer.x && i.pointer.x <= h) {\n          a = h;\n          break;\n        }\n      }\n      e.placeholderMovingObjects.forEach((c) => {\n        c.opacity = 1, c.left = a, c.top = s.top, a += c.width;\n      }), e.placeholderMovingObjects.forEach((c) => {\n        const l = c.draggedObject;\n        t.positionAfterTransform[l.id] = {\n          top: c.top,\n          left: c.left\n        };\n      }), t.trackIdAfterTransform = e.trackTopToIdMap[s.top];\n    } else {\n      e.orderNormalTrack = !1, e.updateItemsInTrack && e.updateItemsInTrack !== s.id && (t.getObjects().find((f) => f.id === e.updateItemsInTrack).magnetic ? e0(t, e) : t.updateTrackItemCoords(!0), e.updateItemsInTrack = null, e.initialTrackPoints = []), e.initialTrackPoints.length === 0 && s instanceof ue && (e.updateItemsInTrack = s.id, e.initialTrackPoints = Pa(\n        e,\n        s\n      ));\n      const a = n.find((d) => Zl(\n        r,\n        d.getBoundingRect()\n      )), c = [], h = e.primaryMovingObjects.sort((d, f) => d.left - f.left), u = h[0];\n      h.forEach((d, f) => {\n        if (!h[f - 1]) return;\n        const g = d.left - u.left;\n        c.push(g);\n      }), e.placeholderMovingObjects.forEach((d, f) => {\n        const g = d.draggedObject;\n        if (g instanceof or) {\n          d.visible = !1;\n          return;\n        }\n        g.setCoords(), Ky(d);\n        let p = n0(\n          g,\n          n,\n          i.pointer,\n          a\n        );\n        if (g instanceof Oe && p.isInvalidDrop && e.draggingOverTrack instanceof ue) {\n          d.opacity = 0;\n          const m = i.pointer, b = [...t.viewportTransform], S = m.y - b[5];\n          i0(t, S);\n        } else e.primaryMovingObjects.length > 1 ? (t.trackIdAfterTransform = e.trackTopToIdMap[p.top], t.positionAfterTransform[g.id] = {\n          top: p.top,\n          left: p.left + (c[f - 1] || 0)\n        }, d.left = p.left + (c[f - 1] || 0), d.top = p.top) : (t.trackIdAfterTransform = e.trackTopToIdMap[p.top], t.positionAfterTransform[g.id] = {\n          top: p.top,\n          left: p.left\n        }, d.left = p.left, d.top = p.top);\n      });\n    }\n  }\n), Pa = (i, t) => {\n  const e = i.canvas, s = [];\n  t.items.forEach((l) => {\n    const h = e.getObjects().find((u) => u.id === l);\n    h && s.push(h);\n  });\n  const r = i.activeObjects.map((l) => l.id), o = s.filter(\n    (l) => !r.includes(l.id)\n  ).sort(\n    (l, h) => l.left - h.left\n  );\n  let a = 0;\n  const c = [];\n  return t.magnetic ? s0(o, a, c) : r0(t, c, e), c;\n};\nfunction e0(i, t) {\n  const e = [];\n  i.getObjects().find((a) => a.id === t.updateItemsInTrack).items.forEach((a) => {\n    const c = i.getObjects().find((l) => l.id === a);\n    c && e.push(c);\n  });\n  const r = t.activeObjects.map((a) => a.id), o = e.filter(\n    (a) => !r.includes(a.id)\n  ).sort(\n    (a, c) => a.left - c.left\n  );\n  t.initialTrackPoints.length > o.length && t0(o, t.initialTrackPoints);\n}\nfunction s0(i, t, e) {\n  var l;\n  const s = Q(), r = (l = i[0]) == null ? void 0 : l.canvas, n = s.draggingOverTrack, o = s.primaryMovingObjects.map((h) => h.id);\n  if (!r) return;\n  const a = r.transitionIds.filter(\n    (h) => r.transitionsMap[h].kind !== \"none\"\n  );\n  i.forEach((h) => {\n    h.set({ left: t }), t += h.width, a.find(\n      (d) => r.transitionsMap[d].toId === h.id\n    ) || e.push(h.left);\n  });\n  const c = i[i.length - 1];\n  if (e.push(((c == null ? void 0 : c.left) || 0) + ((c == null ? void 0 : c.width) || 0)), n != null && n.items.includes(o[0])) {\n    const h = r.getActiveObject(), u = [...e];\n    if (h) {\n      const d = u.findIndex((f) => f > (h == null ? void 0 : h.left));\n      d !== -1 && e.splice(d, 0, h.left);\n    }\n  }\n}\nfunction r0(i, t, e) {\n  const s = i.items, r = {}, n = {}, o = e.getActiveObjects().map((l) => l.id);\n  Object.values(e.trackItemsMap).forEach((l) => {\n    s.includes(l.id) && (r[l.id] = l);\n  });\n  const a = e.getObjects(\"Transition\").filter((l) => l.top === i.top).map((l) => l.id);\n  Object.values(e.transitionsMap).forEach((l) => {\n    a.includes(l.id) && (n[l.id] = l);\n  });\n  const c = ho({\n    trackItemIds: Ut(s),\n    transitionsMap: Ut(n),\n    trackItemsMap: Ut(r)\n  });\n  t.push(0), c.forEach((l) => {\n    if (l.length === 1) {\n      const h = e.getObjects().find((u) => u.id === l[0].id);\n      o.includes(h.id) || t.push(h.left + h.width);\n    } else {\n      const h = l[l.length - 1], u = e.getObjects().find((d) => d.id === h.id);\n      t.push(u.width + u.left);\n    }\n  });\n}\nfunction i0(i, t) {\n  i.getObjects(\"Helper\").reduce(\n    (r, n) => Math.abs(n.top - t) < Math.abs(r.top - t) ? n : r\n  ).setSelected(!0);\n}\nconst n0 = (i, t, e, s) => {\n  const r = Ql(i);\n  return !r && i instanceof Oe ? {\n    top: 0,\n    left: 0,\n    isInvalidDrop: !0\n  } : r ? s ? i instanceof Oe ? {\n    top: 0,\n    left: 0,\n    isInvalidDrop: !0\n  } : Qy(\n    i,\n    s,\n    t,\n    e\n  ) : Zy(i) : Jy();\n};\nfunction o0(i) {\n  i.on(\"mouse:up\", Jl.bind(i)), i.on(\"object:moving\", th);\n}\nfunction a0(i) {\n  i.off(\"mouse:up\", Jl.bind(i)), i.off(\"object:moving\", th);\n}\nconst c0 = (i) => {\n  Q().canvas.fire(\"track:create\", i);\n}, l0 = (i) => {\n  Q().canvas.fire(\"track-items:moved\", i);\n}, eh = (i) => {\n  var a, c, l;\n  const t = (a = i.target) == null ? void 0 : a.canvas;\n  if (!t) return;\n  const e = Q(), s = t.getActiveObject();\n  if (!s || !t.positionBeforeTransform) return;\n  const r = t.getScenePoint(i.e), o = t.getObjects(\"Track\", \"Helper\").find((h) => {\n    const u = h.getBoundingRect();\n    return r.x >= u.left && r.x <= u.left + u.width && r.y >= u.top && r.y <= u.top + u.height;\n  });\n  if (i.action === \"resizing\") {\n    const h = (e.trackToItemsMap[(c = e.originTrack) == null ? void 0 : c.id] || []).filter((d) => d !== s);\n    s.setCoords();\n    const u = sh(\n      h,\n      s.getBoundingRect()\n    );\n    return t.fire(\"track-items:resized\", {\n      trackId: (l = e.originTrack) == null ? void 0 : l.id,\n      trackItemIds: [s.id],\n      isOverlapped: !!u\n    }), !1;\n  }\n  if (!o)\n    return s == null || s.set(t.positionBeforeTransform), s == null || s.setCoords(), !1;\n  if (o instanceof Ss) {\n    let h;\n    switch (o.kind) {\n      case \"top\":\n        h = 0;\n        break;\n      case \"center\":\n        h = o.metadata.order || 0;\n        break;\n      case \"bottom\":\n        h = -1;\n        break;\n      default:\n        return;\n    }\n    const u = {\n      isSecondaryOverlapped: !1,\n      secondaryTracks: e.secondaryTracks,\n      primaryTracks: e.primaryTracks,\n      primaryPositions: {\n        trackIndex: h,\n        trackId: t.trackIdAfterTransform,\n        positions: t.positionAfterTransform\n      }\n    };\n    c0(u);\n  } else if (o instanceof ue) {\n    const u = {\n      isSecondaryOverlapped: u0(),\n      secondaryTracks: e.secondaryTracks,\n      primaryTracks: e.primaryTracks,\n      primaryPositions: {\n        trackId: t.trackIdAfterTransform,\n        positions: t.positionAfterTransform\n      }\n    };\n    l0(u);\n  }\n};\nfunction h0() {\n  const i = Q(), t = i.canvas, [e] = i.primaryMovingObjects, s = e.id, r = t.positionAfterTransform[s], n = e.getBoundingRect().top, o = r.top - n, a = {};\n  return i.secondaryMovingObjects.forEach((c) => {\n    const l = c.getBoundingRect().top + o, h = i.trackTopToIdMap[l], u = In(\n      i.trackTops,\n      i.originTrack.top,\n      l\n    );\n    a[h] ? a[h].objects.push(c) : a[h] = {\n      objects: [c],\n      index: u\n    };\n  }), a;\n}\nfunction u0() {\n  const i = h0(), t = Q();\n  return Object.keys(i).some((e) => {\n    const s = t.trackToItemsMap[e], r = i[e].objects;\n    return !s || !s.length ? !0 : s.filter((n) => !r.includes(n)).some((n) => sh(\n      r,\n      n.getBoundingRect()\n    ));\n  });\n}\nfunction sh(i, t) {\n  return i.find((s) => {\n    const r = s.getBoundingRect();\n    return t.left < r.left + r.width && t.left + t.width > r.left && t.top < r.top + r.height && t.top + t.height > r.top;\n  });\n}\nconst d0 = (i) => {\n  i.on(\"object:modified\", eh);\n}, f0 = (i) => {\n  i.off(\"object:modified\", eh);\n}, rh = \"drag\", g0 = `${rh}:start`, ih = `${rh}:end`, nh = \"timeline\", p0 = `${nh}:boundingChanged`, m0 = `${nh}:seek`, v0 = \"add:audio\", y0 = \"add:video\", b0 = \"add:image\", _0 = \"add:text\", S0 = [\n  \"transition\",\n  \"image\",\n  \"video\",\n  \"audio\",\n  \"caption\",\n  \"text\"\n];\nlet et, Xs, ws = [];\nfunction T0(i, t) {\n  let e = 1 / 0, s = null;\n  const r = new _(i.x, i.y);\n  return t.forEach((n) => {\n    const o = Math.sqrt(\n      Math.pow(n.left - r.x, 2) + Math.pow(n.top - r.y, 2)\n    );\n    o < e && (e = o, s = n);\n  }), s;\n}\nconst x0 = ({\n  width: i,\n  height: t,\n  id: e,\n  left: s,\n  top: r,\n  type: n,\n  duration: o\n}) => {\n  if (n === \"transition\")\n    return new or({\n      top: 0,\n      left: 0,\n      height: 48,\n      width: 48,\n      id: \"TransitionGuide\"\n    });\n  const a = C.getClass(\"PreviewTrackItem\") || Oe;\n  return new a({\n    top: r,\n    left: s,\n    height: t,\n    width: i,\n    id: e,\n    type: n,\n    duration: o\n  });\n};\nfunction oh(i) {\n  var f;\n  const t = (f = i.e.dataTransfer) == null ? void 0 : f.types[0];\n  if (!t) return;\n  const e = JSON.parse(t), s = e.type;\n  if (!S0.includes(s)) return;\n  const r = e.duration || 5e3, n = this;\n  n.discardActiveObject(), n.setActiveIds([]);\n  const o = D(r, this.tScale), a = this.sizesMap[s];\n  et = x0({\n    width: o,\n    height: a,\n    id: \"TransitionGuide\",\n    left: 0,\n    top: 0,\n    type: s,\n    duration: r\n  }), et.visible = !1, s === \"transition\" && (ws = n.getObjects(\"Transition\"), ws.forEach((g) => {\n    g.visible = !0;\n  }));\n  const c = Q();\n  n.trackIdAfterTransform = \"\", n.positionAfterTransform = {};\n  const l = et, h = [et];\n  at({\n    activeTrackToItemsMap: {},\n    primaryTracks: {},\n    secondaryTracks: {},\n    trackTops: [],\n    trackToItemsMap: {},\n    activeObjects: [],\n    trackTopToIdMap: {},\n    isDragOver: !1\n  }), at({ activeObjects: h });\n  const u = n.getObjects(\"Track\"), d = n.getTrackItems();\n  u.forEach((g) => {\n    const p = d.filter((m) => g.items.includes(m.id));\n    c.trackToItemsMap[g.id] = p, c.trackTopToIdMap[g.top] = g.id, c.trackTops.push(g.top);\n  }), c.trackTops.sort((g, p) => g - p), c.primaryMovingObjects = h, c.primaryMovingObjects = c.primaryMovingObjects.sort(\n    (g, p) => g.left - p.left\n  ), l && (n.positionBeforeTransform = {\n    top: l.top,\n    left: l.left\n  }), c.placeholderMovingObjects = c.primaryMovingObjects.map((g) => {\n    const p = g.getBoundingRect();\n    c.objectInitialPositions[g.id] = {\n      top: p.top,\n      left: p.left\n    };\n    const m = new er({\n      id: `${g.id}-placeholder`,\n      left: p.left,\n      top: p.top,\n      width: p.width,\n      height: p.height\n    });\n    return m.visible = !1, m.draggedObject = g, m;\n  }), n.add(...c.placeholderMovingObjects), n.add(et), (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(g0);\n}\nconst ah = (i) => {\n  const t = Q();\n  Vl(i, t.placeholderMovingObjects), i && (Pi(i, i.getObjects()), Gl(i.getObjects(\"Helper\")));\n};\nfunction ch() {\n  if (ah(this), at({ draggingOverTrack: null, isPointerOverHelperTrack: !1 }), !et) return;\n  (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(ih);\n  const i = this;\n  ws.forEach((t) => {\n    t.strokeDashArray = [], t.setSelected(!1), t.kind === \"none\" && (t.visible = !1);\n  }), i.getObjects(\"Helper\", \"Track\").forEach((t) => {\n    t.setSelected && t.setSelected(!1);\n  }), i.remove(et);\n}\nfunction lh(i) {\n  const t = Q(), e = t.placeholderMovingObjects[0];\n  if (e.visible || (et.visible = !0, e.visible = !0), t.activeObjects[0] instanceof or && (e.visible = !1), !et) return !1;\n  i.e.preventDefault();\n  const s = this, r = s.getViewportPoint(i.e), n = [...this.viewportTransform];\n  et.set({\n    left: r.x - 16 - n[4],\n    top: r.y - n[5] - et.height / 2\n  });\n  const o = T0(r, ws);\n  o && (Xs = o, o.strokeDashArray = [5, 1], o.setSelected(!0)), ws.forEach((c) => {\n    c !== o && c.setSelected(!1);\n  }), at({ isDragOver: !0 }), et.setCoords();\n  const a = {\n    target: et,\n    action: \"drag\",\n    originX: \"center\",\n    originY: \"center\",\n    offsetX: r.x - et.left,\n    offsetY: r.y - et.top,\n    scaleX: et.scaleX,\n    scaleY: et.scaleY\n  };\n  s.fire(\"object:moving\", {\n    target: et,\n    e: i.e,\n    pointer: r,\n    transform: a\n  }), s.requestRenderAll();\n}\nfunction hh(i) {\n  var o;\n  const t = this;\n  ah(t);\n  const e = Q(), s = e.draggingOverTrack;\n  at({ draggingOverTrack: null, isPointerOverHelperTrack: !1 });\n  const r = (o = i.e.dataTransfer) == null ? void 0 : o.types[0], n = JSON.parse(i.e.dataTransfer.getData(r));\n  if (n.type !== \"transition\") {\n    const a = e.activeObjects[0], c = Y(a.left, t.tScale);\n    if (s instanceof ue)\n      if (e.placeholderMovingObjects[0].opacity !== 0) {\n        const h = en(s, this.getObjects(\"Track\"));\n        if (s.magnetic) {\n          const u = e.initialTrackPoints[e.initialTrackPoints.length - 1], d = Y(u, t.tScale);\n          Yr(n, h, d);\n        } else Yr(n, h, c);\n      } else {\n        const h = i.viewportPoint, u = [...t.viewportTransform], d = h.y - u[5], g = t.getObjects(\"Helper\").reduce(\n          (m, b) => Math.abs(b.top - d) < Math.abs(m.top - d) ? b : m\n        ), p = en(g, this.getObjects(\"Track\"));\n        Yr(n, p, c, !0);\n      }\n    else {\n      const l = en(\n        s,\n        this.getObjects(\"Track\")\n      );\n      Yr(n, l, c, !0);\n    }\n    this.remove(a), this.requestRenderAll();\n    return;\n  }\n  if (et) {\n    if (Xs) {\n      const a = Xs.id, c = Ty(n, [\"kind\", \"direction\"]);\n      Object.keys(c).forEach((S) => {\n        S === \"kind\" ? Xs.kind = c[S] : Xs[S] = c[S];\n      });\n      const l = Ut(this.trackItemIds), h = Ut(this.transitionsMap), u = Ut(this.trackItemsMap);\n      h[a] = {\n        ...h[a],\n        ...c\n      };\n      const d = xs({\n        trackItemIds: l,\n        transitionsMap: h,\n        trackItemsMap: u\n      }), g = h[a].fromId, p = d.find((S) => S.find((w) => w.id === g)) || [], m = w0(\n        p\n      ), b = C0(\n        this.trackItemsMap,\n        m\n      );\n      this.trackItemsMap = b, this.transitionsMap[a] = {\n        ...this.transitionsMap[a],\n        ...c\n      }, this.transitionGroups = xs({\n        trackItemIds: this.trackItemIds,\n        transitionsMap: this.transitionsMap,\n        trackItemsMap: this.trackItemsMap\n      }), this.updateTrackItemCoords(), this.adjustMagneticTrack(), this.calcBounding(), this.updateTransitions(), this.refreshTrackLayout(), this.updateState({ kind: \"add:transition\", updateHistory: !0 });\n    }\n    ws.forEach((a) => {\n      a.strokeDashArray = [], a.setSelected(!1), a.kind === \"none\" && (a.visible = !1);\n    }), t.remove(et), t.requestRenderAll(), (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(ih);\n  }\n}\nconst w0 = (i) => {\n  const [t] = i, e = i.filter(\n    (r) => r.type !== \"transition\"\n  );\n  let s = t.display.from;\n  return e.map((r) => {\n    const n = r.display.to - r.display.from, o = {\n      from: s,\n      to: s + n\n    };\n    return s = o.to, {\n      ...r,\n      display: o\n    };\n  });\n}, C0 = (i, t) => {\n  let e = i;\n  return t.forEach((s) => {\n    e[s.id] = s;\n  }), e;\n}, en = (i, t) => {\n  const e = t.sort((o, a) => o.top - a.top);\n  if (e.length === 0) return 0;\n  const s = e[e.length - 1];\n  if (s.top + s.height <= i.top)\n    return e.length;\n  const r = i.top;\n  return e.reduce((o, a, c) => {\n    const l = Math.abs(a.top - r), h = Math.abs(e[o].top - r);\n    return l < h ? c : o;\n  }, 0);\n}, Yr = (i, t, e, s) => {\n  i.type === \"image\" ? (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(b0, {\n    payload: {\n      ...i,\n      id: Ws(),\n      display: { from: e }\n    },\n    options: { trackIndex: t, isNewTrack: s }\n  }) : i.type === \"video\" ? (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(y0, {\n    payload: {\n      ...i,\n      id: Ws(),\n      display: { from: e }\n    },\n    options: { trackIndex: t, isNewTrack: s }\n  }) : i.type === \"audio\" ? (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(v0, {\n    payload: {\n      ...i,\n      id: Ws(),\n      display: { from: e }\n    },\n    options: { trackIndex: t, isNewTrack: s }\n  }) : i.type === \"text\" && (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(_0, {\n    payload: {\n      ...i,\n      id: Ws(),\n      display: { from: e }\n    },\n    options: { trackIndex: t, isNewTrack: s }\n  });\n};\nfunction O0(i) {\n  i.on(\"dragover\", lh), i.on(\"dragenter\", oh), i.on(\"dragleave\", ch), i.on(\"drop\", hh);\n}\nfunction k0(i) {\n  i.off(\"dragover\", lh), i.off(\"dragenter\", oh), i.off(\"dragleave\", ch), i.off(\"drop\", hh);\n}\nfunction uh(i) {\n  const t = this.height < this.bounding.height;\n  if (!(this.width < this.bounding.width) && !t) return;\n  const s = this.viewportTransform;\n  let r = s[4], n = s[5];\n  const o = 2;\n  i.e.shiftKey ? r = r - i.e.deltaY * o : (t && (n = n - i.e.deltaY * o), r = r - i.e.deltaX * o), this.setViewportPos(r, n);\n}\nfunction dh() {\n  const i = this, t = i.getActiveObject(), e = i.getActiveObjects(), s = e.map((n) => n.id), r = e.filter((n) => {\n    if (e.length === 1)\n      return !0;\n    if (n.id && !(n instanceof Jt))\n      return !0;\n    if (n instanceof Jt && s.includes(n.fromId) && s.includes(n.toId))\n      return !0;\n  }).map((n) => n.id);\n  t instanceof Ot ? (t.borderColor = \"rgba(0, 216, 214,0.75)\", t.hasControls = !1, t.hoverCursor = \"default\", t.borderScaleFactor = 1, t.padding = 0, t.getObjects().forEach((n) => {\n    n.setSelected(!0);\n  })) : t == null || t.setSelected(!0), this.setActiveIds(r);\n}\nfunction fh(i) {\n  const t = this, e = t.getActiveObject();\n  e instanceof Ot && (e.borderColor = \"transparent\", e.hasControls = !1, e.hoverCursor = \"default\"), i.selected.forEach((n) => {\n    n.setSelected(!0);\n  }), i.deselected.forEach((n) => {\n    n.setSelected(!1);\n  });\n  const r = t.getActiveObjects().map((n) => n.id);\n  this.setActiveIds(r);\n}\nfunction gh(i) {\n  i.deselected.forEach((t) => {\n    t.setSelected(!1);\n  });\n}\nconst M0 = (i) => {\n  i.on(\"selection:created\", dh), i.on(\"selection:updated\", fh), i.on(\"selection:cleared\", gh), i.on(\"mouse:wheel\", uh);\n}, I0 = (i) => {\n  i.off(\"mouse:wheel\", uh), i.off(\"selection:created\", dh), i.off(\"selection:updated\", fh), i.off(\"selection:cleared\", gh);\n}, ph = () => {\n  var n, o;\n  const i = Q(), t = i.canvas, e = i.draggingOverTrack;\n  t.updateTrackItemCoords(!0);\n  const s = e == null ? void 0 : e.magnetic, r = new Set(i.activeObjects.map((a) => a.id));\n  if (s) {\n    const a = e.id, l = i.trackToItemsMap[a].sort((p, m) => p.left - m.left), h = i.placeholderMovingObjects, u = ((n = h[0]) == null ? void 0 : n.top) || 0, d = h.reduce(\n      (p, m) => p + m.width,\n      0\n    ), f = Math.min(...h.map((p) => p.left));\n    let g = 0;\n    l.forEach((p) => {\n      r.has(p.id) || p.top === u && (Math.abs(f - g) < 1 && (g += d), p.left = g, g += p.width);\n    });\n  } else if (e instanceof ue && i.orderNormalTrack) {\n    const a = e.items, c = t.getTrackItems().filter(\n      (x) => !r.has(x.id) && a.includes(x.id)\n    ), l = c.sort((x, I) => x.left - I.left), h = i.placeholderMovingObjects[0], u = i.placeholderMovingObjects[i.placeholderMovingObjects.length - 1], d = h.left, f = u.left - h.left + u.width, g = l.find((x, I) => {\n      if (x.left >= d - 1) return l[I];\n    }), p = D(\n      ((o = g == null ? void 0 : g.display) == null ? void 0 : o.from) || 0,\n      t.tScale\n    ), m = c.map((x) => x.id), b = {}, S = {};\n    Object.values(t.trackItemsMap).forEach((x) => {\n      m.includes(x.id) && (b[x.id] = x);\n    });\n    const w = t.getObjects(\"Transition\").filter((x) => x.top === c[0].top).map((x) => x.id);\n    Object.values(t.transitionsMap).forEach((x) => {\n      w.includes(x.id) && (S[x.id] = x);\n    });\n    const k = ho({\n      trackItemIds: Ut(c.map((x) => x.id)),\n      transitionsMap: Ut(S),\n      trackItemsMap: Ut(b)\n    });\n    c.filter(\n      (x) => x.left >= d - 1\n    ).forEach((x) => {\n      const I = D(x.display.from, t.tScale), M = Object.values(t.transitionsMap).find(\n        (R) => R.kind !== \"none\" && R.toId === x.id\n      );\n      let E = 0;\n      k.forEach((R) => {\n        if (R.map((F) => F == null ? void 0 : F.id).includes(x.id)) {\n          for (const F of R)\n            if (F.type === \"transition\")\n              if ((M == null ? void 0 : M.id) === F.id) {\n                E = E + D(F.duration, t.tScale) / 2;\n                break;\n              } else\n                E = E + D(F.duration, t.tScale);\n            else if (F.id === x.id) break;\n        }\n      }), p <= d + f && (x.left = I + f - E + d - p);\n    });\n  }\n  t.alignTransitionsToTrack(!1);\n};\nfunction D0(i) {\n  i.on(\"object:moving\", ph);\n}\nfunction j0(i) {\n  i.off(\"object:moving\", ph);\n}\nlet Ft, uo = !1;\nfunction E0(i, t) {\n  const e = i.canvas;\n  if (qd.includes(i.type)) {\n    Ft || (Ft = i);\n    const s = i.top, r = i.height, n = i.left, o = i.width, a = t.x, c = t.y, l = Math.abs(c - (s + r / 2)) <= Jd;\n    Math.abs(a - n) <= qo && l || Math.abs(a - n - o) <= qo && l ? (e.hoverCornerItem = !0, i.hoverCursor = \"ew-resize\") : (e.hoverCornerItem = !1, i.hoverCursor = \"move\"), e.requestRenderAll();\n  }\n}\nfunction mh(i) {\n  const t = this, e = t.findTarget(i.e), s = t.getScenePoint(i.e);\n  e && (e.isSelected && Ft && (e.hoverCursor = \"default\"), E0(e, s));\n}\nfunction vh() {\n  Ft && (Ft.lockMovementX = !1, Ft.lockMovementY = !1, Ft = void 0);\n}\nfunction yh(i) {\n  Ft && (uo || Ft._renderControls(i.ctx));\n}\nfunction bh() {\n  Ft && (Ft = void 0, this.requestRenderAll());\n}\nfunction _h() {\n  uo = !0;\n}\nfunction Sh() {\n  uo = !1;\n}\nfunction P0(i) {\n  i.on(\"mouse:out\", bh.bind(i)), i.on(\"mouse:up\", vh.bind(i)), i.on(\"mouse:move\", mh.bind(i)), i.on(\"after:render\", yh.bind(i)), i.on(\"object:resizing\", _h.bind(i)), i.on(\"object:modified\", Sh.bind(i));\n}\nfunction A0(i) {\n  i.off(\"mouse:out\", bh.bind(i)), i.off(\"mouse:up\", vh.bind(i)), i.off(\"mouse:move\", mh.bind(i)), i.off(\"after:render\", yh.bind(i)), i.off(\"object:resizing\", _h.bind(i)), i.off(\"object:modified\", Sh.bind(i));\n}\nconst F0 = (i) => {\n  at({ canvas: i }), Ay(i), Iy(i), Ry(i), Hy(i), Vy(i), o0(i), d0(i), O0(i), M0(i), D0(i), P0(i);\n}, R0 = (i) => {\n  at({ canvas: null }), Fy(i), Dy(i), Ly(i), Yy(i), Gy(i), a0(i), f0(i), k0(i), I0(i), j0(i), A0(i);\n};\nclass L0 {\n  removeTransitions() {\n    const t = this.getObjects(\"Transition\");\n    this.remove(...t);\n  }\n  renderTransitions() {\n    this.removeTransitions(), this.transitionIds.forEach((t) => {\n      const e = this.transitionsMap[t], s = e.fromId, r = e.toId, n = this.getObjects(), o = n.find((d) => d.id === s), a = n.find((d) => d.id === r);\n      if (!o || !a)\n        return;\n      const c = D(e.duration, this.tScale), l = o.left + o.width - c / 2, h = o.height, u = new Jt({\n        id: e.id,\n        left: l,\n        top: o.top,\n        height: h,\n        width: c,\n        tScale: this.tScale,\n        duration: e.duration,\n        fromId: o.id,\n        toId: a.id,\n        kind: e.kind\n      });\n      e.kind === \"none\" && (u.visible = !1), u && this.add(u);\n    });\n  }\n  updateTrackTransitionsItemCoords() {\n    this.pauseEventListeners(), this.getObjects(\"Transition\").forEach((e) => {\n      e.tScale = this.tScale, e.updateCoords(), e.setCoords();\n    }), this.resumeEventListeners();\n  }\n  alignTransitionsToTrack(t = !0) {\n    const e = t ? [] : this.getActiveObjects().map((s) => s.id);\n    this.transitionIds.forEach((s) => {\n      const r = this.getObjects(\"Transition\").find(\n        (n) => n.id === s\n      );\n      if (r instanceof Jt) {\n        const n = this.getObjects().find(\n          (c) => c.id === r.fromId && !e.includes(c.id)\n        );\n        if (!n) return;\n        const o = D(r.duration, this.tScale), a = n.left + n.width - o / 2;\n        r.set({\n          left: a,\n          top: n.top\n        }), r.setCoords();\n      }\n    });\n  }\n  updateTransitions(t = !0) {\n    t && this.pauseEventListeners();\n    const e = this.getObjects(\"Track\"), s = this.getObjects(\"Video\", \"Image\");\n    this.removeTransitions();\n    const r = {}, n = [];\n    e.forEach((a) => {\n      const c = s.filter((l) => a.items.includes(l.id)).sort((l, h) => l.left - h.left);\n      for (let l = 0; l < c.length - 1; l++) {\n        const h = c[l], u = c[l + 1];\n        if (Math.abs(h.left + h.width - u.left) <= 1) {\n          const d = `${h.id}-${u.id}`;\n          if (this.transitionIds.includes(d)) {\n            const g = this.transitionsMap[d];\n            r[d] = g;\n          } else {\n            const g = {\n              id: d,\n              duration: 1500,\n              fromId: h.id,\n              toId: u.id,\n              kind: \"none\",\n              trackId: a.id,\n              type: \"transition\"\n            };\n            r[d] = g;\n          }\n          n.push(d);\n        }\n      }\n    }), this.transitionIds = n, this.transitionsMap = r, this.renderTransitions();\n    const o = this.getObjects(\"Transition\");\n    this.updateCachingActiveObjects(o), this.transitionGroups = xs({\n      trackItemIds: this.trackItemIds,\n      transitionsMap: this.transitionsMap,\n      trackItemsMap: this.trackItemsMap\n    }), t && this.resumeEventListeners();\n  }\n}\nfunction Th(i) {\n  const { secondaryTracks: t, primaryTracks: e, primaryPositions: s } = i, { positions: r, trackIndex: n } = s, o = n === -1 ? this.tracks.length : n, [a] = Object.keys(e), c = this.tracks.find(\n    (p) => p.id === a\n  ), l = e[a], h = {\n    id: Ws(),\n    items: l.objects.map((p) => p.id),\n    type: c.type,\n    accepts: c.accepts\n  }, u = co(\n    Object.keys(t).map((p) => t[p].objects.map((m) => m.id))\n  );\n  let d = rr(this.tracks, [\n    ...Object.keys(r),\n    ...u\n  ]);\n  const f = [];\n  Object.keys(t).forEach((p) => {\n    const { objects: m, index: b } = t[p], S = this.tracks.find(\n      (O) => O.id === p\n    ), w = m.map((O) => O.id).filter((O) => !this.transitionIds.includes(O)), k = {\n      id: gr(),\n      items: w,\n      type: S.type,\n      accepts: S.accepts,\n      tempIndex: b\n    };\n    f.push(k);\n  });\n  const g = ql(h, f);\n  g.length && d.splice(o, 0, ...g), this.tracks = d, this.renderTracks(), this.refreshTrackLayout(), this.alignItemsToTrack(), this.uodateTrackItemIdsOrdering(), this.refreshTrackItemsForTransitions(), this.adjustMagneticTrack(), this.updateTransitions(!0), this.updateState({ updateHistory: !0, kind: \"update\" });\n}\nfunction xh(i) {\n  const {\n    isSecondaryOverlapped: t,\n    secondaryTracks: e,\n    primaryTracks: s,\n    primaryPositions: r\n  } = i, { trackId: n, positions: o } = r, a = this.tracks.find((b) => b.id === n), h = Q().primaryMovingObjects.sort((b, S) => b.left - S.left);\n  h.forEach((b, S) => {\n    h[S - 1] && b.left - h[S - 1].left;\n  });\n  const u = this.tracks.findIndex((b) => b.id === n), d = co(\n    Object.keys(e).map((b) => e[b].objects.map((S) => S.id))\n  );\n  let f = rr(this.tracks, [\n    ...Object.keys(o),\n    ...d\n  ]);\n  Object.keys(s).forEach((b) => {\n    this.pauseEventListeners();\n    const { objects: S } = s[b];\n    S.forEach((O) => {\n      if (O.isMain && (a != null && a.magnetic)) return;\n      const x = o[O.id];\n      O.left = x == null ? void 0 : x.left;\n    }), this.resumeEventListeners();\n    const w = r.trackId, k = f.find((O) => O.id === w);\n    k == null || k.items.push(...Object.keys(o)), this.tracks = f;\n  });\n  const g = this.tracks[u], p = [];\n  Object.keys(e).forEach((b) => {\n    const { objects: S, index: w } = e[b], k = S.filter((I) => I.type !== \"transition\").map((I) => I.id), [O] = k, x = this.trackItemsMap[O];\n    if (t && x) {\n      const I = {\n        id: gr(),\n        items: k,\n        type: x.type,\n        accepts: this.acceptsMap[x.type],\n        tempIndex: w\n      };\n      p.push(I);\n    } else {\n      const I = f[u + w];\n      I == null || I.items.push(...k), this.tracks = f;\n    }\n  });\n  const m = ql(g, p);\n  m.length && f.splice(u, 1, ...m), this.tracks = f, this.renderTracks(), this.alignItemsToTrack(), this.uodateTrackItemIdsOrdering(), this.refreshTrackItemsForTransitions(), this.adjustMagneticTrack(), this.updateTransitions(!0), this.updateState({ updateHistory: !0, kind: \"update\" });\n}\nfunction wh({\n  trackItemIds: i,\n  isOverlapped: t\n}) {\n  const [e] = i;\n  if (!e) return;\n  if (!this.getObjects(\"Transition\").find(\n    (r) => r.id === e\n  )) {\n    const r = this.tracks.find(\n      (n) => n.items.includes(e)\n    );\n    if (t) {\n      const n = rr(this.tracks, i), o = {\n        id: gr(),\n        items: [e],\n        type: r.type,\n        accepts: r.accepts\n      }, a = this.tracks.findIndex(\n        (c) => c.id === r.id\n      );\n      n.splice(a, 0, o), this.tracks = n;\n    }\n  }\n  this.renderTracks(), this.alignItemsToTrack(), this.refreshTrackItemsForTransitions(), this.adjustMagneticTrack(), this.updateTransitions(!0), this.uodateTrackItemIdsOrdering(), this.updateState({ updateHistory: !0, kind: \"update\" });\n}\nlet Dn = { x: 0, y: 0 };\nfunction B0(i) {\n  Dn = i.scenePoint;\n}\nfunction Ch(i) {\n  const t = i.scenePoint;\n  if ((Dn.x === t.x || Dn.y === t.y) && !i.target) {\n    const s = this.getElement().getBoundingClientRect(), r = this.viewportTransform, n = i.e.clientX - s.left - r[4], o = Y(n, this.scale.zoom);\n    (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(m0, { payload: { time: o } });\n  }\n}\nconst W0 = (i) => {\n  i.on(\"track:create\", Th.bind(i)), i.on(\"track-items:resized\", wh.bind(i)), i.on(\"track-items:moved\", xh.bind(i)), i.on(\"mouse:up\", Ch.bind(i)), i.on(\"mouse:down\", B0.bind(i));\n};\nfunction X0(i) {\n  i.off(\"track:create\", Th.bind(i)), i.off(\"track-items:resized\", wh.bind(i)), i.off(\"track-items:moved\", xh.bind(i)), i.off(\"mouse:up\", Ch.bind(i));\n}\nfunction z0(i, t) {\n  return t.forEach((e) => {\n    Object.getOwnPropertyNames(e.prototype).forEach((s) => {\n      s !== \"constructor\" && Object.defineProperty(\n        i.prototype,\n        s,\n        Object.getOwnPropertyDescriptor(e.prototype, s) || /* @__PURE__ */ Object.create(null)\n      );\n    });\n  }), i;\n}\nconst H0 = {\n  video: [\"*\"],\n  image: [\"*\"],\n  audio: [\"*\"],\n  text: [\"*\"],\n  caption: [\"*\"],\n  template: [\"*\"],\n  composition: [\"*\"],\n  illustration: [\"*\"],\n  shape: [\"*\"]\n}, Y0 = {\n  video: 42,\n  image: 42,\n  audio: 42,\n  text: 42,\n  caption: 42,\n  template: 42,\n  illustration: 42,\n  composition: 42,\n  shape: 42\n}, V0 = [\n  \"video\",\n  \"image\",\n  \"audio\",\n  \"text\",\n  \"caption\",\n  \"template\",\n  \"illustration\",\n  \"composition\"\n], G0 = (i = {}) => {\n  const t = Object.assign({}, H0, i), e = {};\n  return Object.keys(t).forEach((s) => {\n    const r = t[s];\n    e[s] = r.includes(\"*\") ? V0 : r;\n  }), e;\n}, N0 = (i = {}) => {\n  const t = Object.assign({}, Y0, i), e = {};\n  return i ? (Object.keys(t).forEach((s) => {\n    const r = t[s];\n    e[s] = r;\n  }), e) : t;\n};\nlet Oh, kh, Mh, Ih, Dh, jh, Eh, Ph;\nconst U0 = (i) => {\n  Oh = i.state.subscribeToActiveIds(\n    ({ activeIds: t }) => {\n      const e = i.activeIds;\n      if (t.length === 1 && e.length === 1) {\n        const s = t[0], r = e[0], o = i.state.getState().structure;\n        let a = \"\";\n        if (o.forEach((c) => {\n          c.id === r && c.items.includes(s) && (a = c.id);\n        }), a !== \"\") return;\n        i.selectTrackItemByIds([s]);\n      } else\n        i.selectTrackItemByIds(t);\n    }\n  ), Ph = i.state.subscribeToTracks(\n    ({ tracks: t, changedTracks: e }) => {\n      e.length && (i.tracks = t, i.renderTracks(), i.refreshTrackLayout());\n    }\n  ), Eh = i.state.subscribeToUpdateAnimations(\n    ({ trackItemsMap: t, changedAnimationIds: e }) => {\n      if (e != null && e.length) {\n        const s = i.getTrackItems();\n        i.trackItemsMap = t, s.forEach((r) => {\n          if (e.includes(r.id)) {\n            const n = t[r.id].animations;\n            n && r.set({\n              animations: n\n            });\n          }\n        });\n      }\n    }\n  ), jh = i.state.subscribeToUpdateTrackItemTiming(\n    ({ trackItemsMap: t, changedTrimIds: e, changedDisplayIds: s }) => {\n      if (e && i.getTrackItems().forEach((n) => {\n        if (e.includes(n.id)) {\n          const o = t[n.id].trim;\n          o && n.set({\n            trim: {\n              from: o.from,\n              to: o.to\n            }\n          });\n        }\n      }), s) {\n        const r = i.getTrackItems();\n        i.pauseEventListeners(), r.forEach((n) => {\n          if (s.includes(n.id)) {\n            const o = t[n.id].display;\n            o && n.set({\n              display: o\n            });\n          }\n        }), i.resumeEventListeners();\n      }\n      i.requestRenderAll();\n    }\n  ), Dh = i.state.subscribeToScale((t) => {\n    i.setScale(t.scale);\n  }), Ih = i.state.subscribeToUpdateItemDetails((t) => {\n    const e = i.getTrackItems();\n    if (e.length === 0) return;\n    const s = i.state.getState(), r = t.trackItemDetailsMap, n = s.trackItemsMap;\n    e.forEach((o) => {\n      const a = r[o.id];\n      if (a)\n        if (o instanceof _t || o instanceof Qs || o instanceof ft) {\n          if (a.type === \"video\" || a.type === \"image\" || a.type === \"audio\") {\n            const c = n[o.id];\n            if (o.src !== a.details.src && o.setSrc && o.setSrc(a.details.src), a.type === \"video\" || a.type === \"audio\") {\n              const h = c.display.to - c.display.from, u = D(\n                h,\n                i.scale.zoom,\n                c.playbackRate\n              );\n              o.set({\n                duration: c.duration,\n                display: c.display,\n                trim: c.trim,\n                width: u\n              }), o.setCoords();\n            }\n          }\n        } else (o instanceof tr || o instanceof sr) && (a.type === \"text\" || a.type === \"caption\") && o.set({ text: a.details.text });\n    }), i.requestRenderAll();\n  }), Mh = i.state.subscribeToHistory((t) => {\n    i.tracks = t.tracks, i.trackItemsMap = t.trackItemsMap, i.trackItemIds = t.trackItemIds, i.trackItemDetailsMap = t.trackItemDetailsMap, i.transitionIds = t.transitionIds, i.transitionsMap = t.transitionsMap, i.transitionGroups = xs({\n      trackItemIds: i.trackItemIds,\n      transitionsMap: i.transitionsMap,\n      trackItemsMap: i.trackItemsMap\n    }), i.renderTracks(), i.refreshTrackLayout(), i.updateTrackItemCoords(), i.alignItemsToTrack(), i.alignTransitionsToTrack(), i.adjustMagneticTrack(), i.updateTransitions(), i.calcBounding(), i.duration = pl(i.trackItemsMap);\n  }), kh = i.state.subscribeToAddOrRemoveItems(() => {\n    const t = i.getTrackItems().map((n) => n.id), e = i.state.getState(), s = e.trackItemIds, r = [];\n    t.forEach((n) => {\n      s.includes(n) || r.push(n);\n    }), i.deleteTrackItemById(r), i.tracks = e.tracks, i.trackItemsMap = e.trackItemsMap, i.trackItemDetailsMap = e.trackItemDetailsMap, i.transitionIds = e.transitionIds, i.transitionsMap = e.transitionsMap, s.forEach((n) => {\n      if (!t.includes(n)) {\n        const a = {\n          ...e.trackItemsMap[n],\n          details: {\n            ...e.trackItemDetailsMap[n].details\n          }\n        };\n        i.addTrackItem(a);\n      }\n    }), i.trackItemIds = e.trackItemIds, i.activeIds = e.activeIds, i.transitionGroups = xs({\n      trackItemIds: i.trackItemIds,\n      transitionsMap: i.transitionsMap,\n      trackItemsMap: i.trackItemsMap\n    }), i.renderTracks(), i.alignItemsToTrack(), i.updateTrackItemCoords(), i.calcBounding(), i.updateTransitions(), i.refreshTrackLayout(), i.selectTrackItemByIds(e.activeIds);\n  });\n}, $0 = (i) => {\n  Oh.unsubscribe(), kh.unsubscribe(), Mh.unsubscribe(), Ih.unsubscribe(), Dh.unsubscribe(), jh.unsubscribe(), Eh.unsubscribe(), Ph.unsubscribe();\n}, Aa = (i, t) => {\n  let e = !1;\n  const s = [];\n  return t.forEach((r) => {\n    r.containsPoint(i) && (s.push(r), e = !0);\n  }), { isOverObject: e, overObjects: s };\n};\nfunction q0(i) {\n  return JSON.parse(JSON.stringify(i));\n}\nclass K0 extends vn {\n  constructor(e, s) {\n    var r;\n    super(e, s);\n    T(this, \"acceptsMap\");\n    T(this, \"sizesMap\", {});\n    // Declare properties from state\n    T(this, \"tracks\", []);\n    T(this, \"hoverCornerItem\", !1);\n    T(this, \"trackItemsMap\", {});\n    T(this, \"trackItemIds\", []);\n    T(this, \"transitionIds\", []);\n    T(this, \"transitionsMap\", {});\n    T(this, \"trackItemDetailsMap\", {});\n    T(this, \"scale\");\n    T(this, \"duration\");\n    T(this, \"bounding\");\n    T(this, \"onScroll\");\n    T(this, \"onResizeCanvas\");\n    T(this, \"tScale\");\n    T(this, \"state\");\n    T(this, \"activeIds\", []);\n    T(this, \"spacing\");\n    T(this, \"guideLineColor\");\n    T(this, \"transitionGroups\", []);\n    this.bounding = s.bounding || {\n      width: s.width || 0,\n      height: s.height || 0\n    }, this.tScale = ((r = s.scale) == null ? void 0 : r.zoom) || 1, this.state = s.state, this.onScroll = s.onScroll, this.onResizeCanvas = s.onResizeCanvas, this.acceptsMap = G0(s.acceptsMap), this.sizesMap = N0(s.sizesMap), this.spacing = Wy(s.spacing), this.positionAfterTransform = {}, this.initializeCanvasDefaults(), this.scale = s.scale, this.duration = s.duration, this.guideLineColor = s.guideLineColor || vt, this.initEventListeners();\n  }\n  static registerItems(e) {\n    Object.keys(e).forEach((s) => {\n      C.setClass(e[s], s);\n    });\n  }\n  initializeCanvasDefaults() {\n    const e = this.viewportTransform;\n    e[4] = this.spacing.left, Object.assign(nt.ownDefaults, {\n      borderColor: \"transparent\",\n      cornerColor: \"white\",\n      cornerStrokeColor: \"transparent\",\n      strokeWidth: 0,\n      borderOpacityWhenMoving: 1,\n      borderScaleFactor: 1,\n      cornerSize: 8,\n      cornerStyle: \"rect\",\n      centeredScaling: !1,\n      centeredRotation: !0,\n      transparentCorners: !1\n    });\n  }\n  // detect if the mouse click does not land on any item -> clean the selection and generate another selection\n  __onMouseDown(e) {\n    const s = this.getScenePoint(e), r = this._activeObject, n = this.getActiveObjects();\n    if (n.length === 0) {\n      super.__onMouseDown(e);\n      return;\n    }\n    const { isOverObject: o } = Aa(\n      s,\n      n\n    );\n    if (r && (r == null ? void 0 : r.findControl(\n      this.getViewportPoint(e),\n      zy(e)\n    ))) {\n      super.__onMouseDown(e);\n      return;\n    }\n    const a = this.getTrackItems(), c = this.getObjects(\"Transition\"), { isOverObject: l, overObjects: h } = Aa(\n      s,\n      [...c, ...a]\n    );\n    l ? o ? super.__onMouseDown(e) : (this.setActiveIds([h[0].id]), super.__onMouseDown(e)) : (this.discardActiveObject(), this.requestRenderAll(), this.setActiveIds([]), this._groupSelector = {\n      x: s.x,\n      y: s.y,\n      deltaY: 0,\n      deltaX: 0\n    }, super.__onMouseDown(e));\n  }\n  _setupCurrentTransform(e, s, r) {\n    var n;\n    if (this.hoverCornerItem) {\n      const o = this.getScenePoint(e), { key: a = \"\", control: c } = s.getActiveControl() || {}, l = c && ((n = c.getActionHandler(e, s, c)) == null ? void 0 : n.bind(c)), h = this._getOriginFromCorner(s, a), u = {\n        target: s,\n        action: \"resizing\",\n        actionHandler: l,\n        actionPerformed: !1,\n        corner: a,\n        scaleX: s.scaleX,\n        scaleY: s.scaleY,\n        skewX: s.skewX,\n        skewY: s.skewY,\n        offsetX: o.x - s.left,\n        offsetY: o.y - s.top,\n        originX: h.x,\n        originY: h.y,\n        ex: o.x,\n        ey: o.y,\n        lastX: o.x,\n        lastY: o.y,\n        theta: s.angle * Math.PI / 180,\n        width: s.width,\n        height: s.height,\n        shiftKey: e.shiftKey,\n        altKey: !1,\n        original: {\n          scaleX: s.scaleX,\n          scaleY: s.scaleY,\n          skewX: s.skewX,\n          skewY: s.skewY,\n          angle: s.angle,\n          left: s.left,\n          flipX: s.flipX,\n          flipY: s.flipY,\n          top: s.top,\n          originX: h.x,\n          originY: h.y\n        }\n      };\n      this._currentTransform = u, this.fire(\"before:transform\", {\n        e,\n        transform: u\n      });\n    } else\n      super._setupCurrentTransform(e, s, r);\n  }\n  initEventListeners() {\n    W0(this), F0(this), U0(this);\n  }\n  setActiveIds(e) {\n    this.activeIds = e, this.state.updateState(\n      {\n        activeIds: q0(this.activeIds)\n      },\n      {\n        kind: \"layer:selection\",\n        updateHistory: !1\n      }\n    );\n  }\n  updateState(e = { updateHistory: !1 }) {\n    this.filterEmptyTracks(), this.synchronizeTrackItemsState(), this.requestRenderAll(), this.duration = this.getDurationBasedOnTrackItemsPosition(), this.calcBounding(), this.refreshTrackLayout(), this.setTrackItemCoords();\n    const s = this.getUpdatedState();\n    this.state.updateState(s, e);\n  }\n  getUpdatedState() {\n    const e = this.getDurationBasedOnTrackItemsPosition();\n    return {\n      tracks: this.tracks,\n      trackItemIds: this.trackItemIds,\n      trackItemsMap: this.trackItemsMap,\n      transitionIds: this.transitionIds,\n      transitionsMap: this.transitionsMap,\n      scale: this.scale,\n      duration: e\n    };\n  }\n  getDurationBasedOnTrackItemsPosition() {\n    const e = this.getTrackItems().map((n) => n.getBoundingRect()), s = e.reduce((n, o) => n.left + n.width < o.left + o.width ? o : n, e[0]), r = s.left + s.width;\n    return Y(r, this.tScale);\n  }\n  notify(e = { updateHistory: !1 }) {\n    const s = this.getUpdatedState();\n    this.state.updateState(s, e);\n  }\n  getState() {\n    const e = pl(this.trackItemsMap);\n    return {\n      tracks: this.tracks,\n      trackItemIds: this.trackItemIds,\n      trackItemsMap: this.trackItemsMap,\n      transitionIds: this.transitionIds,\n      transitionsMap: this.transitionsMap,\n      trackItemDetailsMap: this.trackItemDetailsMap,\n      scale: this.scale,\n      duration: e\n    };\n  }\n  purge() {\n    R0(this), X0(this), $0(), this.dispose();\n  }\n  scrollTo({\n    scrollLeft: e,\n    scrollTop: s\n  }) {\n    var o;\n    const r = [...this.viewportTransform];\n    let n = !1;\n    typeof e == \"number\" && (r[4] = -e + this.spacing.left, n = !0), typeof s == \"number\" && (r[5] = -s, n = !0), n && (this.viewportTransform = r, (o = this.getActiveObject()) == null || o.setCoords(), this.requestRenderAll());\n  }\n  setBounding(e) {\n    this.bounding = e;\n  }\n  calcBounding() {\n    const e = this.getObjects(\"Track\").filter(\n      (c) => c.static\n    ), s = [...this.getTrackItems(), ...e].reduce(\n      (c, l) => {\n        const { top: h, height: u } = l.getBoundingRect();\n        return {\n          top: Math.min(c.top, h),\n          height: Math.max(c.height, h + u)\n        };\n      },\n      {\n        top: 1 / 0,\n        height: 0\n      }\n    ), r = [...this.getTrackItems()].reduce(\n      (c, l) => {\n        const { left: h, width: u } = l.getBoundingRect();\n        return {\n          left: Math.min(c.left, h),\n          width: Math.max(c.width, h + u)\n        };\n      },\n      {\n        left: 1 / 0,\n        width: this.width\n      }\n    ), n = this.bounding.width, o = r.width, a = o - n;\n    if (a < 0) {\n      const c = this.getTrackItems(), l = this.getElement().clientWidth, h = c.reduce(\n        (u, d) => d.left + d.width > u.left + u.width ? d : u,\n        c[0]\n      );\n      Math.abs(a) > l ? this.setViewportPos(\n        -(o - l) - this.spacing.right,\n        this.viewportTransform[5]\n      ) : h.left + h.width <= l ? this.setViewportPos(16, this.viewportTransform[5]) : this.setViewportPos(\n        this.viewportTransform[4] - a,\n        this.viewportTransform[5]\n      );\n    }\n    this.bounding = {\n      ...s,\n      ...r\n    }, (0,_designcombo_events__WEBPACK_IMPORTED_MODULE_0__.dispatch)(p0, {\n      payload: {\n        bounding: {\n          ...s,\n          ...r\n        }\n      }\n    });\n  }\n  setViewportPos(e, s) {\n    var o;\n    const r = this.getViewportPos(e, s), n = this.viewportTransform;\n    n[4] = r.x, n[5] = r.y, this.requestRenderAll(), this.setActiveTrackItemCoords(), (o = this.onScroll) == null || o.call(this, {\n      scrollTop: r.y,\n      scrollLeft: r.x - this.spacing.left\n    });\n  }\n  getViewportPos(e, s) {\n    const r = this, n = this.bounding.width - 100 >= r.width ? this.spacing.right : 0, o = r.width - this.bounding.width - n, a = this.spacing.left, c = Math.max(o, Math.min(e, a));\n    if (this.bounding.height < this.height)\n      return { x: c, y: 0 };\n    const l = r.height - this.bounding.height - 40, u = Math.max(l, Math.min(s, 0));\n    return { x: c, y: u };\n  }\n  setScale(e) {\n    this.pauseEventListeners(), this.tScale = e.zoom, this.scale = e, this.getObjects(\n      \"Video\",\n      \"Image\",\n      \"Text\",\n      \"Audio\",\n      \"Caption\",\n      \"Template\"\n    ).forEach((r) => {\n      const n = this.transitionGroups.find((o) => o.find((a) => a.id === r.id)) || [];\n      if ((n == null ? void 0 : n.length) === 1) {\n        const o = D(r.display.from, this.tScale), a = D(\n          r.display.to - r.display.from,\n          this.tScale,\n          r.playbackRate\n        );\n        r.set({ left: o, width: a, tScale: e.zoom });\n      } else {\n        const o = n.findIndex((u) => u.id === r.id), a = n[o - 1], c = n[o + 1], l = n.filter(\n          (u) => u.type === \"transition\"\n        ), h = this.trackItemsMap[r.id];\n        if (a && !c) {\n          const u = l.indexOf(a), f = l.slice(\n            0,\n            u\n          ).reduce((m, b) => m + (b.duration || 0), 0), g = D(\n            h.display.from - (a.duration || 0) / 2 - f,\n            this.tScale\n          ), p = D(\n            h.display.to - h.display.from - (a.duration || 0) / 2,\n            this.tScale,\n            h.playbackRate\n          );\n          r.set({ left: g, width: p, tScale: e.zoom });\n        } else if (c && !a) {\n          const u = D(h.display.from, this.tScale), d = D(\n            h.display.to - h.display.from - (c.duration || 0) / 2,\n            this.tScale,\n            h.playbackRate\n          );\n          r.set({ left: u, width: d, tScale: e.zoom });\n        } else if (a && c) {\n          const u = D(\n            h.display.from - (a.duration || 0) / 2,\n            this.tScale\n          ), d = D(\n            h.display.to - h.display.from - (c.duration || 0) / 2 - (a.duration || 0) / 2,\n            this.tScale,\n            r.playbackRate\n          );\n          r.set({ left: u, width: d, tScale: e.zoom });\n        }\n      }\n      r.onScale && r.onScale(), r.setCoords();\n    }), this.requestRenderAll(), this.calcBounding(), this.refreshTrackLayout(), this.updateTransitions(!1), this.resumeEventListeners();\n  }\n}\nz0(K0, [\n  Cf,\n  My,\n  ky,\n  L0\n]);\nconst rb = {\n  audio: _n,\n  media: xn,\n  common: Sn,\n  transition: Tn\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRlc2lnbmNvbWJvL3RpbWVsaW5lL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQ3FEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLDBDQUEwQywwREFBMEQ7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYyxzQ0FBc0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsT0FBTywyQkFBMkI7QUFDN0c7QUFDQTtBQUNBO0FBQ0EscWNBQXFjO0FBQ3JjO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEVBQTBFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsQ0FBQyxxQkFBcUI7QUFDdEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGlDQUFpQyxtQ0FBbUM7QUFDcEU7QUFDQTtBQUNBLFVBQVUsNkNBQTZDO0FBQ3ZELGlGQUFpRjtBQUNqRjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsT0FBTztBQUN2RTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsT0FBTztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDO0FBQ0Q7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxLQUFLLDJDQUEyQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEtBQUssa0NBQWtDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkNBQTJDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUUsR0FBRyxFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLGNBQWMsV0FBVyxJQUFJLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsUUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQkFBc0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLHVEQUF1RDtBQUNqRTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDLHVCQUF1QixHQUFHLGlCQUFpQixHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxHQUFHLFFBQVEsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsb0RBQW9ELDZEQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1REFBdUQ7QUFDNUUsRUFBRSw2REFBRTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxRQUFRLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1REFBdUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMEpBQTBKLDJDQUEyQztBQUM1TTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHVDQUF1Qyw2REFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHVCQUF1Qiw2REFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMLGVBQWU7QUFDZixHQUFHLHlCQUF5Qiw2REFBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMLGVBQWU7QUFDZixHQUFHLHlCQUF5Qiw2REFBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMLGVBQWU7QUFDZixHQUFHLHlCQUF5Qiw2REFBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMLGVBQWU7QUFDZixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFdBQVc7QUFDbEIsQ0FBQztBQUNELE9BQU8sY0FBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxHQUFHLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUE0RCxPQUFPLDhCQUE4QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFSQUFxUixtQ0FBbUM7QUFDeFQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU8sMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwUEFBMFAsbUNBQW1DO0FBQzdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVNQUF1TSxtQ0FBbUM7QUFDMU87QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFFLE9BQU8sV0FBVyxXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxjQUFjO0FBQ2YsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sY0FBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTyw2QkFBNkI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTywyREFBMkQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVLG9HQUFvRyxzQkFBc0I7QUFDcEksS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsS0FBSztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNFJBQTRSO0FBQ2pTO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsa0NBQWtDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMEJBQTBCLDRCQUE0QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUsNkRBQUU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUM7QUFDckQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUNBQW1DO0FBQ3JELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1ERSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlbW90aW9uLWNhcHRpb25zLy4vbm9kZV9tb2R1bGVzL0BkZXNpZ25jb21iby90aW1lbGluZS9kaXN0L2luZGV4LmVzLmpzP2NmNTQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEZoID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIFJoID0gKGksIHQsIGUpID0+IHQgaW4gaSA/IEZoKGksIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IGUgfSkgOiBpW3RdID0gZTtcbnZhciBUID0gKGksIHQsIGUpID0+IFJoKGksIHR5cGVvZiB0ICE9IFwic3ltYm9sXCIgPyB0ICsgXCJcIiA6IHQsIGUpO1xuaW1wb3J0IHsgZGlzcGF0Y2ggYXMgaWUgfSBmcm9tIFwiQGRlc2lnbmNvbWJvL2V2ZW50c1wiO1xuZnVuY3Rpb24geShpLCB0LCBlKSB7XG4gIHJldHVybiAodCA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgciA9IGZ1bmN0aW9uKG4sIG8pIHtcbiAgICAgIGlmICh0eXBlb2YgbiAhPSBcIm9iamVjdFwiIHx8ICFuKSByZXR1cm4gbjtcbiAgICAgIHZhciBhID0gbltTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgICAgaWYgKGEgIT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgYyA9IGEuY2FsbChuLCBvKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjICE9IFwib2JqZWN0XCIpIHJldHVybiBjO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG8gPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKG4pO1xuICAgIH0ocywgXCJzdHJpbmdcIik7XG4gICAgcmV0dXJuIHR5cGVvZiByID09IFwic3ltYm9sXCIgPyByIDogciArIFwiXCI7XG4gIH0odCkpIGluIGkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgdCwgeyB2YWx1ZTogZSwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGlbdF0gPSBlLCBpO1xufVxuZnVuY3Rpb24gZm8oaSwgdCkge1xuICB2YXIgZSA9IE9iamVjdC5rZXlzKGkpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhpKTtcbiAgICB0ICYmIChzID0gcy5maWx0ZXIoZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIGUucHVzaC5hcHBseShlLCBzKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHYoaSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBlID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IGZvKE9iamVjdChlKSwgITApLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgeShpLCBzLCBlW3NdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoZSkpIDogZm8oT2JqZWN0KGUpKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHMpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIEcoaSwgdCkge1xuICBpZiAoaSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciBlLCBzLCByID0gZnVuY3Rpb24obywgYSkge1xuICAgIGlmIChvID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgYyA9IHt9O1xuICAgIGZvciAodmFyIGwgaW4gbykgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwobywgbCkpIHtcbiAgICAgIGlmIChhLmluZGV4T2YobCkgPj0gMCkgY29udGludWU7XG4gICAgICBjW2xdID0gb1tsXTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH0oaSwgdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGkpO1xuICAgIGZvciAocyA9IDA7IHMgPCBuLmxlbmd0aDsgcysrKSBlID0gbltzXSwgdC5pbmRleE9mKGUpID49IDAgfHwge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChpLCBlKSAmJiAocltlXSA9IGlbZV0pO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gTWUoaSwgdCkge1xuICByZXR1cm4gdCB8fCAodCA9IGkuc2xpY2UoMCkpLCBPYmplY3QuZnJlZXplKE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGksIHsgcmF3OiB7IHZhbHVlOiBPYmplY3QuZnJlZXplKHQpIH0gfSkpO1xufVxuY2xhc3MgZ28ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB5KHRoaXMsIFwiYnJvd3NlclNoYWRvd0JsdXJDb25zdGFudFwiLCAxKSwgeSh0aGlzLCBcIkRQSVwiLCA5NiksIHkodGhpcywgXCJkZXZpY2VQaXhlbFJhdGlvXCIsIHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMSksIHkodGhpcywgXCJwZXJmTGltaXRTaXplVG90YWxcIiwgMjA5NzE1MiksIHkodGhpcywgXCJtYXhDYWNoZVNpZGVMaW1pdFwiLCA0MDk2KSwgeSh0aGlzLCBcIm1pbkNhY2hlU2lkZUxpbWl0XCIsIDI1NiksIHkodGhpcywgXCJkaXNhYmxlU3R5bGVDb3B5UGFzdGVcIiwgITEpLCB5KHRoaXMsIFwiZW5hYmxlR0xGaWx0ZXJpbmdcIiwgITApLCB5KHRoaXMsIFwidGV4dHVyZVNpemVcIiwgNDA5NiksIHkodGhpcywgXCJmb3JjZUdMUHV0SW1hZ2VEYXRhXCIsICExKSwgeSh0aGlzLCBcImNhY2hlc0JvdW5kc09mQ3VydmVcIiwgITEpLCB5KHRoaXMsIFwiZm9udFBhdGhzXCIsIHt9KSwgeSh0aGlzLCBcIk5VTV9GUkFDVElPTl9ESUdJVFNcIiwgNCk7XG4gIH1cbn1cbmNvbnN0IEEgPSBuZXcgY2xhc3MgZXh0ZW5kcyBnbyB7XG4gIGNvbnN0cnVjdG9yKGkpIHtcbiAgICBzdXBlcigpLCB0aGlzLmNvbmZpZ3VyZShpKTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgbGV0IGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgaSk7XG4gIH1cbiAgYWRkRm9udHMoKSB7XG4gICAgbGV0IGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHRoaXMuZm9udFBhdGhzID0gdih2KHt9LCB0aGlzLmZvbnRQYXRocyksIGkpO1xuICB9XG4gIHJlbW92ZUZvbnRzKCkge1xuICAgIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IFtdKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5mb250UGF0aHNbaV07XG4gICAgfSk7XG4gIH1cbiAgY2xlYXJGb250cygpIHtcbiAgICB0aGlzLmZvbnRQYXRocyA9IHt9O1xuICB9XG4gIHJlc3RvcmVEZWZhdWx0cyhpKSB7XG4gICAgY29uc3QgdCA9IG5ldyBnbygpLCBlID0gKGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkucmVkdWNlKChzLCByKSA9PiAoc1tyXSA9IHRbcl0sIHMpLCB7fSkpIHx8IHQ7XG4gICAgdGhpcy5jb25maWd1cmUoZSk7XG4gIH1cbn0oKSwgVGUgPSBmdW5jdGlvbihpKSB7XG4gIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBlID0gbmV3IEFycmF5KHQgPiAxID8gdCAtIDEgOiAwKSwgcyA9IDE7IHMgPCB0OyBzKyspIGVbcyAtIDFdID0gYXJndW1lbnRzW3NdO1xuICByZXR1cm4gY29uc29sZVtpXShcImZhYnJpY1wiLCAuLi5lKTtcbn07XG5jbGFzcyBZdCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKFwiZmFicmljOiBcIi5jb25jYXQodCksIGUpO1xuICB9XG59XG5jbGFzcyBGYSBleHRlbmRzIFl0IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKFwiXCIuY29uY2F0KHQsIFwiICdvcHRpb25zLnNpZ25hbCcgaXMgaW4gJ2Fib3J0ZWQnIHN0YXRlXCIpKTtcbiAgfVxufVxuY2xhc3MgTGgge1xufVxuY2xhc3MgQmggZXh0ZW5kcyBMaCB7XG4gIHRlc3RQcmVjaXNpb24odCwgZSkge1xuICAgIGNvbnN0IHMgPSBcInByZWNpc2lvbiBcIi5jb25jYXQoZSwgYCBmbG9hdDtcbnZvaWQgbWFpbigpe31gKSwgciA9IHQuY3JlYXRlU2hhZGVyKHQuRlJBR01FTlRfU0hBREVSKTtcbiAgICByZXR1cm4gISFyICYmICh0LnNoYWRlclNvdXJjZShyLCBzKSwgdC5jb21waWxlU2hhZGVyKHIpLCAhIXQuZ2V0U2hhZGVyUGFyYW1ldGVyKHIsIHQuQ09NUElMRV9TVEFUVVMpKTtcbiAgfVxuICBxdWVyeVdlYkdMKHQpIHtcbiAgICBjb25zdCBlID0gdC5nZXRDb250ZXh0KFwid2ViZ2xcIik7XG4gICAgZSAmJiAodGhpcy5tYXhUZXh0dXJlU2l6ZSA9IGUuZ2V0UGFyYW1ldGVyKGUuTUFYX1RFWFRVUkVfU0laRSksIHRoaXMuR0xQcmVjaXNpb24gPSBbXCJoaWdocFwiLCBcIm1lZGl1bXBcIiwgXCJsb3dwXCJdLmZpbmQoKHMpID0+IHRoaXMudGVzdFByZWNpc2lvbihlLCBzKSksIGUuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpLmxvc2VDb250ZXh0KCksIFRlKFwibG9nXCIsIFwiV2ViR0w6IG1heCB0ZXh0dXJlIHNpemUgXCIuY29uY2F0KHRoaXMubWF4VGV4dHVyZVNpemUpKSk7XG4gIH1cbiAgaXNTdXBwb3J0ZWQodCkge1xuICAgIHJldHVybiAhIXRoaXMubWF4VGV4dHVyZVNpemUgJiYgdGhpcy5tYXhUZXh0dXJlU2l6ZSA+PSB0O1xuICB9XG59XG5jb25zdCBXaCA9IHt9O1xubGV0IHBvO1xuY29uc3QgJHQgPSAoKSA9PiBwbyB8fCAocG8gPSB7IGRvY3VtZW50LCB3aW5kb3csIGlzVG91Y2hTdXBwb3J0ZWQ6IFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93IHx8IFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQgfHwgd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAsIFdlYkdMUHJvYmU6IG5ldyBCaCgpLCBkaXNwb3NlKCkge1xufSwgY29weVBhc3RlRGF0YTogV2ggfSksIENzID0gKCkgPT4gJHQoKS5kb2N1bWVudCwgZmkgPSAoKSA9PiAkdCgpLndpbmRvdywgUmEgPSAoKSA9PiB7XG4gIHZhciBpO1xuICByZXR1cm4gTWF0aC5tYXgoKGkgPSBBLmRldmljZVBpeGVsUmF0aW8pICE9PSBudWxsICYmIGkgIT09IHZvaWQgMCA/IGkgOiBmaSgpLmRldmljZVBpeGVsUmF0aW8sIDEpO1xufSwgenMgPSBuZXcgY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB5KHRoaXMsIFwiY2hhcldpZHRoc0NhY2hlXCIsIHt9KSwgeSh0aGlzLCBcImJvdW5kc09mQ3VydmVDYWNoZVwiLCB7fSk7XG4gIH1cbiAgZ2V0Rm9udENhY2hlKGkpIHtcbiAgICBsZXQgeyBmb250RmFtaWx5OiB0LCBmb250U3R5bGU6IGUsIGZvbnRXZWlnaHQ6IHMgfSA9IGk7XG4gICAgdCA9IHQudG9Mb3dlckNhc2UoKSwgdGhpcy5jaGFyV2lkdGhzQ2FjaGVbdF0gfHwgKHRoaXMuY2hhcldpZHRoc0NhY2hlW3RdID0ge30pO1xuICAgIGNvbnN0IHIgPSB0aGlzLmNoYXJXaWR0aHNDYWNoZVt0XSwgbiA9IFwiXCIuY29uY2F0KGUudG9Mb3dlckNhc2UoKSwgXCJfXCIpLmNvbmNhdCgocyArIFwiXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgIHJldHVybiByW25dIHx8IChyW25dID0ge30pLCByW25dO1xuICB9XG4gIGNsZWFyRm9udENhY2hlKGkpIHtcbiAgICAoaSA9IChpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpID8gdGhpcy5jaGFyV2lkdGhzQ2FjaGVbaV0gJiYgZGVsZXRlIHRoaXMuY2hhcldpZHRoc0NhY2hlW2ldIDogdGhpcy5jaGFyV2lkdGhzQ2FjaGUgPSB7fTtcbiAgfVxuICBsaW1pdERpbXNCeUFyZWEoaSkge1xuICAgIGNvbnN0IHsgcGVyZkxpbWl0U2l6ZVRvdGFsOiB0IH0gPSBBLCBlID0gTWF0aC5zcXJ0KHQgKiBpKTtcbiAgICByZXR1cm4gW01hdGguZmxvb3IoZSksIE1hdGguZmxvb3IodCAvIGUpXTtcbiAgfVxufSgpLCBzbiA9IFwiNi42LjFcIjtcbmZ1bmN0aW9uIEJlKCkge1xufVxuY29uc3QgeGUgPSBNYXRoLlBJIC8gMiwgaGUgPSAyICogTWF0aC5QSSwgam4gPSBNYXRoLlBJIC8gMTgwLCBodCA9IE9iamVjdC5mcmVlemUoWzEsIDAsIDAsIDEsIDAsIDBdKSwgRW4gPSAxNiwgeWUgPSAwLjQ0NzcxNTI1MDIsIGogPSBcImNlbnRlclwiLCBMID0gXCJsZWZ0XCIsIGd0ID0gXCJ0b3BcIiwgcm4gPSBcImJvdHRvbVwiLCBaID0gXCJyaWdodFwiLCBwdCA9IFwibm9uZVwiLCBQbiA9IC9cXHI/XFxuLywgTGEgPSBcIm1vdmluZ1wiLCBnaSA9IFwic2NhbGluZ1wiLCBCYSA9IFwicm90YXRpbmdcIiwgQW4gPSBcInJvdGF0ZVwiLCBXYSA9IFwic2tld2luZ1wiLCAkcyA9IFwicmVzaXppbmdcIiwgWGEgPSBcIm1vZGlmeVBvbHlcIiwgWGggPSBcIm1vZGlmeVBhdGhcIiwgVXIgPSBcImNoYW5nZWRcIiwgcGkgPSBcInNjYWxlXCIsIHV0ID0gXCJzY2FsZVhcIiwgVHQgPSBcInNjYWxlWVwiLCBPcyA9IFwic2tld1hcIiwga3MgPSBcInNrZXdZXCIsIHJ0ID0gXCJmaWxsXCIsIG10ID0gXCJzdHJva2VcIiwgJHIgPSBcIm1vZGlmaWVkXCIsIHFlID0gXCJqc29uXCIsIFJpID0gXCJzdmdcIiwgQyA9IG5ldyBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXNbcWVdID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpc1tSaV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGhhcyhpKSB7XG4gICAgcmV0dXJuIHRoaXNbcWVdLmhhcyhpKTtcbiAgfVxuICBnZXRDbGFzcyhpKSB7XG4gICAgY29uc3QgdCA9IHRoaXNbcWVdLmdldChpKTtcbiAgICBpZiAoIXQpIHRocm93IG5ldyBZdChcIk5vIGNsYXNzIHJlZ2lzdGVyZWQgZm9yIFwiLmNvbmNhdChpKSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgc2V0Q2xhc3MoaSwgdCkge1xuICAgIHQgPyB0aGlzW3FlXS5zZXQodCwgaSkgOiAodGhpc1txZV0uc2V0KGkudHlwZSwgaSksIHRoaXNbcWVdLnNldChpLnR5cGUudG9Mb3dlckNhc2UoKSwgaSkpO1xuICB9XG4gIGdldFNWR0NsYXNzKGkpIHtcbiAgICByZXR1cm4gdGhpc1tSaV0uZ2V0KGkpO1xuICB9XG4gIHNldFNWR0NsYXNzKGksIHQpIHtcbiAgICB0aGlzW1JpXS5zZXQodCA/PyBpLnR5cGUudG9Mb3dlckNhc2UoKSwgaSk7XG4gIH1cbn0oKSwgcXIgPSBuZXcgY2xhc3MgZXh0ZW5kcyBBcnJheSB7XG4gIHJlbW92ZShpKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaW5kZXhPZihpKTtcbiAgICB0ID4gLTEgJiYgdGhpcy5zcGxpY2UodCwgMSk7XG4gIH1cbiAgY2FuY2VsQWxsKCkge1xuICAgIGNvbnN0IGkgPSB0aGlzLnNwbGljZSgwKTtcbiAgICByZXR1cm4gaS5mb3JFYWNoKCh0KSA9PiB0LmFib3J0KCkpLCBpO1xuICB9XG4gIGNhbmNlbEJ5Q2FudmFzKGkpIHtcbiAgICBpZiAoIWkpIHJldHVybiBbXTtcbiAgICBjb25zdCB0ID0gdGhpcy5maWx0ZXIoKGUpID0+IHtcbiAgICAgIHZhciBzO1xuICAgICAgcmV0dXJuIGUudGFyZ2V0ID09PSBpIHx8IHR5cGVvZiBlLnRhcmdldCA9PSBcIm9iamVjdFwiICYmICgocyA9IGUudGFyZ2V0KSA9PT0gbnVsbCB8fCBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzLmNhbnZhcykgPT09IGk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHQuZm9yRWFjaCgoZSkgPT4gZS5hYm9ydCgpKSwgdDtcbiAgfVxuICBjYW5jZWxCeVRhcmdldChpKSB7XG4gICAgaWYgKCFpKSByZXR1cm4gW107XG4gICAgY29uc3QgdCA9IHRoaXMuZmlsdGVyKChlKSA9PiBlLnRhcmdldCA9PT0gaSk7XG4gICAgcmV0dXJuIHQuZm9yRWFjaCgoZSkgPT4gZS5hYm9ydCgpKSwgdDtcbiAgfVxufSgpO1xuY2xhc3Mgemgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB5KHRoaXMsIFwiX19ldmVudExpc3RlbmVyc1wiLCB7fSk7XG4gIH1cbiAgb24odCwgZSkge1xuICAgIGlmICh0aGlzLl9fZXZlbnRMaXN0ZW5lcnMgfHwgKHRoaXMuX19ldmVudExpc3RlbmVycyA9IHt9KSwgdHlwZW9mIHQgPT0gXCJvYmplY3RcIikgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGxldCBbciwgbl0gPSBzO1xuICAgICAgdGhpcy5vbihyLCBuKTtcbiAgICB9KSwgKCkgPT4gdGhpcy5vZmYodCk7XG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IHMgPSB0O1xuICAgICAgcmV0dXJuIHRoaXMuX19ldmVudExpc3RlbmVyc1tzXSB8fCAodGhpcy5fX2V2ZW50TGlzdGVuZXJzW3NdID0gW10pLCB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbc10ucHVzaChlKSwgKCkgPT4gdGhpcy5vZmYocywgZSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiAhMTtcbiAgfVxuICBvbmNlKHQsIGUpIHtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgcyA9IFtdO1xuICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgbGV0IFtuLCBvXSA9IHI7XG4gICAgICAgIHMucHVzaCh0aGlzLm9uY2UobiwgbykpO1xuICAgICAgfSksICgpID0+IHMuZm9yRWFjaCgocikgPT4gcigpKTtcbiAgICB9XG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLm9uKHQsIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciByID0gYXJndW1lbnRzLmxlbmd0aCwgbiA9IG5ldyBBcnJheShyKSwgbyA9IDA7IG8gPCByOyBvKyspIG5bb10gPSBhcmd1bWVudHNbb107XG4gICAgICAgIGUuY2FsbCh0aGlzLCAuLi5uKSwgcygpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgcmV0dXJuICgpID0+ICExO1xuICB9XG4gIF9yZW1vdmVFdmVudExpc3RlbmVyKHQsIGUpIHtcbiAgICBpZiAodGhpcy5fX2V2ZW50TGlzdGVuZXJzW3RdKSBpZiAoZSkge1xuICAgICAgY29uc3QgcyA9IHRoaXMuX19ldmVudExpc3RlbmVyc1t0XSwgciA9IHMuaW5kZXhPZihlKTtcbiAgICAgIHIgPiAtMSAmJiBzLnNwbGljZShyLCAxKTtcbiAgICB9IGVsc2UgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW3RdID0gW107XG4gIH1cbiAgb2ZmKHQsIGUpIHtcbiAgICBpZiAodGhpcy5fX2V2ZW50TGlzdGVuZXJzKSBpZiAodCA9PT0gdm9pZCAwKSBmb3IgKGNvbnN0IHMgaW4gdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyKHMpO1xuICAgIGVsc2UgdHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IE9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGxldCBbciwgbl0gPSBzO1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcihyLCBuKTtcbiAgICB9KSA6IHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXIodCwgZSk7XG4gIH1cbiAgZmlyZSh0LCBlKSB7XG4gICAgdmFyIHM7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHJldHVybjtcbiAgICBjb25zdCByID0gKHMgPSB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbdF0pID09PSBudWxsIHx8IHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHMuY29uY2F0KCk7XG4gICAgaWYgKHIpIGZvciAobGV0IG4gPSAwOyBuIDwgci5sZW5ndGg7IG4rKykgcltuXS5jYWxsKHRoaXMsIGUgfHwge30pO1xuICB9XG59XG5jb25zdCBFZSA9IChpLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBpLmluZGV4T2YodCk7XG4gIHJldHVybiBlICE9PSAtMSAmJiBpLnNwbGljZShlLCAxKSwgaTtcbn0sIEx0ID0gKGkpID0+IHtcbiAgaWYgKGkgPT09IDApIHJldHVybiAxO1xuICBzd2l0Y2ggKE1hdGguYWJzKGkpIC8geGUpIHtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiBNYXRoLmNvcyhpKTtcbn0sIEJ0ID0gKGkpID0+IHtcbiAgaWYgKGkgPT09IDApIHJldHVybiAwO1xuICBjb25zdCB0ID0gaSAvIHhlLCBlID0gTWF0aC5zaWduKGkpO1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gLWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguc2luKGkpO1xufTtcbmNsYXNzIF8ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogMCwgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB0eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gKHRoaXMueCA9IHQueCwgdGhpcy55ID0gdC55KSA6ICh0aGlzLnggPSB0LCB0aGlzLnkgPSBlKTtcbiAgfVxuICBhZGQodCkge1xuICAgIHJldHVybiBuZXcgXyh0aGlzLnggKyB0LngsIHRoaXMueSArIHQueSk7XG4gIH1cbiAgYWRkRXF1YWxzKHQpIHtcbiAgICByZXR1cm4gdGhpcy54ICs9IHQueCwgdGhpcy55ICs9IHQueSwgdGhpcztcbiAgfVxuICBzY2FsYXJBZGQodCkge1xuICAgIHJldHVybiBuZXcgXyh0aGlzLnggKyB0LCB0aGlzLnkgKyB0KTtcbiAgfVxuICBzY2FsYXJBZGRFcXVhbHModCkge1xuICAgIHJldHVybiB0aGlzLnggKz0gdCwgdGhpcy55ICs9IHQsIHRoaXM7XG4gIH1cbiAgc3VidHJhY3QodCkge1xuICAgIHJldHVybiBuZXcgXyh0aGlzLnggLSB0LngsIHRoaXMueSAtIHQueSk7XG4gIH1cbiAgc3VidHJhY3RFcXVhbHModCkge1xuICAgIHJldHVybiB0aGlzLnggLT0gdC54LCB0aGlzLnkgLT0gdC55LCB0aGlzO1xuICB9XG4gIHNjYWxhclN1YnRyYWN0KHQpIHtcbiAgICByZXR1cm4gbmV3IF8odGhpcy54IC0gdCwgdGhpcy55IC0gdCk7XG4gIH1cbiAgc2NhbGFyU3VidHJhY3RFcXVhbHModCkge1xuICAgIHJldHVybiB0aGlzLnggLT0gdCwgdGhpcy55IC09IHQsIHRoaXM7XG4gIH1cbiAgbXVsdGlwbHkodCkge1xuICAgIHJldHVybiBuZXcgXyh0aGlzLnggKiB0LngsIHRoaXMueSAqIHQueSk7XG4gIH1cbiAgc2NhbGFyTXVsdGlwbHkodCkge1xuICAgIHJldHVybiBuZXcgXyh0aGlzLnggKiB0LCB0aGlzLnkgKiB0KTtcbiAgfVxuICBzY2FsYXJNdWx0aXBseUVxdWFscyh0KSB7XG4gICAgcmV0dXJuIHRoaXMueCAqPSB0LCB0aGlzLnkgKj0gdCwgdGhpcztcbiAgfVxuICBkaXZpZGUodCkge1xuICAgIHJldHVybiBuZXcgXyh0aGlzLnggLyB0LngsIHRoaXMueSAvIHQueSk7XG4gIH1cbiAgc2NhbGFyRGl2aWRlKHQpIHtcbiAgICByZXR1cm4gbmV3IF8odGhpcy54IC8gdCwgdGhpcy55IC8gdCk7XG4gIH1cbiAgc2NhbGFyRGl2aWRlRXF1YWxzKHQpIHtcbiAgICByZXR1cm4gdGhpcy54IC89IHQsIHRoaXMueSAvPSB0LCB0aGlzO1xuICB9XG4gIGVxKHQpIHtcbiAgICByZXR1cm4gdGhpcy54ID09PSB0LnggJiYgdGhpcy55ID09PSB0Lnk7XG4gIH1cbiAgbHQodCkge1xuICAgIHJldHVybiB0aGlzLnggPCB0LnggJiYgdGhpcy55IDwgdC55O1xuICB9XG4gIGx0ZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMueCA8PSB0LnggJiYgdGhpcy55IDw9IHQueTtcbiAgfVxuICBndCh0KSB7XG4gICAgcmV0dXJuIHRoaXMueCA+IHQueCAmJiB0aGlzLnkgPiB0Lnk7XG4gIH1cbiAgZ3RlKHQpIHtcbiAgICByZXR1cm4gdGhpcy54ID49IHQueCAmJiB0aGlzLnkgPj0gdC55O1xuICB9XG4gIGxlcnAodCkge1xuICAgIGxldCBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAwLjU7XG4gICAgcmV0dXJuIGUgPSBNYXRoLm1heChNYXRoLm1pbigxLCBlKSwgMCksIG5ldyBfKHRoaXMueCArICh0LnggLSB0aGlzLngpICogZSwgdGhpcy55ICsgKHQueSAtIHRoaXMueSkgKiBlKTtcbiAgfVxuICBkaXN0YW5jZUZyb20odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnggLSB0LngsIHMgPSB0aGlzLnkgLSB0Lnk7XG4gICAgcmV0dXJuIE1hdGguc3FydChlICogZSArIHMgKiBzKTtcbiAgfVxuICBtaWRQb2ludEZyb20odCkge1xuICAgIHJldHVybiB0aGlzLmxlcnAodCk7XG4gIH1cbiAgbWluKHQpIHtcbiAgICByZXR1cm4gbmV3IF8oTWF0aC5taW4odGhpcy54LCB0LngpLCBNYXRoLm1pbih0aGlzLnksIHQueSkpO1xuICB9XG4gIG1heCh0KSB7XG4gICAgcmV0dXJuIG5ldyBfKE1hdGgubWF4KHRoaXMueCwgdC54KSwgTWF0aC5tYXgodGhpcy55LCB0LnkpKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy54LCBcIixcIikuY29uY2F0KHRoaXMueSk7XG4gIH1cbiAgc2V0WFkodCwgZSkge1xuICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzLnkgPSBlLCB0aGlzO1xuICB9XG4gIHNldFgodCkge1xuICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzO1xuICB9XG4gIHNldFkodCkge1xuICAgIHJldHVybiB0aGlzLnkgPSB0LCB0aGlzO1xuICB9XG4gIHNldEZyb21Qb2ludCh0KSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IHQueCwgdGhpcy55ID0gdC55LCB0aGlzO1xuICB9XG4gIHN3YXAodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLngsIHMgPSB0aGlzLnk7XG4gICAgdGhpcy54ID0gdC54LCB0aGlzLnkgPSB0LnksIHQueCA9IGUsIHQueSA9IHM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfKHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICByb3RhdGUodCkge1xuICAgIGxldCBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBGbjtcbiAgICBjb25zdCBzID0gQnQodCksIHIgPSBMdCh0KSwgbiA9IHRoaXMuc3VidHJhY3QoZSk7XG4gICAgcmV0dXJuIG5ldyBfKG4ueCAqIHIgLSBuLnkgKiBzLCBuLnggKiBzICsgbi55ICogcikuYWRkKGUpO1xuICB9XG4gIHRyYW5zZm9ybSh0KSB7XG4gICAgbGV0IGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCAmJiBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIG5ldyBfKHRbMF0gKiB0aGlzLnggKyB0WzJdICogdGhpcy55ICsgKGUgPyAwIDogdFs0XSksIHRbMV0gKiB0aGlzLnggKyB0WzNdICogdGhpcy55ICsgKGUgPyAwIDogdFs1XSkpO1xuICB9XG59XG5jb25zdCBGbiA9IG5ldyBfKDAsIDApLCBWciA9IChpKSA9PiAhIWkgJiYgQXJyYXkuaXNBcnJheShpLl9vYmplY3RzKTtcbmZ1bmN0aW9uIHphKGkpIHtcbiAgY2xhc3MgdCBleHRlbmRzIGkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgeSh0aGlzLCBcIl9vYmplY3RzXCIsIFtdKTtcbiAgICB9XG4gICAgX29uT2JqZWN0QWRkZWQocykge1xuICAgIH1cbiAgICBfb25PYmplY3RSZW1vdmVkKHMpIHtcbiAgICB9XG4gICAgX29uU3RhY2tPcmRlckNoYW5nZWQocykge1xuICAgIH1cbiAgICBhZGQoKSB7XG4gICAgICBmb3IgKHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IG5ldyBBcnJheShzKSwgbiA9IDA7IG4gPCBzOyBuKyspIHJbbl0gPSBhcmd1bWVudHNbbl07XG4gICAgICBjb25zdCBvID0gdGhpcy5fb2JqZWN0cy5wdXNoKC4uLnIpO1xuICAgICAgcmV0dXJuIHIuZm9yRWFjaCgoYSkgPT4gdGhpcy5fb25PYmplY3RBZGRlZChhKSksIG87XG4gICAgfVxuICAgIGluc2VydEF0KHMpIHtcbiAgICAgIGZvciAodmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoLCBuID0gbmV3IEFycmF5KHIgPiAxID8gciAtIDEgOiAwKSwgbyA9IDE7IG8gPCByOyBvKyspIG5bbyAtIDFdID0gYXJndW1lbnRzW29dO1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHMuc3BsaWNlKHMsIDAsIC4uLm4pLCBuLmZvckVhY2goKGEpID0+IHRoaXMuX29uT2JqZWN0QWRkZWQoYSkpLCB0aGlzLl9vYmplY3RzLmxlbmd0aDtcbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgY29uc3QgcyA9IHRoaXMuX29iamVjdHMsIHIgPSBbXTtcbiAgICAgIGZvciAodmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBvID0gbmV3IEFycmF5KG4pLCBhID0gMDsgYSA8IG47IGErKykgb1thXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgIHJldHVybiBvLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgY29uc3QgbCA9IHMuaW5kZXhPZihjKTtcbiAgICAgICAgbCAhPT0gLTEgJiYgKHMuc3BsaWNlKGwsIDEpLCByLnB1c2goYyksIHRoaXMuX29uT2JqZWN0UmVtb3ZlZChjKSk7XG4gICAgICB9KSwgcjtcbiAgICB9XG4gICAgZm9yRWFjaE9iamVjdChzKSB7XG4gICAgICB0aGlzLmdldE9iamVjdHMoKS5mb3JFYWNoKChyLCBuLCBvKSA9PiBzKHIsIG4sIG8pKTtcbiAgICB9XG4gICAgZ2V0T2JqZWN0cygpIHtcbiAgICAgIGZvciAodmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gbmV3IEFycmF5KHMpLCBuID0gMDsgbiA8IHM7IG4rKykgcltuXSA9IGFyZ3VtZW50c1tuXTtcbiAgICAgIHJldHVybiByLmxlbmd0aCA9PT0gMCA/IFsuLi50aGlzLl9vYmplY3RzXSA6IHRoaXMuX29iamVjdHMuZmlsdGVyKChvKSA9PiBvLmlzVHlwZSguLi5yKSk7XG4gICAgfVxuICAgIGl0ZW0ocykge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHNbc107XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnRhaW5zKHMsIHIpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX29iamVjdHMuaW5jbHVkZXMocykgfHwgISFyICYmIHRoaXMuX29iamVjdHMuc29tZSgobikgPT4gbiBpbnN0YW5jZW9mIHQgJiYgbi5jb250YWlucyhzLCAhMCkpO1xuICAgIH1cbiAgICBjb21wbGV4aXR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHMucmVkdWNlKChzLCByKSA9PiBzICs9IHIuY29tcGxleGl0eSA/IHIuY29tcGxleGl0eSgpIDogMCwgMCk7XG4gICAgfVxuICAgIHNlbmRPYmplY3RUb0JhY2socykge1xuICAgICAgcmV0dXJuICEoIXMgfHwgcyA9PT0gdGhpcy5fb2JqZWN0c1swXSkgJiYgKEVlKHRoaXMuX29iamVjdHMsIHMpLCB0aGlzLl9vYmplY3RzLnVuc2hpZnQocyksIHRoaXMuX29uU3RhY2tPcmRlckNoYW5nZWQocyksICEwKTtcbiAgICB9XG4gICAgYnJpbmdPYmplY3RUb0Zyb250KHMpIHtcbiAgICAgIHJldHVybiAhKCFzIHx8IHMgPT09IHRoaXMuX29iamVjdHNbdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxXSkgJiYgKEVlKHRoaXMuX29iamVjdHMsIHMpLCB0aGlzLl9vYmplY3RzLnB1c2gocyksIHRoaXMuX29uU3RhY2tPcmRlckNoYW5nZWQocyksICEwKTtcbiAgICB9XG4gICAgc2VuZE9iamVjdEJhY2t3YXJkcyhzLCByKSB7XG4gICAgICBpZiAoIXMpIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yocyk7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5maW5kTmV3TG93ZXJJbmRleChzLCBuLCByKTtcbiAgICAgICAgcmV0dXJuIEVlKHRoaXMuX29iamVjdHMsIHMpLCB0aGlzLl9vYmplY3RzLnNwbGljZShvLCAwLCBzKSwgdGhpcy5fb25TdGFja09yZGVyQ2hhbmdlZChzKSwgITA7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGJyaW5nT2JqZWN0Rm9yd2FyZChzLCByKSB7XG4gICAgICBpZiAoIXMpIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yocyk7XG4gICAgICBpZiAobiAhPT0gdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmZpbmROZXdVcHBlckluZGV4KHMsIG4sIHIpO1xuICAgICAgICByZXR1cm4gRWUodGhpcy5fb2JqZWN0cywgcyksIHRoaXMuX29iamVjdHMuc3BsaWNlKG8sIDAsIHMpLCB0aGlzLl9vblN0YWNrT3JkZXJDaGFuZ2VkKHMpLCAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgbW92ZU9iamVjdFRvKHMsIHIpIHtcbiAgICAgIHJldHVybiBzICE9PSB0aGlzLl9vYmplY3RzW3JdICYmIChFZSh0aGlzLl9vYmplY3RzLCBzKSwgdGhpcy5fb2JqZWN0cy5zcGxpY2UociwgMCwgcyksIHRoaXMuX29uU3RhY2tPcmRlckNoYW5nZWQocyksICEwKTtcbiAgICB9XG4gICAgZmluZE5ld0xvd2VySW5kZXgocywgciwgbikge1xuICAgICAgbGV0IG87XG4gICAgICBpZiAobikge1xuICAgICAgICBvID0gcjtcbiAgICAgICAgZm9yIChsZXQgYSA9IHIgLSAxOyBhID49IDA7IC0tYSkgaWYgKHMuaXNPdmVybGFwcGluZyh0aGlzLl9vYmplY3RzW2FdKSkge1xuICAgICAgICAgIG8gPSBhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgbyA9IHIgLSAxO1xuICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIGZpbmROZXdVcHBlckluZGV4KHMsIHIsIG4pIHtcbiAgICAgIGxldCBvO1xuICAgICAgaWYgKG4pIHtcbiAgICAgICAgbyA9IHI7XG4gICAgICAgIGZvciAobGV0IGEgPSByICsgMTsgYSA8IHRoaXMuX29iamVjdHMubGVuZ3RoOyArK2EpIGlmIChzLmlzT3ZlcmxhcHBpbmcodGhpcy5fb2JqZWN0c1thXSkpIHtcbiAgICAgICAgICBvID0gYTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIG8gPSByICsgMTtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBjb2xsZWN0T2JqZWN0cyhzKSB7XG4gICAgICBsZXQgeyBsZWZ0OiByLCB0b3A6IG4sIHdpZHRoOiBvLCBoZWlnaHQ6IGEgfSA9IHMsIHsgaW5jbHVkZUludGVyc2VjdGluZzogYyA9ICEwIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgY29uc3QgbCA9IFtdLCBoID0gbmV3IF8ociwgbiksIHUgPSBoLmFkZChuZXcgXyhvLCBhKSk7XG4gICAgICBmb3IgKGxldCBkID0gdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICBjb25zdCBmID0gdGhpcy5fb2JqZWN0c1tkXTtcbiAgICAgICAgZi5zZWxlY3RhYmxlICYmIGYudmlzaWJsZSAmJiAoYyAmJiBmLmludGVyc2VjdHNXaXRoUmVjdChoLCB1KSB8fCBmLmlzQ29udGFpbmVkV2l0aGluUmVjdChoLCB1KSB8fCBjICYmIGYuY29udGFpbnNQb2ludChoKSB8fCBjICYmIGYuY29udGFpbnNQb2ludCh1KSkgJiYgbC5wdXNoKGYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGw7XG4gICAgfVxuICB9XG4gIHJldHVybiB0O1xufVxuY2xhc3MgSGEgZXh0ZW5kcyB6aCB7XG4gIF9zZXRPcHRpb25zKCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdCkgdGhpcy5zZXQoZSwgdFtlXSk7XG4gIH1cbiAgX3NldE9iamVjdCh0KSB7XG4gICAgZm9yIChjb25zdCBlIGluIHQpIHRoaXMuX3NldChlLCB0W2VdKTtcbiAgfVxuICBzZXQodCwgZSkge1xuICAgIHJldHVybiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdGhpcy5fc2V0T2JqZWN0KHQpIDogdGhpcy5fc2V0KHQsIGUpLCB0aGlzO1xuICB9XG4gIF9zZXQodCwgZSkge1xuICAgIHRoaXNbdF0gPSBlO1xuICB9XG4gIHRvZ2dsZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0KHQpO1xuICAgIHJldHVybiB0eXBlb2YgZSA9PSBcImJvb2xlYW5cIiAmJiB0aGlzLnNldCh0LCAhZSksIHRoaXM7XG4gIH1cbiAgZ2V0KHQpIHtcbiAgICByZXR1cm4gdGhpc1t0XTtcbiAgfVxufVxuZnVuY3Rpb24gSHMoaSkge1xuICByZXR1cm4gZmkoKS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaSk7XG59XG5mdW5jdGlvbiBZYShpKSB7XG4gIHJldHVybiBmaSgpLmNhbmNlbEFuaW1hdGlvbkZyYW1lKGkpO1xufVxubGV0IEhoID0gMDtcbmNvbnN0IHdlID0gKCkgPT4gSGgrKywga3QgPSAoKSA9PiB7XG4gIGNvbnN0IGkgPSBDcygpLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGlmICghaSB8fCBpLmdldENvbnRleHQgPT09IHZvaWQgMCkgdGhyb3cgbmV3IFl0KFwiRmFpbGVkIHRvIGNyZWF0ZSBgY2FudmFzYCBlbGVtZW50XCIpO1xuICByZXR1cm4gaTtcbn0sIFZhID0gKCkgPT4gQ3MoKS5jcmVhdGVFbGVtZW50KFwiaW1nXCIpLCBXdCA9IChpKSA9PiB7XG4gIGNvbnN0IHQgPSBrdCgpO1xuICByZXR1cm4gdC53aWR0aCA9IGkud2lkdGgsIHQuaGVpZ2h0ID0gaS5oZWlnaHQsIHQ7XG59LCBSbiA9IChpLCB0LCBlKSA9PiBpLnRvRGF0YVVSTChcImltYWdlL1wiLmNvbmNhdCh0KSwgZSksIExuID0gKGksIHQsIGUpID0+IG5ldyBQcm9taXNlKChzLCByKSA9PiB7XG4gIGkudG9CbG9iKHMsIFwiaW1hZ2UvXCIuY29uY2F0KHQpLCBlKTtcbn0pLCBLID0gKGkpID0+IGkgKiBqbiwgQ2UgPSAoaSkgPT4gaSAvIGpuLCBHYSA9IChpKSA9PiBpLmV2ZXJ5KCh0LCBlKSA9PiB0ID09PSBodFtlXSksIG90ID0gKGksIHQsIGUpID0+IG5ldyBfKGkpLnRyYW5zZm9ybSh0LCBlKSwgU3QgPSAoaSkgPT4ge1xuICBjb25zdCB0ID0gMSAvIChpWzBdICogaVszXSAtIGlbMV0gKiBpWzJdKSwgZSA9IFt0ICogaVszXSwgLXQgKiBpWzFdLCAtdCAqIGlbMl0sIHQgKiBpWzBdLCAwLCAwXSwgeyB4OiBzLCB5OiByIH0gPSBuZXcgXyhpWzRdLCBpWzVdKS50cmFuc2Zvcm0oZSwgITApO1xuICByZXR1cm4gZVs0XSA9IC1zLCBlWzVdID0gLXIsIGU7XG59LCBKID0gKGksIHQsIGUpID0+IFtpWzBdICogdFswXSArIGlbMl0gKiB0WzFdLCBpWzFdICogdFswXSArIGlbM10gKiB0WzFdLCBpWzBdICogdFsyXSArIGlbMl0gKiB0WzNdLCBpWzFdICogdFsyXSArIGlbM10gKiB0WzNdLCBlID8gMCA6IGlbMF0gKiB0WzRdICsgaVsyXSAqIHRbNV0gKyBpWzRdLCBlID8gMCA6IGlbMV0gKiB0WzRdICsgaVszXSAqIHRbNV0gKyBpWzVdXSwgbWkgPSAoaSwgdCkgPT4gaS5yZWR1Y2VSaWdodCgoZSwgcykgPT4gcyAmJiBlID8gSihzLCBlLCB0KSA6IHMgfHwgZSwgdm9pZCAwKSB8fCBodC5jb25jYXQoKSwgTmEgPSAoaSkgPT4ge1xuICBsZXQgW3QsIGVdID0gaTtcbiAgcmV0dXJuIE1hdGguYXRhbjIoZSwgdCk7XG59LCB5cyA9IChpKSA9PiB7XG4gIGNvbnN0IHQgPSBOYShpKSwgZSA9IE1hdGgucG93KGlbMF0sIDIpICsgTWF0aC5wb3coaVsxXSwgMiksIHMgPSBNYXRoLnNxcnQoZSksIHIgPSAoaVswXSAqIGlbM10gLSBpWzJdICogaVsxXSkgLyBzLCBuID0gTWF0aC5hdGFuMihpWzBdICogaVsyXSArIGlbMV0gKiBpWzNdLCBlKTtcbiAgcmV0dXJuIHsgYW5nbGU6IENlKHQpLCBzY2FsZVg6IHMsIHNjYWxlWTogciwgc2tld1g6IENlKG4pLCBza2V3WTogMCwgdHJhbnNsYXRlWDogaVs0XSB8fCAwLCB0cmFuc2xhdGVZOiBpWzVdIHx8IDAgfTtcbn0sIE1zID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gWzEsIDAsIDAsIDEsIGksIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMF07XG59O1xuZnVuY3Rpb24gSXMoKSB7XG4gIGxldCB7IGFuZ2xlOiBpID0gMCB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fSwgeyB4OiB0ID0gMCwgeTogZSA9IDAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gIGNvbnN0IHMgPSBLKGkpLCByID0gTHQocyksIG4gPSBCdChzKTtcbiAgcmV0dXJuIFtyLCBuLCAtbiwgciwgdCA/IHQgLSAociAqIHQgLSBuICogZSkgOiAwLCBlID8gZSAtIChuICogdCArIHIgKiBlKSA6IDBdO1xufVxuY29uc3QgdmkgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiBbaSwgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBpLCAwLCAwXTtcbn0sIFVhID0gKGkpID0+IE1hdGgudGFuKEsoaSkpLCBCbiA9IChpKSA9PiBbMSwgMCwgVWEoaSksIDEsIDAsIDBdLCBXbiA9IChpKSA9PiBbMSwgVWEoaSksIDAsIDEsIDAsIDBdLCBhciA9IChpKSA9PiB7XG4gIGxldCB7IHNjYWxlWDogdCA9IDEsIHNjYWxlWTogZSA9IDEsIGZsaXBYOiBzID0gITEsIGZsaXBZOiByID0gITEsIHNrZXdYOiBuID0gMCwgc2tld1k6IG8gPSAwIH0gPSBpLCBhID0gdmkocyA/IC10IDogdCwgciA/IC1lIDogZSk7XG4gIHJldHVybiBuICYmIChhID0gSihhLCBCbihuKSwgITApKSwgbyAmJiAoYSA9IEooYSwgV24obyksICEwKSksIGE7XG59LCAkYSA9IChpKSA9PiB7XG4gIGNvbnN0IHsgdHJhbnNsYXRlWDogdCA9IDAsIHRyYW5zbGF0ZVk6IGUgPSAwLCBhbmdsZTogcyA9IDAgfSA9IGk7XG4gIGxldCByID0gTXModCwgZSk7XG4gIHMgJiYgKHIgPSBKKHIsIElzKHsgYW5nbGU6IHMgfSkpKTtcbiAgY29uc3QgbiA9IGFyKGkpO1xuICByZXR1cm4gR2EobikgfHwgKHIgPSBKKHIsIG4pKSwgcjtcbn0sIFlzID0gZnVuY3Rpb24oaSkge1xuICBsZXQgeyBzaWduYWw6IHQsIGNyb3NzT3JpZ2luOiBlID0gbnVsbCB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHMsIHIpIHtcbiAgICBpZiAodCAmJiB0LmFib3J0ZWQpIHJldHVybiByKG5ldyBGYShcImxvYWRJbWFnZVwiKSk7XG4gICAgY29uc3QgbiA9IFZhKCk7XG4gICAgbGV0IG87XG4gICAgdCAmJiAobyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIG4uc3JjID0gXCJcIiwgcihjKTtcbiAgICB9LCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvLCB7IG9uY2U6ICEwIH0pKTtcbiAgICBjb25zdCBhID0gZnVuY3Rpb24oKSB7XG4gICAgICBuLm9ubG9hZCA9IG4ub25lcnJvciA9IG51bGwsIG8gJiYgKHQgPT0gbnVsbCB8fCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvKSksIHMobik7XG4gICAgfTtcbiAgICBpID8gKG4ub25sb2FkID0gYSwgbi5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvICYmICh0ID09IG51bGwgfHwgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbykpLCByKG5ldyBZdChcIkVycm9yIGxvYWRpbmcgXCIuY29uY2F0KG4uc3JjKSkpO1xuICAgIH0sIGUgJiYgKG4uY3Jvc3NPcmlnaW4gPSBlKSwgbi5zcmMgPSBpKSA6IGEoKTtcbiAgfSk7XG59LCBicyA9IGZ1bmN0aW9uKGkpIHtcbiAgbGV0IHsgc2lnbmFsOiB0LCByZXZpdmVyOiBlID0gQmUgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocywgcikgPT4ge1xuICAgIGNvbnN0IG4gPSBbXTtcbiAgICB0ICYmIHQuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHIsIHsgb25jZTogITAgfSksIFByb21pc2UuYWxsKGkubWFwKChvKSA9PiBDLmdldENsYXNzKG8udHlwZSkuZnJvbU9iamVjdChvLCB7IHNpZ25hbDogdCB9KS50aGVuKChhKSA9PiAoZShvLCBhKSwgbi5wdXNoKGEpLCBhKSkpKS50aGVuKHMpLmNhdGNoKChvKSA9PiB7XG4gICAgICBuLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgYS5kaXNwb3NlICYmIGEuZGlzcG9zZSgpO1xuICAgICAgfSksIHIobyk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB0ICYmIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHIpO1xuICAgIH0pO1xuICB9KTtcbn0sIGNyID0gZnVuY3Rpb24oaSkge1xuICBsZXQgeyBzaWduYWw6IHQgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoZSwgcykgPT4ge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICB0ICYmIHQuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHMsIHsgb25jZTogITAgfSk7XG4gICAgY29uc3QgbiA9IE9iamVjdC52YWx1ZXMoaSkubWFwKChhKSA9PiBhICYmIGEudHlwZSAmJiBDLmhhcyhhLnR5cGUpID8gYnMoW2FdLCB7IHNpZ25hbDogdCB9KS50aGVuKChjKSA9PiB7XG4gICAgICBsZXQgW2xdID0gYztcbiAgICAgIHJldHVybiByLnB1c2gobCksIGw7XG4gICAgfSkgOiBhKSwgbyA9IE9iamVjdC5rZXlzKGkpO1xuICAgIFByb21pc2UuYWxsKG4pLnRoZW4oKGEpID0+IGEucmVkdWNlKChjLCBsLCBoKSA9PiAoY1tvW2hdXSA9IGwsIGMpLCB7fSkpLnRoZW4oZSkuY2F0Y2goKGEpID0+IHtcbiAgICAgIHIuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjLmRpc3Bvc2UgJiYgYy5kaXNwb3NlKCk7XG4gICAgICB9KSwgcyhhKTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHQgJiYgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgcyk7XG4gICAgfSk7XG4gIH0pO1xufSwgVmUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBbXSkucmVkdWNlKCh0LCBlKSA9PiAoZSBpbiBpICYmICh0W2VdID0gaVtlXSksIHQpLCB7fSk7XG59LCBYbiA9IChpLCB0KSA9PiBPYmplY3Qua2V5cyhpKS5yZWR1Y2UoKGUsIHMpID0+ICh0KGlbc10sIHMsIGkpICYmIChlW3NdID0gaVtzXSksIGUpLCB7fSksIG1vID0geyBhbGljZWJsdWU6IFwiI0YwRjhGRlwiLCBhbnRpcXVld2hpdGU6IFwiI0ZBRUJEN1wiLCBhcXVhOiBcIiMwRkZcIiwgYXF1YW1hcmluZTogXCIjN0ZGRkQ0XCIsIGF6dXJlOiBcIiNGMEZGRkZcIiwgYmVpZ2U6IFwiI0Y1RjVEQ1wiLCBiaXNxdWU6IFwiI0ZGRTRDNFwiLCBibGFjazogXCIjMDAwXCIsIGJsYW5jaGVkYWxtb25kOiBcIiNGRkVCQ0RcIiwgYmx1ZTogXCIjMDBGXCIsIGJsdWV2aW9sZXQ6IFwiIzhBMkJFMlwiLCBicm93bjogXCIjQTUyQTJBXCIsIGJ1cmx5d29vZDogXCIjREVCODg3XCIsIGNhZGV0Ymx1ZTogXCIjNUY5RUEwXCIsIGNoYXJ0cmV1c2U6IFwiIzdGRkYwMFwiLCBjaG9jb2xhdGU6IFwiI0QyNjkxRVwiLCBjb3JhbDogXCIjRkY3RjUwXCIsIGNvcm5mbG93ZXJibHVlOiBcIiM2NDk1RURcIiwgY29ybnNpbGs6IFwiI0ZGRjhEQ1wiLCBjcmltc29uOiBcIiNEQzE0M0NcIiwgY3lhbjogXCIjMEZGXCIsIGRhcmtibHVlOiBcIiMwMDAwOEJcIiwgZGFya2N5YW46IFwiIzAwOEI4QlwiLCBkYXJrZ29sZGVucm9kOiBcIiNCODg2MEJcIiwgZGFya2dyYXk6IFwiI0E5QTlBOVwiLCBkYXJrZ3JleTogXCIjQTlBOUE5XCIsIGRhcmtncmVlbjogXCIjMDA2NDAwXCIsIGRhcmtraGFraTogXCIjQkRCNzZCXCIsIGRhcmttYWdlbnRhOiBcIiM4QjAwOEJcIiwgZGFya29saXZlZ3JlZW46IFwiIzU1NkIyRlwiLCBkYXJrb3JhbmdlOiBcIiNGRjhDMDBcIiwgZGFya29yY2hpZDogXCIjOTkzMkNDXCIsIGRhcmtyZWQ6IFwiIzhCMDAwMFwiLCBkYXJrc2FsbW9uOiBcIiNFOTk2N0FcIiwgZGFya3NlYWdyZWVuOiBcIiM4RkJDOEZcIiwgZGFya3NsYXRlYmx1ZTogXCIjNDgzRDhCXCIsIGRhcmtzbGF0ZWdyYXk6IFwiIzJGNEY0RlwiLCBkYXJrc2xhdGVncmV5OiBcIiMyRjRGNEZcIiwgZGFya3R1cnF1b2lzZTogXCIjMDBDRUQxXCIsIGRhcmt2aW9sZXQ6IFwiIzk0MDBEM1wiLCBkZWVwcGluazogXCIjRkYxNDkzXCIsIGRlZXBza3libHVlOiBcIiMwMEJGRkZcIiwgZGltZ3JheTogXCIjNjk2OTY5XCIsIGRpbWdyZXk6IFwiIzY5Njk2OVwiLCBkb2RnZXJibHVlOiBcIiMxRTkwRkZcIiwgZmlyZWJyaWNrOiBcIiNCMjIyMjJcIiwgZmxvcmFsd2hpdGU6IFwiI0ZGRkFGMFwiLCBmb3Jlc3RncmVlbjogXCIjMjI4QjIyXCIsIGZ1Y2hzaWE6IFwiI0YwRlwiLCBnYWluc2Jvcm86IFwiI0RDRENEQ1wiLCBnaG9zdHdoaXRlOiBcIiNGOEY4RkZcIiwgZ29sZDogXCIjRkZENzAwXCIsIGdvbGRlbnJvZDogXCIjREFBNTIwXCIsIGdyYXk6IFwiIzgwODA4MFwiLCBncmV5OiBcIiM4MDgwODBcIiwgZ3JlZW46IFwiIzAwODAwMFwiLCBncmVlbnllbGxvdzogXCIjQURGRjJGXCIsIGhvbmV5ZGV3OiBcIiNGMEZGRjBcIiwgaG90cGluazogXCIjRkY2OUI0XCIsIGluZGlhbnJlZDogXCIjQ0Q1QzVDXCIsIGluZGlnbzogXCIjNEIwMDgyXCIsIGl2b3J5OiBcIiNGRkZGRjBcIiwga2hha2k6IFwiI0YwRTY4Q1wiLCBsYXZlbmRlcjogXCIjRTZFNkZBXCIsIGxhdmVuZGVyYmx1c2g6IFwiI0ZGRjBGNVwiLCBsYXduZ3JlZW46IFwiIzdDRkMwMFwiLCBsZW1vbmNoaWZmb246IFwiI0ZGRkFDRFwiLCBsaWdodGJsdWU6IFwiI0FERDhFNlwiLCBsaWdodGNvcmFsOiBcIiNGMDgwODBcIiwgbGlnaHRjeWFuOiBcIiNFMEZGRkZcIiwgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFwiI0ZBRkFEMlwiLCBsaWdodGdyYXk6IFwiI0QzRDNEM1wiLCBsaWdodGdyZXk6IFwiI0QzRDNEM1wiLCBsaWdodGdyZWVuOiBcIiM5MEVFOTBcIiwgbGlnaHRwaW5rOiBcIiNGRkI2QzFcIiwgbGlnaHRzYWxtb246IFwiI0ZGQTA3QVwiLCBsaWdodHNlYWdyZWVuOiBcIiMyMEIyQUFcIiwgbGlnaHRza3libHVlOiBcIiM4N0NFRkFcIiwgbGlnaHRzbGF0ZWdyYXk6IFwiIzc4OVwiLCBsaWdodHNsYXRlZ3JleTogXCIjNzg5XCIsIGxpZ2h0c3RlZWxibHVlOiBcIiNCMEM0REVcIiwgbGlnaHR5ZWxsb3c6IFwiI0ZGRkZFMFwiLCBsaW1lOiBcIiMwRjBcIiwgbGltZWdyZWVuOiBcIiMzMkNEMzJcIiwgbGluZW46IFwiI0ZBRjBFNlwiLCBtYWdlbnRhOiBcIiNGMEZcIiwgbWFyb29uOiBcIiM4MDAwMDBcIiwgbWVkaXVtYXF1YW1hcmluZTogXCIjNjZDREFBXCIsIG1lZGl1bWJsdWU6IFwiIzAwMDBDRFwiLCBtZWRpdW1vcmNoaWQ6IFwiI0JBNTVEM1wiLCBtZWRpdW1wdXJwbGU6IFwiIzkzNzBEQlwiLCBtZWRpdW1zZWFncmVlbjogXCIjM0NCMzcxXCIsIG1lZGl1bXNsYXRlYmx1ZTogXCIjN0I2OEVFXCIsIG1lZGl1bXNwcmluZ2dyZWVuOiBcIiMwMEZBOUFcIiwgbWVkaXVtdHVycXVvaXNlOiBcIiM0OEQxQ0NcIiwgbWVkaXVtdmlvbGV0cmVkOiBcIiNDNzE1ODVcIiwgbWlkbmlnaHRibHVlOiBcIiMxOTE5NzBcIiwgbWludGNyZWFtOiBcIiNGNUZGRkFcIiwgbWlzdHlyb3NlOiBcIiNGRkU0RTFcIiwgbW9jY2FzaW46IFwiI0ZGRTRCNVwiLCBuYXZham93aGl0ZTogXCIjRkZERUFEXCIsIG5hdnk6IFwiIzAwMDA4MFwiLCBvbGRsYWNlOiBcIiNGREY1RTZcIiwgb2xpdmU6IFwiIzgwODAwMFwiLCBvbGl2ZWRyYWI6IFwiIzZCOEUyM1wiLCBvcmFuZ2U6IFwiI0ZGQTUwMFwiLCBvcmFuZ2VyZWQ6IFwiI0ZGNDUwMFwiLCBvcmNoaWQ6IFwiI0RBNzBENlwiLCBwYWxlZ29sZGVucm9kOiBcIiNFRUU4QUFcIiwgcGFsZWdyZWVuOiBcIiM5OEZCOThcIiwgcGFsZXR1cnF1b2lzZTogXCIjQUZFRUVFXCIsIHBhbGV2aW9sZXRyZWQ6IFwiI0RCNzA5M1wiLCBwYXBheWF3aGlwOiBcIiNGRkVGRDVcIiwgcGVhY2hwdWZmOiBcIiNGRkRBQjlcIiwgcGVydTogXCIjQ0Q4NTNGXCIsIHBpbms6IFwiI0ZGQzBDQlwiLCBwbHVtOiBcIiNEREEwRERcIiwgcG93ZGVyYmx1ZTogXCIjQjBFMEU2XCIsIHB1cnBsZTogXCIjODAwMDgwXCIsIHJlYmVjY2FwdXJwbGU6IFwiIzYzOVwiLCByZWQ6IFwiI0YwMFwiLCByb3N5YnJvd246IFwiI0JDOEY4RlwiLCByb3lhbGJsdWU6IFwiIzQxNjlFMVwiLCBzYWRkbGVicm93bjogXCIjOEI0NTEzXCIsIHNhbG1vbjogXCIjRkE4MDcyXCIsIHNhbmR5YnJvd246IFwiI0Y0QTQ2MFwiLCBzZWFncmVlbjogXCIjMkU4QjU3XCIsIHNlYXNoZWxsOiBcIiNGRkY1RUVcIiwgc2llbm5hOiBcIiNBMDUyMkRcIiwgc2lsdmVyOiBcIiNDMEMwQzBcIiwgc2t5Ymx1ZTogXCIjODdDRUVCXCIsIHNsYXRlYmx1ZTogXCIjNkE1QUNEXCIsIHNsYXRlZ3JheTogXCIjNzA4MDkwXCIsIHNsYXRlZ3JleTogXCIjNzA4MDkwXCIsIHNub3c6IFwiI0ZGRkFGQVwiLCBzcHJpbmdncmVlbjogXCIjMDBGRjdGXCIsIHN0ZWVsYmx1ZTogXCIjNDY4MkI0XCIsIHRhbjogXCIjRDJCNDhDXCIsIHRlYWw6IFwiIzAwODA4MFwiLCB0aGlzdGxlOiBcIiNEOEJGRDhcIiwgdG9tYXRvOiBcIiNGRjYzNDdcIiwgdHVycXVvaXNlOiBcIiM0MEUwRDBcIiwgdmlvbGV0OiBcIiNFRTgyRUVcIiwgd2hlYXQ6IFwiI0Y1REVCM1wiLCB3aGl0ZTogXCIjRkZGXCIsIHdoaXRlc21va2U6IFwiI0Y1RjVGNVwiLCB5ZWxsb3c6IFwiI0ZGMFwiLCB5ZWxsb3dncmVlbjogXCIjOUFDRDMyXCIgfSwgTGkgPSAoaSwgdCwgZSkgPT4gKGUgPCAwICYmIChlICs9IDEpLCBlID4gMSAmJiAoZSAtPSAxKSwgZSA8IDEgLyA2ID8gaSArIDYgKiAodCAtIGkpICogZSA6IGUgPCAwLjUgPyB0IDogZSA8IDIgLyAzID8gaSArICh0IC0gaSkgKiAoMiAvIDMgLSBlKSAqIDYgOiBpKSwgdm8gPSAoaSwgdCwgZSwgcykgPT4ge1xuICBpIC89IDI1NSwgdCAvPSAyNTUsIGUgLz0gMjU1O1xuICBjb25zdCByID0gTWF0aC5tYXgoaSwgdCwgZSksIG4gPSBNYXRoLm1pbihpLCB0LCBlKTtcbiAgbGV0IG8sIGE7XG4gIGNvbnN0IGMgPSAociArIG4pIC8gMjtcbiAgaWYgKHIgPT09IG4pIG8gPSBhID0gMDtcbiAgZWxzZSB7XG4gICAgY29uc3QgbCA9IHIgLSBuO1xuICAgIHN3aXRjaCAoYSA9IGMgPiAwLjUgPyBsIC8gKDIgLSByIC0gbikgOiBsIC8gKHIgKyBuKSwgcikge1xuICAgICAgY2FzZSBpOlxuICAgICAgICBvID0gKHQgLSBlKSAvIGwgKyAodCA8IGUgPyA2IDogMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0OlxuICAgICAgICBvID0gKGUgLSBpKSAvIGwgKyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZTpcbiAgICAgICAgbyA9IChpIC0gdCkgLyBsICsgNDtcbiAgICB9XG4gICAgbyAvPSA2O1xuICB9XG4gIHJldHVybiBbTWF0aC5yb3VuZCgzNjAgKiBvKSwgTWF0aC5yb3VuZCgxMDAgKiBhKSwgTWF0aC5yb3VuZCgxMDAgKiBjKSwgc107XG59LCB5byA9IGZ1bmN0aW9uKCkge1xuICBsZXQgaSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogXCIxXCI7XG4gIHJldHVybiBwYXJzZUZsb2F0KGkpIC8gKGkuZW5kc1dpdGgoXCIlXCIpID8gMTAwIDogMSk7XG59LCB2ciA9IChpKSA9PiBNYXRoLm1pbihNYXRoLnJvdW5kKGkpLCAyNTUpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgYm8gPSAoaSkgPT4ge1xuICBsZXQgW3QsIGUsIHMsIHIgPSAxXSA9IGk7XG4gIGNvbnN0IG4gPSBNYXRoLnJvdW5kKDAuMyAqIHQgKyAwLjU5ICogZSArIDAuMTEgKiBzKTtcbiAgcmV0dXJuIFtuLCBuLCBuLCByXTtcbn07XG5jbGFzcyBXIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIGlmICh5KHRoaXMsIFwiaXNVbnJlY29nbmlzZWRcIiwgITEpLCB0KSBpZiAodCBpbnN0YW5jZW9mIFcpIHRoaXMuc2V0U291cmNlKFsuLi50Ll9zb3VyY2VdKTtcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICBjb25zdCBbZSwgcywgciwgbiA9IDFdID0gdDtcbiAgICAgIHRoaXMuc2V0U291cmNlKFtlLCBzLCByLCBuXSk7XG4gICAgfSBlbHNlIHRoaXMuc2V0U291cmNlKHRoaXMuX3RyeVBhcnNpbmdDb2xvcih0KSk7XG4gICAgZWxzZSB0aGlzLnNldFNvdXJjZShbMCwgMCwgMCwgMV0pO1xuICB9XG4gIF90cnlQYXJzaW5nQ29sb3IodCkge1xuICAgIHJldHVybiAodCA9IHQudG9Mb3dlckNhc2UoKSkgaW4gbW8gJiYgKHQgPSBtb1t0XSksIHQgPT09IFwidHJhbnNwYXJlbnRcIiA/IFsyNTUsIDI1NSwgMjU1LCAwXSA6IFcuc291cmNlRnJvbUhleCh0KSB8fCBXLnNvdXJjZUZyb21SZ2IodCkgfHwgVy5zb3VyY2VGcm9tSHNsKHQpIHx8ICh0aGlzLmlzVW5yZWNvZ25pc2VkID0gITApICYmIFswLCAwLCAwLCAxXTtcbiAgfVxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgfVxuICBzZXRTb3VyY2UodCkge1xuICAgIHRoaXMuX3NvdXJjZSA9IHQ7XG4gIH1cbiAgdG9SZ2IoKSB7XG4gICAgY29uc3QgW3QsIGUsIHNdID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICByZXR1cm4gXCJyZ2IoXCIuY29uY2F0KHQsIFwiLFwiKS5jb25jYXQoZSwgXCIsXCIpLmNvbmNhdChzLCBcIilcIik7XG4gIH1cbiAgdG9SZ2JhKCkge1xuICAgIHJldHVybiBcInJnYmEoXCIuY29uY2F0KHRoaXMuZ2V0U291cmNlKCkuam9pbihcIixcIiksIFwiKVwiKTtcbiAgfVxuICB0b0hzbCgpIHtcbiAgICBjb25zdCBbdCwgZSwgc10gPSB2byguLi50aGlzLmdldFNvdXJjZSgpKTtcbiAgICByZXR1cm4gXCJoc2woXCIuY29uY2F0KHQsIFwiLFwiKS5jb25jYXQoZSwgXCIlLFwiKS5jb25jYXQocywgXCIlKVwiKTtcbiAgfVxuICB0b0hzbGEoKSB7XG4gICAgY29uc3QgW3QsIGUsIHMsIHJdID0gdm8oLi4udGhpcy5nZXRTb3VyY2UoKSk7XG4gICAgcmV0dXJuIFwiaHNsYShcIi5jb25jYXQodCwgXCIsXCIpLmNvbmNhdChlLCBcIiUsXCIpLmNvbmNhdChzLCBcIiUsXCIpLmNvbmNhdChyLCBcIilcIik7XG4gIH1cbiAgdG9IZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9IZXhhKCkuc2xpY2UoMCwgNik7XG4gIH1cbiAgdG9IZXhhKCkge1xuICAgIGNvbnN0IFt0LCBlLCBzLCByXSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHZyKHQpKS5jb25jYXQodnIoZSkpLmNvbmNhdCh2cihzKSkuY29uY2F0KHZyKE1hdGgucm91bmQoMjU1ICogcikpKTtcbiAgfVxuICBnZXRBbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UoKVszXTtcbiAgfVxuICBzZXRBbHBoYSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZVszXSA9IHQsIHRoaXM7XG4gIH1cbiAgdG9HcmF5c2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0U291cmNlKGJvKHRoaXMuZ2V0U291cmNlKCkpKSwgdGhpcztcbiAgfVxuICB0b0JsYWNrV2hpdGUodCkge1xuICAgIGNvbnN0IFtlLCAsICwgc10gPSBibyh0aGlzLmdldFNvdXJjZSgpKSwgciA9IGUgPCAodCB8fCAxMjcpID8gMCA6IDI1NTtcbiAgICByZXR1cm4gdGhpcy5zZXRTb3VyY2UoW3IsIHIsIHIsIHNdKSwgdGhpcztcbiAgfVxuICBvdmVybGF5V2l0aCh0KSB7XG4gICAgdCBpbnN0YW5jZW9mIFcgfHwgKHQgPSBuZXcgVyh0KSk7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0U291cmNlKCksIHMgPSB0LmdldFNvdXJjZSgpLCBbciwgbiwgb10gPSBlLm1hcCgoYSwgYykgPT4gTWF0aC5yb3VuZCgwLjUgKiBhICsgMC41ICogc1tjXSkpO1xuICAgIHJldHVybiB0aGlzLnNldFNvdXJjZShbciwgbiwgbywgZVszXV0pLCB0aGlzO1xuICB9XG4gIHN0YXRpYyBmcm9tUmdiKHQpIHtcbiAgICByZXR1cm4gVy5mcm9tUmdiYSh0KTtcbiAgfVxuICBzdGF0aWMgZnJvbVJnYmEodCkge1xuICAgIHJldHVybiBuZXcgVyhXLnNvdXJjZUZyb21SZ2IodCkpO1xuICB9XG4gIHN0YXRpYyBzb3VyY2VGcm9tUmdiKHQpIHtcbiAgICBjb25zdCBlID0gdC5tYXRjaCgvXnJnYmE/XFwoXFxzKihcXGR7MCwzfSg/OlxcLlxcZCspPyU/KVxccypbXFxzfCxdXFxzKihcXGR7MCwzfSg/OlxcLlxcZCspPyU/KVxccypbXFxzfCxdXFxzKihcXGR7MCwzfSg/OlxcLlxcZCspPyU/KVxccyooPzpcXHMqWywvXVxccyooXFxkezAsM30oPzpcXC5cXGQrKT8lPylcXHMqKT9cXCkkL2kpO1xuICAgIGlmIChlKSB7XG4gICAgICBjb25zdCBbcywgciwgbl0gPSBlLnNsaWNlKDEsIDQpLm1hcCgobykgPT4ge1xuICAgICAgICBjb25zdCBhID0gcGFyc2VGbG9hdChvKTtcbiAgICAgICAgcmV0dXJuIG8uZW5kc1dpdGgoXCIlXCIpID8gTWF0aC5yb3VuZCgyLjU1ICogYSkgOiBhO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3MsIHIsIG4sIHlvKGVbNF0pXTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21Ic2wodCkge1xuICAgIHJldHVybiBXLmZyb21Ic2xhKHQpO1xuICB9XG4gIHN0YXRpYyBmcm9tSHNsYSh0KSB7XG4gICAgcmV0dXJuIG5ldyBXKFcuc291cmNlRnJvbUhzbCh0KSk7XG4gIH1cbiAgc3RhdGljIHNvdXJjZUZyb21Ic2wodCkge1xuICAgIGNvbnN0IGUgPSB0Lm1hdGNoKC9eaHNsYT9cXChcXHMqKFsrLV0/XFxkezAsM30oPzpcXC5cXGQrKT8oPzpkZWd8dHVybnxyYWQpPylcXHMqW1xcc3wsXVxccyooXFxkezAsM30oPzpcXC5cXGQrKT8lPylcXHMqW1xcc3wsXVxccyooXFxkezAsM30oPzpcXC5cXGQrKT8lPylcXHMqKD86XFxzKlssL11cXHMqKFxcZCooPzpcXC5cXGQrKT8lPylcXHMqKT9cXCkkL2kpO1xuICAgIGlmICghZSkgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSAoVy5wYXJzZUFuZ2xldG9EZWdyZWVzKGVbMV0pICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MCwgciA9IHBhcnNlRmxvYXQoZVsyXSkgLyAxMDAsIG4gPSBwYXJzZUZsb2F0KGVbM10pIC8gMTAwO1xuICAgIGxldCBvLCBhLCBjO1xuICAgIGlmIChyID09PSAwKSBvID0gYSA9IGMgPSBuO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbCA9IG4gPD0gMC41ID8gbiAqIChyICsgMSkgOiBuICsgciAtIG4gKiByLCBoID0gMiAqIG4gLSBsO1xuICAgICAgbyA9IExpKGgsIGwsIHMgKyAxIC8gMyksIGEgPSBMaShoLCBsLCBzKSwgYyA9IExpKGgsIGwsIHMgLSAxIC8gMyk7XG4gICAgfVxuICAgIHJldHVybiBbTWF0aC5yb3VuZCgyNTUgKiBvKSwgTWF0aC5yb3VuZCgyNTUgKiBhKSwgTWF0aC5yb3VuZCgyNTUgKiBjKSwgeW8oZVs0XSldO1xuICB9XG4gIHN0YXRpYyBmcm9tSGV4KHQpIHtcbiAgICByZXR1cm4gbmV3IFcoVy5zb3VyY2VGcm9tSGV4KHQpKTtcbiAgfVxuICBzdGF0aWMgc291cmNlRnJvbUhleCh0KSB7XG4gICAgaWYgKHQubWF0Y2goL14jPygoWzAtOWEtZl0pezMsNH18KFswLTlhLWZdezJ9KXszLDR9KSQvaSkpIHtcbiAgICAgIGNvbnN0IGUgPSB0LnNsaWNlKHQuaW5kZXhPZihcIiNcIikgKyAxKTtcbiAgICAgIGxldCBzO1xuICAgICAgcyA9IGUubGVuZ3RoIDw9IDQgPyBlLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4gYyArIGMpIDogZS5tYXRjaCgvLnsyfS9nKTtcbiAgICAgIGNvbnN0IFtyLCBuLCBvLCBhID0gMjU1XSA9IHMubWFwKChjKSA9PiBwYXJzZUludChjLCAxNikpO1xuICAgICAgcmV0dXJuIFtyLCBuLCBvLCBhIC8gMjU1XTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHBhcnNlQW5nbGV0b0RlZ3JlZXModCkge1xuICAgIGNvbnN0IGUgPSB0LnRvTG93ZXJDYXNlKCksIHMgPSBwYXJzZUZsb2F0KGUpO1xuICAgIHJldHVybiBlLmluY2x1ZGVzKFwicmFkXCIpID8gQ2UocykgOiBlLmluY2x1ZGVzKFwidHVyblwiKSA/IDM2MCAqIHMgOiBzO1xuICB9XG59XG5jb25zdCBWID0gKGksIHQpID0+IHBhcnNlRmxvYXQoTnVtYmVyKGkpLnRvRml4ZWQodCkpLCBXZSA9IGZ1bmN0aW9uKGkpIHtcbiAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IEVuO1xuICBjb25zdCBlID0gL1xcRHswLDJ9JC8uZXhlYyhpKSwgcyA9IHBhcnNlRmxvYXQoaSksIHIgPSBBLkRQSTtcbiAgc3dpdGNoIChlID09IG51bGwgPyB2b2lkIDAgOiBlWzBdKSB7XG4gICAgY2FzZSBcIm1tXCI6XG4gICAgICByZXR1cm4gcyAqIHIgLyAyNS40O1xuICAgIGNhc2UgXCJjbVwiOlxuICAgICAgcmV0dXJuIHMgKiByIC8gMi41NDtcbiAgICBjYXNlIFwiaW5cIjpcbiAgICAgIHJldHVybiBzICogcjtcbiAgICBjYXNlIFwicHRcIjpcbiAgICAgIHJldHVybiBzICogciAvIDcyO1xuICAgIGNhc2UgXCJwY1wiOlxuICAgICAgcmV0dXJuIHMgKiByIC8gNzIgKiAxMjtcbiAgICBjYXNlIFwiZW1cIjpcbiAgICAgIHJldHVybiBzICogdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHM7XG4gIH1cbn0sIHFhID0gKGkpID0+IHtcbiAgY29uc3QgW3QsIGVdID0gaS50cmltKCkuc3BsaXQoXCIgXCIpLCBbcywgcl0gPSAobiA9IHQpICYmIG4gIT09IHB0ID8gW24uc2xpY2UoMSwgNCksIG4uc2xpY2UoNSwgOCldIDogbiA9PT0gcHQgPyBbbiwgbl0gOiBbXCJNaWRcIiwgXCJNaWRcIl07XG4gIHZhciBuO1xuICByZXR1cm4geyBtZWV0T3JTbGljZTogZSB8fCBcIm1lZXRcIiwgYWxpZ25YOiBzLCBhbGlnblk6IHIgfTtcbn0sIHFzID0gKGkpID0+IFwibWF0cml4KFwiICsgaS5tYXAoKHQpID0+IFYodCwgQS5OVU1fRlJBQ1RJT05fRElHSVRTKSkuam9pbihcIiBcIikgKyBcIilcIiwgS3MgPSBmdW5jdGlvbihpLCB0KSB7XG4gIGxldCBlLCBzLCByID0gIShhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCkgfHwgYXJndW1lbnRzWzJdO1xuICBpZiAodCkgaWYgKHQudG9MaXZlKSBlID0gXCJ1cmwoI1NWR0lEX1wiLmNvbmNhdCh0LmlkLCBcIilcIik7XG4gIGVsc2Uge1xuICAgIGNvbnN0IG4gPSBuZXcgVyh0KSwgbyA9IG4uZ2V0QWxwaGEoKTtcbiAgICBlID0gbi50b1JnYigpLCBvICE9PSAxICYmIChzID0gby50b1N0cmluZygpKTtcbiAgfVxuICBlbHNlIGUgPSBcIm5vbmVcIjtcbiAgcmV0dXJuIHIgPyBcIlwiLmNvbmNhdChpLCBcIjogXCIpLmNvbmNhdChlLCBcIjsgXCIpLmNvbmNhdChzID8gXCJcIi5jb25jYXQoaSwgXCItb3BhY2l0eTogXCIpLmNvbmNhdChzLCBcIjsgXCIpIDogXCJcIikgOiBcIlwiLmNvbmNhdChpLCAnPVwiJykuY29uY2F0KGUsICdcIiAnKS5jb25jYXQocyA/IFwiXCIuY29uY2F0KGksICctb3BhY2l0eT1cIicpLmNvbmNhdChzLCAnXCIgJykgOiBcIlwiKTtcbn0sIEN0ID0gKGkpID0+ICEhaSAmJiBpLnRvTGl2ZSAhPT0gdm9pZCAwLCBfbyA9IChpKSA9PiAhIWkgJiYgdHlwZW9mIGkudG9PYmplY3QgPT0gXCJmdW5jdGlvblwiLCBTbyA9IChpKSA9PiAhIWkgJiYgaS5vZmZzZXRYICE9PSB2b2lkIDAgJiYgXCJzb3VyY2VcIiBpbiBpLCBQZSA9IChpKSA9PiAhIWkgJiYgXCJtdWx0aVNlbGVjdGlvblN0YWNraW5nXCIgaW4gaTtcbmZ1bmN0aW9uIEthKGkpIHtcbiAgY29uc3QgdCA9IGkgJiYgQXQoaSk7XG4gIGxldCBlID0gMCwgcyA9IDA7XG4gIGlmICghaSB8fCAhdCkgcmV0dXJuIHsgbGVmdDogZSwgdG9wOiBzIH07XG4gIGxldCByID0gaTtcbiAgY29uc3QgbiA9IHQuZG9jdW1lbnRFbGVtZW50LCBvID0gdC5ib2R5IHx8IHsgc2Nyb2xsTGVmdDogMCwgc2Nyb2xsVG9wOiAwIH07XG4gIGZvciAoOyByICYmIChyLnBhcmVudE5vZGUgfHwgci5ob3N0KSAmJiAociA9IHIucGFyZW50Tm9kZSB8fCByLmhvc3QsIHIgPT09IHQgPyAoZSA9IG8uc2Nyb2xsTGVmdCB8fCBuLnNjcm9sbExlZnQgfHwgMCwgcyA9IG8uc2Nyb2xsVG9wIHx8IG4uc2Nyb2xsVG9wIHx8IDApIDogKGUgKz0gci5zY3JvbGxMZWZ0IHx8IDAsIHMgKz0gci5zY3JvbGxUb3AgfHwgMCksIHIubm9kZVR5cGUgIT09IDEgfHwgci5zdHlsZS5wb3NpdGlvbiAhPT0gXCJmaXhlZFwiKTsgKSA7XG4gIHJldHVybiB7IGxlZnQ6IGUsIHRvcDogcyB9O1xufVxuY29uc3QgQXQgPSAoaSkgPT4gaS5vd25lckRvY3VtZW50IHx8IG51bGwsIEphID0gKGkpID0+IHtcbiAgdmFyIHQ7XG4gIHJldHVybiAoKHQgPSBpLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHQuZGVmYXVsdFZpZXcpIHx8IG51bGw7XG59LCBaYSA9IGZ1bmN0aW9uKGksIHQsIGUpIHtcbiAgbGV0IHsgd2lkdGg6IHMsIGhlaWdodDogciB9ID0gZSwgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzNdIDogMTtcbiAgaS53aWR0aCA9IHMsIGkuaGVpZ2h0ID0gciwgbiA+IDEgJiYgKGkuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgKHMgKiBuKS50b1N0cmluZygpKSwgaS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgKHIgKiBuKS50b1N0cmluZygpKSwgdC5zY2FsZShuLCBuKSk7XG59LCBubiA9IChpLCB0KSA9PiB7XG4gIGxldCB7IHdpZHRoOiBlLCBoZWlnaHQ6IHMgfSA9IHQ7XG4gIGUgJiYgKGkuc3R5bGUud2lkdGggPSB0eXBlb2YgZSA9PSBcIm51bWJlclwiID8gXCJcIi5jb25jYXQoZSwgXCJweFwiKSA6IGUpLCBzICYmIChpLnN0eWxlLmhlaWdodCA9IHR5cGVvZiBzID09IFwibnVtYmVyXCIgPyBcIlwiLmNvbmNhdChzLCBcInB4XCIpIDogcyk7XG59O1xuZnVuY3Rpb24gVG8oaSkge1xuICByZXR1cm4gaS5vbnNlbGVjdHN0YXJ0ICE9PSB2b2lkIDAgJiYgKGkub25zZWxlY3RzdGFydCA9ICgpID0+ICExKSwgaS5zdHlsZS51c2VyU2VsZWN0ID0gcHQsIGk7XG59XG5jbGFzcyBRYSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB5KHRoaXMsIFwiX29yaWdpbmFsQ2FudmFzU3R5bGVcIiwgdm9pZCAwKSwgeSh0aGlzLCBcImxvd2VyXCIsIHZvaWQgMCk7XG4gICAgY29uc3QgZSA9IHRoaXMuY3JlYXRlTG93ZXJDYW52YXModCk7XG4gICAgdGhpcy5sb3dlciA9IHsgZWw6IGUsIGN0eDogZS5nZXRDb250ZXh0KFwiMmRcIikgfTtcbiAgfVxuICBjcmVhdGVMb3dlckNhbnZhcyh0KSB7XG4gICAgY29uc3QgZSA9IChzID0gdCkgJiYgcy5nZXRDb250ZXh0ICE9PSB2b2lkIDAgPyB0IDogdCAmJiBDcygpLmdldEVsZW1lbnRCeUlkKHQpIHx8IGt0KCk7XG4gICAgdmFyIHM7XG4gICAgaWYgKGUuaGFzQXR0cmlidXRlKFwiZGF0YS1mYWJyaWNcIikpIHRocm93IG5ldyBZdChcIlRyeWluZyB0byBpbml0aWFsaXplIGEgY2FudmFzIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC4gRGlkIHlvdSBmb3JnZXQgdG8gZGlzcG9zZSB0aGUgY2FudmFzP1wiKTtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxDYW52YXNTdHlsZSA9IGUuc3R5bGUuY3NzVGV4dCwgZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWZhYnJpY1wiLCBcIm1haW5cIiksIGUuY2xhc3NMaXN0LmFkZChcImxvd2VyLWNhbnZhc1wiKSwgZTtcbiAgfVxuICBjbGVhbnVwRE9NKHQpIHtcbiAgICBsZXQgeyB3aWR0aDogZSwgaGVpZ2h0OiBzIH0gPSB0O1xuICAgIGNvbnN0IHsgZWw6IHIgfSA9IHRoaXMubG93ZXI7XG4gICAgci5jbGFzc0xpc3QucmVtb3ZlKFwibG93ZXItY2FudmFzXCIpLCByLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtZmFicmljXCIpLCByLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiXCIuY29uY2F0KGUpKSwgci5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCJcIi5jb25jYXQocykpLCByLnN0eWxlLmNzc1RleHQgPSB0aGlzLl9vcmlnaW5hbENhbnZhc1N0eWxlIHx8IFwiXCIsIHRoaXMuX29yaWdpbmFsQ2FudmFzU3R5bGUgPSB2b2lkIDA7XG4gIH1cbiAgc2V0RGltZW5zaW9ucyh0LCBlKSB7XG4gICAgY29uc3QgeyBlbDogcywgY3R4OiByIH0gPSB0aGlzLmxvd2VyO1xuICAgIFphKHMsIHIsIHQsIGUpO1xuICB9XG4gIHNldENTU0RpbWVuc2lvbnModCkge1xuICAgIG5uKHRoaXMubG93ZXIuZWwsIHQpO1xuICB9XG4gIGNhbGNPZmZzZXQoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBlO1xuICAgICAgY29uc3QgcyA9IHQgJiYgQXQodCksIHIgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgaWYgKCFzKSByZXR1cm4gcjtcbiAgICAgIGNvbnN0IG4gPSAoKGUgPSBKYSh0KSkgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpKSB8fCB7fTtcbiAgICAgIHIubGVmdCArPSBwYXJzZUludChuLmJvcmRlckxlZnRXaWR0aCwgMTApIHx8IDAsIHIudG9wICs9IHBhcnNlSW50KG4uYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwLCByLmxlZnQgKz0gcGFyc2VJbnQobi5wYWRkaW5nTGVmdCwgMTApIHx8IDAsIHIudG9wICs9IHBhcnNlSW50KG4ucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICBsZXQgbyA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICBjb25zdCBhID0gcy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gdm9pZCAwICYmIChvID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICBjb25zdCBjID0gS2EodCk7XG4gICAgICByZXR1cm4geyBsZWZ0OiBvLmxlZnQgKyBjLmxlZnQgLSAoYS5jbGllbnRMZWZ0IHx8IDApICsgci5sZWZ0LCB0b3A6IG8udG9wICsgYy50b3AgLSAoYS5jbGllbnRUb3AgfHwgMCkgKyByLnRvcCB9O1xuICAgIH0odGhpcy5sb3dlci5lbCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICAkdCgpLmRpc3Bvc2UodGhpcy5sb3dlci5lbCksIGRlbGV0ZSB0aGlzLmxvd2VyO1xuICB9XG59XG5jb25zdCBZaCA9IHsgYmFja2dyb3VuZFZwdDogITAsIGJhY2tncm91bmRDb2xvcjogXCJcIiwgb3ZlcmxheVZwdDogITAsIG92ZXJsYXlDb2xvcjogXCJcIiwgaW5jbHVkZURlZmF1bHRWYWx1ZXM6ICEwLCBzdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uOiAhMCwgcmVuZGVyT25BZGRSZW1vdmU6ICEwLCBza2lwT2Zmc2NyZWVuOiAhMCwgZW5hYmxlUmV0aW5hU2NhbGluZzogITAsIGltYWdlU21vb3RoaW5nRW5hYmxlZDogITAsIGNvbnRyb2xzQWJvdmVPdmVybGF5OiAhMSwgYWxsb3dUb3VjaFNjcm9sbGluZzogITEsIHZpZXdwb3J0VHJhbnNmb3JtOiBbLi4uaHRdIH07XG5jbGFzcyBsciBleHRlbmRzIHphKEhhKSB7XG4gIGdldCBsb3dlckNhbnZhc0VsKCkge1xuICAgIHZhciB0O1xuICAgIHJldHVybiAodCA9IHRoaXMuZWxlbWVudHMubG93ZXIpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHQuZWw7XG4gIH1cbiAgZ2V0IGNvbnRleHRDb250YWluZXIoKSB7XG4gICAgdmFyIHQ7XG4gICAgcmV0dXJuICh0ID0gdGhpcy5lbGVtZW50cy5sb3dlcikgPT09IG51bGwgfHwgdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdC5jdHg7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiBsci5vd25EZWZhdWx0cztcbiAgfVxuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgbGV0IGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHN1cGVyKCksIE9iamVjdC5hc3NpZ24odGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5nZXREZWZhdWx0cygpKSwgdGhpcy5zZXQoZSksIHRoaXMuaW5pdEVsZW1lbnRzKHQpLCB0aGlzLl9zZXREaW1lbnNpb25zSW1wbCh7IHdpZHRoOiB0aGlzLndpZHRoIHx8IHRoaXMuZWxlbWVudHMubG93ZXIuZWwud2lkdGggfHwgMCwgaGVpZ2h0OiB0aGlzLmhlaWdodCB8fCB0aGlzLmVsZW1lbnRzLmxvd2VyLmVsLmhlaWdodCB8fCAwIH0pLCB0aGlzLnNraXBDb250cm9sc0RyYXdpbmcgPSAhMSwgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IFsuLi50aGlzLnZpZXdwb3J0VHJhbnNmb3JtXSwgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gIH1cbiAgaW5pdEVsZW1lbnRzKHQpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFFhKHQpO1xuICB9XG4gIGFkZCgpIHtcbiAgICBjb25zdCB0ID0gc3VwZXIuYWRkKC4uLmFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCksIHQ7XG4gIH1cbiAgaW5zZXJ0QXQodCkge1xuICAgIGZvciAodmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoLCBzID0gbmV3IEFycmF5KGUgPiAxID8gZSAtIDEgOiAwKSwgciA9IDE7IHIgPCBlOyByKyspIHNbciAtIDFdID0gYXJndW1lbnRzW3JdO1xuICAgIGNvbnN0IG4gPSBzdXBlci5pbnNlcnRBdCh0LCAuLi5zKTtcbiAgICByZXR1cm4gcy5sZW5ndGggPiAwICYmIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCksIG47XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGNvbnN0IHQgPSBzdXBlci5yZW1vdmUoLi4uYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdC5sZW5ndGggPiAwICYmIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCksIHQ7XG4gIH1cbiAgX29uT2JqZWN0QWRkZWQodCkge1xuICAgIHQuY2FudmFzICYmIHQuY2FudmFzICE9PSB0aGlzICYmIChUZShcIndhcm5cIiwgYENhbnZhcyBpcyB0cnlpbmcgdG8gYWRkIGFuIG9iamVjdCB0aGF0IGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgY2FudmFzLlxuUmVzdWx0aW5nIHRvIGRlZmF1bHQgYmVoYXZpb3I6IHJlbW92aW5nIG9iamVjdCBmcm9tIHByZXZpb3VzIGNhbnZhcyBhbmQgYWRkaW5nIHRvIG5ldyBjYW52YXNgKSwgdC5jYW52YXMucmVtb3ZlKHQpKSwgdC5fc2V0KFwiY2FudmFzXCIsIHRoaXMpLCB0LnNldENvb3JkcygpLCB0aGlzLmZpcmUoXCJvYmplY3Q6YWRkZWRcIiwgeyB0YXJnZXQ6IHQgfSksIHQuZmlyZShcImFkZGVkXCIsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICB9XG4gIF9vbk9iamVjdFJlbW92ZWQodCkge1xuICAgIHQuX3NldChcImNhbnZhc1wiLCB2b2lkIDApLCB0aGlzLmZpcmUoXCJvYmplY3Q6cmVtb3ZlZFwiLCB7IHRhcmdldDogdCB9KSwgdC5maXJlKFwicmVtb3ZlZFwiLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgfVxuICBfb25TdGFja09yZGVyQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9XG4gIGdldFJldGluYVNjYWxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyA/IFJhKCkgOiAxO1xuICB9XG4gIGNhbGNPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldCA9IHRoaXMuZWxlbWVudHMuY2FsY09mZnNldCgpO1xuICB9XG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoO1xuICB9XG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gIH1cbiAgc2V0V2lkdGgodCwgZSkge1xuICAgIHJldHVybiB0aGlzLnNldERpbWVuc2lvbnMoeyB3aWR0aDogdCB9LCBlKTtcbiAgfVxuICBzZXRIZWlnaHQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLnNldERpbWVuc2lvbnMoeyBoZWlnaHQ6IHQgfSwgZSk7XG4gIH1cbiAgX3NldERpbWVuc2lvbnNJbXBsKHQpIHtcbiAgICBsZXQgeyBjc3NPbmx5OiBlID0gITEsIGJhY2tzdG9yZU9ubHk6IHMgPSAhMSB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpZiAoIWUpIHtcbiAgICAgIGNvbnN0IHIgPSB2KHsgd2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHQgfSwgdCk7XG4gICAgICB0aGlzLmVsZW1lbnRzLnNldERpbWVuc2lvbnMociwgdGhpcy5nZXRSZXRpbmFTY2FsaW5nKCkpLCB0aGlzLmhhc0xvc3RDb250ZXh0ID0gITAsIHRoaXMud2lkdGggPSByLndpZHRoLCB0aGlzLmhlaWdodCA9IHIuaGVpZ2h0O1xuICAgIH1cbiAgICBzIHx8IHRoaXMuZWxlbWVudHMuc2V0Q1NTRGltZW5zaW9ucyh0KSwgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucyh0LCBlKSB7XG4gICAgdGhpcy5fc2V0RGltZW5zaW9uc0ltcGwodCwgZSksIGUgJiYgZS5jc3NPbmx5IHx8IHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9XG4gIGdldFpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bMF07XG4gIH1cbiAgc2V0Vmlld3BvcnRUcmFuc2Zvcm0odCkge1xuICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB0LCB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKSwgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfVxuICB6b29tVG9Qb2ludCh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHQsIHIgPSBbLi4udGhpcy52aWV3cG9ydFRyYW5zZm9ybV0sIG4gPSBvdCh0LCBTdChyKSk7XG4gICAgclswXSA9IGUsIHJbM10gPSBlO1xuICAgIGNvbnN0IG8gPSBvdChuLCByKTtcbiAgICByWzRdICs9IHMueCAtIG8ueCwgcls1XSArPSBzLnkgLSBvLnksIHRoaXMuc2V0Vmlld3BvcnRUcmFuc2Zvcm0ocik7XG4gIH1cbiAgc2V0Wm9vbSh0KSB7XG4gICAgdGhpcy56b29tVG9Qb2ludChuZXcgXygwLCAwKSwgdCk7XG4gIH1cbiAgYWJzb2x1dGVQYW4odCkge1xuICAgIGNvbnN0IGUgPSBbLi4udGhpcy52aWV3cG9ydFRyYW5zZm9ybV07XG4gICAgcmV0dXJuIGVbNF0gPSAtdC54LCBlWzVdID0gLXQueSwgdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybShlKTtcbiAgfVxuICByZWxhdGl2ZVBhbih0KSB7XG4gICAgcmV0dXJuIHRoaXMuYWJzb2x1dGVQYW4obmV3IF8oLXQueCAtIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bNF0sIC10LnkgLSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzVdKSk7XG4gIH1cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5sb3dlci5lbDtcbiAgfVxuICBjbGVhckNvbnRleHQodCkge1xuICAgIHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmxvd2VyLmN0eDtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnJlbW92ZSguLi50aGlzLmdldE9iamVjdHMoKSksIHRoaXMuYmFja2dyb3VuZEltYWdlID0gdm9pZCAwLCB0aGlzLm92ZXJsYXlJbWFnZSA9IHZvaWQgMCwgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBcIlwiLCB0aGlzLm92ZXJsYXlDb2xvciA9IFwiXCIsIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKSwgdGhpcy5maXJlKFwiY2FudmFzOmNsZWFyZWRcIiksIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH1cbiAgcmVuZGVyQWxsKCkge1xuICAgIHRoaXMuY2FuY2VsUmVxdWVzdGVkUmVuZGVyKCksIHRoaXMuZGVzdHJveWVkIHx8IHRoaXMucmVuZGVyQ2FudmFzKHRoaXMuZ2V0Q29udGV4dCgpLCB0aGlzLl9vYmplY3RzKTtcbiAgfVxuICByZW5kZXJBbmRSZXNldCgpIHtcbiAgICB0aGlzLm5leHRSZW5kZXJIYW5kbGUgPSAwLCB0aGlzLnJlbmRlckFsbCgpO1xuICB9XG4gIHJlcXVlc3RSZW5kZXJBbGwoKSB7XG4gICAgdGhpcy5uZXh0UmVuZGVySGFuZGxlIHx8IHRoaXMuZGlzcG9zZWQgfHwgdGhpcy5kZXN0cm95ZWQgfHwgKHRoaXMubmV4dFJlbmRlckhhbmRsZSA9IEhzKCgpID0+IHRoaXMucmVuZGVyQW5kUmVzZXQoKSkpO1xuICB9XG4gIGNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMud2lkdGgsIGUgPSB0aGlzLmhlaWdodCwgcyA9IFN0KHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pLCByID0gb3QoeyB4OiAwLCB5OiAwIH0sIHMpLCBuID0gb3QoeyB4OiB0LCB5OiBlIH0sIHMpLCBvID0gci5taW4obiksIGEgPSByLm1heChuKTtcbiAgICByZXR1cm4gdGhpcy52cHRDb29yZHMgPSB7IHRsOiBvLCB0cjogbmV3IF8oYS54LCBvLnkpLCBibDogbmV3IF8oby54LCBhLnkpLCBicjogYSB9O1xuICB9XG4gIGNhbmNlbFJlcXVlc3RlZFJlbmRlcigpIHtcbiAgICB0aGlzLm5leHRSZW5kZXJIYW5kbGUgJiYgKFlhKHRoaXMubmV4dFJlbmRlckhhbmRsZSksIHRoaXMubmV4dFJlbmRlckhhbmRsZSA9IDApO1xuICB9XG4gIGRyYXdDb250cm9scyh0KSB7XG4gIH1cbiAgcmVuZGVyQ2FudmFzKHQsIGUpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBjb25zdCBzID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgciA9IHRoaXMuY2xpcFBhdGg7XG4gICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCksIHRoaXMuY2xlYXJDb250ZXh0KHQpLCB0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRoaXMuaW1hZ2VTbW9vdGhpbmdFbmFibGVkLCB0LnBhdHRlcm5RdWFsaXR5ID0gXCJiZXN0XCIsIHRoaXMuZmlyZShcImJlZm9yZTpyZW5kZXJcIiwgeyBjdHg6IHQgfSksIHRoaXMuX3JlbmRlckJhY2tncm91bmQodCksIHQuc2F2ZSgpLCB0LnRyYW5zZm9ybShzWzBdLCBzWzFdLCBzWzJdLCBzWzNdLCBzWzRdLCBzWzVdKSwgdGhpcy5fcmVuZGVyT2JqZWN0cyh0LCBlKSwgdC5yZXN0b3JlKCksIHRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgfHwgdGhpcy5za2lwQ29udHJvbHNEcmF3aW5nIHx8IHRoaXMuZHJhd0NvbnRyb2xzKHQpLCByICYmIChyLl9zZXQoXCJjYW52YXNcIiwgdGhpcyksIHIuc2hvdWxkQ2FjaGUoKSwgci5fdHJhbnNmb3JtRG9uZSA9ICEwLCByLnJlbmRlckNhY2hlKHsgZm9yQ2xpcHBpbmc6ICEwIH0pLCB0aGlzLmRyYXdDbGlwUGF0aE9uQ2FudmFzKHQsIHIpKSwgdGhpcy5fcmVuZGVyT3ZlcmxheSh0KSwgdGhpcy5jb250cm9sc0Fib3ZlT3ZlcmxheSAmJiAhdGhpcy5za2lwQ29udHJvbHNEcmF3aW5nICYmIHRoaXMuZHJhd0NvbnRyb2xzKHQpLCB0aGlzLmZpcmUoXCJhZnRlcjpyZW5kZXJcIiwgeyBjdHg6IHQgfSksIHRoaXMuX19jbGVhbnVwVGFzayAmJiAodGhpcy5fX2NsZWFudXBUYXNrKCksIHRoaXMuX19jbGVhbnVwVGFzayA9IHZvaWQgMCk7XG4gIH1cbiAgZHJhd0NsaXBQYXRoT25DYW52YXModCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgIHQuc2F2ZSgpLCB0LnRyYW5zZm9ybSguLi5zKSwgdC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCIsIGUudHJhbnNmb3JtKHQpLCB0LnNjYWxlKDEgLyBlLnpvb21YLCAxIC8gZS56b29tWSksIHQuZHJhd0ltYWdlKGUuX2NhY2hlQ2FudmFzLCAtZS5jYWNoZVRyYW5zbGF0aW9uWCwgLWUuY2FjaGVUcmFuc2xhdGlvblkpLCB0LnJlc3RvcmUoKTtcbiAgfVxuICBfcmVuZGVyT2JqZWN0cyh0LCBlKSB7XG4gICAgZm9yIChsZXQgcyA9IDAsIHIgPSBlLmxlbmd0aDsgcyA8IHI7ICsrcykgZVtzXSAmJiBlW3NdLnJlbmRlcih0KTtcbiAgfVxuICBfcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXNbXCJcIi5jb25jYXQoZSwgXCJDb2xvclwiKV0sIHIgPSB0aGlzW1wiXCIuY29uY2F0KGUsIFwiSW1hZ2VcIildLCBuID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgbyA9IHRoaXNbXCJcIi5jb25jYXQoZSwgXCJWcHRcIildO1xuICAgIGlmICghcyAmJiAhcikgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBDdChzKTtcbiAgICBpZiAocykge1xuICAgICAgaWYgKHQuc2F2ZSgpLCB0LmJlZ2luUGF0aCgpLCB0Lm1vdmVUbygwLCAwKSwgdC5saW5lVG8odGhpcy53aWR0aCwgMCksIHQubGluZVRvKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSwgdC5saW5lVG8oMCwgdGhpcy5oZWlnaHQpLCB0LmNsb3NlUGF0aCgpLCB0LmZpbGxTdHlsZSA9IGEgPyBzLnRvTGl2ZSh0KSA6IHMsIG8gJiYgdC50cmFuc2Zvcm0oLi4ubiksIGEpIHtcbiAgICAgICAgdC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgcy5vZmZzZXRYIHx8IDAsIHMub2Zmc2V0WSB8fCAwKTtcbiAgICAgICAgY29uc3QgYyA9IHMuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgcy5wYXR0ZXJuVHJhbnNmb3JtO1xuICAgICAgICBjICYmIHQudHJhbnNmb3JtKC4uLmMpO1xuICAgICAgfVxuICAgICAgdC5maWxsKCksIHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAocikge1xuICAgICAgdC5zYXZlKCk7XG4gICAgICBjb25zdCB7IHNraXBPZmZzY3JlZW46IGMgfSA9IHRoaXM7XG4gICAgICB0aGlzLnNraXBPZmZzY3JlZW4gPSBvLCBvICYmIHQudHJhbnNmb3JtKC4uLm4pLCByLnJlbmRlcih0KSwgdGhpcy5za2lwT2Zmc2NyZWVuID0gYywgdC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIF9yZW5kZXJCYWNrZ3JvdW5kKHQpIHtcbiAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5KHQsIFwiYmFja2dyb3VuZFwiKTtcbiAgfVxuICBfcmVuZGVyT3ZlcmxheSh0KSB7XG4gICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheSh0LCBcIm92ZXJsYXlcIik7XG4gIH1cbiAgZ2V0Q2VudGVyKCkge1xuICAgIHJldHVybiB7IHRvcDogdGhpcy5oZWlnaHQgLyAyLCBsZWZ0OiB0aGlzLndpZHRoIC8gMiB9O1xuICB9XG4gIGdldENlbnRlclBvaW50KCkge1xuICAgIHJldHVybiBuZXcgXyh0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyKTtcbiAgfVxuICBjZW50ZXJPYmplY3RIKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KHQsIG5ldyBfKHRoaXMuZ2V0Q2VudGVyUG9pbnQoKS54LCB0LmdldENlbnRlclBvaW50KCkueSkpO1xuICB9XG4gIGNlbnRlck9iamVjdFYodCkge1xuICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3QodCwgbmV3IF8odC5nZXRDZW50ZXJQb2ludCgpLngsIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gIH1cbiAgY2VudGVyT2JqZWN0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KHQsIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSk7XG4gIH1cbiAgdmlld3BvcnRDZW50ZXJPYmplY3QodCkge1xuICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3QodCwgdGhpcy5nZXRWcENlbnRlcigpKTtcbiAgfVxuICB2aWV3cG9ydENlbnRlck9iamVjdEgodCkge1xuICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3QodCwgbmV3IF8odGhpcy5nZXRWcENlbnRlcigpLngsIHQuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gIH1cbiAgdmlld3BvcnRDZW50ZXJPYmplY3RWKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KHQsIG5ldyBfKHQuZ2V0Q2VudGVyUG9pbnQoKS54LCB0aGlzLmdldFZwQ2VudGVyKCkueSkpO1xuICB9XG4gIGdldFZwQ2VudGVyKCkge1xuICAgIHJldHVybiBvdCh0aGlzLmdldENlbnRlclBvaW50KCksIFN0KHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pKTtcbiAgfVxuICBfY2VudGVyT2JqZWN0KHQsIGUpIHtcbiAgICB0LnNldFhZKGUsIGosIGopLCB0LnNldENvb3JkcygpLCB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9XG4gIHRvRGF0YWxlc3NKU09OKHQpIHtcbiAgICByZXR1cm4gdGhpcy50b0RhdGFsZXNzT2JqZWN0KHQpO1xuICB9XG4gIHRvT2JqZWN0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9PYmplY3RNZXRob2QoXCJ0b09iamVjdFwiLCB0KTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoKTtcbiAgfVxuICB0b0RhdGFsZXNzT2JqZWN0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9PYmplY3RNZXRob2QoXCJ0b0RhdGFsZXNzT2JqZWN0XCIsIHQpO1xuICB9XG4gIF90b09iamVjdE1ldGhvZCh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuY2xpcFBhdGgsIHIgPSBzICYmICFzLmV4Y2x1ZGVGcm9tRXhwb3J0ID8gdGhpcy5fdG9PYmplY3QocywgdCwgZSkgOiBudWxsO1xuICAgIHJldHVybiB2KHYodih7IHZlcnNpb246IHNuIH0sIFZlKHRoaXMsIGUpKSwge30sIHsgb2JqZWN0czogdGhpcy5fb2JqZWN0cy5maWx0ZXIoKG4pID0+ICFuLmV4Y2x1ZGVGcm9tRXhwb3J0KS5tYXAoKG4pID0+IHRoaXMuX3RvT2JqZWN0KG4sIHQsIGUpKSB9LCB0aGlzLl9fc2VyaWFsaXplQmdPdmVybGF5KHQsIGUpKSwgciA/IHsgY2xpcFBhdGg6IHIgfSA6IG51bGwpO1xuICB9XG4gIF90b09iamVjdCh0LCBlLCBzKSB7XG4gICAgbGV0IHI7XG4gICAgdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcyB8fCAociA9IHQuaW5jbHVkZURlZmF1bHRWYWx1ZXMsIHQuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSAhMSk7XG4gICAgY29uc3QgbiA9IHRbZV0ocyk7XG4gICAgcmV0dXJuIHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMgfHwgKHQuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSAhIXIpLCBuO1xuICB9XG4gIF9fc2VyaWFsaXplQmdPdmVybGF5KHQsIGUpIHtcbiAgICBjb25zdCBzID0ge30sIHIgPSB0aGlzLmJhY2tncm91bmRJbWFnZSwgbiA9IHRoaXMub3ZlcmxheUltYWdlLCBvID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IsIGEgPSB0aGlzLm92ZXJsYXlDb2xvcjtcbiAgICByZXR1cm4gQ3QobykgPyBvLmV4Y2x1ZGVGcm9tRXhwb3J0IHx8IChzLmJhY2tncm91bmQgPSBvLnRvT2JqZWN0KGUpKSA6IG8gJiYgKHMuYmFja2dyb3VuZCA9IG8pLCBDdChhKSA/IGEuZXhjbHVkZUZyb21FeHBvcnQgfHwgKHMub3ZlcmxheSA9IGEudG9PYmplY3QoZSkpIDogYSAmJiAocy5vdmVybGF5ID0gYSksIHIgJiYgIXIuZXhjbHVkZUZyb21FeHBvcnQgJiYgKHMuYmFja2dyb3VuZEltYWdlID0gdGhpcy5fdG9PYmplY3QociwgdCwgZSkpLCBuICYmICFuLmV4Y2x1ZGVGcm9tRXhwb3J0ICYmIChzLm92ZXJsYXlJbWFnZSA9IHRoaXMuX3RvT2JqZWN0KG4sIHQsIGUpKSwgcztcbiAgfVxuICB0b1NWRygpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge30sIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICB0LnJldml2ZXIgPSBlO1xuICAgIGNvbnN0IHMgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5fc2V0U1ZHUHJlYW1ibGUocywgdCksIHRoaXMuX3NldFNWR0hlYWRlcihzLCB0KSwgdGhpcy5jbGlwUGF0aCAmJiBzLnB1c2goJzxnIGNsaXAtcGF0aD1cInVybCgjJy5jb25jYXQodGhpcy5jbGlwUGF0aC5jbGlwUGF0aElkLCBgKVwiID5cbmApKSwgdGhpcy5fc2V0U1ZHQmdPdmVybGF5Q29sb3IocywgXCJiYWNrZ3JvdW5kXCIpLCB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShzLCBcImJhY2tncm91bmRJbWFnZVwiLCBlKSwgdGhpcy5fc2V0U1ZHT2JqZWN0cyhzLCBlKSwgdGhpcy5jbGlwUGF0aCAmJiBzLnB1c2goYDwvZz5cbmApLCB0aGlzLl9zZXRTVkdCZ092ZXJsYXlDb2xvcihzLCBcIm92ZXJsYXlcIiksIHRoaXMuX3NldFNWR0JnT3ZlcmxheUltYWdlKHMsIFwib3ZlcmxheUltYWdlXCIsIGUpLCBzLnB1c2goXCI8L3N2Zz5cIiksIHMuam9pbihcIlwiKTtcbiAgfVxuICBfc2V0U1ZHUHJlYW1ibGUodCwgZSkge1xuICAgIGUuc3VwcHJlc3NQcmVhbWJsZSB8fCB0LnB1c2goJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIicsIGUuZW5jb2RpbmcgfHwgXCJVVEYtOFwiLCBgXCIgc3RhbmRhbG9uZT1cIm5vXCIgPz5cbmAsICc8IURPQ1RZUEUgc3ZnIFBVQkxJQyBcIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOXCIgJywgYFwiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkXCI+XG5gKTtcbiAgfVxuICBfc2V0U1ZHSGVhZGVyKHQsIGUpIHtcbiAgICBjb25zdCBzID0gZS53aWR0aCB8fCBcIlwiLmNvbmNhdCh0aGlzLndpZHRoKSwgciA9IGUuaGVpZ2h0IHx8IFwiXCIuY29uY2F0KHRoaXMuaGVpZ2h0KSwgbiA9IEEuTlVNX0ZSQUNUSU9OX0RJR0lUUywgbyA9IGUudmlld0JveDtcbiAgICBsZXQgYTtcbiAgICBpZiAobykgYSA9ICd2aWV3Qm94PVwiJy5jb25jYXQoby54LCBcIiBcIikuY29uY2F0KG8ueSwgXCIgXCIpLmNvbmNhdChvLndpZHRoLCBcIiBcIikuY29uY2F0KG8uaGVpZ2h0LCAnXCIgJyk7XG4gICAgZWxzZSBpZiAodGhpcy5zdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIGEgPSAndmlld0JveD1cIicuY29uY2F0KFYoLWNbNF0gLyBjWzBdLCBuKSwgXCIgXCIpLmNvbmNhdChWKC1jWzVdIC8gY1szXSwgbiksIFwiIFwiKS5jb25jYXQoVih0aGlzLndpZHRoIC8gY1swXSwgbiksIFwiIFwiKS5jb25jYXQoVih0aGlzLmhlaWdodCAvIGNbM10sIG4pLCAnXCIgJyk7XG4gICAgfSBlbHNlIGEgPSAndmlld0JveD1cIjAgMCAnLmNvbmNhdCh0aGlzLndpZHRoLCBcIiBcIikuY29uY2F0KHRoaXMuaGVpZ2h0LCAnXCIgJyk7XG4gICAgdC5wdXNoKFwiPHN2ZyBcIiwgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnLCAneG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgJywgJ3ZlcnNpb249XCIxLjFcIiAnLCAnd2lkdGg9XCInLCBzLCAnXCIgJywgJ2hlaWdodD1cIicsIHIsICdcIiAnLCBhLCBgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cbmAsIFwiPGRlc2M+Q3JlYXRlZCB3aXRoIEZhYnJpYy5qcyBcIiwgc24sIGA8L2Rlc2M+XG5gLCBgPGRlZnM+XG5gLCB0aGlzLmNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cCgpLCB0aGlzLmNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwKCksIHRoaXMuY3JlYXRlU1ZHQ2xpcFBhdGhNYXJrdXAoZSksIGA8L2RlZnM+XG5gKTtcbiAgfVxuICBjcmVhdGVTVkdDbGlwUGF0aE1hcmt1cCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY2xpcFBhdGg7XG4gICAgcmV0dXJuIGUgPyAoZS5jbGlwUGF0aElkID0gXCJDTElQUEFUSF9cIi5jb25jYXQod2UoKSksICc8Y2xpcFBhdGggaWQ9XCInLmNvbmNhdChlLmNsaXBQYXRoSWQsIGBcIiA+XG5gKS5jb25jYXQoZS50b0NsaXBQYXRoU1ZHKHQucmV2aXZlciksIGA8L2NsaXBQYXRoPlxuYCkpIDogXCJcIjtcbiAgfVxuICBjcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cCgpIHtcbiAgICByZXR1cm4gW1wiYmFja2dyb3VuZFwiLCBcIm92ZXJsYXlcIl0ubWFwKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdGhpc1tcIlwiLmNvbmNhdCh0LCBcIkNvbG9yXCIpXTtcbiAgICAgIGlmIChDdChlKSkge1xuICAgICAgICBjb25zdCBzID0gdGhpc1tcIlwiLmNvbmNhdCh0LCBcIlZwdFwiKV0sIHIgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLCBuID0geyBpc1R5cGU6ICgpID0+ICExLCB3aWR0aDogdGhpcy53aWR0aCAvIChzID8gclswXSA6IDEpLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IC8gKHMgPyByWzNdIDogMSkgfTtcbiAgICAgICAgcmV0dXJuIGUudG9TVkcobiwgeyBhZGRpdGlvbmFsVHJhbnNmb3JtOiBzID8gcXMocikgOiBcIlwiIH0pO1xuICAgICAgfVxuICAgIH0pLmpvaW4oXCJcIik7XG4gIH1cbiAgY3JlYXRlU1ZHRm9udEZhY2VzTWFya3VwKCkge1xuICAgIGNvbnN0IHQgPSBbXSwgZSA9IHt9LCBzID0gQS5mb250UGF0aHM7XG4gICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIG4obykge1xuICAgICAgdC5wdXNoKG8pLCBWcihvKSAmJiBvLl9vYmplY3RzLmZvckVhY2gobik7XG4gICAgfSksIHQuZm9yRWFjaCgobikgPT4ge1xuICAgICAgaWYgKCEobyA9IG4pIHx8IHR5cGVvZiBvLl9yZW5kZXJUZXh0ICE9IFwiZnVuY3Rpb25cIikgcmV0dXJuO1xuICAgICAgdmFyIG87XG4gICAgICBjb25zdCB7IHN0eWxlczogYSwgZm9udEZhbWlseTogYyB9ID0gbjtcbiAgICAgICFlW2NdICYmIHNbY10gJiYgKGVbY10gPSAhMCwgYSAmJiBPYmplY3QudmFsdWVzKGEpLmZvckVhY2goKGwpID0+IHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhsKS5mb3JFYWNoKChoKSA9PiB7XG4gICAgICAgICAgbGV0IHsgZm9udEZhbWlseTogdSA9IFwiXCIgfSA9IGg7XG4gICAgICAgICAgIWVbdV0gJiYgc1t1XSAmJiAoZVt1XSA9ICEwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgY29uc3QgciA9IE9iamVjdC5rZXlzKGUpLm1hcCgobikgPT4gYFx0XHRAZm9udC1mYWNlIHtcblx0XHRcdGZvbnQtZmFtaWx5OiAnYC5jb25jYXQobiwgYCc7XG5cdFx0XHRzcmM6IHVybCgnYCkuY29uY2F0KHNbbl0sIGAnKTtcblx0XHR9XG5gKSkuam9pbihcIlwiKTtcbiAgICByZXR1cm4gciA/IGBcdDxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj48IVtDREFUQVtcbmAuY29uY2F0KHIsIGBdXT48L3N0eWxlPlxuYCkgOiBcIlwiO1xuICB9XG4gIF9zZXRTVkdPYmplY3RzKHQsIGUpIHtcbiAgICB0aGlzLmZvckVhY2hPYmplY3QoKHMpID0+IHtcbiAgICAgIHMuZXhjbHVkZUZyb21FeHBvcnQgfHwgdGhpcy5fc2V0U1ZHT2JqZWN0KHQsIHMsIGUpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRTVkdPYmplY3QodCwgZSwgcykge1xuICAgIHQucHVzaChlLnRvU1ZHKHMpKTtcbiAgfVxuICBfc2V0U1ZHQmdPdmVybGF5SW1hZ2UodCwgZSwgcykge1xuICAgIGNvbnN0IHIgPSB0aGlzW2VdO1xuICAgIHIgJiYgIXIuZXhjbHVkZUZyb21FeHBvcnQgJiYgci50b1NWRyAmJiB0LnB1c2goci50b1NWRyhzKSk7XG4gIH1cbiAgX3NldFNWR0JnT3ZlcmxheUNvbG9yKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpc1tcIlwiLmNvbmNhdChlLCBcIkNvbG9yXCIpXTtcbiAgICBpZiAocykgaWYgKEN0KHMpKSB7XG4gICAgICBjb25zdCByID0gcy5yZXBlYXQgfHwgXCJcIiwgbiA9IHRoaXMud2lkdGgsIG8gPSB0aGlzLmhlaWdodCwgYSA9IHRoaXNbXCJcIi5jb25jYXQoZSwgXCJWcHRcIildID8gcXMoU3QodGhpcy52aWV3cG9ydFRyYW5zZm9ybSkpIDogXCJcIjtcbiAgICAgIHQucHVzaCgnPHJlY3QgdHJhbnNmb3JtPVwiJy5jb25jYXQoYSwgXCIgdHJhbnNsYXRlKFwiKS5jb25jYXQobiAvIDIsIFwiLFwiKS5jb25jYXQobyAvIDIsICcpXCIgeD1cIicpLmNvbmNhdChzLm9mZnNldFggLSBuIC8gMiwgJ1wiIHk9XCInKS5jb25jYXQocy5vZmZzZXRZIC0gbyAvIDIsICdcIiB3aWR0aD1cIicpLmNvbmNhdChyICE9PSBcInJlcGVhdC15XCIgJiYgciAhPT0gXCJuby1yZXBlYXRcIiB8fCAhU28ocykgPyBuIDogcy5zb3VyY2Uud2lkdGgsICdcIiBoZWlnaHQ9XCInKS5jb25jYXQociAhPT0gXCJyZXBlYXQteFwiICYmIHIgIT09IFwibm8tcmVwZWF0XCIgfHwgIVNvKHMpID8gbyA6IHMuc291cmNlLmhlaWdodCwgJ1wiIGZpbGw9XCJ1cmwoI1NWR0lEXycpLmNvbmNhdChzLmlkLCBgKVwiPjwvcmVjdD5cbmApKTtcbiAgICB9IGVsc2UgdC5wdXNoKCc8cmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiICcsICdmaWxsPVwiJywgcywgJ1wiJywgYD48L3JlY3Q+XG5gKTtcbiAgfVxuICBsb2FkRnJvbUpTT04odCwgZSkge1xuICAgIGxldCB7IHNpZ25hbDogcyB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAoIXQpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgWXQoXCJganNvbmAgaXMgdW5kZWZpbmVkXCIpKTtcbiAgICBjb25zdCByID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UodCkgOiB0LCB7IG9iamVjdHM6IG4gPSBbXSwgYmFja2dyb3VuZEltYWdlOiBvLCBiYWNrZ3JvdW5kOiBhLCBvdmVybGF5SW1hZ2U6IGMsIG92ZXJsYXk6IGwsIGNsaXBQYXRoOiBoIH0gPSByLCB1ID0gdGhpcy5yZW5kZXJPbkFkZFJlbW92ZTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9ICExLCBQcm9taXNlLmFsbChbYnMobiwgeyByZXZpdmVyOiBlLCBzaWduYWw6IHMgfSksIGNyKHsgYmFja2dyb3VuZEltYWdlOiBvLCBiYWNrZ3JvdW5kQ29sb3I6IGEsIG92ZXJsYXlJbWFnZTogYywgb3ZlcmxheUNvbG9yOiBsLCBjbGlwUGF0aDogaCB9LCB7IHNpZ25hbDogcyB9KV0pLnRoZW4oKGQpID0+IHtcbiAgICAgIGxldCBbZiwgZ10gPSBkO1xuICAgICAgcmV0dXJuIHRoaXMuY2xlYXIoKSwgdGhpcy5hZGQoLi4uZiksIHRoaXMuc2V0KHIpLCB0aGlzLnNldChnKSwgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IHUsIHRoaXM7XG4gICAgfSk7XG4gIH1cbiAgY2xvbmUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnRvT2JqZWN0KHQpO1xuICAgIHJldHVybiB0aGlzLmNsb25lV2l0aG91dERhdGEoKS5sb2FkRnJvbUpTT04oZSk7XG4gIH1cbiAgY2xvbmVXaXRob3V0RGF0YSgpIHtcbiAgICBjb25zdCB0ID0gV3QodGhpcyk7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHQpO1xuICB9XG4gIHRvRGF0YVVSTCgpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3QgeyBmb3JtYXQ6IGUgPSBcInBuZ1wiLCBxdWFsaXR5OiBzID0gMSwgbXVsdGlwbGllcjogciA9IDEsIGVuYWJsZVJldGluYVNjYWxpbmc6IG4gPSAhMSB9ID0gdCwgbyA9IHIgKiAobiA/IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpIDogMSk7XG4gICAgcmV0dXJuIFJuKHRoaXMudG9DYW52YXNFbGVtZW50KG8sIHQpLCBlLCBzKTtcbiAgfVxuICB0b0Jsb2IoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IHsgZm9ybWF0OiBlID0gXCJwbmdcIiwgcXVhbGl0eTogcyA9IDEsIG11bHRpcGxpZXI6IHIgPSAxLCBlbmFibGVSZXRpbmFTY2FsaW5nOiBuID0gITEgfSA9IHQsIG8gPSByICogKG4gPyB0aGlzLmdldFJldGluYVNjYWxpbmcoKSA6IDEpO1xuICAgIHJldHVybiBMbih0aGlzLnRvQ2FudmFzRWxlbWVudChvLCB0KSwgZSwgcyk7XG4gIH1cbiAgdG9DYW52YXNFbGVtZW50KCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAxLCB7IHdpZHRoOiBlLCBoZWlnaHQ6IHMsIGxlZnQ6IHIsIHRvcDogbiwgZmlsdGVyOiBvIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IGEgPSAoZSB8fCB0aGlzLndpZHRoKSAqIHQsIGMgPSAocyB8fCB0aGlzLmhlaWdodCkgKiB0LCBsID0gdGhpcy5nZXRab29tKCksIGggPSB0aGlzLndpZHRoLCB1ID0gdGhpcy5oZWlnaHQsIGQgPSB0aGlzLnNraXBDb250cm9sc0RyYXdpbmcsIGYgPSBsICogdCwgZyA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIHAgPSBbZiwgMCwgMCwgZiwgKGdbNF0gLSAociB8fCAwKSkgKiB0LCAoZ1s1XSAtIChuIHx8IDApKSAqIHRdLCBtID0gdGhpcy5lbmFibGVSZXRpbmFTY2FsaW5nLCBiID0gV3QoeyB3aWR0aDogYSwgaGVpZ2h0OiBjIH0pLCBTID0gbyA/IHRoaXMuX29iamVjdHMuZmlsdGVyKCh3KSA9PiBvKHcpKSA6IHRoaXMuX29iamVjdHM7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyA9ICExLCB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gcCwgdGhpcy53aWR0aCA9IGEsIHRoaXMuaGVpZ2h0ID0gYywgdGhpcy5za2lwQ29udHJvbHNEcmF3aW5nID0gITAsIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpLCB0aGlzLnJlbmRlckNhbnZhcyhiLmdldENvbnRleHQoXCIyZFwiKSwgUyksIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSBnLCB0aGlzLndpZHRoID0gaCwgdGhpcy5oZWlnaHQgPSB1LCB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKSwgdGhpcy5lbmFibGVSZXRpbmFTY2FsaW5nID0gbSwgdGhpcy5za2lwQ29udHJvbHNEcmF3aW5nID0gZCwgYjtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHJldHVybiAhdGhpcy5kaXNwb3NlZCAmJiB0aGlzLmVsZW1lbnRzLmNsZWFudXBET00oeyB3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCB9KSwgcXIuY2FuY2VsQnlDYW52YXModGhpcyksIHRoaXMuZGlzcG9zZWQgPSAhMCwgbmV3IFByb21pc2UoKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IHMgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpLCB0KCEwKTtcbiAgICAgIH07XG4gICAgICBzLmtpbGwgPSBlLCB0aGlzLl9fY2xlYW51cFRhc2sgJiYgdGhpcy5fX2NsZWFudXBUYXNrLmtpbGwoXCJhYm9ydGVkXCIpLCB0aGlzLmRlc3Ryb3llZCA/IHQoITEpIDogdGhpcy5uZXh0UmVuZGVySGFuZGxlID8gdGhpcy5fX2NsZWFudXBUYXNrID0gcyA6IHMoKTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gITAsIHRoaXMuY2FuY2VsUmVxdWVzdGVkUmVuZGVyKCksIHRoaXMuZm9yRWFjaE9iamVjdCgodCkgPT4gdC5kaXNwb3NlKCkpLCB0aGlzLl9vYmplY3RzID0gW10sIHRoaXMuYmFja2dyb3VuZEltYWdlICYmIHRoaXMuYmFja2dyb3VuZEltYWdlLmRpc3Bvc2UoKSwgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSB2b2lkIDAsIHRoaXMub3ZlcmxheUltYWdlICYmIHRoaXMub3ZlcmxheUltYWdlLmRpc3Bvc2UoKSwgdGhpcy5vdmVybGF5SW1hZ2UgPSB2b2lkIDAsIHRoaXMuZWxlbWVudHMuZGlzcG9zZSgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIiM8Q2FudmFzIChcIi5jb25jYXQodGhpcy5jb21wbGV4aXR5KCksIFwiKTogeyBvYmplY3RzOiBcIikuY29uY2F0KHRoaXMuX29iamVjdHMubGVuZ3RoLCBcIiB9PlwiKTtcbiAgfVxufVxueShsciwgXCJvd25EZWZhdWx0c1wiLCBZaCk7XG5jb25zdCBWaCA9IFtcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGVuZFwiXSwgdGMgPSAoaSkgPT4ge1xuICBjb25zdCB0ID0gS2EoaS50YXJnZXQpLCBlID0gZnVuY3Rpb24ocykge1xuICAgIGNvbnN0IHIgPSBzLmNoYW5nZWRUb3VjaGVzO1xuICAgIHJldHVybiByICYmIHJbMF0gPyByWzBdIDogcztcbiAgfShpKTtcbiAgcmV0dXJuIG5ldyBfKGUuY2xpZW50WCArIHQubGVmdCwgZS5jbGllbnRZICsgdC50b3ApO1xufSwgS3IgPSAoaSkgPT4gVmguaW5jbHVkZXMoaS50eXBlKSB8fCBpLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIsIG9uID0gKGkpID0+IHtcbiAgaS5wcmV2ZW50RGVmYXVsdCgpLCBpLnN0b3BQcm9wYWdhdGlvbigpO1xufSwgR3QgPSAoaSkgPT4ge1xuICBsZXQgdCA9IDAsIGUgPSAwLCBzID0gMCwgciA9IDA7XG4gIGZvciAobGV0IG4gPSAwLCBvID0gaS5sZW5ndGg7IG4gPCBvOyBuKyspIHtcbiAgICBjb25zdCB7IHg6IGEsIHk6IGMgfSA9IGlbbl07XG4gICAgKGEgPiBzIHx8ICFuKSAmJiAocyA9IGEpLCAoYSA8IHQgfHwgIW4pICYmICh0ID0gYSksIChjID4gciB8fCAhbikgJiYgKHIgPSBjKSwgKGMgPCBlIHx8ICFuKSAmJiAoZSA9IGMpO1xuICB9XG4gIHJldHVybiB7IGxlZnQ6IHQsIHRvcDogZSwgd2lkdGg6IHMgLSB0LCBoZWlnaHQ6IHIgLSBlIH07XG59LCBHaCA9IFtcInRyYW5zbGF0ZVhcIiwgXCJ0cmFuc2xhdGVZXCIsIFwic2NhbGVYXCIsIFwic2NhbGVZXCJdLCBlYyA9IChpLCB0KSA9PiBfcyhpLCBKKHQsIGkuY2FsY093bk1hdHJpeCgpKSksIF9zID0gKGksIHQpID0+IHtcbiAgY29uc3QgZSA9IHlzKHQpLCB7IHRyYW5zbGF0ZVg6IHMsIHRyYW5zbGF0ZVk6IHIsIHNjYWxlWDogbiwgc2NhbGVZOiBvIH0gPSBlLCBhID0gRyhlLCBHaCksIGMgPSBuZXcgXyhzLCByKTtcbiAgaS5mbGlwWCA9ICExLCBpLmZsaXBZID0gITEsIE9iamVjdC5hc3NpZ24oaSwgYSksIGkuc2V0KHsgc2NhbGVYOiBuLCBzY2FsZVk6IG8gfSksIGkuc2V0UG9zaXRpb25CeU9yaWdpbihjLCBqLCBqKTtcbn0sIHNjID0gKGkpID0+IHtcbiAgaS5zY2FsZVggPSAxLCBpLnNjYWxlWSA9IDEsIGkuc2tld1ggPSAwLCBpLnNrZXdZID0gMCwgaS5mbGlwWCA9ICExLCBpLmZsaXBZID0gITEsIGkucm90YXRlKDApO1xufSwgem4gPSAoaSkgPT4gKHsgc2NhbGVYOiBpLnNjYWxlWCwgc2NhbGVZOiBpLnNjYWxlWSwgc2tld1g6IGkuc2tld1gsIHNrZXdZOiBpLnNrZXdZLCBhbmdsZTogaS5hbmdsZSwgbGVmdDogaS5sZWZ0LCBmbGlwWDogaS5mbGlwWCwgZmxpcFk6IGkuZmxpcFksIHRvcDogaS50b3AgfSksIHlpID0gKGksIHQsIGUpID0+IHtcbiAgY29uc3QgcyA9IGkgLyAyLCByID0gdCAvIDIsIG4gPSBbbmV3IF8oLXMsIC1yKSwgbmV3IF8ocywgLXIpLCBuZXcgXygtcywgciksIG5ldyBfKHMsIHIpXS5tYXAoKGEpID0+IGEudHJhbnNmb3JtKGUpKSwgbyA9IEd0KG4pO1xuICByZXR1cm4gbmV3IF8oby53aWR0aCwgby5oZWlnaHQpO1xufSwgaHIgPSBmdW5jdGlvbigpIHtcbiAgbGV0IGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IGh0O1xuICByZXR1cm4gSihTdChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGh0KSwgaSk7XG59LCBhZSA9IGZ1bmN0aW9uKGkpIHtcbiAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGh0LCBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiBodDtcbiAgcmV0dXJuIGkudHJhbnNmb3JtKGhyKHQsIGUpKTtcbn0sIHJjID0gZnVuY3Rpb24oaSkge1xuICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogaHQsIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IGh0O1xuICByZXR1cm4gaS50cmFuc2Zvcm0oaHIodCwgZSksICEwKTtcbn0sIGFuID0gKGksIHQsIGUpID0+IHtcbiAgY29uc3QgcyA9IGhyKHQsIGUpO1xuICByZXR1cm4gX3MoaSwgSihzLCBpLmNhbGNPd25NYXRyaXgoKSkpLCBzO1xufSwgSG4gPSAoaSwgdCkgPT4ge1xuICB2YXIgZTtcbiAgY29uc3QgeyB0cmFuc2Zvcm06IHsgdGFyZ2V0OiBzIH0gfSA9IHQ7XG4gIChlID0gcy5jYW52YXMpID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCB8fCBlLmZpcmUoXCJvYmplY3Q6XCIuY29uY2F0KGkpLCB2KHYoe30sIHQpLCB7fSwgeyB0YXJnZXQ6IHMgfSkpLCBzLmZpcmUoaSwgdCk7XG59LCBOaCA9IHsgbGVmdDogLTAuNSwgdG9wOiAtMC41LCBjZW50ZXI6IDAsIGJvdHRvbTogMC41LCByaWdodDogMC41IH0sIHN0ID0gKGkpID0+IHR5cGVvZiBpID09IFwic3RyaW5nXCIgPyBOaFtpXSA6IGkgLSAwLjUsIEpyID0gXCJub3QtYWxsb3dlZFwiO1xuZnVuY3Rpb24gaWMoaSkge1xuICByZXR1cm4gc3QoaS5vcmlnaW5YKSA9PT0gc3QoaikgJiYgc3QoaS5vcmlnaW5ZKSA9PT0gc3Qoaik7XG59XG5mdW5jdGlvbiB4byhpKSB7XG4gIHJldHVybiAwLjUgLSBzdChpKTtcbn1cbmNvbnN0IFJ0ID0gKGksIHQpID0+IGlbdF0sIFluID0gKGksIHQsIGUsIHMpID0+ICh7IGU6IGksIHRyYW5zZm9ybTogdCwgcG9pbnRlcjogbmV3IF8oZSwgcykgfSk7XG5mdW5jdGlvbiBuYyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLmdldFRvdGFsQW5nbGUoKSArIENlKE1hdGguYXRhbjIodC55LCB0LngpKSArIDM2MDtcbiAgcmV0dXJuIE1hdGgucm91bmQoZSAlIDM2MCAvIDQ1KTtcbn1cbmZ1bmN0aW9uIGJpKGksIHQsIGUsIHMsIHIpIHtcbiAgdmFyIG47XG4gIGxldCB7IHRhcmdldDogbywgY29ybmVyOiBhIH0gPSBpO1xuICBjb25zdCBjID0gby5jb250cm9sc1thXSwgbCA9ICgobiA9IG8uY2FudmFzKSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLmdldFpvb20oKSkgfHwgMSwgaCA9IG8ucGFkZGluZyAvIGwsIHUgPSBmdW5jdGlvbihkLCBmLCBnLCBwKSB7XG4gICAgY29uc3QgbSA9IGQuZ2V0UmVsYXRpdmVDZW50ZXJQb2ludCgpLCBiID0gZyAhPT0gdm9pZCAwICYmIHAgIT09IHZvaWQgMCA/IGQudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihtLCBqLCBqLCBnLCBwKSA6IG5ldyBfKGQubGVmdCwgZC50b3ApO1xuICAgIHJldHVybiAoZC5hbmdsZSA/IGYucm90YXRlKC1LKGQuYW5nbGUpLCBtKSA6IGYpLnN1YnRyYWN0KGIpO1xuICB9KG8sIG5ldyBfKHMsIHIpLCB0LCBlKTtcbiAgcmV0dXJuIHUueCA+PSBoICYmICh1LnggLT0gaCksIHUueCA8PSAtaCAmJiAodS54ICs9IGgpLCB1LnkgPj0gaCAmJiAodS55IC09IGgpLCB1LnkgPD0gaCAmJiAodS55ICs9IGgpLCB1LnggLT0gYy5vZmZzZXRYLCB1LnkgLT0gYy5vZmZzZXRZLCB1O1xufVxuY29uc3Qgb2MgPSAoaSwgdCwgZSwgcykgPT4ge1xuICBjb25zdCB7IHRhcmdldDogciwgb2Zmc2V0WDogbiwgb2Zmc2V0WTogbyB9ID0gdCwgYSA9IGUgLSBuLCBjID0gcyAtIG8sIGwgPSAhUnQociwgXCJsb2NrTW92ZW1lbnRYXCIpICYmIHIubGVmdCAhPT0gYSwgaCA9ICFSdChyLCBcImxvY2tNb3ZlbWVudFlcIikgJiYgci50b3AgIT09IGM7XG4gIHJldHVybiBsICYmIHIuc2V0KEwsIGEpLCBoICYmIHIuc2V0KGd0LCBjKSwgKGwgfHwgaCkgJiYgSG4oTGEsIFluKGksIHQsIGUsIHMpKSwgbCB8fCBoO1xufTtcbmNsYXNzIGFjIHtcbiAgZ2V0U3ZnU3R5bGVzKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5maWxsUnVsZSA/IHRoaXMuZmlsbFJ1bGUgOiBcIm5vbnplcm9cIiwgcyA9IHRoaXMuc3Ryb2tlV2lkdGggPyB0aGlzLnN0cm9rZVdpZHRoIDogXCIwXCIsIHIgPSB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmpvaW4oXCIgXCIpIDogcHQsIG4gPSB0aGlzLnN0cm9rZURhc2hPZmZzZXQgPyB0aGlzLnN0cm9rZURhc2hPZmZzZXQgOiBcIjBcIiwgbyA9IHRoaXMuc3Ryb2tlTGluZUNhcCA/IHRoaXMuc3Ryb2tlTGluZUNhcCA6IFwiYnV0dFwiLCBhID0gdGhpcy5zdHJva2VMaW5lSm9pbiA/IHRoaXMuc3Ryb2tlTGluZUpvaW4gOiBcIm1pdGVyXCIsIGMgPSB0aGlzLnN0cm9rZU1pdGVyTGltaXQgPyB0aGlzLnN0cm9rZU1pdGVyTGltaXQgOiBcIjRcIiwgbCA9IHRoaXMub3BhY2l0eSAhPT0gdm9pZCAwID8gdGhpcy5vcGFjaXR5IDogXCIxXCIsIGggPSB0aGlzLnZpc2libGUgPyBcIlwiIDogXCIgdmlzaWJpbGl0eTogaGlkZGVuO1wiLCB1ID0gdCA/IFwiXCIgOiB0aGlzLmdldFN2Z0ZpbHRlcigpLCBkID0gS3MocnQsIHRoaXMuZmlsbCk7XG4gICAgcmV0dXJuIFtLcyhtdCwgdGhpcy5zdHJva2UpLCBcInN0cm9rZS13aWR0aDogXCIsIHMsIFwiOyBcIiwgXCJzdHJva2UtZGFzaGFycmF5OiBcIiwgciwgXCI7IFwiLCBcInN0cm9rZS1saW5lY2FwOiBcIiwgbywgXCI7IFwiLCBcInN0cm9rZS1kYXNob2Zmc2V0OiBcIiwgbiwgXCI7IFwiLCBcInN0cm9rZS1saW5lam9pbjogXCIsIGEsIFwiOyBcIiwgXCJzdHJva2UtbWl0ZXJsaW1pdDogXCIsIGMsIFwiOyBcIiwgZCwgXCJmaWxsLXJ1bGU6IFwiLCBlLCBcIjsgXCIsIFwib3BhY2l0eTogXCIsIGwsIFwiO1wiLCB1LCBoXS5qb2luKFwiXCIpO1xuICB9XG4gIGdldFN2Z0ZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkb3cgPyBcImZpbHRlcjogdXJsKCNTVkdJRF9cIi5jb25jYXQodGhpcy5zaGFkb3cuaWQsIFwiKTtcIikgOiBcIlwiO1xuICB9XG4gIGdldFN2Z0NvbW1vbnMoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmlkID8gJ2lkPVwiJy5jb25jYXQodGhpcy5pZCwgJ1wiICcpIDogXCJcIiwgdGhpcy5jbGlwUGF0aCA/ICdjbGlwLXBhdGg9XCJ1cmwoIycuY29uY2F0KHRoaXMuY2xpcFBhdGguY2xpcFBhdGhJZCwgJylcIiAnKSA6IFwiXCJdLmpvaW4oXCJcIik7XG4gIH1cbiAgZ2V0U3ZnVHJhbnNmb3JtKHQpIHtcbiAgICBsZXQgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogXCJcIjtcbiAgICBjb25zdCBzID0gdCA/IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpIDogdGhpcy5jYWxjT3duTWF0cml4KCksIHIgPSAndHJhbnNmb3JtPVwiJy5jb25jYXQocXMocykpO1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChyKS5jb25jYXQoZSwgJ1wiICcpO1xuICB9XG4gIF90b1NWRyh0KSB7XG4gICAgcmV0dXJuIFtcIlwiXTtcbiAgfVxuICB0b1NWRyh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAodGhpcy5fdG9TVkcodCksIHsgcmV2aXZlcjogdCB9KTtcbiAgfVxuICB0b0NsaXBQYXRoU1ZHKHQpIHtcbiAgICByZXR1cm4gXCJcdFwiICsgdGhpcy5fY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwKHRoaXMuX3RvU1ZHKHQpLCB7IHJldml2ZXI6IHQgfSk7XG4gIH1cbiAgX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cCh0KSB7XG4gICAgbGV0IHsgcmV2aXZlcjogZSwgYWRkaXRpb25hbFRyYW5zZm9ybTogcyA9IFwiXCIgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgciA9IFt0aGlzLmdldFN2Z1RyYW5zZm9ybSghMCwgcyksIHRoaXMuZ2V0U3ZnQ29tbW9ucygpXS5qb2luKFwiXCIpLCBuID0gdC5pbmRleE9mKFwiQ09NTU9OX1BBUlRTXCIpO1xuICAgIHJldHVybiB0W25dID0gciwgZSA/IGUodC5qb2luKFwiXCIpKSA6IHQuam9pbihcIlwiKTtcbiAgfVxuICBfY3JlYXRlQmFzZVNWR01hcmt1cCh0KSB7XG4gICAgbGV0IHsgbm9TdHlsZTogZSwgcmV2aXZlcjogcywgd2l0aFNoYWRvdzogciwgYWRkaXRpb25hbFRyYW5zZm9ybTogbiB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBvID0gZSA/IFwiXCIgOiAnc3R5bGU9XCInLmNvbmNhdCh0aGlzLmdldFN2Z1N0eWxlcygpLCAnXCIgJyksIGEgPSByID8gJ3N0eWxlPVwiJy5jb25jYXQodGhpcy5nZXRTdmdGaWx0ZXIoKSwgJ1wiICcpIDogXCJcIiwgYyA9IHRoaXMuY2xpcFBhdGgsIGwgPSB0aGlzLnN0cm9rZVVuaWZvcm0gPyAndmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiICcgOiBcIlwiLCBoID0gYyAmJiBjLmFic29sdXRlUG9zaXRpb25lZCwgdSA9IHRoaXMuc3Ryb2tlLCBkID0gdGhpcy5maWxsLCBmID0gdGhpcy5zaGFkb3csIGcgPSBbXSwgcCA9IHQuaW5kZXhPZihcIkNPTU1PTl9QQVJUU1wiKTtcbiAgICBsZXQgbTtcbiAgICBjICYmIChjLmNsaXBQYXRoSWQgPSBcIkNMSVBQQVRIX1wiLmNvbmNhdCh3ZSgpKSwgbSA9ICc8Y2xpcFBhdGggaWQ9XCInLmNvbmNhdChjLmNsaXBQYXRoSWQsIGBcIiA+XG5gKS5jb25jYXQoYy50b0NsaXBQYXRoU1ZHKHMpLCBgPC9jbGlwUGF0aD5cbmApKSwgaCAmJiBnLnB1c2goXCI8ZyBcIiwgYSwgdGhpcy5nZXRTdmdDb21tb25zKCksIGAgPlxuYCksIGcucHVzaChcIjxnIFwiLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSghMSksIGggPyBcIlwiIDogYSArIHRoaXMuZ2V0U3ZnQ29tbW9ucygpLCBgID5cbmApO1xuICAgIGNvbnN0IGIgPSBbbywgbCwgZSA/IFwiXCIgOiB0aGlzLmFkZFBhaW50T3JkZXIoKSwgXCIgXCIsIG4gPyAndHJhbnNmb3JtPVwiJy5jb25jYXQobiwgJ1wiICcpIDogXCJcIl0uam9pbihcIlwiKTtcbiAgICByZXR1cm4gdFtwXSA9IGIsIEN0KGQpICYmIGcucHVzaChkLnRvU1ZHKHRoaXMpKSwgQ3QodSkgJiYgZy5wdXNoKHUudG9TVkcodGhpcykpLCBmICYmIGcucHVzaChmLnRvU1ZHKHRoaXMpKSwgYyAmJiBnLnB1c2gobSksIGcucHVzaCh0LmpvaW4oXCJcIikpLCBnLnB1c2goYDwvZz5cbmApLCBoICYmIGcucHVzaChgPC9nPlxuYCksIHMgPyBzKGcuam9pbihcIlwiKSkgOiBnLmpvaW4oXCJcIik7XG4gIH1cbiAgYWRkUGFpbnRPcmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludEZpcnN0ICE9PSBydCA/ICcgcGFpbnQtb3JkZXI9XCInLmNvbmNhdCh0aGlzLnBhaW50Rmlyc3QsICdcIiAnKSA6IFwiXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pKGkpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKFwiICsgaS5qb2luKFwifFwiKSArIFwiKVxcXFxiXCIsIFwiaVwiKTtcbn1cbnZhciB3bztcbmNvbnN0IFhlID0gU3RyaW5nLnJhdyh3byB8fCAod28gPSBNZShbXCIoPzpbLStdPyg/OmQqLmQrfGQrLj8pKD86W2VFXVstK10/ZCspPylcIl0sIFtcIig/OlstK10/KD86XFxcXGQqXFxcXC5cXFxcZCt8XFxcXGQrXFxcXC4/KSg/OltlRV1bLStdP1xcXFxkKyk/KVwiXSkpKSwgVWggPSBuZXcgUmVnRXhwKFwiKG5vcm1hbHxpdGFsaWMpP1xcXFxzKihub3JtYWx8c21hbGwtY2Fwcyk/XFxcXHMqKG5vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwKT9cXFxccyooXCIgKyBYZSArIFwiKD86cHh8Y218bW18ZW18cHR8cGN8aW4pKikoPzpcXFxcLyhub3JtYWx8XCIgKyBYZSArIFwiKSk/XFxcXHMrKC4qKVwiKSwgJGggPSB7IGN4OiBMLCB4OiBMLCByOiBcInJhZGl1c1wiLCBjeTogZ3QsIHk6IGd0LCBkaXNwbGF5OiBcInZpc2libGVcIiwgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCIsIHRyYW5zZm9ybTogXCJ0cmFuc2Zvcm1NYXRyaXhcIiwgXCJmaWxsLW9wYWNpdHlcIjogXCJmaWxsT3BhY2l0eVwiLCBcImZpbGwtcnVsZVwiOiBcImZpbGxSdWxlXCIsIFwiZm9udC1mYW1pbHlcIjogXCJmb250RmFtaWx5XCIsIFwiZm9udC1zaXplXCI6IFwiZm9udFNpemVcIiwgXCJmb250LXN0eWxlXCI6IFwiZm9udFN0eWxlXCIsIFwiZm9udC13ZWlnaHRcIjogXCJmb250V2VpZ2h0XCIsIFwibGV0dGVyLXNwYWNpbmdcIjogXCJjaGFyU3BhY2luZ1wiLCBcInBhaW50LW9yZGVyXCI6IFwicGFpbnRGaXJzdFwiLCBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJzdHJva2VEYXNoQXJyYXlcIiwgXCJzdHJva2UtZGFzaG9mZnNldFwiOiBcInN0cm9rZURhc2hPZmZzZXRcIiwgXCJzdHJva2UtbGluZWNhcFwiOiBcInN0cm9rZUxpbmVDYXBcIiwgXCJzdHJva2UtbGluZWpvaW5cIjogXCJzdHJva2VMaW5lSm9pblwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCI6IFwic3Ryb2tlTWl0ZXJMaW1pdFwiLCBcInN0cm9rZS1vcGFjaXR5XCI6IFwic3Ryb2tlT3BhY2l0eVwiLCBcInN0cm9rZS13aWR0aFwiOiBcInN0cm9rZVdpZHRoXCIsIFwidGV4dC1kZWNvcmF0aW9uXCI6IFwidGV4dERlY29yYXRpb25cIiwgXCJ0ZXh0LWFuY2hvclwiOiBcInRleHRBbmNob3JcIiwgb3BhY2l0eTogXCJvcGFjaXR5XCIsIFwiY2xpcC1wYXRoXCI6IFwiY2xpcFBhdGhcIiwgXCJjbGlwLXJ1bGVcIjogXCJjbGlwUnVsZVwiLCBcInZlY3Rvci1lZmZlY3RcIjogXCJzdHJva2VVbmlmb3JtXCIsIFwiaW1hZ2UtcmVuZGVyaW5nXCI6IFwiaW1hZ2VTbW9vdGhpbmdcIiB9LCBCaSA9IFwiZm9udC1zaXplXCIsIFdpID0gXCJjbGlwLXBhdGhcIjtcbl9pKFtcInBhdGhcIiwgXCJjaXJjbGVcIiwgXCJwb2x5Z29uXCIsIFwicG9seWxpbmVcIiwgXCJlbGxpcHNlXCIsIFwicmVjdFwiLCBcImxpbmVcIiwgXCJpbWFnZVwiLCBcInRleHRcIl0pO1xuX2koW1wic3ltYm9sXCIsIFwiaW1hZ2VcIiwgXCJtYXJrZXJcIiwgXCJwYXR0ZXJuXCIsIFwidmlld1wiLCBcInN2Z1wiXSk7XG5jb25zdCBDbyA9IF9pKFtcInN5bWJvbFwiLCBcImdcIiwgXCJhXCIsIFwic3ZnXCIsIFwiY2xpcFBhdGhcIiwgXCJkZWZzXCJdKSwgcWggPSBuZXcgXygxLCAwKSwgY2MgPSBuZXcgXygpLCBWbiA9IChpLCB0KSA9PiBpLnJvdGF0ZSh0KSwgWnIgPSAoaSwgdCkgPT4gbmV3IF8odCkuc3VidHJhY3QoaSksIFFyID0gKGkpID0+IGkuZGlzdGFuY2VGcm9tKGNjKSwgdGkgPSAoaSwgdCkgPT4gTWF0aC5hdGFuMihwcyhpLCB0KSwgaGMoaSwgdCkpLCBsYyA9IChpKSA9PiB0aShxaCwgaSksIFNpID0gKGkpID0+IGkuZXEoY2MpID8gaSA6IGkuc2NhbGFyRGl2aWRlKFFyKGkpKSwgR24gPSBmdW5jdGlvbihpKSB7XG4gIGxldCB0ID0gIShhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCkgfHwgYXJndW1lbnRzWzFdO1xuICByZXR1cm4gU2kobmV3IF8oLWkueSwgaS54KS5zY2FsYXJNdWx0aXBseSh0ID8gMSA6IC0xKSk7XG59LCBwcyA9IChpLCB0KSA9PiBpLnggKiB0LnkgLSBpLnkgKiB0LngsIGhjID0gKGksIHQpID0+IGkueCAqIHQueCArIGkueSAqIHQueSwgY24gPSAoaSwgdCwgZSkgPT4ge1xuICBpZiAoaS5lcSh0KSB8fCBpLmVxKGUpKSByZXR1cm4gITA7XG4gIGNvbnN0IHMgPSBwcyh0LCBlKSwgciA9IHBzKHQsIGkpLCBuID0gcHMoZSwgaSk7XG4gIHJldHVybiBzID49IDAgPyByID49IDAgJiYgbiA8PSAwIDogIShyIDw9IDAgJiYgbiA+PSAwKTtcbn0sIE9vID0gXCIoLT9cXFxcZCsoPzpcXFxcLlxcXFxkKik/KD86cHgpPyg/OlxcXFxzP3wkKSk/XCIsIGtvID0gbmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBPbyArIE9vICsgXCIoXCIgKyBYZSArIFwiPyg/OnB4KT8pPyg/OlxcXFxzP3wkKSg/OiR8XFxcXHMpXCIpO1xuY2xhc3MgY2Uge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgY29uc3QgZSA9IHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBjZS5wYXJzZVNoYWRvdyh0KSA6IHQ7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZS5vd25EZWZhdWx0cywgZSksIHRoaXMuaWQgPSB3ZSgpO1xuICB9XG4gIHN0YXRpYyBwYXJzZVNoYWRvdyh0KSB7XG4gICAgY29uc3QgZSA9IHQudHJpbSgpLCBbLCBzID0gMCwgciA9IDAsIG4gPSAwXSA9IChrby5leGVjKGUpIHx8IFtdKS5tYXAoKG8pID0+IHBhcnNlRmxvYXQobykgfHwgMCk7XG4gICAgcmV0dXJuIHsgY29sb3I6IChlLnJlcGxhY2Uoa28sIFwiXCIpIHx8IFwicmdiKDAsMCwwKVwiKS50cmltKCksIG9mZnNldFg6IHMsIG9mZnNldFk6IHIsIGJsdXI6IG4gfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gW3RoaXMub2Zmc2V0WCwgdGhpcy5vZmZzZXRZLCB0aGlzLmJsdXIsIHRoaXMuY29sb3JdLmpvaW4oXCJweCBcIik7XG4gIH1cbiAgdG9TVkcodCkge1xuICAgIGNvbnN0IGUgPSBWbihuZXcgXyh0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSksIEsoLXQuYW5nbGUpKSwgcyA9IG5ldyBXKHRoaXMuY29sb3IpO1xuICAgIGxldCByID0gNDAsIG4gPSA0MDtcbiAgICByZXR1cm4gdC53aWR0aCAmJiB0LmhlaWdodCAmJiAociA9IDEwMCAqIFYoKE1hdGguYWJzKGUueCkgKyB0aGlzLmJsdXIpIC8gdC53aWR0aCwgQS5OVU1fRlJBQ1RJT05fRElHSVRTKSArIDIwLCBuID0gMTAwICogVigoTWF0aC5hYnMoZS55KSArIHRoaXMuYmx1cikgLyB0LmhlaWdodCwgQS5OVU1fRlJBQ1RJT05fRElHSVRTKSArIDIwKSwgdC5mbGlwWCAmJiAoZS54ICo9IC0xKSwgdC5mbGlwWSAmJiAoZS55ICo9IC0xKSwgJzxmaWx0ZXIgaWQ9XCJTVkdJRF8nLmNvbmNhdCh0aGlzLmlkLCAnXCIgeT1cIi0nKS5jb25jYXQobiwgJyVcIiBoZWlnaHQ9XCInKS5jb25jYXQoMTAwICsgMiAqIG4sICclXCIgeD1cIi0nKS5jb25jYXQociwgJyVcIiB3aWR0aD1cIicpLmNvbmNhdCgxMDAgKyAyICogciwgYCVcIiA+XG5cdDxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwiYCkuY29uY2F0KFYodGhpcy5ibHVyID8gdGhpcy5ibHVyIC8gMiA6IDAsIEEuTlVNX0ZSQUNUSU9OX0RJR0lUUyksIGBcIj48L2ZlR2F1c3NpYW5CbHVyPlxuXHQ8ZmVPZmZzZXQgZHg9XCJgKS5jb25jYXQoVihlLngsIEEuTlVNX0ZSQUNUSU9OX0RJR0lUUyksICdcIiBkeT1cIicpLmNvbmNhdChWKGUueSwgQS5OVU1fRlJBQ1RJT05fRElHSVRTKSwgYFwiIHJlc3VsdD1cIm9CbHVyXCIgPjwvZmVPZmZzZXQ+XG5cdDxmZUZsb29kIGZsb29kLWNvbG9yPVwiYCkuY29uY2F0KHMudG9SZ2IoKSwgJ1wiIGZsb29kLW9wYWNpdHk9XCInKS5jb25jYXQocy5nZXRBbHBoYSgpLCBgXCIvPlxuXHQ8ZmVDb21wb3NpdGUgaW4yPVwib0JsdXJcIiBvcGVyYXRvcj1cImluXCIgLz5cblx0PGZlTWVyZ2U+XG5cdFx0PGZlTWVyZ2VOb2RlPjwvZmVNZXJnZU5vZGU+XG5cdFx0PGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiPjwvZmVNZXJnZU5vZGU+XG5cdDwvZmVNZXJnZT5cbjwvZmlsdGVyPlxuYCk7XG4gIH1cbiAgdG9PYmplY3QoKSB7XG4gICAgY29uc3QgdCA9IHsgY29sb3I6IHRoaXMuY29sb3IsIGJsdXI6IHRoaXMuYmx1ciwgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLCBvZmZzZXRZOiB0aGlzLm9mZnNldFksIGFmZmVjdFN0cm9rZTogdGhpcy5hZmZlY3RTdHJva2UsIG5vblNjYWxpbmc6IHRoaXMubm9uU2NhbGluZywgdHlwZTogdGhpcy5jb25zdHJ1Y3Rvci50eXBlIH0sIGUgPSBjZS5vd25EZWZhdWx0cztcbiAgICByZXR1cm4gdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcyA/IHQgOiBYbih0LCAocywgcikgPT4gcyAhPT0gZVtyXSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21PYmplY3QodCkge1xuICAgIHJldHVybiBuZXcgdGhpcyh0KTtcbiAgfVxufVxueShjZSwgXCJvd25EZWZhdWx0c1wiLCB7IGNvbG9yOiBcInJnYigwLDAsMClcIiwgYmx1cjogMCwgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCwgYWZmZWN0U3Ryb2tlOiAhMSwgaW5jbHVkZURlZmF1bHRWYWx1ZXM6ICEwLCBub25TY2FsaW5nOiAhMSB9KSwgeShjZSwgXCJ0eXBlXCIsIFwic2hhZG93XCIpLCBDLnNldENsYXNzKGNlLCBcInNoYWRvd1wiKTtcbmNvbnN0IHplID0gKGksIHQsIGUpID0+IE1hdGgubWF4KGksIE1hdGgubWluKHQsIGUpKSwgS2ggPSBbZ3QsIEwsIHV0LCBUdCwgXCJmbGlwWFwiLCBcImZsaXBZXCIsIFwib3JpZ2luWFwiLCBcIm9yaWdpbllcIiwgXCJhbmdsZVwiLCBcIm9wYWNpdHlcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJzaGFkb3dcIiwgXCJ2aXNpYmxlXCIsIE9zLCBrc10sIGRlID0gW3J0LCBtdCwgXCJzdHJva2VXaWR0aFwiLCBcInN0cm9rZURhc2hBcnJheVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwicGFpbnRGaXJzdFwiLCBcInN0cm9rZVVuaWZvcm1cIiwgXCJzdHJva2VMaW5lQ2FwXCIsIFwic3Ryb2tlRGFzaE9mZnNldFwiLCBcInN0cm9rZUxpbmVKb2luXCIsIFwic3Ryb2tlTWl0ZXJMaW1pdFwiLCBcImJhY2tncm91bmRDb2xvclwiLCBcImNsaXBQYXRoXCJdLCBKaCA9IHsgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBhbmdsZTogMCwgZmxpcFg6ICExLCBmbGlwWTogITEsIHNjYWxlWDogMSwgc2NhbGVZOiAxLCBtaW5TY2FsZUxpbWl0OiAwLCBza2V3WDogMCwgc2tld1k6IDAsIG9yaWdpblg6IEwsIG9yaWdpblk6IGd0LCBzdHJva2VXaWR0aDogMSwgc3Ryb2tlVW5pZm9ybTogITEsIHBhZGRpbmc6IDAsIG9wYWNpdHk6IDEsIHBhaW50Rmlyc3Q6IHJ0LCBmaWxsOiBcInJnYigwLDAsMClcIiwgZmlsbFJ1bGU6IFwibm9uemVyb1wiLCBzdHJva2U6IG51bGwsIHN0cm9rZURhc2hBcnJheTogbnVsbCwgc3Ryb2tlRGFzaE9mZnNldDogMCwgc3Ryb2tlTGluZUNhcDogXCJidXR0XCIsIHN0cm9rZUxpbmVKb2luOiBcIm1pdGVyXCIsIHN0cm9rZU1pdGVyTGltaXQ6IDQsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjogXCJzb3VyY2Utb3ZlclwiLCBiYWNrZ3JvdW5kQ29sb3I6IFwiXCIsIHNoYWRvdzogbnVsbCwgdmlzaWJsZTogITAsIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiAhMCwgZXhjbHVkZUZyb21FeHBvcnQ6ICExLCBvYmplY3RDYWNoaW5nOiAhMCwgY2xpcFBhdGg6IHZvaWQgMCwgaW52ZXJ0ZWQ6ICExLCBhYnNvbHV0ZVBvc2l0aW9uZWQ6ICExLCBjZW50ZXJlZFJvdGF0aW9uOiAhMCwgY2VudGVyZWRTY2FsaW5nOiAhMSwgZGlydHk6ICEwIH0sIFhpID0gKGksIHQsIGUsIHMpID0+IChpIDwgTWF0aC5hYnModCkgPyAoaSA9IHQsIHMgPSBlIC8gNCkgOiBzID0gdCA9PT0gMCAmJiBpID09PSAwID8gZSAvIGhlICogTWF0aC5hc2luKDEpIDogZSAvIGhlICogTWF0aC5hc2luKHQgLyBpKSwgeyBhOiBpLCBjOiB0LCBwOiBlLCBzIH0pLCBNbyA9IChpLCB0LCBlLCBzLCByKSA9PiBpICogTWF0aC5wb3coMiwgMTAgKiAocyAtPSAxKSkgKiBNYXRoLnNpbigocyAqIHIgLSB0KSAqIGhlIC8gZSksIHVjID0gKGksIHQsIGUsIHMpID0+IC1lICogTWF0aC5jb3MoaSAvIHMgKiB4ZSkgKyBlICsgdCwgbG4gPSAoaSwgdCwgZSwgcykgPT4gKGkgLz0gcykgPCAxIC8gMi43NSA/IGUgKiAoNy41NjI1ICogaSAqIGkpICsgdCA6IGkgPCAyIC8gMi43NSA/IGUgKiAoNy41NjI1ICogKGkgLT0gMS41IC8gMi43NSkgKiBpICsgMC43NSkgKyB0IDogaSA8IDIuNSAvIDIuNzUgPyBlICogKDcuNTYyNSAqIChpIC09IDIuMjUgLyAyLjc1KSAqIGkgKyAwLjkzNzUpICsgdCA6IGUgKiAoNy41NjI1ICogKGkgLT0gMi42MjUgLyAyLjc1KSAqIGkgKyAwLjk4NDM3NSkgKyB0LCBJbyA9IChpLCB0LCBlLCBzKSA9PiBlIC0gbG4ocyAtIGksIDAsIGUsIHMpICsgdDtcbnZhciBaaCA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGRlZmF1bHRFYXNpbmc6IHVjLCBlYXNlSW5CYWNrOiBmdW5jdGlvbihpLCB0LCBlLCBzKSB7XG4gIGxldCByID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbNF0gOiAxLjcwMTU4O1xuICByZXR1cm4gZSAqIChpIC89IHMpICogaSAqICgociArIDEpICogaSAtIHIpICsgdDtcbn0sIGVhc2VJbkJvdW5jZTogSW8sIGVhc2VJbkNpcmM6IChpLCB0LCBlLCBzKSA9PiAtZSAqIChNYXRoLnNxcnQoMSAtIChpIC89IHMpICogaSkgLSAxKSArIHQsIGVhc2VJbkN1YmljOiAoaSwgdCwgZSwgcykgPT4gZSAqIChpIC8gcykgKiogMyArIHQsIGVhc2VJbkVsYXN0aWM6IChpLCB0LCBlLCBzKSA9PiB7XG4gIGNvbnN0IHIgPSBlO1xuICBsZXQgbiA9IDA7XG4gIGlmIChpID09PSAwKSByZXR1cm4gdDtcbiAgaWYgKChpIC89IHMpID09PSAxKSByZXR1cm4gdCArIGU7XG4gIG4gfHwgKG4gPSAwLjMgKiBzKTtcbiAgY29uc3QgeyBhOiBvLCBzOiBhLCBwOiBjIH0gPSBYaShyLCBlLCBuLCAxLjcwMTU4KTtcbiAgcmV0dXJuIC1NbyhvLCBhLCBjLCBpLCBzKSArIHQ7XG59LCBlYXNlSW5FeHBvOiAoaSwgdCwgZSwgcykgPT4gaSA9PT0gMCA/IHQgOiBlICogMiAqKiAoMTAgKiAoaSAvIHMgLSAxKSkgKyB0LCBlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbihpLCB0LCBlLCBzKSB7XG4gIGxldCByID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbNF0gOiAxLjcwMTU4O1xuICByZXR1cm4gKGkgLz0gcyAvIDIpIDwgMSA/IGUgLyAyICogKGkgKiBpICogKCgxICsgKHIgKj0gMS41MjUpKSAqIGkgLSByKSkgKyB0IDogZSAvIDIgKiAoKGkgLT0gMikgKiBpICogKCgxICsgKHIgKj0gMS41MjUpKSAqIGkgKyByKSArIDIpICsgdDtcbn0sIGVhc2VJbk91dEJvdW5jZTogKGksIHQsIGUsIHMpID0+IGkgPCBzIC8gMiA/IDAuNSAqIElvKDIgKiBpLCAwLCBlLCBzKSArIHQgOiAwLjUgKiBsbigyICogaSAtIHMsIDAsIGUsIHMpICsgMC41ICogZSArIHQsIGVhc2VJbk91dENpcmM6IChpLCB0LCBlLCBzKSA9PiAoaSAvPSBzIC8gMikgPCAxID8gLWUgLyAyICogKE1hdGguc3FydCgxIC0gaSAqKiAyKSAtIDEpICsgdCA6IGUgLyAyICogKE1hdGguc3FydCgxIC0gKGkgLT0gMikgKiBpKSArIDEpICsgdCwgZWFzZUluT3V0Q3ViaWM6IChpLCB0LCBlLCBzKSA9PiAoaSAvPSBzIC8gMikgPCAxID8gZSAvIDIgKiBpICoqIDMgKyB0IDogZSAvIDIgKiAoKGkgLSAyKSAqKiAzICsgMikgKyB0LCBlYXNlSW5PdXRFbGFzdGljOiAoaSwgdCwgZSwgcykgPT4ge1xuICBjb25zdCByID0gZTtcbiAgbGV0IG4gPSAwO1xuICBpZiAoaSA9PT0gMCkgcmV0dXJuIHQ7XG4gIGlmICgoaSAvPSBzIC8gMikgPT09IDIpIHJldHVybiB0ICsgZTtcbiAgbiB8fCAobiA9IHMgKiAoMC4zICogMS41KSk7XG4gIGNvbnN0IHsgYTogbywgczogYSwgcDogYywgYzogbCB9ID0gWGkociwgZSwgbiwgMS43MDE1OCk7XG4gIHJldHVybiBpIDwgMSA/IC0wLjUgKiBNbyhvLCBhLCBjLCBpLCBzKSArIHQgOiBvICogTWF0aC5wb3coMiwgLTEwICogKGkgLT0gMSkpICogTWF0aC5zaW4oKGkgKiBzIC0gYSkgKiBoZSAvIGMpICogMC41ICsgbCArIHQ7XG59LCBlYXNlSW5PdXRFeHBvOiAoaSwgdCwgZSwgcykgPT4gaSA9PT0gMCA/IHQgOiBpID09PSBzID8gdCArIGUgOiAoaSAvPSBzIC8gMikgPCAxID8gZSAvIDIgKiAyICoqICgxMCAqIChpIC0gMSkpICsgdCA6IGUgLyAyICogLSgyICoqICgtMTAgKiAtLWkpICsgMikgKyB0LCBlYXNlSW5PdXRRdWFkOiAoaSwgdCwgZSwgcykgPT4gKGkgLz0gcyAvIDIpIDwgMSA/IGUgLyAyICogaSAqKiAyICsgdCA6IC1lIC8gMiAqICgtLWkgKiAoaSAtIDIpIC0gMSkgKyB0LCBlYXNlSW5PdXRRdWFydDogKGksIHQsIGUsIHMpID0+IChpIC89IHMgLyAyKSA8IDEgPyBlIC8gMiAqIGkgKiogNCArIHQgOiAtZSAvIDIgKiAoKGkgLT0gMikgKiBpICoqIDMgLSAyKSArIHQsIGVhc2VJbk91dFF1aW50OiAoaSwgdCwgZSwgcykgPT4gKGkgLz0gcyAvIDIpIDwgMSA/IGUgLyAyICogaSAqKiA1ICsgdCA6IGUgLyAyICogKChpIC0gMikgKiogNSArIDIpICsgdCwgZWFzZUluT3V0U2luZTogKGksIHQsIGUsIHMpID0+IC1lIC8gMiAqIChNYXRoLmNvcyhNYXRoLlBJICogaSAvIHMpIC0gMSkgKyB0LCBlYXNlSW5RdWFkOiAoaSwgdCwgZSwgcykgPT4gZSAqIChpIC89IHMpICogaSArIHQsIGVhc2VJblF1YXJ0OiAoaSwgdCwgZSwgcykgPT4gZSAqIChpIC89IHMpICogaSAqKiAzICsgdCwgZWFzZUluUXVpbnQ6IChpLCB0LCBlLCBzKSA9PiBlICogKGkgLyBzKSAqKiA1ICsgdCwgZWFzZUluU2luZTogKGksIHQsIGUsIHMpID0+IC1lICogTWF0aC5jb3MoaSAvIHMgKiB4ZSkgKyBlICsgdCwgZWFzZU91dEJhY2s6IGZ1bmN0aW9uKGksIHQsIGUsIHMpIHtcbiAgbGV0IHIgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1s0XSA6IDEuNzAxNTg7XG4gIHJldHVybiBlICogKChpID0gaSAvIHMgLSAxKSAqIGkgKiAoKHIgKyAxKSAqIGkgKyByKSArIDEpICsgdDtcbn0sIGVhc2VPdXRCb3VuY2U6IGxuLCBlYXNlT3V0Q2lyYzogKGksIHQsIGUsIHMpID0+IGUgKiBNYXRoLnNxcnQoMSAtIChpID0gaSAvIHMgLSAxKSAqIGkpICsgdCwgZWFzZU91dEN1YmljOiAoaSwgdCwgZSwgcykgPT4gZSAqICgoaSAvIHMgLSAxKSAqKiAzICsgMSkgKyB0LCBlYXNlT3V0RWxhc3RpYzogKGksIHQsIGUsIHMpID0+IHtcbiAgY29uc3QgciA9IGU7XG4gIGxldCBuID0gMDtcbiAgaWYgKGkgPT09IDApIHJldHVybiB0O1xuICBpZiAoKGkgLz0gcykgPT09IDEpIHJldHVybiB0ICsgZTtcbiAgbiB8fCAobiA9IDAuMyAqIHMpO1xuICBjb25zdCB7IGE6IG8sIHM6IGEsIHA6IGMsIGM6IGwgfSA9IFhpKHIsIGUsIG4sIDEuNzAxNTgpO1xuICByZXR1cm4gbyAqIDIgKiogKC0xMCAqIGkpICogTWF0aC5zaW4oKGkgKiBzIC0gYSkgKiBoZSAvIGMpICsgbCArIHQ7XG59LCBlYXNlT3V0RXhwbzogKGksIHQsIGUsIHMpID0+IGkgPT09IHMgPyB0ICsgZSA6IGUgKiAtKDIgKiogKC0xMCAqIGkgLyBzKSArIDEpICsgdCwgZWFzZU91dFF1YWQ6IChpLCB0LCBlLCBzKSA9PiAtZSAqIChpIC89IHMpICogKGkgLSAyKSArIHQsIGVhc2VPdXRRdWFydDogKGksIHQsIGUsIHMpID0+IC1lICogKChpID0gaSAvIHMgLSAxKSAqIGkgKiogMyAtIDEpICsgdCwgZWFzZU91dFF1aW50OiAoaSwgdCwgZSwgcykgPT4gZSAqICgoaSAvIHMgLSAxKSAqKiA1ICsgMSkgKyB0LCBlYXNlT3V0U2luZTogKGksIHQsIGUsIHMpID0+IGUgKiBNYXRoLnNpbihpIC8gcyAqIHhlKSArIHQgfSk7XG5jb25zdCBRaCA9ICgpID0+ICExO1xuY2xhc3MgTm4ge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgbGV0IHsgc3RhcnRWYWx1ZTogZSwgYnlWYWx1ZTogcywgZHVyYXRpb246IHIgPSA1MDAsIGRlbGF5OiBuID0gMCwgZWFzaW5nOiBvID0gdWMsIG9uU3RhcnQ6IGEgPSBCZSwgb25DaGFuZ2U6IGMgPSBCZSwgb25Db21wbGV0ZTogbCA9IEJlLCBhYm9ydDogaCA9IFFoLCB0YXJnZXQ6IHUgfSA9IHQ7XG4gICAgeSh0aGlzLCBcIl9zdGF0ZVwiLCBcInBlbmRpbmdcIiksIHkodGhpcywgXCJkdXJhdGlvblByb2dyZXNzXCIsIDApLCB5KHRoaXMsIFwidmFsdWVQcm9ncmVzc1wiLCAwKSwgdGhpcy50aWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyksIHRoaXMuZHVyYXRpb24gPSByLCB0aGlzLmRlbGF5ID0gbiwgdGhpcy5lYXNpbmcgPSBvLCB0aGlzLl9vblN0YXJ0ID0gYSwgdGhpcy5fb25DaGFuZ2UgPSBjLCB0aGlzLl9vbkNvbXBsZXRlID0gbCwgdGhpcy5fYWJvcnQgPSBoLCB0aGlzLnRhcmdldCA9IHUsIHRoaXMuc3RhcnRWYWx1ZSA9IGUsIHRoaXMuYnlWYWx1ZSA9IHMsIHRoaXMudmFsdWUgPSB0aGlzLnN0YXJ0VmFsdWUsIHRoaXMuZW5kVmFsdWUgPSBPYmplY3QuZnJlZXplKHRoaXMuY2FsY3VsYXRlKHRoaXMuZHVyYXRpb24pLnZhbHVlKTtcbiAgfVxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG4gIGlzRG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUgPT09IFwiYWJvcnRlZFwiIHx8IHRoaXMuX3N0YXRlID09PSBcImNvbXBsZXRlZFwiO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIGNvbnN0IHQgPSAoZSkgPT4ge1xuICAgICAgdGhpcy5fc3RhdGUgPT09IFwicGVuZGluZ1wiICYmICh0aGlzLnN0YXJ0VGltZSA9IGUgfHwgKy8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCB0aGlzLl9zdGF0ZSA9IFwicnVubmluZ1wiLCB0aGlzLl9vblN0YXJ0KCksIHRoaXMudGljayh0aGlzLnN0YXJ0VGltZSkpO1xuICAgIH07XG4gICAgdGhpcy5yZWdpc3RlcigpLCB0aGlzLmRlbGF5ID4gMCA/IHNldFRpbWVvdXQoKCkgPT4gSHModCksIHRoaXMuZGVsYXkpIDogSHModCk7XG4gIH1cbiAgdGljayh0KSB7XG4gICAgY29uc3QgZSA9ICh0IHx8ICsvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkgLSB0aGlzLnN0YXJ0VGltZSwgcyA9IE1hdGgubWluKGUsIHRoaXMuZHVyYXRpb24pO1xuICAgIHRoaXMuZHVyYXRpb25Qcm9ncmVzcyA9IHMgLyB0aGlzLmR1cmF0aW9uO1xuICAgIGNvbnN0IHsgdmFsdWU6IHIsIHZhbHVlUHJvZ3Jlc3M6IG4gfSA9IHRoaXMuY2FsY3VsYXRlKHMpO1xuICAgIHRoaXMudmFsdWUgPSBPYmplY3QuZnJlZXplKHIpLCB0aGlzLnZhbHVlUHJvZ3Jlc3MgPSBuLCB0aGlzLl9zdGF0ZSAhPT0gXCJhYm9ydGVkXCIgJiYgKHRoaXMuX2Fib3J0KHRoaXMudmFsdWUsIHRoaXMudmFsdWVQcm9ncmVzcywgdGhpcy5kdXJhdGlvblByb2dyZXNzKSA/ICh0aGlzLl9zdGF0ZSA9IFwiYWJvcnRlZFwiLCB0aGlzLnVucmVnaXN0ZXIoKSkgOiBlID49IHRoaXMuZHVyYXRpb24gPyAodGhpcy5kdXJhdGlvblByb2dyZXNzID0gdGhpcy52YWx1ZVByb2dyZXNzID0gMSwgdGhpcy5fb25DaGFuZ2UodGhpcy5lbmRWYWx1ZSwgdGhpcy52YWx1ZVByb2dyZXNzLCB0aGlzLmR1cmF0aW9uUHJvZ3Jlc3MpLCB0aGlzLl9zdGF0ZSA9IFwiY29tcGxldGVkXCIsIHRoaXMuX29uQ29tcGxldGUodGhpcy5lbmRWYWx1ZSwgdGhpcy52YWx1ZVByb2dyZXNzLCB0aGlzLmR1cmF0aW9uUHJvZ3Jlc3MpLCB0aGlzLnVucmVnaXN0ZXIoKSkgOiAodGhpcy5fb25DaGFuZ2UodGhpcy52YWx1ZSwgdGhpcy52YWx1ZVByb2dyZXNzLCB0aGlzLmR1cmF0aW9uUHJvZ3Jlc3MpLCBIcyh0aGlzLnRpY2spKSk7XG4gIH1cbiAgcmVnaXN0ZXIoKSB7XG4gICAgcXIucHVzaCh0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyKCkge1xuICAgIHFyLnJlbW92ZSh0aGlzKTtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICB0aGlzLl9zdGF0ZSA9IFwiYWJvcnRlZFwiLCB0aGlzLnVucmVnaXN0ZXIoKTtcbiAgfVxufVxuY29uc3QgdHUgPSBbXCJzdGFydFZhbHVlXCIsIFwiZW5kVmFsdWVcIl07XG5jbGFzcyBldSBleHRlbmRzIE5uIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIGxldCB7IHN0YXJ0VmFsdWU6IGUgPSAwLCBlbmRWYWx1ZTogcyA9IDEwMCB9ID0gdDtcbiAgICBzdXBlcih2KHYoe30sIEcodCwgdHUpKSwge30sIHsgc3RhcnRWYWx1ZTogZSwgYnlWYWx1ZTogcyAtIGUgfSkpO1xuICB9XG4gIGNhbGN1bGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZWFzaW5nKHQsIHRoaXMuc3RhcnRWYWx1ZSwgdGhpcy5ieVZhbHVlLCB0aGlzLmR1cmF0aW9uKTtcbiAgICByZXR1cm4geyB2YWx1ZTogZSwgdmFsdWVQcm9ncmVzczogTWF0aC5hYnMoKGUgLSB0aGlzLnN0YXJ0VmFsdWUpIC8gdGhpcy5ieVZhbHVlKSB9O1xuICB9XG59XG5jb25zdCBzdSA9IFtcInN0YXJ0VmFsdWVcIiwgXCJlbmRWYWx1ZVwiXTtcbmNsYXNzIHJ1IGV4dGVuZHMgTm4ge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgbGV0IHsgc3RhcnRWYWx1ZTogZSA9IFswXSwgZW5kVmFsdWU6IHMgPSBbMTAwXSB9ID0gdDtcbiAgICBzdXBlcih2KHYoe30sIEcodCwgc3UpKSwge30sIHsgc3RhcnRWYWx1ZTogZSwgYnlWYWx1ZTogcy5tYXAoKHIsIG4pID0+IHIgLSBlW25dKSB9KSk7XG4gIH1cbiAgY2FsY3VsYXRlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5zdGFydFZhbHVlLm1hcCgocywgcikgPT4gdGhpcy5lYXNpbmcodCwgcywgdGhpcy5ieVZhbHVlW3JdLCB0aGlzLmR1cmF0aW9uLCByKSk7XG4gICAgcmV0dXJuIHsgdmFsdWU6IGUsIHZhbHVlUHJvZ3Jlc3M6IE1hdGguYWJzKChlWzBdIC0gdGhpcy5zdGFydFZhbHVlWzBdKSAvIHRoaXMuYnlWYWx1ZVswXSkgfTtcbiAgfVxufVxuY29uc3QgaXUgPSBbXCJzdGFydFZhbHVlXCIsIFwiZW5kVmFsdWVcIiwgXCJlYXNpbmdcIiwgXCJvbkNoYW5nZVwiLCBcIm9uQ29tcGxldGVcIiwgXCJhYm9ydFwiXSwgbnUgPSAoaSwgdCwgZSwgcykgPT4gdCArIGUgKiAoMSAtIE1hdGguY29zKGkgLyBzICogeGUpKSwgemkgPSAoaSkgPT4gaSAmJiAoKHQsIGUsIHMpID0+IGkobmV3IFcodCkudG9SZ2JhKCksIGUsIHMpKTtcbmNsYXNzIG91IGV4dGVuZHMgTm4ge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgbGV0IHsgc3RhcnRWYWx1ZTogZSwgZW5kVmFsdWU6IHMsIGVhc2luZzogciA9IG51LCBvbkNoYW5nZTogbiwgb25Db21wbGV0ZTogbywgYWJvcnQ6IGEgfSA9IHQsIGMgPSBHKHQsIGl1KTtcbiAgICBjb25zdCBsID0gbmV3IFcoZSkuZ2V0U291cmNlKCksIGggPSBuZXcgVyhzKS5nZXRTb3VyY2UoKTtcbiAgICBzdXBlcih2KHYoe30sIGMpLCB7fSwgeyBzdGFydFZhbHVlOiBsLCBieVZhbHVlOiBoLm1hcCgodSwgZCkgPT4gdSAtIGxbZF0pLCBlYXNpbmc6IHIsIG9uQ2hhbmdlOiB6aShuKSwgb25Db21wbGV0ZTogemkobyksIGFib3J0OiB6aShhKSB9KSk7XG4gIH1cbiAgY2FsY3VsYXRlKHQpIHtcbiAgICBjb25zdCBbZSwgcywgciwgbl0gPSB0aGlzLnN0YXJ0VmFsdWUubWFwKChhLCBjKSA9PiB0aGlzLmVhc2luZyh0LCBhLCB0aGlzLmJ5VmFsdWVbY10sIHRoaXMuZHVyYXRpb24sIGMpKSwgbyA9IFsuLi5bZSwgcywgcl0ubWFwKE1hdGgucm91bmQpLCB6ZSgwLCBuLCAxKV07XG4gICAgcmV0dXJuIHsgdmFsdWU6IG8sIHZhbHVlUHJvZ3Jlc3M6IG8ubWFwKChhLCBjKSA9PiB0aGlzLmJ5VmFsdWVbY10gIT09IDAgPyBNYXRoLmFicygoYSAtIHRoaXMuc3RhcnRWYWx1ZVtjXSkgLyB0aGlzLmJ5VmFsdWVbY10pIDogMCkuZmluZCgoYSkgPT4gYSAhPT0gMCkgfHwgMCB9O1xuICB9XG59XG5mdW5jdGlvbiBVbihpKSB7XG4gIGNvbnN0IHQgPSAoKGUpID0+IEFycmF5LmlzQXJyYXkoZS5zdGFydFZhbHVlKSB8fCBBcnJheS5pc0FycmF5KGUuZW5kVmFsdWUpKShpKSA/IG5ldyBydShpKSA6IG5ldyBldShpKTtcbiAgcmV0dXJuIHQuc3RhcnQoKSwgdDtcbn1cbmZ1bmN0aW9uIGRjKGkpIHtcbiAgY29uc3QgdCA9IG5ldyBvdShpKTtcbiAgcmV0dXJuIHQuc3RhcnQoKSwgdDtcbn1cbmNsYXNzIE4ge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5zdGF0dXMgPSB0LCB0aGlzLnBvaW50cyA9IFtdO1xuICB9XG4gIGluY2x1ZGVzKHQpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHMuc29tZSgoZSkgPT4gZS5lcSh0KSk7XG4gIH1cbiAgYXBwZW5kKCkge1xuICAgIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBlID0gbmV3IEFycmF5KHQpLCBzID0gMDsgcyA8IHQ7IHMrKykgZVtzXSA9IGFyZ3VtZW50c1tzXTtcbiAgICByZXR1cm4gdGhpcy5wb2ludHMgPSB0aGlzLnBvaW50cy5jb25jYXQoZS5maWx0ZXIoKHIpID0+ICF0aGlzLmluY2x1ZGVzKHIpKSksIHRoaXM7XG4gIH1cbiAgc3RhdGljIGlzUG9pbnRDb250YWluZWQodCwgZSwgcykge1xuICAgIGxldCByID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB2b2lkIDAgJiYgYXJndW1lbnRzWzNdO1xuICAgIGlmIChlLmVxKHMpKSByZXR1cm4gdC5lcShlKTtcbiAgICBpZiAoZS54ID09PSBzLngpIHJldHVybiB0LnggPT09IGUueCAmJiAociB8fCB0LnkgPj0gTWF0aC5taW4oZS55LCBzLnkpICYmIHQueSA8PSBNYXRoLm1heChlLnksIHMueSkpO1xuICAgIGlmIChlLnkgPT09IHMueSkgcmV0dXJuIHQueSA9PT0gZS55ICYmIChyIHx8IHQueCA+PSBNYXRoLm1pbihlLngsIHMueCkgJiYgdC54IDw9IE1hdGgubWF4KGUueCwgcy54KSk7XG4gICAge1xuICAgICAgY29uc3QgbiA9IFpyKGUsIHMpLCBvID0gWnIoZSwgdCkuZGl2aWRlKG4pO1xuICAgICAgcmV0dXJuIHIgPyBNYXRoLmFicyhvLngpID09PSBNYXRoLmFicyhvLnkpIDogby54ID09PSBvLnkgJiYgby54ID49IDAgJiYgby54IDw9IDE7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBpc1BvaW50SW5Qb2x5Z29uKHQsIGUpIHtcbiAgICBjb25zdCBzID0gbmV3IF8odCkuc2V0WChNYXRoLm1pbih0LnggLSAxLCAuLi5lLm1hcCgobikgPT4gbi54KSkpO1xuICAgIGxldCByID0gMDtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLmludGVyc2VjdFNlZ21lbnRTZWdtZW50KGVbbl0sIGVbKG4gKyAxKSAlIGUubGVuZ3RoXSwgdCwgcyk7XG4gICAgICBpZiAoby5pbmNsdWRlcyh0KSkgcmV0dXJuICEwO1xuICAgICAgciArPSArKG8uc3RhdHVzID09PSBcIkludGVyc2VjdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHIgJSAyID09IDE7XG4gIH1cbiAgc3RhdGljIGludGVyc2VjdExpbmVMaW5lKHQsIGUsIHMsIHIpIHtcbiAgICBsZXQgbiA9ICEoYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB2b2lkIDApIHx8IGFyZ3VtZW50c1s0XSwgbyA9ICEoYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB2b2lkIDApIHx8IGFyZ3VtZW50c1s1XTtcbiAgICBjb25zdCBhID0gZS54IC0gdC54LCBjID0gZS55IC0gdC55LCBsID0gci54IC0gcy54LCBoID0gci55IC0gcy55LCB1ID0gdC54IC0gcy54LCBkID0gdC55IC0gcy55LCBmID0gbCAqIGQgLSBoICogdSwgZyA9IGEgKiBkIC0gYyAqIHUsIHAgPSBoICogYSAtIGwgKiBjO1xuICAgIGlmIChwICE9PSAwKSB7XG4gICAgICBjb25zdCBtID0gZiAvIHAsIGIgPSBnIC8gcDtcbiAgICAgIHJldHVybiAobiB8fCAwIDw9IG0gJiYgbSA8PSAxKSAmJiAobyB8fCAwIDw9IGIgJiYgYiA8PSAxKSA/IG5ldyBOKFwiSW50ZXJzZWN0aW9uXCIpLmFwcGVuZChuZXcgXyh0LnggKyBtICogYSwgdC55ICsgbSAqIGMpKSA6IG5ldyBOKCk7XG4gICAgfVxuICAgIGlmIChmID09PSAwIHx8IGcgPT09IDApIHtcbiAgICAgIGNvbnN0IG0gPSBuIHx8IG8gfHwgTi5pc1BvaW50Q29udGFpbmVkKHQsIHMsIHIpIHx8IE4uaXNQb2ludENvbnRhaW5lZChlLCBzLCByKSB8fCBOLmlzUG9pbnRDb250YWluZWQocywgdCwgZSkgfHwgTi5pc1BvaW50Q29udGFpbmVkKHIsIHQsIGUpO1xuICAgICAgcmV0dXJuIG5ldyBOKG0gPyBcIkNvaW5jaWRlbnRcIiA6IHZvaWQgMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTihcIlBhcmFsbGVsXCIpO1xuICB9XG4gIHN0YXRpYyBpbnRlcnNlY3RTZWdtZW50TGluZSh0LCBlLCBzLCByKSB7XG4gICAgcmV0dXJuIE4uaW50ZXJzZWN0TGluZUxpbmUodCwgZSwgcywgciwgITEsICEwKTtcbiAgfVxuICBzdGF0aWMgaW50ZXJzZWN0U2VnbWVudFNlZ21lbnQodCwgZSwgcywgcikge1xuICAgIHJldHVybiBOLmludGVyc2VjdExpbmVMaW5lKHQsIGUsIHMsIHIsICExLCAhMSk7XG4gIH1cbiAgc3RhdGljIGludGVyc2VjdExpbmVQb2x5Z29uKHQsIGUsIHMpIHtcbiAgICBsZXQgciA9ICEoYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB2b2lkIDApIHx8IGFyZ3VtZW50c1szXTtcbiAgICBjb25zdCBuID0gbmV3IE4oKSwgbyA9IHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGEsIGMsIGwsIGggPSAwOyBoIDwgbzsgaCsrKSB7XG4gICAgICBpZiAoYSA9IHNbaF0sIGMgPSBzWyhoICsgMSkgJSBvXSwgbCA9IE4uaW50ZXJzZWN0TGluZUxpbmUodCwgZSwgYSwgYywgciwgITEpLCBsLnN0YXR1cyA9PT0gXCJDb2luY2lkZW50XCIpIHJldHVybiBsO1xuICAgICAgbi5hcHBlbmQoLi4ubC5wb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gbi5wb2ludHMubGVuZ3RoID4gMCAmJiAobi5zdGF0dXMgPSBcIkludGVyc2VjdGlvblwiKSwgbjtcbiAgfVxuICBzdGF0aWMgaW50ZXJzZWN0U2VnbWVudFBvbHlnb24odCwgZSwgcykge1xuICAgIHJldHVybiBOLmludGVyc2VjdExpbmVQb2x5Z29uKHQsIGUsIHMsICExKTtcbiAgfVxuICBzdGF0aWMgaW50ZXJzZWN0UG9seWdvblBvbHlnb24odCwgZSkge1xuICAgIGNvbnN0IHMgPSBuZXcgTigpLCByID0gdC5sZW5ndGgsIG4gPSBbXTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHI7IG8rKykge1xuICAgICAgY29uc3QgYSA9IHRbb10sIGMgPSB0WyhvICsgMSkgJSByXSwgbCA9IE4uaW50ZXJzZWN0U2VnbWVudFBvbHlnb24oYSwgYywgZSk7XG4gICAgICBsLnN0YXR1cyA9PT0gXCJDb2luY2lkZW50XCIgPyAobi5wdXNoKGwpLCBzLmFwcGVuZChhLCBjKSkgOiBzLmFwcGVuZCguLi5sLnBvaW50cyk7XG4gICAgfVxuICAgIHJldHVybiBuLmxlbmd0aCA+IDAgJiYgbi5sZW5ndGggPT09IHQubGVuZ3RoID8gbmV3IE4oXCJDb2luY2lkZW50XCIpIDogKHMucG9pbnRzLmxlbmd0aCA+IDAgJiYgKHMuc3RhdHVzID0gXCJJbnRlcnNlY3Rpb25cIiksIHMpO1xuICB9XG4gIHN0YXRpYyBpbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlKHQsIGUsIHMpIHtcbiAgICBjb25zdCByID0gZS5taW4ocyksIG4gPSBlLm1heChzKSwgbyA9IG5ldyBfKG4ueCwgci55KSwgYSA9IG5ldyBfKHIueCwgbi55KTtcbiAgICByZXR1cm4gTi5pbnRlcnNlY3RQb2x5Z29uUG9seWdvbih0LCBbciwgbywgbiwgYV0pO1xuICB9XG59XG5jbGFzcyBhdSBleHRlbmRzIEhhIHtcbiAgZ2V0WCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRYWSgpLng7XG4gIH1cbiAgc2V0WCh0KSB7XG4gICAgdGhpcy5zZXRYWSh0aGlzLmdldFhZKCkuc2V0WCh0KSk7XG4gIH1cbiAgZ2V0WSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRYWSgpLnk7XG4gIH1cbiAgc2V0WSh0KSB7XG4gICAgdGhpcy5zZXRYWSh0aGlzLmdldFhZKCkuc2V0WSh0KSk7XG4gIH1cbiAgZ2V0UmVsYXRpdmVYKCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQ7XG4gIH1cbiAgc2V0UmVsYXRpdmVYKHQpIHtcbiAgICB0aGlzLmxlZnQgPSB0O1xuICB9XG4gIGdldFJlbGF0aXZlWSgpIHtcbiAgICByZXR1cm4gdGhpcy50b3A7XG4gIH1cbiAgc2V0UmVsYXRpdmVZKHQpIHtcbiAgICB0aGlzLnRvcCA9IHQ7XG4gIH1cbiAgZ2V0WFkoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0UmVsYXRpdmVYWSgpO1xuICAgIHJldHVybiB0aGlzLmdyb3VwID8gb3QodCwgdGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KCkpIDogdDtcbiAgfVxuICBzZXRYWSh0LCBlLCBzKSB7XG4gICAgdGhpcy5ncm91cCAmJiAodCA9IG90KHQsIFN0KHRoaXMuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKSkpLCB0aGlzLnNldFJlbGF0aXZlWFkodCwgZSwgcyk7XG4gIH1cbiAgZ2V0UmVsYXRpdmVYWSgpIHtcbiAgICByZXR1cm4gbmV3IF8odGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG4gIH1cbiAgc2V0UmVsYXRpdmVYWSh0KSB7XG4gICAgbGV0IGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMub3JpZ2luWCwgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogdGhpcy5vcmlnaW5ZO1xuICAgIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbih0LCBlLCBzKTtcbiAgfVxuICBpc1N0cm9rZUFjY291bnRlZEZvckluRGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZ2V0Q29vcmRzKCkge1xuICAgIGNvbnN0IHsgdGw6IHQsIHRyOiBlLCBicjogcywgYmw6IHIgfSA9IHRoaXMuYUNvb3JkcyB8fCAodGhpcy5hQ29vcmRzID0gdGhpcy5jYWxjQUNvb3JkcygpKSwgbiA9IFt0LCBlLCBzLCByXTtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgY29uc3QgbyA9IHRoaXMuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgcmV0dXJuIG4ubWFwKChhKSA9PiBvdChhLCBvKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGludGVyc2VjdHNXaXRoUmVjdCh0LCBlKSB7XG4gICAgcmV0dXJuIE4uaW50ZXJzZWN0UG9seWdvblJlY3RhbmdsZSh0aGlzLmdldENvb3JkcygpLCB0LCBlKS5zdGF0dXMgPT09IFwiSW50ZXJzZWN0aW9uXCI7XG4gIH1cbiAgaW50ZXJzZWN0c1dpdGhPYmplY3QodCkge1xuICAgIGNvbnN0IGUgPSBOLmludGVyc2VjdFBvbHlnb25Qb2x5Z29uKHRoaXMuZ2V0Q29vcmRzKCksIHQuZ2V0Q29vcmRzKCkpO1xuICAgIHJldHVybiBlLnN0YXR1cyA9PT0gXCJJbnRlcnNlY3Rpb25cIiB8fCBlLnN0YXR1cyA9PT0gXCJDb2luY2lkZW50XCIgfHwgdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzKSB8fCB0aGlzLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHQpO1xuICB9XG4gIGlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb29yZHMoKS5ldmVyeSgoZSkgPT4gdC5jb250YWluc1BvaW50KGUpKTtcbiAgfVxuICBpc0NvbnRhaW5lZFdpdGhpblJlY3QodCwgZSkge1xuICAgIGNvbnN0IHsgbGVmdDogcywgdG9wOiByLCB3aWR0aDogbiwgaGVpZ2h0OiBvIH0gPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHJldHVybiBzID49IHQueCAmJiBzICsgbiA8PSBlLnggJiYgciA+PSB0LnkgJiYgciArIG8gPD0gZS55O1xuICB9XG4gIGlzT3ZlcmxhcHBpbmcodCkge1xuICAgIHJldHVybiB0aGlzLmludGVyc2VjdHNXaXRoT2JqZWN0KHQpIHx8IHRoaXMuaXNDb250YWluZWRXaXRoaW5PYmplY3QodCkgfHwgdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzKTtcbiAgfVxuICBjb250YWluc1BvaW50KHQpIHtcbiAgICByZXR1cm4gTi5pc1BvaW50SW5Qb2x5Z29uKHQsIHRoaXMuZ2V0Q29vcmRzKCkpO1xuICB9XG4gIGlzT25TY3JlZW4oKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcykgcmV0dXJuICExO1xuICAgIGNvbnN0IHsgdGw6IHQsIGJyOiBlIH0gPSB0aGlzLmNhbnZhcy52cHRDb29yZHM7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRDb29yZHMoKS5zb21lKChzKSA9PiBzLnggPD0gZS54ICYmIHMueCA+PSB0LnggJiYgcy55IDw9IGUueSAmJiBzLnkgPj0gdC55KSB8fCAhIXRoaXMuaW50ZXJzZWN0c1dpdGhSZWN0KHQsIGUpIHx8IHRoaXMuY29udGFpbnNQb2ludCh0Lm1pZFBvaW50RnJvbShlKSk7XG4gIH1cbiAgaXNQYXJ0aWFsbHlPblNjcmVlbigpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzKSByZXR1cm4gITE7XG4gICAgY29uc3QgeyB0bDogdCwgYnI6IGUgfSA9IHRoaXMuY2FudmFzLnZwdENvb3JkcztcbiAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzV2l0aFJlY3QodCwgZSkgPyAhMCA6IHRoaXMuZ2V0Q29vcmRzKCkuZXZlcnkoKHMpID0+IChzLnggPj0gZS54IHx8IHMueCA8PSB0LngpICYmIChzLnkgPj0gZS55IHx8IHMueSA8PSB0LnkpKSAmJiB0aGlzLmNvbnRhaW5zUG9pbnQodC5taWRQb2ludEZyb20oZSkpO1xuICB9XG4gIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICByZXR1cm4gR3QodGhpcy5nZXRDb29yZHMoKSk7XG4gIH1cbiAgZ2V0U2NhbGVkV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLng7XG4gIH1cbiAgZ2V0U2NhbGVkSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS55O1xuICB9XG4gIHNjYWxlKHQpIHtcbiAgICB0aGlzLl9zZXQodXQsIHQpLCB0aGlzLl9zZXQoVHQsIHQpLCB0aGlzLnNldENvb3JkcygpO1xuICB9XG4gIHNjYWxlVG9XaWR0aCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyB0aGlzLmdldFNjYWxlZFdpZHRoKCk7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUodCAvIHRoaXMud2lkdGggLyBlKTtcbiAgfVxuICBzY2FsZVRvSGVpZ2h0KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyB0aGlzLmdldFNjYWxlZEhlaWdodCgpO1xuICAgIHJldHVybiB0aGlzLnNjYWxlKHQgLyB0aGlzLmhlaWdodCAvIGUpO1xuICB9XG4gIGdldENhbnZhc1JldGluYVNjYWxpbmcoKSB7XG4gICAgdmFyIHQ7XG4gICAgcmV0dXJuICgodCA9IHRoaXMuY2FudmFzKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0LmdldFJldGluYVNjYWxpbmcoKSkgfHwgMTtcbiAgfVxuICBnZXRUb3RhbEFuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLmdyb3VwID8gQ2UoTmEodGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkpKSA6IHRoaXMuYW5nbGU7XG4gIH1cbiAgZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSB7XG4gICAgdmFyIHQ7XG4gICAgcmV0dXJuICgodCA9IHRoaXMuY2FudmFzKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0LnZpZXdwb3J0VHJhbnNmb3JtKSB8fCBodC5jb25jYXQoKTtcbiAgfVxuICBjYWxjQUNvb3JkcygpIHtcbiAgICBjb25zdCB0ID0gSXMoeyBhbmdsZTogdGhpcy5hbmdsZSB9KSwgeyB4OiBlLCB5OiBzIH0gPSB0aGlzLmdldFJlbGF0aXZlQ2VudGVyUG9pbnQoKSwgciA9IE1zKGUsIHMpLCBuID0gSihyLCB0KSwgbyA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLCBhID0gby54IC8gMiwgYyA9IG8ueSAvIDI7XG4gICAgcmV0dXJuIHsgdGw6IG90KHsgeDogLWEsIHk6IC1jIH0sIG4pLCB0cjogb3QoeyB4OiBhLCB5OiAtYyB9LCBuKSwgYmw6IG90KHsgeDogLWEsIHk6IGMgfSwgbiksIGJyOiBvdCh7IHg6IGEsIHk6IGMgfSwgbikgfTtcbiAgfVxuICBzZXRDb29yZHMoKSB7XG4gICAgdGhpcy5hQ29vcmRzID0gdGhpcy5jYWxjQUNvb3JkcygpO1xuICB9XG4gIHRyYW5zZm9ybU1hdHJpeEtleSgpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwICYmIGFyZ3VtZW50c1swXSwgZSA9IFtdO1xuICAgIHJldHVybiAhdCAmJiB0aGlzLmdyb3VwICYmIChlID0gdGhpcy5ncm91cC50cmFuc2Zvcm1NYXRyaXhLZXkodCkpLCBlLnB1c2godGhpcy50b3AsIHRoaXMubGVmdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuc2NhbGVYLCB0aGlzLnNjYWxlWSwgdGhpcy5hbmdsZSwgdGhpcy5zdHJva2VXaWR0aCwgdGhpcy5za2V3WCwgdGhpcy5za2V3WSwgK3RoaXMuZmxpcFgsICt0aGlzLmZsaXBZLCBzdCh0aGlzLm9yaWdpblgpLCBzdCh0aGlzLm9yaWdpblkpKSwgZTtcbiAgfVxuICBjYWxjVHJhbnNmb3JtTWF0cml4KCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgJiYgYXJndW1lbnRzWzBdLCBlID0gdGhpcy5jYWxjT3duTWF0cml4KCk7XG4gICAgaWYgKHQgfHwgIXRoaXMuZ3JvdXApIHJldHVybiBlO1xuICAgIGNvbnN0IHMgPSB0aGlzLnRyYW5zZm9ybU1hdHJpeEtleSh0KSwgciA9IHRoaXMubWF0cml4Q2FjaGU7XG4gICAgcmV0dXJuIHIgJiYgci5rZXkuZXZlcnkoKG4sIG8pID0+IG4gPT09IHNbb10pID8gci52YWx1ZSA6ICh0aGlzLmdyb3VwICYmIChlID0gSih0aGlzLmdyb3VwLmNhbGNUcmFuc2Zvcm1NYXRyaXgoITEpLCBlKSksIHRoaXMubWF0cml4Q2FjaGUgPSB7IGtleTogcywgdmFsdWU6IGUgfSwgZSk7XG4gIH1cbiAgY2FsY093bk1hdHJpeCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXhLZXkoITApLCBlID0gdGhpcy5vd25NYXRyaXhDYWNoZTtcbiAgICBpZiAoZSAmJiBlLmtleSA9PT0gdCkgcmV0dXJuIGUudmFsdWU7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0UmVsYXRpdmVDZW50ZXJQb2ludCgpLCByID0geyBhbmdsZTogdGhpcy5hbmdsZSwgdHJhbnNsYXRlWDogcy54LCB0cmFuc2xhdGVZOiBzLnksIHNjYWxlWDogdGhpcy5zY2FsZVgsIHNjYWxlWTogdGhpcy5zY2FsZVksIHNrZXdYOiB0aGlzLnNrZXdYLCBza2V3WTogdGhpcy5za2V3WSwgZmxpcFg6IHRoaXMuZmxpcFgsIGZsaXBZOiB0aGlzLmZsaXBZIH0sIG4gPSAkYShyKTtcbiAgICByZXR1cm4gdGhpcy5vd25NYXRyaXhDYWNoZSA9IHsga2V5OiB0LCB2YWx1ZTogbiB9LCBuO1xuICB9XG4gIF9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIG5ldyBfKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KS5zY2FsYXJBZGQodGhpcy5zdHJva2VXaWR0aCk7XG4gIH1cbiAgX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKHQpLnRyYW5zZm9ybSh0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksICEwKS5zY2FsYXJBZGQoMiAqIHRoaXMucGFkZGluZyk7XG4gIH1cbiAgX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3QgZSA9IHYoeyBzY2FsZVg6IHRoaXMuc2NhbGVYLCBzY2FsZVk6IHRoaXMuc2NhbGVZLCBza2V3WDogdGhpcy5za2V3WCwgc2tld1k6IHRoaXMuc2tld1ksIHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0LCBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCB9LCB0KSwgcyA9IGUuc3Ryb2tlV2lkdGg7XG4gICAgbGV0IHIgPSBzLCBuID0gMDtcbiAgICB0aGlzLnN0cm9rZVVuaWZvcm0gJiYgKHIgPSAwLCBuID0gcyk7XG4gICAgY29uc3QgbyA9IGUud2lkdGggKyByLCBhID0gZS5oZWlnaHQgKyByO1xuICAgIGxldCBjO1xuICAgIHJldHVybiBjID0gZS5za2V3WCA9PT0gMCAmJiBlLnNrZXdZID09PSAwID8gbmV3IF8obyAqIGUuc2NhbGVYLCBhICogZS5zY2FsZVkpIDogeWkobywgYSwgYXIoZSkpLCBjLnNjYWxhckFkZChuKTtcbiAgfVxuICB0cmFuc2xhdGVUb0dpdmVuT3JpZ2luKHQsIGUsIHMsIHIsIG4pIHtcbiAgICBsZXQgbyA9IHQueCwgYSA9IHQueTtcbiAgICBjb25zdCBjID0gc3QocikgLSBzdChlKSwgbCA9IHN0KG4pIC0gc3Qocyk7XG4gICAgaWYgKGMgfHwgbCkge1xuICAgICAgY29uc3QgaCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgbyArPSBjICogaC54LCBhICs9IGwgKiBoLnk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgXyhvLCBhKTtcbiAgfVxuICB0cmFuc2xhdGVUb0NlbnRlclBvaW50KHQsIGUsIHMpIHtcbiAgICBpZiAoZSA9PT0gaiAmJiBzID09PSBqKSByZXR1cm4gdDtcbiAgICBjb25zdCByID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKHQsIGUsIHMsIGosIGopO1xuICAgIHJldHVybiB0aGlzLmFuZ2xlID8gci5yb3RhdGUoSyh0aGlzLmFuZ2xlKSwgdCkgOiByO1xuICB9XG4gIHRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodCwgZSwgcykge1xuICAgIGNvbnN0IHIgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4odCwgaiwgaiwgZSwgcyk7XG4gICAgcmV0dXJuIHRoaXMuYW5nbGUgPyByLnJvdGF0ZShLKHRoaXMuYW5nbGUpLCB0KSA6IHI7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0UmVsYXRpdmVDZW50ZXJQb2ludCgpO1xuICAgIHJldHVybiB0aGlzLmdyb3VwID8gb3QodCwgdGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KCkpIDogdDtcbiAgfVxuICBnZXRSZWxhdGl2ZUNlbnRlclBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQobmV3IF8odGhpcy5sZWZ0LCB0aGlzLnRvcCksIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgfVxuICBnZXRQb2ludEJ5T3JpZ2luKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KHRoaXMuZ2V0UmVsYXRpdmVDZW50ZXJQb2ludCgpLCB0LCBlKTtcbiAgfVxuICBzZXRQb3NpdGlvbkJ5T3JpZ2luKHQsIGUsIHMpIHtcbiAgICBjb25zdCByID0gdGhpcy50cmFuc2xhdGVUb0NlbnRlclBvaW50KHQsIGUsIHMpLCBuID0gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KHIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICB0aGlzLnNldCh7IGxlZnQ6IG4ueCwgdG9wOiBuLnkgfSk7XG4gIH1cbiAgX2dldExlZnRUb3BDb29yZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludCh0aGlzLmdldFJlbGF0aXZlQ2VudGVyUG9pbnQoKSwgTCwgZ3QpO1xuICB9XG59XG5jb25zdCBjdSA9IFtcInR5cGVcIl0sIGx1ID0gW1wiZXh0cmFQYXJhbVwiXTtcbmxldCBlZSA9IGNsYXNzIEdyIGV4dGVuZHMgYXUge1xuICBzdGF0aWMgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIEdyLm93bkRlZmF1bHRzO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XG4gICAgcmV0dXJuIHQgPT09IFwiRmFicmljT2JqZWN0XCIgPyBcIm9iamVjdFwiIDogdC50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHNldCB0eXBlKHQpIHtcbiAgICBUZShcIndhcm5cIiwgXCJTZXR0aW5nIHR5cGUgaGFzIG5vIGVmZmVjdFwiLCB0KTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKSwgeSh0aGlzLCBcIl9jYWNoZUNvbnRleHRcIiwgbnVsbCksIE9iamVjdC5hc3NpZ24odGhpcywgR3Iub3duRGVmYXVsdHMpLCB0aGlzLnNldE9wdGlvbnModCk7XG4gIH1cbiAgX2NyZWF0ZUNhY2hlQ2FudmFzKCkge1xuICAgIHRoaXMuX2NhY2hlQ2FudmFzID0ga3QoKSwgdGhpcy5fY2FjaGVDb250ZXh0ID0gdGhpcy5fY2FjaGVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCB0aGlzLl91cGRhdGVDYWNoZUNhbnZhcygpLCB0aGlzLmRpcnR5ID0gITA7XG4gIH1cbiAgX2xpbWl0Q2FjaGVTaXplKHQpIHtcbiAgICBjb25zdCBlID0gdC53aWR0aCwgcyA9IHQuaGVpZ2h0LCByID0gQS5tYXhDYWNoZVNpZGVMaW1pdCwgbiA9IEEubWluQ2FjaGVTaWRlTGltaXQ7XG4gICAgaWYgKGUgPD0gciAmJiBzIDw9IHIgJiYgZSAqIHMgPD0gQS5wZXJmTGltaXRTaXplVG90YWwpIHJldHVybiBlIDwgbiAmJiAodC53aWR0aCA9IG4pLCBzIDwgbiAmJiAodC5oZWlnaHQgPSBuKSwgdDtcbiAgICBjb25zdCBvID0gZSAvIHMsIFthLCBjXSA9IHpzLmxpbWl0RGltc0J5QXJlYShvKSwgbCA9IHplKG4sIGEsIHIpLCBoID0gemUobiwgYywgcik7XG4gICAgcmV0dXJuIGUgPiBsICYmICh0Lnpvb21YIC89IGUgLyBsLCB0LndpZHRoID0gbCwgdC5jYXBwZWQgPSAhMCksIHMgPiBoICYmICh0Lnpvb21ZIC89IHMgLyBoLCB0LmhlaWdodCA9IGgsIHQuY2FwcGVkID0gITApLCB0O1xuICB9XG4gIF9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0VG90YWxPYmplY3RTY2FsaW5nKCksIGUgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoeyBza2V3WDogMCwgc2tld1k6IDAgfSksIHMgPSBlLnggKiB0LnggLyB0aGlzLnNjYWxlWCwgciA9IGUueSAqIHQueSAvIHRoaXMuc2NhbGVZO1xuICAgIHJldHVybiB7IHdpZHRoOiBNYXRoLmNlaWwocyArIDIpLCBoZWlnaHQ6IE1hdGguY2VpbChyICsgMiksIHpvb21YOiB0LngsIHpvb21ZOiB0LnksIHg6IHMsIHk6IHIgfTtcbiAgfVxuICBfdXBkYXRlQ2FjaGVDYW52YXMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NhY2hlQ2FudmFzLCBlID0gdGhpcy5fY2FjaGVDb250ZXh0LCB7IHdpZHRoOiBzLCBoZWlnaHQ6IHIsIHpvb21YOiBuLCB6b29tWTogbywgeDogYSwgeTogYyB9ID0gdGhpcy5fbGltaXRDYWNoZVNpemUodGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkpLCBsID0gcyAhPT0gdC53aWR0aCB8fCByICE9PSB0LmhlaWdodCwgaCA9IHRoaXMuem9vbVggIT09IG4gfHwgdGhpcy56b29tWSAhPT0gbztcbiAgICBpZiAoIXQgfHwgIWUpIHJldHVybiAhMTtcbiAgICBpZiAobCB8fCBoKSB7XG4gICAgICBzICE9PSB0LndpZHRoIHx8IHIgIT09IHQuaGVpZ2h0ID8gKHQud2lkdGggPSBzLCB0LmhlaWdodCA9IHIpIDogKGUuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApLCBlLmNsZWFyUmVjdCgwLCAwLCB0LndpZHRoLCB0LmhlaWdodCkpO1xuICAgICAgY29uc3QgdSA9IGEgLyAyLCBkID0gYyAvIDI7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVRyYW5zbGF0aW9uWCA9IE1hdGgucm91bmQodC53aWR0aCAvIDIgLSB1KSArIHUsIHRoaXMuY2FjaGVUcmFuc2xhdGlvblkgPSBNYXRoLnJvdW5kKHQuaGVpZ2h0IC8gMiAtIGQpICsgZCwgZS50cmFuc2xhdGUodGhpcy5jYWNoZVRyYW5zbGF0aW9uWCwgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSksIGUuc2NhbGUobiwgbyksIHRoaXMuem9vbVggPSBuLCB0aGlzLnpvb21ZID0gbywgITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBzZXRPcHRpb25zKCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB0aGlzLl9zZXRPcHRpb25zKHQpO1xuICB9XG4gIHRyYW5zZm9ybSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUgfHwgdGhpcy5ncm91cCAmJiB0aGlzLmNhbnZhcyAmJiB0ID09PSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBzID0gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCFlKTtcbiAgICB0LnRyYW5zZm9ybShzWzBdLCBzWzFdLCBzWzJdLCBzWzNdLCBzWzRdLCBzWzVdKTtcbiAgfVxuICBnZXRPYmplY3RTY2FsaW5nKCkge1xuICAgIGlmICghdGhpcy5ncm91cCkgcmV0dXJuIG5ldyBfKE1hdGguYWJzKHRoaXMuc2NhbGVYKSwgTWF0aC5hYnModGhpcy5zY2FsZVkpKTtcbiAgICBjb25zdCB0ID0geXModGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgIHJldHVybiBuZXcgXyhNYXRoLmFicyh0LnNjYWxlWCksIE1hdGguYWJzKHQuc2NhbGVZKSk7XG4gIH1cbiAgZ2V0VG90YWxPYmplY3RTY2FsaW5nKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmNhbnZhcy5nZXRab29tKCksIHMgPSB0aGlzLmdldENhbnZhc1JldGluYVNjYWxpbmcoKTtcbiAgICAgIHJldHVybiB0LnNjYWxhck11bHRpcGx5KGUgKiBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZ2V0T2JqZWN0T3BhY2l0eSgpIHtcbiAgICBsZXQgdCA9IHRoaXMub3BhY2l0eTtcbiAgICByZXR1cm4gdGhpcy5ncm91cCAmJiAodCAqPSB0aGlzLmdyb3VwLmdldE9iamVjdE9wYWNpdHkoKSksIHQ7XG4gIH1cbiAgX2NvbnN0cmFpblNjYWxlKHQpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModCkgPCB0aGlzLm1pblNjYWxlTGltaXQgPyB0IDwgMCA/IC10aGlzLm1pblNjYWxlTGltaXQgOiB0aGlzLm1pblNjYWxlTGltaXQgOiB0ID09PSAwID8gMWUtNCA6IHQ7XG4gIH1cbiAgX3NldCh0LCBlKSB7XG4gICAgdCAhPT0gdXQgJiYgdCAhPT0gVHQgfHwgKGUgPSB0aGlzLl9jb25zdHJhaW5TY2FsZShlKSksIHQgPT09IHV0ICYmIGUgPCAwID8gKHRoaXMuZmxpcFggPSAhdGhpcy5mbGlwWCwgZSAqPSAtMSkgOiB0ID09PSBcInNjYWxlWVwiICYmIGUgPCAwID8gKHRoaXMuZmxpcFkgPSAhdGhpcy5mbGlwWSwgZSAqPSAtMSkgOiB0ICE9PSBcInNoYWRvd1wiIHx8ICFlIHx8IGUgaW5zdGFuY2VvZiBjZSB8fCAoZSA9IG5ldyBjZShlKSk7XG4gICAgY29uc3QgcyA9IHRoaXNbdF0gIT09IGU7XG4gICAgcmV0dXJuIHRoaXNbdF0gPSBlLCBzICYmIHRoaXMuY29uc3RydWN0b3IuY2FjaGVQcm9wZXJ0aWVzLmluY2x1ZGVzKHQpICYmICh0aGlzLmRpcnR5ID0gITApLCB0aGlzLnBhcmVudCAmJiAodGhpcy5kaXJ0eSB8fCBzICYmIHRoaXMuY29uc3RydWN0b3Iuc3RhdGVQcm9wZXJ0aWVzLmluY2x1ZGVzKHQpKSAmJiB0aGlzLnBhcmVudC5fc2V0KFwiZGlydHlcIiwgITApLCB0aGlzO1xuICB9XG4gIGlzTm90VmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID09PSAwIHx8ICF0aGlzLndpZHRoICYmICF0aGlzLmhlaWdodCAmJiB0aGlzLnN0cm9rZVdpZHRoID09PSAwIHx8ICF0aGlzLnZpc2libGU7XG4gIH1cbiAgcmVuZGVyKHQpIHtcbiAgICB0aGlzLmlzTm90VmlzaWJsZSgpIHx8IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnNraXBPZmZzY3JlZW4gJiYgIXRoaXMuZ3JvdXAgJiYgIXRoaXMuaXNPblNjcmVlbigpIHx8ICh0LnNhdmUoKSwgdGhpcy5fc2V0dXBDb21wb3NpdGVPcGVyYXRpb24odCksIHRoaXMuZHJhd1NlbGVjdGlvbkJhY2tncm91bmQodCksIHRoaXMudHJhbnNmb3JtKHQpLCB0aGlzLl9zZXRPcGFjaXR5KHQpLCB0aGlzLl9zZXRTaGFkb3codCksIHRoaXMuc2hvdWxkQ2FjaGUoKSA/ICh0aGlzLnJlbmRlckNhY2hlKCksIHRoaXMuZHJhd0NhY2hlT25DYW52YXModCkpIDogKHRoaXMuX3JlbW92ZUNhY2hlQ2FudmFzKCksIHRoaXMuZHJhd09iamVjdCh0LCAhMSwge30pLCB0aGlzLmRpcnR5ID0gITEpLCB0LnJlc3RvcmUoKSk7XG4gIH1cbiAgZHJhd1NlbGVjdGlvbkJhY2tncm91bmQodCkge1xuICB9XG4gIHJlbmRlckNhY2hlKHQpIHtcbiAgICBpZiAodCA9IHQgfHwge30sIHRoaXMuX2NhY2hlQ2FudmFzICYmIHRoaXMuX2NhY2hlQ29udGV4dCB8fCB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpLCB0aGlzLmlzQ2FjaGVEaXJ0eSgpICYmIHRoaXMuX2NhY2hlQ29udGV4dCkge1xuICAgICAgY29uc3QgeyB6b29tWDogZSwgem9vbVk6IHMsIGNhY2hlVHJhbnNsYXRpb25YOiByLCBjYWNoZVRyYW5zbGF0aW9uWTogbiB9ID0gdGhpcywgeyB3aWR0aDogbywgaGVpZ2h0OiBhIH0gPSB0aGlzLl9jYWNoZUNhbnZhcztcbiAgICAgIHRoaXMuZHJhd09iamVjdCh0aGlzLl9jYWNoZUNvbnRleHQsIHQuZm9yQ2xpcHBpbmcsIHsgem9vbVg6IGUsIHpvb21ZOiBzLCBjYWNoZVRyYW5zbGF0aW9uWDogciwgY2FjaGVUcmFuc2xhdGlvblk6IG4sIHdpZHRoOiBvLCBoZWlnaHQ6IGEsIHBhcmVudENsaXBQYXRoczogW10gfSksIHRoaXMuZGlydHkgPSAhMTtcbiAgICB9XG4gIH1cbiAgX3JlbW92ZUNhY2hlQ2FudmFzKCkge1xuICAgIHRoaXMuX2NhY2hlQ2FudmFzID0gdm9pZCAwLCB0aGlzLl9jYWNoZUNvbnRleHQgPSBudWxsO1xuICB9XG4gIGhhc1N0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UgIT09IFwidHJhbnNwYXJlbnRcIiAmJiB0aGlzLnN0cm9rZVdpZHRoICE9PSAwO1xuICB9XG4gIGhhc0ZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbCAmJiB0aGlzLmZpbGwgIT09IFwidHJhbnNwYXJlbnRcIjtcbiAgfVxuICBuZWVkc0l0c093bkNhY2hlKCkge1xuICAgIHJldHVybiAhISh0aGlzLnBhaW50Rmlyc3QgPT09IG10ICYmIHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkgJiYgdGhpcy5zaGFkb3cpIHx8ICEhdGhpcy5jbGlwUGF0aDtcbiAgfVxuICBzaG91bGRDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vd25DYWNoaW5nID0gdGhpcy5vYmplY3RDYWNoaW5nICYmICghdGhpcy5wYXJlbnQgfHwgIXRoaXMucGFyZW50LmlzT25BQ2FjaGUoKSkgfHwgdGhpcy5uZWVkc0l0c093bkNhY2hlKCksIHRoaXMub3duQ2FjaGluZztcbiAgfVxuICB3aWxsRHJhd1NoYWRvdygpIHtcbiAgICByZXR1cm4gISF0aGlzLnNoYWRvdyAmJiAodGhpcy5zaGFkb3cub2Zmc2V0WCAhPT0gMCB8fCB0aGlzLnNoYWRvdy5vZmZzZXRZICE9PSAwKTtcbiAgfVxuICBkcmF3Q2xpcFBhdGhPbkNhY2hlKHQsIGUsIHMpIHtcbiAgICB0LnNhdmUoKSwgZS5pbnZlcnRlZCA/IHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1vdXRcIiA6IHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiLCB0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKSwgdC5kcmF3SW1hZ2UocywgMCwgMCksIHQucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdPYmplY3QodCwgZSwgcykge1xuICAgIGNvbnN0IHIgPSB0aGlzLmZpbGwsIG4gPSB0aGlzLnN0cm9rZTtcbiAgICBlID8gKHRoaXMuZmlsbCA9IFwiYmxhY2tcIiwgdGhpcy5zdHJva2UgPSBcIlwiLCB0aGlzLl9zZXRDbGlwcGluZ1Byb3BlcnRpZXModCkpIDogdGhpcy5fcmVuZGVyQmFja2dyb3VuZCh0KSwgdGhpcy5fcmVuZGVyKHQpLCB0aGlzLl9kcmF3Q2xpcFBhdGgodCwgdGhpcy5jbGlwUGF0aCwgcyksIHRoaXMuZmlsbCA9IHIsIHRoaXMuc3Ryb2tlID0gbjtcbiAgfVxuICBjcmVhdGVDbGlwUGF0aExheWVyKHQsIGUpIHtcbiAgICBjb25zdCBzID0gV3QoZSksIHIgPSBzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoci50cmFuc2xhdGUoZS5jYWNoZVRyYW5zbGF0aW9uWCwgZS5jYWNoZVRyYW5zbGF0aW9uWSksIHIuc2NhbGUoZS56b29tWCwgZS56b29tWSksIHQuX2NhY2hlQ2FudmFzID0gcywgZS5wYXJlbnRDbGlwUGF0aHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgbi50cmFuc2Zvcm0ocik7XG4gICAgfSksIGUucGFyZW50Q2xpcFBhdGhzLnB1c2godCksIHQuYWJzb2x1dGVQb3NpdGlvbmVkKSB7XG4gICAgICBjb25zdCBuID0gU3QodGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgICAgci50cmFuc2Zvcm0oblswXSwgblsxXSwgblsyXSwgblszXSwgbls0XSwgbls1XSk7XG4gICAgfVxuICAgIHJldHVybiB0LnRyYW5zZm9ybShyKSwgdC5kcmF3T2JqZWN0KHIsICEwLCBlKSwgcztcbiAgfVxuICBfZHJhd0NsaXBQYXRoKHQsIGUsIHMpIHtcbiAgICBpZiAoIWUpIHJldHVybjtcbiAgICBlLl90cmFuc2Zvcm1Eb25lID0gITA7XG4gICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ2xpcFBhdGhMYXllcihlLCBzKTtcbiAgICB0aGlzLmRyYXdDbGlwUGF0aE9uQ2FjaGUodCwgZSwgcik7XG4gIH1cbiAgZHJhd0NhY2hlT25DYW52YXModCkge1xuICAgIHQuc2NhbGUoMSAvIHRoaXMuem9vbVgsIDEgLyB0aGlzLnpvb21ZKSwgdC5kcmF3SW1hZ2UodGhpcy5fY2FjaGVDYW52YXMsIC10aGlzLmNhY2hlVHJhbnNsYXRpb25YLCAtdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gIH1cbiAgaXNDYWNoZURpcnR5KCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgJiYgYXJndW1lbnRzWzBdO1xuICAgIGlmICh0aGlzLmlzTm90VmlzaWJsZSgpKSByZXR1cm4gITE7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlQ2FudmFzLCBzID0gdGhpcy5fY2FjaGVDb250ZXh0O1xuICAgIHJldHVybiAhKCFlIHx8ICFzIHx8IHQgfHwgIXRoaXMuX3VwZGF0ZUNhY2hlQ2FudmFzKCkpIHx8ICEhKHRoaXMuZGlydHkgfHwgdGhpcy5jbGlwUGF0aCAmJiB0aGlzLmNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCkgJiYgKGUgJiYgcyAmJiAhdCAmJiAocy5zYXZlKCksIHMuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApLCBzLmNsZWFyUmVjdCgwLCAwLCBlLndpZHRoLCBlLmhlaWdodCksIHMucmVzdG9yZSgpKSwgITApO1xuICB9XG4gIF9yZW5kZXJCYWNrZ3JvdW5kKHQpIHtcbiAgICBpZiAoIXRoaXMuYmFja2dyb3VuZENvbG9yKSByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgIHQuZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IsIHQuZmlsbFJlY3QoLWUueCAvIDIsIC1lLnkgLyAyLCBlLngsIGUueSksIHRoaXMuX3JlbW92ZVNoYWRvdyh0KTtcbiAgfVxuICBfc2V0T3BhY2l0eSh0KSB7XG4gICAgdGhpcy5ncm91cCAmJiAhdGhpcy5ncm91cC5fdHJhbnNmb3JtRG9uZSA/IHQuZ2xvYmFsQWxwaGEgPSB0aGlzLmdldE9iamVjdE9wYWNpdHkoKSA6IHQuZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5O1xuICB9XG4gIF9zZXRTdHJva2VTdHlsZXModCwgZSkge1xuICAgIGNvbnN0IHMgPSBlLnN0cm9rZTtcbiAgICBzICYmICh0LmxpbmVXaWR0aCA9IGUuc3Ryb2tlV2lkdGgsIHQubGluZUNhcCA9IGUuc3Ryb2tlTGluZUNhcCwgdC5saW5lRGFzaE9mZnNldCA9IGUuc3Ryb2tlRGFzaE9mZnNldCwgdC5saW5lSm9pbiA9IGUuc3Ryb2tlTGluZUpvaW4sIHQubWl0ZXJMaW1pdCA9IGUuc3Ryb2tlTWl0ZXJMaW1pdCwgQ3QocykgPyBzLmdyYWRpZW50VW5pdHMgPT09IFwicGVyY2VudGFnZVwiIHx8IHMuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgcy5wYXR0ZXJuVHJhbnNmb3JtID8gdGhpcy5fYXBwbHlQYXR0ZXJuRm9yVHJhbnNmb3JtZWRHcmFkaWVudCh0LCBzKSA6ICh0LnN0cm9rZVN0eWxlID0gcy50b0xpdmUodCksIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKHQsIHMpKSA6IHQuc3Ryb2tlU3R5bGUgPSBlLnN0cm9rZSk7XG4gIH1cbiAgX3NldEZpbGxTdHlsZXModCwgZSkge1xuICAgIGxldCB7IGZpbGw6IHMgfSA9IGU7XG4gICAgcyAmJiAoQ3QocykgPyAodC5maWxsU3R5bGUgPSBzLnRvTGl2ZSh0KSwgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0odCwgcykpIDogdC5maWxsU3R5bGUgPSBzKTtcbiAgfVxuICBfc2V0Q2xpcHBpbmdQcm9wZXJ0aWVzKHQpIHtcbiAgICB0Lmdsb2JhbEFscGhhID0gMSwgdC5zdHJva2VTdHlsZSA9IFwidHJhbnNwYXJlbnRcIiwgdC5maWxsU3R5bGUgPSBcIiMwMDAwMDBcIjtcbiAgfVxuICBfc2V0TGluZURhc2godCwgZSkge1xuICAgIGUgJiYgZS5sZW5ndGggIT09IDAgJiYgdC5zZXRMaW5lRGFzaChlKTtcbiAgfVxuICBfc2V0U2hhZG93KHQpIHtcbiAgICBpZiAoIXRoaXMuc2hhZG93KSByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuc2hhZG93LCBzID0gdGhpcy5jYW52YXMsIHIgPSB0aGlzLmdldENhbnZhc1JldGluYVNjYWxpbmcoKSwgW24sICwgLCBvXSA9IChzID09IG51bGwgPyB2b2lkIDAgOiBzLnZpZXdwb3J0VHJhbnNmb3JtKSB8fCBodCwgYSA9IG4gKiByLCBjID0gbyAqIHIsIGwgPSBlLm5vblNjYWxpbmcgPyBuZXcgXygxLCAxKSA6IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgIHQuc2hhZG93Q29sb3IgPSBlLmNvbG9yLCB0LnNoYWRvd0JsdXIgPSBlLmJsdXIgKiBBLmJyb3dzZXJTaGFkb3dCbHVyQ29uc3RhbnQgKiAoYSArIGMpICogKGwueCArIGwueSkgLyA0LCB0LnNoYWRvd09mZnNldFggPSBlLm9mZnNldFggKiBhICogbC54LCB0LnNoYWRvd09mZnNldFkgPSBlLm9mZnNldFkgKiBjICogbC55O1xuICB9XG4gIF9yZW1vdmVTaGFkb3codCkge1xuICAgIHRoaXMuc2hhZG93ICYmICh0LnNoYWRvd0NvbG9yID0gXCJcIiwgdC5zaGFkb3dCbHVyID0gdC5zaGFkb3dPZmZzZXRYID0gdC5zaGFkb3dPZmZzZXRZID0gMCk7XG4gIH1cbiAgX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKHQsIGUpIHtcbiAgICBpZiAoIUN0KGUpKSByZXR1cm4geyBvZmZzZXRYOiAwLCBvZmZzZXRZOiAwIH07XG4gICAgY29uc3QgcyA9IGUuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZS5wYXR0ZXJuVHJhbnNmb3JtLCByID0gLXRoaXMud2lkdGggLyAyICsgZS5vZmZzZXRYIHx8IDAsIG4gPSAtdGhpcy5oZWlnaHQgLyAyICsgZS5vZmZzZXRZIHx8IDA7XG4gICAgcmV0dXJuIGUuZ3JhZGllbnRVbml0cyA9PT0gXCJwZXJjZW50YWdlXCIgPyB0LnRyYW5zZm9ybSh0aGlzLndpZHRoLCAwLCAwLCB0aGlzLmhlaWdodCwgciwgbikgOiB0LnRyYW5zZm9ybSgxLCAwLCAwLCAxLCByLCBuKSwgcyAmJiB0LnRyYW5zZm9ybShzWzBdLCBzWzFdLCBzWzJdLCBzWzNdLCBzWzRdLCBzWzVdKSwgeyBvZmZzZXRYOiByLCBvZmZzZXRZOiBuIH07XG4gIH1cbiAgX3JlbmRlclBhaW50SW5PcmRlcih0KSB7XG4gICAgdGhpcy5wYWludEZpcnN0ID09PSBtdCA/ICh0aGlzLl9yZW5kZXJTdHJva2UodCksIHRoaXMuX3JlbmRlckZpbGwodCkpIDogKHRoaXMuX3JlbmRlckZpbGwodCksIHRoaXMuX3JlbmRlclN0cm9rZSh0KSk7XG4gIH1cbiAgX3JlbmRlcih0KSB7XG4gIH1cbiAgX3JlbmRlckZpbGwodCkge1xuICAgIHRoaXMuZmlsbCAmJiAodC5zYXZlKCksIHRoaXMuX3NldEZpbGxTdHlsZXModCwgdGhpcyksIHRoaXMuZmlsbFJ1bGUgPT09IFwiZXZlbm9kZFwiID8gdC5maWxsKFwiZXZlbm9kZFwiKSA6IHQuZmlsbCgpLCB0LnJlc3RvcmUoKSk7XG4gIH1cbiAgX3JlbmRlclN0cm9rZSh0KSB7XG4gICAgaWYgKHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlV2lkdGggIT09IDApIHtcbiAgICAgIGlmICh0aGlzLnNoYWRvdyAmJiAhdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlICYmIHRoaXMuX3JlbW92ZVNoYWRvdyh0KSwgdC5zYXZlKCksIHRoaXMuc3Ryb2tlVW5pZm9ybSkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICAgIHQuc2NhbGUoMSAvIGUueCwgMSAvIGUueSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaCh0LCB0aGlzLnN0cm9rZURhc2hBcnJheSksIHRoaXMuX3NldFN0cm9rZVN0eWxlcyh0LCB0aGlzKSwgdC5zdHJva2UoKSwgdC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIF9hcHBseVBhdHRlcm5Gb3JUcmFuc2Zvcm1lZEdyYWRpZW50KHQsIGUpIHtcbiAgICB2YXIgcztcbiAgICBjb25zdCByID0gdGhpcy5fbGltaXRDYWNoZVNpemUodGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkpLCBuID0gdGhpcy5nZXRDYW52YXNSZXRpbmFTY2FsaW5nKCksIG8gPSByLnggLyB0aGlzLnNjYWxlWCAvIG4sIGEgPSByLnkgLyB0aGlzLnNjYWxlWSAvIG4sIGMgPSBXdCh7IHdpZHRoOiBNYXRoLmNlaWwobyksIGhlaWdodDogTWF0aC5jZWlsKGEpIH0pLCBsID0gYy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgbCAmJiAobC5iZWdpblBhdGgoKSwgbC5tb3ZlVG8oMCwgMCksIGwubGluZVRvKG8sIDApLCBsLmxpbmVUbyhvLCBhKSwgbC5saW5lVG8oMCwgYSksIGwuY2xvc2VQYXRoKCksIGwudHJhbnNsYXRlKG8gLyAyLCBhIC8gMiksIGwuc2NhbGUoci56b29tWCAvIHRoaXMuc2NhbGVYIC8gbiwgci56b29tWSAvIHRoaXMuc2NhbGVZIC8gbiksIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGwsIGUpLCBsLmZpbGxTdHlsZSA9IGUudG9MaXZlKHQpLCBsLmZpbGwoKSwgdC50cmFuc2xhdGUoLXRoaXMud2lkdGggLyAyIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIgLSB0aGlzLnN0cm9rZVdpZHRoIC8gMiksIHQuc2NhbGUobiAqIHRoaXMuc2NhbGVYIC8gci56b29tWCwgbiAqIHRoaXMuc2NhbGVZIC8gci56b29tWSksIHQuc3Ryb2tlU3R5bGUgPSAocyA9IGwuY3JlYXRlUGF0dGVybihjLCBcIm5vLXJlcGVhdFwiKSkgIT09IG51bGwgJiYgcyAhPT0gdm9pZCAwID8gcyA6IFwiXCIpO1xuICB9XG4gIF9maW5kQ2VudGVyRnJvbUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBfKHRoaXMubGVmdCArIHRoaXMud2lkdGggLyAyLCB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0IC8gMik7XG4gIH1cbiAgY2xvbmUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnRvT2JqZWN0KHQpO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmZyb21PYmplY3QoZSk7XG4gIH1cbiAgY2xvbmVBc0ltYWdlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy50b0NhbnZhc0VsZW1lbnQodCk7XG4gICAgcmV0dXJuIG5ldyAoQy5nZXRDbGFzcyhcImltYWdlXCIpKShlKTtcbiAgfVxuICB0b0NhbnZhc0VsZW1lbnQoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IGUgPSB6bih0aGlzKSwgcyA9IHRoaXMuZ3JvdXAsIHIgPSB0aGlzLnNoYWRvdywgbiA9IE1hdGguYWJzLCBvID0gdC5lbmFibGVSZXRpbmFTY2FsaW5nID8gUmEoKSA6IDEsIGEgPSAodC5tdWx0aXBsaWVyIHx8IDEpICogbywgYyA9IHQuY2FudmFzUHJvdmlkZXIgfHwgKChTKSA9PiBuZXcgbHIoUywgeyBlbmFibGVSZXRpbmFTY2FsaW5nOiAhMSwgcmVuZGVyT25BZGRSZW1vdmU6ICExLCBza2lwT2Zmc2NyZWVuOiAhMSB9KSk7XG4gICAgZGVsZXRlIHRoaXMuZ3JvdXAsIHQud2l0aG91dFRyYW5zZm9ybSAmJiBzYyh0aGlzKSwgdC53aXRob3V0U2hhZG93ICYmICh0aGlzLnNoYWRvdyA9IG51bGwpLCB0LnZpZXdwb3J0VHJhbnNmb3JtICYmIGFuKHRoaXMsIHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSksIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgY29uc3QgbCA9IGt0KCksIGggPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLCB1ID0gdGhpcy5zaGFkb3csIGQgPSBuZXcgXygpO1xuICAgIGlmICh1KSB7XG4gICAgICBjb25zdCBTID0gdS5ibHVyLCB3ID0gdS5ub25TY2FsaW5nID8gbmV3IF8oMSwgMSkgOiB0aGlzLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICAgIGQueCA9IDIgKiBNYXRoLnJvdW5kKG4odS5vZmZzZXRYKSArIFMpICogbih3LngpLCBkLnkgPSAyICogTWF0aC5yb3VuZChuKHUub2Zmc2V0WSkgKyBTKSAqIG4ody55KTtcbiAgICB9XG4gICAgY29uc3QgZiA9IGgud2lkdGggKyBkLngsIGcgPSBoLmhlaWdodCArIGQueTtcbiAgICBsLndpZHRoID0gTWF0aC5jZWlsKGYpLCBsLmhlaWdodCA9IE1hdGguY2VpbChnKTtcbiAgICBjb25zdCBwID0gYyhsKTtcbiAgICB0LmZvcm1hdCA9PT0gXCJqcGVnXCIgJiYgKHAuYmFja2dyb3VuZENvbG9yID0gXCIjZmZmXCIpLCB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4obmV3IF8ocC53aWR0aCAvIDIsIHAuaGVpZ2h0IC8gMiksIGosIGopO1xuICAgIGNvbnN0IG0gPSB0aGlzLmNhbnZhcztcbiAgICBwLl9vYmplY3RzID0gW3RoaXNdLCB0aGlzLnNldChcImNhbnZhc1wiLCBwKSwgdGhpcy5zZXRDb29yZHMoKTtcbiAgICBjb25zdCBiID0gcC50b0NhbnZhc0VsZW1lbnQoYSB8fCAxLCB0KTtcbiAgICByZXR1cm4gdGhpcy5zZXQoXCJjYW52YXNcIiwgbSksIHRoaXMuc2hhZG93ID0gciwgcyAmJiAodGhpcy5ncm91cCA9IHMpLCB0aGlzLnNldChlKSwgdGhpcy5zZXRDb29yZHMoKSwgcC5fb2JqZWN0cyA9IFtdLCBwLmRlc3Ryb3koKSwgYjtcbiAgfVxuICB0b0RhdGFVUkwoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHJldHVybiBSbih0aGlzLnRvQ2FudmFzRWxlbWVudCh0KSwgdC5mb3JtYXQgfHwgXCJwbmdcIiwgdC5xdWFsaXR5IHx8IDEpO1xuICB9XG4gIHRvQmxvYigpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgcmV0dXJuIExuKHRoaXMudG9DYW52YXNFbGVtZW50KHQpLCB0LmZvcm1hdCB8fCBcInBuZ1wiLCB0LnF1YWxpdHkgfHwgMSk7XG4gIH1cbiAgaXNUeXBlKCkge1xuICAgIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBlID0gbmV3IEFycmF5KHQpLCBzID0gMDsgcyA8IHQ7IHMrKykgZVtzXSA9IGFyZ3VtZW50c1tzXTtcbiAgICByZXR1cm4gZS5pbmNsdWRlcyh0aGlzLmNvbnN0cnVjdG9yLnR5cGUpIHx8IGUuaW5jbHVkZXModGhpcy50eXBlKTtcbiAgfVxuICBjb21wbGV4aXR5KCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b09iamVjdCgpO1xuICB9XG4gIHJvdGF0ZSh0KSB7XG4gICAgY29uc3QgeyBjZW50ZXJlZFJvdGF0aW9uOiBlLCBvcmlnaW5YOiBzLCBvcmlnaW5ZOiByIH0gPSB0aGlzO1xuICAgIGlmIChlKSB7XG4gICAgICBjb25zdCB7IHg6IG4sIHk6IG8gfSA9IHRoaXMuZ2V0UmVsYXRpdmVDZW50ZXJQb2ludCgpO1xuICAgICAgdGhpcy5vcmlnaW5YID0gaiwgdGhpcy5vcmlnaW5ZID0gaiwgdGhpcy5sZWZ0ID0gbiwgdGhpcy50b3AgPSBvO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXQoXCJhbmdsZVwiLCB0KSwgZSkge1xuICAgICAgY29uc3QgeyB4OiBuLCB5OiBvIH0gPSB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGhpcy5nZXRSZWxhdGl2ZUNlbnRlclBvaW50KCksIHMsIHIpO1xuICAgICAgdGhpcy5sZWZ0ID0gbiwgdGhpcy50b3AgPSBvLCB0aGlzLm9yaWdpblggPSBzLCB0aGlzLm9yaWdpblkgPSByO1xuICAgIH1cbiAgfVxuICBzZXRPbkdyb3VwKCkge1xuICB9XG4gIF9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbih0KSB7XG4gICAgdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gJiYgKHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgcXIuY2FuY2VsQnlUYXJnZXQodGhpcyksIHRoaXMub2ZmKCksIHRoaXMuX3NldChcImNhbnZhc1wiLCB2b2lkIDApLCB0aGlzLl9jYWNoZUNhbnZhcyAmJiAkdCgpLmRpc3Bvc2UodGhpcy5fY2FjaGVDYW52YXMpLCB0aGlzLl9jYWNoZUNhbnZhcyA9IHZvaWQgMCwgdGhpcy5fY2FjaGVDb250ZXh0ID0gbnVsbDtcbiAgfVxuICBhbmltYXRlKHQsIGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModCkucmVkdWNlKChzLCByKSA9PiB7XG4gICAgICBsZXQgW24sIG9dID0gcjtcbiAgICAgIHJldHVybiBzW25dID0gdGhpcy5fYW5pbWF0ZShuLCBvLCBlKSwgcztcbiAgICB9LCB7fSk7XG4gIH1cbiAgX2FuaW1hdGUodCwgZSkge1xuICAgIGxldCBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjb25zdCByID0gdC5zcGxpdChcIi5cIiksIG4gPSB0aGlzLmNvbnN0cnVjdG9yLmNvbG9yUHJvcGVydGllcy5pbmNsdWRlcyhyW3IubGVuZ3RoIC0gMV0pLCB7IGFib3J0OiBvLCBzdGFydFZhbHVlOiBhLCBvbkNoYW5nZTogYywgb25Db21wbGV0ZTogbCB9ID0gcywgaCA9IHYodih7fSwgcyksIHt9LCB7IHRhcmdldDogdGhpcywgc3RhcnRWYWx1ZTogYSA/PyByLnJlZHVjZSgodSwgZCkgPT4gdVtkXSwgdGhpcyksIGVuZFZhbHVlOiBlLCBhYm9ydDogbyA9PSBudWxsID8gdm9pZCAwIDogby5iaW5kKHRoaXMpLCBvbkNoYW5nZTogKHUsIGQsIGYpID0+IHtcbiAgICAgIHIucmVkdWNlKChnLCBwLCBtKSA9PiAobSA9PT0gci5sZW5ndGggLSAxICYmIChnW3BdID0gdSksIGdbcF0pLCB0aGlzKSwgYyAmJiBjKHUsIGQsIGYpO1xuICAgIH0sIG9uQ29tcGxldGU6ICh1LCBkLCBmKSA9PiB7XG4gICAgICB0aGlzLnNldENvb3JkcygpLCBsICYmIGwodSwgZCwgZik7XG4gICAgfSB9KTtcbiAgICByZXR1cm4gbiA/IGRjKGgpIDogVW4oaCk7XG4gIH1cbiAgaXNEZXNjZW5kYW50T2YodCkge1xuICAgIGNvbnN0IHsgcGFyZW50OiBlLCBncm91cDogcyB9ID0gdGhpcztcbiAgICByZXR1cm4gZSA9PT0gdCB8fCBzID09PSB0IHx8ICEhZSAmJiBlLmlzRGVzY2VuZGFudE9mKHQpIHx8ICEhcyAmJiBzICE9PSBlICYmIHMuaXNEZXNjZW5kYW50T2YodCk7XG4gIH1cbiAgZ2V0QW5jZXN0b3JzKCkge1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICBsZXQgZSA9IHRoaXM7XG4gICAgZG9cbiAgICAgIGUgPSBlLnBhcmVudCwgZSAmJiB0LnB1c2goZSk7XG4gICAgd2hpbGUgKGUpO1xuICAgIHJldHVybiB0O1xuICB9XG4gIGZpbmRDb21tb25BbmNlc3RvcnModCkge1xuICAgIGlmICh0aGlzID09PSB0KSByZXR1cm4geyBmb3JrOiBbXSwgb3RoZXJGb3JrOiBbXSwgY29tbW9uOiBbdGhpcywgLi4udGhpcy5nZXRBbmNlc3RvcnMoKV0gfTtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRBbmNlc3RvcnMoKSwgcyA9IHQuZ2V0QW5jZXN0b3JzKCk7XG4gICAgaWYgKGUubGVuZ3RoID09PSAwICYmIHMubGVuZ3RoID4gMCAmJiB0aGlzID09PSBzW3MubGVuZ3RoIC0gMV0pIHJldHVybiB7IGZvcms6IFtdLCBvdGhlckZvcms6IFt0LCAuLi5zLnNsaWNlKDAsIHMubGVuZ3RoIC0gMSldLCBjb21tb246IFt0aGlzXSB9O1xuICAgIGZvciAobGV0IHIsIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgaWYgKHIgPSBlW25dLCByID09PSB0KSByZXR1cm4geyBmb3JrOiBbdGhpcywgLi4uZS5zbGljZSgwLCBuKV0sIG90aGVyRm9yazogW10sIGNvbW1vbjogZS5zbGljZShuKSB9O1xuICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBzW29dKSByZXR1cm4geyBmb3JrOiBbXSwgb3RoZXJGb3JrOiBbdCwgLi4ucy5zbGljZSgwLCBvKV0sIGNvbW1vbjogW3RoaXMsIC4uLmVdIH07XG4gICAgICAgIGlmIChyID09PSBzW29dKSByZXR1cm4geyBmb3JrOiBbdGhpcywgLi4uZS5zbGljZSgwLCBuKV0sIG90aGVyRm9yazogW3QsIC4uLnMuc2xpY2UoMCwgbyldLCBjb21tb246IGUuc2xpY2UobikgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZm9yazogW3RoaXMsIC4uLmVdLCBvdGhlckZvcms6IFt0LCAuLi5zXSwgY29tbW9uOiBbXSB9O1xuICB9XG4gIGhhc0NvbW1vbkFuY2VzdG9ycyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZmluZENvbW1vbkFuY2VzdG9ycyh0KTtcbiAgICByZXR1cm4gZSAmJiAhIWUuY29tbW9uLmxlbmd0aDtcbiAgfVxuICBpc0luRnJvbnRPZih0KSB7XG4gICAgaWYgKHRoaXMgPT09IHQpIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5maW5kQ29tbW9uQW5jZXN0b3JzKHQpO1xuICAgIGlmIChlLmZvcmsuaW5jbHVkZXModCkpIHJldHVybiAhMDtcbiAgICBpZiAoZS5vdGhlckZvcmsuaW5jbHVkZXModGhpcykpIHJldHVybiAhMTtcbiAgICBjb25zdCBzID0gZS5jb21tb25bMF0gfHwgdGhpcy5jYW52YXM7XG4gICAgaWYgKCFzKSByZXR1cm47XG4gICAgY29uc3QgciA9IGUuZm9yay5wb3AoKSwgbiA9IGUub3RoZXJGb3JrLnBvcCgpLCBvID0gcy5fb2JqZWN0cy5pbmRleE9mKHIpLCBhID0gcy5fb2JqZWN0cy5pbmRleE9mKG4pO1xuICAgIHJldHVybiBvID4gLTEgJiYgbyA+IGE7XG4gIH1cbiAgdG9PYmplY3QoKSB7XG4gICAgY29uc3QgdCA9IChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IFtdKS5jb25jYXQoR3IuY3VzdG9tUHJvcGVydGllcywgdGhpcy5jb25zdHJ1Y3Rvci5jdXN0b21Qcm9wZXJ0aWVzIHx8IFtdKTtcbiAgICBsZXQgZTtcbiAgICBjb25zdCBzID0gQS5OVU1fRlJBQ1RJT05fRElHSVRTLCB7IGNsaXBQYXRoOiByLCBmaWxsOiBuLCBzdHJva2U6IG8sIHNoYWRvdzogYSwgc3Ryb2tlRGFzaEFycmF5OiBjLCBsZWZ0OiBsLCB0b3A6IGgsIG9yaWdpblg6IHUsIG9yaWdpblk6IGQsIHdpZHRoOiBmLCBoZWlnaHQ6IGcsIHN0cm9rZVdpZHRoOiBwLCBzdHJva2VMaW5lQ2FwOiBtLCBzdHJva2VEYXNoT2Zmc2V0OiBiLCBzdHJva2VMaW5lSm9pbjogUywgc3Ryb2tlVW5pZm9ybTogdywgc3Ryb2tlTWl0ZXJMaW1pdDogaywgc2NhbGVYOiBPLCBzY2FsZVk6IHgsIGFuZ2xlOiBJLCBmbGlwWDogTSwgZmxpcFk6IEUsIG9wYWNpdHk6IFIsIHZpc2libGU6IHR0LCBiYWNrZ3JvdW5kQ29sb3I6IEYsIGZpbGxSdWxlOiBCLCBwYWludEZpcnN0OiAkLCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246IHl0LCBza2V3WDogZHQsIHNrZXdZOiBEdCB9ID0gdGhpcztcbiAgICByICYmICFyLmV4Y2x1ZGVGcm9tRXhwb3J0ICYmIChlID0gci50b09iamVjdCh0LmNvbmNhdChcImludmVydGVkXCIsIFwiYWJzb2x1dGVQb3NpdGlvbmVkXCIpKSk7XG4gICAgY29uc3QgcSA9ICh0ZSkgPT4gVih0ZSwgcyksIHp0ID0gdih2KHt9LCBWZSh0aGlzLCB0KSksIHt9LCB7IHR5cGU6IHRoaXMuY29uc3RydWN0b3IudHlwZSwgdmVyc2lvbjogc24sIG9yaWdpblg6IHUsIG9yaWdpblk6IGQsIGxlZnQ6IHEobCksIHRvcDogcShoKSwgd2lkdGg6IHEoZiksIGhlaWdodDogcShnKSwgZmlsbDogX28obikgPyBuLnRvT2JqZWN0KCkgOiBuLCBzdHJva2U6IF9vKG8pID8gby50b09iamVjdCgpIDogbywgc3Ryb2tlV2lkdGg6IHEocCksIHN0cm9rZURhc2hBcnJheTogYyAmJiBjLmNvbmNhdCgpLCBzdHJva2VMaW5lQ2FwOiBtLCBzdHJva2VEYXNoT2Zmc2V0OiBiLCBzdHJva2VMaW5lSm9pbjogUywgc3Ryb2tlVW5pZm9ybTogdywgc3Ryb2tlTWl0ZXJMaW1pdDogcShrKSwgc2NhbGVYOiBxKE8pLCBzY2FsZVk6IHEoeCksIGFuZ2xlOiBxKEkpLCBmbGlwWDogTSwgZmxpcFk6IEUsIG9wYWNpdHk6IHEoUiksIHNoYWRvdzogYSAmJiBhLnRvT2JqZWN0KCksIHZpc2libGU6IHR0LCBiYWNrZ3JvdW5kQ29sb3I6IEYsIGZpbGxSdWxlOiBCLCBwYWludEZpcnN0OiAkLCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246IHl0LCBza2V3WDogcShkdCksIHNrZXdZOiBxKER0KSB9LCBlID8geyBjbGlwUGF0aDogZSB9IDogbnVsbCk7XG4gICAgcmV0dXJuIHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPyB6dCA6IHRoaXMuX3JlbW92ZURlZmF1bHRWYWx1ZXMoenQpO1xuICB9XG4gIHRvRGF0YWxlc3NPYmplY3QodCkge1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KHQpO1xuICB9XG4gIF9yZW1vdmVEZWZhdWx0VmFsdWVzKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXREZWZhdWx0cygpLCBzID0gT2JqZWN0LmtleXMoZSkubGVuZ3RoID4gMCA/IGUgOiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgcmV0dXJuIFhuKHQsIChyLCBuKSA9PiB7XG4gICAgICBpZiAobiA9PT0gTCB8fCBuID09PSBndCB8fCBuID09PSBcInR5cGVcIikgcmV0dXJuICEwO1xuICAgICAgY29uc3QgbyA9IHNbbl07XG4gICAgICByZXR1cm4gciAhPT0gbyAmJiAhKEFycmF5LmlzQXJyYXkocikgJiYgQXJyYXkuaXNBcnJheShvKSAmJiByLmxlbmd0aCA9PT0gMCAmJiBvLmxlbmd0aCA9PT0gMCk7XG4gICAgfSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiIzxcIi5jb25jYXQodGhpcy5jb25zdHJ1Y3Rvci50eXBlLCBcIj5cIik7XG4gIH1cbiAgc3RhdGljIF9mcm9tT2JqZWN0KHQpIHtcbiAgICBsZXQgZSA9IEcodCwgY3UpLCBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fSwgeyBleHRyYVBhcmFtOiByIH0gPSBzLCBuID0gRyhzLCBsdSk7XG4gICAgcmV0dXJuIGNyKGUsIG4pLnRoZW4oKG8pID0+IHIgPyAoZGVsZXRlIG9bcl0sIG5ldyB0aGlzKGVbcl0sIG8pKSA6IG5ldyB0aGlzKG8pKTtcbiAgfVxuICBzdGF0aWMgZnJvbU9iamVjdCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zyb21PYmplY3QodCwgZSk7XG4gIH1cbn07XG55KGVlLCBcInN0YXRlUHJvcGVydGllc1wiLCBLaCksIHkoZWUsIFwiY2FjaGVQcm9wZXJ0aWVzXCIsIGRlKSwgeShlZSwgXCJvd25EZWZhdWx0c1wiLCBKaCksIHkoZWUsIFwidHlwZVwiLCBcIkZhYnJpY09iamVjdFwiKSwgeShlZSwgXCJjb2xvclByb3BlcnRpZXNcIiwgW3J0LCBtdCwgXCJiYWNrZ3JvdW5kQ29sb3JcIl0pLCB5KGVlLCBcImN1c3RvbVByb3BlcnRpZXNcIiwgW10pLCBDLnNldENsYXNzKGVlKSwgQy5zZXRDbGFzcyhlZSwgXCJvYmplY3RcIik7XG5jb25zdCBJZSA9IChpLCB0LCBlKSA9PiAocywgciwgbiwgbykgPT4ge1xuICBjb25zdCBhID0gdChzLCByLCBuLCBvKTtcbiAgcmV0dXJuIGEgJiYgSG4oaSwgdih2KHt9LCBZbihzLCByLCBuLCBvKSksIGUpKSwgYTtcbn07XG5mdW5jdGlvbiBHZShpKSB7XG4gIHJldHVybiAodCwgZSwgcywgcikgPT4ge1xuICAgIGNvbnN0IHsgdGFyZ2V0OiBuLCBvcmlnaW5YOiBvLCBvcmlnaW5ZOiBhIH0gPSBlLCBjID0gbi5nZXRSZWxhdGl2ZUNlbnRlclBvaW50KCksIGwgPSBuLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoYywgbywgYSksIGggPSBpKHQsIGUsIHMsIHIpO1xuICAgIHJldHVybiBuLnNldFBvc2l0aW9uQnlPcmlnaW4obCwgZS5vcmlnaW5YLCBlLm9yaWdpblkpLCBoO1xuICB9O1xufVxuY29uc3QgaG4gPSBJZSgkcywgR2UoKGksIHQsIGUsIHMpID0+IHtcbiAgY29uc3QgciA9IGJpKHQsIHQub3JpZ2luWCwgdC5vcmlnaW5ZLCBlLCBzKTtcbiAgaWYgKHN0KHQub3JpZ2luWCkgPT09IHN0KGopIHx8IHN0KHQub3JpZ2luWCkgPT09IHN0KFopICYmIHIueCA8IDAgfHwgc3QodC5vcmlnaW5YKSA9PT0gc3QoTCkgJiYgci54ID4gMCkge1xuICAgIGNvbnN0IHsgdGFyZ2V0OiBuIH0gPSB0LCBvID0gbi5zdHJva2VXaWR0aCAvIChuLnN0cm9rZVVuaWZvcm0gPyBuLnNjYWxlWCA6IDEpLCBhID0gaWModCkgPyAyIDogMSwgYyA9IG4ud2lkdGgsIGwgPSBNYXRoLmFicyhyLnggKiBhIC8gbi5zY2FsZVgpIC0gbztcbiAgICByZXR1cm4gbi5zZXQoXCJ3aWR0aFwiLCBNYXRoLm1heChsLCAxKSksIGMgIT09IG4ud2lkdGg7XG4gIH1cbiAgcmV0dXJuICExO1xufSkpO1xuZnVuY3Rpb24gZmMoaSwgdCwgZSwgcywgcikge1xuICBzID0gcyB8fCB7fTtcbiAgY29uc3QgbiA9IHRoaXMuc2l6ZVggfHwgcy5jb3JuZXJTaXplIHx8IHIuY29ybmVyU2l6ZSwgbyA9IHRoaXMuc2l6ZVkgfHwgcy5jb3JuZXJTaXplIHx8IHIuY29ybmVyU2l6ZSwgYSA9IHMudHJhbnNwYXJlbnRDb3JuZXJzICE9PSB2b2lkIDAgPyBzLnRyYW5zcGFyZW50Q29ybmVycyA6IHIudHJhbnNwYXJlbnRDb3JuZXJzLCBjID0gYSA/IG10IDogcnQsIGwgPSAhYSAmJiAocy5jb3JuZXJTdHJva2VDb2xvciB8fCByLmNvcm5lclN0cm9rZUNvbG9yKTtcbiAgbGV0IGgsIHUgPSB0LCBkID0gZTtcbiAgaS5zYXZlKCksIGkuZmlsbFN0eWxlID0gcy5jb3JuZXJDb2xvciB8fCByLmNvcm5lckNvbG9yIHx8IFwiXCIsIGkuc3Ryb2tlU3R5bGUgPSBzLmNvcm5lclN0cm9rZUNvbG9yIHx8IHIuY29ybmVyU3Ryb2tlQ29sb3IgfHwgXCJcIiwgbiA+IG8gPyAoaCA9IG4sIGkuc2NhbGUoMSwgbyAvIG4pLCBkID0gZSAqIG4gLyBvKSA6IG8gPiBuID8gKGggPSBvLCBpLnNjYWxlKG4gLyBvLCAxKSwgdSA9IHQgKiBvIC8gbikgOiBoID0gbiwgaS5iZWdpblBhdGgoKSwgaS5hcmModSwgZCwgaCAvIDIsIDAsIGhlLCAhMSksIGlbY10oKSwgbCAmJiBpLnN0cm9rZSgpLCBpLnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGdjKGksIHQsIGUsIHMsIHIpIHtcbiAgcyA9IHMgfHwge307XG4gIGNvbnN0IG4gPSB0aGlzLnNpemVYIHx8IHMuY29ybmVyU2l6ZSB8fCByLmNvcm5lclNpemUsIG8gPSB0aGlzLnNpemVZIHx8IHMuY29ybmVyU2l6ZSB8fCByLmNvcm5lclNpemUsIGEgPSBzLnRyYW5zcGFyZW50Q29ybmVycyAhPT0gdm9pZCAwID8gcy50cmFuc3BhcmVudENvcm5lcnMgOiByLnRyYW5zcGFyZW50Q29ybmVycywgYyA9IGEgPyBtdCA6IHJ0LCBsID0gIWEgJiYgKHMuY29ybmVyU3Ryb2tlQ29sb3IgfHwgci5jb3JuZXJTdHJva2VDb2xvciksIGggPSBuIC8gMiwgdSA9IG8gLyAyO1xuICBpLnNhdmUoKSwgaS5maWxsU3R5bGUgPSBzLmNvcm5lckNvbG9yIHx8IHIuY29ybmVyQ29sb3IgfHwgXCJcIiwgaS5zdHJva2VTdHlsZSA9IHMuY29ybmVyU3Ryb2tlQ29sb3IgfHwgci5jb3JuZXJTdHJva2VDb2xvciB8fCBcIlwiLCBpLnRyYW5zbGF0ZSh0LCBlKTtcbiAgY29uc3QgZCA9IHIuZ2V0VG90YWxBbmdsZSgpO1xuICBpLnJvdGF0ZShLKGQpKSwgaVtcIlwiLmNvbmNhdChjLCBcIlJlY3RcIildKC1oLCAtdSwgbiwgbyksIGwgJiYgaS5zdHJva2VSZWN0KC1oLCAtdSwgbiwgbyksIGkucmVzdG9yZSgpO1xufVxuY2xhc3MgVSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB5KHRoaXMsIFwidmlzaWJsZVwiLCAhMCksIHkodGhpcywgXCJhY3Rpb25OYW1lXCIsIHBpKSwgeSh0aGlzLCBcImFuZ2xlXCIsIDApLCB5KHRoaXMsIFwieFwiLCAwKSwgeSh0aGlzLCBcInlcIiwgMCksIHkodGhpcywgXCJvZmZzZXRYXCIsIDApLCB5KHRoaXMsIFwib2Zmc2V0WVwiLCAwKSwgeSh0aGlzLCBcInNpemVYXCIsIDApLCB5KHRoaXMsIFwic2l6ZVlcIiwgMCksIHkodGhpcywgXCJ0b3VjaFNpemVYXCIsIDApLCB5KHRoaXMsIFwidG91Y2hTaXplWVwiLCAwKSwgeSh0aGlzLCBcImN1cnNvclN0eWxlXCIsIFwiY3Jvc3NoYWlyXCIpLCB5KHRoaXMsIFwid2l0aENvbm5lY3Rpb25cIiwgITEpLCBPYmplY3QuYXNzaWduKHRoaXMsIHQpO1xuICB9XG4gIHNob3VsZEFjdGl2YXRlKHQsIGUsIHMsIHIpIHtcbiAgICB2YXIgbjtcbiAgICBsZXQgeyB0bDogbywgdHI6IGEsIGJyOiBjLCBibDogbCB9ID0gcjtcbiAgICByZXR1cm4gKChuID0gZS5jYW52YXMpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uZ2V0QWN0aXZlT2JqZWN0KCkpID09PSBlICYmIGUuaXNDb250cm9sVmlzaWJsZSh0KSAmJiBOLmlzUG9pbnRJblBvbHlnb24ocywgW28sIGEsIGMsIGxdKTtcbiAgfVxuICBnZXRBY3Rpb25IYW5kbGVyKHQsIGUsIHMpIHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25IYW5kbGVyO1xuICB9XG4gIGdldE1vdXNlRG93bkhhbmRsZXIodCwgZSwgcykge1xuICAgIHJldHVybiB0aGlzLm1vdXNlRG93bkhhbmRsZXI7XG4gIH1cbiAgZ2V0TW91c2VVcEhhbmRsZXIodCwgZSwgcykge1xuICAgIHJldHVybiB0aGlzLm1vdXNlVXBIYW5kbGVyO1xuICB9XG4gIGN1cnNvclN0eWxlSGFuZGxlcih0LCBlLCBzKSB7XG4gICAgcmV0dXJuIGUuY3Vyc29yU3R5bGU7XG4gIH1cbiAgZ2V0QWN0aW9uTmFtZSh0LCBlLCBzKSB7XG4gICAgcmV0dXJuIGUuYWN0aW9uTmFtZTtcbiAgfVxuICBnZXRWaXNpYmlsaXR5KHQsIGUpIHtcbiAgICB2YXIgcywgcjtcbiAgICByZXR1cm4gKHMgPSAociA9IHQuX2NvbnRyb2xzVmlzaWJpbGl0eSkgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcltlXSkgIT09IG51bGwgJiYgcyAhPT0gdm9pZCAwID8gcyA6IHRoaXMudmlzaWJsZTtcbiAgfVxuICBzZXRWaXNpYmlsaXR5KHQsIGUsIHMpIHtcbiAgICB0aGlzLnZpc2libGUgPSB0O1xuICB9XG4gIHBvc2l0aW9uSGFuZGxlcih0LCBlLCBzLCByKSB7XG4gICAgcmV0dXJuIG5ldyBfKHRoaXMueCAqIHQueCArIHRoaXMub2Zmc2V0WCwgdGhpcy55ICogdC55ICsgdGhpcy5vZmZzZXRZKS50cmFuc2Zvcm0oZSk7XG4gIH1cbiAgY2FsY0Nvcm5lckNvb3Jkcyh0LCBlLCBzLCByLCBuLCBvKSB7XG4gICAgY29uc3QgYSA9IG1pKFtNcyhzLCByKSwgSXMoeyBhbmdsZTogdCB9KSwgdmkoKG4gPyB0aGlzLnRvdWNoU2l6ZVggOiB0aGlzLnNpemVYKSB8fCBlLCAobiA/IHRoaXMudG91Y2hTaXplWSA6IHRoaXMuc2l6ZVkpIHx8IGUpXSk7XG4gICAgcmV0dXJuIHsgdGw6IG5ldyBfKC0wLjUsIC0wLjUpLnRyYW5zZm9ybShhKSwgdHI6IG5ldyBfKDAuNSwgLTAuNSkudHJhbnNmb3JtKGEpLCBicjogbmV3IF8oMC41LCAwLjUpLnRyYW5zZm9ybShhKSwgYmw6IG5ldyBfKC0wLjUsIDAuNSkudHJhbnNmb3JtKGEpIH07XG4gIH1cbiAgcmVuZGVyKHQsIGUsIHMsIHIsIG4pIHtcbiAgICAoKHIgPSByIHx8IHt9KS5jb3JuZXJTdHlsZSB8fCBuLmNvcm5lclN0eWxlKSA9PT0gXCJjaXJjbGVcIiA/IGZjLmNhbGwodGhpcywgdCwgZSwgcywgciwgbikgOiBnYy5jYWxsKHRoaXMsIHQsIGUsIHMsIHIsIG4pO1xuICB9XG59XG5jb25zdCBwYyA9IChpLCB0LCBlKSA9PiBlLmxvY2tSb3RhdGlvbiA/IEpyIDogdC5jdXJzb3JTdHlsZSwgbWMgPSBJZShCYSwgR2UoKGksIHQsIGUsIHMpID0+IHtcbiAgbGV0IHsgdGFyZ2V0OiByLCBleDogbiwgZXk6IG8sIHRoZXRhOiBhLCBvcmlnaW5YOiBjLCBvcmlnaW5ZOiBsIH0gPSB0O1xuICBjb25zdCBoID0gci50cmFuc2xhdGVUb09yaWdpblBvaW50KHIuZ2V0UmVsYXRpdmVDZW50ZXJQb2ludCgpLCBjLCBsKTtcbiAgaWYgKFJ0KHIsIFwibG9ja1JvdGF0aW9uXCIpKSByZXR1cm4gITE7XG4gIGNvbnN0IHUgPSBNYXRoLmF0YW4yKG8gLSBoLnksIG4gLSBoLngpLCBkID0gTWF0aC5hdGFuMihzIC0gaC55LCBlIC0gaC54KTtcbiAgbGV0IGYgPSBDZShkIC0gdSArIGEpO1xuICBpZiAoci5zbmFwQW5nbGUgJiYgci5zbmFwQW5nbGUgPiAwKSB7XG4gICAgY29uc3QgcCA9IHIuc25hcEFuZ2xlLCBtID0gci5zbmFwVGhyZXNob2xkIHx8IHAsIGIgPSBNYXRoLmNlaWwoZiAvIHApICogcCwgUyA9IE1hdGguZmxvb3IoZiAvIHApICogcDtcbiAgICBNYXRoLmFicyhmIC0gUykgPCBtID8gZiA9IFMgOiBNYXRoLmFicyhmIC0gYikgPCBtICYmIChmID0gYik7XG4gIH1cbiAgZiA8IDAgJiYgKGYgPSAzNjAgKyBmKSwgZiAlPSAzNjA7XG4gIGNvbnN0IGcgPSByLmFuZ2xlICE9PSBmO1xuICByZXR1cm4gci5hbmdsZSA9IGYsIGc7XG59KSk7XG5mdW5jdGlvbiB2YyhpLCB0KSB7XG4gIGNvbnN0IGUgPSB0LmNhbnZhcywgcyA9IGlbZS51bmlTY2FsZUtleV07XG4gIHJldHVybiBlLnVuaWZvcm1TY2FsaW5nICYmICFzIHx8ICFlLnVuaWZvcm1TY2FsaW5nICYmIHM7XG59XG5mdW5jdGlvbiB5YyhpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBSdChpLCBcImxvY2tTY2FsaW5nWFwiKSwgciA9IFJ0KGksIFwibG9ja1NjYWxpbmdZXCIpO1xuICBpZiAocyAmJiByIHx8ICF0ICYmIChzIHx8IHIpICYmIGUgfHwgcyAmJiB0ID09PSBcInhcIiB8fCByICYmIHQgPT09IFwieVwiKSByZXR1cm4gITA7XG4gIGNvbnN0IHsgd2lkdGg6IG4sIGhlaWdodDogbywgc3Ryb2tlV2lkdGg6IGEgfSA9IGk7XG4gIHJldHVybiBuID09PSAwICYmIGEgPT09IDAgJiYgdCAhPT0gXCJ5XCIgfHwgbyA9PT0gMCAmJiBhID09PSAwICYmIHQgIT09IFwieFwiO1xufVxuY29uc3QgaHUgPSBbXCJlXCIsIFwic2VcIiwgXCJzXCIsIFwic3dcIiwgXCJ3XCIsIFwibndcIiwgXCJuXCIsIFwibmVcIiwgXCJlXCJdLCBaZSA9IChpLCB0LCBlKSA9PiB7XG4gIGNvbnN0IHMgPSB2YyhpLCBlKTtcbiAgaWYgKHljKGUsIHQueCAhPT0gMCAmJiB0LnkgPT09IDAgPyBcInhcIiA6IHQueCA9PT0gMCAmJiB0LnkgIT09IDAgPyBcInlcIiA6IFwiXCIsIHMpKSByZXR1cm4gSnI7XG4gIGNvbnN0IHIgPSBuYyhlLCB0KTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGh1W3JdLCBcIi1yZXNpemVcIik7XG59O1xuZnVuY3Rpb24gJG4oaSwgdCwgZSwgcykge1xuICBsZXQgciA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzRdIDoge307XG4gIGNvbnN0IG4gPSB0LnRhcmdldCwgbyA9IHIuYnksIGEgPSB2YyhpLCBuKTtcbiAgbGV0IGMsIGwsIGgsIHUsIGQsIGY7XG4gIGlmICh5YyhuLCBvLCBhKSkgcmV0dXJuICExO1xuICBpZiAodC5nZXN0dXJlU2NhbGUpIGwgPSB0LnNjYWxlWCAqIHQuZ2VzdHVyZVNjYWxlLCBoID0gdC5zY2FsZVkgKiB0Lmdlc3R1cmVTY2FsZTtcbiAgZWxzZSB7XG4gICAgaWYgKGMgPSBiaSh0LCB0Lm9yaWdpblgsIHQub3JpZ2luWSwgZSwgcyksIGQgPSBvICE9PSBcInlcIiA/IE1hdGguc2lnbihjLnggfHwgdC5zaWduWCB8fCAxKSA6IDEsIGYgPSBvICE9PSBcInhcIiA/IE1hdGguc2lnbihjLnkgfHwgdC5zaWduWSB8fCAxKSA6IDEsIHQuc2lnblggfHwgKHQuc2lnblggPSBkKSwgdC5zaWduWSB8fCAodC5zaWduWSA9IGYpLCBSdChuLCBcImxvY2tTY2FsaW5nRmxpcFwiKSAmJiAodC5zaWduWCAhPT0gZCB8fCB0LnNpZ25ZICE9PSBmKSkgcmV0dXJuICExO1xuICAgIGlmICh1ID0gbi5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCksIGEgJiYgIW8pIHtcbiAgICAgIGNvbnN0IG0gPSBNYXRoLmFicyhjLngpICsgTWF0aC5hYnMoYy55KSwgeyBvcmlnaW5hbDogYiB9ID0gdCwgUyA9IG0gLyAoTWF0aC5hYnModS54ICogYi5zY2FsZVggLyBuLnNjYWxlWCkgKyBNYXRoLmFicyh1LnkgKiBiLnNjYWxlWSAvIG4uc2NhbGVZKSk7XG4gICAgICBsID0gYi5zY2FsZVggKiBTLCBoID0gYi5zY2FsZVkgKiBTO1xuICAgIH0gZWxzZSBsID0gTWF0aC5hYnMoYy54ICogbi5zY2FsZVggLyB1LngpLCBoID0gTWF0aC5hYnMoYy55ICogbi5zY2FsZVkgLyB1LnkpO1xuICAgIGljKHQpICYmIChsICo9IDIsIGggKj0gMiksIHQuc2lnblggIT09IGQgJiYgbyAhPT0gXCJ5XCIgJiYgKHQub3JpZ2luWCA9IHhvKHQub3JpZ2luWCksIGwgKj0gLTEsIHQuc2lnblggPSBkKSwgdC5zaWduWSAhPT0gZiAmJiBvICE9PSBcInhcIiAmJiAodC5vcmlnaW5ZID0geG8odC5vcmlnaW5ZKSwgaCAqPSAtMSwgdC5zaWduWSA9IGYpO1xuICB9XG4gIGNvbnN0IGcgPSBuLnNjYWxlWCwgcCA9IG4uc2NhbGVZO1xuICByZXR1cm4gbyA/IChvID09PSBcInhcIiAmJiBuLnNldCh1dCwgbCksIG8gPT09IFwieVwiICYmIG4uc2V0KFR0LCBoKSkgOiAoIVJ0KG4sIFwibG9ja1NjYWxpbmdYXCIpICYmIG4uc2V0KHV0LCBsKSwgIVJ0KG4sIFwibG9ja1NjYWxpbmdZXCIpICYmIG4uc2V0KFR0LCBoKSksIGcgIT09IG4uc2NhbGVYIHx8IHAgIT09IG4uc2NhbGVZO1xufVxuY29uc3QgTHMgPSBJZShnaSwgR2UoKGksIHQsIGUsIHMpID0+ICRuKGksIHQsIGUsIHMpKSksIGJjID0gSWUoZ2ksIEdlKChpLCB0LCBlLCBzKSA9PiAkbihpLCB0LCBlLCBzLCB7IGJ5OiBcInhcIiB9KSkpLCBfYyA9IEllKGdpLCBHZSgoaSwgdCwgZSwgcykgPT4gJG4oaSwgdCwgZSwgcywgeyBieTogXCJ5XCIgfSkpKSwgdXUgPSBbXCJ0YXJnZXRcIiwgXCJleFwiLCBcImV5XCIsIFwic2tld2luZ1NpZGVcIl0sIEhpID0geyB4OiB7IGNvdW50ZXJBeGlzOiBcInlcIiwgc2NhbGU6IHV0LCBza2V3OiBPcywgbG9ja1NrZXdpbmc6IFwibG9ja1NrZXdpbmdYXCIsIG9yaWdpbjogXCJvcmlnaW5YXCIsIGZsaXA6IFwiZmxpcFhcIiB9LCB5OiB7IGNvdW50ZXJBeGlzOiBcInhcIiwgc2NhbGU6IFR0LCBza2V3OiBrcywgbG9ja1NrZXdpbmc6IFwibG9ja1NrZXdpbmdZXCIsIG9yaWdpbjogXCJvcmlnaW5ZXCIsIGZsaXA6IFwiZmxpcFlcIiB9IH0sIGR1ID0gW1wibnNcIiwgXCJuZXN3XCIsIFwiZXdcIiwgXCJud3NlXCJdLCBTYyA9IChpLCB0LCBlKSA9PiB7XG4gIGlmICh0LnggIT09IDAgJiYgUnQoZSwgXCJsb2NrU2tld2luZ1lcIikgfHwgdC55ICE9PSAwICYmIFJ0KGUsIFwibG9ja1NrZXdpbmdYXCIpKSByZXR1cm4gSnI7XG4gIGNvbnN0IHMgPSBuYyhlLCB0KSAlIDQ7XG4gIHJldHVybiBcIlwiLmNvbmNhdChkdVtzXSwgXCItcmVzaXplXCIpO1xufTtcbmZ1bmN0aW9uIFRjKGksIHQsIGUsIHMsIHIpIHtcbiAgY29uc3QgeyB0YXJnZXQ6IG4gfSA9IGUsIHsgY291bnRlckF4aXM6IG8sIG9yaWdpbjogYSwgbG9ja1NrZXdpbmc6IGMsIHNrZXc6IGwsIGZsaXA6IGggfSA9IEhpW2ldO1xuICBpZiAoUnQobiwgYykpIHJldHVybiAhMTtcbiAgY29uc3QgeyBvcmlnaW46IHUsIGZsaXA6IGQgfSA9IEhpW29dLCBmID0gc3QoZVt1XSkgKiAobltkXSA/IC0xIDogMSksIGcgPSAtTWF0aC5zaWduKGYpICogKG5baF0gPyAtMSA6IDEpLCBwID0gMC41ICogLSgobltsXSA9PT0gMCAmJiBiaShlLCBqLCBqLCBzLCByKVtpXSA+IDAgfHwgbltsXSA+IDAgPyAxIDogLTEpICogZykgKyAwLjU7XG4gIHJldHVybiBJZShXYSwgR2UoKGIsIFMsIHcsIGspID0+IGZ1bmN0aW9uKE8sIHgsIEkpIHtcbiAgICBsZXQgeyB0YXJnZXQ6IE0sIGV4OiBFLCBleTogUiwgc2tld2luZ1NpZGU6IHR0IH0gPSB4LCBGID0gRyh4LCB1dSk7XG4gICAgY29uc3QgeyBza2V3OiBCIH0gPSBIaVtPXSwgJCA9IEkuc3VidHJhY3QobmV3IF8oRSwgUikpLmRpdmlkZShuZXcgXyhNLnNjYWxlWCwgTS5zY2FsZVkpKVtPXSwgeXQgPSBNW0JdLCBkdCA9IEZbQl0sIER0ID0gTWF0aC50YW4oSyhkdCkpLCBxID0gTyA9PT0gXCJ5XCIgPyBNLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoeyBzY2FsZVg6IDEsIHNjYWxlWTogMSwgc2tld1g6IDAgfSkueCA6IE0uX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucyh7IHNjYWxlWDogMSwgc2NhbGVZOiAxIH0pLnksIHp0ID0gMiAqICQgKiB0dCAvIE1hdGgubWF4KHEsIDEpICsgRHQsIHRlID0gQ2UoTWF0aC5hdGFuKHp0KSk7XG4gICAgTS5zZXQoQiwgdGUpO1xuICAgIGNvbnN0IHByID0geXQgIT09IE1bQl07XG4gICAgaWYgKHByICYmIE8gPT09IFwieVwiKSB7XG4gICAgICBjb25zdCB7IHNrZXdYOiBBaSwgc2NhbGVYOiBQcyB9ID0gTSwgbWUgPSBNLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoeyBza2V3WTogeXQgfSksIG1yID0gTS5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCksIGplID0gQWkgIT09IDAgPyBtZS54IC8gbXIueCA6IDE7XG4gICAgICBqZSAhPT0gMSAmJiBNLnNldCh1dCwgamUgKiBQcyk7XG4gICAgfVxuICAgIHJldHVybiBwcjtcbiAgfShpLCBTLCBuZXcgXyh3LCBrKSkpKSh0LCB2KHYoe30sIGUpLCB7fSwgeyBbYV06IHAsIHNrZXdpbmdTaWRlOiBnIH0pLCBzLCByKTtcbn1cbmNvbnN0IHhjID0gKGksIHQsIGUsIHMpID0+IFRjKFwieFwiLCBpLCB0LCBlLCBzKSwgd2MgPSAoaSwgdCwgZSwgcykgPT4gVGMoXCJ5XCIsIGksIHQsIGUsIHMpO1xuZnVuY3Rpb24gVGkoaSwgdCkge1xuICByZXR1cm4gaVt0LmNhbnZhcy5hbHRBY3Rpb25LZXldO1xufVxuY29uc3QgQnMgPSAoaSwgdCwgZSkgPT4ge1xuICBjb25zdCBzID0gVGkoaSwgZSk7XG4gIHJldHVybiB0LnggPT09IDAgPyBzID8gT3MgOiBUdCA6IHQueSA9PT0gMCA/IHMgPyBrcyA6IHV0IDogXCJcIjtcbn0sIEZlID0gKGksIHQsIGUpID0+IFRpKGksIGUpID8gU2MoMCwgdCwgZSkgOiBaZShpLCB0LCBlKSwgdW4gPSAoaSwgdCwgZSwgcykgPT4gVGkoaSwgdC50YXJnZXQpID8gd2MoaSwgdCwgZSwgcykgOiBiYyhpLCB0LCBlLCBzKSwgZG4gPSAoaSwgdCwgZSwgcykgPT4gVGkoaSwgdC50YXJnZXQpID8geGMoaSwgdCwgZSwgcykgOiBfYyhpLCB0LCBlLCBzKSwgcW4gPSAoKSA9PiAoeyBtbDogbmV3IFUoeyB4OiAtMC41LCB5OiAwLCBjdXJzb3JTdHlsZUhhbmRsZXI6IEZlLCBhY3Rpb25IYW5kbGVyOiB1biwgZ2V0QWN0aW9uTmFtZTogQnMgfSksIG1yOiBuZXcgVSh7IHg6IDAuNSwgeTogMCwgY3Vyc29yU3R5bGVIYW5kbGVyOiBGZSwgYWN0aW9uSGFuZGxlcjogdW4sIGdldEFjdGlvbk5hbWU6IEJzIH0pLCBtYjogbmV3IFUoeyB4OiAwLCB5OiAwLjUsIGN1cnNvclN0eWxlSGFuZGxlcjogRmUsIGFjdGlvbkhhbmRsZXI6IGRuLCBnZXRBY3Rpb25OYW1lOiBCcyB9KSwgbXQ6IG5ldyBVKHsgeDogMCwgeTogLTAuNSwgY3Vyc29yU3R5bGVIYW5kbGVyOiBGZSwgYWN0aW9uSGFuZGxlcjogZG4sIGdldEFjdGlvbk5hbWU6IEJzIH0pLCB0bDogbmV3IFUoeyB4OiAtMC41LCB5OiAtMC41LCBjdXJzb3JTdHlsZUhhbmRsZXI6IFplLCBhY3Rpb25IYW5kbGVyOiBMcyB9KSwgdHI6IG5ldyBVKHsgeDogMC41LCB5OiAtMC41LCBjdXJzb3JTdHlsZUhhbmRsZXI6IFplLCBhY3Rpb25IYW5kbGVyOiBMcyB9KSwgYmw6IG5ldyBVKHsgeDogLTAuNSwgeTogMC41LCBjdXJzb3JTdHlsZUhhbmRsZXI6IFplLCBhY3Rpb25IYW5kbGVyOiBMcyB9KSwgYnI6IG5ldyBVKHsgeDogMC41LCB5OiAwLjUsIGN1cnNvclN0eWxlSGFuZGxlcjogWmUsIGFjdGlvbkhhbmRsZXI6IExzIH0pLCBtdHI6IG5ldyBVKHsgeDogMCwgeTogLTAuNSwgYWN0aW9uSGFuZGxlcjogbWMsIGN1cnNvclN0eWxlSGFuZGxlcjogcGMsIG9mZnNldFk6IC00MCwgd2l0aENvbm5lY3Rpb246ICEwLCBhY3Rpb25OYW1lOiBBbiB9KSB9KSwgQ2MgPSAoKSA9PiAoeyBtcjogbmV3IFUoeyB4OiAwLjUsIHk6IDAsIGFjdGlvbkhhbmRsZXI6IGhuLCBjdXJzb3JTdHlsZUhhbmRsZXI6IEZlLCBhY3Rpb25OYW1lOiAkcyB9KSwgbWw6IG5ldyBVKHsgeDogLTAuNSwgeTogMCwgYWN0aW9uSGFuZGxlcjogaG4sIGN1cnNvclN0eWxlSGFuZGxlcjogRmUsIGFjdGlvbk5hbWU6ICRzIH0pIH0pLCBPYyA9ICgpID0+IHYodih7fSwgcW4oKSksIENjKCkpO1xuY2xhc3MgSnMgZXh0ZW5kcyBlZSB7XG4gIHN0YXRpYyBnZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4gdih2KHt9LCBzdXBlci5nZXREZWZhdWx0cygpKSwgSnMub3duRGVmYXVsdHMpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpLCBPYmplY3QuYXNzaWduKHRoaXMsIHRoaXMuY29uc3RydWN0b3IuY3JlYXRlQ29udHJvbHMoKSwgSnMub3duRGVmYXVsdHMpLCB0aGlzLnNldE9wdGlvbnModCk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUNvbnRyb2xzKCkge1xuICAgIHJldHVybiB7IGNvbnRyb2xzOiBxbigpIH07XG4gIH1cbiAgX3VwZGF0ZUNhY2hlQ2FudmFzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNhbnZhcztcbiAgICBpZiAodGhpcy5ub1NjYWxlQ2FjaGUgJiYgdCAmJiB0Ll9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCBlID0gdC5fY3VycmVudFRyYW5zZm9ybSwgcyA9IGUudGFyZ2V0LCByID0gZS5hY3Rpb247XG4gICAgICBpZiAodGhpcyA9PT0gcyAmJiByICYmIHIuc3RhcnRzV2l0aChwaSkpIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLl91cGRhdGVDYWNoZUNhbnZhcygpO1xuICB9XG4gIGdldEFjdGl2ZUNvbnRyb2woKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX19jb3JuZXI7XG4gICAgcmV0dXJuIHQgPyB7IGtleTogdCwgY29udHJvbDogdGhpcy5jb250cm9sc1t0XSwgY29vcmQ6IHRoaXMub0Nvb3Jkc1t0XSB9IDogdm9pZCAwO1xuICB9XG4gIGZpbmRDb250cm9sKHQpIHtcbiAgICBsZXQgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwICYmIGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoIXRoaXMuaGFzQ29udHJvbHMgfHwgIXRoaXMuY2FudmFzKSByZXR1cm47XG4gICAgdGhpcy5fX2Nvcm5lciA9IHZvaWQgMDtcbiAgICBjb25zdCBzID0gT2JqZWN0LmVudHJpZXModGhpcy5vQ29vcmRzKTtcbiAgICBmb3IgKGxldCByID0gcy5sZW5ndGggLSAxOyByID49IDA7IHItLSkge1xuICAgICAgY29uc3QgW24sIG9dID0gc1tyXSwgYSA9IHRoaXMuY29udHJvbHNbbl07XG4gICAgICBpZiAoYS5zaG91bGRBY3RpdmF0ZShuLCB0aGlzLCB0LCBlID8gby50b3VjaENvcm5lciA6IG8uY29ybmVyKSkgcmV0dXJuIHRoaXMuX19jb3JuZXIgPSBuLCB7IGtleTogbiwgY29udHJvbDogYSwgY29vcmQ6IHRoaXMub0Nvb3Jkc1tuXSB9O1xuICAgIH1cbiAgfVxuICBjYWxjT0Nvb3JkcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLCBlID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpLCBzID0gTXMoZS54LCBlLnkpLCByID0gSXMoeyBhbmdsZTogdGhpcy5nZXRUb3RhbEFuZ2xlKCkgLSAodGhpcy5ncm91cCAmJiB0aGlzLmZsaXBYID8gMTgwIDogMCkgfSksIG4gPSBKKHMsIHIpLCBvID0gSih0LCBuKSwgYSA9IEoobywgWzEgLyB0WzBdLCAwLCAwLCAxIC8gdFszXSwgMCwgMF0pLCBjID0gdGhpcy5ncm91cCA/IHlzKHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKSA6IHZvaWQgMDtcbiAgICBjICYmIChjLnNjYWxlWCA9IE1hdGguYWJzKGMuc2NhbGVYKSwgYy5zY2FsZVkgPSBNYXRoLmFicyhjLnNjYWxlWSkpO1xuICAgIGNvbnN0IGwgPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucyhjKSwgaCA9IHt9O1xuICAgIHJldHVybiB0aGlzLmZvckVhY2hDb250cm9sKCh1LCBkKSA9PiB7XG4gICAgICBjb25zdCBmID0gdS5wb3NpdGlvbkhhbmRsZXIobCwgYSwgdGhpcywgdSk7XG4gICAgICBoW2RdID0gT2JqZWN0LmFzc2lnbihmLCB0aGlzLl9jYWxjQ29ybmVyQ29vcmRzKHUsIGYpKTtcbiAgICB9KSwgaDtcbiAgfVxuICBfY2FsY0Nvcm5lckNvb3Jkcyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0VG90YWxBbmdsZSgpO1xuICAgIHJldHVybiB7IGNvcm5lcjogdC5jYWxjQ29ybmVyQ29vcmRzKHMsIHRoaXMuY29ybmVyU2l6ZSwgZS54LCBlLnksICExLCB0aGlzKSwgdG91Y2hDb3JuZXI6IHQuY2FsY0Nvcm5lckNvb3JkcyhzLCB0aGlzLnRvdWNoQ29ybmVyU2l6ZSwgZS54LCBlLnksICEwLCB0aGlzKSB9O1xuICB9XG4gIHNldENvb3JkcygpIHtcbiAgICBzdXBlci5zZXRDb29yZHMoKSwgdGhpcy5jYW52YXMgJiYgKHRoaXMub0Nvb3JkcyA9IHRoaXMuY2FsY09Db29yZHMoKSk7XG4gIH1cbiAgZm9yRWFjaENvbnRyb2wodCkge1xuICAgIGZvciAoY29uc3QgZSBpbiB0aGlzLmNvbnRyb2xzKSB0KHRoaXMuY29udHJvbHNbZV0sIGUsIHRoaXMpO1xuICB9XG4gIGRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kKHQpIHtcbiAgICBpZiAoIXRoaXMuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yIHx8IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpIHJldHVybjtcbiAgICB0LnNhdmUoKTtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRSZWxhdGl2ZUNlbnRlclBvaW50KCksIHMgPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLCByID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpO1xuICAgIHQudHJhbnNsYXRlKGUueCwgZS55KSwgdC5zY2FsZSgxIC8gclswXSwgMSAvIHJbM10pLCB0LnJvdGF0ZShLKHRoaXMuYW5nbGUpKSwgdC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciwgdC5maWxsUmVjdCgtcy54IC8gMiwgLXMueSAvIDIsIHMueCwgcy55KSwgdC5yZXN0b3JlKCk7XG4gIH1cbiAgc3Ryb2tlQm9yZGVycyh0LCBlKSB7XG4gICAgdC5zdHJva2VSZWN0KC1lLnggLyAyLCAtZS55IC8gMiwgZS54LCBlLnkpO1xuICB9XG4gIF9kcmF3Qm9yZGVycyh0LCBlKSB7XG4gICAgbGV0IHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNvbnN0IHIgPSB2KHsgaGFzQ29udHJvbHM6IHRoaXMuaGFzQ29udHJvbHMsIGJvcmRlckNvbG9yOiB0aGlzLmJvcmRlckNvbG9yLCBib3JkZXJEYXNoQXJyYXk6IHRoaXMuYm9yZGVyRGFzaEFycmF5IH0sIHMpO1xuICAgIHQuc2F2ZSgpLCB0LnN0cm9rZVN0eWxlID0gci5ib3JkZXJDb2xvciwgdGhpcy5fc2V0TGluZURhc2godCwgci5ib3JkZXJEYXNoQXJyYXkpLCB0aGlzLnN0cm9rZUJvcmRlcnModCwgZSksIHIuaGFzQ29udHJvbHMgJiYgdGhpcy5kcmF3Q29udHJvbHNDb25uZWN0aW5nTGluZXModCwgZSksIHQucmVzdG9yZSgpO1xuICB9XG4gIF9yZW5kZXJDb250cm9scyh0KSB7XG4gICAgbGV0IGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IHsgaGFzQm9yZGVyczogcywgaGFzQ29udHJvbHM6IHIgfSA9IHRoaXMsIG4gPSB2KHsgaGFzQm9yZGVyczogcywgaGFzQ29udHJvbHM6IHIgfSwgZSksIG8gPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksIGEgPSBuLmhhc0JvcmRlcnMsIGMgPSBuLmhhc0NvbnRyb2xzLCBsID0gSihvLCB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSksIGggPSB5cyhsKTtcbiAgICB0LnNhdmUoKSwgdC50cmFuc2xhdGUoaC50cmFuc2xhdGVYLCBoLnRyYW5zbGF0ZVkpLCB0LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyU2NhbGVGYWN0b3IsIHRoaXMuZ3JvdXAgPT09IHRoaXMucGFyZW50ICYmICh0Lmdsb2JhbEFscGhhID0gdGhpcy5pc01vdmluZyA/IHRoaXMuYm9yZGVyT3BhY2l0eVdoZW5Nb3ZpbmcgOiAxKSwgdGhpcy5mbGlwWCAmJiAoaC5hbmdsZSAtPSAxODApLCB0LnJvdGF0ZShLKHRoaXMuZ3JvdXAgPyBoLmFuZ2xlIDogdGhpcy5hbmdsZSkpLCBhICYmIHRoaXMuZHJhd0JvcmRlcnModCwgaCwgZSksIGMgJiYgdGhpcy5kcmF3Q29udHJvbHModCwgZSksIHQucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdCb3JkZXJzKHQsIGUsIHMpIHtcbiAgICBsZXQgcjtcbiAgICBpZiAocyAmJiBzLmZvckFjdGl2ZVNlbGVjdGlvbiB8fCB0aGlzLmdyb3VwKSB7XG4gICAgICBjb25zdCBuID0geWkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGFyKGUpKSwgbyA9IHRoaXMuaXNTdHJva2VBY2NvdW50ZWRGb3JJbkRpbWVuc2lvbnMoKSA/IEZuIDogKHRoaXMuc3Ryb2tlVW5pZm9ybSA/IG5ldyBfKCkuc2NhbGFyQWRkKHRoaXMuY2FudmFzID8gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpIDogMSkgOiBuZXcgXyhlLnNjYWxlWCwgZS5zY2FsZVkpKS5zY2FsYXJNdWx0aXBseSh0aGlzLnN0cm9rZVdpZHRoKTtcbiAgICAgIHIgPSBuLmFkZChvKS5zY2FsYXJBZGQodGhpcy5ib3JkZXJTY2FsZUZhY3Rvcikuc2NhbGFyQWRkKDIgKiB0aGlzLnBhZGRpbmcpO1xuICAgIH0gZWxzZSByID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKS5zY2FsYXJBZGQodGhpcy5ib3JkZXJTY2FsZUZhY3Rvcik7XG4gICAgdGhpcy5fZHJhd0JvcmRlcnModCwgciwgcyk7XG4gIH1cbiAgZHJhd0NvbnRyb2xzQ29ubmVjdGluZ0xpbmVzKHQsIGUpIHtcbiAgICBsZXQgcyA9ICExO1xuICAgIHQuYmVnaW5QYXRoKCksIHRoaXMuZm9yRWFjaENvbnRyb2woKHIsIG4pID0+IHtcbiAgICAgIHIud2l0aENvbm5lY3Rpb24gJiYgci5nZXRWaXNpYmlsaXR5KHRoaXMsIG4pICYmIChzID0gITAsIHQubW92ZVRvKHIueCAqIGUueCwgci55ICogZS55KSwgdC5saW5lVG8oci54ICogZS54ICsgci5vZmZzZXRYLCByLnkgKiBlLnkgKyByLm9mZnNldFkpKTtcbiAgICB9KSwgcyAmJiB0LnN0cm9rZSgpO1xuICB9XG4gIGRyYXdDb250cm9scyh0KSB7XG4gICAgbGV0IGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHQuc2F2ZSgpO1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldENhbnZhc1JldGluYVNjYWxpbmcoKSwgeyBjb3JuZXJTdHJva2VDb2xvcjogciwgY29ybmVyRGFzaEFycmF5OiBuLCBjb3JuZXJDb2xvcjogbyB9ID0gdGhpcywgYSA9IHYoeyBjb3JuZXJTdHJva2VDb2xvcjogciwgY29ybmVyRGFzaEFycmF5OiBuLCBjb3JuZXJDb2xvcjogbyB9LCBlKTtcbiAgICB0LnNldFRyYW5zZm9ybShzLCAwLCAwLCBzLCAwLCAwKSwgdC5zdHJva2VTdHlsZSA9IHQuZmlsbFN0eWxlID0gYS5jb3JuZXJDb2xvciwgdGhpcy50cmFuc3BhcmVudENvcm5lcnMgfHwgKHQuc3Ryb2tlU3R5bGUgPSBhLmNvcm5lclN0cm9rZUNvbG9yKSwgdGhpcy5fc2V0TGluZURhc2godCwgYS5jb3JuZXJEYXNoQXJyYXkpLCB0aGlzLmZvckVhY2hDb250cm9sKChjLCBsKSA9PiB7XG4gICAgICBpZiAoYy5nZXRWaXNpYmlsaXR5KHRoaXMsIGwpKSB7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLm9Db29yZHNbbF07XG4gICAgICAgIGMucmVuZGVyKHQsIGgueCwgaC55LCBhLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9KSwgdC5yZXN0b3JlKCk7XG4gIH1cbiAgaXNDb250cm9sVmlzaWJsZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbHNbdF0gJiYgdGhpcy5jb250cm9sc1t0XS5nZXRWaXNpYmlsaXR5KHRoaXMsIHQpO1xuICB9XG4gIHNldENvbnRyb2xWaXNpYmxlKHQsIGUpIHtcbiAgICB0aGlzLl9jb250cm9sc1Zpc2liaWxpdHkgfHwgKHRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eSA9IHt9KSwgdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5W3RdID0gZTtcbiAgfVxuICBzZXRDb250cm9sc1Zpc2liaWxpdHkoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGxldCBbcywgcl0gPSBlO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q29udHJvbFZpc2libGUocywgcik7XG4gICAgfSk7XG4gIH1cbiAgY2xlYXJDb250ZXh0VG9wKHQpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzKSByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgaWYgKCFlKSByZXR1cm47XG4gICAgY29uc3QgcyA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgIGUuc2F2ZSgpLCBlLnRyYW5zZm9ybShzWzBdLCBzWzFdLCBzWzJdLCBzWzNdLCBzWzRdLCBzWzVdKSwgdGhpcy50cmFuc2Zvcm0oZSk7XG4gICAgY29uc3QgciA9IHRoaXMud2lkdGggKyA0LCBuID0gdGhpcy5oZWlnaHQgKyA0O1xuICAgIHJldHVybiBlLmNsZWFyUmVjdCgtciAvIDIsIC1uIC8gMiwgciwgbiksIHQgfHwgZS5yZXN0b3JlKCksIGU7XG4gIH1cbiAgb25EZXNlbGVjdCh0KSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIG9uU2VsZWN0KHQpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgc2hvdWxkU3RhcnREcmFnZ2luZyh0KSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIG9uRHJhZ1N0YXJ0KHQpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgY2FuRHJvcCh0KSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJlbmRlckRyYWdTb3VyY2VFZmZlY3QodCkge1xuICB9XG4gIHJlbmRlckRyb3BUYXJnZXRFZmZlY3QodCkge1xuICB9XG59XG5mdW5jdGlvbiBrYyhpLCB0KSB7XG4gIHJldHVybiB0LmZvckVhY2goKGUpID0+IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlLnByb3RvdHlwZSkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgcyAhPT0gXCJjb25zdHJ1Y3RvclwiICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLnByb3RvdHlwZSwgcywgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLnByb3RvdHlwZSwgcykgfHwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH0pO1xuICB9KSwgaTtcbn1cbnkoSnMsIFwib3duRGVmYXVsdHNcIiwgeyBub1NjYWxlQ2FjaGU6ICEwLCBsb2NrTW92ZW1lbnRYOiAhMSwgbG9ja01vdmVtZW50WTogITEsIGxvY2tSb3RhdGlvbjogITEsIGxvY2tTY2FsaW5nWDogITEsIGxvY2tTY2FsaW5nWTogITEsIGxvY2tTa2V3aW5nWDogITEsIGxvY2tTa2V3aW5nWTogITEsIGxvY2tTY2FsaW5nRmxpcDogITEsIGNvcm5lclNpemU6IDEzLCB0b3VjaENvcm5lclNpemU6IDI0LCB0cmFuc3BhcmVudENvcm5lcnM6ICEwLCBjb3JuZXJDb2xvcjogXCJyZ2IoMTc4LDIwNCwyNTUpXCIsIGNvcm5lclN0cm9rZUNvbG9yOiBcIlwiLCBjb3JuZXJTdHlsZTogXCJyZWN0XCIsIGNvcm5lckRhc2hBcnJheTogbnVsbCwgaGFzQ29udHJvbHM6ICEwLCBib3JkZXJDb2xvcjogXCJyZ2IoMTc4LDIwNCwyNTUpXCIsIGJvcmRlckRhc2hBcnJheTogbnVsbCwgYm9yZGVyT3BhY2l0eVdoZW5Nb3Zpbmc6IDAuNCwgYm9yZGVyU2NhbGVGYWN0b3I6IDEsIGhhc0JvcmRlcnM6ICEwLCBzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I6IFwiXCIsIHNlbGVjdGFibGU6ICEwLCBldmVudGVkOiAhMCwgcGVyUGl4ZWxUYXJnZXRGaW5kOiAhMSwgYWN0aXZlT246IFwiZG93blwiLCBob3ZlckN1cnNvcjogbnVsbCwgbW92ZUN1cnNvcjogbnVsbCB9KTtcbmNsYXNzIG50IGV4dGVuZHMgSnMge1xufVxua2MobnQsIFthY10pLCBDLnNldENsYXNzKG50KSwgQy5zZXRDbGFzcyhudCwgXCJvYmplY3RcIik7XG5jb25zdCBNYyA9IChpLCB0LCBlLCBzKSA9PiB7XG4gIGNvbnN0IHIgPSAyICogKHMgPSBNYXRoLnJvdW5kKHMpKSArIDEsIHsgZGF0YTogbiB9ID0gaS5nZXRJbWFnZURhdGEodCAtIHMsIGUgLSBzLCByLCByKTtcbiAgZm9yIChsZXQgbyA9IDM7IG8gPCBuLmxlbmd0aDsgbyArPSA0KVxuICAgIGlmIChuW29dID4gMCkgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59O1xuY2xhc3MgSWMge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5vcHRpb25zID0gdCwgdGhpcy5zdHJva2VQcm9qZWN0aW9uTWFnbml0dWRlID0gdGhpcy5vcHRpb25zLnN0cm9rZVdpZHRoIC8gMiwgdGhpcy5zY2FsZSA9IG5ldyBfKHRoaXMub3B0aW9ucy5zY2FsZVgsIHRoaXMub3B0aW9ucy5zY2FsZVkpLCB0aGlzLnN0cm9rZVVuaWZvcm1TY2FsYXIgPSB0aGlzLm9wdGlvbnMuc3Ryb2tlVW5pZm9ybSA/IG5ldyBfKDEgLyB0aGlzLm9wdGlvbnMuc2NhbGVYLCAxIC8gdGhpcy5vcHRpb25zLnNjYWxlWSkgOiBuZXcgXygxLCAxKTtcbiAgfVxuICBjcmVhdGVTaWRlVmVjdG9yKHQsIGUpIHtcbiAgICBjb25zdCBzID0gWnIodCwgZSk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdHJva2VVbmlmb3JtID8gcy5tdWx0aXBseSh0aGlzLnNjYWxlKSA6IHM7XG4gIH1cbiAgcHJvamVjdE9ydGhvZ29uYWxseSh0LCBlLCBzKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTa2V3KHQuYWRkKHRoaXMuY2FsY09ydGhvZ29uYWxQcm9qZWN0aW9uKHQsIGUsIHMpKSk7XG4gIH1cbiAgaXNTa2V3ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5za2V3WCAhPT0gMCB8fCB0aGlzLm9wdGlvbnMuc2tld1kgIT09IDA7XG4gIH1cbiAgYXBwbHlTa2V3KHQpIHtcbiAgICBjb25zdCBlID0gbmV3IF8odCk7XG4gICAgcmV0dXJuIGUueSArPSBlLnggKiBNYXRoLnRhbihLKHRoaXMub3B0aW9ucy5za2V3WSkpLCBlLnggKz0gZS55ICogTWF0aC50YW4oSyh0aGlzLm9wdGlvbnMuc2tld1gpKSwgZTtcbiAgfVxuICBzY2FsZVVuaXRWZWN0b3IodCwgZSkge1xuICAgIHJldHVybiB0Lm11bHRpcGx5KHRoaXMuc3Ryb2tlVW5pZm9ybVNjYWxhcikuc2NhbGFyTXVsdGlwbHkoZSk7XG4gIH1cbn1cbmNvbnN0IGZ1ID0gbmV3IF8oKTtcbmNsYXNzIG1zIGV4dGVuZHMgSWMge1xuICBzdGF0aWMgZ2V0T3J0aG9nb25hbFJvdGF0aW9uRmFjdG9yKHQsIGUpIHtcbiAgICBjb25zdCBzID0gZSA/IHRpKHQsIGUpIDogbGModCk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHMpIDwgeGUgPyAtMSA6IDE7XG4gIH1cbiAgY29uc3RydWN0b3IodCwgZSwgcywgcikge1xuICAgIHN1cGVyKHIpLCB5KHRoaXMsIFwiQUJcIiwgdm9pZCAwKSwgeSh0aGlzLCBcIkFDXCIsIHZvaWQgMCksIHkodGhpcywgXCJhbHBoYVwiLCB2b2lkIDApLCB5KHRoaXMsIFwiYmlzZWN0b3JcIiwgdm9pZCAwKSwgdGhpcy5BID0gbmV3IF8odCksIHRoaXMuQiA9IG5ldyBfKGUpLCB0aGlzLkMgPSBuZXcgXyhzKSwgdGhpcy5BQiA9IHRoaXMuY3JlYXRlU2lkZVZlY3Rvcih0aGlzLkEsIHRoaXMuQiksIHRoaXMuQUMgPSB0aGlzLmNyZWF0ZVNpZGVWZWN0b3IodGhpcy5BLCB0aGlzLkMpLCB0aGlzLmFscGhhID0gdGkodGhpcy5BQiwgdGhpcy5BQyksIHRoaXMuYmlzZWN0b3IgPSBTaShWbih0aGlzLkFCLmVxKGZ1KSA/IHRoaXMuQUMgOiB0aGlzLkFCLCB0aGlzLmFscGhhIC8gMikpO1xuICB9XG4gIGNhbGNPcnRob2dvbmFsUHJvamVjdGlvbih0LCBlKSB7XG4gICAgbGV0IHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuc3Ryb2tlUHJvamVjdGlvbk1hZ25pdHVkZTtcbiAgICBjb25zdCByID0gdGhpcy5jcmVhdGVTaWRlVmVjdG9yKHQsIGUpLCBuID0gR24ociksIG8gPSBtcy5nZXRPcnRob2dvbmFsUm90YXRpb25GYWN0b3IobiwgdGhpcy5iaXNlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVVbml0VmVjdG9yKG4sIHMgKiBvKTtcbiAgfVxuICBwcm9qZWN0QmV2ZWwoKSB7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIHJldHVybiAodGhpcy5hbHBoYSAlIGhlID09IDAgPyBbdGhpcy5CXSA6IFt0aGlzLkIsIHRoaXMuQ10pLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHQucHVzaCh0aGlzLnByb2plY3RPcnRob2dvbmFsbHkodGhpcy5BLCBlKSksIHQucHVzaCh0aGlzLnByb2plY3RPcnRob2dvbmFsbHkodGhpcy5BLCBlLCAtdGhpcy5zdHJva2VQcm9qZWN0aW9uTWFnbml0dWRlKSk7XG4gICAgfSksIHQ7XG4gIH1cbiAgcHJvamVjdE1pdGVyKCkge1xuICAgIGNvbnN0IHQgPSBbXSwgZSA9IE1hdGguYWJzKHRoaXMuYWxwaGEpLCBzID0gMSAvIE1hdGguc2luKGUgLyAyKSwgciA9IHRoaXMuc2NhbGVVbml0VmVjdG9yKHRoaXMuYmlzZWN0b3IsIC10aGlzLnN0cm9rZVByb2plY3Rpb25NYWduaXR1ZGUgKiBzKSwgbiA9IHRoaXMub3B0aW9ucy5zdHJva2VVbmlmb3JtID8gUXIodGhpcy5zY2FsZVVuaXRWZWN0b3IodGhpcy5iaXNlY3RvciwgdGhpcy5vcHRpb25zLnN0cm9rZU1pdGVyTGltaXQpKSA6IHRoaXMub3B0aW9ucy5zdHJva2VNaXRlckxpbWl0O1xuICAgIHJldHVybiBRcihyKSAvIHRoaXMuc3Ryb2tlUHJvamVjdGlvbk1hZ25pdHVkZSA8PSBuICYmIHQucHVzaCh0aGlzLmFwcGx5U2tldyh0aGlzLkEuYWRkKHIpKSksIHQucHVzaCguLi50aGlzLnByb2plY3RCZXZlbCgpKSwgdDtcbiAgfVxuICBwcm9qZWN0Um91bmROb1NrZXcodCwgZSkge1xuICAgIGNvbnN0IHMgPSBbXSwgciA9IG5ldyBfKG1zLmdldE9ydGhvZ29uYWxSb3RhdGlvbkZhY3Rvcih0aGlzLmJpc2VjdG9yKSwgbXMuZ2V0T3J0aG9nb25hbFJvdGF0aW9uRmFjdG9yKG5ldyBfKHRoaXMuYmlzZWN0b3IueSwgdGhpcy5iaXNlY3Rvci54KSkpO1xuICAgIHJldHVybiBbbmV3IF8oMSwgMCkuc2NhbGFyTXVsdGlwbHkodGhpcy5zdHJva2VQcm9qZWN0aW9uTWFnbml0dWRlKS5tdWx0aXBseSh0aGlzLnN0cm9rZVVuaWZvcm1TY2FsYXIpLm11bHRpcGx5KHIpLCBuZXcgXygwLCAxKS5zY2FsYXJNdWx0aXBseSh0aGlzLnN0cm9rZVByb2plY3Rpb25NYWduaXR1ZGUpLm11bHRpcGx5KHRoaXMuc3Ryb2tlVW5pZm9ybVNjYWxhcikubXVsdGlwbHkocildLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGNuKG4sIHQsIGUpICYmIHMucHVzaCh0aGlzLkEuYWRkKG4pKTtcbiAgICB9KSwgcztcbiAgfVxuICBwcm9qZWN0Um91bmRXaXRoU2tldyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IFtdLCB7IHNrZXdYOiByLCBza2V3WTogbiwgc2NhbGVYOiBvLCBzY2FsZVk6IGEsIHN0cm9rZVVuaWZvcm06IGMgfSA9IHRoaXMub3B0aW9ucywgbCA9IG5ldyBfKE1hdGgudGFuKEsocikpLCBNYXRoLnRhbihLKG4pKSksIGggPSB0aGlzLnN0cm9rZVByb2plY3Rpb25NYWduaXR1ZGUsIHUgPSBjID8gaCAvIGEgLyBNYXRoLnNxcnQoMSAvIGEgKiogMiArIDEgLyBvICoqIDIgKiBsLnkgKiogMikgOiBoIC8gTWF0aC5zcXJ0KDEgKyBsLnkgKiogMiksIGQgPSBuZXcgXyhNYXRoLnNxcnQoTWF0aC5tYXgoaCAqKiAyIC0gdSAqKiAyLCAwKSksIHUpLCBmID0gYyA/IGggLyBNYXRoLnNxcnQoMSArIGwueCAqKiAyICogKDEgLyBhKSAqKiAyIC8gKDEgLyBvICsgMSAvIG8gKiBsLnggKiBsLnkpICoqIDIpIDogaCAvIE1hdGguc3FydCgxICsgbC54ICoqIDIgLyAoMSArIGwueCAqIGwueSkgKiogMiksIGcgPSBuZXcgXyhmLCBNYXRoLnNxcnQoTWF0aC5tYXgoaCAqKiAyIC0gZiAqKiAyLCAwKSkpO1xuICAgIHJldHVybiBbZywgZy5zY2FsYXJNdWx0aXBseSgtMSksIGQsIGQuc2NhbGFyTXVsdGlwbHkoLTEpXS5tYXAoKHApID0+IHRoaXMuYXBwbHlTa2V3KGMgPyBwLm11bHRpcGx5KHRoaXMuc3Ryb2tlVW5pZm9ybVNjYWxhcikgOiBwKSkuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgY24ocCwgdCwgZSkgJiYgcy5wdXNoKHRoaXMuYXBwbHlTa2V3KHRoaXMuQSkuYWRkKHApKTtcbiAgICB9KSwgcztcbiAgfVxuICBwcm9qZWN0Um91bmQoKSB7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIHQucHVzaCguLi50aGlzLnByb2plY3RCZXZlbCgpKTtcbiAgICBjb25zdCBlID0gdGhpcy5hbHBoYSAlIGhlID09IDAsIHMgPSB0aGlzLmFwcGx5U2tldyh0aGlzLkEpLCByID0gdFtlID8gMCA6IDJdLnN1YnRyYWN0KHMpLCBuID0gdFtlID8gMSA6IDBdLnN1YnRyYWN0KHMpLCBvID0gZSA/IHRoaXMuYXBwbHlTa2V3KHRoaXMuQUIuc2NhbGFyTXVsdGlwbHkoLTEpKSA6IHRoaXMuYXBwbHlTa2V3KHRoaXMuYmlzZWN0b3IubXVsdGlwbHkodGhpcy5zdHJva2VVbmlmb3JtU2NhbGFyKS5zY2FsYXJNdWx0aXBseSgtMSkpLCBhID0gcHMociwgbykgPiAwLCBjID0gYSA/IHIgOiBuLCBsID0gYSA/IG4gOiByO1xuICAgIHJldHVybiB0aGlzLmlzU2tld2VkKCkgPyB0LnB1c2goLi4udGhpcy5wcm9qZWN0Um91bmRXaXRoU2tldyhjLCBsKSkgOiB0LnB1c2goLi4udGhpcy5wcm9qZWN0Um91bmROb1NrZXcoYywgbCkpLCB0O1xuICB9XG4gIHByb2plY3RQb2ludHMoKSB7XG4gICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuc3Ryb2tlTGluZUpvaW4pIHtcbiAgICAgIGNhc2UgXCJtaXRlclwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0TWl0ZXIoKTtcbiAgICAgIGNhc2UgXCJyb3VuZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0Um91bmQoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3RCZXZlbCgpO1xuICAgIH1cbiAgfVxuICBwcm9qZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3RQb2ludHMoKS5tYXAoKHQpID0+ICh7IG9yaWdpblBvaW50OiB0aGlzLkEsIHByb2plY3RlZFBvaW50OiB0LCBhbmdsZTogdGhpcy5hbHBoYSwgYmlzZWN0b3I6IHRoaXMuYmlzZWN0b3IgfSkpO1xuICB9XG59XG5jbGFzcyBEbyBleHRlbmRzIEljIHtcbiAgY29uc3RydWN0b3IodCwgZSwgcykge1xuICAgIHN1cGVyKHMpLCB0aGlzLkEgPSBuZXcgXyh0KSwgdGhpcy5UID0gbmV3IF8oZSk7XG4gIH1cbiAgY2FsY09ydGhvZ29uYWxQcm9qZWN0aW9uKHQsIGUpIHtcbiAgICBsZXQgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogdGhpcy5zdHJva2VQcm9qZWN0aW9uTWFnbml0dWRlO1xuICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZVNpZGVWZWN0b3IodCwgZSk7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVVbml0VmVjdG9yKEduKHIpLCBzKTtcbiAgfVxuICBwcm9qZWN0QnV0dCgpIHtcbiAgICByZXR1cm4gW3RoaXMucHJvamVjdE9ydGhvZ29uYWxseSh0aGlzLkEsIHRoaXMuVCwgdGhpcy5zdHJva2VQcm9qZWN0aW9uTWFnbml0dWRlKSwgdGhpcy5wcm9qZWN0T3J0aG9nb25hbGx5KHRoaXMuQSwgdGhpcy5ULCAtdGhpcy5zdHJva2VQcm9qZWN0aW9uTWFnbml0dWRlKV07XG4gIH1cbiAgcHJvamVjdFJvdW5kKCkge1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuaXNTa2V3ZWQoKSAmJiB0aGlzLkEuZXEodGhpcy5UKSkge1xuICAgICAgY29uc3QgZSA9IG5ldyBfKDEsIDEpLnNjYWxhck11bHRpcGx5KHRoaXMuc3Ryb2tlUHJvamVjdGlvbk1hZ25pdHVkZSkubXVsdGlwbHkodGhpcy5zdHJva2VVbmlmb3JtU2NhbGFyKTtcbiAgICAgIHQucHVzaCh0aGlzLmFwcGx5U2tldyh0aGlzLkEuYWRkKGUpKSwgdGhpcy5hcHBseVNrZXcodGhpcy5BLnN1YnRyYWN0KGUpKSk7XG4gICAgfSBlbHNlIHQucHVzaCguLi5uZXcgbXModGhpcy5BLCB0aGlzLlQsIHRoaXMuVCwgdGhpcy5vcHRpb25zKS5wcm9qZWN0Um91bmQoKSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgcHJvamVjdFNxdWFyZSgpIHtcbiAgICBjb25zdCB0ID0gW107XG4gICAgaWYgKHRoaXMuQS5lcSh0aGlzLlQpKSB7XG4gICAgICBjb25zdCBlID0gbmV3IF8oMSwgMSkuc2NhbGFyTXVsdGlwbHkodGhpcy5zdHJva2VQcm9qZWN0aW9uTWFnbml0dWRlKS5tdWx0aXBseSh0aGlzLnN0cm9rZVVuaWZvcm1TY2FsYXIpO1xuICAgICAgdC5wdXNoKHRoaXMuQS5hZGQoZSksIHRoaXMuQS5zdWJ0cmFjdChlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmNhbGNPcnRob2dvbmFsUHJvamVjdGlvbih0aGlzLkEsIHRoaXMuVCwgdGhpcy5zdHJva2VQcm9qZWN0aW9uTWFnbml0dWRlKSwgcyA9IHRoaXMuc2NhbGVVbml0VmVjdG9yKFNpKHRoaXMuY3JlYXRlU2lkZVZlY3Rvcih0aGlzLkEsIHRoaXMuVCkpLCAtdGhpcy5zdHJva2VQcm9qZWN0aW9uTWFnbml0dWRlKSwgciA9IHRoaXMuQS5hZGQocyk7XG4gICAgICB0LnB1c2goci5hZGQoZSksIHIuc3VidHJhY3QoZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdC5tYXAoKGUpID0+IHRoaXMuYXBwbHlTa2V3KGUpKTtcbiAgfVxuICBwcm9qZWN0UG9pbnRzKCkge1xuICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnN0cm9rZUxpbmVDYXApIHtcbiAgICAgIGNhc2UgXCJyb3VuZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0Um91bmQoKTtcbiAgICAgIGNhc2UgXCJzcXVhcmVcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdFNxdWFyZSgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdEJ1dHQoKTtcbiAgICB9XG4gIH1cbiAgcHJvamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9qZWN0UG9pbnRzKCkubWFwKCh0KSA9PiAoeyBvcmlnaW5Qb2ludDogdGhpcy5BLCBwcm9qZWN0ZWRQb2ludDogdCB9KSk7XG4gIH1cbn1cbmNvbnN0IERjID0gZnVuY3Rpb24oaSwgdCkge1xuICBsZXQgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwICYmIGFyZ3VtZW50c1syXTtcbiAgY29uc3QgcyA9IFtdO1xuICBpZiAoaS5sZW5ndGggPT09IDApIHJldHVybiBzO1xuICBjb25zdCByID0gaS5yZWR1Y2UoKG4sIG8pID0+IChuW24ubGVuZ3RoIC0gMV0uZXEobykgfHwgbi5wdXNoKG5ldyBfKG8pKSwgbiksIFtuZXcgXyhpWzBdKV0pO1xuICBpZiAoci5sZW5ndGggPT09IDEpIGUgPSAhMDtcbiAgZWxzZSBpZiAoIWUpIHtcbiAgICBjb25zdCBuID0gclswXSwgbyA9ICgoYSwgYykgPT4ge1xuICAgICAgZm9yIChsZXQgbCA9IGEubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIGlmIChjKGFbbF0sIGwsIGEpKSByZXR1cm4gbDtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9KShyLCAoYSkgPT4gIWEuZXEobikpO1xuICAgIHIuc3BsaWNlKG8gKyAxKTtcbiAgfVxuICByZXR1cm4gci5mb3JFYWNoKChuLCBvLCBhKSA9PiB7XG4gICAgbGV0IGMsIGw7XG4gICAgbyA9PT0gMCA/IChsID0gYVsxXSwgYyA9IGUgPyBuIDogYVthLmxlbmd0aCAtIDFdKSA6IG8gPT09IGEubGVuZ3RoIC0gMSA/IChjID0gYVtvIC0gMV0sIGwgPSBlID8gbiA6IGFbMF0pIDogKGMgPSBhW28gLSAxXSwgbCA9IGFbbyArIDFdKSwgZSAmJiBhLmxlbmd0aCA9PT0gMSA/IHMucHVzaCguLi5uZXcgRG8obiwgbiwgdCkucHJvamVjdCgpKSA6ICFlIHx8IG8gIT09IDAgJiYgbyAhPT0gYS5sZW5ndGggLSAxID8gcy5wdXNoKC4uLm5ldyBtcyhuLCBjLCBsLCB0KS5wcm9qZWN0KCkpIDogcy5wdXNoKC4uLm5ldyBEbyhuLCBvID09PSAwID8gbCA6IGMsIHQpLnByb2plY3QoKSk7XG4gIH0pLCBzO1xufSwgS24gPSAoaSkgPT4ge1xuICBjb25zdCB0ID0ge307XG4gIHJldHVybiBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgdFtlXSA9IHt9LCBPYmplY3Qua2V5cyhpW2VdKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICB0W2VdW3NdID0gdih7fSwgaVtlXVtzXSk7XG4gICAgfSk7XG4gIH0pLCB0O1xufSwgamMgPSAoaSkgPT4gaS5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvJy9nLCBcIiZhcG9zO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKSwgeGkgPSAoaSkgPT4ge1xuICBjb25zdCB0ID0gW107XG4gIGZvciAobGV0IGUsIHMgPSAwOyBzIDwgaS5sZW5ndGg7IHMrKykgKGUgPSBndShpLCBzKSkgIT09ICExICYmIHQucHVzaChlKTtcbiAgcmV0dXJuIHQ7XG59LCBndSA9IChpLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBpLmNoYXJDb2RlQXQodCk7XG4gIGlmIChpc05hTihlKSkgcmV0dXJuIFwiXCI7XG4gIGlmIChlIDwgNTUyOTYgfHwgZSA+IDU3MzQzKSByZXR1cm4gaS5jaGFyQXQodCk7XG4gIGlmICg1NTI5NiA8PSBlICYmIGUgPD0gNTYzMTkpIHtcbiAgICBpZiAoaS5sZW5ndGggPD0gdCArIDEpIHRocm93IFwiSGlnaCBzdXJyb2dhdGUgd2l0aG91dCBmb2xsb3dpbmcgbG93IHN1cnJvZ2F0ZVwiO1xuICAgIGNvbnN0IHIgPSBpLmNoYXJDb2RlQXQodCArIDEpO1xuICAgIGlmICg1NjMyMCA+IHIgfHwgciA+IDU3MzQzKSB0aHJvdyBcIkhpZ2ggc3Vycm9nYXRlIHdpdGhvdXQgZm9sbG93aW5nIGxvdyBzdXJyb2dhdGVcIjtcbiAgICByZXR1cm4gaS5jaGFyQXQodCkgKyBpLmNoYXJBdCh0ICsgMSk7XG4gIH1cbiAgaWYgKHQgPT09IDApIHRocm93IFwiTG93IHN1cnJvZ2F0ZSB3aXRob3V0IHByZWNlZGluZyBoaWdoIHN1cnJvZ2F0ZVwiO1xuICBjb25zdCBzID0gaS5jaGFyQ29kZUF0KHQgLSAxKTtcbiAgaWYgKDU1Mjk2ID4gcyB8fCBzID4gNTYzMTkpIHRocm93IFwiTG93IHN1cnJvZ2F0ZSB3aXRob3V0IHByZWNlZGluZyBoaWdoIHN1cnJvZ2F0ZVwiO1xuICByZXR1cm4gITE7XG59O1xudmFyIHB1ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgY2FwaXRhbGl6ZTogZnVuY3Rpb24oaSkge1xuICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwICYmIGFyZ3VtZW50c1sxXTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkpLmNvbmNhdCh0ID8gaS5zbGljZSgxKSA6IGkuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSk7XG59LCBlc2NhcGVYbWw6IGpjLCBncmFwaGVtZVNwbGl0OiB4aSB9KTtcbmNvbnN0IHdpID0gZnVuY3Rpb24oaSwgdCkge1xuICBsZXQgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwICYmIGFyZ3VtZW50c1syXTtcbiAgcmV0dXJuIGkuZmlsbCAhPT0gdC5maWxsIHx8IGkuc3Ryb2tlICE9PSB0LnN0cm9rZSB8fCBpLnN0cm9rZVdpZHRoICE9PSB0LnN0cm9rZVdpZHRoIHx8IGkuZm9udFNpemUgIT09IHQuZm9udFNpemUgfHwgaS5mb250RmFtaWx5ICE9PSB0LmZvbnRGYW1pbHkgfHwgaS5mb250V2VpZ2h0ICE9PSB0LmZvbnRXZWlnaHQgfHwgaS5mb250U3R5bGUgIT09IHQuZm9udFN0eWxlIHx8IGkudGV4dEJhY2tncm91bmRDb2xvciAhPT0gdC50ZXh0QmFja2dyb3VuZENvbG9yIHx8IGkuZGVsdGFZICE9PSB0LmRlbHRhWSB8fCBlICYmIChpLm92ZXJsaW5lICE9PSB0Lm92ZXJsaW5lIHx8IGkudW5kZXJsaW5lICE9PSB0LnVuZGVybGluZSB8fCBpLmxpbmV0aHJvdWdoICE9PSB0LmxpbmV0aHJvdWdoKTtcbn0sIEVjID0gKGksIHQpID0+IHtcbiAgY29uc3QgZSA9IHQuc3BsaXQoYFxuYCksIHMgPSBbXTtcbiAgbGV0IHIgPSAtMSwgbiA9IHt9O1xuICBpID0gS24oaSk7XG4gIGZvciAobGV0IG8gPSAwOyBvIDwgZS5sZW5ndGg7IG8rKykge1xuICAgIGNvbnN0IGEgPSB4aShlW29dKTtcbiAgICBpZiAoaVtvXSkgZm9yIChsZXQgYyA9IDA7IGMgPCBhLmxlbmd0aDsgYysrKSB7XG4gICAgICByKys7XG4gICAgICBjb25zdCBsID0gaVtvXVtjXTtcbiAgICAgIGwgJiYgT2JqZWN0LmtleXMobCkubGVuZ3RoID4gMCAmJiAod2kobiwgbCwgITApID8gcy5wdXNoKHsgc3RhcnQ6IHIsIGVuZDogciArIDEsIHN0eWxlOiBsIH0pIDogc1tzLmxlbmd0aCAtIDFdLmVuZCsrKSwgbiA9IGwgfHwge307XG4gICAgfVxuICAgIGVsc2UgciArPSBhLmxlbmd0aCwgbiA9IHt9O1xuICB9XG4gIHJldHVybiBzO1xufSwgUGMgPSAoaSwgdCkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaSkpIHJldHVybiBLbihpKTtcbiAgY29uc3QgZSA9IHQuc3BsaXQoUG4pLCBzID0ge307XG4gIGxldCByID0gLTEsIG4gPSAwO1xuICBmb3IgKGxldCBvID0gMDsgbyA8IGUubGVuZ3RoOyBvKyspIHtcbiAgICBjb25zdCBhID0geGkoZVtvXSk7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBhLmxlbmd0aDsgYysrKSByKyssIGlbbl0gJiYgaVtuXS5zdGFydCA8PSByICYmIHIgPCBpW25dLmVuZCAmJiAoc1tvXSA9IHNbb10gfHwge30sIHNbb11bY10gPSB2KHt9LCBpW25dLnN0eWxlKSwgciA9PT0gaVtuXS5lbmQgLSAxICYmIG4rKyk7XG4gIH1cbiAgcmV0dXJuIHM7XG59LCBEZSA9IFtcImRpc3BsYXlcIiwgXCJ0cmFuc2Zvcm1cIiwgcnQsIFwiZmlsbC1vcGFjaXR5XCIsIFwiZmlsbC1ydWxlXCIsIFwib3BhY2l0eVwiLCBtdCwgXCJzdHJva2UtZGFzaGFycmF5XCIsIFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJzdHJva2UtZGFzaG9mZnNldFwiLCBcInN0cm9rZS1saW5lam9pblwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCIsIFwic3Ryb2tlLW9wYWNpdHlcIiwgXCJzdHJva2Utd2lkdGhcIiwgXCJpZFwiLCBcInBhaW50LW9yZGVyXCIsIFwidmVjdG9yLWVmZmVjdFwiLCBcImluc3RhbnRpYXRlZF9ieV91c2VcIiwgXCJjbGlwLXBhdGhcIl07XG5mdW5jdGlvbiBqbyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLm5vZGVOYW1lLCBzID0gaS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSwgciA9IGkuZ2V0QXR0cmlidXRlKFwiaWRcIiksIG4gPSBcIig/IVthLXpBLVpcXFxcLV0rKVwiO1xuICBsZXQgbztcbiAgaWYgKG8gPSBuZXcgUmVnRXhwKFwiXlwiICsgZSwgXCJpXCIpLCB0ID0gdC5yZXBsYWNlKG8sIFwiXCIpLCByICYmIHQubGVuZ3RoICYmIChvID0gbmV3IFJlZ0V4cChcIiNcIiArIHIgKyBuLCBcImlcIiksIHQgPSB0LnJlcGxhY2UobywgXCJcIikpLCBzICYmIHQubGVuZ3RoKSB7XG4gICAgY29uc3QgYSA9IHMuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAobGV0IGMgPSBhLmxlbmd0aDsgYy0tOyApIG8gPSBuZXcgUmVnRXhwKFwiXFxcXC5cIiArIGFbY10gKyBuLCBcImlcIiksIHQgPSB0LnJlcGxhY2UobywgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHQubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gbXUoaSwgdCkge1xuICBsZXQgZSA9ICEwO1xuICBjb25zdCBzID0gam8oaSwgdC5wb3AoKSk7XG4gIHJldHVybiBzICYmIHQubGVuZ3RoICYmIChlID0gZnVuY3Rpb24ociwgbikge1xuICAgIGxldCBvLCBhID0gITA7XG4gICAgZm9yICg7IHIucGFyZW50RWxlbWVudCAmJiByLnBhcmVudEVsZW1lbnQubm9kZVR5cGUgPT09IDEgJiYgbi5sZW5ndGg7ICkgYSAmJiAobyA9IG4ucG9wKCkpLCBhID0gam8ociA9IHIucGFyZW50RWxlbWVudCwgbyk7XG4gICAgcmV0dXJuIG4ubGVuZ3RoID09PSAwO1xuICB9KGksIHQpKSwgcyAmJiBlICYmIHQubGVuZ3RoID09PSAwO1xufVxuY29uc3QgdnUgPSAoaSkgPT4ge1xuICB2YXIgdDtcbiAgcmV0dXJuICh0ID0gJGhbaV0pICE9PSBudWxsICYmIHQgIT09IHZvaWQgMCA/IHQgOiBpO1xufSwgeXUgPSBuZXcgUmVnRXhwKFwiKFwiLmNvbmNhdChYZSwgXCIpXCIpLCBcImdpXCIpLCBidSA9IChpKSA9PiBpLnJlcGxhY2UoeXUsIFwiICQxIFwiKS5yZXBsYWNlKC8sL2dpLCBcIiBcIikucmVwbGFjZSgvXFxzKy9naSwgXCIgXCIpO1xudmFyIEVvLCBQbywgQW8sIEZvLCBSbywgTG8sIEJvO1xuY29uc3QgbHQgPSBcIihcIi5jb25jYXQoWGUsIFwiKVwiKSwgX3UgPSBTdHJpbmcucmF3KEVvIHx8IChFbyA9IE1lKFtcIihza2V3WCkoXCIsIFwiKVwiXSwgW1wiKHNrZXdYKVxcXFwoXCIsIFwiXFxcXClcIl0pKSwgbHQpLCBTdSA9IFN0cmluZy5yYXcoUG8gfHwgKFBvID0gTWUoW1wiKHNrZXdZKShcIiwgXCIpXCJdLCBbXCIoc2tld1kpXFxcXChcIiwgXCJcXFxcKVwiXSkpLCBsdCksIFR1ID0gU3RyaW5nLnJhdyhBbyB8fCAoQW8gPSBNZShbXCIocm90YXRlKShcIiwgXCIoPzogXCIsIFwiIFwiLCBcIik/KVwiXSwgW1wiKHJvdGF0ZSlcXFxcKFwiLCBcIig/OiBcIiwgXCIgXCIsIFwiKT9cXFxcKVwiXSkpLCBsdCwgbHQsIGx0KSwgeHUgPSBTdHJpbmcucmF3KEZvIHx8IChGbyA9IE1lKFtcIihzY2FsZSkoXCIsIFwiKD86IFwiLCBcIik/KVwiXSwgW1wiKHNjYWxlKVxcXFwoXCIsIFwiKD86IFwiLCBcIik/XFxcXClcIl0pKSwgbHQsIGx0KSwgd3UgPSBTdHJpbmcucmF3KFJvIHx8IChSbyA9IE1lKFtcIih0cmFuc2xhdGUpKFwiLCBcIig/OiBcIiwgXCIpPylcIl0sIFtcIih0cmFuc2xhdGUpXFxcXChcIiwgXCIoPzogXCIsIFwiKT9cXFxcKVwiXSkpLCBsdCwgbHQpLCBDdSA9IFN0cmluZy5yYXcoTG8gfHwgKExvID0gTWUoW1wiKG1hdHJpeCkoXCIsIFwiIFwiLCBcIiBcIiwgXCIgXCIsIFwiIFwiLCBcIiBcIiwgXCIpXCJdLCBbXCIobWF0cml4KVxcXFwoXCIsIFwiIFwiLCBcIiBcIiwgXCIgXCIsIFwiIFwiLCBcIiBcIiwgXCJcXFxcKVwiXSkpLCBsdCwgbHQsIGx0LCBsdCwgbHQsIGx0KSwgSm4gPSBcIig/OlwiLmNvbmNhdChDdSwgXCJ8XCIpLmNvbmNhdCh3dSwgXCJ8XCIpLmNvbmNhdChUdSwgXCJ8XCIpLmNvbmNhdCh4dSwgXCJ8XCIpLmNvbmNhdChfdSwgXCJ8XCIpLmNvbmNhdChTdSwgXCIpXCIpLCBPdSA9IFwiKD86XCIuY29uY2F0KEpuLCBcIiopXCIpLCBrdSA9IFN0cmluZy5yYXcoQm8gfHwgKEJvID0gTWUoW1wiXnMqKD86XCIsIFwiPylzKiRcIl0sIFtcIl5cXFxccyooPzpcIiwgXCI/KVxcXFxzKiRcIl0pKSwgT3UpLCBNdSA9IG5ldyBSZWdFeHAoa3UpLCBJdSA9IG5ldyBSZWdFeHAoSm4pLCBEdSA9IG5ldyBSZWdFeHAoSm4sIFwiZ1wiKTtcbmZ1bmN0aW9uIGZuKGkpIHtcbiAgY29uc3QgdCA9IFtdO1xuICBpZiAoIShpID0gYnUoaSkucmVwbGFjZSgvXFxzKihbKCldKVxccyovZ2ksIFwiJDFcIikpIHx8IGkgJiYgIU11LnRlc3QoaSkpIHJldHVybiBbLi4uaHRdO1xuICBmb3IgKGNvbnN0IGUgb2YgaS5tYXRjaEFsbChEdSkpIHtcbiAgICBjb25zdCBzID0gSXUuZXhlYyhlWzBdKTtcbiAgICBpZiAoIXMpIGNvbnRpbnVlO1xuICAgIGxldCByID0gaHQ7XG4gICAgY29uc3QgbiA9IHMuZmlsdGVyKChnKSA9PiAhIWcpLCBbLCBvLCAuLi5hXSA9IG4sIFtjLCBsLCBoLCB1LCBkLCBmXSA9IGEubWFwKChnKSA9PiBwYXJzZUZsb2F0KGcpKTtcbiAgICBzd2l0Y2ggKG8pIHtcbiAgICAgIGNhc2UgXCJ0cmFuc2xhdGVcIjpcbiAgICAgICAgciA9IE1zKGMsIGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW46XG4gICAgICAgIHIgPSBJcyh7IGFuZ2xlOiBjIH0sIHsgeDogbCwgeTogaCB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBpOlxuICAgICAgICByID0gdmkoYywgbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBPczpcbiAgICAgICAgciA9IEJuKGMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Uga3M6XG4gICAgICAgIHIgPSBXbihjKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWF0cml4XCI6XG4gICAgICAgIHIgPSBbYywgbCwgaCwgdSwgZCwgZl07XG4gICAgfVxuICAgIHQucHVzaChyKTtcbiAgfVxuICByZXR1cm4gbWkodCk7XG59XG5mdW5jdGlvbiBqdShpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IHIgPSBBcnJheS5pc0FycmF5KHQpO1xuICBsZXQgbiwgbyA9IHQ7XG4gIGlmIChpICE9PSBydCAmJiBpICE9PSBtdCB8fCB0ICE9PSBwdCkge1xuICAgIGlmIChpID09PSBcInN0cm9rZVVuaWZvcm1cIikgcmV0dXJuIHQgPT09IFwibm9uLXNjYWxpbmctc3Ryb2tlXCI7XG4gICAgaWYgKGkgPT09IFwic3Ryb2tlRGFzaEFycmF5XCIpIG8gPSB0ID09PSBwdCA/IG51bGwgOiB0LnJlcGxhY2UoLywvZywgXCIgXCIpLnNwbGl0KC9cXHMrLykubWFwKHBhcnNlRmxvYXQpO1xuICAgIGVsc2UgaWYgKGkgPT09IFwidHJhbnNmb3JtTWF0cml4XCIpIG8gPSBlICYmIGUudHJhbnNmb3JtTWF0cml4ID8gSihlLnRyYW5zZm9ybU1hdHJpeCwgZm4odCkpIDogZm4odCk7XG4gICAgZWxzZSBpZiAoaSA9PT0gXCJ2aXNpYmxlXCIpIG8gPSB0ICE9PSBwdCAmJiB0ICE9PSBcImhpZGRlblwiLCBlICYmIGUudmlzaWJsZSA9PT0gITEgJiYgKG8gPSAhMSk7XG4gICAgZWxzZSBpZiAoaSA9PT0gXCJvcGFjaXR5XCIpIG8gPSBwYXJzZUZsb2F0KHQpLCBlICYmIGUub3BhY2l0eSAhPT0gdm9pZCAwICYmIChvICo9IGUub3BhY2l0eSk7XG4gICAgZWxzZSBpZiAoaSA9PT0gXCJ0ZXh0QW5jaG9yXCIpIG8gPSB0ID09PSBcInN0YXJ0XCIgPyBMIDogdCA9PT0gXCJlbmRcIiA/IFogOiBqO1xuICAgIGVsc2UgaWYgKGkgPT09IFwiY2hhclNwYWNpbmdcIikgbiA9IFdlKHQsIHMpIC8gcyAqIDFlMztcbiAgICBlbHNlIGlmIChpID09PSBcInBhaW50Rmlyc3RcIikge1xuICAgICAgY29uc3QgYSA9IHQuaW5kZXhPZihydCksIGMgPSB0LmluZGV4T2YobXQpO1xuICAgICAgbyA9IHJ0LCAoYSA+IC0xICYmIGMgPiAtMSAmJiBjIDwgYSB8fCBhID09PSAtMSAmJiBjID4gLTEpICYmIChvID0gbXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA9PT0gXCJocmVmXCIgfHwgaSA9PT0gXCJ4bGluazpocmVmXCIgfHwgaSA9PT0gXCJmb250XCIgfHwgaSA9PT0gXCJpZFwiKSByZXR1cm4gdDtcbiAgICAgIGlmIChpID09PSBcImltYWdlU21vb3RoaW5nXCIpIHJldHVybiB0ID09PSBcIm9wdGltaXplUXVhbGl0eVwiO1xuICAgICAgbiA9IHIgPyB0Lm1hcChXZSkgOiBXZSh0LCBzKTtcbiAgICB9XG4gIH0gZWxzZSBvID0gXCJcIjtcbiAgcmV0dXJuICFyICYmIGlzTmFOKG4pID8gbyA6IG47XG59XG5mdW5jdGlvbiBFdShpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLm1hdGNoKFVoKTtcbiAgaWYgKCFlKSByZXR1cm47XG4gIGNvbnN0IHMgPSBlWzFdLCByID0gZVszXSwgbiA9IGVbNF0sIG8gPSBlWzVdLCBhID0gZVs2XTtcbiAgcyAmJiAodC5mb250U3R5bGUgPSBzKSwgciAmJiAodC5mb250V2VpZ2h0ID0gaXNOYU4ocGFyc2VGbG9hdChyKSkgPyByIDogcGFyc2VGbG9hdChyKSksIG4gJiYgKHQuZm9udFNpemUgPSBXZShuKSksIGEgJiYgKHQuZm9udEZhbWlseSA9IGEpLCBvICYmICh0LmxpbmVIZWlnaHQgPSBvID09PSBcIm5vcm1hbFwiID8gMSA6IG8pO1xufVxuZnVuY3Rpb24gUHUoaSwgdCkge1xuICBpLnJlcGxhY2UoLztcXHMqJC8sIFwiXCIpLnNwbGl0KFwiO1wiKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgaWYgKCFlKSByZXR1cm47XG4gICAgY29uc3QgW3MsIHJdID0gZS5zcGxpdChcIjpcIik7XG4gICAgdFtzLnRyaW0oKS50b0xvd2VyQ2FzZSgpXSA9IHIudHJpbSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIEF1KGkpIHtcbiAgY29uc3QgdCA9IHt9LCBlID0gaS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIGUgJiYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBQdShlLCB0KSA6IGZ1bmN0aW9uKHMsIHIpIHtcbiAgICBPYmplY3QuZW50cmllcyhzKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBsZXQgW28sIGFdID0gbjtcbiAgICAgIGEgIT09IHZvaWQgMCAmJiAocltvLnRvTG93ZXJDYXNlKCldID0gYSk7XG4gICAgfSk7XG4gIH0oZSwgdCkpLCB0O1xufVxuY29uc3QgRnUgPSB7IHN0cm9rZTogXCJzdHJva2VPcGFjaXR5XCIsIGZpbGw6IFwiZmlsbE9wYWNpdHlcIiB9O1xuZnVuY3Rpb24gZmUoaSwgdCwgZSkge1xuICBpZiAoIWkpIHJldHVybiB7fTtcbiAgbGV0IHMsIHIgPSB7fSwgbiA9IEVuO1xuICBpLnBhcmVudE5vZGUgJiYgQ28udGVzdChpLnBhcmVudE5vZGUubm9kZU5hbWUpICYmIChyID0gZmUoaS5wYXJlbnRFbGVtZW50LCB0LCBlKSwgci5mb250U2l6ZSAmJiAocyA9IG4gPSBXZShyLmZvbnRTaXplKSkpO1xuICBjb25zdCBvID0gdih2KHYoe30sIHQucmVkdWNlKChsLCBoKSA9PiB7XG4gICAgY29uc3QgdSA9IGkuZ2V0QXR0cmlidXRlKGgpO1xuICAgIHJldHVybiB1ICYmIChsW2hdID0gdSksIGw7XG4gIH0sIHt9KSksIGZ1bmN0aW9uKGwpIHtcbiAgICBsZXQgaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge30sIHUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGQgaW4gaCkgbXUobCwgZC5zcGxpdChcIiBcIikpICYmICh1ID0gdih2KHt9LCB1KSwgaFtkXSkpO1xuICAgIHJldHVybiB1O1xuICB9KGksIGUpKSwgQXUoaSkpO1xuICBvW1dpXSAmJiBpLnNldEF0dHJpYnV0ZShXaSwgb1tXaV0pLCBvW0JpXSAmJiAocyA9IFdlKG9bQmldLCBuKSwgb1tCaV0gPSBcIlwiLmNvbmNhdChzKSk7XG4gIGNvbnN0IGEgPSB7fTtcbiAgZm9yIChjb25zdCBsIGluIG8pIHtcbiAgICBjb25zdCBoID0gdnUobCksIHUgPSBqdShoLCBvW2xdLCByLCBzKTtcbiAgICBhW2hdID0gdTtcbiAgfVxuICBhICYmIGEuZm9udCAmJiBFdShhLmZvbnQsIGEpO1xuICBjb25zdCBjID0gdih2KHt9LCByKSwgYSk7XG4gIHJldHVybiBDby50ZXN0KGkubm9kZU5hbWUpID8gYyA6IGZ1bmN0aW9uKGwpIHtcbiAgICBjb25zdCBoID0gbnQuZ2V0RGVmYXVsdHMoKTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoRnUpLmZvckVhY2goKHUpID0+IHtcbiAgICAgIGxldCBbZCwgZl0gPSB1O1xuICAgICAgaWYgKGxbZl0gPT09IHZvaWQgMCB8fCBsW2RdID09PSBcIlwiKSByZXR1cm47XG4gICAgICBpZiAobFtkXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghaFtkXSkgcmV0dXJuO1xuICAgICAgICBsW2RdID0gaFtkXTtcbiAgICAgIH1cbiAgICAgIGlmIChsW2RdLmluZGV4T2YoXCJ1cmwoXCIpID09PSAwKSByZXR1cm47XG4gICAgICBjb25zdCBnID0gbmV3IFcobFtkXSk7XG4gICAgICBsW2RdID0gZy5zZXRBbHBoYShWKGcuZ2V0QWxwaGEoKSAqIGxbZl0sIDIpKS50b1JnYmEoKTtcbiAgICB9KSwgbDtcbiAgfShjKTtcbn1cbmNvbnN0IFJ1ID0gW1wibGVmdFwiLCBcInRvcFwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwidmlzaWJsZVwiXSwgQWMgPSBbXCJyeFwiLCBcInJ5XCJdO1xuY2xhc3MgWCBleHRlbmRzIG50IHtcbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB2KHYoe30sIHN1cGVyLmdldERlZmF1bHRzKCkpLCBYLm93bkRlZmF1bHRzKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBYLm93bkRlZmF1bHRzKSwgdGhpcy5zZXRPcHRpb25zKHQpLCB0aGlzLl9pbml0UnhSeSgpO1xuICB9XG4gIF9pbml0UnhSeSgpIHtcbiAgICBjb25zdCB7IHJ4OiB0LCByeTogZSB9ID0gdGhpcztcbiAgICB0ICYmICFlID8gdGhpcy5yeSA9IHQgOiBlICYmICF0ICYmICh0aGlzLnJ4ID0gZSk7XG4gIH1cbiAgX3JlbmRlcih0KSB7XG4gICAgY29uc3QgeyB3aWR0aDogZSwgaGVpZ2h0OiBzIH0gPSB0aGlzLCByID0gLWUgLyAyLCBuID0gLXMgLyAyLCBvID0gdGhpcy5yeCA/IE1hdGgubWluKHRoaXMucngsIGUgLyAyKSA6IDAsIGEgPSB0aGlzLnJ5ID8gTWF0aC5taW4odGhpcy5yeSwgcyAvIDIpIDogMCwgYyA9IG8gIT09IDAgfHwgYSAhPT0gMDtcbiAgICB0LmJlZ2luUGF0aCgpLCB0Lm1vdmVUbyhyICsgbywgbiksIHQubGluZVRvKHIgKyBlIC0gbywgbiksIGMgJiYgdC5iZXppZXJDdXJ2ZVRvKHIgKyBlIC0geWUgKiBvLCBuLCByICsgZSwgbiArIHllICogYSwgciArIGUsIG4gKyBhKSwgdC5saW5lVG8ociArIGUsIG4gKyBzIC0gYSksIGMgJiYgdC5iZXppZXJDdXJ2ZVRvKHIgKyBlLCBuICsgcyAtIHllICogYSwgciArIGUgLSB5ZSAqIG8sIG4gKyBzLCByICsgZSAtIG8sIG4gKyBzKSwgdC5saW5lVG8ociArIG8sIG4gKyBzKSwgYyAmJiB0LmJlemllckN1cnZlVG8ociArIHllICogbywgbiArIHMsIHIsIG4gKyBzIC0geWUgKiBhLCByLCBuICsgcyAtIGEpLCB0LmxpbmVUbyhyLCBuICsgYSksIGMgJiYgdC5iZXppZXJDdXJ2ZVRvKHIsIG4gKyB5ZSAqIGEsIHIgKyB5ZSAqIG8sIG4sIHIgKyBvLCBuKSwgdC5jbG9zZVBhdGgoKSwgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKHQpO1xuICB9XG4gIHRvT2JqZWN0KCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICByZXR1cm4gc3VwZXIudG9PYmplY3QoWy4uLkFjLCAuLi50XSk7XG4gIH1cbiAgX3RvU1ZHKCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHQsIGhlaWdodDogZSwgcng6IHMsIHJ5OiByIH0gPSB0aGlzO1xuICAgIHJldHVybiBbXCI8cmVjdCBcIiwgXCJDT01NT05fUEFSVFNcIiwgJ3g9XCInLmNvbmNhdCgtdCAvIDIsICdcIiB5PVwiJykuY29uY2F0KC1lIC8gMiwgJ1wiIHJ4PVwiJykuY29uY2F0KHMsICdcIiByeT1cIicpLmNvbmNhdChyLCAnXCIgd2lkdGg9XCInKS5jb25jYXQodCwgJ1wiIGhlaWdodD1cIicpLmNvbmNhdChlLCBgXCIgLz5cbmApXTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVsZW1lbnQodCwgZSwgcykge1xuICAgIGNvbnN0IHIgPSBmZSh0LCB0aGlzLkFUVFJJQlVURV9OQU1FUywgcyksIHsgbGVmdDogbiA9IDAsIHRvcDogbyA9IDAsIHdpZHRoOiBhID0gMCwgaGVpZ2h0OiBjID0gMCwgdmlzaWJsZTogbCA9ICEwIH0gPSByLCBoID0gRyhyLCBSdSk7XG4gICAgcmV0dXJuIG5ldyB0aGlzKHYodih2KHt9LCBlKSwgaCksIHt9LCB7IGxlZnQ6IG4sIHRvcDogbywgd2lkdGg6IGEsIGhlaWdodDogYywgdmlzaWJsZTogISEobCAmJiBhICYmIGMpIH0pKTtcbiAgfVxufVxueShYLCBcInR5cGVcIiwgXCJSZWN0XCIpLCB5KFgsIFwiY2FjaGVQcm9wZXJ0aWVzXCIsIFsuLi5kZSwgLi4uQWNdKSwgeShYLCBcIm93bkRlZmF1bHRzXCIsIHsgcng6IDAsIHJ5OiAwIH0pLCB5KFgsIFwiQVRUUklCVVRFX05BTUVTXCIsIFsuLi5EZSwgXCJ4XCIsIFwieVwiLCBcInJ4XCIsIFwicnlcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSksIEMuc2V0Q2xhc3MoWCksIEMuc2V0U1ZHQ2xhc3MoWCk7XG5jb25zdCBuZSA9IFwiaW5pdGlhbGl6YXRpb25cIiwgZWkgPSBcImFkZGVkXCIsIFpuID0gXCJyZW1vdmVkXCIsIHNpID0gXCJpbXBlcmF0aXZlXCIsIEZjID0gKGksIHQpID0+IHtcbiAgY29uc3QgeyBzdHJva2VVbmlmb3JtOiBlLCBzdHJva2VXaWR0aDogcywgd2lkdGg6IHIsIGhlaWdodDogbiwgZ3JvdXA6IG8gfSA9IHQsIGEgPSBvICYmIG8gIT09IGkgPyBocihvLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSwgaS5jYWxjVHJhbnNmb3JtTWF0cml4KCkpIDogbnVsbCwgYyA9IGEgPyB0LmdldFJlbGF0aXZlQ2VudGVyUG9pbnQoKS50cmFuc2Zvcm0oYSkgOiB0LmdldFJlbGF0aXZlQ2VudGVyUG9pbnQoKSwgbCA9ICF0LmlzU3Ryb2tlQWNjb3VudGVkRm9ySW5EaW1lbnNpb25zKCksIGggPSBlICYmIGwgPyByYyhuZXcgXyhzLCBzKSwgdm9pZCAwLCBpLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSkgOiBGbiwgdSA9ICFlICYmIGwgPyBzIDogMCwgZCA9IHlpKHIgKyB1LCBuICsgdSwgbWkoW2EsIHQuY2FsY093bk1hdHJpeCgpXSwgITApKS5hZGQoaCkuc2NhbGFyRGl2aWRlKDIpO1xuICByZXR1cm4gW2Muc3VidHJhY3QoZCksIGMuYWRkKGQpXTtcbn07XG5jbGFzcyBDaSB7XG4gIGNhbGNMYXlvdXRSZXN1bHQodCwgZSkge1xuICAgIGlmICh0aGlzLnNob3VsZFBlcmZvcm1MYXlvdXQodCkpIHJldHVybiB0aGlzLmNhbGNCb3VuZGluZ0JveChlLCB0KTtcbiAgfVxuICBzaG91bGRQZXJmb3JtTGF5b3V0KHQpIHtcbiAgICBsZXQgeyB0eXBlOiBlLCBwcmV2U3RyYXRlZ3k6IHMsIHN0cmF0ZWd5OiByIH0gPSB0O1xuICAgIHJldHVybiBlID09PSBuZSB8fCBlID09PSBzaSB8fCAhIXMgJiYgciAhPT0gcztcbiAgfVxuICBzaG91bGRMYXlvdXRDbGlwUGF0aCh0KSB7XG4gICAgbGV0IHsgdHlwZTogZSwgdGFyZ2V0OiB7IGNsaXBQYXRoOiBzIH0gfSA9IHQ7XG4gICAgcmV0dXJuIGUgIT09IG5lICYmIHMgJiYgIXMuYWJzb2x1dGVQb3NpdGlvbmVkO1xuICB9XG4gIGdldEluaXRpYWxTaXplKHQsIGUpIHtcbiAgICByZXR1cm4gZS5zaXplO1xuICB9XG4gIGNhbGNCb3VuZGluZ0JveCh0LCBlKSB7XG4gICAgY29uc3QgeyB0eXBlOiBzLCB0YXJnZXQ6IHIgfSA9IGU7XG4gICAgaWYgKHMgPT09IHNpICYmIGUub3ZlcnJpZGVzKSByZXR1cm4gZS5vdmVycmlkZXM7XG4gICAgaWYgKHQubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgeyBsZWZ0OiBuLCB0b3A6IG8sIHdpZHRoOiBhLCBoZWlnaHQ6IGMgfSA9IEd0KHQubWFwKCh1KSA9PiBGYyhyLCB1KSkucmVkdWNlKCh1LCBkKSA9PiB1LmNvbmNhdChkKSwgW10pKSwgbCA9IG5ldyBfKGEsIGMpLCBoID0gbmV3IF8obiwgbykuYWRkKGwuc2NhbGFyRGl2aWRlKDIpKTtcbiAgICBpZiAocyA9PT0gbmUpIHtcbiAgICAgIGNvbnN0IHUgPSB0aGlzLmdldEluaXRpYWxTaXplKGUsIHsgc2l6ZTogbCwgY2VudGVyOiBoIH0pO1xuICAgICAgcmV0dXJuIHsgY2VudGVyOiBoLCByZWxhdGl2ZUNvcnJlY3Rpb246IG5ldyBfKDAsIDApLCBzaXplOiB1IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNlbnRlcjogaC50cmFuc2Zvcm0oci5jYWxjT3duTWF0cml4KCkpLCBzaXplOiBsIH07XG4gIH1cbn1cbnkoQ2ksIFwidHlwZVwiLCBcInN0cmF0ZWd5XCIpO1xuY2xhc3MgZ24gZXh0ZW5kcyBDaSB7XG4gIHNob3VsZFBlcmZvcm1MYXlvdXQodCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxufVxueShnbiwgXCJ0eXBlXCIsIFwiZml0LWNvbnRlbnRcIiksIEMuc2V0Q2xhc3MoZ24pO1xuY29uc3QgTHUgPSBbXCJzdHJhdGVneVwiXSwgQnUgPSBbXCJ0YXJnZXRcIiwgXCJzdHJhdGVneVwiLCBcImJ1YmJsZXNcIiwgXCJwcmV2U3RyYXRlZ3lcIl0sIFJjID0gXCJsYXlvdXRNYW5hZ2VyXCI7XG5jbGFzcyBacyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBuZXcgZ24oKTtcbiAgICB5KHRoaXMsIFwic3RyYXRlZ3lcIiwgdm9pZCAwKSwgdGhpcy5zdHJhdGVneSA9IHQsIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHBlcmZvcm1MYXlvdXQodCkge1xuICAgIGNvbnN0IGUgPSB2KHYoeyBidWJibGVzOiAhMCwgc3RyYXRlZ3k6IHRoaXMuc3RyYXRlZ3kgfSwgdCksIHt9LCB7IHByZXZTdHJhdGVneTogdGhpcy5fcHJldkxheW91dFN0cmF0ZWd5LCBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICB0aGlzLmJ1YmJsZXMgPSAhMTtcbiAgICB9IH0pO1xuICAgIHRoaXMub25CZWZvcmVMYXlvdXQoZSk7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0TGF5b3V0UmVzdWx0KGUpO1xuICAgIHMgJiYgdGhpcy5jb21taXRMYXlvdXQoZSwgcyksIHRoaXMub25BZnRlckxheW91dChlLCBzKSwgdGhpcy5fcHJldkxheW91dFN0cmF0ZWd5ID0gZS5zdHJhdGVneTtcbiAgfVxuICBhdHRhY2hIYW5kbGVycyh0LCBlKSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IHMgfSA9IGU7XG4gICAgcmV0dXJuIFskciwgTGEsICRzLCBCYSwgZ2ksIFdhLCBVciwgWGEsIFhoXS5tYXAoKHIpID0+IHQub24ociwgKG4pID0+IHRoaXMucGVyZm9ybUxheW91dChyID09PSAkciA/IHsgdHlwZTogXCJvYmplY3RfbW9kaWZpZWRcIiwgdHJpZ2dlcjogciwgZTogbiwgdGFyZ2V0OiBzIH0gOiB7IHR5cGU6IFwib2JqZWN0X21vZGlmeWluZ1wiLCB0cmlnZ2VyOiByLCBlOiBuLCB0YXJnZXQ6IHMgfSkpKTtcbiAgfVxuICBzdWJzY3JpYmUodCwgZSkge1xuICAgIHRoaXMudW5zdWJzY3JpYmUodCwgZSk7XG4gICAgY29uc3QgcyA9IHRoaXMuYXR0YWNoSGFuZGxlcnModCwgZSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5zZXQodCwgcyk7XG4gIH1cbiAgdW5zdWJzY3JpYmUodCwgZSkge1xuICAgICh0aGlzLl9zdWJzY3JpcHRpb25zLmdldCh0KSB8fCBbXSkuZm9yRWFjaCgocykgPT4gcygpKSwgdGhpcy5fc3Vic2NyaXB0aW9ucy5kZWxldGUodCk7XG4gIH1cbiAgdW5zdWJzY3JpYmVUYXJnZXRzKHQpIHtcbiAgICB0LnRhcmdldHMuZm9yRWFjaCgoZSkgPT4gdGhpcy51bnN1YnNjcmliZShlLCB0KSk7XG4gIH1cbiAgc3Vic2NyaWJlVGFyZ2V0cyh0KSB7XG4gICAgdC50YXJnZXRzLmZvckVhY2goKGUpID0+IHRoaXMuc3Vic2NyaWJlKGUsIHQpKTtcbiAgfVxuICBvbkJlZm9yZUxheW91dCh0KSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IGUsIHR5cGU6IHMgfSA9IHQsIHsgY2FudmFzOiByIH0gPSBlO1xuICAgIGlmIChzID09PSBuZSB8fCBzID09PSBlaSA/IHRoaXMuc3Vic2NyaWJlVGFyZ2V0cyh0KSA6IHMgPT09IFpuICYmIHRoaXMudW5zdWJzY3JpYmVUYXJnZXRzKHQpLCBlLmZpcmUoXCJsYXlvdXQ6YmVmb3JlXCIsIHsgY29udGV4dDogdCB9KSwgciAmJiByLmZpcmUoXCJvYmplY3Q6bGF5b3V0OmJlZm9yZVwiLCB7IHRhcmdldDogZSwgY29udGV4dDogdCB9KSwgcyA9PT0gc2kgJiYgdC5kZWVwKSB7XG4gICAgICBjb25zdCBuID0gRyh0LCBMdSk7XG4gICAgICBlLmZvckVhY2hPYmplY3QoKG8pID0+IG8ubGF5b3V0TWFuYWdlciAmJiBvLmxheW91dE1hbmFnZXIucGVyZm9ybUxheW91dCh2KHYoe30sIG4pLCB7fSwgeyBidWJibGVzOiAhMSwgdGFyZ2V0OiBvIH0pKSk7XG4gICAgfVxuICB9XG4gIGdldExheW91dFJlc3VsdCh0KSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IGUsIHN0cmF0ZWd5OiBzLCB0eXBlOiByIH0gPSB0LCBuID0gcy5jYWxjTGF5b3V0UmVzdWx0KHQsIGUuZ2V0T2JqZWN0cygpKTtcbiAgICBpZiAoIW4pIHJldHVybjtcbiAgICBjb25zdCBvID0gciA9PT0gbmUgPyBuZXcgXygpIDogZS5nZXRSZWxhdGl2ZUNlbnRlclBvaW50KCksIHsgY2VudGVyOiBhLCBjb3JyZWN0aW9uOiBjID0gbmV3IF8oKSwgcmVsYXRpdmVDb3JyZWN0aW9uOiBsID0gbmV3IF8oKSB9ID0gbiwgaCA9IG8uc3VidHJhY3QoYSkuYWRkKGMpLnRyYW5zZm9ybShyID09PSBuZSA/IGh0IDogU3QoZS5jYWxjT3duTWF0cml4KCkpLCAhMCkuYWRkKGwpO1xuICAgIHJldHVybiB7IHJlc3VsdDogbiwgcHJldkNlbnRlcjogbywgbmV4dENlbnRlcjogYSwgb2Zmc2V0OiBoIH07XG4gIH1cbiAgY29tbWl0TGF5b3V0KHQsIGUpIHtcbiAgICBjb25zdCB7IHRhcmdldDogcyB9ID0gdCwgeyByZXN1bHQ6IHsgc2l6ZTogciB9LCBuZXh0Q2VudGVyOiBuIH0gPSBlO1xuICAgIHZhciBvLCBhO1xuICAgIHMuc2V0KHsgd2lkdGg6IHIueCwgaGVpZ2h0OiByLnkgfSksIHRoaXMubGF5b3V0T2JqZWN0cyh0LCBlKSwgdC50eXBlID09PSBuZSA/IHMuc2V0KHsgbGVmdDogKG8gPSB0LngpICE9PSBudWxsICYmIG8gIT09IHZvaWQgMCA/IG8gOiBuLnggKyByLnggKiBzdChzLm9yaWdpblgpLCB0b3A6IChhID0gdC55KSAhPT0gbnVsbCAmJiBhICE9PSB2b2lkIDAgPyBhIDogbi55ICsgci55ICogc3Qocy5vcmlnaW5ZKSB9KSA6IChzLnNldFBvc2l0aW9uQnlPcmlnaW4obiwgaiwgaiksIHMuc2V0Q29vcmRzKCksIHMuc2V0KFwiZGlydHlcIiwgITApKTtcbiAgfVxuICBsYXlvdXRPYmplY3RzKHQsIGUpIHtcbiAgICBjb25zdCB7IHRhcmdldDogcyB9ID0gdDtcbiAgICBzLmZvckVhY2hPYmplY3QoKHIpID0+IHtcbiAgICAgIHIuZ3JvdXAgPT09IHMgJiYgdGhpcy5sYXlvdXRPYmplY3QodCwgZSwgcik7XG4gICAgfSksIHQuc3RyYXRlZ3kuc2hvdWxkTGF5b3V0Q2xpcFBhdGgodCkgJiYgdGhpcy5sYXlvdXRPYmplY3QodCwgZSwgcy5jbGlwUGF0aCk7XG4gIH1cbiAgbGF5b3V0T2JqZWN0KHQsIGUsIHMpIHtcbiAgICBsZXQgeyBvZmZzZXQ6IHIgfSA9IGU7XG4gICAgcy5zZXQoeyBsZWZ0OiBzLmxlZnQgKyByLngsIHRvcDogcy50b3AgKyByLnkgfSk7XG4gIH1cbiAgb25BZnRlckxheW91dCh0LCBlKSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IHMsIHN0cmF0ZWd5OiByLCBidWJibGVzOiBuLCBwcmV2U3RyYXRlZ3k6IG8gfSA9IHQsIGEgPSBHKHQsIEJ1KSwgeyBjYW52YXM6IGMgfSA9IHM7XG4gICAgcy5maXJlKFwibGF5b3V0OmFmdGVyXCIsIHsgY29udGV4dDogdCwgcmVzdWx0OiBlIH0pLCBjICYmIGMuZmlyZShcIm9iamVjdDpsYXlvdXQ6YWZ0ZXJcIiwgeyBjb250ZXh0OiB0LCByZXN1bHQ6IGUsIHRhcmdldDogcyB9KTtcbiAgICBjb25zdCBsID0gcy5wYXJlbnQ7XG4gICAgbiAmJiBsICE9IG51bGwgJiYgbC5sYXlvdXRNYW5hZ2VyICYmICgoYS5wYXRoIHx8IChhLnBhdGggPSBbXSkpLnB1c2gocyksIGwubGF5b3V0TWFuYWdlci5wZXJmb3JtTGF5b3V0KHYodih7fSwgYSksIHt9LCB7IHRhcmdldDogbCB9KSkpLCBzLnNldChcImRpcnR5XCIsICEwKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHsgX3N1YnNjcmlwdGlvbnM6IHQgfSA9IHRoaXM7XG4gICAgdC5mb3JFYWNoKChlKSA9PiBlLmZvckVhY2goKHMpID0+IHMoKSkpLCB0LmNsZWFyKCk7XG4gIH1cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogUmMsIHN0cmF0ZWd5OiB0aGlzLnN0cmF0ZWd5LmNvbnN0cnVjdG9yLnR5cGUgfTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoKTtcbiAgfVxufVxuQy5zZXRDbGFzcyhacywgUmMpO1xuY29uc3QgV3UgPSBbXCJ0eXBlXCIsIFwib2JqZWN0c1wiLCBcImxheW91dE1hbmFnZXJcIl07XG5jbGFzcyBYdSBleHRlbmRzIFpzIHtcbiAgcGVyZm9ybUxheW91dCgpIHtcbiAgfVxufVxuY2xhc3MgTnQgZXh0ZW5kcyB6YShudCkge1xuICBzdGF0aWMgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHYodih7fSwgc3VwZXIuZ2V0RGVmYXVsdHMoKSksIE50Lm93bkRlZmF1bHRzKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogW10sIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHN1cGVyKCksIHkodGhpcywgXCJfYWN0aXZlT2JqZWN0c1wiLCBbXSksIHkodGhpcywgXCJfX29iamVjdFNlbGVjdGlvblRyYWNrZXJcIiwgdm9pZCAwKSwgeSh0aGlzLCBcIl9fb2JqZWN0U2VsZWN0aW9uRGlzcG9zZXJcIiwgdm9pZCAwKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBOdC5vd25EZWZhdWx0cyksIHRoaXMuc2V0T3B0aW9ucyhlKSwgdGhpcy5ncm91cEluaXQodCwgZSk7XG4gIH1cbiAgZ3JvdXBJbml0KHQsIGUpIHtcbiAgICB2YXIgcztcbiAgICB0aGlzLl9vYmplY3RzID0gWy4uLnRdLCB0aGlzLl9fb2JqZWN0U2VsZWN0aW9uVHJhY2tlciA9IHRoaXMuX19vYmplY3RTZWxlY3Rpb25Nb25pdG9yLmJpbmQodGhpcywgITApLCB0aGlzLl9fb2JqZWN0U2VsZWN0aW9uRGlzcG9zZXIgPSB0aGlzLl9fb2JqZWN0U2VsZWN0aW9uTW9uaXRvci5iaW5kKHRoaXMsICExKSwgdGhpcy5mb3JFYWNoT2JqZWN0KChyKSA9PiB7XG4gICAgICB0aGlzLmVudGVyR3JvdXAociwgITEpO1xuICAgIH0pLCB0aGlzLmxheW91dE1hbmFnZXIgPSAocyA9IGUubGF5b3V0TWFuYWdlcikgIT09IG51bGwgJiYgcyAhPT0gdm9pZCAwID8gcyA6IG5ldyBacygpLCB0aGlzLmxheW91dE1hbmFnZXIucGVyZm9ybUxheW91dCh7IHR5cGU6IG5lLCB0YXJnZXQ6IHRoaXMsIHRhcmdldHM6IFsuLi50XSwgeDogZS5sZWZ0LCB5OiBlLnRvcCB9KTtcbiAgfVxuICBjYW5FbnRlckdyb3VwKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gdGhpcyB8fCB0aGlzLmlzRGVzY2VuZGFudE9mKHQpID8gKFRlKFwiZXJyb3JcIiwgXCJHcm91cDogY2lyY3VsYXIgb2JqZWN0IHRyZWVzIGFyZSBub3Qgc3VwcG9ydGVkLCB0aGlzIGNhbGwgaGFzIG5vIGVmZmVjdFwiKSwgITEpIDogdGhpcy5fb2JqZWN0cy5pbmRleE9mKHQpID09PSAtMSB8fCAoVGUoXCJlcnJvclwiLCBcIkdyb3VwOiBkdXBsaWNhdGUgb2JqZWN0cyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUgZ3JvdXAsIHRoaXMgY2FsbCBoYXMgbm8gZWZmZWN0XCIpLCAhMSk7XG4gIH1cbiAgX2ZpbHRlck9iamVjdHNCZWZvcmVFbnRlcmluZ0dyb3VwKHQpIHtcbiAgICByZXR1cm4gdC5maWx0ZXIoKGUsIHMsIHIpID0+IHRoaXMuY2FuRW50ZXJHcm91cChlKSAmJiByLmluZGV4T2YoZSkgPT09IHMpO1xuICB9XG4gIGFkZCgpIHtcbiAgICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgZSA9IG5ldyBBcnJheSh0KSwgcyA9IDA7IHMgPCB0OyBzKyspIGVbc10gPSBhcmd1bWVudHNbc107XG4gICAgY29uc3QgciA9IHRoaXMuX2ZpbHRlck9iamVjdHNCZWZvcmVFbnRlcmluZ0dyb3VwKGUpLCBuID0gc3VwZXIuYWRkKC4uLnIpO1xuICAgIHJldHVybiB0aGlzLl9vbkFmdGVyT2JqZWN0c0NoYW5nZShlaSwgciksIG47XG4gIH1cbiAgaW5zZXJ0QXQodCkge1xuICAgIGZvciAodmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoLCBzID0gbmV3IEFycmF5KGUgPiAxID8gZSAtIDEgOiAwKSwgciA9IDE7IHIgPCBlOyByKyspIHNbciAtIDFdID0gYXJndW1lbnRzW3JdO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9maWx0ZXJPYmplY3RzQmVmb3JlRW50ZXJpbmdHcm91cChzKSwgbyA9IHN1cGVyLmluc2VydEF0KHQsIC4uLm4pO1xuICAgIHJldHVybiB0aGlzLl9vbkFmdGVyT2JqZWN0c0NoYW5nZShlaSwgbiksIG87XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGNvbnN0IHQgPSBzdXBlci5yZW1vdmUoLi4uYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcy5fb25BZnRlck9iamVjdHNDaGFuZ2UoWm4sIHQpLCB0O1xuICB9XG4gIF9vbk9iamVjdEFkZGVkKHQpIHtcbiAgICB0aGlzLmVudGVyR3JvdXAodCwgITApLCB0aGlzLmZpcmUoXCJvYmplY3Q6YWRkZWRcIiwgeyB0YXJnZXQ6IHQgfSksIHQuZmlyZShcImFkZGVkXCIsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICB9XG4gIF9vbk9iamVjdFJlbW92ZWQodCwgZSkge1xuICAgIHRoaXMuZXhpdEdyb3VwKHQsIGUpLCB0aGlzLmZpcmUoXCJvYmplY3Q6cmVtb3ZlZFwiLCB7IHRhcmdldDogdCB9KSwgdC5maXJlKFwicmVtb3ZlZFwiLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgfVxuICBfb25BZnRlck9iamVjdHNDaGFuZ2UodCwgZSkge1xuICAgIHRoaXMubGF5b3V0TWFuYWdlci5wZXJmb3JtTGF5b3V0KHsgdHlwZTogdCwgdGFyZ2V0czogZSwgdGFyZ2V0OiB0aGlzIH0pO1xuICB9XG4gIF9vblN0YWNrT3JkZXJDaGFuZ2VkKCkge1xuICAgIHRoaXMuX3NldChcImRpcnR5XCIsICEwKTtcbiAgfVxuICBfc2V0KHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpc1t0XTtcbiAgICByZXR1cm4gc3VwZXIuX3NldCh0LCBlKSwgdCA9PT0gXCJjYW52YXNcIiAmJiBzICE9PSBlICYmICh0aGlzLl9vYmplY3RzIHx8IFtdKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICByLl9zZXQodCwgZSk7XG4gICAgfSksIHRoaXM7XG4gIH1cbiAgX3Nob3VsZFNldE5lc3RlZENvb3JkcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJUYXJnZXRDaGVjaztcbiAgfVxuICByZW1vdmVBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZU9iamVjdHMgPSBbXSwgdGhpcy5yZW1vdmUoLi4udGhpcy5fb2JqZWN0cyk7XG4gIH1cbiAgX19vYmplY3RTZWxlY3Rpb25Nb25pdG9yKHQsIGUpIHtcbiAgICBsZXQgeyB0YXJnZXQ6IHMgfSA9IGU7XG4gICAgY29uc3QgciA9IHRoaXMuX2FjdGl2ZU9iamVjdHM7XG4gICAgaWYgKHQpIHIucHVzaChzKSwgdGhpcy5fc2V0KFwiZGlydHlcIiwgITApO1xuICAgIGVsc2UgaWYgKHIubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbiA9IHIuaW5kZXhPZihzKTtcbiAgICAgIG4gPiAtMSAmJiAoci5zcGxpY2UobiwgMSksIHRoaXMuX3NldChcImRpcnR5XCIsICEwKSk7XG4gICAgfVxuICB9XG4gIF93YXRjaE9iamVjdCh0LCBlKSB7XG4gICAgdCAmJiB0aGlzLl93YXRjaE9iamVjdCghMSwgZSksIHQgPyAoZS5vbihcInNlbGVjdGVkXCIsIHRoaXMuX19vYmplY3RTZWxlY3Rpb25UcmFja2VyKSwgZS5vbihcImRlc2VsZWN0ZWRcIiwgdGhpcy5fX29iamVjdFNlbGVjdGlvbkRpc3Bvc2VyKSkgOiAoZS5vZmYoXCJzZWxlY3RlZFwiLCB0aGlzLl9fb2JqZWN0U2VsZWN0aW9uVHJhY2tlciksIGUub2ZmKFwiZGVzZWxlY3RlZFwiLCB0aGlzLl9fb2JqZWN0U2VsZWN0aW9uRGlzcG9zZXIpKTtcbiAgfVxuICBlbnRlckdyb3VwKHQsIGUpIHtcbiAgICB0Lmdyb3VwICYmIHQuZ3JvdXAucmVtb3ZlKHQpLCB0Ll9zZXQoXCJwYXJlbnRcIiwgdGhpcyksIHRoaXMuX2VudGVyR3JvdXAodCwgZSk7XG4gIH1cbiAgX2VudGVyR3JvdXAodCwgZSkge1xuICAgIGUgJiYgX3ModCwgSihTdCh0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSksIHQuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKSksIHRoaXMuX3Nob3VsZFNldE5lc3RlZENvb3JkcygpICYmIHQuc2V0Q29vcmRzKCksIHQuX3NldChcImdyb3VwXCIsIHRoaXMpLCB0Ll9zZXQoXCJjYW52YXNcIiwgdGhpcy5jYW52YXMpLCB0aGlzLl93YXRjaE9iamVjdCghMCwgdCk7XG4gICAgY29uc3QgcyA9IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmdldEFjdGl2ZU9iamVjdCAmJiB0aGlzLmNhbnZhcy5nZXRBY3RpdmVPYmplY3QoKTtcbiAgICBzICYmIChzID09PSB0IHx8IHQuaXNEZXNjZW5kYW50T2YocykpICYmIHRoaXMuX2FjdGl2ZU9iamVjdHMucHVzaCh0KTtcbiAgfVxuICBleGl0R3JvdXAodCwgZSkge1xuICAgIHRoaXMuX2V4aXRHcm91cCh0LCBlKSwgdC5fc2V0KFwicGFyZW50XCIsIHZvaWQgMCksIHQuX3NldChcImNhbnZhc1wiLCB2b2lkIDApO1xuICB9XG4gIF9leGl0R3JvdXAodCwgZSkge1xuICAgIHQuX3NldChcImdyb3VwXCIsIHZvaWQgMCksIGUgfHwgKF9zKHQsIEoodGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCksIHQuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKSksIHQuc2V0Q29vcmRzKCkpLCB0aGlzLl93YXRjaE9iamVjdCghMSwgdCk7XG4gICAgY29uc3QgcyA9IHRoaXMuX2FjdGl2ZU9iamVjdHMubGVuZ3RoID4gMCA/IHRoaXMuX2FjdGl2ZU9iamVjdHMuaW5kZXhPZih0KSA6IC0xO1xuICAgIHMgPiAtMSAmJiB0aGlzLl9hY3RpdmVPYmplY3RzLnNwbGljZShzLCAxKTtcbiAgfVxuICBzaG91bGRDYWNoZSgpIHtcbiAgICBjb25zdCB0ID0gbnQucHJvdG90eXBlLnNob3VsZENhY2hlLmNhbGwodGhpcyk7XG4gICAgaWYgKHQpIHtcbiAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGUrKykgaWYgKHRoaXMuX29iamVjdHNbZV0ud2lsbERyYXdTaGFkb3coKSkgcmV0dXJuIHRoaXMub3duQ2FjaGluZyA9ICExLCAhMTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgd2lsbERyYXdTaGFkb3coKSB7XG4gICAgaWYgKHN1cGVyLndpbGxEcmF3U2hhZG93KCkpIHJldHVybiAhMDtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMuX29iamVjdHMubGVuZ3RoOyB0KyspIGlmICh0aGlzLl9vYmplY3RzW3RdLndpbGxEcmF3U2hhZG93KCkpIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgaXNPbkFDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vd25DYWNoaW5nIHx8ICEhdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNPbkFDYWNoZSgpO1xuICB9XG4gIGRyYXdPYmplY3QodCwgZSwgcykge1xuICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQodCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0aGlzLl9vYmplY3RzLmxlbmd0aDsgbisrKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLl9vYmplY3RzW25dO1xuICAgICAgKHIgPSB0aGlzLmNhbnZhcykgIT09IG51bGwgJiYgciAhPT0gdm9pZCAwICYmIHIucHJlc2VydmVPYmplY3RTdGFja2luZyAmJiBvLmdyb3VwICE9PSB0aGlzID8gKHQuc2F2ZSgpLCB0LnRyYW5zZm9ybSguLi5TdCh0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSkpLCBvLnJlbmRlcih0KSwgdC5yZXN0b3JlKCkpIDogby5ncm91cCA9PT0gdGhpcyAmJiBvLnJlbmRlcih0KTtcbiAgICB9XG4gICAgdGhpcy5fZHJhd0NsaXBQYXRoKHQsIHRoaXMuY2xpcFBhdGgsIHMpO1xuICB9XG4gIHNldENvb3JkcygpIHtcbiAgICBzdXBlci5zZXRDb29yZHMoKSwgdGhpcy5fc2hvdWxkU2V0TmVzdGVkQ29vcmRzKCkgJiYgdGhpcy5mb3JFYWNoT2JqZWN0KCh0KSA9PiB0LnNldENvb3JkcygpKTtcbiAgfVxuICB0cmlnZ2VyTGF5b3V0KCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB0aGlzLmxheW91dE1hbmFnZXIucGVyZm9ybUxheW91dCh2KHsgdGFyZ2V0OiB0aGlzLCB0eXBlOiBzaSB9LCB0KSk7XG4gIH1cbiAgcmVuZGVyKHQpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gITAsIHN1cGVyLnJlbmRlcih0KSwgdGhpcy5fdHJhbnNmb3JtRG9uZSA9ICExO1xuICB9XG4gIF9fc2VyaWFsaXplT2JqZWN0cyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiAhci5leGNsdWRlRnJvbUV4cG9ydDtcbiAgICB9KS5tYXAoZnVuY3Rpb24ocikge1xuICAgICAgY29uc3QgbiA9IHIuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICByLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gcztcbiAgICAgIGNvbnN0IG8gPSByW3QgfHwgXCJ0b09iamVjdFwiXShlKTtcbiAgICAgIHJldHVybiByLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gbiwgbztcbiAgICB9KTtcbiAgfVxuICB0b09iamVjdCgpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgY29uc3QgZSA9IHRoaXMubGF5b3V0TWFuYWdlci50b09iamVjdCgpO1xuICAgIHJldHVybiB2KHYodih7fSwgc3VwZXIudG9PYmplY3QoW1wic3ViVGFyZ2V0Q2hlY2tcIiwgXCJpbnRlcmFjdGl2ZVwiLCAuLi50XSkpLCBlLnN0cmF0ZWd5ICE9PSBcImZpdC1jb250ZW50XCIgfHwgdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcyA/IHsgbGF5b3V0TWFuYWdlcjogZSB9IDoge30pLCB7fSwgeyBvYmplY3RzOiB0aGlzLl9fc2VyaWFsaXplT2JqZWN0cyhcInRvT2JqZWN0XCIsIHQpIH0pO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIiM8R3JvdXA6IChcIi5jb25jYXQodGhpcy5jb21wbGV4aXR5KCksIFwiKT5cIik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmxheW91dE1hbmFnZXIudW5zdWJzY3JpYmVUYXJnZXRzKHsgdGFyZ2V0czogdGhpcy5nZXRPYmplY3RzKCksIHRhcmdldDogdGhpcyB9KSwgdGhpcy5fYWN0aXZlT2JqZWN0cyA9IFtdLCB0aGlzLmZvckVhY2hPYmplY3QoKHQpID0+IHtcbiAgICAgIHRoaXMuX3dhdGNoT2JqZWN0KCExLCB0KSwgdC5kaXNwb3NlKCk7XG4gICAgfSksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBfY3JlYXRlU1ZHQmdSZWN0KHQpIHtcbiAgICBpZiAoIXRoaXMuYmFja2dyb3VuZENvbG9yKSByZXR1cm4gXCJcIjtcbiAgICBjb25zdCBlID0gWC5wcm90b3R5cGUuX3RvU1ZHLmNhbGwodGhpcyksIHMgPSBlLmluZGV4T2YoXCJDT01NT05fUEFSVFNcIik7XG4gICAgZVtzXSA9ICdmb3I9XCJncm91cFwiICc7XG4gICAgY29uc3QgciA9IGUuam9pbihcIlwiKTtcbiAgICByZXR1cm4gdCA/IHQocikgOiByO1xuICB9XG4gIF90b1NWRyh0KSB7XG4gICAgY29uc3QgZSA9IFtcIjxnIFwiLCBcIkNPTU1PTl9QQVJUU1wiLCBgID5cbmBdLCBzID0gdGhpcy5fY3JlYXRlU1ZHQmdSZWN0KHQpO1xuICAgIHMgJiYgZS5wdXNoKFwiXHRcdFwiLCBzKTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHRoaXMuX29iamVjdHMubGVuZ3RoOyByKyspIGUucHVzaChcIlx0XHRcIiwgdGhpcy5fb2JqZWN0c1tyXS50b1NWRyh0KSk7XG4gICAgcmV0dXJuIGUucHVzaChgPC9nPlxuYCksIGU7XG4gIH1cbiAgZ2V0U3ZnU3R5bGVzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wYWNpdHkgIT09IHZvaWQgMCAmJiB0aGlzLm9wYWNpdHkgIT09IDEgPyBcIm9wYWNpdHk6IFwiLmNvbmNhdCh0aGlzLm9wYWNpdHksIFwiO1wiKSA6IFwiXCIsIGUgPSB0aGlzLnZpc2libGUgPyBcIlwiIDogXCIgdmlzaWJpbGl0eTogaGlkZGVuO1wiO1xuICAgIHJldHVybiBbdCwgdGhpcy5nZXRTdmdGaWx0ZXIoKSwgZV0uam9pbihcIlwiKTtcbiAgfVxuICB0b0NsaXBQYXRoU1ZHKHQpIHtcbiAgICBjb25zdCBlID0gW10sIHMgPSB0aGlzLl9jcmVhdGVTVkdCZ1JlY3QodCk7XG4gICAgcyAmJiBlLnB1c2goXCJcdFwiLCBzKTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHRoaXMuX29iamVjdHMubGVuZ3RoOyByKyspIGUucHVzaChcIlx0XCIsIHRoaXMuX29iamVjdHNbcl0udG9DbGlwUGF0aFNWRyh0KSk7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cChlLCB7IHJldml2ZXI6IHQgfSk7XG4gIH1cbiAgc3RhdGljIGZyb21PYmplY3QodCwgZSkge1xuICAgIGxldCB7IHR5cGU6IHMsIG9iamVjdHM6IHIgPSBbXSwgbGF5b3V0TWFuYWdlcjogbiB9ID0gdCwgbyA9IEcodCwgV3UpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbYnMociwgZSksIGNyKG8sIGUpXSkudGhlbigoYSkgPT4ge1xuICAgICAgbGV0IFtjLCBsXSA9IGE7XG4gICAgICBjb25zdCBoID0gbmV3IHRoaXMoYywgdih2KHYoe30sIG8pLCBsKSwge30sIHsgbGF5b3V0TWFuYWdlcjogbmV3IFh1KCkgfSkpO1xuICAgICAgaWYgKG4pIHtcbiAgICAgICAgY29uc3QgdSA9IEMuZ2V0Q2xhc3Mobi50eXBlKSwgZCA9IEMuZ2V0Q2xhc3Mobi5zdHJhdGVneSk7XG4gICAgICAgIGgubGF5b3V0TWFuYWdlciA9IG5ldyB1KG5ldyBkKCkpO1xuICAgICAgfSBlbHNlIGgubGF5b3V0TWFuYWdlciA9IG5ldyBacygpO1xuICAgICAgcmV0dXJuIGgubGF5b3V0TWFuYWdlci5zdWJzY3JpYmVUYXJnZXRzKHsgdHlwZTogbmUsIHRhcmdldDogaCwgdGFyZ2V0czogaC5nZXRPYmplY3RzKCkgfSksIGguc2V0Q29vcmRzKCksIGg7XG4gICAgfSk7XG4gIH1cbn1cbnkoTnQsIFwidHlwZVwiLCBcIkdyb3VwXCIpLCB5KE50LCBcIm93bkRlZmF1bHRzXCIsIHsgc3Ryb2tlV2lkdGg6IDAsIHN1YlRhcmdldENoZWNrOiAhMSwgaW50ZXJhY3RpdmU6ICExIH0pLCBDLnNldENsYXNzKE50KTtcbmNvbnN0IExjID0gKGksIHQpID0+IE1hdGgubWluKHQud2lkdGggLyBpLndpZHRoLCB0LmhlaWdodCAvIGkuaGVpZ2h0KSwgQmMgPSAoaSwgdCkgPT4gTWF0aC5tYXgodC53aWR0aCAvIGkud2lkdGgsIHQuaGVpZ2h0IC8gaS5oZWlnaHQpLCBwbiA9IFwiXFxcXHMqLD9cXFxccypcIiwgRnMgPSBcIlwiLmNvbmNhdChwbiwgXCIoXCIpLmNvbmNhdChYZSwgXCIpXCIpLCB6dSA9IFwiXCIuY29uY2F0KEZzKS5jb25jYXQoRnMpLmNvbmNhdChGcykuY29uY2F0KHBuLCBcIihbMDFdKVwiKS5jb25jYXQocG4sIFwiKFswMV0pXCIpLmNvbmNhdChGcykuY29uY2F0KEZzKSwgSHUgPSB7IG06IFwibFwiLCBNOiBcIkxcIiB9LCBZdSA9IChpLCB0LCBlLCBzLCByLCBuLCBvLCBhLCBjLCBsLCBoKSA9PiB7XG4gIGNvbnN0IHUgPSBMdChpKSwgZCA9IEJ0KGkpLCBmID0gTHQodCksIGcgPSBCdCh0KSwgcCA9IGUgKiByICogZiAtIHMgKiBuICogZyArIG8sIG0gPSBzICogciAqIGYgKyBlICogbiAqIGcgKyBhO1xuICByZXR1cm4gW1wiQ1wiLCBsICsgYyAqICgtZSAqIHIgKiBkIC0gcyAqIG4gKiB1KSwgaCArIGMgKiAoLXMgKiByICogZCArIGUgKiBuICogdSksIHAgKyBjICogKGUgKiByICogZyArIHMgKiBuICogZiksIG0gKyBjICogKHMgKiByICogZyAtIGUgKiBuICogZiksIHAsIG1dO1xufSwgV28gPSAoaSwgdCwgZSwgcykgPT4ge1xuICBjb25zdCByID0gTWF0aC5hdGFuMih0LCBpKSwgbiA9IE1hdGguYXRhbjIocywgZSk7XG4gIHJldHVybiBuID49IHIgPyBuIC0gciA6IDIgKiBNYXRoLlBJIC0gKHIgLSBuKTtcbn07XG5mdW5jdGlvbiBtbihpLCB0LCBlLCBzLCByLCBuLCBvLCBhKSB7XG4gIGxldCBjO1xuICBpZiAoQS5jYWNoZXNCb3VuZHNPZkN1cnZlICYmIChjID0gWy4uLmFyZ3VtZW50c10uam9pbigpLCB6cy5ib3VuZHNPZkN1cnZlQ2FjaGVbY10pKSByZXR1cm4genMuYm91bmRzT2ZDdXJ2ZUNhY2hlW2NdO1xuICBjb25zdCBsID0gTWF0aC5zcXJ0LCBoID0gTWF0aC5hYnMsIHUgPSBbXSwgZCA9IFtbMCwgMF0sIFswLCAwXV07XG4gIGxldCBmID0gNiAqIGkgLSAxMiAqIGUgKyA2ICogciwgZyA9IC0zICogaSArIDkgKiBlIC0gOSAqIHIgKyAzICogbywgcCA9IDMgKiBlIC0gMyAqIGk7XG4gIGZvciAobGV0IGsgPSAwOyBrIDwgMjsgKytrKSB7XG4gICAgaWYgKGsgPiAwICYmIChmID0gNiAqIHQgLSAxMiAqIHMgKyA2ICogbiwgZyA9IC0zICogdCArIDkgKiBzIC0gOSAqIG4gKyAzICogYSwgcCA9IDMgKiBzIC0gMyAqIHQpLCBoKGcpIDwgMWUtMTIpIHtcbiAgICAgIGlmIChoKGYpIDwgMWUtMTIpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgRSA9IC1wIC8gZjtcbiAgICAgIDAgPCBFICYmIEUgPCAxICYmIHUucHVzaChFKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBPID0gZiAqIGYgLSA0ICogcCAqIGc7XG4gICAgaWYgKE8gPCAwKSBjb250aW51ZTtcbiAgICBjb25zdCB4ID0gbChPKSwgSSA9ICgtZiArIHgpIC8gKDIgKiBnKTtcbiAgICAwIDwgSSAmJiBJIDwgMSAmJiB1LnB1c2goSSk7XG4gICAgY29uc3QgTSA9ICgtZiAtIHgpIC8gKDIgKiBnKTtcbiAgICAwIDwgTSAmJiBNIDwgMSAmJiB1LnB1c2goTSk7XG4gIH1cbiAgbGV0IG0gPSB1Lmxlbmd0aDtcbiAgY29uc3QgYiA9IG0sIFMgPSBYYyhpLCB0LCBlLCBzLCByLCBuLCBvLCBhKTtcbiAgZm9yICg7IG0tLTsgKSB7XG4gICAgY29uc3QgeyB4OiBrLCB5OiBPIH0gPSBTKHVbbV0pO1xuICAgIGRbMF1bbV0gPSBrLCBkWzFdW21dID0gTztcbiAgfVxuICBkWzBdW2JdID0gaSwgZFsxXVtiXSA9IHQsIGRbMF1bYiArIDFdID0gbywgZFsxXVtiICsgMV0gPSBhO1xuICBjb25zdCB3ID0gW25ldyBfKE1hdGgubWluKC4uLmRbMF0pLCBNYXRoLm1pbiguLi5kWzFdKSksIG5ldyBfKE1hdGgubWF4KC4uLmRbMF0pLCBNYXRoLm1heCguLi5kWzFdKSldO1xuICByZXR1cm4gQS5jYWNoZXNCb3VuZHNPZkN1cnZlICYmICh6cy5ib3VuZHNPZkN1cnZlQ2FjaGVbY10gPSB3KSwgdztcbn1cbmNvbnN0IFZ1ID0gKGksIHQsIGUpID0+IHtcbiAgbGV0IFtzLCByLCBuLCBvLCBhLCBjLCBsLCBoXSA9IGU7XG4gIGNvbnN0IHUgPSAoKGQsIGYsIGcsIHAsIG0sIGIsIFMpID0+IHtcbiAgICBpZiAoZyA9PT0gMCB8fCBwID09PSAwKSByZXR1cm4gW107XG4gICAgbGV0IHcgPSAwLCBrID0gMCwgTyA9IDA7XG4gICAgY29uc3QgeCA9IE1hdGguUEksIEkgPSBTICogam4sIE0gPSBCdChJKSwgRSA9IEx0KEkpLCBSID0gMC41ICogKC1FICogZCAtIE0gKiBmKSwgdHQgPSAwLjUgKiAoLUUgKiBmICsgTSAqIGQpLCBGID0gZyAqKiAyLCBCID0gcCAqKiAyLCAkID0gdHQgKiogMiwgeXQgPSBSICoqIDIsIGR0ID0gRiAqIEIgLSBGICogJCAtIEIgKiB5dDtcbiAgICBsZXQgRHQgPSBNYXRoLmFicyhnKSwgcSA9IE1hdGguYWJzKHApO1xuICAgIGlmIChkdCA8IDApIHtcbiAgICAgIGNvbnN0IHZlID0gTWF0aC5zcXJ0KDEgLSBkdCAvIChGICogQikpO1xuICAgICAgRHQgKj0gdmUsIHEgKj0gdmU7XG4gICAgfSBlbHNlIE8gPSAobSA9PT0gYiA/IC0xIDogMSkgKiBNYXRoLnNxcnQoZHQgLyAoRiAqICQgKyBCICogeXQpKTtcbiAgICBjb25zdCB6dCA9IE8gKiBEdCAqIHR0IC8gcSwgdGUgPSAtTyAqIHEgKiBSIC8gRHQsIHByID0gRSAqIHp0IC0gTSAqIHRlICsgMC41ICogZCwgQWkgPSBNICogenQgKyBFICogdGUgKyAwLjUgKiBmO1xuICAgIGxldCBQcyA9IFdvKDEsIDAsIChSIC0genQpIC8gRHQsICh0dCAtIHRlKSAvIHEpLCBtZSA9IFdvKChSIC0genQpIC8gRHQsICh0dCAtIHRlKSAvIHEsICgtUiAtIHp0KSAvIER0LCAoLXR0IC0gdGUpIC8gcSk7XG4gICAgYiA9PT0gMCAmJiBtZSA+IDAgPyBtZSAtPSAyICogeCA6IGIgPT09IDEgJiYgbWUgPCAwICYmIChtZSArPSAyICogeCk7XG4gICAgY29uc3QgbXIgPSBNYXRoLmNlaWwoTWF0aC5hYnMobWUgLyB4ICogMikpLCBqZSA9IFtdLCBBcyA9IG1lIC8gbXIsIEFoID0gOCAvIDMgKiBNYXRoLnNpbihBcyAvIDQpICogTWF0aC5zaW4oQXMgLyA0KSAvIE1hdGguc2luKEFzIC8gMik7XG4gICAgbGV0IEZpID0gUHMgKyBBcztcbiAgICBmb3IgKGxldCB2ZSA9IDA7IHZlIDwgbXI7IHZlKyspIGplW3ZlXSA9IFl1KFBzLCBGaSwgRSwgTSwgRHQsIHEsIHByLCBBaSwgQWgsIHcsIGspLCB3ID0gamVbdmVdWzVdLCBrID0gamVbdmVdWzZdLCBQcyA9IEZpLCBGaSArPSBBcztcbiAgICByZXR1cm4gamU7XG4gIH0pKGwgLSBpLCBoIC0gdCwgciwgbiwgYSwgYywgbyk7XG4gIGZvciAobGV0IGQgPSAwLCBmID0gdS5sZW5ndGg7IGQgPCBmOyBkKyspIHVbZF1bMV0gKz0gaSwgdVtkXVsyXSArPSB0LCB1W2RdWzNdICs9IGksIHVbZF1bNF0gKz0gdCwgdVtkXVs1XSArPSBpLCB1W2RdWzZdICs9IHQ7XG4gIHJldHVybiB1O1xufSwgV2MgPSAoaSkgPT4ge1xuICBsZXQgdCA9IDAsIGUgPSAwLCBzID0gMCwgciA9IDA7XG4gIGNvbnN0IG4gPSBbXTtcbiAgbGV0IG8sIGEgPSAwLCBjID0gMDtcbiAgZm9yIChjb25zdCBsIG9mIGkpIHtcbiAgICBjb25zdCBoID0gWy4uLmxdO1xuICAgIGxldCB1O1xuICAgIHN3aXRjaCAoaFswXSkge1xuICAgICAgY2FzZSBcImxcIjpcbiAgICAgICAgaFsxXSArPSB0LCBoWzJdICs9IGU7XG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgICB0ID0gaFsxXSwgZSA9IGhbMl0sIHUgPSBbXCJMXCIsIHQsIGVdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgIGhbMV0gKz0gdDtcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHQgPSBoWzFdLCB1ID0gW1wiTFwiLCB0LCBlXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidlwiOlxuICAgICAgICBoWzFdICs9IGU7XG4gICAgICBjYXNlIFwiVlwiOlxuICAgICAgICBlID0gaFsxXSwgdSA9IFtcIkxcIiwgdCwgZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgaFsxXSArPSB0LCBoWzJdICs9IGU7XG4gICAgICBjYXNlIFwiTVwiOlxuICAgICAgICB0ID0gaFsxXSwgZSA9IGhbMl0sIHMgPSBoWzFdLCByID0gaFsyXSwgdSA9IFtcIk1cIiwgdCwgZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgaFsxXSArPSB0LCBoWzJdICs9IGUsIGhbM10gKz0gdCwgaFs0XSArPSBlLCBoWzVdICs9IHQsIGhbNl0gKz0gZTtcbiAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgIGEgPSBoWzNdLCBjID0gaFs0XSwgdCA9IGhbNV0sIGUgPSBoWzZdLCB1ID0gW1wiQ1wiLCBoWzFdLCBoWzJdLCBhLCBjLCB0LCBlXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICBoWzFdICs9IHQsIGhbMl0gKz0gZSwgaFszXSArPSB0LCBoWzRdICs9IGU7XG4gICAgICBjYXNlIFwiU1wiOlxuICAgICAgICBvID09PSBcIkNcIiA/IChhID0gMiAqIHQgLSBhLCBjID0gMiAqIGUgLSBjKSA6IChhID0gdCwgYyA9IGUpLCB0ID0gaFszXSwgZSA9IGhbNF0sIHUgPSBbXCJDXCIsIGEsIGMsIGhbMV0sIGhbMl0sIHQsIGVdLCBhID0gdVszXSwgYyA9IHVbNF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgaFsxXSArPSB0LCBoWzJdICs9IGUsIGhbM10gKz0gdCwgaFs0XSArPSBlO1xuICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgYSA9IGhbMV0sIGMgPSBoWzJdLCB0ID0gaFszXSwgZSA9IGhbNF0sIHUgPSBbXCJRXCIsIGEsIGMsIHQsIGVdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgIGhbMV0gKz0gdCwgaFsyXSArPSBlO1xuICAgICAgY2FzZSBcIlRcIjpcbiAgICAgICAgbyA9PT0gXCJRXCIgPyAoYSA9IDIgKiB0IC0gYSwgYyA9IDIgKiBlIC0gYykgOiAoYSA9IHQsIGMgPSBlKSwgdCA9IGhbMV0sIGUgPSBoWzJdLCB1ID0gW1wiUVwiLCBhLCBjLCB0LCBlXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYVwiOlxuICAgICAgICBoWzZdICs9IHQsIGhbN10gKz0gZTtcbiAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgIFZ1KHQsIGUsIGgpLmZvckVhY2goKGQpID0+IG4ucHVzaChkKSksIHQgPSBoWzZdLCBlID0gaFs3XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwielwiOlxuICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgdCA9IHMsIGUgPSByLCB1ID0gW1wiWlwiXTtcbiAgICB9XG4gICAgdSA/IChuLnB1c2godSksIG8gPSB1WzBdKSA6IG8gPSBcIlwiO1xuICB9XG4gIHJldHVybiBuO1xufSwgcmkgPSAoaSwgdCwgZSwgcykgPT4gTWF0aC5zcXJ0KChlIC0gaSkgKiogMiArIChzIC0gdCkgKiogMiksIFhjID0gKGksIHQsIGUsIHMsIHIsIG4sIG8sIGEpID0+IChjKSA9PiB7XG4gIGNvbnN0IGwgPSBjICoqIDMsIGggPSAoKGYpID0+IDMgKiBmICoqIDIgKiAoMSAtIGYpKShjKSwgdSA9ICgoZikgPT4gMyAqIGYgKiAoMSAtIGYpICoqIDIpKGMpLCBkID0gKChmKSA9PiAoMSAtIGYpICoqIDMpKGMpO1xuICByZXR1cm4gbmV3IF8obyAqIGwgKyByICogaCArIGUgKiB1ICsgaSAqIGQsIGEgKiBsICsgbiAqIGggKyBzICogdSArIHQgKiBkKTtcbn0sIHpjID0gKGkpID0+IGkgKiogMiwgSGMgPSAoaSkgPT4gMiAqIGkgKiAoMSAtIGkpLCBZYyA9IChpKSA9PiAoMSAtIGkpICoqIDIsIEd1ID0gKGksIHQsIGUsIHMsIHIsIG4sIG8sIGEpID0+IChjKSA9PiB7XG4gIGNvbnN0IGwgPSB6YyhjKSwgaCA9IEhjKGMpLCB1ID0gWWMoYyksIGQgPSAzICogKHUgKiAoZSAtIGkpICsgaCAqIChyIC0gZSkgKyBsICogKG8gLSByKSksIGYgPSAzICogKHUgKiAocyAtIHQpICsgaCAqIChuIC0gcykgKyBsICogKGEgLSBuKSk7XG4gIHJldHVybiBNYXRoLmF0YW4yKGYsIGQpO1xufSwgTnUgPSAoaSwgdCwgZSwgcywgciwgbikgPT4gKG8pID0+IHtcbiAgY29uc3QgYSA9IHpjKG8pLCBjID0gSGMobyksIGwgPSBZYyhvKTtcbiAgcmV0dXJuIG5ldyBfKHIgKiBhICsgZSAqIGMgKyBpICogbCwgbiAqIGEgKyBzICogYyArIHQgKiBsKTtcbn0sIFV1ID0gKGksIHQsIGUsIHMsIHIsIG4pID0+IChvKSA9PiB7XG4gIGNvbnN0IGEgPSAxIC0gbywgYyA9IDIgKiAoYSAqIChlIC0gaSkgKyBvICogKHIgLSBlKSksIGwgPSAyICogKGEgKiAocyAtIHQpICsgbyAqIChuIC0gcykpO1xuICByZXR1cm4gTWF0aC5hdGFuMihsLCBjKTtcbn0sIFhvID0gKGksIHQsIGUpID0+IHtcbiAgbGV0IHMgPSBuZXcgXyh0LCBlKSwgciA9IDA7XG4gIGZvciAobGV0IG4gPSAxOyBuIDw9IDEwMDsgbiArPSAxKSB7XG4gICAgY29uc3QgbyA9IGkobiAvIDEwMCk7XG4gICAgciArPSByaShzLngsIHMueSwgby54LCBvLnkpLCBzID0gbztcbiAgfVxuICByZXR1cm4gcjtcbn0sICR1ID0gKGksIHQpID0+IHtcbiAgbGV0IGUsIHMgPSAwLCByID0gMCwgbiA9IHsgeDogaS54LCB5OiBpLnkgfSwgbyA9IHYoe30sIG4pLCBhID0gMC4wMSwgYyA9IDA7XG4gIGNvbnN0IGwgPSBpLml0ZXJhdG9yLCBoID0gaS5hbmdsZUZpbmRlcjtcbiAgZm9yICg7IHIgPCB0ICYmIGEgPiAxZS00OyApIG8gPSBsKHMpLCBjID0gcywgZSA9IHJpKG4ueCwgbi55LCBvLngsIG8ueSksIGUgKyByID4gdCA/IChzIC09IGEsIGEgLz0gMikgOiAobiA9IG8sIHMgKz0gYSwgciArPSBlKTtcbiAgcmV0dXJuIHYodih7fSwgbyksIHt9LCB7IGFuZ2xlOiBoKGMpIH0pO1xufSwgUW4gPSAoaSkgPT4ge1xuICBsZXQgdCwgZSwgcyA9IDAsIHIgPSAwLCBuID0gMCwgbyA9IDAsIGEgPSAwO1xuICBjb25zdCBjID0gW107XG4gIGZvciAoY29uc3QgbCBvZiBpKSB7XG4gICAgY29uc3QgaCA9IHsgeDogciwgeTogbiwgY29tbWFuZDogbFswXSwgbGVuZ3RoOiAwIH07XG4gICAgc3dpdGNoIChsWzBdKSB7XG4gICAgICBjYXNlIFwiTVwiOlxuICAgICAgICBlID0gaCwgZS54ID0gbyA9IHIgPSBsWzFdLCBlLnkgPSBhID0gbiA9IGxbMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgZSA9IGgsIGUubGVuZ3RoID0gcmkociwgbiwgbFsxXSwgbFsyXSksIHIgPSBsWzFdLCBuID0gbFsyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQ1wiOlxuICAgICAgICB0ID0gWGMociwgbiwgbFsxXSwgbFsyXSwgbFszXSwgbFs0XSwgbFs1XSwgbFs2XSksIGUgPSBoLCBlLml0ZXJhdG9yID0gdCwgZS5hbmdsZUZpbmRlciA9IEd1KHIsIG4sIGxbMV0sIGxbMl0sIGxbM10sIGxbNF0sIGxbNV0sIGxbNl0pLCBlLmxlbmd0aCA9IFhvKHQsIHIsIG4pLCByID0gbFs1XSwgbiA9IGxbNl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgdCA9IE51KHIsIG4sIGxbMV0sIGxbMl0sIGxbM10sIGxbNF0pLCBlID0gaCwgZS5pdGVyYXRvciA9IHQsIGUuYW5nbGVGaW5kZXIgPSBVdShyLCBuLCBsWzFdLCBsWzJdLCBsWzNdLCBsWzRdKSwgZS5sZW5ndGggPSBYbyh0LCByLCBuKSwgciA9IGxbM10sIG4gPSBsWzRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgIGUgPSBoLCBlLmRlc3RYID0gbywgZS5kZXN0WSA9IGEsIGUubGVuZ3RoID0gcmkociwgbiwgbywgYSksIHIgPSBvLCBuID0gYTtcbiAgICB9XG4gICAgcyArPSBlLmxlbmd0aCwgYy5wdXNoKGUpO1xuICB9XG4gIHJldHVybiBjLnB1c2goeyBsZW5ndGg6IHMsIHg6IHIsIHk6IG4gfSksIGM7XG59LCBWYyA9IGZ1bmN0aW9uKGksIHQpIHtcbiAgbGV0IGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IFFuKGkpLCBzID0gMDtcbiAgZm9yICg7IHQgLSBlW3NdLmxlbmd0aCA+IDAgJiYgcyA8IGUubGVuZ3RoIC0gMjsgKSB0IC09IGVbc10ubGVuZ3RoLCBzKys7XG4gIGNvbnN0IHIgPSBlW3NdLCBuID0gdCAvIHIubGVuZ3RoLCBvID0gaVtzXTtcbiAgc3dpdGNoIChyLmNvbW1hbmQpIHtcbiAgICBjYXNlIFwiTVwiOlxuICAgICAgcmV0dXJuIHsgeDogci54LCB5OiByLnksIGFuZ2xlOiAwIH07XG4gICAgY2FzZSBcIlpcIjpcbiAgICAgIHJldHVybiB2KHYoe30sIG5ldyBfKHIueCwgci55KS5sZXJwKG5ldyBfKHIuZGVzdFgsIHIuZGVzdFkpLCBuKSksIHt9LCB7IGFuZ2xlOiBNYXRoLmF0YW4yKHIuZGVzdFkgLSByLnksIHIuZGVzdFggLSByLngpIH0pO1xuICAgIGNhc2UgXCJMXCI6XG4gICAgICByZXR1cm4gdih2KHt9LCBuZXcgXyhyLngsIHIueSkubGVycChuZXcgXyhvWzFdLCBvWzJdKSwgbikpLCB7fSwgeyBhbmdsZTogTWF0aC5hdGFuMihvWzJdIC0gci55LCBvWzFdIC0gci54KSB9KTtcbiAgICBjYXNlIFwiQ1wiOlxuICAgIGNhc2UgXCJRXCI6XG4gICAgICByZXR1cm4gJHUociwgdCk7XG4gIH1cbn0sIHF1ID0gbmV3IFJlZ0V4cChcIlttemxodmNzcXRhXVtebXpsaHZjc3F0YV0qXCIsIFwiZ2lcIiksIHpvID0gbmV3IFJlZ0V4cCh6dSwgXCJnXCIpLCBLdSA9IG5ldyBSZWdFeHAoWGUsIFwiZ2lcIiksIEp1ID0geyBtOiAyLCBsOiAyLCBoOiAxLCB2OiAxLCBjOiA2LCBzOiA0LCBxOiA0LCB0OiAyLCBhOiA3IH0sIEdjID0gKGkpID0+IHtcbiAgdmFyIHQ7XG4gIGNvbnN0IGUgPSBbXSwgcyA9ICh0ID0gaS5tYXRjaChxdSkpICE9PSBudWxsICYmIHQgIT09IHZvaWQgMCA/IHQgOiBbXTtcbiAgZm9yIChjb25zdCByIG9mIHMpIHtcbiAgICBjb25zdCBuID0gclswXTtcbiAgICBpZiAobiA9PT0gXCJ6XCIgfHwgbiA9PT0gXCJaXCIpIHtcbiAgICAgIGUucHVzaChbbl0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG8gPSBKdVtuLnRvTG93ZXJDYXNlKCldO1xuICAgIGxldCBhID0gW107XG4gICAgaWYgKG4gPT09IFwiYVwiIHx8IG4gPT09IFwiQVwiKSB7XG4gICAgICB6by5sYXN0SW5kZXggPSAwO1xuICAgICAgZm9yIChsZXQgYyA9IG51bGw7IGMgPSB6by5leGVjKHIpOyApIGEucHVzaCguLi5jLnNsaWNlKDEpKTtcbiAgICB9IGVsc2UgYSA9IHIubWF0Y2goS3UpIHx8IFtdO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYS5sZW5ndGg7IGMgKz0gbykge1xuICAgICAgY29uc3QgbCA9IG5ldyBBcnJheShvKSwgaCA9IEh1W25dO1xuICAgICAgbFswXSA9IGMgPiAwICYmIGggPyBoIDogbjtcbiAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgbzsgdSsrKSBsW3UgKyAxXSA9IHBhcnNlRmxvYXQoYVtjICsgdV0pO1xuICAgICAgZS5wdXNoKGwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZTtcbn0sIFp1ID0gZnVuY3Rpb24oaSkge1xuICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMCwgZSA9IG5ldyBfKGlbMF0pLCBzID0gbmV3IF8oaVsxXSksIHIgPSAxLCBuID0gMDtcbiAgY29uc3QgbyA9IFtdLCBhID0gaS5sZW5ndGgsIGMgPSBhID4gMjtcbiAgbGV0IGw7XG4gIGZvciAoYyAmJiAociA9IGlbMl0ueCA8IHMueCA/IC0xIDogaVsyXS54ID09PSBzLnggPyAwIDogMSwgbiA9IGlbMl0ueSA8IHMueSA/IC0xIDogaVsyXS55ID09PSBzLnkgPyAwIDogMSksIG8ucHVzaChbXCJNXCIsIGUueCAtIHIgKiB0LCBlLnkgLSBuICogdF0pLCBsID0gMTsgbCA8IGE7IGwrKykge1xuICAgIGlmICghZS5lcShzKSkge1xuICAgICAgY29uc3QgaCA9IGUubWlkUG9pbnRGcm9tKHMpO1xuICAgICAgby5wdXNoKFtcIlFcIiwgZS54LCBlLnksIGgueCwgaC55XSk7XG4gICAgfVxuICAgIGUgPSBpW2xdLCBsICsgMSA8IGkubGVuZ3RoICYmIChzID0gaVtsICsgMV0pO1xuICB9XG4gIHJldHVybiBjICYmIChyID0gZS54ID4gaVtsIC0gMl0ueCA/IDEgOiBlLnggPT09IGlbbCAtIDJdLnggPyAwIDogLTEsIG4gPSBlLnkgPiBpW2wgLSAyXS55ID8gMSA6IGUueSA9PT0gaVtsIC0gMl0ueSA/IDAgOiAtMSksIG8ucHVzaChbXCJMXCIsIGUueCArIHIgKiB0LCBlLnkgKyBuICogdF0pLCBvO1xufSwgTmMgPSAoaSwgdCkgPT4gaS5tYXAoKGUpID0+IGUubWFwKChzLCByKSA9PiByID09PSAwIHx8IHQgPT09IHZvaWQgMCA/IHMgOiBWKHMsIHQpKS5qb2luKFwiIFwiKSkuam9pbihcIiBcIik7XG5mdW5jdGlvbiBpaShpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLnN0eWxlO1xuICBlICYmIHQgJiYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBlLmNzc1RleHQgKz0gXCI7XCIgKyB0IDogT2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgocykgPT4ge1xuICAgIGxldCBbciwgbl0gPSBzO1xuICAgIHJldHVybiBlLnNldFByb3BlcnR5KHIsIG4pO1xuICB9KSk7XG59XG5jb25zdCBRdSA9IChpLCB0KSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAodCAtIGkgKyAxKSkgKyBpO1xuZnVuY3Rpb24gdGQoaSkge1xuICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gIGNvbnN0IGUgPSB0Lm9uQ29tcGxldGUgfHwgQmUsIHMgPSBuZXcgKGZpKCkpLlhNTEh0dHBSZXF1ZXN0KCksIHIgPSB0LnNpZ25hbCwgbiA9IGZ1bmN0aW9uKCkge1xuICAgIHMuYWJvcnQoKTtcbiAgfSwgbyA9IGZ1bmN0aW9uKCkge1xuICAgIHIgJiYgci5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbiksIHMub25lcnJvciA9IHMub250aW1lb3V0ID0gQmU7XG4gIH07XG4gIGlmIChyICYmIHIuYWJvcnRlZCkgdGhyb3cgbmV3IEZhKFwicmVxdWVzdFwiKTtcbiAgcmV0dXJuIHIgJiYgci5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbiwgeyBvbmNlOiAhMCB9KSwgcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBzLnJlYWR5U3RhdGUgPT09IDQgJiYgKG8oKSwgZShzKSwgcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBCZSk7XG4gIH0sIHMub25lcnJvciA9IHMub250aW1lb3V0ID0gbywgcy5vcGVuKFwiZ2V0XCIsIGksICEwKSwgcy5zZW5kKCksIHM7XG59XG5jb25zdCBlZCA9IChpLCB0KSA9PiB7XG4gIGxldCBlID0gaS5fZmluZENlbnRlckZyb21FbGVtZW50KCk7XG4gIGkudHJhbnNmb3JtTWF0cml4ICYmICgoKHMpID0+IHtcbiAgICBpZiAocy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgIGNvbnN0IHsgc2NhbGVYOiByLCBzY2FsZVk6IG4sIGFuZ2xlOiBvLCBza2V3WDogYSB9ID0geXMocy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgcy5mbGlwWCA9ICExLCBzLmZsaXBZID0gITEsIHMuc2V0KHV0LCByKSwgcy5zZXQoVHQsIG4pLCBzLmFuZ2xlID0gbywgcy5za2V3WCA9IGEsIHMuc2tld1kgPSAwO1xuICAgIH1cbiAgfSkoaSksIGUgPSBlLnRyYW5zZm9ybShpLnRyYW5zZm9ybU1hdHJpeCkpLCBkZWxldGUgaS50cmFuc2Zvcm1NYXRyaXgsIHQgJiYgKGkuc2NhbGVYICo9IHQuc2NhbGVYLCBpLnNjYWxlWSAqPSB0LnNjYWxlWSwgaS5jcm9wWCA9IHQuY3JvcFgsIGkuY3JvcFkgPSB0LmNyb3BZLCBlLnggKz0gdC5vZmZzZXRMZWZ0LCBlLnkgKz0gdC5vZmZzZXRUb3AsIGkud2lkdGggPSB0LndpZHRoLCBpLmhlaWdodCA9IHQuaGVpZ2h0KSwgaS5zZXRQb3NpdGlvbkJ5T3JpZ2luKGUsIGosIGopO1xufTtcbnZhciBzZCA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGFkZFRyYW5zZm9ybVRvT2JqZWN0OiBlYywgYW5pbWF0ZTogVW4sIGFuaW1hdGVDb2xvcjogZGMsIGFwcGx5VHJhbnNmb3JtVG9PYmplY3Q6IF9zLCBjYWxjQW5nbGVCZXR3ZWVuVmVjdG9yczogdGksIGNhbGNEaW1lbnNpb25zTWF0cml4OiBhciwgY2FsY1BsYW5lQ2hhbmdlTWF0cml4OiBociwgY2FsY1ZlY3RvclJvdGF0aW9uOiBsYywgY2FuY2VsQW5pbUZyYW1lOiBZYSwgY2FwVmFsdWU6IHplLCBjb21wb3NlTWF0cml4OiAkYSwgY29weUNhbnZhc0VsZW1lbnQ6IChpKSA9PiB7XG4gIHZhciB0O1xuICBjb25zdCBlID0gV3QoaSk7XG4gIHJldHVybiAodCA9IGUuZ2V0Q29udGV4dChcIjJkXCIpKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgfHwgdC5kcmF3SW1hZ2UoaSwgMCwgMCksIGU7XG59LCBjb3M6IEx0LCBjcmVhdGVDYW52YXNFbGVtZW50OiBrdCwgY3JlYXRlSW1hZ2U6IFZhLCBjcmVhdGVSb3RhdGVNYXRyaXg6IElzLCBjcmVhdGVTY2FsZU1hdHJpeDogdmksIGNyZWF0ZVNrZXdYTWF0cml4OiBCbiwgY3JlYXRlU2tld1lNYXRyaXg6IFduLCBjcmVhdGVUcmFuc2xhdGVNYXRyaXg6IE1zLCBjcmVhdGVWZWN0b3I6IFpyLCBjcm9zc1Byb2R1Y3Q6IHBzLCBkZWdyZWVzVG9SYWRpYW5zOiBLLCBkb3RQcm9kdWN0OiBoYywgZWFzZTogWmgsIGVubGl2ZW5PYmplY3RFbmxpdmFibGVzOiBjciwgZW5saXZlbk9iamVjdHM6IGJzLCBmaW5kU2NhbGVUb0NvdmVyOiBCYywgZmluZFNjYWxlVG9GaXQ6IExjLCBnZXRCb3VuZHNPZkN1cnZlOiBtbiwgZ2V0T3J0aG9ub3JtYWxWZWN0b3I6IEduLCBnZXRQYXRoU2VnbWVudHNJbmZvOiBRbiwgZ2V0UG9pbnRPblBhdGg6IFZjLCBnZXRQb2ludGVyOiB0YywgZ2V0UmFuZG9tSW50OiBRdSwgZ2V0UmVndWxhclBvbHlnb25QYXRoOiAoaSwgdCkgPT4ge1xuICBjb25zdCBlID0gMiAqIE1hdGguUEkgLyBpO1xuICBsZXQgcyA9IC14ZTtcbiAgaSAlIDIgPT0gMCAmJiAocyArPSBlIC8gMik7XG4gIGNvbnN0IHIgPSBuZXcgQXJyYXkoaSArIDEpO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IGk7IG4rKykge1xuICAgIGNvbnN0IG8gPSBuICogZSArIHMsIHsgeDogYSwgeTogYyB9ID0gbmV3IF8oTHQobyksIEJ0KG8pKS5zY2FsYXJNdWx0aXBseSh0KTtcbiAgICByW25dID0gW24gPT09IDAgPyBcIk1cIiA6IFwiTFwiLCBhLCBjXTtcbiAgfVxuICByZXR1cm4gcltpXSA9IFtcIlpcIl0sIHI7XG59LCBnZXRTbW9vdGhQYXRoRnJvbVBvaW50czogWnUsIGdldFN2Z0F0dHJpYnV0ZXM6IChpKSA9PiB7XG4gIGNvbnN0IHQgPSBbXCJpbnN0YW50aWF0ZWRfYnlfdXNlXCIsIFwic3R5bGVcIiwgXCJpZFwiLCBcImNsYXNzXCJdO1xuICBzd2l0Y2ggKGkpIHtcbiAgICBjYXNlIFwibGluZWFyR3JhZGllbnRcIjpcbiAgICAgIHJldHVybiB0LmNvbmNhdChbXCJ4MVwiLCBcInkxXCIsIFwieDJcIiwgXCJ5MlwiLCBcImdyYWRpZW50VW5pdHNcIiwgXCJncmFkaWVudFRyYW5zZm9ybVwiXSk7XG4gICAgY2FzZSBcInJhZGlhbEdyYWRpZW50XCI6XG4gICAgICByZXR1cm4gdC5jb25jYXQoW1wiZ3JhZGllbnRVbml0c1wiLCBcImdyYWRpZW50VHJhbnNmb3JtXCIsIFwiY3hcIiwgXCJjeVwiLCBcInJcIiwgXCJmeFwiLCBcImZ5XCIsIFwiZnJcIl0pO1xuICAgIGNhc2UgXCJzdG9wXCI6XG4gICAgICByZXR1cm4gdC5jb25jYXQoW1wib2Zmc2V0XCIsIFwic3RvcC1jb2xvclwiLCBcInN0b3Atb3BhY2l0eVwiXSk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59LCBnZXRVbml0VmVjdG9yOiBTaSwgZ3JvdXBTVkdFbGVtZW50czogKGksIHQpID0+IGkgJiYgaS5sZW5ndGggPT09IDEgPyBpWzBdIDogbmV3IE50KGksIHQpLCBoYXNTdHlsZUNoYW5nZWQ6IHdpLCBpbnZlcnRUcmFuc2Zvcm06IFN0LCBpc0JldHdlZW5WZWN0b3JzOiBjbiwgaXNJZGVudGl0eU1hdHJpeDogR2EsIGlzVG91Y2hFdmVudDogS3IsIGlzVHJhbnNwYXJlbnQ6IE1jLCBqb2luUGF0aDogTmMsIGxvYWRJbWFnZTogWXMsIG1hZ25pdHVkZTogUXIsIG1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHM6IEd0LCBtYWtlUGF0aFNpbXBsZXI6IFdjLCBtYXRyaXhUb1NWRzogcXMsIG1lcmdlQ2xpcFBhdGhzOiAoaSwgdCkgPT4ge1xuICB2YXIgZTtcbiAgbGV0IHMgPSBpLCByID0gdDtcbiAgcy5pbnZlcnRlZCAmJiAhci5pbnZlcnRlZCAmJiAocyA9IHQsIHIgPSBpKSwgYW4ociwgKGUgPSByLmdyb3VwKSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSwgcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICBjb25zdCBuID0gcy5pbnZlcnRlZCAmJiByLmludmVydGVkO1xuICByZXR1cm4gbiAmJiAocy5pbnZlcnRlZCA9IHIuaW52ZXJ0ZWQgPSAhMSksIG5ldyBOdChbc10sIHsgY2xpcFBhdGg6IHIsIGludmVydGVkOiBuIH0pO1xufSwgbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlczogSiwgbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaXhBcnJheTogbWksIHBhcnNlUGF0aDogR2MsIHBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZTogcWEsIHBhcnNlVW5pdDogV2UsIHBpY2s6IFZlLCBwcm9qZWN0U3Ryb2tlT25Qb2ludHM6IERjLCBxckRlY29tcG9zZTogeXMsIHJhZGlhbnNUb0RlZ3JlZXM6IENlLCByZW1vdmVGcm9tQXJyYXk6IEVlLCByZW1vdmVUcmFuc2Zvcm1Gcm9tT2JqZWN0OiAoaSwgdCkgPT4ge1xuICBjb25zdCBlID0gU3QodCksIHMgPSBKKGUsIGkuY2FsY093bk1hdHJpeCgpKTtcbiAgX3MoaSwgcyk7XG59LCByZW1vdmVUcmFuc2Zvcm1NYXRyaXhGb3JTdmdQYXJzaW5nOiBlZCwgcmVxdWVzdDogdGQsIHJlcXVlc3RBbmltRnJhbWU6IEhzLCByZXNldE9iamVjdFRyYW5zZm9ybTogc2MsIHJvdGF0ZVBvaW50OiAoaSwgdCwgZSkgPT4gaS5yb3RhdGUoZSwgdCksIHJvdGF0ZVZlY3RvcjogVm4sIHNhdmVPYmplY3RUcmFuc2Zvcm06IHpuLCBzZW5kT2JqZWN0VG9QbGFuZTogYW4sIHNlbmRQb2ludFRvUGxhbmU6IGFlLCBzZW5kVmVjdG9yVG9QbGFuZTogcmMsIHNldFN0eWxlOiBpaSwgc2luOiBCdCwgc2l6ZUFmdGVyVHJhbnNmb3JtOiB5aSwgc3RyaW5nOiBwdSwgc3R5bGVzRnJvbUFycmF5OiBQYywgc3R5bGVzVG9BcnJheTogRWMsIHRvQmxvYjogTG4sIHRvRGF0YVVSTDogUm4sIHRvRml4ZWQ6IFYsIHRyYW5zZm9ybVBhdGg6IChpLCB0LCBlKSA9PiAoZSAmJiAodCA9IEoodCwgWzEsIDAsIDAsIDEsIC1lLngsIC1lLnldKSksIGkubWFwKChzKSA9PiB7XG4gIGNvbnN0IHIgPSBbLi4uc107XG4gIGZvciAobGV0IG4gPSAxOyBuIDwgcy5sZW5ndGggLSAxOyBuICs9IDIpIHtcbiAgICBjb25zdCB7IHg6IG8sIHk6IGEgfSA9IG90KHsgeDogc1tuXSwgeTogc1tuICsgMV0gfSwgdCk7XG4gICAgcltuXSA9IG8sIHJbbiArIDFdID0gYTtcbiAgfVxuICByZXR1cm4gcjtcbn0pKSwgdHJhbnNmb3JtUG9pbnQ6IG90IH0pO1xuY2xhc3MgcmQgZXh0ZW5kcyBRYSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBsZXQgeyBhbGxvd1RvdWNoU2Nyb2xsaW5nOiBlID0gITEsIGNvbnRhaW5lckNsYXNzOiBzID0gXCJcIiB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBzdXBlcih0KSwgeSh0aGlzLCBcInVwcGVyXCIsIHZvaWQgMCksIHkodGhpcywgXCJjb250YWluZXJcIiwgdm9pZCAwKTtcbiAgICBjb25zdCB7IGVsOiByIH0gPSB0aGlzLmxvd2VyLCBuID0gdGhpcy5jcmVhdGVVcHBlckNhbnZhcygpO1xuICAgIHRoaXMudXBwZXIgPSB7IGVsOiBuLCBjdHg6IG4uZ2V0Q29udGV4dChcIjJkXCIpIH0sIHRoaXMuYXBwbHlDYW52YXNTdHlsZShyLCB7IGFsbG93VG91Y2hTY3JvbGxpbmc6IGUgfSksIHRoaXMuYXBwbHlDYW52YXNTdHlsZShuLCB7IGFsbG93VG91Y2hTY3JvbGxpbmc6IGUsIHN0eWxlczogeyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCBsZWZ0OiBcIjBcIiwgdG9wOiBcIjBcIiB9IH0pO1xuICAgIGNvbnN0IG8gPSB0aGlzLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoKTtcbiAgICBvLmNsYXNzTGlzdC5hZGQocyksIHIucGFyZW50Tm9kZSAmJiByLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG8sIHIpLCBvLmFwcGVuZChyLCBuKSwgdGhpcy5jb250YWluZXIgPSBvO1xuICB9XG4gIGNyZWF0ZVVwcGVyQ2FudmFzKCkge1xuICAgIGNvbnN0IHsgZWw6IHQgfSA9IHRoaXMubG93ZXIsIGUgPSBrdCgpO1xuICAgIHJldHVybiBlLmNsYXNzTmFtZSA9IHQuY2xhc3NOYW1lLCBlLmNsYXNzTGlzdC5yZW1vdmUoXCJsb3dlci1jYW52YXNcIiksIGUuY2xhc3NMaXN0LmFkZChcInVwcGVyLWNhbnZhc1wiKSwgZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWZhYnJpY1wiLCBcInRvcFwiKSwgZS5zdHlsZS5jc3NUZXh0ID0gdC5zdHlsZS5jc3NUZXh0LCBlLnNldEF0dHJpYnV0ZShcImRyYWdnYWJsZVwiLCBcInRydWVcIiksIGU7XG4gIH1cbiAgY3JlYXRlQ29udGFpbmVyRWxlbWVudCgpIHtcbiAgICBjb25zdCB0ID0gQ3MoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHJldHVybiB0LnNldEF0dHJpYnV0ZShcImRhdGEtZmFicmljXCIsIFwid3JhcHBlclwiKSwgaWkodCwgeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0pLCBUbyh0KSwgdDtcbiAgfVxuICBhcHBseUNhbnZhc1N0eWxlKHQsIGUpIHtcbiAgICBjb25zdCB7IHN0eWxlczogcywgYWxsb3dUb3VjaFNjcm9sbGluZzogciB9ID0gZTtcbiAgICBpaSh0LCB2KHYoe30sIHMpLCB7fSwgeyBcInRvdWNoLWFjdGlvblwiOiByID8gXCJtYW5pcHVsYXRpb25cIiA6IHB0IH0pKSwgVG8odCk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucyh0LCBlKSB7XG4gICAgc3VwZXIuc2V0RGltZW5zaW9ucyh0LCBlKTtcbiAgICBjb25zdCB7IGVsOiBzLCBjdHg6IHIgfSA9IHRoaXMudXBwZXI7XG4gICAgWmEocywgciwgdCwgZSk7XG4gIH1cbiAgc2V0Q1NTRGltZW5zaW9ucyh0KSB7XG4gICAgc3VwZXIuc2V0Q1NTRGltZW5zaW9ucyh0KSwgbm4odGhpcy51cHBlci5lbCwgdCksIG5uKHRoaXMuY29udGFpbmVyLCB0KTtcbiAgfVxuICBjbGVhbnVwRE9NKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb250YWluZXIsIHsgZWw6IHMgfSA9IHRoaXMubG93ZXIsIHsgZWw6IHIgfSA9IHRoaXMudXBwZXI7XG4gICAgc3VwZXIuY2xlYW51cERPTSh0KSwgZS5yZW1vdmVDaGlsZChyKSwgZS5yZW1vdmVDaGlsZChzKSwgZS5wYXJlbnROb2RlICYmIGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQocywgZSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCksICR0KCkuZGlzcG9zZSh0aGlzLnVwcGVyLmVsKSwgZGVsZXRlIHRoaXMudXBwZXIsIGRlbGV0ZSB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgT2kgZXh0ZW5kcyBsciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHkodGhpcywgXCJ0YXJnZXRzXCIsIFtdKSwgeSh0aGlzLCBcIl9ob3ZlcmVkVGFyZ2V0c1wiLCBbXSksIHkodGhpcywgXCJfb2JqZWN0c1RvUmVuZGVyXCIsIHZvaWQgMCksIHkodGhpcywgXCJfY3VycmVudFRyYW5zZm9ybVwiLCBudWxsKSwgeSh0aGlzLCBcIl9ncm91cFNlbGVjdG9yXCIsIG51bGwpLCB5KHRoaXMsIFwiY29udGV4dFRvcERpcnR5XCIsICExKTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHYodih7fSwgc3VwZXIuZ2V0RGVmYXVsdHMoKSksIE9pLm93bkRlZmF1bHRzKTtcbiAgfVxuICBnZXQgdXBwZXJDYW52YXNFbCgpIHtcbiAgICB2YXIgdDtcbiAgICByZXR1cm4gKHQgPSB0aGlzLmVsZW1lbnRzLnVwcGVyKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0LmVsO1xuICB9XG4gIGdldCBjb250ZXh0VG9wKCkge1xuICAgIHZhciB0O1xuICAgIHJldHVybiAodCA9IHRoaXMuZWxlbWVudHMudXBwZXIpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHQuY3R4O1xuICB9XG4gIGdldCB3cmFwcGVyRWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuY29udGFpbmVyO1xuICB9XG4gIGluaXRFbGVtZW50cyh0KSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyByZCh0LCB7IGFsbG93VG91Y2hTY3JvbGxpbmc6IHRoaXMuYWxsb3dUb3VjaFNjcm9sbGluZywgY29udGFpbmVyQ2xhc3M6IHRoaXMuY29udGFpbmVyQ2xhc3MgfSksIHRoaXMuX2NyZWF0ZUNhY2hlQ2FudmFzKCk7XG4gIH1cbiAgX29uT2JqZWN0QWRkZWQodCkge1xuICAgIHRoaXMuX29iamVjdHNUb1JlbmRlciA9IHZvaWQgMCwgc3VwZXIuX29uT2JqZWN0QWRkZWQodCk7XG4gIH1cbiAgX29uT2JqZWN0UmVtb3ZlZCh0KSB7XG4gICAgdGhpcy5fb2JqZWN0c1RvUmVuZGVyID0gdm9pZCAwLCB0ID09PSB0aGlzLl9hY3RpdmVPYmplY3QgJiYgKHRoaXMuZmlyZShcImJlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZFwiLCB7IGRlc2VsZWN0ZWQ6IFt0XSB9KSwgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdCgpLCB0aGlzLmZpcmUoXCJzZWxlY3Rpb246Y2xlYXJlZFwiLCB7IGRlc2VsZWN0ZWQ6IFt0XSB9KSwgdC5maXJlKFwiZGVzZWxlY3RlZFwiLCB7IHRhcmdldDogdCB9KSksIHQgPT09IHRoaXMuX2hvdmVyZWRUYXJnZXQgJiYgKHRoaXMuX2hvdmVyZWRUYXJnZXQgPSB2b2lkIDAsIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gW10pLCBzdXBlci5fb25PYmplY3RSZW1vdmVkKHQpO1xuICB9XG4gIF9vblN0YWNrT3JkZXJDaGFuZ2VkKCkge1xuICAgIHRoaXMuX29iamVjdHNUb1JlbmRlciA9IHZvaWQgMCwgc3VwZXIuX29uU3RhY2tPcmRlckNoYW5nZWQoKTtcbiAgfVxuICBfY2hvb3NlT2JqZWN0c1RvUmVuZGVyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgcmV0dXJuICF0aGlzLnByZXNlcnZlT2JqZWN0U3RhY2tpbmcgJiYgdCA/IHRoaXMuX29iamVjdHMuZmlsdGVyKChlKSA9PiAhZS5ncm91cCAmJiBlICE9PSB0KS5jb25jYXQodCkgOiB0aGlzLl9vYmplY3RzO1xuICB9XG4gIHJlbmRlckFsbCgpIHtcbiAgICB0aGlzLmNhbmNlbFJlcXVlc3RlZFJlbmRlcigpLCB0aGlzLmRlc3Ryb3llZCB8fCAoIXRoaXMuY29udGV4dFRvcERpcnR5IHx8IHRoaXMuX2dyb3VwU2VsZWN0b3IgfHwgdGhpcy5pc0RyYXdpbmdNb2RlIHx8ICh0aGlzLmNsZWFyQ29udGV4dCh0aGlzLmNvbnRleHRUb3ApLCB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9ICExKSwgdGhpcy5oYXNMb3N0Q29udGV4dCAmJiAodGhpcy5yZW5kZXJUb3BMYXllcih0aGlzLmNvbnRleHRUb3ApLCB0aGlzLmhhc0xvc3RDb250ZXh0ID0gITEpLCAhdGhpcy5fb2JqZWN0c1RvUmVuZGVyICYmICh0aGlzLl9vYmplY3RzVG9SZW5kZXIgPSB0aGlzLl9jaG9vc2VPYmplY3RzVG9SZW5kZXIoKSksIHRoaXMucmVuZGVyQ2FudmFzKHRoaXMuZ2V0Q29udGV4dCgpLCB0aGlzLl9vYmplY3RzVG9SZW5kZXIpKTtcbiAgfVxuICByZW5kZXJUb3BMYXllcih0KSB7XG4gICAgdC5zYXZlKCksIHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcgJiYgKHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2guX3JlbmRlcigpLCB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9ICEwKSwgdGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5fZ3JvdXBTZWxlY3RvciAmJiAodGhpcy5fZHJhd1NlbGVjdGlvbih0KSwgdGhpcy5jb250ZXh0VG9wRGlydHkgPSAhMCksIHQucmVzdG9yZSgpO1xuICB9XG4gIHJlbmRlclRvcCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jb250ZXh0VG9wO1xuICAgIHRoaXMuY2xlYXJDb250ZXh0KHQpLCB0aGlzLnJlbmRlclRvcExheWVyKHQpLCB0aGlzLmZpcmUoXCJhZnRlcjpyZW5kZXJcIiwgeyBjdHg6IHQgfSk7XG4gIH1cbiAgc2V0VGFyZ2V0RmluZFRvbGVyYW5jZSh0KSB7XG4gICAgdCA9IE1hdGgucm91bmQodCksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSA9IHQ7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpLCBzID0gTWF0aC5jZWlsKCgyICogdCArIDEpICogZSk7XG4gICAgdGhpcy5waXhlbEZpbmRDYW52YXNFbC53aWR0aCA9IHRoaXMucGl4ZWxGaW5kQ2FudmFzRWwuaGVpZ2h0ID0gcywgdGhpcy5waXhlbEZpbmRDb250ZXh0LnNjYWxlKGUsIGUpO1xuICB9XG4gIGlzVGFyZ2V0VHJhbnNwYXJlbnQodCwgZSwgcykge1xuICAgIGNvbnN0IHIgPSB0aGlzLnRhcmdldEZpbmRUb2xlcmFuY2UsIG4gPSB0aGlzLnBpeGVsRmluZENvbnRleHQ7XG4gICAgdGhpcy5jbGVhckNvbnRleHQobiksIG4uc2F2ZSgpLCBuLnRyYW5zbGF0ZSgtZSArIHIsIC1zICsgciksIG4udHJhbnNmb3JtKC4uLnRoaXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgIGNvbnN0IG8gPSB0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvcjtcbiAgICB0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciA9IFwiXCIsIHQucmVuZGVyKG4pLCB0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciA9IG8sIG4ucmVzdG9yZSgpO1xuICAgIGNvbnN0IGEgPSBNYXRoLnJvdW5kKHIgKiB0aGlzLmdldFJldGluYVNjYWxpbmcoKSk7XG4gICAgcmV0dXJuIE1jKG4sIGEsIGEsIGEpO1xuICB9XG4gIF9pc1NlbGVjdGlvbktleVByZXNzZWQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnNlbGVjdGlvbktleTtcbiAgICByZXR1cm4gISFlICYmIChBcnJheS5pc0FycmF5KGUpID8gISFlLmZpbmQoKHMpID0+ICEhcyAmJiB0W3NdID09PSAhMCkgOiB0W2VdKTtcbiAgfVxuICBfc2hvdWxkQ2xlYXJTZWxlY3Rpb24odCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSwgciA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICByZXR1cm4gISEoIWUgfHwgZSAmJiByICYmIHMubGVuZ3RoID4gMSAmJiBzLmluZGV4T2YoZSkgPT09IC0xICYmIHIgIT09IGUgJiYgIXRoaXMuX2lzU2VsZWN0aW9uS2V5UHJlc3NlZCh0KSB8fCBlICYmICFlLmV2ZW50ZWQgfHwgZSAmJiAhZS5zZWxlY3RhYmxlICYmIHIgJiYgciAhPT0gZSk7XG4gIH1cbiAgX3Nob3VsZENlbnRlclRyYW5zZm9ybSh0LCBlLCBzKSB7XG4gICAgaWYgKCF0KSByZXR1cm47XG4gICAgbGV0IHI7XG4gICAgcmV0dXJuIGUgPT09IHBpIHx8IGUgPT09IHV0IHx8IGUgPT09IFR0IHx8IGUgPT09ICRzID8gciA9IHRoaXMuY2VudGVyZWRTY2FsaW5nIHx8IHQuY2VudGVyZWRTY2FsaW5nIDogZSA9PT0gQW4gJiYgKHIgPSB0aGlzLmNlbnRlcmVkUm90YXRpb24gfHwgdC5jZW50ZXJlZFJvdGF0aW9uKSwgciA/ICFzIDogcztcbiAgfVxuICBfZ2V0T3JpZ2luRnJvbUNvcm5lcih0LCBlKSB7XG4gICAgY29uc3QgcyA9IHsgeDogdC5vcmlnaW5YLCB5OiB0Lm9yaWdpblkgfTtcbiAgICByZXR1cm4gZSAmJiAoW1wibWxcIiwgXCJ0bFwiLCBcImJsXCJdLmluY2x1ZGVzKGUpID8gcy54ID0gWiA6IFtcIm1yXCIsIFwidHJcIiwgXCJiclwiXS5pbmNsdWRlcyhlKSAmJiAocy54ID0gTCksIFtcInRsXCIsIFwibXRcIiwgXCJ0clwiXS5pbmNsdWRlcyhlKSA/IHMueSA9IHJuIDogW1wiYmxcIiwgXCJtYlwiLCBcImJyXCJdLmluY2x1ZGVzKGUpICYmIChzLnkgPSBndCkpLCBzO1xuICB9XG4gIF9zZXR1cEN1cnJlbnRUcmFuc2Zvcm0odCwgZSwgcykge1xuICAgIHZhciByO1xuICAgIGNvbnN0IG4gPSBlLmdyb3VwID8gYWUodGhpcy5nZXRTY2VuZVBvaW50KHQpLCB2b2lkIDAsIGUuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKSA6IHRoaXMuZ2V0U2NlbmVQb2ludCh0KSwgeyBrZXk6IG8gPSBcIlwiLCBjb250cm9sOiBhIH0gPSBlLmdldEFjdGl2ZUNvbnRyb2woKSB8fCB7fSwgYyA9IHMgJiYgYSA/IChyID0gYS5nZXRBY3Rpb25IYW5kbGVyKHQsIGUsIGEpKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgPyB2b2lkIDAgOiByLmJpbmQoYSkgOiBvYywgbCA9ICgoZiwgZywgcCwgbSkgPT4ge1xuICAgICAgaWYgKCFnIHx8ICFmKSByZXR1cm4gXCJkcmFnXCI7XG4gICAgICBjb25zdCBiID0gbS5jb250cm9sc1tnXTtcbiAgICAgIHJldHVybiBiLmdldEFjdGlvbk5hbWUocCwgYiwgbSk7XG4gICAgfSkocywgbywgdCwgZSksIGggPSB0W3RoaXMuY2VudGVyZWRLZXldLCB1ID0gdGhpcy5fc2hvdWxkQ2VudGVyVHJhbnNmb3JtKGUsIGwsIGgpID8geyB4OiBqLCB5OiBqIH0gOiB0aGlzLl9nZXRPcmlnaW5Gcm9tQ29ybmVyKGUsIG8pLCBkID0geyB0YXJnZXQ6IGUsIGFjdGlvbjogbCwgYWN0aW9uSGFuZGxlcjogYywgYWN0aW9uUGVyZm9ybWVkOiAhMSwgY29ybmVyOiBvLCBzY2FsZVg6IGUuc2NhbGVYLCBzY2FsZVk6IGUuc2NhbGVZLCBza2V3WDogZS5za2V3WCwgc2tld1k6IGUuc2tld1ksIG9mZnNldFg6IG4ueCAtIGUubGVmdCwgb2Zmc2V0WTogbi55IC0gZS50b3AsIG9yaWdpblg6IHUueCwgb3JpZ2luWTogdS55LCBleDogbi54LCBleTogbi55LCBsYXN0WDogbi54LCBsYXN0WTogbi55LCB0aGV0YTogSyhlLmFuZ2xlKSwgd2lkdGg6IGUud2lkdGgsIGhlaWdodDogZS5oZWlnaHQsIHNoaWZ0S2V5OiB0LnNoaWZ0S2V5LCBhbHRLZXk6IGgsIG9yaWdpbmFsOiB2KHYoe30sIHpuKGUpKSwge30sIHsgb3JpZ2luWDogdS54LCBvcmlnaW5ZOiB1LnkgfSkgfTtcbiAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gZCwgdGhpcy5maXJlKFwiYmVmb3JlOnRyYW5zZm9ybVwiLCB7IGU6IHQsIHRyYW5zZm9ybTogZCB9KTtcbiAgfVxuICBzZXRDdXJzb3IodCkge1xuICAgIHRoaXMudXBwZXJDYW52YXNFbC5zdHlsZS5jdXJzb3IgPSB0O1xuICB9XG4gIF9kcmF3U2VsZWN0aW9uKHQpIHtcbiAgICBjb25zdCB7IHg6IGUsIHk6IHMsIGRlbHRhWDogciwgZGVsdGFZOiBuIH0gPSB0aGlzLl9ncm91cFNlbGVjdG9yLCBvID0gbmV3IF8oZSwgcykudHJhbnNmb3JtKHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pLCBhID0gbmV3IF8oZSArIHIsIHMgKyBuKS50cmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSksIGMgPSB0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aCAvIDI7XG4gICAgbGV0IGwgPSBNYXRoLm1pbihvLngsIGEueCksIGggPSBNYXRoLm1pbihvLnksIGEueSksIHUgPSBNYXRoLm1heChvLngsIGEueCksIGQgPSBNYXRoLm1heChvLnksIGEueSk7XG4gICAgdGhpcy5zZWxlY3Rpb25Db2xvciAmJiAodC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkNvbG9yLCB0LmZpbGxSZWN0KGwsIGgsIHUgLSBsLCBkIC0gaCkpLCB0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aCAmJiB0aGlzLnNlbGVjdGlvbkJvcmRlckNvbG9yICYmICh0LmxpbmVXaWR0aCA9IHRoaXMuc2VsZWN0aW9uTGluZVdpZHRoLCB0LnN0cm9rZVN0eWxlID0gdGhpcy5zZWxlY3Rpb25Cb3JkZXJDb2xvciwgbCArPSBjLCBoICs9IGMsIHUgLT0gYywgZCAtPSBjLCBudC5wcm90b3R5cGUuX3NldExpbmVEYXNoLmNhbGwodGhpcywgdCwgdGhpcy5zZWxlY3Rpb25EYXNoQXJyYXkpLCB0LnN0cm9rZVJlY3QobCwgaCwgdSAtIGwsIGQgLSBoKSk7XG4gIH1cbiAgZmluZFRhcmdldCh0KSB7XG4gICAgaWYgKHRoaXMuc2tpcFRhcmdldEZpbmQpIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRWaWV3cG9ydFBvaW50KHQpLCBzID0gdGhpcy5fYWN0aXZlT2JqZWN0LCByID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCk7XG4gICAgaWYgKHRoaXMudGFyZ2V0cyA9IFtdLCBzICYmIHIubGVuZ3RoID49IDEpIHtcbiAgICAgIGlmIChzLmZpbmRDb250cm9sKGUsIEtyKHQpKSB8fCByLmxlbmd0aCA+IDEgJiYgdGhpcy5zZWFyY2hQb3NzaWJsZVRhcmdldHMoW3NdLCBlKSkgcmV0dXJuIHM7XG4gICAgICBpZiAocyA9PT0gdGhpcy5zZWFyY2hQb3NzaWJsZVRhcmdldHMoW3NdLCBlKSkge1xuICAgICAgICBpZiAodGhpcy5wcmVzZXJ2ZU9iamVjdFN0YWNraW5nKSB7XG4gICAgICAgICAgY29uc3QgbiA9IHRoaXMudGFyZ2V0cztcbiAgICAgICAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICAgICAgICBjb25zdCBvID0gdGhpcy5zZWFyY2hQb3NzaWJsZVRhcmdldHModGhpcy5fb2JqZWN0cywgZSk7XG4gICAgICAgICAgcmV0dXJuIHRbdGhpcy5hbHRTZWxlY3Rpb25LZXldICYmIG8gJiYgbyAhPT0gcyA/ICh0aGlzLnRhcmdldHMgPSBuLCBzKSA6IG87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlYXJjaFBvc3NpYmxlVGFyZ2V0cyh0aGlzLl9vYmplY3RzLCBlKTtcbiAgfVxuICBfcG9pbnRJc0luT2JqZWN0U2VsZWN0aW9uQXJlYSh0LCBlKSB7XG4gICAgbGV0IHMgPSB0LmdldENvb3JkcygpO1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldFpvb20oKSwgbiA9IHQucGFkZGluZyAvIHI7XG4gICAgaWYgKG4pIHtcbiAgICAgIGNvbnN0IFtvLCBhLCBjLCBsXSA9IHMsIGggPSBNYXRoLmF0YW4yKGEueSAtIG8ueSwgYS54IC0gby54KSwgdSA9IEx0KGgpICogbiwgZCA9IEJ0KGgpICogbiwgZiA9IHUgKyBkLCBnID0gdSAtIGQ7XG4gICAgICBzID0gW25ldyBfKG8ueCAtIGcsIG8ueSAtIGYpLCBuZXcgXyhhLnggKyBmLCBhLnkgLSBnKSwgbmV3IF8oYy54ICsgZywgYy55ICsgZiksIG5ldyBfKGwueCAtIGYsIGwueSArIGcpXTtcbiAgICB9XG4gICAgcmV0dXJuIE4uaXNQb2ludEluUG9seWdvbihlLCBzKTtcbiAgfVxuICBfY2hlY2tUYXJnZXQodCwgZSkge1xuICAgIHJldHVybiAhISh0ICYmIHQudmlzaWJsZSAmJiB0LmV2ZW50ZWQgJiYgdGhpcy5fcG9pbnRJc0luT2JqZWN0U2VsZWN0aW9uQXJlYSh0LCBhZShlLCB2b2lkIDAsIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pKSAmJiAoIXRoaXMucGVyUGl4ZWxUYXJnZXRGaW5kICYmICF0LnBlclBpeGVsVGFyZ2V0RmluZCB8fCB0LmlzRWRpdGluZyB8fCAhdGhpcy5pc1RhcmdldFRyYW5zcGFyZW50KHQsIGUueCwgZS55KSkpO1xuICB9XG4gIF9zZWFyY2hQb3NzaWJsZVRhcmdldHModCwgZSkge1xuICAgIGxldCBzID0gdC5sZW5ndGg7XG4gICAgZm9yICg7IHMtLTsgKSB7XG4gICAgICBjb25zdCByID0gdFtzXTtcbiAgICAgIGlmICh0aGlzLl9jaGVja1RhcmdldChyLCBlKSkge1xuICAgICAgICBpZiAoVnIocikgJiYgci5zdWJUYXJnZXRDaGVjaykge1xuICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHMoci5fb2JqZWN0cywgZSk7XG4gICAgICAgICAgbiAmJiB0aGlzLnRhcmdldHMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2VhcmNoUG9zc2libGVUYXJnZXRzKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKHQsIGUpO1xuICAgIGlmIChzICYmIFZyKHMpICYmIHMuaW50ZXJhY3RpdmUgJiYgdGhpcy50YXJnZXRzWzBdKSB7XG4gICAgICBjb25zdCByID0gdGhpcy50YXJnZXRzO1xuICAgICAgZm9yIChsZXQgbiA9IHIubGVuZ3RoIC0gMTsgbiA+IDA7IG4tLSkge1xuICAgICAgICBjb25zdCBvID0gcltuXTtcbiAgICAgICAgaWYgKCFWcihvKSB8fCAhby5pbnRlcmFjdGl2ZSkgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICByZXR1cm4gclswXTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgZ2V0Vmlld3BvcnRQb2ludCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50ZXIgPyB0aGlzLl9wb2ludGVyIDogdGhpcy5nZXRQb2ludGVyKHQsICEwKTtcbiAgfVxuICBnZXRTY2VuZVBvaW50KHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVQb2ludGVyID8gdGhpcy5fYWJzb2x1dGVQb2ludGVyIDogdGhpcy5nZXRQb2ludGVyKHQpO1xuICB9XG4gIGdldFBvaW50ZXIodCkge1xuICAgIGxldCBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgJiYgYXJndW1lbnRzWzFdO1xuICAgIGNvbnN0IHMgPSB0aGlzLnVwcGVyQ2FudmFzRWwsIHIgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBuID0gdGModCksIG8gPSByLndpZHRoIHx8IDAsIGEgPSByLmhlaWdodCB8fCAwO1xuICAgIG8gJiYgYSB8fCAoZ3QgaW4gciAmJiBybiBpbiByICYmIChhID0gTWF0aC5hYnMoci50b3AgLSByLmJvdHRvbSkpLCBaIGluIHIgJiYgTCBpbiByICYmIChvID0gTWF0aC5hYnMoci5yaWdodCAtIHIubGVmdCkpKSwgdGhpcy5jYWxjT2Zmc2V0KCksIG4ueCA9IG4ueCAtIHRoaXMuX29mZnNldC5sZWZ0LCBuLnkgPSBuLnkgLSB0aGlzLl9vZmZzZXQudG9wLCBlIHx8IChuID0gYWUobiwgdm9pZCAwLCB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKSk7XG4gICAgY29uc3QgYyA9IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpO1xuICAgIGMgIT09IDEgJiYgKG4ueCAvPSBjLCBuLnkgLz0gYyk7XG4gICAgY29uc3QgbCA9IG8gPT09IDAgfHwgYSA9PT0gMCA/IG5ldyBfKDEsIDEpIDogbmV3IF8ocy53aWR0aCAvIG8sIHMuaGVpZ2h0IC8gYSk7XG4gICAgcmV0dXJuIG4ubXVsdGlwbHkobCk7XG4gIH1cbiAgX3NldERpbWVuc2lvbnNJbXBsKHQsIGUpIHtcbiAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpLCBzdXBlci5fc2V0RGltZW5zaW9uc0ltcGwodCwgZSksIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggJiYgdGhpcy5mcmVlRHJhd2luZ0JydXNoLl9zZXRCcnVzaFN0eWxlcyh0aGlzLmNvbnRleHRUb3ApO1xuICB9XG4gIF9jcmVhdGVDYWNoZUNhbnZhcygpIHtcbiAgICB0aGlzLnBpeGVsRmluZENhbnZhc0VsID0ga3QoKSwgdGhpcy5waXhlbEZpbmRDb250ZXh0ID0gdGhpcy5waXhlbEZpbmRDYW52YXNFbC5nZXRDb250ZXh0KFwiMmRcIiwgeyB3aWxsUmVhZEZyZXF1ZW50bHk6ICEwIH0pLCB0aGlzLnNldFRhcmdldEZpbmRUb2xlcmFuY2UodGhpcy50YXJnZXRGaW5kVG9sZXJhbmNlKTtcbiAgfVxuICBnZXRUb3BDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLnVwcGVyLmN0eDtcbiAgfVxuICBnZXRTZWxlY3Rpb25Db250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLnVwcGVyLmN0eDtcbiAgfVxuICBnZXRTZWxlY3Rpb25FbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLnVwcGVyLmVsO1xuICB9XG4gIGdldEFjdGl2ZU9iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICB9XG4gIGdldEFjdGl2ZU9iamVjdHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICByZXR1cm4gUGUodCkgPyB0LmdldE9iamVjdHMoKSA6IHQgPyBbdF0gOiBbXTtcbiAgfVxuICBfZmlyZVNlbGVjdGlvbkV2ZW50cyh0LCBlKSB7XG4gICAgbGV0IHMgPSAhMSwgciA9ICExO1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSwgbyA9IFtdLCBhID0gW107XG4gICAgdC5mb3JFYWNoKChjKSA9PiB7XG4gICAgICBuLmluY2x1ZGVzKGMpIHx8IChzID0gITAsIGMuZmlyZShcImRlc2VsZWN0ZWRcIiwgeyBlLCB0YXJnZXQ6IGMgfSksIGEucHVzaChjKSk7XG4gICAgfSksIG4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgdC5pbmNsdWRlcyhjKSB8fCAocyA9ICEwLCBjLmZpcmUoXCJzZWxlY3RlZFwiLCB7IGUsIHRhcmdldDogYyB9KSwgby5wdXNoKGMpKTtcbiAgICB9KSwgdC5sZW5ndGggPiAwICYmIG4ubGVuZ3RoID4gMCA/IChyID0gITAsIHMgJiYgdGhpcy5maXJlKFwic2VsZWN0aW9uOnVwZGF0ZWRcIiwgeyBlLCBzZWxlY3RlZDogbywgZGVzZWxlY3RlZDogYSB9KSkgOiBuLmxlbmd0aCA+IDAgPyAociA9ICEwLCB0aGlzLmZpcmUoXCJzZWxlY3Rpb246Y3JlYXRlZFwiLCB7IGUsIHNlbGVjdGVkOiBvIH0pKSA6IHQubGVuZ3RoID4gMCAmJiAociA9ICEwLCB0aGlzLmZpcmUoXCJzZWxlY3Rpb246Y2xlYXJlZFwiLCB7IGUsIGRlc2VsZWN0ZWQ6IGEgfSkpLCByICYmICh0aGlzLl9vYmplY3RzVG9SZW5kZXIgPSB2b2lkIDApO1xuICB9XG4gIHNldEFjdGl2ZU9iamVjdCh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLCByID0gdGhpcy5fc2V0QWN0aXZlT2JqZWN0KHQsIGUpO1xuICAgIHJldHVybiB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKHMsIGUpLCByO1xuICB9XG4gIF9zZXRBY3RpdmVPYmplY3QodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgcmV0dXJuIHMgIT09IHQgJiYgISghdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdChlLCB0KSAmJiB0aGlzLl9hY3RpdmVPYmplY3QpICYmICF0Lm9uU2VsZWN0KHsgZSB9KSAmJiAodGhpcy5fYWN0aXZlT2JqZWN0ID0gdCwgUGUodCkgJiYgcyAhPT0gdCAmJiB0LnNldChcImNhbnZhc1wiLCB0aGlzKSwgdC5zZXRDb29yZHMoKSwgITApO1xuICB9XG4gIF9kaXNjYXJkQWN0aXZlT2JqZWN0KHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgIHJldHVybiAhIXMgJiYgIXMub25EZXNlbGVjdCh7IGU6IHQsIG9iamVjdDogZSB9KSAmJiAodGhpcy5fY3VycmVudFRyYW5zZm9ybSAmJiB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLnRhcmdldCA9PT0gcyAmJiB0aGlzLmVuZEN1cnJlbnRUcmFuc2Zvcm0odCksIFBlKHMpICYmIHMgPT09IHRoaXMuX2hvdmVyZWRUYXJnZXQgJiYgKHRoaXMuX2hvdmVyZWRUYXJnZXQgPSB2b2lkIDApLCB0aGlzLl9hY3RpdmVPYmplY3QgPSB2b2lkIDAsICEwKTtcbiAgfVxuICBkaXNjYXJkQWN0aXZlT2JqZWN0KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksIHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdCgpO1xuICAgIGUubGVuZ3RoICYmIHRoaXMuZmlyZShcImJlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZFwiLCB7IGU6IHQsIGRlc2VsZWN0ZWQ6IFtzXSB9KTtcbiAgICBjb25zdCByID0gdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdCh0KTtcbiAgICByZXR1cm4gdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhlLCB0KSwgcjtcbiAgfVxuICBlbmRDdXJyZW50VHJhbnNmb3JtKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcbiAgICB0aGlzLl9maW5hbGl6ZUN1cnJlbnRUcmFuc2Zvcm0odCksIGUgJiYgZS50YXJnZXQgJiYgKGUudGFyZ2V0LmlzTW92aW5nID0gITEpLCB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbnVsbDtcbiAgfVxuICBfZmluYWxpemVDdXJyZW50VHJhbnNmb3JtKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSwgcyA9IGUudGFyZ2V0LCByID0geyBlOiB0LCB0YXJnZXQ6IHMsIHRyYW5zZm9ybTogZSwgYWN0aW9uOiBlLmFjdGlvbiB9O1xuICAgIHMuX3NjYWxpbmcgJiYgKHMuX3NjYWxpbmcgPSAhMSksIHMuc2V0Q29vcmRzKCksIGUuYWN0aW9uUGVyZm9ybWVkICYmICh0aGlzLmZpcmUoXCJvYmplY3Q6bW9kaWZpZWRcIiwgciksIHMuZmlyZSgkciwgcikpO1xuICB9XG4gIHNldFZpZXdwb3J0VHJhbnNmb3JtKHQpIHtcbiAgICBzdXBlci5zZXRWaWV3cG9ydFRyYW5zZm9ybSh0KTtcbiAgICBjb25zdCBlID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgIGUgJiYgZS5zZXRDb29yZHMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgUGUodCkgJiYgKHQucmVtb3ZlQWxsKCksIHQuZGlzcG9zZSgpKSwgZGVsZXRlIHRoaXMuX2FjdGl2ZU9iamVjdCwgc3VwZXIuZGVzdHJveSgpLCB0aGlzLnBpeGVsRmluZENvbnRleHQgPSBudWxsLCB0aGlzLnBpeGVsRmluZENhbnZhc0VsID0gdm9pZCAwO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdCgpLCB0aGlzLl9hY3RpdmVPYmplY3QgPSB2b2lkIDAsIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCksIHN1cGVyLmNsZWFyKCk7XG4gIH1cbiAgZHJhd0NvbnRyb2xzKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgIGUgJiYgZS5fcmVuZGVyQ29udHJvbHModCk7XG4gIH1cbiAgX3RvT2JqZWN0KHQsIGUsIHMpIHtcbiAgICBjb25zdCByID0gdGhpcy5fcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3QodCksIG4gPSBzdXBlci5fdG9PYmplY3QodCwgZSwgcyk7XG4gICAgcmV0dXJuIHQuc2V0KHIpLCBuO1xuICB9XG4gIF9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdCh0KSB7XG4gICAgY29uc3QgeyBncm91cDogZSB9ID0gdDtcbiAgICBpZiAoZSAmJiBQZShlKSAmJiB0aGlzLl9hY3RpdmVPYmplY3QgPT09IGUpIHtcbiAgICAgIGNvbnN0IHMgPSBWZSh0LCBbXCJhbmdsZVwiLCBcImZsaXBYXCIsIFwiZmxpcFlcIiwgTCwgdXQsIFR0LCBPcywga3MsIGd0XSk7XG4gICAgICByZXR1cm4gZWModCwgZS5jYWxjT3duTWF0cml4KCkpLCBzO1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH1cbiAgX3NldFNWR09iamVjdCh0LCBlLCBzKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGUpO1xuICAgIHN1cGVyLl9zZXRTVkdPYmplY3QodCwgZSwgcyksIGUuc2V0KHIpO1xuICB9XG59XG55KE9pLCBcIm93bkRlZmF1bHRzXCIsIHsgdW5pZm9ybVNjYWxpbmc6ICEwLCB1bmlTY2FsZUtleTogXCJzaGlmdEtleVwiLCBjZW50ZXJlZFNjYWxpbmc6ICExLCBjZW50ZXJlZFJvdGF0aW9uOiAhMSwgY2VudGVyZWRLZXk6IFwiYWx0S2V5XCIsIGFsdEFjdGlvbktleTogXCJzaGlmdEtleVwiLCBzZWxlY3Rpb246ICEwLCBzZWxlY3Rpb25LZXk6IFwic2hpZnRLZXlcIiwgc2VsZWN0aW9uQ29sb3I6IFwicmdiYSgxMDAsIDEwMCwgMjU1LCAwLjMpXCIsIHNlbGVjdGlvbkRhc2hBcnJheTogW10sIHNlbGVjdGlvbkJvcmRlckNvbG9yOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKVwiLCBzZWxlY3Rpb25MaW5lV2lkdGg6IDEsIHNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkOiAhMSwgaG92ZXJDdXJzb3I6IFwibW92ZVwiLCBtb3ZlQ3Vyc29yOiBcIm1vdmVcIiwgZGVmYXVsdEN1cnNvcjogXCJkZWZhdWx0XCIsIGZyZWVEcmF3aW5nQ3Vyc29yOiBcImNyb3NzaGFpclwiLCBub3RBbGxvd2VkQ3Vyc29yOiBcIm5vdC1hbGxvd2VkXCIsIHBlclBpeGVsVGFyZ2V0RmluZDogITEsIHRhcmdldEZpbmRUb2xlcmFuY2U6IDAsIHNraXBUYXJnZXRGaW5kOiAhMSwgc3RvcENvbnRleHRNZW51OiAhMSwgZmlyZVJpZ2h0Q2xpY2s6ICExLCBmaXJlTWlkZGxlQ2xpY2s6ICExLCBlbmFibGVQb2ludGVyRXZlbnRzOiAhMSwgY29udGFpbmVyQ2xhc3M6IFwiY2FudmFzLWNvbnRhaW5lclwiLCBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nOiAhMSB9KTtcbmNsYXNzIGlkIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHkodGhpcywgXCJ0YXJnZXRzXCIsIFtdKSwgeSh0aGlzLCBcIl9fZGlzcG9zZXJcIiwgdm9pZCAwKTtcbiAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyBoaWRkZW5UZXh0YXJlYTogciB9ID0gdC5nZXRBY3RpdmVPYmplY3QoKSB8fCB7fTtcbiAgICAgIHIgJiYgci5mb2N1cygpO1xuICAgIH0sIHMgPSB0LnVwcGVyQ2FudmFzRWw7XG4gICAgcy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSksIHRoaXMuX19kaXNwb3NlciA9ICgpID0+IHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUpO1xuICB9XG4gIGV4aXRUZXh0RWRpdGluZygpIHtcbiAgICB0aGlzLnRhcmdldCA9IHZvaWQgMCwgdGhpcy50YXJnZXRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuaXNFZGl0aW5nICYmIHQuZXhpdEVkaXRpbmcoKTtcbiAgICB9KTtcbiAgfVxuICBhZGQodCkge1xuICAgIHRoaXMudGFyZ2V0cy5wdXNoKHQpO1xuICB9XG4gIHJlbW92ZSh0KSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyKHQpLCBFZSh0aGlzLnRhcmdldHMsIHQpO1xuICB9XG4gIHJlZ2lzdGVyKHQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHQ7XG4gIH1cbiAgdW5yZWdpc3Rlcih0KSB7XG4gICAgdCA9PT0gdGhpcy50YXJnZXQgJiYgKHRoaXMudGFyZ2V0ID0gdm9pZCAwKTtcbiAgfVxuICBvbk1vdXNlTW92ZSh0KSB7XG4gICAgdmFyIGU7XG4gICAgISgoZSA9IHRoaXMudGFyZ2V0KSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDApICYmIGUuaXNFZGl0aW5nICYmIHRoaXMudGFyZ2V0LnVwZGF0ZVNlbGVjdGlvbk9uTW91c2VNb3ZlKHQpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMudGFyZ2V0cyA9IFtdLCB0aGlzLnRhcmdldCA9IHZvaWQgMDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuY2xlYXIoKSwgdGhpcy5fX2Rpc3Bvc2VyKCksIGRlbGV0ZSB0aGlzLl9fZGlzcG9zZXI7XG4gIH1cbn1cbmNvbnN0IG5kID0gW1widGFyZ2V0XCIsIFwib2xkVGFyZ2V0XCIsIFwiZmlyZUNhbnZhc1wiLCBcImVcIl0sIGJ0ID0geyBwYXNzaXZlOiAhMSB9LCBLZSA9IChpLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBpLmdldFZpZXdwb3J0UG9pbnQodCksIHMgPSBpLmdldFNjZW5lUG9pbnQodCk7XG4gIHJldHVybiB7IHZpZXdwb3J0UG9pbnQ6IGUsIHNjZW5lUG9pbnQ6IHMsIHBvaW50ZXI6IGUsIGFic29sdXRlUG9pbnRlcjogcyB9O1xufSwgYmUgPSBmdW5jdGlvbihpKSB7XG4gIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBlID0gbmV3IEFycmF5KHQgPiAxID8gdCAtIDEgOiAwKSwgcyA9IDE7IHMgPCB0OyBzKyspIGVbcyAtIDFdID0gYXJndW1lbnRzW3NdO1xuICByZXR1cm4gaS5hZGRFdmVudExpc3RlbmVyKC4uLmUpO1xufSwgeHQgPSBmdW5jdGlvbihpKSB7XG4gIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBlID0gbmV3IEFycmF5KHQgPiAxID8gdCAtIDEgOiAwKSwgcyA9IDE7IHMgPCB0OyBzKyspIGVbcyAtIDFdID0gYXJndW1lbnRzW3NdO1xuICByZXR1cm4gaS5yZW1vdmVFdmVudExpc3RlbmVyKC4uLmUpO1xufSwgb2QgPSB7IG1vdXNlOiB7IGluOiBcIm92ZXJcIiwgb3V0OiBcIm91dFwiLCB0YXJnZXRJbjogXCJtb3VzZW92ZXJcIiwgdGFyZ2V0T3V0OiBcIm1vdXNlb3V0XCIsIGNhbnZhc0luOiBcIm1vdXNlOm92ZXJcIiwgY2FudmFzT3V0OiBcIm1vdXNlOm91dFwiIH0sIGRyYWc6IHsgaW46IFwiZW50ZXJcIiwgb3V0OiBcImxlYXZlXCIsIHRhcmdldEluOiBcImRyYWdlbnRlclwiLCB0YXJnZXRPdXQ6IFwiZHJhZ2xlYXZlXCIsIGNhbnZhc0luOiBcImRyYWc6ZW50ZXJcIiwgY2FudmFzT3V0OiBcImRyYWc6bGVhdmVcIiB9IH07XG5jbGFzcyB2biBleHRlbmRzIE9pIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKHQsIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge30pLCB5KHRoaXMsIFwiX2lzQ2xpY2tcIiwgdm9pZCAwKSwgeSh0aGlzLCBcInRleHRFZGl0aW5nTWFuYWdlclwiLCBuZXcgaWQodGhpcykpLCBbXCJfb25Nb3VzZURvd25cIiwgXCJfb25Ub3VjaFN0YXJ0XCIsIFwiX29uTW91c2VNb3ZlXCIsIFwiX29uTW91c2VVcFwiLCBcIl9vblRvdWNoRW5kXCIsIFwiX29uUmVzaXplXCIsIFwiX29uTW91c2VXaGVlbFwiLCBcIl9vbk1vdXNlT3V0XCIsIFwiX29uTW91c2VFbnRlclwiLCBcIl9vbkNvbnRleHRNZW51XCIsIFwiX29uRG91YmxlQ2xpY2tcIiwgXCJfb25EcmFnU3RhcnRcIiwgXCJfb25EcmFnRW5kXCIsIFwiX29uRHJhZ1Byb2dyZXNzXCIsIFwiX29uRHJhZ092ZXJcIiwgXCJfb25EcmFnRW50ZXJcIiwgXCJfb25EcmFnTGVhdmVcIiwgXCJfb25Ecm9wXCJdLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXNbZV0gPSB0aGlzW2VdLmJpbmQodGhpcyk7XG4gICAgfSksIHRoaXMuYWRkT3JSZW1vdmUoYmUsIFwiYWRkXCIpO1xuICB9XG4gIF9nZXRFdmVudFByZWZpeCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVQb2ludGVyRXZlbnRzID8gXCJwb2ludGVyXCIgOiBcIm1vdXNlXCI7XG4gIH1cbiAgYWRkT3JSZW1vdmUodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnVwcGVyQ2FudmFzRWwsIHIgPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgIHQoSmEocyksIFwicmVzaXplXCIsIHRoaXMuX29uUmVzaXplKSwgdChzLCByICsgXCJkb3duXCIsIHRoaXMuX29uTW91c2VEb3duKSwgdChzLCBcIlwiLmNvbmNhdChyLCBcIm1vdmVcIiksIHRoaXMuX29uTW91c2VNb3ZlLCBidCksIHQocywgXCJcIi5jb25jYXQociwgXCJvdXRcIiksIHRoaXMuX29uTW91c2VPdXQpLCB0KHMsIFwiXCIuY29uY2F0KHIsIFwiZW50ZXJcIiksIHRoaXMuX29uTW91c2VFbnRlciksIHQocywgXCJ3aGVlbFwiLCB0aGlzLl9vbk1vdXNlV2hlZWwpLCB0KHMsIFwiY29udGV4dG1lbnVcIiwgdGhpcy5fb25Db250ZXh0TWVudSksIHQocywgXCJkYmxjbGlja1wiLCB0aGlzLl9vbkRvdWJsZUNsaWNrKSwgdChzLCBcImRyYWdzdGFydFwiLCB0aGlzLl9vbkRyYWdTdGFydCksIHQocywgXCJkcmFnZW5kXCIsIHRoaXMuX29uRHJhZ0VuZCksIHQocywgXCJkcmFnb3ZlclwiLCB0aGlzLl9vbkRyYWdPdmVyKSwgdChzLCBcImRyYWdlbnRlclwiLCB0aGlzLl9vbkRyYWdFbnRlciksIHQocywgXCJkcmFnbGVhdmVcIiwgdGhpcy5fb25EcmFnTGVhdmUpLCB0KHMsIFwiZHJvcFwiLCB0aGlzLl9vbkRyb3ApLCB0aGlzLmVuYWJsZVBvaW50ZXJFdmVudHMgfHwgdChzLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25Ub3VjaFN0YXJ0LCBidCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuYWRkT3JSZW1vdmUoeHQsIFwicmVtb3ZlXCIpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpLCBlID0gQXQodGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICB4dChlLCBcIlwiLmNvbmNhdCh0LCBcInVwXCIpLCB0aGlzLl9vbk1vdXNlVXApLCB4dChlLCBcInRvdWNoZW5kXCIsIHRoaXMuX29uVG91Y2hFbmQsIGJ0KSwgeHQoZSwgXCJcIi5jb25jYXQodCwgXCJtb3ZlXCIpLCB0aGlzLl9vbk1vdXNlTW92ZSwgYnQpLCB4dChlLCBcInRvdWNobW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSwgYnQpLCBjbGVhclRpbWVvdXQodGhpcy5fd2lsbEFkZE1vdXNlRG93bik7XG4gIH1cbiAgX29uTW91c2VXaGVlbCh0KSB7XG4gICAgdGhpcy5fX29uTW91c2VXaGVlbCh0KTtcbiAgfVxuICBfb25Nb3VzZU91dCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2hvdmVyZWRUYXJnZXQsIHMgPSB2KHsgZTogdCB9LCBLZSh0aGlzLCB0KSk7XG4gICAgdGhpcy5maXJlKFwibW91c2U6b3V0XCIsIHYodih7fSwgcyksIHt9LCB7IHRhcmdldDogZSB9KSksIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSB2b2lkIDAsIGUgJiYgZS5maXJlKFwibW91c2VvdXRcIiwgdih7fSwgcykpLCB0aGlzLl9ob3ZlcmVkVGFyZ2V0cy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICB0aGlzLmZpcmUoXCJtb3VzZTpvdXRcIiwgdih2KHt9LCBzKSwge30sIHsgdGFyZ2V0OiByIH0pKSwgciAmJiByLmZpcmUoXCJtb3VzZW91dFwiLCB2KHt9LCBzKSk7XG4gICAgfSksIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gW107XG4gIH1cbiAgX29uTW91c2VFbnRlcih0KSB7XG4gICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSB8fCB0aGlzLmZpbmRUYXJnZXQodCkgfHwgKHRoaXMuZmlyZShcIm1vdXNlOm92ZXJcIiwgdih7IGU6IHQgfSwgS2UodGhpcywgdCkpKSwgdGhpcy5faG92ZXJlZFRhcmdldCA9IHZvaWQgMCwgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXSk7XG4gIH1cbiAgX29uRHJhZ1N0YXJ0KHQpIHtcbiAgICB0aGlzLl9pc0NsaWNrID0gITE7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0KCk7XG4gICAgaWYgKGUgJiYgZS5vbkRyYWdTdGFydCh0KSkge1xuICAgICAgdGhpcy5fZHJhZ1NvdXJjZSA9IGU7XG4gICAgICBjb25zdCBzID0geyBlOiB0LCB0YXJnZXQ6IGUgfTtcbiAgICAgIHJldHVybiB0aGlzLmZpcmUoXCJkcmFnc3RhcnRcIiwgcyksIGUuZmlyZShcImRyYWdzdGFydFwiLCBzKSwgdm9pZCBiZSh0aGlzLnVwcGVyQ2FudmFzRWwsIFwiZHJhZ1wiLCB0aGlzLl9vbkRyYWdQcm9ncmVzcyk7XG4gICAgfVxuICAgIG9uKHQpO1xuICB9XG4gIF9yZW5kZXJEcmFnRWZmZWN0cyh0LCBlLCBzKSB7XG4gICAgbGV0IHIgPSAhMTtcbiAgICBjb25zdCBuID0gdGhpcy5fZHJvcFRhcmdldDtcbiAgICBuICYmIG4gIT09IGUgJiYgbiAhPT0gcyAmJiAobi5jbGVhckNvbnRleHRUb3AoKSwgciA9ICEwKSwgZSA9PSBudWxsIHx8IGUuY2xlYXJDb250ZXh0VG9wKCksIHMgIT09IGUgJiYgKHMgPT0gbnVsbCB8fCBzLmNsZWFyQ29udGV4dFRvcCgpKTtcbiAgICBjb25zdCBvID0gdGhpcy5jb250ZXh0VG9wO1xuICAgIG8uc2F2ZSgpLCBvLnRyYW5zZm9ybSguLi50aGlzLnZpZXdwb3J0VHJhbnNmb3JtKSwgZSAmJiAoby5zYXZlKCksIGUudHJhbnNmb3JtKG8pLCBlLnJlbmRlckRyYWdTb3VyY2VFZmZlY3QodCksIG8ucmVzdG9yZSgpLCByID0gITApLCBzICYmIChvLnNhdmUoKSwgcy50cmFuc2Zvcm0obyksIHMucmVuZGVyRHJvcFRhcmdldEVmZmVjdCh0KSwgby5yZXN0b3JlKCksIHIgPSAhMCksIG8ucmVzdG9yZSgpLCByICYmICh0aGlzLmNvbnRleHRUb3BEaXJ0eSA9ICEwKTtcbiAgfVxuICBfb25EcmFnRW5kKHQpIHtcbiAgICBjb25zdCBlID0gISF0LmRhdGFUcmFuc2ZlciAmJiB0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ICE9PSBwdCwgcyA9IGUgPyB0aGlzLl9hY3RpdmVPYmplY3QgOiB2b2lkIDAsIHIgPSB7IGU6IHQsIHRhcmdldDogdGhpcy5fZHJhZ1NvdXJjZSwgc3ViVGFyZ2V0czogdGhpcy50YXJnZXRzLCBkcmFnU291cmNlOiB0aGlzLl9kcmFnU291cmNlLCBkaWREcm9wOiBlLCBkcm9wVGFyZ2V0OiBzIH07XG4gICAgeHQodGhpcy51cHBlckNhbnZhc0VsLCBcImRyYWdcIiwgdGhpcy5fb25EcmFnUHJvZ3Jlc3MpLCB0aGlzLmZpcmUoXCJkcmFnZW5kXCIsIHIpLCB0aGlzLl9kcmFnU291cmNlICYmIHRoaXMuX2RyYWdTb3VyY2UuZmlyZShcImRyYWdlbmRcIiwgciksIGRlbGV0ZSB0aGlzLl9kcmFnU291cmNlLCB0aGlzLl9vbk1vdXNlVXAodCk7XG4gIH1cbiAgX29uRHJhZ1Byb2dyZXNzKHQpIHtcbiAgICBjb25zdCBlID0geyBlOiB0LCB0YXJnZXQ6IHRoaXMuX2RyYWdTb3VyY2UsIGRyYWdTb3VyY2U6IHRoaXMuX2RyYWdTb3VyY2UsIGRyb3BUYXJnZXQ6IHRoaXMuX2RyYWdnZWRvdmVyVGFyZ2V0IH07XG4gICAgdGhpcy5maXJlKFwiZHJhZ1wiLCBlKSwgdGhpcy5fZHJhZ1NvdXJjZSAmJiB0aGlzLl9kcmFnU291cmNlLmZpcmUoXCJkcmFnXCIsIGUpO1xuICB9XG4gIGZpbmREcmFnVGFyZ2V0cyh0KSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0cyA9IFtdLCB7IHRhcmdldDogdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKHRoaXMuX29iamVjdHMsIHRoaXMuZ2V0Vmlld3BvcnRQb2ludCh0KSksIHRhcmdldHM6IFsuLi50aGlzLnRhcmdldHNdIH07XG4gIH1cbiAgX29uRHJhZ092ZXIodCkge1xuICAgIGNvbnN0IGUgPSBcImRyYWdvdmVyXCIsIHsgdGFyZ2V0OiBzLCB0YXJnZXRzOiByIH0gPSB0aGlzLmZpbmREcmFnVGFyZ2V0cyh0KSwgbiA9IHRoaXMuX2RyYWdTb3VyY2UsIG8gPSB7IGU6IHQsIHRhcmdldDogcywgc3ViVGFyZ2V0czogciwgZHJhZ1NvdXJjZTogbiwgY2FuRHJvcDogITEsIGRyb3BUYXJnZXQ6IHZvaWQgMCB9O1xuICAgIGxldCBhO1xuICAgIHRoaXMuZmlyZShlLCBvKSwgdGhpcy5fZmlyZUVudGVyTGVhdmVFdmVudHMocywgbyksIHMgJiYgKHMuY2FuRHJvcCh0KSAmJiAoYSA9IHMpLCBzLmZpcmUoZSwgbykpO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgci5sZW5ndGg7IGMrKykge1xuICAgICAgY29uc3QgbCA9IHJbY107XG4gICAgICBsLmNhbkRyb3AodCkgJiYgKGEgPSBsKSwgbC5maXJlKGUsIG8pO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJEcmFnRWZmZWN0cyh0LCBuLCBhKSwgdGhpcy5fZHJvcFRhcmdldCA9IGE7XG4gIH1cbiAgX29uRHJhZ0VudGVyKHQpIHtcbiAgICBjb25zdCB7IHRhcmdldDogZSwgdGFyZ2V0czogcyB9ID0gdGhpcy5maW5kRHJhZ1RhcmdldHModCksIHIgPSB7IGU6IHQsIHRhcmdldDogZSwgc3ViVGFyZ2V0czogcywgZHJhZ1NvdXJjZTogdGhpcy5fZHJhZ1NvdXJjZSB9O1xuICAgIHRoaXMuZmlyZShcImRyYWdlbnRlclwiLCByKSwgdGhpcy5fZmlyZUVudGVyTGVhdmVFdmVudHMoZSwgcik7XG4gIH1cbiAgX29uRHJhZ0xlYXZlKHQpIHtcbiAgICBjb25zdCBlID0geyBlOiB0LCB0YXJnZXQ6IHRoaXMuX2RyYWdnZWRvdmVyVGFyZ2V0LCBzdWJUYXJnZXRzOiB0aGlzLnRhcmdldHMsIGRyYWdTb3VyY2U6IHRoaXMuX2RyYWdTb3VyY2UgfTtcbiAgICB0aGlzLmZpcmUoXCJkcmFnbGVhdmVcIiwgZSksIHRoaXMuX2ZpcmVFbnRlckxlYXZlRXZlbnRzKHZvaWQgMCwgZSksIHRoaXMuX3JlbmRlckRyYWdFZmZlY3RzKHQsIHRoaXMuX2RyYWdTb3VyY2UpLCB0aGlzLl9kcm9wVGFyZ2V0ID0gdm9pZCAwLCB0aGlzLnRhcmdldHMgPSBbXSwgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgfVxuICBfb25Ecm9wKHQpIHtcbiAgICBjb25zdCB7IHRhcmdldDogZSwgdGFyZ2V0czogcyB9ID0gdGhpcy5maW5kRHJhZ1RhcmdldHModCksIHIgPSB0aGlzLl9iYXNpY0V2ZW50SGFuZGxlcihcImRyb3A6YmVmb3JlXCIsIHYoeyBlOiB0LCB0YXJnZXQ6IGUsIHN1YlRhcmdldHM6IHMsIGRyYWdTb3VyY2U6IHRoaXMuX2RyYWdTb3VyY2UgfSwgS2UodGhpcywgdCkpKTtcbiAgICByLmRpZERyb3AgPSAhMSwgci5kcm9wVGFyZ2V0ID0gdm9pZCAwLCB0aGlzLl9iYXNpY0V2ZW50SGFuZGxlcihcImRyb3BcIiwgciksIHRoaXMuZmlyZShcImRyb3A6YWZ0ZXJcIiwgcik7XG4gIH1cbiAgX29uQ29udGV4dE1lbnUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmZpbmRUYXJnZXQodCksIHMgPSB0aGlzLnRhcmdldHMgfHwgW10sIHIgPSB0aGlzLl9iYXNpY0V2ZW50SGFuZGxlcihcImNvbnRleHRtZW51OmJlZm9yZVwiLCB7IGU6IHQsIHRhcmdldDogZSwgc3ViVGFyZ2V0czogcyB9KTtcbiAgICByZXR1cm4gdGhpcy5zdG9wQ29udGV4dE1lbnUgJiYgb24odCksIHRoaXMuX2Jhc2ljRXZlbnRIYW5kbGVyKFwiY29udGV4dG1lbnVcIiwgciksICExO1xuICB9XG4gIF9vbkRvdWJsZUNsaWNrKHQpIHtcbiAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YSh0KSwgdGhpcy5faGFuZGxlRXZlbnQodCwgXCJkYmxjbGlja1wiKSwgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgfVxuICBnZXRQb2ludGVySWQodCkge1xuICAgIGNvbnN0IGUgPSB0LmNoYW5nZWRUb3VjaGVzO1xuICAgIHJldHVybiBlID8gZVswXSAmJiBlWzBdLmlkZW50aWZpZXIgOiB0aGlzLmVuYWJsZVBvaW50ZXJFdmVudHMgPyB0LnBvaW50ZXJJZCA6IC0xO1xuICB9XG4gIF9pc01haW5FdmVudCh0KSB7XG4gICAgcmV0dXJuIHQuaXNQcmltYXJ5ID09PSAhMCB8fCB0LmlzUHJpbWFyeSAhPT0gITEgJiYgKHQudHlwZSA9PT0gXCJ0b3VjaGVuZFwiICYmIHQudG91Y2hlcy5sZW5ndGggPT09IDAgfHwgIXQuY2hhbmdlZFRvdWNoZXMgfHwgdC5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyID09PSB0aGlzLm1haW5Ub3VjaElkKTtcbiAgfVxuICBfb25Ub3VjaFN0YXJ0KHQpIHtcbiAgICBsZXQgZSA9ICF0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmc7XG4gICAgY29uc3QgcyA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICB0aGlzLm1haW5Ub3VjaElkID09PSB2b2lkIDAgJiYgKHRoaXMubWFpblRvdWNoSWQgPSB0aGlzLmdldFBvaW50ZXJJZCh0KSksIHRoaXMuX19vbk1vdXNlRG93bih0KSwgKHRoaXMuaXNEcmF3aW5nTW9kZSB8fCBzICYmIHRoaXMuX3RhcmdldCA9PT0gcykgJiYgKGUgPSAhMCksIGUgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgIGNvbnN0IHIgPSB0aGlzLnVwcGVyQ2FudmFzRWwsIG4gPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpLCBvID0gQXQocik7XG4gICAgYmUobywgXCJ0b3VjaGVuZFwiLCB0aGlzLl9vblRvdWNoRW5kLCBidCksIGUgJiYgYmUobywgXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUsIGJ0KSwgeHQociwgXCJcIi5jb25jYXQobiwgXCJkb3duXCIpLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gIH1cbiAgX29uTW91c2VEb3duKHQpIHtcbiAgICB0aGlzLl9fb25Nb3VzZURvd24odCksIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgY29uc3QgZSA9IHRoaXMudXBwZXJDYW52YXNFbCwgcyA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgeHQoZSwgXCJcIi5jb25jYXQocywgXCJtb3ZlXCIpLCB0aGlzLl9vbk1vdXNlTW92ZSwgYnQpO1xuICAgIGNvbnN0IHIgPSBBdChlKTtcbiAgICBiZShyLCBcIlwiLmNvbmNhdChzLCBcInVwXCIpLCB0aGlzLl9vbk1vdXNlVXApLCBiZShyLCBcIlwiLmNvbmNhdChzLCBcIm1vdmVcIiksIHRoaXMuX29uTW91c2VNb3ZlLCBidCk7XG4gIH1cbiAgX29uVG91Y2hFbmQodCkge1xuICAgIGlmICh0LnRvdWNoZXMubGVuZ3RoID4gMCkgcmV0dXJuO1xuICAgIHRoaXMuX19vbk1vdXNlVXAodCksIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCksIGRlbGV0ZSB0aGlzLm1haW5Ub3VjaElkO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpLCBzID0gQXQodGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICB4dChzLCBcInRvdWNoZW5kXCIsIHRoaXMuX29uVG91Y2hFbmQsIGJ0KSwgeHQocywgXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUsIGJ0KSwgdGhpcy5fd2lsbEFkZE1vdXNlRG93biAmJiBjbGVhclRpbWVvdXQodGhpcy5fd2lsbEFkZE1vdXNlRG93biksIHRoaXMuX3dpbGxBZGRNb3VzZURvd24gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGJlKHRoaXMudXBwZXJDYW52YXNFbCwgXCJcIi5jb25jYXQoZSwgXCJkb3duXCIpLCB0aGlzLl9vbk1vdXNlRG93biksIHRoaXMuX3dpbGxBZGRNb3VzZURvd24gPSAwO1xuICAgIH0sIDQwMCk7XG4gIH1cbiAgX29uTW91c2VVcCh0KSB7XG4gICAgdGhpcy5fX29uTW91c2VVcCh0KSwgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICBjb25zdCBlID0gdGhpcy51cHBlckNhbnZhc0VsLCBzID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICBpZiAodGhpcy5faXNNYWluRXZlbnQodCkpIHtcbiAgICAgIGNvbnN0IHIgPSBBdCh0aGlzLnVwcGVyQ2FudmFzRWwpO1xuICAgICAgeHQociwgXCJcIi5jb25jYXQocywgXCJ1cFwiKSwgdGhpcy5fb25Nb3VzZVVwKSwgeHQociwgXCJcIi5jb25jYXQocywgXCJtb3ZlXCIpLCB0aGlzLl9vbk1vdXNlTW92ZSwgYnQpLCBiZShlLCBcIlwiLmNvbmNhdChzLCBcIm1vdmVcIiksIHRoaXMuX29uTW91c2VNb3ZlLCBidCk7XG4gICAgfVxuICB9XG4gIF9vbk1vdXNlTW92ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0KCk7XG4gICAgIXRoaXMuYWxsb3dUb3VjaFNjcm9sbGluZyAmJiAoIWUgfHwgIWUuc2hvdWxkU3RhcnREcmFnZ2luZyh0KSkgJiYgdC5wcmV2ZW50RGVmYXVsdCAmJiB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX19vbk1vdXNlTW92ZSh0KTtcbiAgfVxuICBfb25SZXNpemUoKSB7XG4gICAgdGhpcy5jYWxjT2Zmc2V0KCksIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gIH1cbiAgX3Nob3VsZFJlbmRlcih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0KCk7XG4gICAgcmV0dXJuICEhZSAhPSAhIXQgfHwgZSAmJiB0ICYmIGUgIT09IHQ7XG4gIH1cbiAgX19vbk1vdXNlVXAodCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKHQpLCB0aGlzLl9oYW5kbGVFdmVudCh0LCBcInVwOmJlZm9yZVwiKTtcbiAgICBjb25zdCBzID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSwgciA9IHRoaXMuX2lzQ2xpY2ssIG4gPSB0aGlzLl90YXJnZXQsIHsgYnV0dG9uOiBvIH0gPSB0O1xuICAgIGlmIChvKSByZXR1cm4gKHRoaXMuZmlyZU1pZGRsZUNsaWNrICYmIG8gPT09IDEgfHwgdGhpcy5maXJlUmlnaHRDbGljayAmJiBvID09PSAyKSAmJiB0aGlzLl9oYW5kbGVFdmVudCh0LCBcInVwXCIpLCB2b2lkIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHJldHVybiB2b2lkIHRoaXMuX29uTW91c2VVcEluRHJhd2luZ01vZGUodCk7XG4gICAgaWYgKCF0aGlzLl9pc01haW5FdmVudCh0KSkgcmV0dXJuO1xuICAgIGxldCBhLCBjLCBsID0gITE7XG4gICAgaWYgKHMgJiYgKHRoaXMuX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybSh0KSwgbCA9IHMuYWN0aW9uUGVyZm9ybWVkKSwgIXIpIHtcbiAgICAgIGNvbnN0IGggPSBuID09PSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICB0aGlzLmhhbmRsZVNlbGVjdGlvbih0KSwgbCB8fCAobCA9IHRoaXMuX3Nob3VsZFJlbmRlcihuKSB8fCAhaCAmJiBuID09PSB0aGlzLl9hY3RpdmVPYmplY3QpO1xuICAgIH1cbiAgICBpZiAobikge1xuICAgICAgY29uc3QgaCA9IG4uZmluZENvbnRyb2wodGhpcy5nZXRWaWV3cG9ydFBvaW50KHQpLCBLcih0KSksIHsga2V5OiB1LCBjb250cm9sOiBkIH0gPSBoIHx8IHt9O1xuICAgICAgaWYgKGMgPSB1LCBuLnNlbGVjdGFibGUgJiYgbiAhPT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIG4uYWN0aXZlT24gPT09IFwidXBcIikgdGhpcy5zZXRBY3RpdmVPYmplY3QobiwgdCksIGwgPSAhMDtcbiAgICAgIGVsc2UgaWYgKGQpIHtcbiAgICAgICAgY29uc3QgZiA9IGQuZ2V0TW91c2VVcEhhbmRsZXIodCwgbiwgZCk7XG4gICAgICAgIGYgJiYgKGEgPSB0aGlzLmdldFNjZW5lUG9pbnQodCksIGYuY2FsbChkLCB0LCBzLCBhLngsIGEueSkpO1xuICAgICAgfVxuICAgICAgbi5pc01vdmluZyA9ICExO1xuICAgIH1cbiAgICBpZiAocyAmJiAocy50YXJnZXQgIT09IG4gfHwgcy5jb3JuZXIgIT09IGMpKSB7XG4gICAgICBjb25zdCBoID0gcy50YXJnZXQgJiYgcy50YXJnZXQuY29udHJvbHNbcy5jb3JuZXJdLCB1ID0gaCAmJiBoLmdldE1vdXNlVXBIYW5kbGVyKHQsIHMudGFyZ2V0LCBoKTtcbiAgICAgIGEgPSBhIHx8IHRoaXMuZ2V0U2NlbmVQb2ludCh0KSwgdSAmJiB1LmNhbGwoaCwgdCwgcywgYS54LCBhLnkpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRDdXJzb3JGcm9tRXZlbnQodCwgbiksIHRoaXMuX2hhbmRsZUV2ZW50KHQsIFwidXBcIiksIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsLCB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbnVsbCwgbiAmJiAobi5fX2Nvcm5lciA9IHZvaWQgMCksIGwgPyB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKSA6IHIgfHwgKGUgPSB0aGlzLl9hY3RpdmVPYmplY3QpICE9PSBudWxsICYmIGUgIT09IHZvaWQgMCAmJiBlLmlzRWRpdGluZyB8fCB0aGlzLnJlbmRlclRvcCgpO1xuICB9XG4gIF9iYXNpY0V2ZW50SGFuZGxlcih0LCBlKSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IHMsIHN1YlRhcmdldHM6IHIgPSBbXSB9ID0gZTtcbiAgICB0aGlzLmZpcmUodCwgZSksIHMgJiYgcy5maXJlKHQsIGUpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgci5sZW5ndGg7IG4rKykgcltuXSAhPT0gcyAmJiByW25dLmZpcmUodCwgZSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgX2hhbmRsZUV2ZW50KHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fdGFyZ2V0LCByID0gdGhpcy50YXJnZXRzIHx8IFtdLCBuID0gdih2KHsgZTogdCwgdGFyZ2V0OiBzLCBzdWJUYXJnZXRzOiByIH0sIEtlKHRoaXMsIHQpKSwge30sIHsgdHJhbnNmb3JtOiB0aGlzLl9jdXJyZW50VHJhbnNmb3JtIH0sIGUgPT09IFwidXA6YmVmb3JlXCIgfHwgZSA9PT0gXCJ1cFwiID8geyBpc0NsaWNrOiB0aGlzLl9pc0NsaWNrLCBjdXJyZW50VGFyZ2V0OiB0aGlzLmZpbmRUYXJnZXQodCksIGN1cnJlbnRTdWJUYXJnZXRzOiB0aGlzLnRhcmdldHMgfSA6IHt9KTtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZTpcIi5jb25jYXQoZSksIG4pLCBzICYmIHMuZmlyZShcIm1vdXNlXCIuY29uY2F0KGUpLCBuKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspIHJbb10gIT09IHMgJiYgcltvXS5maXJlKFwibW91c2VcIi5jb25jYXQoZSksIG4pO1xuICB9XG4gIF9vbk1vdXNlRG93bkluRHJhd2luZ01vZGUodCkge1xuICAgIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyA9ICEwLCB0aGlzLmdldEFjdGl2ZU9iamVjdCgpICYmICh0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QodCksIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpKTtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRTY2VuZVBvaW50KHQpO1xuICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZURvd24oZSwgeyBlOiB0LCBwb2ludGVyOiBlIH0pLCB0aGlzLl9oYW5kbGVFdmVudCh0LCBcImRvd25cIik7XG4gIH1cbiAgX29uTW91c2VNb3ZlSW5EcmF3aW5nTW9kZSh0KSB7XG4gICAgaWYgKHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgY29uc3QgZSA9IHRoaXMuZ2V0U2NlbmVQb2ludCh0KTtcbiAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZU1vdmUoZSwgeyBlOiB0LCBwb2ludGVyOiBlIH0pO1xuICAgIH1cbiAgICB0aGlzLnNldEN1cnNvcih0aGlzLmZyZWVEcmF3aW5nQ3Vyc29yKSwgdGhpcy5faGFuZGxlRXZlbnQodCwgXCJtb3ZlXCIpO1xuICB9XG4gIF9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRTY2VuZVBvaW50KHQpO1xuICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCA/IHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyA9ICEhdGhpcy5mcmVlRHJhd2luZ0JydXNoLm9uTW91c2VVcCh7IGU6IHQsIHBvaW50ZXI6IGUgfSkgOiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcgPSAhMSwgdGhpcy5faGFuZGxlRXZlbnQodCwgXCJ1cFwiKTtcbiAgfVxuICBfX29uTW91c2VEb3duKHQpIHtcbiAgICB0aGlzLl9pc0NsaWNrID0gITAsIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKHQpLCB0aGlzLl9oYW5kbGVFdmVudCh0LCBcImRvd246YmVmb3JlXCIpO1xuICAgIGxldCBlID0gdGhpcy5fdGFyZ2V0O1xuICAgIGNvbnN0IHsgYnV0dG9uOiBzIH0gPSB0O1xuICAgIGlmIChzKSByZXR1cm4gKHRoaXMuZmlyZU1pZGRsZUNsaWNrICYmIHMgPT09IDEgfHwgdGhpcy5maXJlUmlnaHRDbGljayAmJiBzID09PSAyKSAmJiB0aGlzLl9oYW5kbGVFdmVudCh0LCBcImRvd25cIiksIHZvaWQgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlKSByZXR1cm4gdm9pZCB0aGlzLl9vbk1vdXNlRG93bkluRHJhd2luZ01vZGUodCk7XG4gICAgaWYgKCF0aGlzLl9pc01haW5FdmVudCh0KSB8fCB0aGlzLl9jdXJyZW50VHJhbnNmb3JtKSByZXR1cm47XG4gICAgbGV0IHIgPSB0aGlzLl9zaG91bGRSZW5kZXIoZSksIG4gPSAhMTtcbiAgICBpZiAodGhpcy5oYW5kbGVNdWx0aVNlbGVjdGlvbih0LCBlKSA/IChlID0gdGhpcy5fYWN0aXZlT2JqZWN0LCBuID0gITAsIHIgPSAhMCkgOiB0aGlzLl9zaG91bGRDbGVhclNlbGVjdGlvbih0LCBlKSAmJiB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QodCksIHRoaXMuc2VsZWN0aW9uICYmICghZSB8fCAhZS5zZWxlY3RhYmxlICYmICFlLmlzRWRpdGluZyAmJiBlICE9PSB0aGlzLl9hY3RpdmVPYmplY3QpKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5nZXRTY2VuZVBvaW50KHQpO1xuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IHsgeDogby54LCB5OiBvLnksIGRlbHRhWTogMCwgZGVsdGFYOiAwIH07XG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICBjb25zdCBvID0gZSA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgZS5zZWxlY3RhYmxlICYmIGUuYWN0aXZlT24gPT09IFwiZG93blwiICYmIHRoaXMuc2V0QWN0aXZlT2JqZWN0KGUsIHQpO1xuICAgICAgY29uc3QgYSA9IGUuZmluZENvbnRyb2wodGhpcy5nZXRWaWV3cG9ydFBvaW50KHQpLCBLcih0KSk7XG4gICAgICBpZiAoZSA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIChhIHx8ICFuKSkge1xuICAgICAgICB0aGlzLl9zZXR1cEN1cnJlbnRUcmFuc2Zvcm0odCwgZSwgbyk7XG4gICAgICAgIGNvbnN0IGMgPSBhID8gYS5jb250cm9sIDogdm9pZCAwLCBsID0gdGhpcy5nZXRTY2VuZVBvaW50KHQpLCBoID0gYyAmJiBjLmdldE1vdXNlRG93bkhhbmRsZXIodCwgZSwgYyk7XG4gICAgICAgIGggJiYgaC5jYWxsKGMsIHQsIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sIGwueCwgbC55KTtcbiAgICAgIH1cbiAgICB9XG4gICAgciAmJiAodGhpcy5fb2JqZWN0c1RvUmVuZGVyID0gdm9pZCAwKSwgdGhpcy5faGFuZGxlRXZlbnQodCwgXCJkb3duXCIpLCByICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9XG4gIF9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpIHtcbiAgICB0aGlzLl90YXJnZXQgPSB0aGlzLl9wb2ludGVyID0gdGhpcy5fYWJzb2x1dGVQb2ludGVyID0gdm9pZCAwO1xuICB9XG4gIF9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YSh0KSB7XG4gICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKSwgdGhpcy5fcG9pbnRlciA9IHRoaXMuZ2V0Vmlld3BvcnRQb2ludCh0KSwgdGhpcy5fYWJzb2x1dGVQb2ludGVyID0gYWUodGhpcy5fcG9pbnRlciwgdm9pZCAwLCB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKSwgdGhpcy5fdGFyZ2V0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSA/IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0IDogdGhpcy5maW5kVGFyZ2V0KHQpO1xuICB9XG4gIF9fb25Nb3VzZU1vdmUodCkge1xuICAgIGlmICh0aGlzLl9pc0NsaWNrID0gITEsIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKHQpLCB0aGlzLl9oYW5kbGVFdmVudCh0LCBcIm1vdmU6YmVmb3JlXCIpLCB0aGlzLmlzRHJhd2luZ01vZGUpIHJldHVybiB2b2lkIHRoaXMuX29uTW91c2VNb3ZlSW5EcmF3aW5nTW9kZSh0KTtcbiAgICBpZiAoIXRoaXMuX2lzTWFpbkV2ZW50KHQpKSByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dyb3VwU2VsZWN0b3I7XG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmdldFNjZW5lUG9pbnQodCk7XG4gICAgICBlLmRlbHRhWCA9IHMueCAtIGUueCwgZS5kZWx0YVkgPSBzLnkgLSBlLnksIHRoaXMucmVuZGVyVG9wKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jdXJyZW50VHJhbnNmb3JtKSB0aGlzLl90cmFuc2Zvcm1PYmplY3QodCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5maW5kVGFyZ2V0KHQpO1xuICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KHQsIHMpLCB0aGlzLl9maXJlT3Zlck91dEV2ZW50cyh0LCBzKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0RWRpdGluZ01hbmFnZXIub25Nb3VzZU1vdmUodCksIHRoaXMuX2hhbmRsZUV2ZW50KHQsIFwibW92ZVwiKSwgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgfVxuICBfZmlyZU92ZXJPdXRFdmVudHModCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0LCByID0gdGhpcy5faG92ZXJlZFRhcmdldHMsIG4gPSB0aGlzLnRhcmdldHMsIG8gPSBNYXRoLm1heChyLmxlbmd0aCwgbi5sZW5ndGgpO1xuICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKFwibW91c2VcIiwgeyBlOiB0LCB0YXJnZXQ6IGUsIG9sZFRhcmdldDogcywgZmlyZUNhbnZhczogITAgfSk7XG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCBvOyBhKyspIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKFwibW91c2VcIiwgeyBlOiB0LCB0YXJnZXQ6IG5bYV0sIG9sZFRhcmdldDogclthXSB9KTtcbiAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gZSwgdGhpcy5faG92ZXJlZFRhcmdldHMgPSB0aGlzLnRhcmdldHMuY29uY2F0KCk7XG4gIH1cbiAgX2ZpcmVFbnRlckxlYXZlRXZlbnRzKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fZHJhZ2dlZG92ZXJUYXJnZXQsIHIgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0cywgbiA9IHRoaXMudGFyZ2V0cywgbyA9IE1hdGgubWF4KHIubGVuZ3RoLCBuLmxlbmd0aCk7XG4gICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHMoXCJkcmFnXCIsIHYodih7fSwgZSksIHt9LCB7IHRhcmdldDogdCwgb2xkVGFyZ2V0OiBzLCBmaXJlQ2FudmFzOiAhMCB9KSk7XG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCBvOyBhKyspIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKFwiZHJhZ1wiLCB2KHYoe30sIGUpLCB7fSwgeyB0YXJnZXQ6IG5bYV0sIG9sZFRhcmdldDogclthXSB9KSk7XG4gICAgdGhpcy5fZHJhZ2dlZG92ZXJUYXJnZXQgPSB0O1xuICB9XG4gIGZpcmVTeW50aGV0aWNJbk91dEV2ZW50cyh0LCBlKSB7XG4gICAgbGV0IHsgdGFyZ2V0OiBzLCBvbGRUYXJnZXQ6IHIsIGZpcmVDYW52YXM6IG4sIGU6IG8gfSA9IGUsIGEgPSBHKGUsIG5kKTtcbiAgICBjb25zdCB7IHRhcmdldEluOiBjLCB0YXJnZXRPdXQ6IGwsIGNhbnZhc0luOiBoLCBjYW52YXNPdXQ6IHUgfSA9IG9kW3RdLCBkID0gciAhPT0gcztcbiAgICBpZiAociAmJiBkKSB7XG4gICAgICBjb25zdCBmID0gdih2KHt9LCBhKSwge30sIHsgZTogbywgdGFyZ2V0OiByLCBuZXh0VGFyZ2V0OiBzIH0sIEtlKHRoaXMsIG8pKTtcbiAgICAgIG4gJiYgdGhpcy5maXJlKHUsIGYpLCByLmZpcmUobCwgZik7XG4gICAgfVxuICAgIGlmIChzICYmIGQpIHtcbiAgICAgIGNvbnN0IGYgPSB2KHYoe30sIGEpLCB7fSwgeyBlOiBvLCB0YXJnZXQ6IHMsIHByZXZpb3VzVGFyZ2V0OiByIH0sIEtlKHRoaXMsIG8pKTtcbiAgICAgIG4gJiYgdGhpcy5maXJlKGgsIGYpLCBzLmZpcmUoYywgZik7XG4gICAgfVxuICB9XG4gIF9fb25Nb3VzZVdoZWVsKHQpIHtcbiAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YSh0KSwgdGhpcy5faGFuZGxlRXZlbnQodCwgXCJ3aGVlbFwiKSwgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgfVxuICBfdHJhbnNmb3JtT2JqZWN0KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRTY2VuZVBvaW50KHQpLCBzID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSwgciA9IHMudGFyZ2V0LCBuID0gci5ncm91cCA/IGFlKGUsIHZvaWQgMCwgci5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KCkpIDogZTtcbiAgICBzLnNoaWZ0S2V5ID0gdC5zaGlmdEtleSwgcy5hbHRLZXkgPSAhIXRoaXMuY2VudGVyZWRLZXkgJiYgdFt0aGlzLmNlbnRlcmVkS2V5XSwgdGhpcy5fcGVyZm9ybVRyYW5zZm9ybUFjdGlvbih0LCBzLCBuKSwgcy5hY3Rpb25QZXJmb3JtZWQgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH1cbiAgX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb24odCwgZSwgcykge1xuICAgIGNvbnN0IHsgYWN0aW9uOiByLCBhY3Rpb25IYW5kbGVyOiBuLCB0YXJnZXQ6IG8gfSA9IGUsIGEgPSAhIW4gJiYgbih0LCBlLCBzLngsIHMueSk7XG4gICAgYSAmJiBvLnNldENvb3JkcygpLCByID09PSBcImRyYWdcIiAmJiBhICYmIChlLnRhcmdldC5pc01vdmluZyA9ICEwLCB0aGlzLnNldEN1cnNvcihlLnRhcmdldC5tb3ZlQ3Vyc29yIHx8IHRoaXMubW92ZUN1cnNvcikpLCBlLmFjdGlvblBlcmZvcm1lZCA9IGUuYWN0aW9uUGVyZm9ybWVkIHx8IGE7XG4gIH1cbiAgX3NldEN1cnNvckZyb21FdmVudCh0LCBlKSB7XG4gICAgaWYgKCFlKSByZXR1cm4gdm9pZCB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgIGxldCBzID0gZS5ob3ZlckN1cnNvciB8fCB0aGlzLmhvdmVyQ3Vyc29yO1xuICAgIGNvbnN0IHIgPSBQZSh0aGlzLl9hY3RpdmVPYmplY3QpID8gdGhpcy5fYWN0aXZlT2JqZWN0IDogbnVsbCwgbiA9ICghciB8fCBlLmdyb3VwICE9PSByKSAmJiBlLmZpbmRDb250cm9sKHRoaXMuZ2V0Vmlld3BvcnRQb2ludCh0KSk7XG4gICAgaWYgKG4pIHtcbiAgICAgIGNvbnN0IG8gPSBuLmNvbnRyb2w7XG4gICAgICB0aGlzLnNldEN1cnNvcihvLmN1cnNvclN0eWxlSGFuZGxlcih0LCBvLCBlKSk7XG4gICAgfSBlbHNlIGUuc3ViVGFyZ2V0Q2hlY2sgJiYgdGhpcy50YXJnZXRzLmNvbmNhdCgpLnJldmVyc2UoKS5tYXAoKG8pID0+IHtcbiAgICAgIHMgPSBvLmhvdmVyQ3Vyc29yIHx8IHM7XG4gICAgfSksIHRoaXMuc2V0Q3Vyc29yKHMpO1xuICB9XG4gIGhhbmRsZU11bHRpU2VsZWN0aW9uKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fYWN0aXZlT2JqZWN0LCByID0gUGUocyk7XG4gICAgaWYgKHMgJiYgdGhpcy5faXNTZWxlY3Rpb25LZXlQcmVzc2VkKHQpICYmIHRoaXMuc2VsZWN0aW9uICYmIGUgJiYgZS5zZWxlY3RhYmxlICYmIChzICE9PSBlIHx8IHIpICYmIChyIHx8ICFlLmlzRGVzY2VuZGFudE9mKHMpICYmICFzLmlzRGVzY2VuZGFudE9mKGUpKSAmJiAhZS5vblNlbGVjdCh7IGU6IHQgfSkgJiYgIXMuZ2V0QWN0aXZlQ29udHJvbCgpKSB7XG4gICAgICBpZiAocikge1xuICAgICAgICBjb25zdCBuID0gcy5nZXRPYmplY3RzKCk7XG4gICAgICAgIGlmIChlID09PSBzKSB7XG4gICAgICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0Vmlld3BvcnRQb2ludCh0KTtcbiAgICAgICAgICBpZiAoIShlID0gdGhpcy5zZWFyY2hQb3NzaWJsZVRhcmdldHMobiwgbykgfHwgdGhpcy5zZWFyY2hQb3NzaWJsZVRhcmdldHModGhpcy5fb2JqZWN0cywgbykpIHx8ICFlLnNlbGVjdGFibGUpIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgICBlLmdyb3VwID09PSBzID8gKHMucmVtb3ZlKGUpLCB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gZSwgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbLi4udGhpcy50YXJnZXRzXSwgcy5zaXplKCkgPT09IDEgJiYgdGhpcy5fc2V0QWN0aXZlT2JqZWN0KHMuaXRlbSgwKSwgdCkpIDogKHMubXVsdGlTZWxlY3RBZGQoZSksIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBzLCB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IFsuLi50aGlzLnRhcmdldHNdKSwgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhuLCB0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuaXNFZGl0aW5nICYmIHMuZXhpdEVkaXRpbmcoKTtcbiAgICAgICAgY29uc3QgbiA9IG5ldyAoQy5nZXRDbGFzcyhcIkFjdGl2ZVNlbGVjdGlvblwiKSkoW10sIHsgY2FudmFzOiB0aGlzIH0pO1xuICAgICAgICBuLm11bHRpU2VsZWN0QWRkKHMsIGUpLCB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbiwgdGhpcy5fc2V0QWN0aXZlT2JqZWN0KG4sIHQpLCB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKFtzXSwgdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBoYW5kbGVTZWxlY3Rpb24odCkge1xuICAgIGlmICghdGhpcy5zZWxlY3Rpb24gfHwgIXRoaXMuX2dyb3VwU2VsZWN0b3IpIHJldHVybiAhMTtcbiAgICBjb25zdCB7IHg6IGUsIHk6IHMsIGRlbHRhWDogciwgZGVsdGFZOiBuIH0gPSB0aGlzLl9ncm91cFNlbGVjdG9yLCBvID0gbmV3IF8oZSwgcyksIGEgPSBvLmFkZChuZXcgXyhyLCBuKSksIGMgPSBvLm1pbihhKSwgbCA9IG8ubWF4KGEpLnN1YnRyYWN0KGMpLCBoID0gdGhpcy5jb2xsZWN0T2JqZWN0cyh7IGxlZnQ6IGMueCwgdG9wOiBjLnksIHdpZHRoOiBsLngsIGhlaWdodDogbC55IH0sIHsgaW5jbHVkZUludGVyc2VjdGluZzogIXRoaXMuc2VsZWN0aW9uRnVsbHlDb250YWluZWQgfSksIHUgPSBvLmVxKGEpID8gaFswXSA/IFtoWzBdXSA6IFtdIDogaC5sZW5ndGggPiAxID8gaC5maWx0ZXIoKGQpID0+ICFkLm9uU2VsZWN0KHsgZTogdCB9KSkucmV2ZXJzZSgpIDogaDtcbiAgICBpZiAodS5sZW5ndGggPT09IDEpIHRoaXMuc2V0QWN0aXZlT2JqZWN0KHVbMF0sIHQpO1xuICAgIGVsc2UgaWYgKHUubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgZCA9IEMuZ2V0Q2xhc3MoXCJBY3RpdmVTZWxlY3Rpb25cIik7XG4gICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdChuZXcgZCh1LCB7IGNhbnZhczogdGhpcyB9KSwgdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbCwgITA7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy50ZXh0RWRpdGluZ01hbmFnZXIuY2xlYXIoKSwgc3VwZXIuY2xlYXIoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCksIHRoaXMudGV4dEVkaXRpbmdNYW5hZ2VyLmRpc3Bvc2UoKSwgc3VwZXIuZGVzdHJveSgpO1xuICB9XG59XG5jb25zdCBVYyA9IHsgeDE6IDAsIHkxOiAwLCB4MjogMCwgeTI6IDAgfSwgYWQgPSB2KHYoe30sIFVjKSwge30sIHsgcjE6IDAsIHIyOiAwIH0pLCBRZSA9IChpLCB0KSA9PiBpc05hTihpKSAmJiB0eXBlb2YgdCA9PSBcIm51bWJlclwiID8gdCA6IGksIGNkID0gL14oXFxkK1xcLlxcZCspJXwoXFxkKyklJC87XG5mdW5jdGlvbiAkYyhpKSB7XG4gIHJldHVybiBpICYmIGNkLnRlc3QoaSk7XG59XG5mdW5jdGlvbiBxYyhpLCB0KSB7XG4gIGNvbnN0IGUgPSB0eXBlb2YgaSA9PSBcIm51bWJlclwiID8gaSA6IHR5cGVvZiBpID09IFwic3RyaW5nXCIgPyBwYXJzZUZsb2F0KGkpIC8gKCRjKGkpID8gMTAwIDogMSkgOiBOYU47XG4gIHJldHVybiB6ZSgwLCBRZShlLCB0KSwgMSk7XG59XG5jb25zdCBsZCA9IC9cXHMqO1xccyovLCBoZCA9IC9cXHMqOlxccyovO1xuZnVuY3Rpb24gdWQoaSwgdCkge1xuICBsZXQgZSwgcztcbiAgY29uc3QgciA9IGkuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIGlmIChyKSB7XG4gICAgY29uc3QgbyA9IHIuc3BsaXQobGQpO1xuICAgIG9bby5sZW5ndGggLSAxXSA9PT0gXCJcIiAmJiBvLnBvcCgpO1xuICAgIGZvciAobGV0IGEgPSBvLmxlbmd0aDsgYS0tOyApIHtcbiAgICAgIGNvbnN0IFtjLCBsXSA9IG9bYV0uc3BsaXQoaGQpLm1hcCgoaCkgPT4gaC50cmltKCkpO1xuICAgICAgYyA9PT0gXCJzdG9wLWNvbG9yXCIgPyBlID0gbCA6IGMgPT09IFwic3RvcC1vcGFjaXR5XCIgJiYgKHMgPSBsKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbiA9IG5ldyBXKGUgfHwgaS5nZXRBdHRyaWJ1dGUoXCJzdG9wLWNvbG9yXCIpIHx8IFwicmdiKDAsMCwwKVwiKTtcbiAgcmV0dXJuIHsgb2Zmc2V0OiBxYyhpLmdldEF0dHJpYnV0ZShcIm9mZnNldFwiKSwgMCksIGNvbG9yOiBuLnRvUmdiKCksIG9wYWNpdHk6IFFlKHBhcnNlRmxvYXQocyB8fCBpLmdldEF0dHJpYnV0ZShcInN0b3Atb3BhY2l0eVwiKSB8fCBcIlwiKSwgMSkgKiBuLmdldEFscGhhKCkgKiB0IH07XG59XG5mdW5jdGlvbiBkZChpLCB0KSB7XG4gIGNvbnN0IGUgPSBbXSwgcyA9IGkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdG9wXCIpLCByID0gcWModCwgMSk7XG4gIGZvciAobGV0IG4gPSBzLmxlbmd0aDsgbi0tOyApIGUucHVzaCh1ZChzW25dLCByKSk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gS2MoaSkge1xuICByZXR1cm4gaS5ub2RlTmFtZSA9PT0gXCJsaW5lYXJHcmFkaWVudFwiIHx8IGkubm9kZU5hbWUgPT09IFwiTElORUFSR1JBRElFTlRcIiA/IFwibGluZWFyXCIgOiBcInJhZGlhbFwiO1xufVxuZnVuY3Rpb24gSmMoaSkge1xuICByZXR1cm4gaS5nZXRBdHRyaWJ1dGUoXCJncmFkaWVudFVuaXRzXCIpID09PSBcInVzZXJTcGFjZU9uVXNlXCIgPyBcInBpeGVsc1wiIDogXCJwZXJjZW50YWdlXCI7XG59XG5mdW5jdGlvbiBqdChpLCB0KSB7XG4gIHJldHVybiBpLmdldEF0dHJpYnV0ZSh0KTtcbn1cbmZ1bmN0aW9uIGZkKGksIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIHMpIHtcbiAgICBsZXQgciwgeyB3aWR0aDogbiwgaGVpZ2h0OiBvLCBncmFkaWVudFVuaXRzOiBhIH0gPSBzO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5yZWR1Y2UoKGMsIGwpID0+IHtcbiAgICAgIGNvbnN0IGggPSBlW2xdO1xuICAgICAgcmV0dXJuIGggPT09IFwiSW5maW5pdHlcIiA/IHIgPSAxIDogaCA9PT0gXCItSW5maW5pdHlcIiA/IHIgPSAwIDogKHIgPSB0eXBlb2YgaCA9PSBcInN0cmluZ1wiID8gcGFyc2VGbG9hdChoKSA6IGgsIHR5cGVvZiBoID09IFwic3RyaW5nXCIgJiYgJGMoaCkgJiYgKHIgKj0gMC4wMSwgYSA9PT0gXCJwaXhlbHNcIiAmJiAobCAhPT0gXCJ4MVwiICYmIGwgIT09IFwieDJcIiAmJiBsICE9PSBcInIyXCIgfHwgKHIgKj0gbiksIGwgIT09IFwieTFcIiAmJiBsICE9PSBcInkyXCIgfHwgKHIgKj0gbykpKSksIGNbbF0gPSByLCBjO1xuICAgIH0sIHt9KTtcbiAgfShLYyhpKSA9PT0gXCJsaW5lYXJcIiA/IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4geyB4MToganQoZSwgXCJ4MVwiKSB8fCAwLCB5MToganQoZSwgXCJ5MVwiKSB8fCAwLCB4MjoganQoZSwgXCJ4MlwiKSB8fCBcIjEwMCVcIiwgeTI6IGp0KGUsIFwieTJcIikgfHwgMCB9O1xuICB9KGkpIDogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB7IHgxOiBqdChlLCBcImZ4XCIpIHx8IGp0KGUsIFwiY3hcIikgfHwgXCI1MCVcIiwgeTE6IGp0KGUsIFwiZnlcIikgfHwganQoZSwgXCJjeVwiKSB8fCBcIjUwJVwiLCByMTogMCwgeDI6IGp0KGUsIFwiY3hcIikgfHwgXCI1MCVcIiwgeTI6IGp0KGUsIFwiY3lcIikgfHwgXCI1MCVcIiwgcjI6IGp0KGUsIFwiclwiKSB8fCBcIjUwJVwiIH07XG4gIH0oaSksIHYodih7fSwgdCksIHt9LCB7IGdyYWRpZW50VW5pdHM6IEpjKGkpIH0pKTtcbn1cbmNsYXNzIHlyIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIGNvbnN0IHsgdHlwZTogZSA9IFwibGluZWFyXCIsIGdyYWRpZW50VW5pdHM6IHMgPSBcInBpeGVsc1wiLCBjb29yZHM6IHIgPSB7fSwgY29sb3JTdG9wczogbiA9IFtdLCBvZmZzZXRYOiBvID0gMCwgb2Zmc2V0WTogYSA9IDAsIGdyYWRpZW50VHJhbnNmb3JtOiBjLCBpZDogbCB9ID0gdCB8fCB7fTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgdHlwZTogZSwgZ3JhZGllbnRVbml0czogcywgY29vcmRzOiB2KHYoe30sIGUgPT09IFwicmFkaWFsXCIgPyBhZCA6IFVjKSwgciksIGNvbG9yU3RvcHM6IG4sIG9mZnNldFg6IG8sIG9mZnNldFk6IGEsIGdyYWRpZW50VHJhbnNmb3JtOiBjLCBpZDogbCA/IFwiXCIuY29uY2F0KGwsIFwiX1wiKS5jb25jYXQod2UoKSkgOiB3ZSgpIH0pO1xuICB9XG4gIGFkZENvbG9yU3RvcCh0KSB7XG4gICAgZm9yIChjb25zdCBlIGluIHQpIHtcbiAgICAgIGNvbnN0IHMgPSBuZXcgVyh0W2VdKTtcbiAgICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHsgb2Zmc2V0OiBwYXJzZUZsb2F0KGUpLCBjb2xvcjogcy50b1JnYigpLCBvcGFjaXR5OiBzLmdldEFscGhhKCkgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvT2JqZWN0KHQpIHtcbiAgICByZXR1cm4gdih2KHt9LCBWZSh0aGlzLCB0KSksIHt9LCB7IHR5cGU6IHRoaXMudHlwZSwgY29vcmRzOiB2KHt9LCB0aGlzLmNvb3JkcyksIGNvbG9yU3RvcHM6IHRoaXMuY29sb3JTdG9wcy5tYXAoKGUpID0+IHYoe30sIGUpKSwgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLCBvZmZzZXRZOiB0aGlzLm9mZnNldFksIGdyYWRpZW50VW5pdHM6IHRoaXMuZ3JhZGllbnRVbml0cywgZ3JhZGllbnRUcmFuc2Zvcm06IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyBbLi4udGhpcy5ncmFkaWVudFRyYW5zZm9ybV0gOiB2b2lkIDAgfSk7XG4gIH1cbiAgdG9TVkcodCkge1xuICAgIGxldCB7IGFkZGl0aW9uYWxUcmFuc2Zvcm06IGUgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgcyA9IFtdLCByID0gdGhpcy5ncmFkaWVudFRyYW5zZm9ybSA/IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0uY29uY2F0KCkgOiBodC5jb25jYXQoKSwgbiA9IHRoaXMuZ3JhZGllbnRVbml0cyA9PT0gXCJwaXhlbHNcIiA/IFwidXNlclNwYWNlT25Vc2VcIiA6IFwib2JqZWN0Qm91bmRpbmdCb3hcIiwgbyA9IHRoaXMuY29sb3JTdG9wcy5tYXAoKHUpID0+IHYoe30sIHUpKS5zb3J0KCh1LCBkKSA9PiB1Lm9mZnNldCAtIGQub2Zmc2V0KTtcbiAgICBsZXQgYSA9IC10aGlzLm9mZnNldFgsIGMgPSAtdGhpcy5vZmZzZXRZO1xuICAgIHZhciBsO1xuICAgIG4gPT09IFwib2JqZWN0Qm91bmRpbmdCb3hcIiA/IChhIC89IHQud2lkdGgsIGMgLz0gdC5oZWlnaHQpIDogKGEgKz0gdC53aWR0aCAvIDIsIGMgKz0gdC5oZWlnaHQgLyAyKSwgKGwgPSB0KSAmJiB0eXBlb2YgbC5fcmVuZGVyUGF0aENvbW1hbmRzID09IFwiZnVuY3Rpb25cIiAmJiB0aGlzLmdyYWRpZW50VW5pdHMgIT09IFwicGVyY2VudGFnZVwiICYmIChhIC09IHQucGF0aE9mZnNldC54LCBjIC09IHQucGF0aE9mZnNldC55KSwgcls0XSAtPSBhLCByWzVdIC09IGM7XG4gICAgY29uc3QgaCA9IFsnaWQ9XCJTVkdJRF8nLmNvbmNhdCh0aGlzLmlkLCAnXCInKSwgJ2dyYWRpZW50VW5pdHM9XCInLmNvbmNhdChuLCAnXCInKSwgJ2dyYWRpZW50VHJhbnNmb3JtPVwiJy5jb25jYXQoZSA/IGUgKyBcIiBcIiA6IFwiXCIpLmNvbmNhdChxcyhyKSwgJ1wiJyksIFwiXCJdLmpvaW4oXCIgXCIpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IFwibGluZWFyXCIpIHtcbiAgICAgIGNvbnN0IHsgeDE6IHUsIHkxOiBkLCB4MjogZiwgeTI6IGcgfSA9IHRoaXMuY29vcmRzO1xuICAgICAgcy5wdXNoKFwiPGxpbmVhckdyYWRpZW50IFwiLCBoLCAnIHgxPVwiJywgdSwgJ1wiIHkxPVwiJywgZCwgJ1wiIHgyPVwiJywgZiwgJ1wiIHkyPVwiJywgZywgYFwiPlxuYCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwicmFkaWFsXCIpIHtcbiAgICAgIGNvbnN0IHsgeDE6IHUsIHkxOiBkLCB4MjogZiwgeTI6IGcsIHIxOiBwLCByMjogbSB9ID0gdGhpcy5jb29yZHMsIGIgPSBwID4gbTtcbiAgICAgIHMucHVzaChcIjxyYWRpYWxHcmFkaWVudCBcIiwgaCwgJyBjeD1cIicsIGIgPyB1IDogZiwgJ1wiIGN5PVwiJywgYiA/IGQgOiBnLCAnXCIgcj1cIicsIGIgPyBwIDogbSwgJ1wiIGZ4PVwiJywgYiA/IGYgOiB1LCAnXCIgZnk9XCInLCBiID8gZyA6IGQsIGBcIj5cbmApLCBiICYmIChvLnJldmVyc2UoKSwgby5mb3JFYWNoKCh3KSA9PiB7XG4gICAgICAgIHcub2Zmc2V0ID0gMSAtIHcub2Zmc2V0O1xuICAgICAgfSkpO1xuICAgICAgY29uc3QgUyA9IE1hdGgubWluKHAsIG0pO1xuICAgICAgaWYgKFMgPiAwKSB7XG4gICAgICAgIGNvbnN0IHcgPSBTIC8gTWF0aC5tYXgocCwgbSk7XG4gICAgICAgIG8uZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgIGsub2Zmc2V0ICs9IHcgKiAoMSAtIGsub2Zmc2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvLmZvckVhY2goKHUpID0+IHtcbiAgICAgIGxldCB7IGNvbG9yOiBkLCBvZmZzZXQ6IGYsIG9wYWNpdHk6IGcgfSA9IHU7XG4gICAgICBzLnB1c2goXCI8c3RvcCBcIiwgJ29mZnNldD1cIicsIDEwMCAqIGYgKyBcIiVcIiwgJ1wiIHN0eWxlPVwic3RvcC1jb2xvcjonLCBkLCBnICE9PSB2b2lkIDAgPyBcIjtzdG9wLW9wYWNpdHk6IFwiICsgZyA6IFwiO1wiLCBgXCIvPlxuYCk7XG4gICAgfSksIHMucHVzaCh0aGlzLnR5cGUgPT09IFwibGluZWFyXCIgPyBcIjwvbGluZWFyR3JhZGllbnQ+XCIgOiBcIjwvcmFkaWFsR3JhZGllbnQ+XCIsIGBcbmApLCBzLmpvaW4oXCJcIik7XG4gIH1cbiAgdG9MaXZlKHQpIHtcbiAgICBjb25zdCB7IHgxOiBlLCB5MTogcywgeDI6IHIsIHkyOiBuLCByMTogbywgcjI6IGEgfSA9IHRoaXMuY29vcmRzLCBjID0gdGhpcy50eXBlID09PSBcImxpbmVhclwiID8gdC5jcmVhdGVMaW5lYXJHcmFkaWVudChlLCBzLCByLCBuKSA6IHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoZSwgcywgbywgciwgbiwgYSk7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JTdG9wcy5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBsZXQgeyBjb2xvcjogaCwgb3BhY2l0eTogdSwgb2Zmc2V0OiBkIH0gPSBsO1xuICAgICAgYy5hZGRDb2xvclN0b3AoZCwgdSAhPT0gdm9pZCAwID8gbmV3IFcoaCkuc2V0QWxwaGEodSkudG9SZ2JhKCkgOiBoKTtcbiAgICB9KSwgYztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbU9iamVjdCh0KSB7XG4gICAgY29uc3QgeyBjb2xvclN0b3BzOiBlLCBncmFkaWVudFRyYW5zZm9ybTogcyB9ID0gdDtcbiAgICByZXR1cm4gbmV3IHRoaXModih2KHt9LCB0KSwge30sIHsgY29sb3JTdG9wczogZSA/IGUubWFwKChyKSA9PiB2KHt9LCByKSkgOiB2b2lkIDAsIGdyYWRpZW50VHJhbnNmb3JtOiBzID8gWy4uLnNdIDogdm9pZCAwIH0pKTtcbiAgfVxuICBzdGF0aWMgZnJvbUVsZW1lbnQodCwgZSwgcykge1xuICAgIGNvbnN0IHIgPSBKYyh0KSwgbiA9IGUuX2ZpbmRDZW50ZXJGcm9tRWxlbWVudCgpO1xuICAgIHJldHVybiBuZXcgdGhpcyh2KHsgaWQ6IHQuZ2V0QXR0cmlidXRlKFwiaWRcIikgfHwgdm9pZCAwLCB0eXBlOiBLYyh0KSwgY29vcmRzOiBmZCh0LCB7IHdpZHRoOiBzLnZpZXdCb3hXaWR0aCB8fCBzLndpZHRoLCBoZWlnaHQ6IHMudmlld0JveEhlaWdodCB8fCBzLmhlaWdodCB9KSwgY29sb3JTdG9wczogZGQodCwgcy5vcGFjaXR5KSwgZ3JhZGllbnRVbml0czogciwgZ3JhZGllbnRUcmFuc2Zvcm06IGZuKHQuZ2V0QXR0cmlidXRlKFwiZ3JhZGllbnRUcmFuc2Zvcm1cIikgfHwgXCJcIikgfSwgciA9PT0gXCJwaXhlbHNcIiA/IHsgb2Zmc2V0WDogZS53aWR0aCAvIDIgLSBuLngsIG9mZnNldFk6IGUuaGVpZ2h0IC8gMiAtIG4ueSB9IDogeyBvZmZzZXRYOiAwLCBvZmZzZXRZOiAwIH0pKTtcbiAgfVxufVxueSh5ciwgXCJ0eXBlXCIsIFwiR3JhZGllbnRcIiksIEMuc2V0Q2xhc3MoeXIsIFwiZ3JhZGllbnRcIiksIEMuc2V0Q2xhc3MoeXIsIFwibGluZWFyXCIpLCBDLnNldENsYXNzKHlyLCBcInJhZGlhbFwiKTtcbmNvbnN0IGdkID0gW1widHlwZVwiLCBcInNvdXJjZVwiLCBcInBhdHRlcm5UcmFuc2Zvcm1cIl07XG5jbGFzcyBZaSB7XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcInBhdHRlcm5cIjtcbiAgfVxuICBzZXQgdHlwZSh0KSB7XG4gICAgVGUoXCJ3YXJuXCIsIFwiU2V0dGluZyB0eXBlIGhhcyBubyBlZmZlY3RcIiwgdCk7XG4gIH1cbiAgY29uc3RydWN0b3IodCkge1xuICAgIHkodGhpcywgXCJyZXBlYXRcIiwgXCJyZXBlYXRcIiksIHkodGhpcywgXCJvZmZzZXRYXCIsIDApLCB5KHRoaXMsIFwib2Zmc2V0WVwiLCAwKSwgeSh0aGlzLCBcImNyb3NzT3JpZ2luXCIsIFwiXCIpLCB0aGlzLmlkID0gd2UoKSwgT2JqZWN0LmFzc2lnbih0aGlzLCB0KTtcbiAgfVxuICBpc0ltYWdlU291cmNlKCkge1xuICAgIHJldHVybiAhIXRoaXMuc291cmNlICYmIHR5cGVvZiB0aGlzLnNvdXJjZS5zcmMgPT0gXCJzdHJpbmdcIjtcbiAgfVxuICBpc0NhbnZhc1NvdXJjZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnNvdXJjZSAmJiAhIXRoaXMuc291cmNlLnRvRGF0YVVSTDtcbiAgfVxuICBzb3VyY2VUb1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0ltYWdlU291cmNlKCkgPyB0aGlzLnNvdXJjZS5zcmMgOiB0aGlzLmlzQ2FudmFzU291cmNlKCkgPyB0aGlzLnNvdXJjZS50b0RhdGFVUkwoKSA6IFwiXCI7XG4gIH1cbiAgdG9MaXZlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UgJiYgKCF0aGlzLmlzSW1hZ2VTb3VyY2UoKSB8fCB0aGlzLnNvdXJjZS5jb21wbGV0ZSAmJiB0aGlzLnNvdXJjZS5uYXR1cmFsV2lkdGggIT09IDAgJiYgdGhpcy5zb3VyY2UubmF0dXJhbEhlaWdodCAhPT0gMCkgPyB0LmNyZWF0ZVBhdHRlcm4odGhpcy5zb3VyY2UsIHRoaXMucmVwZWF0KSA6IG51bGw7XG4gIH1cbiAgdG9PYmplY3QoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNvbnN0IHsgcmVwZWF0OiBlLCBjcm9zc09yaWdpbjogcyB9ID0gdGhpcztcbiAgICByZXR1cm4gdih2KHt9LCBWZSh0aGlzLCB0KSksIHt9LCB7IHR5cGU6IFwicGF0dGVyblwiLCBzb3VyY2U6IHRoaXMuc291cmNlVG9TdHJpbmcoKSwgcmVwZWF0OiBlLCBjcm9zc09yaWdpbjogcywgb2Zmc2V0WDogVih0aGlzLm9mZnNldFgsIEEuTlVNX0ZSQUNUSU9OX0RJR0lUUyksIG9mZnNldFk6IFYodGhpcy5vZmZzZXRZLCBBLk5VTV9GUkFDVElPTl9ESUdJVFMpLCBwYXR0ZXJuVHJhbnNmb3JtOiB0aGlzLnBhdHRlcm5UcmFuc2Zvcm0gPyBbLi4udGhpcy5wYXR0ZXJuVHJhbnNmb3JtXSA6IG51bGwgfSk7XG4gIH1cbiAgdG9TVkcodCkge1xuICAgIGxldCB7IHdpZHRoOiBlLCBoZWlnaHQ6IHMgfSA9IHQ7XG4gICAgY29uc3QgeyBzb3VyY2U6IHIsIHJlcGVhdDogbiwgaWQ6IG8gfSA9IHRoaXMsIGEgPSBRZSh0aGlzLm9mZnNldFggLyBlLCAwKSwgYyA9IFFlKHRoaXMub2Zmc2V0WSAvIHMsIDApLCBsID0gbiA9PT0gXCJyZXBlYXQteVwiIHx8IG4gPT09IFwibm8tcmVwZWF0XCIgPyAxICsgTWF0aC5hYnMoYSB8fCAwKSA6IFFlKHIud2lkdGggLyBlLCAwKSwgaCA9IG4gPT09IFwicmVwZWF0LXhcIiB8fCBuID09PSBcIm5vLXJlcGVhdFwiID8gMSArIE1hdGguYWJzKGMgfHwgMCkgOiBRZShyLmhlaWdodCAvIHMsIDApO1xuICAgIHJldHVybiBbJzxwYXR0ZXJuIGlkPVwiU1ZHSURfJy5jb25jYXQobywgJ1wiIHg9XCInKS5jb25jYXQoYSwgJ1wiIHk9XCInKS5jb25jYXQoYywgJ1wiIHdpZHRoPVwiJykuY29uY2F0KGwsICdcIiBoZWlnaHQ9XCInKS5jb25jYXQoaCwgJ1wiPicpLCAnPGltYWdlIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIicuY29uY2F0KHIud2lkdGgsICdcIiBoZWlnaHQ9XCInKS5jb25jYXQoci5oZWlnaHQsICdcIiB4bGluazpocmVmPVwiJykuY29uY2F0KHRoaXMuc291cmNlVG9TdHJpbmcoKSwgJ1wiPjwvaW1hZ2U+JyksIFwiPC9wYXR0ZXJuPlwiLCBcIlwiXS5qb2luKGBcbmApO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tT2JqZWN0KHQsIGUpIHtcbiAgICBsZXQgeyB0eXBlOiBzLCBzb3VyY2U6IHIsIHBhdHRlcm5UcmFuc2Zvcm06IG4gfSA9IHQsIG8gPSBHKHQsIGdkKTtcbiAgICBjb25zdCBhID0gYXdhaXQgWXMociwgdih2KHt9LCBlKSwge30sIHsgY3Jvc3NPcmlnaW46IG8uY3Jvc3NPcmlnaW4gfSkpO1xuICAgIHJldHVybiBuZXcgdGhpcyh2KHYoe30sIG8pLCB7fSwgeyBwYXR0ZXJuVHJhbnNmb3JtOiBuICYmIG4uc2xpY2UoMCksIHNvdXJjZTogYSB9KSk7XG4gIH1cbn1cbnkoWWksIFwidHlwZVwiLCBcIlBhdHRlcm5cIiksIEMuc2V0Q2xhc3MoWWkpLCBDLnNldENsYXNzKFlpLCBcInBhdHRlcm5cIik7XG5jb25zdCBwZCA9IFtcInBhdGhcIiwgXCJsZWZ0XCIsIFwidG9wXCJdLCBtZCA9IFtcImRcIl07XG5jbGFzcyBBZSBleHRlbmRzIG50IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIGxldCBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fSwgeyBwYXRoOiBzLCBsZWZ0OiByLCB0b3A6IG4gfSA9IGUsIG8gPSBHKGUsIHBkKTtcbiAgICBzdXBlcigpLCBPYmplY3QuYXNzaWduKHRoaXMsIEFlLm93bkRlZmF1bHRzKSwgdGhpcy5zZXRPcHRpb25zKG8pLCB0aGlzLl9zZXRQYXRoKHQgfHwgW10sICEwKSwgdHlwZW9mIHIgPT0gXCJudW1iZXJcIiAmJiB0aGlzLnNldChMLCByKSwgdHlwZW9mIG4gPT0gXCJudW1iZXJcIiAmJiB0aGlzLnNldChndCwgbik7XG4gIH1cbiAgX3NldFBhdGgodCwgZSkge1xuICAgIHRoaXMucGF0aCA9IFdjKEFycmF5LmlzQXJyYXkodCkgPyB0IDogR2ModCkpLCB0aGlzLnNldEJvdW5kaW5nQm94KGUpO1xuICB9XG4gIF9maW5kQ2VudGVyRnJvbUVsZW1lbnQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NhbGNCb3VuZHNGcm9tUGF0aCgpO1xuICAgIHJldHVybiBuZXcgXyh0LmxlZnQgKyB0LndpZHRoIC8gMiwgdC50b3AgKyB0LmhlaWdodCAvIDIpO1xuICB9XG4gIF9yZW5kZXJQYXRoQ29tbWFuZHModCkge1xuICAgIGNvbnN0IGUgPSAtdGhpcy5wYXRoT2Zmc2V0LngsIHMgPSAtdGhpcy5wYXRoT2Zmc2V0Lnk7XG4gICAgdC5iZWdpblBhdGgoKTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5wYXRoKSBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgIHQubGluZVRvKHJbMV0gKyBlLCByWzJdICsgcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgdC5tb3ZlVG8oclsxXSArIGUsIHJbMl0gKyBzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQ1wiOlxuICAgICAgICB0LmJlemllckN1cnZlVG8oclsxXSArIGUsIHJbMl0gKyBzLCByWzNdICsgZSwgcls0XSArIHMsIHJbNV0gKyBlLCByWzZdICsgcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgdC5xdWFkcmF0aWNDdXJ2ZVRvKHJbMV0gKyBlLCByWzJdICsgcywgclszXSArIGUsIHJbNF0gKyBzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiWlwiOlxuICAgICAgICB0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBfcmVuZGVyKHQpIHtcbiAgICB0aGlzLl9yZW5kZXJQYXRoQ29tbWFuZHModCksIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcih0KTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCIjPFBhdGggKFwiLmNvbmNhdCh0aGlzLmNvbXBsZXhpdHkoKSwgJyk6IHsgXCJ0b3BcIjogJykuY29uY2F0KHRoaXMudG9wLCAnLCBcImxlZnRcIjogJykuY29uY2F0KHRoaXMubGVmdCwgXCIgfT5cIik7XG4gIH1cbiAgdG9PYmplY3QoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIHJldHVybiB2KHYoe30sIHN1cGVyLnRvT2JqZWN0KHQpKSwge30sIHsgcGF0aDogdGhpcy5wYXRoLm1hcCgoZSkgPT4gZS5zbGljZSgpKSB9KTtcbiAgfVxuICB0b0RhdGFsZXNzT2JqZWN0KCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICBjb25zdCBlID0gdGhpcy50b09iamVjdCh0KTtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VQYXRoICYmIChkZWxldGUgZS5wYXRoLCBlLnNvdXJjZVBhdGggPSB0aGlzLnNvdXJjZVBhdGgpLCBlO1xuICB9XG4gIF90b1NWRygpIHtcbiAgICBjb25zdCB0ID0gTmModGhpcy5wYXRoLCBBLk5VTV9GUkFDVElPTl9ESUdJVFMpO1xuICAgIHJldHVybiBbXCI8cGF0aCBcIiwgXCJDT01NT05fUEFSVFNcIiwgJ2Q9XCInLmNvbmNhdCh0LCBgXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIC8+XG5gKV07XG4gIH1cbiAgX2dldE9mZnNldFRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCB0ID0gQS5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgIHJldHVybiBcIiB0cmFuc2xhdGUoXCIuY29uY2F0KFYoLXRoaXMucGF0aE9mZnNldC54LCB0KSwgXCIsIFwiKS5jb25jYXQoVigtdGhpcy5wYXRoT2Zmc2V0LnksIHQpLCBcIilcIik7XG4gIH1cbiAgdG9DbGlwUGF0aFNWRyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldE9mZnNldFRyYW5zZm9ybSgpO1xuICAgIHJldHVybiBcIlx0XCIgKyB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAodGhpcy5fdG9TVkcoKSwgeyByZXZpdmVyOiB0LCBhZGRpdGlvbmFsVHJhbnNmb3JtOiBlIH0pO1xuICB9XG4gIHRvU1ZHKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0T2Zmc2V0VHJhbnNmb3JtKCk7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAodGhpcy5fdG9TVkcoKSwgeyByZXZpdmVyOiB0LCBhZGRpdGlvbmFsVHJhbnNmb3JtOiBlIH0pO1xuICB9XG4gIGNvbXBsZXhpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aC5sZW5ndGg7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICB0aGlzLnNldEJvdW5kaW5nQm94KCk7XG4gIH1cbiAgc2V0Qm91bmRpbmdCb3godCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IGUsIGhlaWdodDogcywgcGF0aE9mZnNldDogciB9ID0gdGhpcy5fY2FsY0RpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNldCh7IHdpZHRoOiBlLCBoZWlnaHQ6IHMsIHBhdGhPZmZzZXQ6IHIgfSksIHQgJiYgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKHIsIGosIGopO1xuICB9XG4gIF9jYWxjQm91bmRzRnJvbVBhdGgoKSB7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIGxldCBlID0gMCwgcyA9IDAsIHIgPSAwLCBuID0gMDtcbiAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5wYXRoKSBzd2l0Y2ggKG9bMF0pIHtcbiAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgIHIgPSBvWzFdLCBuID0gb1syXSwgdC5wdXNoKHsgeDogZSwgeTogcyB9LCB7IHg6IHIsIHk6IG4gfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgciA9IG9bMV0sIG4gPSBvWzJdLCBlID0gciwgcyA9IG47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkNcIjpcbiAgICAgICAgdC5wdXNoKC4uLm1uKHIsIG4sIG9bMV0sIG9bMl0sIG9bM10sIG9bNF0sIG9bNV0sIG9bNl0pKSwgciA9IG9bNV0sIG4gPSBvWzZdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgIHQucHVzaCguLi5tbihyLCBuLCBvWzFdLCBvWzJdLCBvWzFdLCBvWzJdLCBvWzNdLCBvWzRdKSksIHIgPSBvWzNdLCBuID0gb1s0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiWlwiOlxuICAgICAgICByID0gZSwgbiA9IHM7XG4gICAgfVxuICAgIHJldHVybiBHdCh0KTtcbiAgfVxuICBfY2FsY0RpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NhbGNCb3VuZHNGcm9tUGF0aCgpO1xuICAgIHJldHVybiB2KHYoe30sIHQpLCB7fSwgeyBwYXRoT2Zmc2V0OiBuZXcgXyh0LmxlZnQgKyB0LndpZHRoIC8gMiwgdC50b3AgKyB0LmhlaWdodCAvIDIpIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tT2JqZWN0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZnJvbU9iamVjdCh0LCB7IGV4dHJhUGFyYW06IFwicGF0aFwiIH0pO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tRWxlbWVudCh0LCBlLCBzKSB7XG4gICAgY29uc3QgciA9IGZlKHQsIHRoaXMuQVRUUklCVVRFX05BTUVTLCBzKSwgeyBkOiBuIH0gPSByO1xuICAgIHJldHVybiBuZXcgdGhpcyhuLCB2KHYodih7fSwgRyhyLCBtZCkpLCBlKSwge30sIHsgbGVmdDogdm9pZCAwLCB0b3A6IHZvaWQgMCB9KSk7XG4gIH1cbn1cbnkoQWUsIFwidHlwZVwiLCBcIlBhdGhcIiksIHkoQWUsIFwiY2FjaGVQcm9wZXJ0aWVzXCIsIFsuLi5kZSwgXCJwYXRoXCIsIFwiZmlsbFJ1bGVcIl0pLCB5KEFlLCBcIkFUVFJJQlVURV9OQU1FU1wiLCBbLi4uRGUsIFwiZFwiXSksIEMuc2V0Q2xhc3MoQWUpLCBDLnNldFNWR0NsYXNzKEFlKTtcbmNvbnN0IHZkID0gW1wibGVmdFwiLCBcInRvcFwiLCBcInJhZGl1c1wiXSwgWmMgPSBbXCJyYWRpdXNcIiwgXCJzdGFydEFuZ2xlXCIsIFwiZW5kQW5nbGVcIiwgXCJjb3VudGVyQ2xvY2t3aXNlXCJdO1xuY2xhc3Mgc2UgZXh0ZW5kcyBudCB7XG4gIHN0YXRpYyBnZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4gdih2KHt9LCBzdXBlci5nZXREZWZhdWx0cygpKSwgc2Uub3duRGVmYXVsdHMpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpLCBPYmplY3QuYXNzaWduKHRoaXMsIHNlLm93bkRlZmF1bHRzKSwgdGhpcy5zZXRPcHRpb25zKHQpO1xuICB9XG4gIF9zZXQodCwgZSkge1xuICAgIHJldHVybiBzdXBlci5fc2V0KHQsIGUpLCB0ID09PSBcInJhZGl1c1wiICYmIHRoaXMuc2V0UmFkaXVzKGUpLCB0aGlzO1xuICB9XG4gIF9yZW5kZXIodCkge1xuICAgIHQuYmVnaW5QYXRoKCksIHQuYXJjKDAsIDAsIHRoaXMucmFkaXVzLCBLKHRoaXMuc3RhcnRBbmdsZSksIEsodGhpcy5lbmRBbmdsZSksIHRoaXMuY291bnRlckNsb2Nrd2lzZSksIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcih0KTtcbiAgfVxuICBnZXRSYWRpdXNYKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInJhZGl1c1wiKSAqIHRoaXMuZ2V0KHV0KTtcbiAgfVxuICBnZXRSYWRpdXNZKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInJhZGl1c1wiKSAqIHRoaXMuZ2V0KFR0KTtcbiAgfVxuICBzZXRSYWRpdXModCkge1xuICAgIHRoaXMucmFkaXVzID0gdCwgdGhpcy5zZXQoeyB3aWR0aDogMiAqIHQsIGhlaWdodDogMiAqIHQgfSk7XG4gIH1cbiAgdG9PYmplY3QoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIHJldHVybiBzdXBlci50b09iamVjdChbLi4uWmMsIC4uLnRdKTtcbiAgfVxuICBfdG9TVkcoKSB7XG4gICAgY29uc3QgdCA9ICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSAlIDM2MDtcbiAgICBpZiAodCA9PT0gMCkgcmV0dXJuIFtcIjxjaXJjbGUgXCIsIFwiQ09NTU9OX1BBUlRTXCIsICdjeD1cIjBcIiBjeT1cIjBcIiAnLCAncj1cIicsIFwiXCIuY29uY2F0KHRoaXMucmFkaXVzKSwgYFwiIC8+XG5gXTtcbiAgICB7XG4gICAgICBjb25zdCB7IHJhZGl1czogZSB9ID0gdGhpcywgcyA9IEsodGhpcy5zdGFydEFuZ2xlKSwgciA9IEsodGhpcy5lbmRBbmdsZSksIG4gPSBMdChzKSAqIGUsIG8gPSBCdChzKSAqIGUsIGEgPSBMdChyKSAqIGUsIGMgPSBCdChyKSAqIGUsIGwgPSB0ID4gMTgwID8gMSA6IDAsIGggPSB0aGlzLmNvdW50ZXJDbG9ja3dpc2UgPyAwIDogMTtcbiAgICAgIHJldHVybiBbJzxwYXRoIGQ9XCJNICcuY29uY2F0KG4sIFwiIFwiKS5jb25jYXQobywgXCIgQSBcIikuY29uY2F0KGUsIFwiIFwiKS5jb25jYXQoZSwgXCIgMCBcIikuY29uY2F0KGwsIFwiIFwiKS5jb25jYXQoaCwgXCIgXCIpLmNvbmNhdChhLCBcIiBcIikuY29uY2F0KGMsICdcIiAnKSwgXCJDT01NT05fUEFSVFNcIiwgYCAvPlxuYF07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tRWxlbWVudCh0LCBlLCBzKSB7XG4gICAgY29uc3QgciA9IGZlKHQsIHRoaXMuQVRUUklCVVRFX05BTUVTLCBzKSwgeyBsZWZ0OiBuID0gMCwgdG9wOiBvID0gMCwgcmFkaXVzOiBhID0gMCB9ID0gcjtcbiAgICByZXR1cm4gbmV3IHRoaXModih2KHt9LCBHKHIsIHZkKSksIHt9LCB7IHJhZGl1czogYSwgbGVmdDogbiAtIGEsIHRvcDogbyAtIGEgfSkpO1xuICB9XG4gIHN0YXRpYyBmcm9tT2JqZWN0KHQpIHtcbiAgICByZXR1cm4gc3VwZXIuX2Zyb21PYmplY3QodCk7XG4gIH1cbn1cbnkoc2UsIFwidHlwZVwiLCBcIkNpcmNsZVwiKSwgeShzZSwgXCJjYWNoZVByb3BlcnRpZXNcIiwgWy4uLmRlLCAuLi5aY10pLCB5KHNlLCBcIm93bkRlZmF1bHRzXCIsIHsgcmFkaXVzOiAwLCBzdGFydEFuZ2xlOiAwLCBlbmRBbmdsZTogMzYwLCBjb3VudGVyQ2xvY2t3aXNlOiAhMSB9KSwgeShzZSwgXCJBVFRSSUJVVEVfTkFNRVNcIiwgW1wiY3hcIiwgXCJjeVwiLCBcInJcIiwgLi4uRGVdKSwgQy5zZXRDbGFzcyhzZSksIEMuc2V0U1ZHQ2xhc3Moc2UpO1xuY29uc3QgeWQgPSBbXCJ4MVwiLCBcInkxXCIsIFwieDJcIiwgXCJ5MlwiXSwgYmQgPSBbXCJ4MVwiLCBcInkxXCIsIFwieDJcIiwgXCJ5MlwiXSwgeW4gPSBbXCJ4MVwiLCBcIngyXCIsIFwieTFcIiwgXCJ5MlwiXTtcbmNsYXNzIFNlIGV4dGVuZHMgbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgW3QsIGUsIHMsIHJdID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBbMCwgMCwgMCwgMF0sIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHN1cGVyKCksIE9iamVjdC5hc3NpZ24odGhpcywgU2Uub3duRGVmYXVsdHMpLCB0aGlzLnNldE9wdGlvbnMobiksIHRoaXMueDEgPSB0LCB0aGlzLngyID0gcywgdGhpcy55MSA9IGUsIHRoaXMueTIgPSByLCB0aGlzLl9zZXRXaWR0aEhlaWdodCgpO1xuICAgIGNvbnN0IHsgbGVmdDogbywgdG9wOiBhIH0gPSBuO1xuICAgIHR5cGVvZiBvID09IFwibnVtYmVyXCIgJiYgdGhpcy5zZXQoTCwgbyksIHR5cGVvZiBhID09IFwibnVtYmVyXCIgJiYgdGhpcy5zZXQoZ3QsIGEpO1xuICB9XG4gIF9zZXRXaWR0aEhlaWdodCgpIHtcbiAgICBjb25zdCB7IHgxOiB0LCB5MTogZSwgeDI6IHMsIHkyOiByIH0gPSB0aGlzO1xuICAgIHRoaXMud2lkdGggPSBNYXRoLmFicyhzIC0gdCksIHRoaXMuaGVpZ2h0ID0gTWF0aC5hYnMociAtIGUpO1xuICAgIGNvbnN0IHsgbGVmdDogbiwgdG9wOiBvLCB3aWR0aDogYSwgaGVpZ2h0OiBjIH0gPSBHdChbeyB4OiB0LCB5OiBlIH0sIHsgeDogcywgeTogciB9XSksIGwgPSBuZXcgXyhuICsgYSAvIDIsIG8gKyBjIC8gMik7XG4gICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKGwsIGosIGopO1xuICB9XG4gIF9zZXQodCwgZSkge1xuICAgIHJldHVybiBzdXBlci5fc2V0KHQsIGUpLCB5bi5pbmNsdWRlcyh0KSAmJiB0aGlzLl9zZXRXaWR0aEhlaWdodCgpLCB0aGlzO1xuICB9XG4gIF9yZW5kZXIodCkge1xuICAgIHQuYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgZSA9IHRoaXMuY2FsY0xpbmVQb2ludHMoKTtcbiAgICB0Lm1vdmVUbyhlLngxLCBlLnkxKSwgdC5saW5lVG8oZS54MiwgZS55MiksIHQubGluZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICBjb25zdCBzID0gdC5zdHJva2VTdHlsZTtcbiAgICB2YXIgcjtcbiAgICBDdCh0aGlzLnN0cm9rZSkgPyB0LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2UudG9MaXZlKHQpIDogdC5zdHJva2VTdHlsZSA9IChyID0gdGhpcy5zdHJva2UpICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiB0LmZpbGxTdHlsZSwgdGhpcy5zdHJva2UgJiYgdGhpcy5fcmVuZGVyU3Ryb2tlKHQpLCB0LnN0cm9rZVN0eWxlID0gcztcbiAgfVxuICBfZmluZENlbnRlckZyb21FbGVtZW50KCkge1xuICAgIHJldHVybiBuZXcgXygodGhpcy54MSArIHRoaXMueDIpIC8gMiwgKHRoaXMueTEgKyB0aGlzLnkyKSAvIDIpO1xuICB9XG4gIHRvT2JqZWN0KCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICByZXR1cm4gdih2KHt9LCBzdXBlci50b09iamVjdCh0KSksIHRoaXMuY2FsY0xpbmVQb2ludHMoKSk7XG4gIH1cbiAgX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB0ID0gc3VwZXIuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgIHJldHVybiB0aGlzLnN0cm9rZUxpbmVDYXAgPT09IFwiYnV0dFwiICYmICh0aGlzLndpZHRoID09PSAwICYmICh0LnkgLT0gdGhpcy5zdHJva2VXaWR0aCksIHRoaXMuaGVpZ2h0ID09PSAwICYmICh0LnggLT0gdGhpcy5zdHJva2VXaWR0aCkpLCB0O1xuICB9XG4gIGNhbGNMaW5lUG9pbnRzKCkge1xuICAgIGNvbnN0IHsgeDE6IHQsIHgyOiBlLCB5MTogcywgeTI6IHIsIHdpZHRoOiBuLCBoZWlnaHQ6IG8gfSA9IHRoaXMsIGEgPSB0IDw9IGUgPyAtMSA6IDEsIGMgPSBzIDw9IHIgPyAtMSA6IDE7XG4gICAgcmV0dXJuIHsgeDE6IGEgKiBuIC8gMiwgeDI6IGEgKiAtbiAvIDIsIHkxOiBjICogbyAvIDIsIHkyOiBjICogLW8gLyAyIH07XG4gIH1cbiAgX3RvU1ZHKCkge1xuICAgIGNvbnN0IHsgeDE6IHQsIHgyOiBlLCB5MTogcywgeTI6IHIgfSA9IHRoaXMuY2FsY0xpbmVQb2ludHMoKTtcbiAgICByZXR1cm4gW1wiPGxpbmUgXCIsIFwiQ09NTU9OX1BBUlRTXCIsICd4MT1cIicuY29uY2F0KHQsICdcIiB5MT1cIicpLmNvbmNhdChzLCAnXCIgeDI9XCInKS5jb25jYXQoZSwgJ1wiIHkyPVwiJykuY29uY2F0KHIsIGBcIiAvPlxuYCldO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tRWxlbWVudCh0LCBlLCBzKSB7XG4gICAgY29uc3QgciA9IGZlKHQsIHRoaXMuQVRUUklCVVRFX05BTUVTLCBzKSwgeyB4MTogbiA9IDAsIHkxOiBvID0gMCwgeDI6IGEgPSAwLCB5MjogYyA9IDAgfSA9IHI7XG4gICAgcmV0dXJuIG5ldyB0aGlzKFtuLCBvLCBhLCBjXSwgRyhyLCB5ZCkpO1xuICB9XG4gIHN0YXRpYyBmcm9tT2JqZWN0KHQpIHtcbiAgICBsZXQgeyB4MTogZSwgeTE6IHMsIHgyOiByLCB5MjogbiB9ID0gdCwgbyA9IEcodCwgYmQpO1xuICAgIHJldHVybiB0aGlzLl9mcm9tT2JqZWN0KHYodih7fSwgbyksIHt9LCB7IHBvaW50czogW2UsIHMsIHIsIG5dIH0pLCB7IGV4dHJhUGFyYW06IFwicG9pbnRzXCIgfSk7XG4gIH1cbn1cbnkoU2UsIFwidHlwZVwiLCBcIkxpbmVcIiksIHkoU2UsIFwiY2FjaGVQcm9wZXJ0aWVzXCIsIFsuLi5kZSwgLi4ueW5dKSwgeShTZSwgXCJBVFRSSUJVVEVfTkFNRVNcIiwgRGUuY29uY2F0KHluKSksIEMuc2V0Q2xhc3MoU2UpLCBDLnNldFNWR0NsYXNzKFNlKTtcbmNsYXNzIFJlIGV4dGVuZHMgbnQge1xuICBzdGF0aWMgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHYodih7fSwgc3VwZXIuZ2V0RGVmYXVsdHMoKSksIFJlLm93bkRlZmF1bHRzKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBSZS5vd25EZWZhdWx0cyksIHRoaXMuc2V0T3B0aW9ucyh0KTtcbiAgfVxuICBfcmVuZGVyKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy53aWR0aCAvIDIsIHMgPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgdC5iZWdpblBhdGgoKSwgdC5tb3ZlVG8oLWUsIHMpLCB0LmxpbmVUbygwLCAtcyksIHQubGluZVRvKGUsIHMpLCB0LmNsb3NlUGF0aCgpLCB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIodCk7XG4gIH1cbiAgX3RvU1ZHKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLndpZHRoIC8gMiwgZSA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICByZXR1cm4gW1wiPHBvbHlnb24gXCIsIFwiQ09NTU9OX1BBUlRTXCIsICdwb2ludHM9XCInLCBcIlwiLmNvbmNhdCgtdCwgXCIgXCIpLmNvbmNhdChlLCBcIiwwIFwiKS5jb25jYXQoLWUsIFwiLFwiKS5jb25jYXQodCwgXCIgXCIpLmNvbmNhdChlKSwgJ1wiIC8+J107XG4gIH1cbn1cbnkoUmUsIFwidHlwZVwiLCBcIlRyaWFuZ2xlXCIpLCB5KFJlLCBcIm93bkRlZmF1bHRzXCIsIHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAgfSksIEMuc2V0Q2xhc3MoUmUpLCBDLnNldFNWR0NsYXNzKFJlKTtcbmNvbnN0IFFjID0gW1wicnhcIiwgXCJyeVwiXTtcbmNsYXNzIHJlIGV4dGVuZHMgbnQge1xuICBzdGF0aWMgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHYodih7fSwgc3VwZXIuZ2V0RGVmYXVsdHMoKSksIHJlLm93bkRlZmF1bHRzKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKSwgT2JqZWN0LmFzc2lnbih0aGlzLCByZS5vd25EZWZhdWx0cyksIHRoaXMuc2V0T3B0aW9ucyh0KTtcbiAgfVxuICBfc2V0KHQsIGUpIHtcbiAgICBzd2l0Y2ggKHN1cGVyLl9zZXQodCwgZSksIHQpIHtcbiAgICAgIGNhc2UgXCJyeFwiOlxuICAgICAgICB0aGlzLnJ4ID0gZSwgdGhpcy5zZXQoXCJ3aWR0aFwiLCAyICogZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJ5XCI6XG4gICAgICAgIHRoaXMucnkgPSBlLCB0aGlzLnNldChcImhlaWdodFwiLCAyICogZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFJ4KCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInJ4XCIpICogdGhpcy5nZXQodXQpO1xuICB9XG4gIGdldFJ5KCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInJ5XCIpICogdGhpcy5nZXQoVHQpO1xuICB9XG4gIHRvT2JqZWN0KCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICByZXR1cm4gc3VwZXIudG9PYmplY3QoWy4uLlFjLCAuLi50XSk7XG4gIH1cbiAgX3RvU1ZHKCkge1xuICAgIHJldHVybiBbXCI8ZWxsaXBzZSBcIiwgXCJDT01NT05fUEFSVFNcIiwgJ2N4PVwiMFwiIGN5PVwiMFwiIHJ4PVwiJy5jb25jYXQodGhpcy5yeCwgJ1wiIHJ5PVwiJykuY29uY2F0KHRoaXMucnksIGBcIiAvPlxuYCldO1xuICB9XG4gIF9yZW5kZXIodCkge1xuICAgIHQuYmVnaW5QYXRoKCksIHQuc2F2ZSgpLCB0LnRyYW5zZm9ybSgxLCAwLCAwLCB0aGlzLnJ5IC8gdGhpcy5yeCwgMCwgMCksIHQuYXJjKDAsIDAsIHRoaXMucngsIDAsIGhlLCAhMSksIHQucmVzdG9yZSgpLCB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIodCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21FbGVtZW50KHQsIGUsIHMpIHtcbiAgICBjb25zdCByID0gZmUodCwgdGhpcy5BVFRSSUJVVEVfTkFNRVMsIHMpO1xuICAgIHJldHVybiByLmxlZnQgPSAoci5sZWZ0IHx8IDApIC0gci5yeCwgci50b3AgPSAoci50b3AgfHwgMCkgLSByLnJ5LCBuZXcgdGhpcyhyKTtcbiAgfVxufVxuZnVuY3Rpb24gX2QoaSkge1xuICBpZiAoIWkpIHJldHVybiBbXTtcbiAgY29uc3QgdCA9IGkucmVwbGFjZSgvLC9nLCBcIiBcIikudHJpbSgpLnNwbGl0KC9cXHMrLyksIGUgPSBbXTtcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcyArPSAyKSBlLnB1c2goeyB4OiBwYXJzZUZsb2F0KHRbc10pLCB5OiBwYXJzZUZsb2F0KHRbcyArIDFdKSB9KTtcbiAgcmV0dXJuIGU7XG59XG55KHJlLCBcInR5cGVcIiwgXCJFbGxpcHNlXCIpLCB5KHJlLCBcImNhY2hlUHJvcGVydGllc1wiLCBbLi4uZGUsIC4uLlFjXSksIHkocmUsIFwib3duRGVmYXVsdHNcIiwgeyByeDogMCwgcnk6IDAgfSksIHkocmUsIFwiQVRUUklCVVRFX05BTUVTXCIsIFsuLi5EZSwgXCJjeFwiLCBcImN5XCIsIFwicnhcIiwgXCJyeVwiXSksIEMuc2V0Q2xhc3MocmUpLCBDLnNldFNWR0NsYXNzKHJlKTtcbmNvbnN0IFNkID0gW1wibGVmdFwiLCBcInRvcFwiXSwgdGwgPSB7IGV4YWN0Qm91bmRpbmdCb3g6ICExIH07XG5jbGFzcyBFdCBleHRlbmRzIG50IHtcbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB2KHYoe30sIHN1cGVyLmdldERlZmF1bHRzKCkpLCBFdC5vd25EZWZhdWx0cyk7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IFtdLCBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBzdXBlcigpLCB5KHRoaXMsIFwic3Ryb2tlRGlmZlwiLCB2b2lkIDApLCBPYmplY3QuYXNzaWduKHRoaXMsIEV0Lm93bkRlZmF1bHRzKSwgdGhpcy5zZXRPcHRpb25zKGUpLCB0aGlzLnBvaW50cyA9IHQ7XG4gICAgY29uc3QgeyBsZWZ0OiBzLCB0b3A6IHIgfSA9IGU7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9ICEwLCB0aGlzLnNldEJvdW5kaW5nQm94KCEwKSwgdHlwZW9mIHMgPT0gXCJudW1iZXJcIiAmJiB0aGlzLnNldChMLCBzKSwgdHlwZW9mIHIgPT0gXCJudW1iZXJcIiAmJiB0aGlzLnNldChndCwgcik7XG4gIH1cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBfcHJvamVjdFN0cm9rZU9uUG9pbnRzKHQpIHtcbiAgICByZXR1cm4gRGModGhpcy5wb2ludHMsIHQsIHRoaXMuaXNPcGVuKCkpO1xuICB9XG4gIF9jYWxjRGltZW5zaW9ucyh0KSB7XG4gICAgdCA9IHYoeyBzY2FsZVg6IHRoaXMuc2NhbGVYLCBzY2FsZVk6IHRoaXMuc2NhbGVZLCBza2V3WDogdGhpcy5za2V3WCwgc2tld1k6IHRoaXMuc2tld1ksIHN0cm9rZUxpbmVDYXA6IHRoaXMuc3Ryb2tlTGluZUNhcCwgc3Ryb2tlTGluZUpvaW46IHRoaXMuc3Ryb2tlTGluZUpvaW4sIHN0cm9rZU1pdGVyTGltaXQ6IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCwgc3Ryb2tlVW5pZm9ybTogdGhpcy5zdHJva2VVbmlmb3JtLCBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCB9LCB0IHx8IHt9KTtcbiAgICBjb25zdCBlID0gdGhpcy5leGFjdEJvdW5kaW5nQm94ID8gdGhpcy5fcHJvamVjdFN0cm9rZU9uUG9pbnRzKHQpLm1hcCgobCkgPT4gbC5wcm9qZWN0ZWRQb2ludCkgOiB0aGlzLnBvaW50cztcbiAgICBpZiAoZS5sZW5ndGggPT09IDApIHJldHVybiB7IGxlZnQ6IDAsIHRvcDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCwgcGF0aE9mZnNldDogbmV3IF8oKSwgc3Ryb2tlT2Zmc2V0OiBuZXcgXygpLCBzdHJva2VEaWZmOiBuZXcgXygpIH07XG4gICAgY29uc3QgcyA9IEd0KGUpLCByID0gYXIodih2KHt9LCB0KSwge30sIHsgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfSkpLCBuID0gR3QodGhpcy5wb2ludHMubWFwKChsKSA9PiBvdChsLCByLCAhMCkpKSwgbyA9IG5ldyBfKHRoaXMuc2NhbGVYLCB0aGlzLnNjYWxlWSk7XG4gICAgbGV0IGEgPSBzLmxlZnQgKyBzLndpZHRoIC8gMiwgYyA9IHMudG9wICsgcy5oZWlnaHQgLyAyO1xuICAgIHJldHVybiB0aGlzLmV4YWN0Qm91bmRpbmdCb3ggJiYgKGEgLT0gYyAqIE1hdGgudGFuKEsodGhpcy5za2V3WCkpLCBjIC09IGEgKiBNYXRoLnRhbihLKHRoaXMuc2tld1kpKSksIHYodih7fSwgcyksIHt9LCB7IHBhdGhPZmZzZXQ6IG5ldyBfKGEsIGMpLCBzdHJva2VPZmZzZXQ6IG5ldyBfKG4ubGVmdCwgbi50b3ApLnN1YnRyYWN0KG5ldyBfKHMubGVmdCwgcy50b3ApKS5tdWx0aXBseShvKSwgc3Ryb2tlRGlmZjogbmV3IF8ocy53aWR0aCwgcy5oZWlnaHQpLnN1YnRyYWN0KG5ldyBfKG4ud2lkdGgsIG4uaGVpZ2h0KSkubXVsdGlwbHkobykgfSk7XG4gIH1cbiAgX2ZpbmRDZW50ZXJGcm9tRWxlbWVudCgpIHtcbiAgICBjb25zdCB0ID0gR3QodGhpcy5wb2ludHMpO1xuICAgIHJldHVybiBuZXcgXyh0LmxlZnQgKyB0LndpZHRoIC8gMiwgdC50b3AgKyB0LmhlaWdodCAvIDIpO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgdGhpcy5zZXRCb3VuZGluZ0JveCgpO1xuICB9XG4gIHNldEJvdW5kaW5nQm94KHQpIHtcbiAgICBjb25zdCB7IGxlZnQ6IGUsIHRvcDogcywgd2lkdGg6IHIsIGhlaWdodDogbiwgcGF0aE9mZnNldDogbywgc3Ryb2tlT2Zmc2V0OiBhLCBzdHJva2VEaWZmOiBjIH0gPSB0aGlzLl9jYWxjRGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2V0KHsgd2lkdGg6IHIsIGhlaWdodDogbiwgcGF0aE9mZnNldDogbywgc3Ryb2tlT2Zmc2V0OiBhLCBzdHJva2VEaWZmOiBjIH0pLCB0ICYmIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbihuZXcgXyhlICsgciAvIDIsIHMgKyBuIC8gMiksIGosIGopO1xuICB9XG4gIGlzU3Ryb2tlQWNjb3VudGVkRm9ySW5EaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmV4YWN0Qm91bmRpbmdCb3g7XG4gIH1cbiAgX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5leGFjdEJvdW5kaW5nQm94ID8gbmV3IF8odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpIDogc3VwZXIuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICB9XG4gIF9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGlmICh0aGlzLmV4YWN0Qm91bmRpbmdCb3gpIHtcbiAgICAgIGxldCBvO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHQpLnNvbWUoKGEpID0+IHRoaXMuc3Ryb2tlVW5pZm9ybSB8fCB0aGlzLmNvbnN0cnVjdG9yLmxheW91dFByb3BlcnRpZXMuaW5jbHVkZXMoYSkpKSB7XG4gICAgICAgIHZhciBlLCBzO1xuICAgICAgICBjb25zdCB7IHdpZHRoOiBhLCBoZWlnaHQ6IGMgfSA9IHRoaXMuX2NhbGNEaW1lbnNpb25zKHQpO1xuICAgICAgICBvID0gbmV3IF8oKGUgPSB0LndpZHRoKSAhPT0gbnVsbCAmJiBlICE9PSB2b2lkIDAgPyBlIDogYSwgKHMgPSB0LmhlaWdodCkgIT09IG51bGwgJiYgcyAhPT0gdm9pZCAwID8gcyA6IGMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHIsIG47XG4gICAgICAgIG8gPSBuZXcgXygociA9IHQud2lkdGgpICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiB0aGlzLndpZHRoLCAobiA9IHQuaGVpZ2h0KSAhPT0gbnVsbCAmJiBuICE9PSB2b2lkIDAgPyBuIDogdGhpcy5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG8ubXVsdGlwbHkobmV3IF8odC5zY2FsZVggfHwgdGhpcy5zY2FsZVgsIHQuc2NhbGVZIHx8IHRoaXMuc2NhbGVZKSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKHQpO1xuICB9XG4gIF9zZXQodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmluaXRpYWxpemVkICYmIHRoaXNbdF0gIT09IGUsIHIgPSBzdXBlci5fc2V0KHQsIGUpO1xuICAgIHJldHVybiB0aGlzLmV4YWN0Qm91bmRpbmdCb3ggJiYgcyAmJiAoKHQgPT09IHV0IHx8IHQgPT09IFR0KSAmJiB0aGlzLnN0cm9rZVVuaWZvcm0gJiYgdGhpcy5jb25zdHJ1Y3Rvci5sYXlvdXRQcm9wZXJ0aWVzLmluY2x1ZGVzKFwic3Ryb2tlVW5pZm9ybVwiKSB8fCB0aGlzLmNvbnN0cnVjdG9yLmxheW91dFByb3BlcnRpZXMuaW5jbHVkZXModCkpICYmIHRoaXMuc2V0RGltZW5zaW9ucygpLCByO1xuICB9XG4gIHRvT2JqZWN0KCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICByZXR1cm4gdih2KHt9LCBzdXBlci50b09iamVjdCh0KSksIHt9LCB7IHBvaW50czogdGhpcy5wb2ludHMubWFwKChlKSA9PiB7XG4gICAgICBsZXQgeyB4OiBzLCB5OiByIH0gPSBlO1xuICAgICAgcmV0dXJuIHsgeDogcywgeTogciB9O1xuICAgIH0pIH0pO1xuICB9XG4gIF90b1NWRygpIHtcbiAgICBjb25zdCB0ID0gW10sIGUgPSB0aGlzLnBhdGhPZmZzZXQueCwgcyA9IHRoaXMucGF0aE9mZnNldC55LCByID0gQS5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgIGZvciAobGV0IG4gPSAwLCBvID0gdGhpcy5wb2ludHMubGVuZ3RoOyBuIDwgbzsgbisrKSB0LnB1c2goVih0aGlzLnBvaW50c1tuXS54IC0gZSwgciksIFwiLFwiLCBWKHRoaXMucG9pbnRzW25dLnkgLSBzLCByKSwgXCIgXCIpO1xuICAgIHJldHVybiBbXCI8XCIuY29uY2F0KHRoaXMuY29uc3RydWN0b3IudHlwZS50b0xvd2VyQ2FzZSgpLCBcIiBcIiksIFwiQ09NTU9OX1BBUlRTXCIsICdwb2ludHM9XCInLmNvbmNhdCh0LmpvaW4oXCJcIiksIGBcIiAvPlxuYCldO1xuICB9XG4gIF9yZW5kZXIodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnBvaW50cy5sZW5ndGgsIHMgPSB0aGlzLnBhdGhPZmZzZXQueCwgciA9IHRoaXMucGF0aE9mZnNldC55O1xuICAgIGlmIChlICYmICFpc05hTih0aGlzLnBvaW50c1tlIC0gMV0ueSkpIHtcbiAgICAgIHQuYmVnaW5QYXRoKCksIHQubW92ZVRvKHRoaXMucG9pbnRzWzBdLnggLSBzLCB0aGlzLnBvaW50c1swXS55IC0gcik7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGU7IG4rKykge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5wb2ludHNbbl07XG4gICAgICAgIHQubGluZVRvKG8ueCAtIHMsIG8ueSAtIHIpO1xuICAgICAgfVxuICAgICAgIXRoaXMuaXNPcGVuKCkgJiYgdC5jbG9zZVBhdGgoKSwgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKHQpO1xuICAgIH1cbiAgfVxuICBjb21wbGV4aXR5KCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50cy5sZW5ndGg7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21FbGVtZW50KHQsIGUsIHMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoX2QodC5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIikpLCB2KHYoe30sIEcoZmUodCwgdGhpcy5BVFRSSUJVVEVfTkFNRVMsIHMpLCBTZCkpLCBlKSk7XG4gIH1cbiAgc3RhdGljIGZyb21PYmplY3QodCkge1xuICAgIHJldHVybiB0aGlzLl9mcm9tT2JqZWN0KHQsIHsgZXh0cmFQYXJhbTogXCJwb2ludHNcIiB9KTtcbiAgfVxufVxueShFdCwgXCJvd25EZWZhdWx0c1wiLCB0bCksIHkoRXQsIFwidHlwZVwiLCBcIlBvbHlsaW5lXCIpLCB5KEV0LCBcImxheW91dFByb3BlcnRpZXNcIiwgW09zLCBrcywgXCJzdHJva2VMaW5lQ2FwXCIsIFwic3Ryb2tlTGluZUpvaW5cIiwgXCJzdHJva2VNaXRlckxpbWl0XCIsIFwic3Ryb2tlV2lkdGhcIiwgXCJzdHJva2VVbmlmb3JtXCIsIFwicG9pbnRzXCJdKSwgeShFdCwgXCJjYWNoZVByb3BlcnRpZXNcIiwgWy4uLmRlLCBcInBvaW50c1wiXSksIHkoRXQsIFwiQVRUUklCVVRFX05BTUVTXCIsIFsuLi5EZV0pLCBDLnNldENsYXNzKEV0KSwgQy5zZXRTVkdDbGFzcyhFdCk7XG5jbGFzcyBiciBleHRlbmRzIEV0IHtcbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxueShiciwgXCJvd25EZWZhdWx0c1wiLCB0bCksIHkoYnIsIFwidHlwZVwiLCBcIlBvbHlnb25cIiksIEMuc2V0Q2xhc3MoYnIpLCBDLnNldFNWR0NsYXNzKGJyKTtcbmNvbnN0IGVsID0gW1wiZm9udFNpemVcIiwgXCJmb250V2VpZ2h0XCIsIFwiZm9udEZhbWlseVwiLCBcImZvbnRTdHlsZVwiXSwgc2wgPSBbXCJ1bmRlcmxpbmVcIiwgXCJvdmVybGluZVwiLCBcImxpbmV0aHJvdWdoXCJdLCBybCA9IFsuLi5lbCwgXCJsaW5lSGVpZ2h0XCIsIFwidGV4dFwiLCBcImNoYXJTcGFjaW5nXCIsIFwidGV4dEFsaWduXCIsIFwic3R5bGVzXCIsIFwicGF0aFwiLCBcInBhdGhTdGFydE9mZnNldFwiLCBcInBhdGhTaWRlXCIsIFwicGF0aEFsaWduXCJdLCBpbCA9IFsuLi5ybCwgLi4uc2wsIFwidGV4dEJhY2tncm91bmRDb2xvclwiLCBcImRpcmVjdGlvblwiXSwgVGQgPSBbLi4uZWwsIC4uLnNsLCBtdCwgXCJzdHJva2VXaWR0aFwiLCBydCwgXCJkZWx0YVlcIiwgXCJ0ZXh0QmFja2dyb3VuZENvbG9yXCJdLCB4ZCA9IHsgX3JlTmV3bGluZTogUG4sIF9yZVNwYWNlc0FuZFRhYnM6IC9bIFxcdFxccl0vZywgX3JlU3BhY2VBbmRUYWI6IC9bIFxcdFxccl0vLCBfcmVXb3JkczogL1xcUysvZywgZm9udFNpemU6IDQwLCBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLCBmb250RmFtaWx5OiBcIlRpbWVzIE5ldyBSb21hblwiLCB1bmRlcmxpbmU6ICExLCBvdmVybGluZTogITEsIGxpbmV0aHJvdWdoOiAhMSwgdGV4dEFsaWduOiBMLCBmb250U3R5bGU6IFwibm9ybWFsXCIsIGxpbmVIZWlnaHQ6IDEuMTYsIHN1cGVyc2NyaXB0OiB7IHNpemU6IDAuNiwgYmFzZWxpbmU6IC0wLjM1IH0sIHN1YnNjcmlwdDogeyBzaXplOiAwLjYsIGJhc2VsaW5lOiAwLjExIH0sIHRleHRCYWNrZ3JvdW5kQ29sb3I6IFwiXCIsIHN0cm9rZTogbnVsbCwgc2hhZG93OiBudWxsLCBwYXRoOiB2b2lkIDAsIHBhdGhTdGFydE9mZnNldDogMCwgcGF0aFNpZGU6IEwsIHBhdGhBbGlnbjogXCJiYXNlbGluZVwiLCBfZm9udFNpemVGcmFjdGlvbjogMC4yMjIsIG9mZnNldHM6IHsgdW5kZXJsaW5lOiAwLjEsIGxpbmV0aHJvdWdoOiAtMC4zMTUsIG92ZXJsaW5lOiAtMC44OCB9LCBfZm9udFNpemVNdWx0OiAxLjEzLCBjaGFyU3BhY2luZzogMCwgZGVsdGFZOiAwLCBkaXJlY3Rpb246IFwibHRyXCIsIENBQ0hFX0ZPTlRfU0laRTogNDAwLCBNSU5fVEVYVF9XSURUSDogMiB9LCBIdCA9IFwianVzdGlmeVwiLCBuaSA9IFwianVzdGlmeS1sZWZ0XCIsIFZzID0gXCJqdXN0aWZ5LXJpZ2h0XCIsIEdzID0gXCJqdXN0aWZ5LWNlbnRlclwiO1xuY2xhc3MgbmwgZXh0ZW5kcyBudCB7XG4gIGlzRW1wdHlTdHlsZXModCkge1xuICAgIGlmICghdGhpcy5zdHlsZXMgfHwgdCAhPT0gdm9pZCAwICYmICF0aGlzLnN0eWxlc1t0XSkgcmV0dXJuICEwO1xuICAgIGNvbnN0IGUgPSB0ID09PSB2b2lkIDAgPyB0aGlzLnN0eWxlcyA6IHsgbGluZTogdGhpcy5zdHlsZXNbdF0gfTtcbiAgICBmb3IgKGNvbnN0IHMgaW4gZSkgZm9yIChjb25zdCByIGluIGVbc10pIGZvciAoY29uc3QgbiBpbiBlW3NdW3JdKSByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIHN0eWxlSGFzKHQsIGUpIHtcbiAgICBpZiAoIXRoaXMuc3R5bGVzIHx8IGUgIT09IHZvaWQgMCAmJiAhdGhpcy5zdHlsZXNbZV0pIHJldHVybiAhMTtcbiAgICBjb25zdCBzID0gZSA9PT0gdm9pZCAwID8gdGhpcy5zdHlsZXMgOiB7IDA6IHRoaXMuc3R5bGVzW2VdIH07XG4gICAgZm9yIChjb25zdCByIGluIHMpIGZvciAoY29uc3QgbiBpbiBzW3JdKSBpZiAoc1tyXVtuXVt0XSAhPT0gdm9pZCAwKSByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGNsZWFuU3R5bGUodCkge1xuICAgIGlmICghdGhpcy5zdHlsZXMpIHJldHVybiAhMTtcbiAgICBjb25zdCBlID0gdGhpcy5zdHlsZXM7XG4gICAgbGV0IHMsIHIsIG4gPSAwLCBvID0gITAsIGEgPSAwO1xuICAgIGZvciAoY29uc3QgYyBpbiBlKSB7XG4gICAgICBzID0gMDtcbiAgICAgIGZvciAoY29uc3QgbCBpbiBlW2NdKSB7XG4gICAgICAgIGNvbnN0IGggPSBlW2NdW2xdIHx8IHt9O1xuICAgICAgICBuKyssIGhbdF0gIT09IHZvaWQgMCA/IChyID8gaFt0XSAhPT0gciAmJiAobyA9ICExKSA6IHIgPSBoW3RdLCBoW3RdID09PSB0aGlzW3RdICYmIGRlbGV0ZSBoW3RdKSA6IG8gPSAhMSwgT2JqZWN0LmtleXMoaCkubGVuZ3RoICE9PSAwID8gcysrIDogZGVsZXRlIGVbY11bbF07XG4gICAgICB9XG4gICAgICBzID09PSAwICYmIGRlbGV0ZSBlW2NdO1xuICAgIH1cbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGMrKykgYSArPSB0aGlzLl90ZXh0TGluZXNbY10ubGVuZ3RoO1xuICAgIG8gJiYgbiA9PT0gYSAmJiAodGhpc1t0XSA9IHIsIHRoaXMucmVtb3ZlU3R5bGUodCkpO1xuICB9XG4gIHJlbW92ZVN0eWxlKHQpIHtcbiAgICBpZiAoIXRoaXMuc3R5bGVzKSByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuc3R5bGVzO1xuICAgIGxldCBzLCByLCBuO1xuICAgIGZvciAociBpbiBlKSB7XG4gICAgICBmb3IgKG4gaW4gcyA9IGVbcl0sIHMpIGRlbGV0ZSBzW25dW3RdLCBPYmplY3Qua2V5cyhzW25dKS5sZW5ndGggPT09IDAgJiYgZGVsZXRlIHNbbl07XG4gICAgICBPYmplY3Qua2V5cyhzKS5sZW5ndGggPT09IDAgJiYgZGVsZXRlIGVbcl07XG4gICAgfVxuICB9XG4gIF9leHRlbmRTdHlsZXModCwgZSkge1xuICAgIGNvbnN0IHsgbGluZUluZGV4OiBzLCBjaGFySW5kZXg6IHIgfSA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbih0KTtcbiAgICB0aGlzLl9nZXRMaW5lU3R5bGUocykgfHwgdGhpcy5fc2V0TGluZVN0eWxlKHMpO1xuICAgIGNvbnN0IG4gPSBYbih2KHYoe30sIHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24ocywgcikpLCBlKSwgKG8pID0+IG8gIT09IHZvaWQgMCk7XG4gICAgdGhpcy5fc2V0U3R5bGVEZWNsYXJhdGlvbihzLCByLCBuKTtcbiAgfVxuICBnZXRTZWxlY3Rpb25TdHlsZXModCwgZSwgcykge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gdDsgbiA8IChlIHx8IHQpOyBuKyspIHIucHVzaCh0aGlzLmdldFN0eWxlQXRQb3NpdGlvbihuLCBzKSk7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZ2V0U3R5bGVBdFBvc2l0aW9uKHQsIGUpIHtcbiAgICBjb25zdCB7IGxpbmVJbmRleDogcywgY2hhckluZGV4OiByIH0gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24odCk7XG4gICAgcmV0dXJuIGUgPyB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihzLCByKSA6IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24ocywgcik7XG4gIH1cbiAgc2V0U2VsZWN0aW9uU3R5bGVzKHQsIGUsIHMpIHtcbiAgICBmb3IgKGxldCByID0gZTsgciA8IChzIHx8IGUpOyByKyspIHRoaXMuX2V4dGVuZFN0eWxlcyhyLCB0KTtcbiAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSAhMDtcbiAgfVxuICBfZ2V0U3R5bGVEZWNsYXJhdGlvbih0LCBlKSB7XG4gICAgdmFyIHM7XG4gICAgY29uc3QgciA9IHRoaXMuc3R5bGVzICYmIHRoaXMuc3R5bGVzW3RdO1xuICAgIHJldHVybiByICYmIChzID0gcltlXSkgIT09IG51bGwgJiYgcyAhPT0gdm9pZCAwID8gcyA6IHt9O1xuICB9XG4gIGdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbih0LCBlKSB7XG4gICAgcmV0dXJuIHYodih7fSwgVmUodGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5fc3R5bGVQcm9wZXJ0aWVzKSksIHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24odCwgZSkpO1xuICB9XG4gIF9zZXRTdHlsZURlY2xhcmF0aW9uKHQsIGUsIHMpIHtcbiAgICB0aGlzLnN0eWxlc1t0XVtlXSA9IHM7XG4gIH1cbiAgX2RlbGV0ZVN0eWxlRGVjbGFyYXRpb24odCwgZSkge1xuICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1t0XVtlXTtcbiAgfVxuICBfZ2V0TGluZVN0eWxlKHQpIHtcbiAgICByZXR1cm4gISF0aGlzLnN0eWxlc1t0XTtcbiAgfVxuICBfc2V0TGluZVN0eWxlKHQpIHtcbiAgICB0aGlzLnN0eWxlc1t0XSA9IHt9O1xuICB9XG4gIF9kZWxldGVMaW5lU3R5bGUodCkge1xuICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1t0XTtcbiAgfVxufVxueShubCwgXCJfc3R5bGVQcm9wZXJ0aWVzXCIsIFRkKTtcbmNvbnN0IHdkID0gLyAgKy9nLCBDZCA9IC9cIi9nO1xuZnVuY3Rpb24gVmkoaSwgdCwgZSwgcywgcikge1xuICByZXR1cm4gXCJcdFx0XCIuY29uY2F0KGZ1bmN0aW9uKG4sIG8pIHtcbiAgICBsZXQgeyBsZWZ0OiBhLCB0b3A6IGMsIHdpZHRoOiBsLCBoZWlnaHQ6IGggfSA9IG8sIHUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IEEuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICBjb25zdCBkID0gS3MocnQsIG4sICExKSwgW2YsIGcsIHAsIG1dID0gW2EsIGMsIGwsIGhdLm1hcCgoYikgPT4gVihiLCB1KSk7XG4gICAgcmV0dXJuIFwiPHJlY3QgXCIuY29uY2F0KGQsICcgeD1cIicpLmNvbmNhdChmLCAnXCIgeT1cIicpLmNvbmNhdChnLCAnXCIgd2lkdGg9XCInKS5jb25jYXQocCwgJ1wiIGhlaWdodD1cIicpLmNvbmNhdChtLCAnXCI+PC9yZWN0PicpO1xuICB9KGksIHsgbGVmdDogdCwgdG9wOiBlLCB3aWR0aDogcywgaGVpZ2h0OiByIH0pLCBgXG5gKTtcbn1cbmNvbnN0IE9kID0gW1widGV4dEFuY2hvclwiLCBcInRleHREZWNvcmF0aW9uXCIsIFwiZHhcIiwgXCJkeVwiLCBcInRvcFwiLCBcImxlZnRcIiwgXCJmb250U2l6ZVwiLCBcInN0cm9rZVdpZHRoXCJdO1xubGV0IEdpO1xuY2xhc3MgY3QgZXh0ZW5kcyBubCB7XG4gIHN0YXRpYyBnZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4gdih2KHt9LCBzdXBlci5nZXREZWZhdWx0cygpKSwgY3Qub3duRGVmYXVsdHMpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcigpLCB5KHRoaXMsIFwiX19jaGFyQm91bmRzXCIsIFtdKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBjdC5vd25EZWZhdWx0cyksIHRoaXMuc2V0T3B0aW9ucyhlKSwgdGhpcy5zdHlsZXMgfHwgKHRoaXMuc3R5bGVzID0ge30pLCB0aGlzLnRleHQgPSB0LCB0aGlzLmluaXRpYWxpemVkID0gITAsIHRoaXMucGF0aCAmJiB0aGlzLnNldFBhdGhJbmZvKCksIHRoaXMuaW5pdERpbWVuc2lvbnMoKSwgdGhpcy5zZXRDb29yZHMoKTtcbiAgfVxuICBzZXRQYXRoSW5mbygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5wYXRoO1xuICAgIHQgJiYgKHQuc2VnbWVudHNJbmZvID0gUW4odC5wYXRoKSk7XG4gIH1cbiAgX3NwbGl0VGV4dCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKHRoaXMudGV4dCk7XG4gICAgcmV0dXJuIHRoaXMudGV4dExpbmVzID0gdC5saW5lcywgdGhpcy5fdGV4dExpbmVzID0gdC5ncmFwaGVtZUxpbmVzLCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXMgPSB0Ll91bndyYXBwZWRMaW5lcywgdGhpcy5fdGV4dCA9IHQuZ3JhcGhlbWVUZXh0LCB0O1xuICB9XG4gIGluaXREaW1lbnNpb25zKCkge1xuICAgIHRoaXMuX3NwbGl0VGV4dCgpLCB0aGlzLl9jbGVhckNhY2hlKCksIHRoaXMuZGlydHkgPSAhMCwgdGhpcy5wYXRoID8gKHRoaXMud2lkdGggPSB0aGlzLnBhdGgud2lkdGgsIHRoaXMuaGVpZ2h0ID0gdGhpcy5wYXRoLmhlaWdodCkgOiAodGhpcy53aWR0aCA9IHRoaXMuY2FsY1RleHRXaWR0aCgpIHx8IHRoaXMuY3Vyc29yV2lkdGggfHwgdGhpcy5NSU5fVEVYVF9XSURUSCwgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbGNUZXh0SGVpZ2h0KCkpLCB0aGlzLnRleHRBbGlnbi5pbmNsdWRlcyhIdCkgJiYgdGhpcy5lbmxhcmdlU3BhY2VzKCk7XG4gIH1cbiAgZW5sYXJnZVNwYWNlcygpIHtcbiAgICBsZXQgdCwgZSwgcywgciwgbiwgbywgYTtcbiAgICBmb3IgKGxldCBjID0gMCwgbCA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGMgPCBsOyBjKyspIGlmICgodGhpcy50ZXh0QWxpZ24gPT09IEh0IHx8IGMgIT09IGwgLSAxICYmICF0aGlzLmlzRW5kT2ZXcmFwcGluZyhjKSkgJiYgKHIgPSAwLCBuID0gdGhpcy5fdGV4dExpbmVzW2NdLCBlID0gdGhpcy5nZXRMaW5lV2lkdGgoYyksIGUgPCB0aGlzLndpZHRoICYmIChhID0gdGhpcy50ZXh0TGluZXNbY10ubWF0Y2godGhpcy5fcmVTcGFjZXNBbmRUYWJzKSkpKSB7XG4gICAgICBzID0gYS5sZW5ndGgsIHQgPSAodGhpcy53aWR0aCAtIGUpIC8gcztcbiAgICAgIGZvciAobGV0IGggPSAwOyBoIDw9IG4ubGVuZ3RoOyBoKyspIG8gPSB0aGlzLl9fY2hhckJvdW5kc1tjXVtoXSwgdGhpcy5fcmVTcGFjZUFuZFRhYi50ZXN0KG5baF0pID8gKG8ud2lkdGggKz0gdCwgby5rZXJuZWRXaWR0aCArPSB0LCBvLmxlZnQgKz0gciwgciArPSB0KSA6IG8ubGVmdCArPSByO1xuICAgIH1cbiAgfVxuICBpc0VuZE9mV3JhcHBpbmcodCkge1xuICAgIHJldHVybiB0ID09PSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoIC0gMTtcbiAgfVxuICBtaXNzaW5nTmV3bGluZU9mZnNldCh0KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0MkRDdXJzb3JMb2NhdGlvbih0LCBlKSB7XG4gICAgY29uc3QgcyA9IGUgPyB0aGlzLl91bndyYXBwZWRUZXh0TGluZXMgOiB0aGlzLl90ZXh0TGluZXM7XG4gICAgbGV0IHI7XG4gICAgZm9yIChyID0gMDsgciA8IHMubGVuZ3RoOyByKyspIHtcbiAgICAgIGlmICh0IDw9IHNbcl0ubGVuZ3RoKSByZXR1cm4geyBsaW5lSW5kZXg6IHIsIGNoYXJJbmRleDogdCB9O1xuICAgICAgdCAtPSBzW3JdLmxlbmd0aCArIHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQociwgZSk7XG4gICAgfVxuICAgIHJldHVybiB7IGxpbmVJbmRleDogciAtIDEsIGNoYXJJbmRleDogc1tyIC0gMV0ubGVuZ3RoIDwgdCA/IHNbciAtIDFdLmxlbmd0aCA6IHQgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCIjPFRleHQgKFwiLmNvbmNhdCh0aGlzLmNvbXBsZXhpdHkoKSwgJyk6IHsgXCJ0ZXh0XCI6IFwiJykuY29uY2F0KHRoaXMudGV4dCwgJ1wiLCBcImZvbnRGYW1pbHlcIjogXCInKS5jb25jYXQodGhpcy5mb250RmFtaWx5LCAnXCIgfT4nKTtcbiAgfVxuICBfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHQgPSBzdXBlci5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCksIGUgPSB0aGlzLmZvbnRTaXplO1xuICAgIHJldHVybiB0LndpZHRoICs9IGUgKiB0Lnpvb21YLCB0LmhlaWdodCArPSBlICogdC56b29tWSwgdDtcbiAgfVxuICBfcmVuZGVyKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5wYXRoO1xuICAgIGUgJiYgIWUuaXNOb3RWaXNpYmxlKCkgJiYgZS5fcmVuZGVyKHQpLCB0aGlzLl9zZXRUZXh0U3R5bGVzKHQpLCB0aGlzLl9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kKHQpLCB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbih0LCBcInVuZGVybGluZVwiKSwgdGhpcy5fcmVuZGVyVGV4dCh0KSwgdGhpcy5fcmVuZGVyVGV4dERlY29yYXRpb24odCwgXCJvdmVybGluZVwiKSwgdGhpcy5fcmVuZGVyVGV4dERlY29yYXRpb24odCwgXCJsaW5ldGhyb3VnaFwiKTtcbiAgfVxuICBfcmVuZGVyVGV4dCh0KSB7XG4gICAgdGhpcy5wYWludEZpcnN0ID09PSBtdCA/ICh0aGlzLl9yZW5kZXJUZXh0U3Ryb2tlKHQpLCB0aGlzLl9yZW5kZXJUZXh0RmlsbCh0KSkgOiAodGhpcy5fcmVuZGVyVGV4dEZpbGwodCksIHRoaXMuX3JlbmRlclRleHRTdHJva2UodCkpO1xuICB9XG4gIF9zZXRUZXh0U3R5bGVzKHQsIGUsIHMpIHtcbiAgICBpZiAodC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIiwgdGhpcy5wYXRoKSBzd2l0Y2ggKHRoaXMucGF0aEFsaWduKSB7XG4gICAgICBjYXNlIGo6XG4gICAgICAgIHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYXNjZW5kZXJcIjpcbiAgICAgICAgdC50ZXh0QmFzZWxpbmUgPSBndDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVzY2VuZGVyXCI6XG4gICAgICAgIHQudGV4dEJhc2VsaW5lID0gcm47XG4gICAgfVxuICAgIHQuZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihlLCBzKTtcbiAgfVxuICBjYWxjVGV4dFdpZHRoKCkge1xuICAgIGxldCB0ID0gdGhpcy5nZXRMaW5lV2lkdGgoMCk7XG4gICAgZm9yIChsZXQgZSA9IDEsIHMgPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBlIDwgczsgZSsrKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5nZXRMaW5lV2lkdGgoZSk7XG4gICAgICByID4gdCAmJiAodCA9IHIpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBfcmVuZGVyVGV4dExpbmUodCwgZSwgcywgciwgbiwgbykge1xuICAgIHRoaXMuX3JlbmRlckNoYXJzKHQsIGUsIHMsIHIsIG4sIG8pO1xuICB9XG4gIF9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kKHQpIHtcbiAgICBpZiAoIXRoaXMudGV4dEJhY2tncm91bmRDb2xvciAmJiAhdGhpcy5zdHlsZUhhcyhcInRleHRCYWNrZ3JvdW5kQ29sb3JcIikpIHJldHVybjtcbiAgICBjb25zdCBlID0gdC5maWxsU3R5bGUsIHMgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCk7XG4gICAgbGV0IHIgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKTtcbiAgICBmb3IgKGxldCBuID0gMCwgbyA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IG4gPCBvOyBuKyspIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLmdldEhlaWdodE9mTGluZShuKTtcbiAgICAgIGlmICghdGhpcy50ZXh0QmFja2dyb3VuZENvbG9yICYmICF0aGlzLnN0eWxlSGFzKFwidGV4dEJhY2tncm91bmRDb2xvclwiLCBuKSkge1xuICAgICAgICByICs9IGE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgYyA9IHRoaXMuX3RleHRMaW5lc1tuXS5sZW5ndGgsIGwgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChuKTtcbiAgICAgIGxldCBoLCB1LCBkID0gMCwgZiA9IDAsIGcgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KG4sIDAsIFwidGV4dEJhY2tncm91bmRDb2xvclwiKTtcbiAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgYzsgcCsrKSB7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9fY2hhckJvdW5kc1tuXVtwXTtcbiAgICAgICAgdSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobiwgcCwgXCJ0ZXh0QmFja2dyb3VuZENvbG9yXCIpLCB0aGlzLnBhdGggPyAodC5zYXZlKCksIHQudHJhbnNsYXRlKG0ucmVuZGVyTGVmdCwgbS5yZW5kZXJUb3ApLCB0LnJvdGF0ZShtLmFuZ2xlKSwgdC5maWxsU3R5bGUgPSB1LCB1ICYmIHQuZmlsbFJlY3QoLW0ud2lkdGggLyAyLCAtYSAvIHRoaXMubGluZUhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbiksIG0ud2lkdGgsIGEgLyB0aGlzLmxpbmVIZWlnaHQpLCB0LnJlc3RvcmUoKSkgOiB1ICE9PSBnID8gKGggPSBzICsgbCArIGYsIHRoaXMuZGlyZWN0aW9uID09PSBcInJ0bFwiICYmIChoID0gdGhpcy53aWR0aCAtIGggLSBkKSwgdC5maWxsU3R5bGUgPSBnLCBnICYmIHQuZmlsbFJlY3QoaCwgciwgZCwgYSAvIHRoaXMubGluZUhlaWdodCksIGYgPSBtLmxlZnQsIGQgPSBtLndpZHRoLCBnID0gdSkgOiBkICs9IG0ua2VybmVkV2lkdGg7XG4gICAgICB9XG4gICAgICB1ICYmICF0aGlzLnBhdGggJiYgKGggPSBzICsgbCArIGYsIHRoaXMuZGlyZWN0aW9uID09PSBcInJ0bFwiICYmIChoID0gdGhpcy53aWR0aCAtIGggLSBkKSwgdC5maWxsU3R5bGUgPSB1LCB0LmZpbGxSZWN0KGgsIHIsIGQsIGEgLyB0aGlzLmxpbmVIZWlnaHQpKSwgciArPSBhO1xuICAgIH1cbiAgICB0LmZpbGxTdHlsZSA9IGUsIHRoaXMuX3JlbW92ZVNoYWRvdyh0KTtcbiAgfVxuICBfbWVhc3VyZUNoYXIodCwgZSwgcywgcikge1xuICAgIGNvbnN0IG4gPSB6cy5nZXRGb250Q2FjaGUoZSksIG8gPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oZSksIGEgPSBzICsgdCwgYyA9IHMgJiYgbyA9PT0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKHIpLCBsID0gZS5mb250U2l6ZSAvIHRoaXMuQ0FDSEVfRk9OVF9TSVpFO1xuICAgIGxldCBoLCB1LCBkLCBmO1xuICAgIGlmIChzICYmIG5bc10gIT09IHZvaWQgMCAmJiAoZCA9IG5bc10pLCBuW3RdICE9PSB2b2lkIDAgJiYgKGYgPSBoID0gblt0XSksIGMgJiYgblthXSAhPT0gdm9pZCAwICYmICh1ID0gblthXSwgZiA9IHUgLSBkKSwgaCA9PT0gdm9pZCAwIHx8IGQgPT09IHZvaWQgMCB8fCB1ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEdpIHx8IChHaSA9IFd0KHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KS5nZXRDb250ZXh0KFwiMmRcIikpLCBHaTtcbiAgICAgIH0oKTtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoZywgZSwgITApLCBoID09PSB2b2lkIDAgJiYgKGYgPSBoID0gZy5tZWFzdXJlVGV4dCh0KS53aWR0aCwgblt0XSA9IGgpLCBkID09PSB2b2lkIDAgJiYgYyAmJiBzICYmIChkID0gZy5tZWFzdXJlVGV4dChzKS53aWR0aCwgbltzXSA9IGQpLCBjICYmIHUgPT09IHZvaWQgMCAmJiAodSA9IGcubWVhc3VyZVRleHQoYSkud2lkdGgsIG5bYV0gPSB1LCBmID0gdSAtIGQpO1xuICAgIH1cbiAgICByZXR1cm4geyB3aWR0aDogaCAqIGwsIGtlcm5lZFdpZHRoOiBmICogbCB9O1xuICB9XG4gIGdldEhlaWdodE9mQ2hhcih0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQodCwgZSwgXCJmb250U2l6ZVwiKTtcbiAgfVxuICBtZWFzdXJlTGluZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX21lYXN1cmVMaW5lKHQpO1xuICAgIHJldHVybiB0aGlzLmNoYXJTcGFjaW5nICE9PSAwICYmIChlLndpZHRoIC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpKSwgZS53aWR0aCA8IDAgJiYgKGUud2lkdGggPSAwKSwgZTtcbiAgfVxuICBfbWVhc3VyZUxpbmUodCkge1xuICAgIGxldCBlLCBzLCByID0gMDtcbiAgICBjb25zdCBuID0gdGhpcy5wYXRoU2lkZSA9PT0gWiwgbyA9IHRoaXMucGF0aCwgYSA9IHRoaXMuX3RleHRMaW5lc1t0XSwgYyA9IGEubGVuZ3RoLCBsID0gbmV3IEFycmF5KGMpO1xuICAgIHRoaXMuX19jaGFyQm91bmRzW3RdID0gbDtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IGM7IGgrKykge1xuICAgICAgY29uc3QgdSA9IGFbaF07XG4gICAgICBzID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3godSwgdCwgaCwgZSksIGxbaF0gPSBzLCByICs9IHMua2VybmVkV2lkdGgsIGUgPSB1O1xuICAgIH1cbiAgICBpZiAobFtjXSA9IHsgbGVmdDogcyA/IHMubGVmdCArIHMud2lkdGggOiAwLCB3aWR0aDogMCwga2VybmVkV2lkdGg6IDAsIGhlaWdodDogdGhpcy5mb250U2l6ZSwgZGVsdGFZOiAwIH0sIG8gJiYgby5zZWdtZW50c0luZm8pIHtcbiAgICAgIGxldCBoID0gMDtcbiAgICAgIGNvbnN0IHUgPSBvLnNlZ21lbnRzSW5mb1tvLnNlZ21lbnRzSW5mby5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICBzd2l0Y2ggKHRoaXMudGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgTDpcbiAgICAgICAgICBoID0gbiA/IHUgLSByIDogMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBqOlxuICAgICAgICAgIGggPSAodSAtIHIpIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBaOlxuICAgICAgICAgIGggPSBuID8gMCA6IHUgLSByO1xuICAgICAgfVxuICAgICAgaCArPSB0aGlzLnBhdGhTdGFydE9mZnNldCAqIChuID8gLTEgOiAxKTtcbiAgICAgIGZvciAobGV0IGQgPSBuID8gYyAtIDEgOiAwOyBuID8gZCA+PSAwIDogZCA8IGM7IG4gPyBkLS0gOiBkKyspIHMgPSBsW2RdLCBoID4gdSA/IGggJT0gdSA6IGggPCAwICYmIChoICs9IHUpLCB0aGlzLl9zZXRHcmFwaGVtZU9uUGF0aChoLCBzKSwgaCArPSBzLmtlcm5lZFdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4geyB3aWR0aDogciwgbnVtT2ZTcGFjZXM6IDAgfTtcbiAgfVxuICBfc2V0R3JhcGhlbWVPblBhdGgodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0ICsgZS5rZXJuZWRXaWR0aCAvIDIsIHIgPSB0aGlzLnBhdGgsIG4gPSBWYyhyLnBhdGgsIHMsIHIuc2VnbWVudHNJbmZvKTtcbiAgICBlLnJlbmRlckxlZnQgPSBuLnggLSByLnBhdGhPZmZzZXQueCwgZS5yZW5kZXJUb3AgPSBuLnkgLSByLnBhdGhPZmZzZXQueSwgZS5hbmdsZSA9IG4uYW5nbGUgKyAodGhpcy5wYXRoU2lkZSA9PT0gWiA/IE1hdGguUEkgOiAwKTtcbiAgfVxuICBfZ2V0R3JhcGhlbWVCb3godCwgZSwgcywgciwgbikge1xuICAgIGNvbnN0IG8gPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihlLCBzKSwgYSA9IHIgPyB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihlLCBzIC0gMSkgOiB7fSwgYyA9IHRoaXMuX21lYXN1cmVDaGFyKHQsIG8sIHIsIGEpO1xuICAgIGxldCBsLCBoID0gYy5rZXJuZWRXaWR0aCwgdSA9IGMud2lkdGg7XG4gICAgdGhpcy5jaGFyU3BhY2luZyAhPT0gMCAmJiAobCA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpLCB1ICs9IGwsIGggKz0gbCk7XG4gICAgY29uc3QgZCA9IHsgd2lkdGg6IHUsIGxlZnQ6IDAsIGhlaWdodDogby5mb250U2l6ZSwga2VybmVkV2lkdGg6IGgsIGRlbHRhWTogby5kZWx0YVkgfTtcbiAgICBpZiAocyA+IDAgJiYgIW4pIHtcbiAgICAgIGNvbnN0IGYgPSB0aGlzLl9fY2hhckJvdW5kc1tlXVtzIC0gMV07XG4gICAgICBkLmxlZnQgPSBmLmxlZnQgKyBmLndpZHRoICsgYy5rZXJuZWRXaWR0aCAtIGMud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9XG4gIGdldEhlaWdodE9mTGluZSh0KSB7XG4gICAgaWYgKHRoaXMuX19saW5lSGVpZ2h0c1t0XSkgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1t0XTtcbiAgICBsZXQgZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKHQsIDApO1xuICAgIGZvciAobGV0IHMgPSAxLCByID0gdGhpcy5fdGV4dExpbmVzW3RdLmxlbmd0aDsgcyA8IHI7IHMrKykgZSA9IE1hdGgubWF4KHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKHQsIHMpLCBlKTtcbiAgICByZXR1cm4gdGhpcy5fX2xpbmVIZWlnaHRzW3RdID0gZSAqIHRoaXMubGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplTXVsdDtcbiAgfVxuICBjYWxjVGV4dEhlaWdodCgpIHtcbiAgICBsZXQgdCwgZSA9IDA7XG4gICAgZm9yIChsZXQgcyA9IDAsIHIgPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBzIDwgcjsgcysrKSB0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUocyksIGUgKz0gcyA9PT0gciAtIDEgPyB0IC8gdGhpcy5saW5lSGVpZ2h0IDogdDtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBfZ2V0TGVmdE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09IFwibHRyXCIgPyAtdGhpcy53aWR0aCAvIDIgOiB0aGlzLndpZHRoIC8gMjtcbiAgfVxuICBfZ2V0VG9wT2Zmc2V0KCkge1xuICAgIHJldHVybiAtdGhpcy5oZWlnaHQgLyAyO1xuICB9XG4gIF9yZW5kZXJUZXh0Q29tbW9uKHQsIGUpIHtcbiAgICB0LnNhdmUoKTtcbiAgICBsZXQgcyA9IDA7XG4gICAgY29uc3QgciA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSwgbiA9IHRoaXMuX2dldFRvcE9mZnNldCgpO1xuICAgIGZvciAobGV0IG8gPSAwLCBhID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgbyA8IGE7IG8rKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKG8pLCBsID0gYyAvIHRoaXMubGluZUhlaWdodCwgaCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KG8pO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dExpbmUoZSwgdCwgdGhpcy5fdGV4dExpbmVzW29dLCByICsgaCwgbiArIHMgKyBsLCBvKSwgcyArPSBjO1xuICAgIH1cbiAgICB0LnJlc3RvcmUoKTtcbiAgfVxuICBfcmVuZGVyVGV4dEZpbGwodCkge1xuICAgICh0aGlzLmZpbGwgfHwgdGhpcy5zdHlsZUhhcyhydCkpICYmIHRoaXMuX3JlbmRlclRleHRDb21tb24odCwgXCJmaWxsVGV4dFwiKTtcbiAgfVxuICBfcmVuZGVyVGV4dFN0cm9rZSh0KSB7XG4gICAgKHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlV2lkdGggIT09IDAgfHwgIXRoaXMuaXNFbXB0eVN0eWxlcygpKSAmJiAodGhpcy5zaGFkb3cgJiYgIXRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSAmJiB0aGlzLl9yZW1vdmVTaGFkb3codCksIHQuc2F2ZSgpLCB0aGlzLl9zZXRMaW5lRGFzaCh0LCB0aGlzLnN0cm9rZURhc2hBcnJheSksIHQuYmVnaW5QYXRoKCksIHRoaXMuX3JlbmRlclRleHRDb21tb24odCwgXCJzdHJva2VUZXh0XCIpLCB0LmNsb3NlUGF0aCgpLCB0LnJlc3RvcmUoKSk7XG4gIH1cbiAgX3JlbmRlckNoYXJzKHQsIGUsIHMsIHIsIG4sIG8pIHtcbiAgICBjb25zdCBhID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUobyksIGMgPSB0aGlzLnRleHRBbGlnbi5pbmNsdWRlcyhIdCksIGwgPSB0aGlzLnBhdGgsIGggPSAhYyAmJiB0aGlzLmNoYXJTcGFjaW5nID09PSAwICYmIHRoaXMuaXNFbXB0eVN0eWxlcyhvKSAmJiAhbCwgdSA9IHRoaXMuZGlyZWN0aW9uID09PSBcImx0clwiLCBkID0gdGhpcy5kaXJlY3Rpb24gPT09IFwibHRyXCIgPyAxIDogLTEsIGYgPSBlLmRpcmVjdGlvbjtcbiAgICBsZXQgZywgcCwgbSwgYiwgUywgdyA9IFwiXCIsIGsgPSAwO1xuICAgIGlmIChlLnNhdmUoKSwgZiAhPT0gdGhpcy5kaXJlY3Rpb24gJiYgKGUuY2FudmFzLnNldEF0dHJpYnV0ZShcImRpclwiLCB1ID8gXCJsdHJcIiA6IFwicnRsXCIpLCBlLmRpcmVjdGlvbiA9IHUgPyBcImx0clwiIDogXCJydGxcIiwgZS50ZXh0QWxpZ24gPSB1ID8gTCA6IFopLCBuIC09IGEgKiB0aGlzLl9mb250U2l6ZUZyYWN0aW9uIC8gdGhpcy5saW5lSGVpZ2h0LCBoKSByZXR1cm4gdGhpcy5fcmVuZGVyQ2hhcih0LCBlLCBvLCAwLCBzLmpvaW4oXCJcIiksIHIsIG4pLCB2b2lkIGUucmVzdG9yZSgpO1xuICAgIGZvciAobGV0IE8gPSAwLCB4ID0gcy5sZW5ndGggLSAxOyBPIDw9IHg7IE8rKykgYiA9IE8gPT09IHggfHwgdGhpcy5jaGFyU3BhY2luZyB8fCBsLCB3ICs9IHNbT10sIG0gPSB0aGlzLl9fY2hhckJvdW5kc1tvXVtPXSwgayA9PT0gMCA/IChyICs9IGQgKiAobS5rZXJuZWRXaWR0aCAtIG0ud2lkdGgpLCBrICs9IG0ud2lkdGgpIDogayArPSBtLmtlcm5lZFdpZHRoLCBjICYmICFiICYmIHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChzW09dKSAmJiAoYiA9ICEwKSwgYiB8fCAoZyA9IGcgfHwgdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obywgTyksIHAgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihvLCBPICsgMSksIGIgPSB3aShnLCBwLCAhMSkpLCBiICYmIChsID8gKGUuc2F2ZSgpLCBlLnRyYW5zbGF0ZShtLnJlbmRlckxlZnQsIG0ucmVuZGVyVG9wKSwgZS5yb3RhdGUobS5hbmdsZSksIHRoaXMuX3JlbmRlckNoYXIodCwgZSwgbywgTywgdywgLWsgLyAyLCAwKSwgZS5yZXN0b3JlKCkpIDogKFMgPSByLCB0aGlzLl9yZW5kZXJDaGFyKHQsIGUsIG8sIE8sIHcsIFMsIG4pKSwgdyA9IFwiXCIsIGcgPSBwLCByICs9IGQgKiBrLCBrID0gMCk7XG4gICAgZS5yZXN0b3JlKCk7XG4gIH1cbiAgX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtVGV4dCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMud2lkdGggKyB0aGlzLnN0cm9rZVdpZHRoLCBzID0gdGhpcy5oZWlnaHQgKyB0aGlzLnN0cm9rZVdpZHRoLCByID0gV3QoeyB3aWR0aDogZSwgaGVpZ2h0OiBzIH0pLCBuID0gci5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgcmV0dXJuIHIud2lkdGggPSBlLCByLmhlaWdodCA9IHMsIG4uYmVnaW5QYXRoKCksIG4ubW92ZVRvKDAsIDApLCBuLmxpbmVUbyhlLCAwKSwgbi5saW5lVG8oZSwgcyksIG4ubGluZVRvKDAsIHMpLCBuLmNsb3NlUGF0aCgpLCBuLnRyYW5zbGF0ZShlIC8gMiwgcyAvIDIpLCBuLmZpbGxTdHlsZSA9IHQudG9MaXZlKG4pLCB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShuLCB0KSwgbi5maWxsKCksIG4uY3JlYXRlUGF0dGVybihyLCBcIm5vLXJlcGVhdFwiKTtcbiAgfVxuICBoYW5kbGVGaWxsZXIodCwgZSwgcykge1xuICAgIGxldCByLCBuO1xuICAgIHJldHVybiBDdChzKSA/IHMuZ3JhZGllbnRVbml0cyA9PT0gXCJwZXJjZW50YWdlXCIgfHwgcy5ncmFkaWVudFRyYW5zZm9ybSB8fCBzLnBhdHRlcm5UcmFuc2Zvcm0gPyAociA9IC10aGlzLndpZHRoIC8gMiwgbiA9IC10aGlzLmhlaWdodCAvIDIsIHQudHJhbnNsYXRlKHIsIG4pLCB0W2VdID0gdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm1UZXh0KHMpLCB7IG9mZnNldFg6IHIsIG9mZnNldFk6IG4gfSkgOiAodFtlXSA9IHMudG9MaXZlKHQpLCB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybSh0LCBzKSkgOiAodFtlXSA9IHMsIHsgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCB9KTtcbiAgfVxuICBfc2V0U3Ryb2tlU3R5bGVzKHQsIGUpIHtcbiAgICBsZXQgeyBzdHJva2U6IHMsIHN0cm9rZVdpZHRoOiByIH0gPSBlO1xuICAgIHJldHVybiB0LmxpbmVXaWR0aCA9IHIsIHQubGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcCwgdC5saW5lRGFzaE9mZnNldCA9IHRoaXMuc3Ryb2tlRGFzaE9mZnNldCwgdC5saW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW4sIHQubWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCwgdGhpcy5oYW5kbGVGaWxsZXIodCwgXCJzdHJva2VTdHlsZVwiLCBzKTtcbiAgfVxuICBfc2V0RmlsbFN0eWxlcyh0LCBlKSB7XG4gICAgbGV0IHsgZmlsbDogcyB9ID0gZTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVGaWxsZXIodCwgXCJmaWxsU3R5bGVcIiwgcyk7XG4gIH1cbiAgX3JlbmRlckNoYXIodCwgZSwgcywgciwgbiwgbywgYSkge1xuICAgIGNvbnN0IGMgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKHMsIHIpLCBsID0gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24ocywgciksIGggPSB0ID09PSBcImZpbGxUZXh0XCIgJiYgbC5maWxsLCB1ID0gdCA9PT0gXCJzdHJva2VUZXh0XCIgJiYgbC5zdHJva2UgJiYgbC5zdHJva2VXaWR0aDtcbiAgICBpZiAodSB8fCBoKSB7XG4gICAgICBpZiAoZS5zYXZlKCksIGUuZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihsKSwgYy50ZXh0QmFja2dyb3VuZENvbG9yICYmIHRoaXMuX3JlbW92ZVNoYWRvdyhlKSwgYy5kZWx0YVkgJiYgKGEgKz0gYy5kZWx0YVkpLCBoKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLl9zZXRGaWxsU3R5bGVzKGUsIGwpO1xuICAgICAgICBlLmZpbGxUZXh0KG4sIG8gLSBkLm9mZnNldFgsIGEgLSBkLm9mZnNldFkpO1xuICAgICAgfVxuICAgICAgaWYgKHUpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuX3NldFN0cm9rZVN0eWxlcyhlLCBsKTtcbiAgICAgICAgZS5zdHJva2VUZXh0KG4sIG8gLSBkLm9mZnNldFgsIGEgLSBkLm9mZnNldFkpO1xuICAgICAgfVxuICAgICAgZS5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIHNldFN1cGVyc2NyaXB0KHQsIGUpIHtcbiAgICB0aGlzLl9zZXRTY3JpcHQodCwgZSwgdGhpcy5zdXBlcnNjcmlwdCk7XG4gIH1cbiAgc2V0U3Vic2NyaXB0KHQsIGUpIHtcbiAgICB0aGlzLl9zZXRTY3JpcHQodCwgZSwgdGhpcy5zdWJzY3JpcHQpO1xuICB9XG4gIF9zZXRTY3JpcHQodCwgZSwgcykge1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24odCwgITApLCBuID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChyLmxpbmVJbmRleCwgci5jaGFySW5kZXgsIFwiZm9udFNpemVcIiksIG8gPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KHIubGluZUluZGV4LCByLmNoYXJJbmRleCwgXCJkZWx0YVlcIiksIGEgPSB7IGZvbnRTaXplOiBuICogcy5zaXplLCBkZWx0YVk6IG8gKyBuICogcy5iYXNlbGluZSB9O1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uU3R5bGVzKGEsIHQsIGUpO1xuICB9XG4gIF9nZXRMaW5lTGVmdE9mZnNldCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0TGluZVdpZHRoKHQpLCBzID0gdGhpcy53aWR0aCAtIGUsIHIgPSB0aGlzLnRleHRBbGlnbiwgbiA9IHRoaXMuZGlyZWN0aW9uLCBvID0gdGhpcy5pc0VuZE9mV3JhcHBpbmcodCk7XG4gICAgbGV0IGEgPSAwO1xuICAgIHJldHVybiByID09PSBIdCB8fCByID09PSBHcyAmJiAhbyB8fCByID09PSBWcyAmJiAhbyB8fCByID09PSBuaSAmJiAhbyA/IDAgOiAociA9PT0gaiAmJiAoYSA9IHMgLyAyKSwgciA9PT0gWiAmJiAoYSA9IHMpLCByID09PSBHcyAmJiAoYSA9IHMgLyAyKSwgciA9PT0gVnMgJiYgKGEgPSBzKSwgbiA9PT0gXCJydGxcIiAmJiAociA9PT0gWiB8fCByID09PSBIdCB8fCByID09PSBWcyA/IGEgPSAwIDogciA9PT0gTCB8fCByID09PSBuaSA/IGEgPSAtcyA6IHIgIT09IGogJiYgciAhPT0gR3MgfHwgKGEgPSAtcyAvIDIpKSwgYSk7XG4gIH1cbiAgX2NsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gITEsIHRoaXMuX19saW5lV2lkdGhzID0gW10sIHRoaXMuX19saW5lSGVpZ2h0cyA9IFtdLCB0aGlzLl9fY2hhckJvdW5kcyA9IFtdO1xuICB9XG4gIGdldExpbmVXaWR0aCh0KSB7XG4gICAgaWYgKHRoaXMuX19saW5lV2lkdGhzW3RdICE9PSB2b2lkIDApIHJldHVybiB0aGlzLl9fbGluZVdpZHRoc1t0XTtcbiAgICBjb25zdCB7IHdpZHRoOiBlIH0gPSB0aGlzLm1lYXN1cmVMaW5lKHQpO1xuICAgIHJldHVybiB0aGlzLl9fbGluZVdpZHRoc1t0XSA9IGUsIGU7XG4gIH1cbiAgX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFyU3BhY2luZyAhPT0gMCA/IHRoaXMuZm9udFNpemUgKiB0aGlzLmNoYXJTcGFjaW5nIC8gMWUzIDogMDtcbiAgfVxuICBnZXRWYWx1ZU9mUHJvcGVydHlBdCh0LCBlLCBzKSB7XG4gICAgdmFyIHI7XG4gICAgcmV0dXJuIChyID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbih0LCBlKVtzXSkgIT09IG51bGwgJiYgciAhPT0gdm9pZCAwID8gciA6IHRoaXNbc107XG4gIH1cbiAgX3JlbmRlclRleHREZWNvcmF0aW9uKHQsIGUpIHtcbiAgICBpZiAoIXRoaXNbZV0gJiYgIXRoaXMuc3R5bGVIYXMoZSkpIHJldHVybjtcbiAgICBsZXQgcyA9IHRoaXMuX2dldFRvcE9mZnNldCgpO1xuICAgIGNvbnN0IHIgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksIG4gPSB0aGlzLnBhdGgsIG8gPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKSwgYSA9IHRoaXMub2Zmc2V0c1tlXTtcbiAgICBmb3IgKGxldCBjID0gMCwgbCA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGMgPCBsOyBjKyspIHtcbiAgICAgIGNvbnN0IGggPSB0aGlzLmdldEhlaWdodE9mTGluZShjKTtcbiAgICAgIGlmICghdGhpc1tlXSAmJiAhdGhpcy5zdHlsZUhhcyhlLCBjKSkge1xuICAgICAgICBzICs9IGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdSA9IHRoaXMuX3RleHRMaW5lc1tjXSwgZCA9IGggLyB0aGlzLmxpbmVIZWlnaHQsIGYgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChjKTtcbiAgICAgIGxldCBnLCBwLCBtID0gMCwgYiA9IDAsIFMgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGMsIDAsIGUpLCB3ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChjLCAwLCBydCk7XG4gICAgICBjb25zdCBrID0gcyArIGQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pO1xuICAgICAgbGV0IE8gPSB0aGlzLmdldEhlaWdodE9mQ2hhcihjLCAwKSwgeCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoYywgMCwgXCJkZWx0YVlcIik7XG4gICAgICBmb3IgKGxldCBNID0gMCwgRSA9IHUubGVuZ3RoOyBNIDwgRTsgTSsrKSB7XG4gICAgICAgIGNvbnN0IFIgPSB0aGlzLl9fY2hhckJvdW5kc1tjXVtNXTtcbiAgICAgICAgZyA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoYywgTSwgZSksIHAgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGMsIE0sIHJ0KTtcbiAgICAgICAgY29uc3QgdHQgPSB0aGlzLmdldEhlaWdodE9mQ2hhcihjLCBNKSwgRiA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoYywgTSwgXCJkZWx0YVlcIik7XG4gICAgICAgIGlmIChuICYmIGcgJiYgcCkgdC5zYXZlKCksIHQuZmlsbFN0eWxlID0gdywgdC50cmFuc2xhdGUoUi5yZW5kZXJMZWZ0LCBSLnJlbmRlclRvcCksIHQucm90YXRlKFIuYW5nbGUpLCB0LmZpbGxSZWN0KC1SLmtlcm5lZFdpZHRoIC8gMiwgYSAqIHR0ICsgRiwgUi5rZXJuZWRXaWR0aCwgdGhpcy5mb250U2l6ZSAvIDE1KSwgdC5yZXN0b3JlKCk7XG4gICAgICAgIGVsc2UgaWYgKChnICE9PSBTIHx8IHAgIT09IHcgfHwgdHQgIT09IE8gfHwgRiAhPT0geCkgJiYgYiA+IDApIHtcbiAgICAgICAgICBsZXQgQiA9IHIgKyBmICsgbTtcbiAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9PT0gXCJydGxcIiAmJiAoQiA9IHRoaXMud2lkdGggLSBCIC0gYiksIFMgJiYgdyAmJiAodC5maWxsU3R5bGUgPSB3LCB0LmZpbGxSZWN0KEIsIGsgKyBhICogTyArIHgsIGIsIHRoaXMuZm9udFNpemUgLyAxNSkpLCBtID0gUi5sZWZ0LCBiID0gUi53aWR0aCwgUyA9IGcsIHcgPSBwLCBPID0gdHQsIHggPSBGO1xuICAgICAgICB9IGVsc2UgYiArPSBSLmtlcm5lZFdpZHRoO1xuICAgICAgfVxuICAgICAgbGV0IEkgPSByICsgZiArIG07XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9PT0gXCJydGxcIiAmJiAoSSA9IHRoaXMud2lkdGggLSBJIC0gYiksIHQuZmlsbFN0eWxlID0gcCwgZyAmJiBwICYmIHQuZmlsbFJlY3QoSSwgayArIGEgKiBPICsgeCwgYiAtIG8sIHRoaXMuZm9udFNpemUgLyAxNSksIHMgKz0gaDtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlU2hhZG93KHQpO1xuICB9XG4gIF9nZXRGb250RGVjbGFyYXRpb24oKSB7XG4gICAgbGV0IHsgZm9udEZhbWlseTogdCA9IHRoaXMuZm9udEZhbWlseSwgZm9udFN0eWxlOiBlID0gdGhpcy5mb250U3R5bGUsIGZvbnRXZWlnaHQ6IHMgPSB0aGlzLmZvbnRXZWlnaHQsIGZvbnRTaXplOiByID0gdGhpcy5mb250U2l6ZSB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fSwgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICAgIGNvbnN0IG8gPSB0LmluY2x1ZGVzKFwiJ1wiKSB8fCB0LmluY2x1ZGVzKCdcIicpIHx8IHQuaW5jbHVkZXMoXCIsXCIpIHx8IGN0LmdlbmVyaWNGb250cy5pbmNsdWRlcyh0LnRvTG93ZXJDYXNlKCkpID8gdCA6ICdcIicuY29uY2F0KHQsICdcIicpO1xuICAgIHJldHVybiBbZSwgcywgXCJcIi5jb25jYXQobiA/IHRoaXMuQ0FDSEVfRk9OVF9TSVpFIDogciwgXCJweFwiKSwgb10uam9pbihcIiBcIik7XG4gIH1cbiAgcmVuZGVyKHQpIHtcbiAgICB0aGlzLnZpc2libGUgJiYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnNraXBPZmZzY3JlZW4gJiYgIXRoaXMuZ3JvdXAgJiYgIXRoaXMuaXNPblNjcmVlbigpIHx8ICh0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgJiYgdGhpcy5pbml0RGltZW5zaW9ucygpLCBzdXBlci5yZW5kZXIodCkpKTtcbiAgfVxuICBncmFwaGVtZVNwbGl0KHQpIHtcbiAgICByZXR1cm4geGkodCk7XG4gIH1cbiAgX3NwbGl0VGV4dEludG9MaW5lcyh0KSB7XG4gICAgY29uc3QgZSA9IHQuc3BsaXQodGhpcy5fcmVOZXdsaW5lKSwgcyA9IG5ldyBBcnJheShlLmxlbmd0aCksIHIgPSBbYFxuYF07XG4gICAgbGV0IG4gPSBbXTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGUubGVuZ3RoOyBvKyspIHNbb10gPSB0aGlzLmdyYXBoZW1lU3BsaXQoZVtvXSksIG4gPSBuLmNvbmNhdChzW29dLCByKTtcbiAgICByZXR1cm4gbi5wb3AoKSwgeyBfdW53cmFwcGVkTGluZXM6IHMsIGxpbmVzOiBlLCBncmFwaGVtZVRleHQ6IG4sIGdyYXBoZW1lTGluZXM6IHMgfTtcbiAgfVxuICB0b09iamVjdCgpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgcmV0dXJuIHYodih7fSwgc3VwZXIudG9PYmplY3QoWy4uLmlsLCAuLi50XSkpLCB7fSwgeyBzdHlsZXM6IEVjKHRoaXMuc3R5bGVzLCB0aGlzLnRleHQpIH0sIHRoaXMucGF0aCA/IHsgcGF0aDogdGhpcy5wYXRoLnRvT2JqZWN0KCkgfSA6IHt9KTtcbiAgfVxuICBzZXQodCwgZSkge1xuICAgIGNvbnN0IHsgdGV4dExheW91dFByb3BlcnRpZXM6IHMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgc3VwZXIuc2V0KHQsIGUpO1xuICAgIGxldCByID0gITEsIG4gPSAhMTtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJvYmplY3RcIikgZm9yIChjb25zdCBvIGluIHQpIG8gPT09IFwicGF0aFwiICYmIHRoaXMuc2V0UGF0aEluZm8oKSwgciA9IHIgfHwgcy5pbmNsdWRlcyhvKSwgbiA9IG4gfHwgbyA9PT0gXCJwYXRoXCI7XG4gICAgZWxzZSByID0gcy5pbmNsdWRlcyh0KSwgbiA9IHQgPT09IFwicGF0aFwiO1xuICAgIHJldHVybiBuICYmIHRoaXMuc2V0UGF0aEluZm8oKSwgciAmJiB0aGlzLmluaXRpYWxpemVkICYmICh0aGlzLmluaXREaW1lbnNpb25zKCksIHRoaXMuc2V0Q29vcmRzKCkpLCB0aGlzO1xuICB9XG4gIGNvbXBsZXhpdHkoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21FbGVtZW50KHQsIGUsIHMpIHtcbiAgICBjb25zdCByID0gZmUodCwgY3QuQVRUUklCVVRFX05BTUVTLCBzKSwgbiA9IHYodih7fSwgZSksIHIpLCB7IHRleHRBbmNob3I6IG8gPSBMLCB0ZXh0RGVjb3JhdGlvbjogYSA9IFwiXCIsIGR4OiBjID0gMCwgZHk6IGwgPSAwLCB0b3A6IGggPSAwLCBsZWZ0OiB1ID0gMCwgZm9udFNpemU6IGQgPSBFbiwgc3Ryb2tlV2lkdGg6IGYgPSAxIH0gPSBuLCBnID0gRyhuLCBPZCksIHAgPSBuZXcgdGhpcygodC50ZXh0Q29udGVudCB8fCBcIlwiKS5yZXBsYWNlKC9eXFxzK3xcXHMrJHxcXG4rL2csIFwiXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpLCB2KHsgbGVmdDogdSArIGMsIHRvcDogaCArIGwsIHVuZGVybGluZTogYS5pbmNsdWRlcyhcInVuZGVybGluZVwiKSwgb3ZlcmxpbmU6IGEuaW5jbHVkZXMoXCJvdmVybGluZVwiKSwgbGluZXRocm91Z2g6IGEuaW5jbHVkZXMoXCJsaW5lLXRocm91Z2hcIiksIHN0cm9rZVdpZHRoOiAwLCBmb250U2l6ZTogZCB9LCBnKSksIG0gPSBwLmdldFNjYWxlZEhlaWdodCgpIC8gcC5oZWlnaHQsIGIgPSAoKHAuaGVpZ2h0ICsgcC5zdHJva2VXaWR0aCkgKiBwLmxpbmVIZWlnaHQgLSBwLmhlaWdodCkgKiBtLCBTID0gcC5nZXRTY2FsZWRIZWlnaHQoKSArIGI7XG4gICAgbGV0IHcgPSAwO1xuICAgIHJldHVybiBvID09PSBqICYmICh3ID0gcC5nZXRTY2FsZWRXaWR0aCgpIC8gMiksIG8gPT09IFogJiYgKHcgPSBwLmdldFNjYWxlZFdpZHRoKCkpLCBwLnNldCh7IGxlZnQ6IHAubGVmdCAtIHcsIHRvcDogcC50b3AgLSAoUyAtIHAuZm9udFNpemUgKiAoMC4wNyArIHAuX2ZvbnRTaXplRnJhY3Rpb24pKSAvIHAubGluZUhlaWdodCwgc3Ryb2tlV2lkdGg6IGYgfSksIHA7XG4gIH1cbiAgc3RhdGljIGZyb21PYmplY3QodCkge1xuICAgIHJldHVybiB0aGlzLl9mcm9tT2JqZWN0KHYodih7fSwgdCksIHt9LCB7IHN0eWxlczogUGModC5zdHlsZXMgfHwge30sIHQudGV4dCkgfSksIHsgZXh0cmFQYXJhbTogXCJ0ZXh0XCIgfSk7XG4gIH1cbn1cbnkoY3QsIFwidGV4dExheW91dFByb3BlcnRpZXNcIiwgcmwpLCB5KGN0LCBcImNhY2hlUHJvcGVydGllc1wiLCBbLi4uZGUsIC4uLmlsXSksIHkoY3QsIFwib3duRGVmYXVsdHNcIiwgeGQpLCB5KGN0LCBcInR5cGVcIiwgXCJUZXh0XCIpLCB5KGN0LCBcImdlbmVyaWNGb250c1wiLCBbXCJzZXJpZlwiLCBcInNhbnMtc2VyaWZcIiwgXCJtb25vc3BhY2VcIiwgXCJjdXJzaXZlXCIsIFwiZmFudGFzeVwiLCBcInN5c3RlbS11aVwiLCBcInVpLXNlcmlmXCIsIFwidWktc2Fucy1zZXJpZlwiLCBcInVpLW1vbm9zcGFjZVwiLCBcInVpLXJvdW5kZWRcIiwgXCJtYXRoXCIsIFwiZW1vamlcIiwgXCJmYW5nc29uZ1wiXSksIHkoY3QsIFwiQVRUUklCVVRFX05BTUVTXCIsIERlLmNvbmNhdChcInhcIiwgXCJ5XCIsIFwiZHhcIiwgXCJkeVwiLCBcImZvbnQtZmFtaWx5XCIsIFwiZm9udC1zdHlsZVwiLCBcImZvbnQtd2VpZ2h0XCIsIFwiZm9udC1zaXplXCIsIFwibGV0dGVyLXNwYWNpbmdcIiwgXCJ0ZXh0LWRlY29yYXRpb25cIiwgXCJ0ZXh0LWFuY2hvclwiKSksIGtjKGN0LCBbY2xhc3MgZXh0ZW5kcyBhYyB7XG4gIF90b1NWRygpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0U1ZHTGVmdFRvcE9mZnNldHMoKSwgdCA9IHRoaXMuX2dldFNWR1RleHRBbmRCZyhpLnRleHRUb3AsIGkudGV4dExlZnQpO1xuICAgIHJldHVybiB0aGlzLl93cmFwU1ZHVGV4dEFuZEJnKHQpO1xuICB9XG4gIHRvU1ZHKGkpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCh0aGlzLl90b1NWRygpLCB7IHJldml2ZXI6IGksIG5vU3R5bGU6ICEwLCB3aXRoU2hhZG93OiAhMCB9KTtcbiAgfVxuICBfZ2V0U1ZHTGVmdFRvcE9mZnNldHMoKSB7XG4gICAgcmV0dXJuIHsgdGV4dExlZnQ6IC10aGlzLndpZHRoIC8gMiwgdGV4dFRvcDogLXRoaXMuaGVpZ2h0IC8gMiwgbGluZVRvcDogdGhpcy5nZXRIZWlnaHRPZkxpbmUoMCkgfTtcbiAgfVxuICBfd3JhcFNWR1RleHRBbmRCZyhpKSB7XG4gICAgbGV0IHsgdGV4dEJnUmVjdHM6IHQsIHRleHRTcGFuczogZSB9ID0gaTtcbiAgICBjb25zdCBzID0gdGhpcy5nZXRTdmdUZXh0RGVjb3JhdGlvbih0aGlzKTtcbiAgICByZXR1cm4gW3Quam9pbihcIlwiKSwgJ1x0XHQ8dGV4dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiICcsIHRoaXMuZm9udEZhbWlseSA/ICdmb250LWZhbWlseT1cIicuY29uY2F0KHRoaXMuZm9udEZhbWlseS5yZXBsYWNlKENkLCBcIidcIiksICdcIiAnKSA6IFwiXCIsIHRoaXMuZm9udFNpemUgPyAnZm9udC1zaXplPVwiJy5jb25jYXQodGhpcy5mb250U2l6ZSwgJ1wiICcpIDogXCJcIiwgdGhpcy5mb250U3R5bGUgPyAnZm9udC1zdHlsZT1cIicuY29uY2F0KHRoaXMuZm9udFN0eWxlLCAnXCIgJykgOiBcIlwiLCB0aGlzLmZvbnRXZWlnaHQgPyAnZm9udC13ZWlnaHQ9XCInLmNvbmNhdCh0aGlzLmZvbnRXZWlnaHQsICdcIiAnKSA6IFwiXCIsIHMgPyAndGV4dC1kZWNvcmF0aW9uPVwiJy5jb25jYXQocywgJ1wiICcpIDogXCJcIiwgdGhpcy5kaXJlY3Rpb24gPT09IFwicnRsXCIgPyAnZGlyZWN0aW9uPVwiJy5jb25jYXQodGhpcy5kaXJlY3Rpb24sICdcIiAnKSA6IFwiXCIsICdzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCEwKSwgJ1wiJywgdGhpcy5hZGRQYWludE9yZGVyKCksIFwiID5cIiwgZS5qb2luKFwiXCIpLCBgPC90ZXh0PlxuYF07XG4gIH1cbiAgX2dldFNWR1RleHRBbmRCZyhpLCB0KSB7XG4gICAgY29uc3QgZSA9IFtdLCBzID0gW107XG4gICAgbGV0IHIsIG4gPSBpO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yICYmIHMucHVzaCguLi5WaSh0aGlzLmJhY2tncm91bmRDb2xvciwgLXRoaXMud2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkpO1xuICAgIGZvciAobGV0IG8gPSAwLCBhID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgbyA8IGE7IG8rKykgciA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KG8pLCB0aGlzLmRpcmVjdGlvbiA9PT0gXCJydGxcIiAmJiAociArPSB0aGlzLndpZHRoKSwgKHRoaXMudGV4dEJhY2tncm91bmRDb2xvciB8fCB0aGlzLnN0eWxlSGFzKFwidGV4dEJhY2tncm91bmRDb2xvclwiLCBvKSkgJiYgdGhpcy5fc2V0U1ZHVGV4dExpbmVCZyhzLCBvLCB0ICsgciwgbiksIHRoaXMuX3NldFNWR1RleHRMaW5lVGV4dChlLCBvLCB0ICsgciwgbiksIG4gKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUobyk7XG4gICAgcmV0dXJuIHsgdGV4dFNwYW5zOiBlLCB0ZXh0QmdSZWN0czogcyB9O1xuICB9XG4gIF9jcmVhdGVUZXh0Q2hhclNwYW4oaSwgdCwgZSwgcykge1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldFN2Z1NwYW5TdHlsZXModCwgaSAhPT0gaS50cmltKCkgfHwgISFpLm1hdGNoKHdkKSksIG4gPSByID8gJ3N0eWxlPVwiJy5jb25jYXQociwgJ1wiJykgOiBcIlwiLCBvID0gdC5kZWx0YVksIGEgPSBvID8gJyBkeT1cIicuY29uY2F0KFYobywgQS5OVU1fRlJBQ1RJT05fRElHSVRTKSwgJ1wiICcpIDogXCJcIjtcbiAgICByZXR1cm4gJzx0c3BhbiB4PVwiJy5jb25jYXQoVihlLCBBLk5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgeT1cIicpLmNvbmNhdChWKHMsIEEuTlVNX0ZSQUNUSU9OX0RJR0lUUyksICdcIiAnKS5jb25jYXQoYSkuY29uY2F0KG4sIFwiPlwiKS5jb25jYXQoamMoaSksIFwiPC90c3Bhbj5cIik7XG4gIH1cbiAgX3NldFNWR1RleHRMaW5lVGV4dChpLCB0LCBlLCBzKSB7XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKHQpLCBuID0gdGhpcy50ZXh0QWxpZ24uaW5jbHVkZXMoSHQpLCBvID0gdGhpcy5fdGV4dExpbmVzW3RdO1xuICAgIGxldCBhLCBjLCBsLCBoLCB1LCBkID0gXCJcIiwgZiA9IDA7XG4gICAgcyArPSByICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAvIHRoaXMubGluZUhlaWdodDtcbiAgICBmb3IgKGxldCBnID0gMCwgcCA9IG8ubGVuZ3RoIC0gMTsgZyA8PSBwOyBnKyspIHUgPSBnID09PSBwIHx8IHRoaXMuY2hhclNwYWNpbmcsIGQgKz0gb1tnXSwgbCA9IHRoaXMuX19jaGFyQm91bmRzW3RdW2ddLCBmID09PSAwID8gKGUgKz0gbC5rZXJuZWRXaWR0aCAtIGwud2lkdGgsIGYgKz0gbC53aWR0aCkgOiBmICs9IGwua2VybmVkV2lkdGgsIG4gJiYgIXUgJiYgdGhpcy5fcmVTcGFjZUFuZFRhYi50ZXN0KG9bZ10pICYmICh1ID0gITApLCB1IHx8IChhID0gYSB8fCB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbih0LCBnKSwgYyA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKHQsIGcgKyAxKSwgdSA9IHdpKGEsIGMsICEwKSksIHUgJiYgKGggPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKHQsIGcpLCBpLnB1c2godGhpcy5fY3JlYXRlVGV4dENoYXJTcGFuKGQsIGgsIGUsIHMpKSwgZCA9IFwiXCIsIGEgPSBjLCB0aGlzLmRpcmVjdGlvbiA9PT0gXCJydGxcIiA/IGUgLT0gZiA6IGUgKz0gZiwgZiA9IDApO1xuICB9XG4gIF9zZXRTVkdUZXh0TGluZUJnKGksIHQsIGUsIHMpIHtcbiAgICBjb25zdCByID0gdGhpcy5fdGV4dExpbmVzW3RdLCBuID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUodCkgLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgbGV0IG8sIGEgPSAwLCBjID0gMCwgbCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQodCwgMCwgXCJ0ZXh0QmFja2dyb3VuZENvbG9yXCIpO1xuICAgIGZvciAobGV0IGggPSAwOyBoIDwgci5sZW5ndGg7IGgrKykge1xuICAgICAgY29uc3QgeyBsZWZ0OiB1LCB3aWR0aDogZCwga2VybmVkV2lkdGg6IGYgfSA9IHRoaXMuX19jaGFyQm91bmRzW3RdW2hdO1xuICAgICAgbyA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQodCwgaCwgXCJ0ZXh0QmFja2dyb3VuZENvbG9yXCIpLCBvICE9PSBsID8gKGwgJiYgaS5wdXNoKC4uLlZpKGwsIGUgKyBjLCBzLCBhLCBuKSksIGMgPSB1LCBhID0gZCwgbCA9IG8pIDogYSArPSBmO1xuICAgIH1cbiAgICBvICYmIGkucHVzaCguLi5WaShsLCBlICsgYywgcywgYSwgbikpO1xuICB9XG4gIF9nZXRTVkdMaW5lVG9wT2Zmc2V0KGkpIHtcbiAgICBsZXQgdCwgZSA9IDA7XG4gICAgZm9yICh0ID0gMDsgdCA8IGk7IHQrKykgZSArPSB0aGlzLmdldEhlaWdodE9mTGluZSh0KTtcbiAgICBjb25zdCBzID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUodCk7XG4gICAgcmV0dXJuIHsgbGluZVRvcDogZSwgb2Zmc2V0OiAodGhpcy5fZm9udFNpemVNdWx0IC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiBzIC8gKHRoaXMubGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplTXVsdCkgfTtcbiAgfVxuICBnZXRTdmdTdHlsZXMoaSkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChzdXBlci5nZXRTdmdTdHlsZXMoaSksIFwiIHdoaXRlLXNwYWNlOiBwcmU7XCIpO1xuICB9XG4gIGdldFN2Z1NwYW5TdHlsZXMoaSwgdCkge1xuICAgIGNvbnN0IHsgZm9udEZhbWlseTogZSwgc3Ryb2tlV2lkdGg6IHMsIHN0cm9rZTogciwgZmlsbDogbiwgZm9udFNpemU6IG8sIGZvbnRTdHlsZTogYSwgZm9udFdlaWdodDogYywgZGVsdGFZOiBsIH0gPSBpLCBoID0gdGhpcy5nZXRTdmdUZXh0RGVjb3JhdGlvbihpKTtcbiAgICByZXR1cm4gW3IgPyBLcyhtdCwgcikgOiBcIlwiLCBzID8gXCJzdHJva2Utd2lkdGg6IFwiLmNvbmNhdChzLCBcIjsgXCIpIDogXCJcIiwgZSA/IFwiZm9udC1mYW1pbHk6IFwiLmNvbmNhdChlLmluY2x1ZGVzKFwiJ1wiKSB8fCBlLmluY2x1ZGVzKCdcIicpID8gZSA6IFwiJ1wiLmNvbmNhdChlLCBcIidcIiksIFwiOyBcIikgOiBcIlwiLCBvID8gXCJmb250LXNpemU6IFwiLmNvbmNhdChvLCBcInB4OyBcIikgOiBcIlwiLCBhID8gXCJmb250LXN0eWxlOiBcIi5jb25jYXQoYSwgXCI7IFwiKSA6IFwiXCIsIGMgPyBcImZvbnQtd2VpZ2h0OiBcIi5jb25jYXQoYywgXCI7IFwiKSA6IFwiXCIsIGggJiYgXCJ0ZXh0LWRlY29yYXRpb246IFwiLmNvbmNhdChoLCBcIjsgXCIpLCBuID8gS3MocnQsIG4pIDogXCJcIiwgbCA/IFwiYmFzZWxpbmUtc2hpZnQ6IFwiLmNvbmNhdCgtbCwgXCI7IFwiKSA6IFwiXCIsIHQgPyBcIndoaXRlLXNwYWNlOiBwcmU7IFwiIDogXCJcIl0uam9pbihcIlwiKTtcbiAgfVxuICBnZXRTdmdUZXh0RGVjb3JhdGlvbihpKSB7XG4gICAgcmV0dXJuIFtcIm92ZXJsaW5lXCIsIFwidW5kZXJsaW5lXCIsIFwibGluZS10aHJvdWdoXCJdLmZpbHRlcigodCkgPT4gaVt0LnJlcGxhY2UoXCItXCIsIFwiXCIpXSkuam9pbihcIiBcIik7XG4gIH1cbn1dKSwgQy5zZXRDbGFzcyhjdCksIEMuc2V0U1ZHQ2xhc3MoY3QpO1xuY2xhc3Mga2Qge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgeSh0aGlzLCBcInRhcmdldFwiLCB2b2lkIDApLCB5KHRoaXMsIFwiX19tb3VzZURvd25JblBsYWNlXCIsICExKSwgeSh0aGlzLCBcIl9fZHJhZ1N0YXJ0RmlyZWRcIiwgITEpLCB5KHRoaXMsIFwiX19pc0RyYWdnaW5nT3ZlclwiLCAhMSksIHkodGhpcywgXCJfX2RyYWdTdGFydFNlbGVjdGlvblwiLCB2b2lkIDApLCB5KHRoaXMsIFwiX19kcmFnSW1hZ2VEaXNwb3NlclwiLCB2b2lkIDApLCB5KHRoaXMsIFwiX2Rpc3Bvc2VcIiwgdm9pZCAwKSwgdGhpcy50YXJnZXQgPSB0O1xuICAgIGNvbnN0IGUgPSBbdGhpcy50YXJnZXQub24oXCJkcmFnZW50ZXJcIiwgdGhpcy5kcmFnRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpLCB0aGlzLnRhcmdldC5vbihcImRyYWdvdmVyXCIsIHRoaXMuZHJhZ092ZXJIYW5kbGVyLmJpbmQodGhpcykpLCB0aGlzLnRhcmdldC5vbihcImRyYWdsZWF2ZVwiLCB0aGlzLmRyYWdMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSksIHRoaXMudGFyZ2V0Lm9uKFwiZHJhZ2VuZFwiLCB0aGlzLmRyYWdFbmRIYW5kbGVyLmJpbmQodGhpcykpLCB0aGlzLnRhcmdldC5vbihcImRyb3BcIiwgdGhpcy5kcm9wSGFuZGxlci5iaW5kKHRoaXMpKV07XG4gICAgdGhpcy5fZGlzcG9zZSA9ICgpID0+IHtcbiAgICAgIGUuZm9yRWFjaCgocykgPT4gcygpKSwgdGhpcy5fZGlzcG9zZSA9IHZvaWQgMDtcbiAgICB9O1xuICB9XG4gIGlzUG9pbnRlck92ZXJTZWxlY3Rpb24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnRhcmdldCwgcyA9IGUuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcih0KTtcbiAgICByZXR1cm4gZS5pc0VkaXRpbmcgJiYgcyA+PSBlLnNlbGVjdGlvblN0YXJ0ICYmIHMgPD0gZS5zZWxlY3Rpb25FbmQgJiYgZS5zZWxlY3Rpb25TdGFydCA8IGUuc2VsZWN0aW9uRW5kO1xuICB9XG4gIHN0YXJ0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5fX21vdXNlRG93bkluUGxhY2UgPSB0aGlzLmlzUG9pbnRlck92ZXJTZWxlY3Rpb24odCk7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19tb3VzZURvd25JblBsYWNlO1xuICB9XG4gIGVuZCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaXNBY3RpdmUoKTtcbiAgICByZXR1cm4gZSAmJiAhdGhpcy5fX2RyYWdTdGFydEZpcmVkICYmICh0aGlzLnRhcmdldC5zZXRDdXJzb3JCeUNsaWNrKHQpLCB0aGlzLnRhcmdldC5pbml0RGVsYXllZEN1cnNvcighMCkpLCB0aGlzLl9fbW91c2VEb3duSW5QbGFjZSA9ICExLCB0aGlzLl9fZHJhZ1N0YXJ0RmlyZWQgPSAhMSwgdGhpcy5fX2lzRHJhZ2dpbmdPdmVyID0gITEsIGU7XG4gIH1cbiAgZ2V0RHJhZ1N0YXJ0U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fZHJhZ1N0YXJ0U2VsZWN0aW9uO1xuICB9XG4gIHNldERyYWdJbWFnZSh0LCBlKSB7XG4gICAgdmFyIHM7XG4gICAgbGV0IHsgc2VsZWN0aW9uU3RhcnQ6IHIsIHNlbGVjdGlvbkVuZDogbiB9ID0gZTtcbiAgICBjb25zdCBvID0gdGhpcy50YXJnZXQsIGEgPSBvLmNhbnZhcywgYyA9IG5ldyBfKG8uZmxpcFggPyAtMSA6IDEsIG8uZmxpcFkgPyAtMSA6IDEpLCBsID0gby5fZ2V0Q3Vyc29yQm91bmRhcmllcyhyKSwgaCA9IG5ldyBfKGwubGVmdCArIGwubGVmdE9mZnNldCwgbC50b3AgKyBsLnRvcE9mZnNldCkubXVsdGlwbHkoYykudHJhbnNmb3JtKG8uY2FsY1RyYW5zZm9ybU1hdHJpeCgpKSwgdSA9IGEuZ2V0U2NlbmVQb2ludCh0KS5zdWJ0cmFjdChoKSwgZCA9IG8uZ2V0Q2FudmFzUmV0aW5hU2NhbGluZygpLCBmID0gby5nZXRCb3VuZGluZ1JlY3QoKSwgZyA9IGguc3VidHJhY3QobmV3IF8oZi5sZWZ0LCBmLnRvcCkpLCBwID0gYS52aWV3cG9ydFRyYW5zZm9ybSwgbSA9IGcuYWRkKHUpLnRyYW5zZm9ybShwLCAhMCksIGIgPSBvLmJhY2tncm91bmRDb2xvciwgUyA9IEtuKG8uc3R5bGVzKTtcbiAgICBvLmJhY2tncm91bmRDb2xvciA9IFwiXCI7XG4gICAgY29uc3QgdyA9IHsgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIGZpbGw6IFwidHJhbnNwYXJlbnRcIiwgdGV4dEJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiIH07XG4gICAgby5zZXRTZWxlY3Rpb25TdHlsZXModywgMCwgciksIG8uc2V0U2VsZWN0aW9uU3R5bGVzKHcsIG4sIG8udGV4dC5sZW5ndGgpLCBvLmRpcnR5ID0gITA7XG4gICAgY29uc3QgayA9IG8udG9DYW52YXNFbGVtZW50KHsgZW5hYmxlUmV0aW5hU2NhbGluZzogYS5lbmFibGVSZXRpbmFTY2FsaW5nLCB2aWV3cG9ydFRyYW5zZm9ybTogITAgfSk7XG4gICAgby5iYWNrZ3JvdW5kQ29sb3IgPSBiLCBvLnN0eWxlcyA9IFMsIG8uZGlydHkgPSAhMCwgaWkoaywgeyBwb3NpdGlvbjogXCJmaXhlZFwiLCBsZWZ0OiBcIlwiLmNvbmNhdCgtay53aWR0aCwgXCJweFwiKSwgYm9yZGVyOiBwdCwgd2lkdGg6IFwiXCIuY29uY2F0KGsud2lkdGggLyBkLCBcInB4XCIpLCBoZWlnaHQ6IFwiXCIuY29uY2F0KGsuaGVpZ2h0IC8gZCwgXCJweFwiKSB9KSwgdGhpcy5fX2RyYWdJbWFnZURpc3Bvc2VyICYmIHRoaXMuX19kcmFnSW1hZ2VEaXNwb3NlcigpLCB0aGlzLl9fZHJhZ0ltYWdlRGlzcG9zZXIgPSAoKSA9PiB7XG4gICAgICBrLnJlbW92ZSgpO1xuICAgIH0sIEF0KHQudGFyZ2V0IHx8IHRoaXMudGFyZ2V0LmhpZGRlblRleHRhcmVhKS5ib2R5LmFwcGVuZENoaWxkKGspLCAocyA9IHQuZGF0YVRyYW5zZmVyKSA9PT0gbnVsbCB8fCBzID09PSB2b2lkIDAgfHwgcy5zZXREcmFnSW1hZ2UoaywgbS54LCBtLnkpO1xuICB9XG4gIG9uRHJhZ1N0YXJ0KHQpIHtcbiAgICB0aGlzLl9fZHJhZ1N0YXJ0RmlyZWQgPSAhMDtcbiAgICBjb25zdCBlID0gdGhpcy50YXJnZXQsIHMgPSB0aGlzLmlzQWN0aXZlKCk7XG4gICAgaWYgKHMgJiYgdC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9fZHJhZ1N0YXJ0U2VsZWN0aW9uID0geyBzZWxlY3Rpb25TdGFydDogZS5zZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kOiBlLnNlbGVjdGlvbkVuZCB9LCBuID0gZS5fdGV4dC5zbGljZShyLnNlbGVjdGlvblN0YXJ0LCByLnNlbGVjdGlvbkVuZCkuam9pbihcIlwiKSwgbyA9IHYoeyB0ZXh0OiBlLnRleHQsIHZhbHVlOiBuIH0sIHIpO1xuICAgICAgdC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgbiksIHQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJhcHBsaWNhdGlvbi9mYWJyaWNcIiwgSlNPTi5zdHJpbmdpZnkoeyB2YWx1ZTogbiwgc3R5bGVzOiBlLmdldFNlbGVjdGlvblN0eWxlcyhyLnNlbGVjdGlvblN0YXJ0LCByLnNlbGVjdGlvbkVuZCwgITApIH0pKSwgdC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIiwgdGhpcy5zZXREcmFnSW1hZ2UodCwgbyk7XG4gICAgfVxuICAgIHJldHVybiBlLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCksIHM7XG4gIH1cbiAgY2FuRHJvcCh0KSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0LmVkaXRhYmxlICYmICF0aGlzLnRhcmdldC5nZXRBY3RpdmVDb250cm9sKCkgJiYgIXQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSAmJiB0aGlzLl9fZHJhZ1N0YXJ0U2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLnRhcmdldC5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKHQpLCBzID0gdGhpcy5fX2RyYWdTdGFydFNlbGVjdGlvbjtcbiAgICAgICAgcmV0dXJuIGUgPCBzLnNlbGVjdGlvblN0YXJ0IHx8IGUgPiBzLnNlbGVjdGlvbkVuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHRhcmdldENhbkRyb3AodCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldC5jYW5Ecm9wKHQpO1xuICB9XG4gIGRyYWdFbnRlckhhbmRsZXIodCkge1xuICAgIGxldCB7IGUgfSA9IHQ7XG4gICAgY29uc3QgcyA9IHRoaXMudGFyZ2V0Q2FuRHJvcChlKTtcbiAgICAhdGhpcy5fX2lzRHJhZ2dpbmdPdmVyICYmIHMgJiYgKHRoaXMuX19pc0RyYWdnaW5nT3ZlciA9ICEwKTtcbiAgfVxuICBkcmFnT3ZlckhhbmRsZXIodCkge1xuICAgIGNvbnN0IHsgZSB9ID0gdCwgcyA9IHRoaXMudGFyZ2V0Q2FuRHJvcChlKTtcbiAgICAhdGhpcy5fX2lzRHJhZ2dpbmdPdmVyICYmIHMgPyB0aGlzLl9faXNEcmFnZ2luZ092ZXIgPSAhMCA6IHRoaXMuX19pc0RyYWdnaW5nT3ZlciAmJiAhcyAmJiAodGhpcy5fX2lzRHJhZ2dpbmdPdmVyID0gITEpLCB0aGlzLl9faXNEcmFnZ2luZ092ZXIgJiYgKGUucHJldmVudERlZmF1bHQoKSwgdC5jYW5Ecm9wID0gITAsIHQuZHJvcFRhcmdldCA9IHRoaXMudGFyZ2V0KTtcbiAgfVxuICBkcmFnTGVhdmVIYW5kbGVyKCkge1xuICAgICh0aGlzLl9faXNEcmFnZ2luZ092ZXIgfHwgdGhpcy5pc0FjdGl2ZSgpKSAmJiAodGhpcy5fX2lzRHJhZ2dpbmdPdmVyID0gITEpO1xuICB9XG4gIGRyb3BIYW5kbGVyKHQpIHtcbiAgICB2YXIgZTtcbiAgICBjb25zdCB7IGU6IHMgfSA9IHQsIHIgPSBzLmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgdGhpcy5fX2lzRHJhZ2dpbmdPdmVyID0gITEsIHMucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgbiA9IChlID0gcy5kYXRhVHJhbnNmZXIpID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgaWYgKG4gJiYgIXIpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLnRhcmdldCwgYSA9IG8uY2FudmFzO1xuICAgICAgbGV0IGMgPSBvLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIocyk7XG4gICAgICBjb25zdCB7IHN0eWxlczogbCB9ID0gcy5kYXRhVHJhbnNmZXIudHlwZXMuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9mYWJyaWNcIikgPyBKU09OLnBhcnNlKHMuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJhcHBsaWNhdGlvbi9mYWJyaWNcIikpIDoge30sIGggPSBuW01hdGgubWF4KDAsIG4ubGVuZ3RoIC0gMSldLCB1ID0gMDtcbiAgICAgIGlmICh0aGlzLl9fZHJhZ1N0YXJ0U2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLl9fZHJhZ1N0YXJ0U2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0LCBmID0gdGhpcy5fX2RyYWdTdGFydFNlbGVjdGlvbi5zZWxlY3Rpb25FbmQ7XG4gICAgICAgIGMgPiBkICYmIGMgPD0gZiA/IGMgPSBkIDogYyA+IGYgJiYgKGMgLT0gZiAtIGQpLCBvLnJlbW92ZUNoYXJzKGQsIGYpLCBkZWxldGUgdGhpcy5fX2RyYWdTdGFydFNlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIG8uX3JlTmV3bGluZS50ZXN0KGgpICYmIChvLl9yZU5ld2xpbmUudGVzdChvLl90ZXh0W2NdKSB8fCBjID09PSBvLl90ZXh0Lmxlbmd0aCkgJiYgKG4gPSBuLnRyaW1FbmQoKSksIHQuZGlkRHJvcCA9ICEwLCB0LmRyb3BUYXJnZXQgPSBvLCBvLmluc2VydENoYXJzKG4sIGwsIGMpLCBhLnNldEFjdGl2ZU9iamVjdChvKSwgby5lbnRlckVkaXRpbmcocyksIG8uc2VsZWN0aW9uU3RhcnQgPSBNYXRoLm1pbihjICsgdSwgby5fdGV4dC5sZW5ndGgpLCBvLnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKG8uc2VsZWN0aW9uU3RhcnQgKyBuLmxlbmd0aCwgby5fdGV4dC5sZW5ndGgpLCBvLmhpZGRlblRleHRhcmVhLnZhbHVlID0gby50ZXh0LCBvLl91cGRhdGVUZXh0YXJlYSgpLCBvLmhpZGRlblRleHRhcmVhLmZvY3VzKCksIG8uZmlyZShVciwgeyBpbmRleDogYyArIHUsIGFjdGlvbjogXCJkcm9wXCIgfSksIGEuZmlyZShcInRleHQ6Y2hhbmdlZFwiLCB7IHRhcmdldDogbyB9KSwgYS5jb250ZXh0VG9wRGlydHkgPSAhMCwgYS5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfVxuICB9XG4gIGRyYWdFbmRIYW5kbGVyKHQpIHtcbiAgICBsZXQgeyBlIH0gPSB0O1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkgJiYgdGhpcy5fX2RyYWdTdGFydEZpcmVkICYmIHRoaXMuX19kcmFnU3RhcnRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBzO1xuICAgICAgY29uc3QgciA9IHRoaXMudGFyZ2V0LCBuID0gdGhpcy50YXJnZXQuY2FudmFzLCB7IHNlbGVjdGlvblN0YXJ0OiBvLCBzZWxlY3Rpb25FbmQ6IGEgfSA9IHRoaXMuX19kcmFnU3RhcnRTZWxlY3Rpb24sIGMgPSAoKHMgPSBlLmRhdGFUcmFuc2ZlcikgPT09IG51bGwgfHwgcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcy5kcm9wRWZmZWN0KSB8fCBwdDtcbiAgICAgIGMgPT09IHB0ID8gKHIuc2VsZWN0aW9uU3RhcnQgPSBvLCByLnNlbGVjdGlvbkVuZCA9IGEsIHIuX3VwZGF0ZVRleHRhcmVhKCksIHIuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKSkgOiAoci5jbGVhckNvbnRleHRUb3AoKSwgYyA9PT0gXCJtb3ZlXCIgJiYgKHIucmVtb3ZlQ2hhcnMobywgYSksIHIuc2VsZWN0aW9uU3RhcnQgPSByLnNlbGVjdGlvbkVuZCA9IG8sIHIuaGlkZGVuVGV4dGFyZWEgJiYgKHIuaGlkZGVuVGV4dGFyZWEudmFsdWUgPSByLnRleHQpLCByLl91cGRhdGVUZXh0YXJlYSgpLCByLmZpcmUoVXIsIHsgaW5kZXg6IG8sIGFjdGlvbjogXCJkcmFnZW5kXCIgfSksIG4uZmlyZShcInRleHQ6Y2hhbmdlZFwiLCB7IHRhcmdldDogciB9KSwgbi5yZXF1ZXN0UmVuZGVyQWxsKCkpLCByLmV4aXRFZGl0aW5nKCkpO1xuICAgIH1cbiAgICB0aGlzLl9fZHJhZ0ltYWdlRGlzcG9zZXIgJiYgdGhpcy5fX2RyYWdJbWFnZURpc3Bvc2VyKCksIGRlbGV0ZSB0aGlzLl9fZHJhZ0ltYWdlRGlzcG9zZXIsIGRlbGV0ZSB0aGlzLl9fZHJhZ1N0YXJ0U2VsZWN0aW9uLCB0aGlzLl9faXNEcmFnZ2luZ092ZXIgPSAhMTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2Rpc3Bvc2UgJiYgdGhpcy5fZGlzcG9zZSgpO1xuICB9XG59XG5jb25zdCBIbyA9IC9bIFxcblxcLiw7IVxcP1xcLV0vO1xuY2xhc3MgTWQgZXh0ZW5kcyBjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHkodGhpcywgXCJfY3VycmVudEN1cnNvck9wYWNpdHlcIiwgMSk7XG4gIH1cbiAgaW5pdEJlaGF2aW9yKCkge1xuICAgIHRoaXMuX3RpY2sgPSB0aGlzLl90aWNrLmJpbmQodGhpcyksIHRoaXMuX29uVGlja0NvbXBsZXRlID0gdGhpcy5fb25UaWNrQ29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy51cGRhdGVTZWxlY3Rpb25Pbk1vdXNlTW92ZSA9IHRoaXMudXBkYXRlU2VsZWN0aW9uT25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgfVxuICBvbkRlc2VsZWN0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5leGl0RWRpdGluZygpLCB0aGlzLnNlbGVjdGVkID0gITEsIHN1cGVyLm9uRGVzZWxlY3QodCk7XG4gIH1cbiAgX2FuaW1hdGVDdXJzb3IodCkge1xuICAgIGxldCB7IHRvVmFsdWU6IGUsIGR1cmF0aW9uOiBzLCBkZWxheTogciwgb25Db21wbGV0ZTogbiB9ID0gdDtcbiAgICByZXR1cm4gVW4oeyBzdGFydFZhbHVlOiB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSwgZW5kVmFsdWU6IGUsIGR1cmF0aW9uOiBzLCBkZWxheTogciwgb25Db21wbGV0ZTogbiwgYWJvcnQ6ICgpID0+ICF0aGlzLmNhbnZhcyB8fCB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCwgb25DaGFuZ2U6IChvKSA9PiB7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IG8sIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9IH0pO1xuICB9XG4gIF90aWNrKHQpIHtcbiAgICB0aGlzLl9jdXJyZW50VGlja1N0YXRlID0gdGhpcy5fYW5pbWF0ZUN1cnNvcih7IHRvVmFsdWU6IDAsIGR1cmF0aW9uOiB0aGlzLmN1cnNvckR1cmF0aW9uIC8gMiwgZGVsYXk6IE1hdGgubWF4KHQgfHwgMCwgMTAwKSwgb25Db21wbGV0ZTogdGhpcy5fb25UaWNrQ29tcGxldGUgfSk7XG4gIH1cbiAgX29uVGlja0NvbXBsZXRlKCkge1xuICAgIHZhciB0O1xuICAgICh0ID0gdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgfHwgdC5hYm9ydCgpLCB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgPSB0aGlzLl9hbmltYXRlQ3Vyc29yKHsgdG9WYWx1ZTogMSwgZHVyYXRpb246IHRoaXMuY3Vyc29yRHVyYXRpb24sIG9uQ29tcGxldGU6IHRoaXMuX3RpY2sgfSk7XG4gIH1cbiAgaW5pdERlbGF5ZWRDdXJzb3IodCkge1xuICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKSwgdGhpcy5fdGljayh0ID8gMCA6IHRoaXMuY3Vyc29yRGVsYXkpO1xuICB9XG4gIGFib3J0Q3Vyc29yQW5pbWF0aW9uKCkge1xuICAgIGxldCB0ID0gITE7XG4gICAgW3RoaXMuX2N1cnJlbnRUaWNrU3RhdGUsIHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZV0uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZSAmJiAhZS5pc0RvbmUoKSAmJiAodCA9ICEwLCBlLmFib3J0KCkpO1xuICAgIH0pLCB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDEsIHQgJiYgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgfVxuICByZXN0YXJ0Q3Vyc29ySWZOZWVkZWQoKSB7XG4gICAgW3RoaXMuX2N1cnJlbnRUaWNrU3RhdGUsIHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZV0uc29tZSgodCkgPT4gIXQgfHwgdC5pc0RvbmUoKSkgJiYgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICB9XG4gIHNlbGVjdEFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TdGFydCA9IDAsIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5fdGV4dC5sZW5ndGgsIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCksIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCksIHRoaXM7XG4gIH1cbiAgZ2V0U2VsZWN0ZWRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0LnNsaWNlKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kKS5qb2luKFwiXCIpO1xuICB9XG4gIGZpbmRXb3JkQm91bmRhcnlMZWZ0KHQpIHtcbiAgICBsZXQgZSA9IDAsIHMgPSB0IC0gMTtcbiAgICBpZiAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbc10pKSBmb3IgKDsgdGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbc10pOyApIGUrKywgcy0tO1xuICAgIGZvciAoOyAvXFxTLy50ZXN0KHRoaXMuX3RleHRbc10pICYmIHMgPiAtMTsgKSBlKyssIHMtLTtcbiAgICByZXR1cm4gdCAtIGU7XG4gIH1cbiAgZmluZFdvcmRCb3VuZGFyeVJpZ2h0KHQpIHtcbiAgICBsZXQgZSA9IDAsIHMgPSB0O1xuICAgIGlmICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtzXSkpIGZvciAoOyB0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtzXSk7ICkgZSsrLCBzKys7XG4gICAgZm9yICg7IC9cXFMvLnRlc3QodGhpcy5fdGV4dFtzXSkgJiYgcyA8IHRoaXMuX3RleHQubGVuZ3RoOyApIGUrKywgcysrO1xuICAgIHJldHVybiB0ICsgZTtcbiAgfVxuICBmaW5kTGluZUJvdW5kYXJ5TGVmdCh0KSB7XG4gICAgbGV0IGUgPSAwLCBzID0gdCAtIDE7XG4gICAgZm9yICg7ICEvXFxuLy50ZXN0KHRoaXMuX3RleHRbc10pICYmIHMgPiAtMTsgKSBlKyssIHMtLTtcbiAgICByZXR1cm4gdCAtIGU7XG4gIH1cbiAgZmluZExpbmVCb3VuZGFyeVJpZ2h0KHQpIHtcbiAgICBsZXQgZSA9IDAsIHMgPSB0O1xuICAgIGZvciAoOyAhL1xcbi8udGVzdCh0aGlzLl90ZXh0W3NdKSAmJiBzIDwgdGhpcy5fdGV4dC5sZW5ndGg7ICkgZSsrLCBzKys7XG4gICAgcmV0dXJuIHQgKyBlO1xuICB9XG4gIHNlYXJjaFdvcmRCb3VuZGFyeSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuX3RleHQ7XG4gICAgbGV0IHIgPSB0ID4gMCAmJiB0aGlzLl9yZVNwYWNlLnRlc3Qoc1t0XSkgJiYgKGUgPT09IC0xIHx8ICFQbi50ZXN0KHNbdCAtIDFdKSkgPyB0IC0gMSA6IHQsIG4gPSBzW3JdO1xuICAgIGZvciAoOyByID4gMCAmJiByIDwgcy5sZW5ndGggJiYgIUhvLnRlc3Qobik7ICkgciArPSBlLCBuID0gc1tyXTtcbiAgICByZXR1cm4gZSA9PT0gLTEgJiYgSG8udGVzdChuKSAmJiByKyssIHI7XG4gIH1cbiAgc2VsZWN0V29yZCh0KSB7XG4gICAgdCA9IHQgfHwgdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICBjb25zdCBlID0gdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkodCwgLTEpLCBzID0gTWF0aC5tYXgoZSwgdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkodCwgMSkpO1xuICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBlLCB0aGlzLnNlbGVjdGlvbkVuZCA9IHMsIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCksIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCksIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgfVxuICBzZWxlY3RMaW5lKHQpIHtcbiAgICB0ID0gdCB8fCB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIGNvbnN0IGUgPSB0aGlzLmZpbmRMaW5lQm91bmRhcnlMZWZ0KHQpLCBzID0gdGhpcy5maW5kTGluZUJvdW5kYXJ5UmlnaHQodCk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBlLCB0aGlzLnNlbGVjdGlvbkVuZCA9IHMsIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCksIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCksIHRoaXM7XG4gIH1cbiAgZW50ZXJFZGl0aW5nKHQpIHtcbiAgICAhdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5lZGl0YWJsZSAmJiAodGhpcy5lbnRlckVkaXRpbmdJbXBsKCksIHRoaXMuZmlyZShcImVkaXRpbmc6ZW50ZXJlZFwiLCB0ID8geyBlOiB0IH0gOiB2b2lkIDApLCB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpLCB0aGlzLmNhbnZhcyAmJiAodGhpcy5jYW52YXMuZmlyZShcInRleHQ6ZWRpdGluZzplbnRlcmVkXCIsIHsgdGFyZ2V0OiB0aGlzLCBlOiB0IH0pLCB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCkpKTtcbiAgfVxuICBlbnRlckVkaXRpbmdJbXBsKCkge1xuICAgIHRoaXMuY2FudmFzICYmICh0aGlzLmNhbnZhcy5jYWxjT2Zmc2V0KCksIHRoaXMuY2FudmFzLnRleHRFZGl0aW5nTWFuYWdlci5leGl0VGV4dEVkaXRpbmcoKSksIHRoaXMuaXNFZGl0aW5nID0gITAsIHRoaXMuaW5pdEhpZGRlblRleHRhcmVhKCksIHRoaXMuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKSwgdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSA9IHRoaXMudGV4dCwgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKSwgdGhpcy5fc2F2ZUVkaXRpbmdQcm9wcygpLCB0aGlzLl9zZXRFZGl0aW5nUHJvcHMoKSwgdGhpcy5fdGV4dEJlZm9yZUVkaXQgPSB0aGlzLnRleHQsIHRoaXMuX3RpY2soKTtcbiAgfVxuICB1cGRhdGVTZWxlY3Rpb25Pbk1vdXNlTW92ZSh0KSB7XG4gICAgaWYgKHRoaXMuZ2V0QWN0aXZlQ29udHJvbCgpKSByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuaGlkZGVuVGV4dGFyZWE7XG4gICAgQXQoZSkuYWN0aXZlRWxlbWVudCAhPT0gZSAmJiBlLmZvY3VzKCk7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcih0KSwgciA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsIG4gPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICAocyA9PT0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24gJiYgciAhPT0gbiB8fCByICE9PSBzICYmIG4gIT09IHMpICYmIChzID4gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24gPyAodGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duLCB0aGlzLnNlbGVjdGlvbkVuZCA9IHMpIDogKHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBzLCB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duKSwgdGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gciAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gbiB8fCAodGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKSwgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKSwgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpKSk7XG4gIH1cbiAgX3NldEVkaXRpbmdQcm9wcygpIHtcbiAgICB0aGlzLmhvdmVyQ3Vyc29yID0gXCJ0ZXh0XCIsIHRoaXMuY2FudmFzICYmICh0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5jYW52YXMubW92ZUN1cnNvciA9IFwidGV4dFwiKSwgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuZWRpdGluZ0JvcmRlckNvbG9yLCB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5zZWxlY3RhYmxlID0gITEsIHRoaXMubG9ja01vdmVtZW50WCA9IHRoaXMubG9ja01vdmVtZW50WSA9ICEwO1xuICB9XG4gIGZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uKHQsIGUsIHMpIHtcbiAgICBjb25zdCByID0gcy5zbGljZSgwLCB0KSwgbiA9IHRoaXMuZ3JhcGhlbWVTcGxpdChyKS5sZW5ndGg7XG4gICAgaWYgKHQgPT09IGUpIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBuLCBzZWxlY3Rpb25FbmQ6IG4gfTtcbiAgICBjb25zdCBvID0gcy5zbGljZSh0LCBlKTtcbiAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogbiwgc2VsZWN0aW9uRW5kOiBuICsgdGhpcy5ncmFwaGVtZVNwbGl0KG8pLmxlbmd0aCB9O1xuICB9XG4gIGZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uKHQsIGUsIHMpIHtcbiAgICBjb25zdCByID0gcy5zbGljZSgwLCB0KS5qb2luKFwiXCIpLmxlbmd0aDtcbiAgICByZXR1cm4gdCA9PT0gZSA/IHsgc2VsZWN0aW9uU3RhcnQ6IHIsIHNlbGVjdGlvbkVuZDogciB9IDogeyBzZWxlY3Rpb25TdGFydDogciwgc2VsZWN0aW9uRW5kOiByICsgcy5zbGljZSh0LCBlKS5qb2luKFwiXCIpLmxlbmd0aCB9O1xuICB9XG4gIF91cGRhdGVUZXh0YXJlYSgpIHtcbiAgICBpZiAodGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IHt9LCB0aGlzLmhpZGRlblRleHRhcmVhKSB7XG4gICAgICBpZiAoIXRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuZnJvbUdyYXBoZW1lVG9TdHJpbmdTZWxlY3Rpb24odGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIHRoaXMuX3RleHQpO1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0ID0gdC5zZWxlY3Rpb25TdGFydCwgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQgPSB0LnNlbGVjdGlvbkVuZDtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVGcm9tVGV4dEFyZWEoKSB7XG4gICAgaWYgKCF0aGlzLmhpZGRlblRleHRhcmVhKSByZXR1cm47XG4gICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IHt9O1xuICAgIGNvbnN0IHQgPSB0aGlzLmhpZGRlblRleHRhcmVhO1xuICAgIHRoaXMudGV4dCA9IHQudmFsdWUsIHRoaXMuc2V0KFwiZGlydHlcIiwgITApLCB0aGlzLmluaXREaW1lbnNpb25zKCksIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgY29uc3QgZSA9IHRoaXMuZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24odC5zZWxlY3Rpb25TdGFydCwgdC5zZWxlY3Rpb25FbmQsIHQudmFsdWUpO1xuICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydCA9IGUuc2VsZWN0aW9uRW5kLCB0aGlzLmluQ29tcG9zaXRpb25Nb2RlIHx8ICh0aGlzLnNlbGVjdGlvblN0YXJ0ID0gZS5zZWxlY3Rpb25TdGFydCksIHRoaXMudXBkYXRlVGV4dGFyZWFQb3NpdGlvbigpO1xuICB9XG4gIHVwZGF0ZVRleHRhcmVhUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUubGVmdCA9IHQubGVmdCwgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS50b3AgPSB0LnRvcDtcbiAgICB9XG4gIH1cbiAgX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCkge1xuICAgIGlmICghdGhpcy5jYW52YXMpIHJldHVybiB7IGxlZnQ6IFwiMXB4XCIsIHRvcDogXCIxcHhcIiB9O1xuICAgIGNvbnN0IHQgPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5jb21wb3NpdGlvblN0YXJ0IDogdGhpcy5zZWxlY3Rpb25TdGFydCwgZSA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXModCksIHMgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24odCksIHIgPSBzLmxpbmVJbmRleCwgbiA9IHMuY2hhckluZGV4LCBvID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChyLCBuLCBcImZvbnRTaXplXCIpICogdGhpcy5saW5lSGVpZ2h0LCBhID0gZS5sZWZ0T2Zmc2V0LCBjID0gdGhpcy5nZXRDYW52YXNSZXRpbmFTY2FsaW5nKCksIGwgPSB0aGlzLmNhbnZhcy51cHBlckNhbnZhc0VsLCBoID0gbC53aWR0aCAvIGMsIHUgPSBsLmhlaWdodCAvIGMsIGQgPSBoIC0gbywgZiA9IHUgLSBvLCBnID0gbmV3IF8oZS5sZWZ0ICsgYSwgZS50b3AgKyBlLnRvcE9mZnNldCArIG8pLnRyYW5zZm9ybSh0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSkudHJhbnNmb3JtKHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtKS5tdWx0aXBseShuZXcgXyhsLmNsaWVudFdpZHRoIC8gaCwgbC5jbGllbnRIZWlnaHQgLyB1KSk7XG4gICAgcmV0dXJuIGcueCA8IDAgJiYgKGcueCA9IDApLCBnLnggPiBkICYmIChnLnggPSBkKSwgZy55IDwgMCAmJiAoZy55ID0gMCksIGcueSA+IGYgJiYgKGcueSA9IGYpLCBnLnggKz0gdGhpcy5jYW52YXMuX29mZnNldC5sZWZ0LCBnLnkgKz0gdGhpcy5jYW52YXMuX29mZnNldC50b3AsIHsgbGVmdDogXCJcIi5jb25jYXQoZy54LCBcInB4XCIpLCB0b3A6IFwiXCIuY29uY2F0KGcueSwgXCJweFwiKSwgZm9udFNpemU6IFwiXCIuY29uY2F0KG8sIFwicHhcIiksIGNoYXJIZWlnaHQ6IG8gfTtcbiAgfVxuICBfc2F2ZUVkaXRpbmdQcm9wcygpIHtcbiAgICB0aGlzLl9zYXZlZFByb3BzID0geyBoYXNDb250cm9sczogdGhpcy5oYXNDb250cm9scywgYm9yZGVyQ29sb3I6IHRoaXMuYm9yZGVyQ29sb3IsIGxvY2tNb3ZlbWVudFg6IHRoaXMubG9ja01vdmVtZW50WCwgbG9ja01vdmVtZW50WTogdGhpcy5sb2NrTW92ZW1lbnRZLCBob3ZlckN1cnNvcjogdGhpcy5ob3ZlckN1cnNvciwgc2VsZWN0YWJsZTogdGhpcy5zZWxlY3RhYmxlLCBkZWZhdWx0Q3Vyc29yOiB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yLCBtb3ZlQ3Vyc29yOiB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yIH07XG4gIH1cbiAgX3Jlc3RvcmVFZGl0aW5nUHJvcHMoKSB7XG4gICAgdGhpcy5fc2F2ZWRQcm9wcyAmJiAodGhpcy5ob3ZlckN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuaG92ZXJDdXJzb3IsIHRoaXMuaGFzQ29udHJvbHMgPSB0aGlzLl9zYXZlZFByb3BzLmhhc0NvbnRyb2xzLCB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy5fc2F2ZWRQcm9wcy5ib3JkZXJDb2xvciwgdGhpcy5zZWxlY3RhYmxlID0gdGhpcy5fc2F2ZWRQcm9wcy5zZWxlY3RhYmxlLCB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFgsIHRoaXMubG9ja01vdmVtZW50WSA9IHRoaXMuX3NhdmVkUHJvcHMubG9ja01vdmVtZW50WSwgdGhpcy5jYW52YXMgJiYgKHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IgPSB0aGlzLl9zYXZlZFByb3BzLmRlZmF1bHRDdXJzb3IgfHwgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvciwgdGhpcy5jYW52YXMubW92ZUN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMubW92ZUN1cnNvciB8fCB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yKSwgZGVsZXRlIHRoaXMuX3NhdmVkUHJvcHMpO1xuICB9XG4gIF9leGl0RWRpdGluZygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5oaWRkZW5UZXh0YXJlYTtcbiAgICB0aGlzLnNlbGVjdGVkID0gITEsIHRoaXMuaXNFZGl0aW5nID0gITEsIHQgJiYgKHQuYmx1ciAmJiB0LmJsdXIoKSwgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSksIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBudWxsLCB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCksIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kICYmIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gIH1cbiAgZXhpdEVkaXRpbmdJbXBsKCkge1xuICAgIHRoaXMuX2V4aXRFZGl0aW5nKCksIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5fcmVzdG9yZUVkaXRpbmdQcm9wcygpLCB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgJiYgKHRoaXMuaW5pdERpbWVuc2lvbnMoKSwgdGhpcy5zZXRDb29yZHMoKSk7XG4gIH1cbiAgZXhpdEVkaXRpbmcoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RleHRCZWZvcmVFZGl0ICE9PSB0aGlzLnRleHQ7XG4gICAgcmV0dXJuIHRoaXMuZXhpdEVkaXRpbmdJbXBsKCksIHRoaXMuZmlyZShcImVkaXRpbmc6ZXhpdGVkXCIpLCB0ICYmIHRoaXMuZmlyZSgkciksIHRoaXMuY2FudmFzICYmICh0aGlzLmNhbnZhcy5maXJlKFwidGV4dDplZGl0aW5nOmV4aXRlZFwiLCB7IHRhcmdldDogdGhpcyB9KSwgdCAmJiB0aGlzLmNhbnZhcy5maXJlKFwib2JqZWN0Om1vZGlmaWVkXCIsIHsgdGFyZ2V0OiB0aGlzIH0pKSwgdGhpcztcbiAgfVxuICBfcmVtb3ZlRXh0cmFuZW91c1N0eWxlcygpIHtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5zdHlsZXMpIHRoaXMuX3RleHRMaW5lc1t0XSB8fCBkZWxldGUgdGhpcy5zdHlsZXNbdF07XG4gIH1cbiAgcmVtb3ZlU3R5bGVGcm9tVG8odCwgZSkge1xuICAgIGNvbnN0IHsgbGluZUluZGV4OiBzLCBjaGFySW5kZXg6IHIgfSA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbih0LCAhMCksIHsgbGluZUluZGV4OiBuLCBjaGFySW5kZXg6IG8gfSA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihlLCAhMCk7XG4gICAgaWYgKHMgIT09IG4pIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlc1tzXSkgZm9yIChsZXQgYSA9IHI7IGEgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbc10ubGVuZ3RoOyBhKyspIGRlbGV0ZSB0aGlzLnN0eWxlc1tzXVthXTtcbiAgICAgIGlmICh0aGlzLnN0eWxlc1tuXSkgZm9yIChsZXQgYSA9IG87IGEgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbl0ubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuc3R5bGVzW25dW2FdO1xuICAgICAgICBjICYmICh0aGlzLnN0eWxlc1tzXSB8fCAodGhpcy5zdHlsZXNbc10gPSB7fSksIHRoaXMuc3R5bGVzW3NdW3IgKyBhIC0gb10gPSBjKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGEgPSBzICsgMTsgYSA8PSBuOyBhKyspIGRlbGV0ZSB0aGlzLnN0eWxlc1thXTtcbiAgICAgIHRoaXMuc2hpZnRMaW5lU3R5bGVzKG4sIHMgLSBuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3R5bGVzW3NdKSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5zdHlsZXNbc10sIGMgPSBvIC0gcjtcbiAgICAgIGZvciAobGV0IGwgPSByOyBsIDwgbzsgbCsrKSBkZWxldGUgYVtsXTtcbiAgICAgIGZvciAoY29uc3QgbCBpbiB0aGlzLnN0eWxlc1tzXSkge1xuICAgICAgICBjb25zdCBoID0gcGFyc2VJbnQobCwgMTApO1xuICAgICAgICBoID49IG8gJiYgKGFbaCAtIGNdID0gYVtsXSwgZGVsZXRlIGFbbF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaGlmdExpbmVTdHlsZXModCwgZSkge1xuICAgIGNvbnN0IHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0eWxlcyk7XG4gICAgZm9yIChjb25zdCByIGluIHRoaXMuc3R5bGVzKSB7XG4gICAgICBjb25zdCBuID0gcGFyc2VJbnQociwgMTApO1xuICAgICAgbiA+IHQgJiYgKHRoaXMuc3R5bGVzW24gKyBlXSA9IHNbbl0sIHNbbiAtIGVdIHx8IGRlbGV0ZSB0aGlzLnN0eWxlc1tuXSk7XG4gICAgfVxuICB9XG4gIGluc2VydE5ld2xpbmVTdHlsZU9iamVjdCh0LCBlLCBzLCByKSB7XG4gICAgY29uc3QgbiA9IHt9LCBvID0gdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzW3RdLmxlbmd0aCwgYSA9IG8gPT09IGU7XG4gICAgbGV0IGMgPSAhMTtcbiAgICBzIHx8IChzID0gMSksIHRoaXMuc2hpZnRMaW5lU3R5bGVzKHQsIHMpO1xuICAgIGNvbnN0IGwgPSB0aGlzLnN0eWxlc1t0XSA/IHRoaXMuc3R5bGVzW3RdW2UgPT09IDAgPyBlIDogZSAtIDFdIDogdm9pZCAwO1xuICAgIGZvciAoY29uc3QgdSBpbiB0aGlzLnN0eWxlc1t0XSkge1xuICAgICAgY29uc3QgZCA9IHBhcnNlSW50KHUsIDEwKTtcbiAgICAgIGQgPj0gZSAmJiAoYyA9ICEwLCBuW2QgLSBlXSA9IHRoaXMuc3R5bGVzW3RdW3VdLCBhICYmIGUgPT09IDAgfHwgZGVsZXRlIHRoaXMuc3R5bGVzW3RdW3VdKTtcbiAgICB9XG4gICAgbGV0IGggPSAhMTtcbiAgICBmb3IgKGMgJiYgIWEgJiYgKHRoaXMuc3R5bGVzW3QgKyBzXSA9IG4sIGggPSAhMCksIChoIHx8IG8gPiBlKSAmJiBzLS07IHMgPiAwOyApIHIgJiYgcltzIC0gMV0gPyB0aGlzLnN0eWxlc1t0ICsgc10gPSB7IDA6IHYoe30sIHJbcyAtIDFdKSB9IDogbCA/IHRoaXMuc3R5bGVzW3QgKyBzXSA9IHsgMDogdih7fSwgbCkgfSA6IGRlbGV0ZSB0aGlzLnN0eWxlc1t0ICsgc10sIHMtLTtcbiAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSAhMDtcbiAgfVxuICBpbnNlcnRDaGFyU3R5bGVPYmplY3QodCwgZSwgcywgcikge1xuICAgIHRoaXMuc3R5bGVzIHx8ICh0aGlzLnN0eWxlcyA9IHt9KTtcbiAgICBjb25zdCBuID0gdGhpcy5zdHlsZXNbdF0sIG8gPSBuID8gdih7fSwgbikgOiB7fTtcbiAgICBzIHx8IChzID0gMSk7XG4gICAgZm9yIChjb25zdCBjIGluIG8pIHtcbiAgICAgIGNvbnN0IGwgPSBwYXJzZUludChjLCAxMCk7XG4gICAgICBsID49IGUgJiYgKG5bbCArIHNdID0gb1tsXSwgb1tsIC0gc10gfHwgZGVsZXRlIG5bbF0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZm9yY2VDbGVhckNhY2hlID0gITAsIHIpIHtcbiAgICAgIGZvciAoOyBzLS07ICkgT2JqZWN0LmtleXMocltzXSkubGVuZ3RoICYmICh0aGlzLnN0eWxlc1t0XSB8fCAodGhpcy5zdHlsZXNbdF0gPSB7fSksIHRoaXMuc3R5bGVzW3RdW2UgKyBzXSA9IHYoe30sIHJbc10pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFuKSByZXR1cm47XG4gICAgY29uc3QgYSA9IG5bZSA/IGUgLSAxIDogMV07XG4gICAgZm9yICg7IGEgJiYgcy0tOyApIHRoaXMuc3R5bGVzW3RdW2UgKyBzXSA9IHYoe30sIGEpO1xuICB9XG4gIGluc2VydE5ld1N0eWxlQmxvY2sodCwgZSwgcykge1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oZSwgITApLCBuID0gWzBdO1xuICAgIGxldCBvLCBhID0gMDtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IHQubGVuZ3RoOyBjKyspIHRbY10gPT09IGBcbmAgPyAoYSsrLCBuW2FdID0gMCkgOiBuW2FdKys7XG4gICAgZm9yIChuWzBdID4gMCAmJiAodGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3Qoci5saW5lSW5kZXgsIHIuY2hhckluZGV4LCBuWzBdLCBzKSwgcyA9IHMgJiYgcy5zbGljZShuWzBdICsgMSkpLCBhICYmIHRoaXMuaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0KHIubGluZUluZGV4LCByLmNoYXJJbmRleCArIG5bMF0sIGEpLCBvID0gMTsgbyA8IGE7IG8rKykgbltvXSA+IDAgPyB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChyLmxpbmVJbmRleCArIG8sIDAsIG5bb10sIHMpIDogcyAmJiB0aGlzLnN0eWxlc1tyLmxpbmVJbmRleCArIG9dICYmIHNbMF0gJiYgKHRoaXMuc3R5bGVzW3IubGluZUluZGV4ICsgb11bMF0gPSBzWzBdKSwgcyA9IHMgJiYgcy5zbGljZShuW29dICsgMSk7XG4gICAgbltvXSA+IDAgJiYgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3Qoci5saW5lSW5kZXggKyBvLCAwLCBuW29dLCBzKTtcbiAgfVxuICByZW1vdmVDaGFycyh0KSB7XG4gICAgbGV0IGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHQgKyAxO1xuICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8odCwgZSksIHRoaXMuX3RleHQuc3BsaWNlKHQsIGUgLSB0KSwgdGhpcy50ZXh0ID0gdGhpcy5fdGV4dC5qb2luKFwiXCIpLCB0aGlzLnNldChcImRpcnR5XCIsICEwKSwgdGhpcy5pbml0RGltZW5zaW9ucygpLCB0aGlzLnNldENvb3JkcygpLCB0aGlzLl9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzKCk7XG4gIH1cbiAgaW5zZXJ0Q2hhcnModCwgZSwgcykge1xuICAgIGxldCByID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbM10gOiBzO1xuICAgIHIgPiBzICYmIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8ocywgcik7XG4gICAgY29uc3QgbiA9IHRoaXMuZ3JhcGhlbWVTcGxpdCh0KTtcbiAgICB0aGlzLmluc2VydE5ld1N0eWxlQmxvY2sobiwgcywgZSksIHRoaXMuX3RleHQgPSBbLi4udGhpcy5fdGV4dC5zbGljZSgwLCBzKSwgLi4ubiwgLi4udGhpcy5fdGV4dC5zbGljZShyKV0sIHRoaXMudGV4dCA9IHRoaXMuX3RleHQuam9pbihcIlwiKSwgdGhpcy5zZXQoXCJkaXJ0eVwiLCAhMCksIHRoaXMuaW5pdERpbWVuc2lvbnMoKSwgdGhpcy5zZXRDb29yZHMoKSwgdGhpcy5fcmVtb3ZlRXh0cmFuZW91c1N0eWxlcygpO1xuICB9XG4gIHNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHQsIGUsIHMpIHtcbiAgICBzIDw9IHQgPyAoZSA9PT0gdCA/IHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9IEwgOiB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09IFogJiYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9IEwsIHRoaXMuc2VsZWN0aW9uRW5kID0gdCksIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBzKSA6IHMgPiB0ICYmIHMgPCBlID8gdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSBaID8gdGhpcy5zZWxlY3Rpb25FbmQgPSBzIDogdGhpcy5zZWxlY3Rpb25TdGFydCA9IHMgOiAoZSA9PT0gdCA/IHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9IFogOiB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09IEwgJiYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9IFosIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBlKSwgdGhpcy5zZWxlY3Rpb25FbmQgPSBzKTtcbiAgfVxufVxuY2xhc3MgSWQgZXh0ZW5kcyBNZCB7XG4gIGluaXRIaWRkZW5UZXh0YXJlYSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jYW52YXMgJiYgQXQodGhpcy5jYW52YXMuZ2V0RWxlbWVudCgpKSB8fCBDcygpLCBlID0gdC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgT2JqZWN0LmVudHJpZXMoeyBhdXRvY2FwaXRhbGl6ZTogXCJvZmZcIiwgYXV0b2NvcnJlY3Q6IFwib2ZmXCIsIGF1dG9jb21wbGV0ZTogXCJvZmZcIiwgc3BlbGxjaGVjazogXCJmYWxzZVwiLCBcImRhdGEtZmFicmljXCI6IFwidGV4dGFyZWFcIiwgd3JhcDogXCJvZmZcIiB9KS5tYXAoKG8pID0+IHtcbiAgICAgIGxldCBbYSwgY10gPSBvO1xuICAgICAgcmV0dXJuIGUuc2V0QXR0cmlidXRlKGEsIGMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgdG9wOiBzLCBsZWZ0OiByLCBmb250U2l6ZTogbiB9ID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICBlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiBcIi5jb25jYXQocywgXCI7IGxlZnQ6IFwiKS5jb25jYXQociwgXCI7IHotaW5kZXg6IC05OTk7IG9wYWNpdHk6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMXB4OyBmb250LXNpemU6IDFweDsgcGFkZGluZy10b3A6IFwiKS5jb25jYXQobiwgXCI7XCIpLCAodGhpcy5oaWRkZW5UZXh0YXJlYUNvbnRhaW5lciB8fCB0LmJvZHkpLmFwcGVuZENoaWxkKGUpLCBPYmplY3QuZW50cmllcyh7IGJsdXI6IFwiYmx1clwiLCBrZXlkb3duOiBcIm9uS2V5RG93blwiLCBrZXl1cDogXCJvbktleVVwXCIsIGlucHV0OiBcIm9uSW5wdXRcIiwgY29weTogXCJjb3B5XCIsIGN1dDogXCJjb3B5XCIsIHBhc3RlOiBcInBhc3RlXCIsIGNvbXBvc2l0aW9uc3RhcnQ6IFwib25Db21wb3NpdGlvblN0YXJ0XCIsIGNvbXBvc2l0aW9udXBkYXRlOiBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIiwgY29tcG9zaXRpb25lbmQ6IFwib25Db21wb3NpdGlvbkVuZFwiIH0pLm1hcCgobykgPT4ge1xuICAgICAgbGV0IFthLCBjXSA9IG87XG4gICAgICByZXR1cm4gZS5hZGRFdmVudExpc3RlbmVyKGEsIHRoaXNbY10uYmluZCh0aGlzKSk7XG4gICAgfSksIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBlO1xuICB9XG4gIGJsdXIoKSB7XG4gICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICB9XG4gIG9uS2V5RG93bih0KSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLmRpcmVjdGlvbiA9PT0gXCJydGxcIiA/IHRoaXMua2V5c01hcFJ0bCA6IHRoaXMua2V5c01hcDtcbiAgICBpZiAodC5rZXlDb2RlIGluIGUpIHRoaXNbZVt0LmtleUNvZGVdXSh0KTtcbiAgICBlbHNlIHtcbiAgICAgIGlmICghKHQua2V5Q29kZSBpbiB0aGlzLmN0cmxLZXlzTWFwRG93bikgfHwgIXQuY3RybEtleSAmJiAhdC5tZXRhS2V5KSByZXR1cm47XG4gICAgICB0aGlzW3RoaXMuY3RybEtleXNNYXBEb3duW3Qua2V5Q29kZV1dKHQpO1xuICAgIH1cbiAgICB0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCB0LnByZXZlbnREZWZhdWx0KCksIHQua2V5Q29kZSA+PSAzMyAmJiB0LmtleUNvZGUgPD0gNDAgPyAodGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA9ICExLCB0aGlzLmNsZWFyQ29udGV4dFRvcCgpLCB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCkpIDogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9XG4gIG9uS2V5VXAodCkge1xuICAgICF0aGlzLmlzRWRpdGluZyB8fCB0aGlzLl9jb3B5RG9uZSB8fCB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5fY29weURvbmUgPSAhMSA6IHQua2V5Q29kZSBpbiB0aGlzLmN0cmxLZXlzTWFwVXAgJiYgKHQuY3RybEtleSB8fCB0Lm1ldGFLZXkpICYmICh0aGlzW3RoaXMuY3RybEtleXNNYXBVcFt0LmtleUNvZGVdXSh0KSwgdC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCkpO1xuICB9XG4gIG9uSW5wdXQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmZyb21QYXN0ZTtcbiAgICBpZiAodGhpcy5mcm9tUGFzdGUgPSAhMSwgdCAmJiB0LnN0b3BQcm9wYWdhdGlvbigpLCAhdGhpcy5pc0VkaXRpbmcpIHJldHVybjtcbiAgICBjb25zdCBzID0gKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVGcm9tVGV4dEFyZWEoKSwgdGhpcy5maXJlKFVyKSwgdGhpcy5jYW52YXMgJiYgKHRoaXMuY2FudmFzLmZpcmUoXCJ0ZXh0OmNoYW5nZWRcIiwgeyB0YXJnZXQ6IHRoaXMgfSksIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKSk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSA9PT0gXCJcIikgcmV0dXJuIHRoaXMuc3R5bGVzID0ge30sIHZvaWQgcygpO1xuICAgIGNvbnN0IHIgPSB0aGlzLl9zcGxpdFRleHRJbnRvTGluZXModGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSkuZ3JhcGhlbWVUZXh0LCBuID0gdGhpcy5fdGV4dC5sZW5ndGgsIG8gPSByLmxlbmd0aCwgYSA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsIGMgPSB0aGlzLnNlbGVjdGlvbkVuZCwgbCA9IGEgIT09IGM7XG4gICAgbGV0IGgsIHUsIGQsIGYsIGcgPSBvIC0gbjtcbiAgICBjb25zdCBwID0gdGhpcy5mcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbih0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0LCB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCwgdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSksIG0gPSBhID4gcC5zZWxlY3Rpb25TdGFydDtcbiAgICBsID8gKHUgPSB0aGlzLl90ZXh0LnNsaWNlKGEsIGMpLCBnICs9IGMgLSBhKSA6IG8gPCBuICYmICh1ID0gbSA/IHRoaXMuX3RleHQuc2xpY2UoYyArIGcsIGMpIDogdGhpcy5fdGV4dC5zbGljZShhLCBhIC0gZykpO1xuICAgIGNvbnN0IGIgPSByLnNsaWNlKHAuc2VsZWN0aW9uRW5kIC0gZywgcC5zZWxlY3Rpb25FbmQpO1xuICAgIGlmICh1ICYmIHUubGVuZ3RoICYmIChiLmxlbmd0aCAmJiAoaCA9IHRoaXMuZ2V0U2VsZWN0aW9uU3R5bGVzKGEsIGEgKyAxLCAhMSksIGggPSBiLm1hcCgoKSA9PiBoWzBdKSksIGwgPyAoZCA9IGEsIGYgPSBjKSA6IG0gPyAoZCA9IGMgLSB1Lmxlbmd0aCwgZiA9IGMpIDogKGQgPSBjLCBmID0gYyArIHUubGVuZ3RoKSwgdGhpcy5yZW1vdmVTdHlsZUZyb21UbyhkLCBmKSksIGIubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7IGNvcHlQYXN0ZURhdGE6IFMgfSA9ICR0KCk7XG4gICAgICBlICYmIGIuam9pbihcIlwiKSA9PT0gUy5jb3BpZWRUZXh0ICYmICFBLmRpc2FibGVTdHlsZUNvcHlQYXN0ZSAmJiAoaCA9IFMuY29waWVkVGV4dFN0eWxlKSwgdGhpcy5pbnNlcnROZXdTdHlsZUJsb2NrKGIsIGEsIGgpO1xuICAgIH1cbiAgICBzKCk7XG4gIH1cbiAgb25Db21wb3NpdGlvblN0YXJ0KCkge1xuICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSAhMDtcbiAgfVxuICBvbkNvbXBvc2l0aW9uRW5kKCkge1xuICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSAhMTtcbiAgfVxuICBvbkNvbXBvc2l0aW9uVXBkYXRlKHQpIHtcbiAgICBsZXQgeyB0YXJnZXQ6IGUgfSA9IHQ7XG4gICAgY29uc3QgeyBzZWxlY3Rpb25TdGFydDogcywgc2VsZWN0aW9uRW5kOiByIH0gPSBlO1xuICAgIHRoaXMuY29tcG9zaXRpb25TdGFydCA9IHMsIHRoaXMuY29tcG9zaXRpb25FbmQgPSByLCB0aGlzLnVwZGF0ZVRleHRhcmVhUG9zaXRpb24oKTtcbiAgfVxuICBjb3B5KCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgY29weVBhc3RlRGF0YTogdCB9ID0gJHQoKTtcbiAgICB0LmNvcGllZFRleHQgPSB0aGlzLmdldFNlbGVjdGVkVGV4dCgpLCBBLmRpc2FibGVTdHlsZUNvcHlQYXN0ZSA/IHQuY29waWVkVGV4dFN0eWxlID0gdm9pZCAwIDogdC5jb3BpZWRUZXh0U3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlcyh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgITApLCB0aGlzLl9jb3B5RG9uZSA9ICEwO1xuICB9XG4gIHBhc3RlKCkge1xuICAgIHRoaXMuZnJvbVBhc3RlID0gITA7XG4gIH1cbiAgX2dldFdpZHRoQmVmb3JlQ3Vyc29yKHQsIGUpIHtcbiAgICBsZXQgcywgciA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHQpO1xuICAgIHJldHVybiBlID4gMCAmJiAocyA9IHRoaXMuX19jaGFyQm91bmRzW3RdW2UgLSAxXSwgciArPSBzLmxlZnQgKyBzLndpZHRoKSwgcjtcbiAgfVxuICBnZXREb3duQ3Vyc29yT2Zmc2V0KHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0KHQsIGUpLCByID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHMpLCBuID0gci5saW5lSW5kZXg7XG4gICAgaWYgKG4gPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxIHx8IHQubWV0YUtleSB8fCB0LmtleUNvZGUgPT09IDM0KSByZXR1cm4gdGhpcy5fdGV4dC5sZW5ndGggLSBzO1xuICAgIGNvbnN0IG8gPSByLmNoYXJJbmRleCwgYSA9IHRoaXMuX2dldFdpZHRoQmVmb3JlQ3Vyc29yKG4sIG8pLCBjID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobiArIDEsIGEpO1xuICAgIHJldHVybiB0aGlzLl90ZXh0TGluZXNbbl0uc2xpY2UobykubGVuZ3RoICsgYyArIDEgKyB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KG4pO1xuICB9XG4gIF9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQodCwgZSkge1xuICAgIHJldHVybiB0LnNoaWZ0S2V5ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kICYmIGUgPyB0aGlzLnNlbGVjdGlvbkVuZCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gIH1cbiAgZ2V0VXBDdXJzb3JPZmZzZXQodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLl9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQodCwgZSksIHIgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24ocyksIG4gPSByLmxpbmVJbmRleDtcbiAgICBpZiAobiA9PT0gMCB8fCB0Lm1ldGFLZXkgfHwgdC5rZXlDb2RlID09PSAzMykgcmV0dXJuIC1zO1xuICAgIGNvbnN0IG8gPSByLmNoYXJJbmRleCwgYSA9IHRoaXMuX2dldFdpZHRoQmVmb3JlQ3Vyc29yKG4sIG8pLCBjID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobiAtIDEsIGEpLCBsID0gdGhpcy5fdGV4dExpbmVzW25dLnNsaWNlKDAsIG8pLCBoID0gdGhpcy5taXNzaW5nTmV3bGluZU9mZnNldChuIC0gMSk7XG4gICAgcmV0dXJuIC10aGlzLl90ZXh0TGluZXNbbiAtIDFdLmxlbmd0aCArIGMgLSBsLmxlbmd0aCArICgxIC0gaCk7XG4gIH1cbiAgX2dldEluZGV4T25MaW5lKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fdGV4dExpbmVzW3RdO1xuICAgIGxldCByLCBuLCBvID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQodCksIGEgPSAwO1xuICAgIGZvciAobGV0IGMgPSAwLCBsID0gcy5sZW5ndGg7IGMgPCBsOyBjKyspIGlmIChyID0gdGhpcy5fX2NoYXJCb3VuZHNbdF1bY10ud2lkdGgsIG8gKz0gciwgbyA+IGUpIHtcbiAgICAgIG4gPSAhMDtcbiAgICAgIGNvbnN0IGggPSBvIC0gciwgdSA9IG8sIGQgPSBNYXRoLmFicyhoIC0gZSk7XG4gICAgICBhID0gTWF0aC5hYnModSAtIGUpIDwgZCA/IGMgOiBjIC0gMTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbiB8fCAoYSA9IHMubGVuZ3RoIC0gMSksIGE7XG4gIH1cbiAgbW92ZUN1cnNvckRvd24odCkge1xuICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPj0gdGhpcy5fdGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy5fdGV4dC5sZW5ndGggfHwgdGhpcy5fbW92ZUN1cnNvclVwT3JEb3duKFwiRG93blwiLCB0KTtcbiAgfVxuICBtb3ZlQ3Vyc29yVXAodCkge1xuICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGhpcy5zZWxlY3Rpb25FbmQgPT09IDAgfHwgdGhpcy5fbW92ZUN1cnNvclVwT3JEb3duKFwiVXBcIiwgdCk7XG4gIH1cbiAgX21vdmVDdXJzb3JVcE9yRG93bih0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXNbXCJnZXRcIi5jb25jYXQodCwgXCJDdXJzb3JPZmZzZXRcIildKGUsIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gWik7XG4gICAgaWYgKGUuc2hpZnRLZXkgPyB0aGlzLm1vdmVDdXJzb3JXaXRoU2hpZnQocykgOiB0aGlzLm1vdmVDdXJzb3JXaXRob3V0U2hpZnQocyksIHMgIT09IDApIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHplKDAsIHRoaXMuc2VsZWN0aW9uU3RhcnQsIHIpLCB0aGlzLnNlbGVjdGlvbkVuZCA9IHplKDAsIHRoaXMuc2VsZWN0aW9uRW5kLCByKSwgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpLCB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCksIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCksIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9XG4gIG1vdmVDdXJzb3JXaXRoU2hpZnQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09IEwgPyB0aGlzLnNlbGVjdGlvblN0YXJ0ICsgdCA6IHRoaXMuc2VsZWN0aW9uRW5kICsgdDtcbiAgICByZXR1cm4gdGhpcy5zZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdCh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgZSksIHQgIT09IDA7XG4gIH1cbiAgbW92ZUN1cnNvcldpdGhvdXRTaGlmdCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwID8gKHRoaXMuc2VsZWN0aW9uU3RhcnQgKz0gdCwgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0KSA6ICh0aGlzLnNlbGVjdGlvbkVuZCArPSB0LCB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQpLCB0ICE9PSAwO1xuICB9XG4gIG1vdmVDdXJzb3JMZWZ0KHQpIHtcbiAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRoaXMuc2VsZWN0aW9uRW5kID09PSAwIHx8IHRoaXMuX21vdmVDdXJzb3JMZWZ0T3JSaWdodChcIkxlZnRcIiwgdCk7XG4gIH1cbiAgX21vdmUodCwgZSwgcykge1xuICAgIGxldCByO1xuICAgIGlmICh0LmFsdEtleSkgciA9IHRoaXNbXCJmaW5kV29yZEJvdW5kYXJ5XCIuY29uY2F0KHMpXSh0aGlzW2VdKTtcbiAgICBlbHNlIHtcbiAgICAgIGlmICghdC5tZXRhS2V5ICYmIHQua2V5Q29kZSAhPT0gMzUgJiYgdC5rZXlDb2RlICE9PSAzNikgcmV0dXJuIHRoaXNbZV0gKz0gcyA9PT0gXCJMZWZ0XCIgPyAtMSA6IDEsICEwO1xuICAgICAgciA9IHRoaXNbXCJmaW5kTGluZUJvdW5kYXJ5XCIuY29uY2F0KHMpXSh0aGlzW2VdKTtcbiAgICB9XG4gICAgcmV0dXJuIHIgIT09IHZvaWQgMCAmJiB0aGlzW2VdICE9PSByICYmICh0aGlzW2VdID0gciwgITApO1xuICB9XG4gIF9tb3ZlTGVmdCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmUodCwgZSwgXCJMZWZ0XCIpO1xuICB9XG4gIF9tb3ZlUmlnaHQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlKHQsIGUsIFwiUmlnaHRcIik7XG4gIH1cbiAgbW92ZUN1cnNvckxlZnRXaXRob3V0U2hpZnQodCkge1xuICAgIGxldCBlID0gITA7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9IEwsIHRoaXMuc2VsZWN0aW9uRW5kID09PSB0aGlzLnNlbGVjdGlvblN0YXJ0ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDAgJiYgKGUgPSB0aGlzLl9tb3ZlTGVmdCh0LCBcInNlbGVjdGlvblN0YXJ0XCIpKSwgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LCBlO1xuICB9XG4gIG1vdmVDdXJzb3JMZWZ0V2l0aFNoaWZ0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSBaICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kID8gdGhpcy5fbW92ZUxlZnQodCwgXCJzZWxlY3Rpb25FbmRcIikgOiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSAwID8gKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9IEwsIHRoaXMuX21vdmVMZWZ0KHQsIFwic2VsZWN0aW9uU3RhcnRcIikpIDogdm9pZCAwO1xuICB9XG4gIG1vdmVDdXJzb3JSaWdodCh0KSB7XG4gICAgdGhpcy5zZWxlY3Rpb25TdGFydCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCB8fCB0aGlzLl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQoXCJSaWdodFwiLCB0KTtcbiAgfVxuICBfbW92ZUN1cnNvckxlZnRPclJpZ2h0KHQsIGUpIHtcbiAgICBjb25zdCBzID0gXCJtb3ZlQ3Vyc29yXCIuY29uY2F0KHQpLmNvbmNhdChlLnNoaWZ0S2V5ID8gXCJXaXRoU2hpZnRcIiA6IFwiV2l0aG91dFNoaWZ0XCIpO1xuICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMSwgdGhpc1tzXShlKSAmJiAodGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpLCB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCksIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCksIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCkpO1xuICB9XG4gIG1vdmVDdXJzb3JSaWdodFdpdGhTaGlmdCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gTCAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCA/IHRoaXMuX21vdmVSaWdodCh0LCBcInNlbGVjdGlvblN0YXJ0XCIpIDogdGhpcy5zZWxlY3Rpb25FbmQgIT09IHRoaXMuX3RleHQubGVuZ3RoID8gKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9IFosIHRoaXMuX21vdmVSaWdodCh0LCBcInNlbGVjdGlvbkVuZFwiKSkgOiB2b2lkIDA7XG4gIH1cbiAgbW92ZUN1cnNvclJpZ2h0V2l0aG91dFNoaWZ0KHQpIHtcbiAgICBsZXQgZSA9ICEwO1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSBaLCB0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCA/IChlID0gdGhpcy5fbW92ZVJpZ2h0KHQsIFwic2VsZWN0aW9uU3RhcnRcIiksIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydCkgOiB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQsIGU7XG4gIH1cbn1cbmNvbnN0IE5pID0gKGkpID0+ICEhaS5idXR0b247XG5jbGFzcyBEZCBleHRlbmRzIElkIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgeSh0aGlzLCBcImRyYWdnYWJsZVRleHREZWxlZ2F0ZVwiLCB2b2lkIDApO1xuICB9XG4gIGluaXRCZWhhdmlvcigpIHtcbiAgICB0aGlzLm9uKFwibW91c2Vkb3duXCIsIHRoaXMuX21vdXNlRG93bkhhbmRsZXIpLCB0aGlzLm9uKFwibW91c2Vkb3duOmJlZm9yZVwiLCB0aGlzLl9tb3VzZURvd25IYW5kbGVyQmVmb3JlKSwgdGhpcy5vbihcIm1vdXNldXBcIiwgdGhpcy5tb3VzZVVwSGFuZGxlciksIHRoaXMub24oXCJtb3VzZWRibGNsaWNrXCIsIHRoaXMuZG91YmxlQ2xpY2tIYW5kbGVyKSwgdGhpcy5vbihcInRyaXBsZWNsaWNrXCIsIHRoaXMudHJpcGxlQ2xpY2tIYW5kbGVyKSwgdGhpcy5fX2xhc3RDbGlja1RpbWUgPSArLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9ICsvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgdGhpcy5fX2xhc3RQb2ludGVyID0ge30sIHRoaXMub24oXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlRG93biksIHRoaXMuZHJhZ2dhYmxlVGV4dERlbGVnYXRlID0gbmV3IGtkKHRoaXMpLCBzdXBlci5pbml0QmVoYXZpb3IoKTtcbiAgfVxuICBzaG91bGRTdGFydERyYWdnaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZVRleHREZWxlZ2F0ZS5pc0FjdGl2ZSgpO1xuICB9XG4gIG9uRHJhZ1N0YXJ0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGVUZXh0RGVsZWdhdGUub25EcmFnU3RhcnQodCk7XG4gIH1cbiAgY2FuRHJvcCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlVGV4dERlbGVnYXRlLmNhbkRyb3AodCk7XG4gIH1cbiAgb25Nb3VzZURvd24odCkge1xuICAgIGlmICghdGhpcy5jYW52YXMpIHJldHVybjtcbiAgICB0aGlzLl9fbmV3Q2xpY2tUaW1lID0gKy8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGUgPSB0LnBvaW50ZXI7XG4gICAgdGhpcy5pc1RyaXBsZUNsaWNrKGUpICYmICh0aGlzLmZpcmUoXCJ0cmlwbGVjbGlja1wiLCB0KSwgb24odC5lKSksIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9IHRoaXMuX19sYXN0Q2xpY2tUaW1lLCB0aGlzLl9fbGFzdENsaWNrVGltZSA9IHRoaXMuX19uZXdDbGlja1RpbWUsIHRoaXMuX19sYXN0UG9pbnRlciA9IGUsIHRoaXMuX19sYXN0U2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkICYmICF0aGlzLmdldEFjdGl2ZUNvbnRyb2woKTtcbiAgfVxuICBpc1RyaXBsZUNsaWNrKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fX25ld0NsaWNrVGltZSAtIHRoaXMuX19sYXN0Q2xpY2tUaW1lIDwgNTAwICYmIHRoaXMuX19sYXN0Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lIDwgNTAwICYmIHRoaXMuX19sYXN0UG9pbnRlci54ID09PSB0LnggJiYgdGhpcy5fX2xhc3RQb2ludGVyLnkgPT09IHQueTtcbiAgfVxuICBkb3VibGVDbGlja0hhbmRsZXIodCkge1xuICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuc2VsZWN0V29yZCh0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIodC5lKSk7XG4gIH1cbiAgdHJpcGxlQ2xpY2tIYW5kbGVyKHQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLnNlbGVjdExpbmUodGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKHQuZSkpO1xuICB9XG4gIF9tb3VzZURvd25IYW5kbGVyKHQpIHtcbiAgICBsZXQgeyBlIH0gPSB0O1xuICAgIHRoaXMuY2FudmFzICYmIHRoaXMuZWRpdGFibGUgJiYgIU5pKGUpICYmICF0aGlzLmdldEFjdGl2ZUNvbnRyb2woKSAmJiAodGhpcy5kcmFnZ2FibGVUZXh0RGVsZWdhdGUuc3RhcnQoZSkgfHwgKHRoaXMuY2FudmFzLnRleHRFZGl0aW5nTWFuYWdlci5yZWdpc3Rlcih0aGlzKSwgdGhpcy5zZWxlY3RlZCAmJiAodGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA9ICExLCB0aGlzLnNldEN1cnNvckJ5Q2xpY2soZSkpLCB0aGlzLmlzRWRpdGluZyAmJiAodGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24gPSB0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCAmJiB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCksIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKSkpKTtcbiAgfVxuICBfbW91c2VEb3duSGFuZGxlckJlZm9yZSh0KSB7XG4gICAgbGV0IHsgZSB9ID0gdDtcbiAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmVkaXRhYmxlICYmICFOaShlKSAmJiAodGhpcy5zZWxlY3RlZCA9IHRoaXMgPT09IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QpO1xuICB9XG4gIG1vdXNlVXBIYW5kbGVyKHQpIHtcbiAgICBsZXQgeyBlLCB0cmFuc2Zvcm06IHMgfSA9IHQ7XG4gICAgY29uc3QgciA9IHRoaXMuZHJhZ2dhYmxlVGV4dERlbGVnYXRlLmVuZChlKTtcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnRleHRFZGl0aW5nTWFuYWdlci51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgY29uc3QgbiA9IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAobiAmJiBuICE9PSB0aGlzKSByZXR1cm47XG4gICAgfVxuICAgICF0aGlzLmVkaXRhYmxlIHx8IHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuaW50ZXJhY3RpdmUgfHwgcyAmJiBzLmFjdGlvblBlcmZvcm1lZCB8fCBOaShlKSB8fCByIHx8ICh0aGlzLl9fbGFzdFNlbGVjdGVkICYmICF0aGlzLmdldEFjdGl2ZUNvbnRyb2woKSA/ICh0aGlzLnNlbGVjdGVkID0gITEsIHRoaXMuX19sYXN0U2VsZWN0ZWQgPSAhMSwgdGhpcy5lbnRlckVkaXRpbmcoZSksIHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kID8gdGhpcy5pbml0RGVsYXllZEN1cnNvcighMCkgOiB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCkpIDogdGhpcy5zZWxlY3RlZCA9ICEwKTtcbiAgfVxuICBzZXRDdXJzb3JCeUNsaWNrKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKHQpLCBzID0gdGhpcy5zZWxlY3Rpb25TdGFydCwgciA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIHQuc2hpZnRLZXkgPyB0aGlzLnNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHMsIHIsIGUpIDogKHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBlLCB0aGlzLnNlbGVjdGlvbkVuZCA9IGUpLCB0aGlzLmlzRWRpdGluZyAmJiAodGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKSwgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKSk7XG4gIH1cbiAgZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY2FudmFzLmdldFNjZW5lUG9pbnQodCkudHJhbnNmb3JtKFN0KHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKSkuYWRkKG5ldyBfKC10aGlzLl9nZXRMZWZ0T2Zmc2V0KCksIC10aGlzLl9nZXRUb3BPZmZzZXQoKSkpO1xuICAgIGxldCBzID0gMCwgciA9IDAsIG4gPSAwO1xuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgdGhpcy5fdGV4dExpbmVzLmxlbmd0aCAmJiBzIDw9IGUueTsgbCsrKSBzICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGwpLCBuID0gbCwgbCA+IDAgJiYgKHIgKz0gdGhpcy5fdGV4dExpbmVzW2wgLSAxXS5sZW5ndGggKyB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGwgLSAxKSk7XG4gICAgbGV0IG8gPSBNYXRoLmFicyh0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChuKSk7XG4gICAgY29uc3QgYSA9IHRoaXMuX3RleHRMaW5lc1tuXS5sZW5ndGgsIGMgPSB0aGlzLl9fY2hhckJvdW5kc1tuXTtcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IGE7IGwrKykge1xuICAgICAgY29uc3QgaCA9IG8gKyBjW2xdLmtlcm5lZFdpZHRoO1xuICAgICAgaWYgKGUueCA8PSBoKSB7XG4gICAgICAgIE1hdGguYWJzKGUueCAtIGgpIDw9IE1hdGguYWJzKGUueCAtIG8pICYmIHIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvID0gaCwgcisrO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mbGlwWCA/IGEgLSByIDogciwgdGhpcy5fdGV4dC5sZW5ndGgpO1xuICB9XG59XG5jb25zdCBfciA9IFwibW92ZUN1cnNvclVwXCIsIFNyID0gXCJtb3ZlQ3Vyc29yRG93blwiLCBUciA9IFwibW92ZUN1cnNvckxlZnRcIiwgeHIgPSBcIm1vdmVDdXJzb3JSaWdodFwiLCB3ciA9IFwiZXhpdEVkaXRpbmdcIiwgamQgPSB2KHsgc2VsZWN0aW9uU3RhcnQ6IDAsIHNlbGVjdGlvbkVuZDogMCwgc2VsZWN0aW9uQ29sb3I6IFwicmdiYSgxNywxMTksMjU1LDAuMylcIiwgaXNFZGl0aW5nOiAhMSwgZWRpdGFibGU6ICEwLCBlZGl0aW5nQm9yZGVyQ29sb3I6IFwicmdiYSgxMDIsMTUzLDI1NSwwLjI1KVwiLCBjdXJzb3JXaWR0aDogMiwgY3Vyc29yQ29sb3I6IFwiXCIsIGN1cnNvckRlbGF5OiAxZTMsIGN1cnNvckR1cmF0aW9uOiA2MDAsIGNhY2hpbmc6ICEwLCBoaWRkZW5UZXh0YXJlYUNvbnRhaW5lcjogbnVsbCwga2V5c01hcDogeyA5OiB3ciwgMjc6IHdyLCAzMzogX3IsIDM0OiBTciwgMzU6IHhyLCAzNjogVHIsIDM3OiBUciwgMzg6IF9yLCAzOTogeHIsIDQwOiBTciB9LCBrZXlzTWFwUnRsOiB7IDk6IHdyLCAyNzogd3IsIDMzOiBfciwgMzQ6IFNyLCAzNTogVHIsIDM2OiB4ciwgMzc6IHhyLCAzODogX3IsIDM5OiBUciwgNDA6IFNyIH0sIGN0cmxLZXlzTWFwRG93bjogeyA2NTogXCJzZWxlY3RBbGxcIiB9LCBjdHJsS2V5c01hcFVwOiB7IDY3OiBcImNvcHlcIiwgODg6IFwiY3V0XCIgfSB9LCB7IF9zZWxlY3Rpb25EaXJlY3Rpb246IG51bGwsIF9yZVNwYWNlOiAvXFxzfFxccj9cXG4vLCBpbkNvbXBvc2l0aW9uTW9kZTogITEgfSk7XG5jbGFzcyBvZSBleHRlbmRzIERkIHtcbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB2KHYoe30sIHN1cGVyLmdldERlZmF1bHRzKCkpLCBvZS5vd25EZWZhdWx0cyk7XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgY29uc3QgdCA9IHN1cGVyLnR5cGU7XG4gICAgcmV0dXJuIHQgPT09IFwiaXRleHRcIiA/IFwiaS10ZXh0XCIgOiB0O1xuICB9XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcih0LCB2KHYoe30sIG9lLm93bkRlZmF1bHRzKSwgZSkpLCB0aGlzLmluaXRCZWhhdmlvcigpO1xuICB9XG4gIF9zZXQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLl9zYXZlZFByb3BzICYmIHQgaW4gdGhpcy5fc2F2ZWRQcm9wcyA/ICh0aGlzLl9zYXZlZFByb3BzW3RdID0gZSwgdGhpcykgOiAodCA9PT0gXCJjYW52YXNcIiAmJiAodGhpcy5jYW52YXMgaW5zdGFuY2VvZiB2biAmJiB0aGlzLmNhbnZhcy50ZXh0RWRpdGluZ01hbmFnZXIucmVtb3ZlKHRoaXMpLCBlIGluc3RhbmNlb2Ygdm4gJiYgZS50ZXh0RWRpdGluZ01hbmFnZXIuYWRkKHRoaXMpKSwgc3VwZXIuX3NldCh0LCBlKSk7XG4gIH1cbiAgc2V0U2VsZWN0aW9uU3RhcnQodCkge1xuICAgIHQgPSBNYXRoLm1heCh0LCAwKSwgdGhpcy5fdXBkYXRlQW5kRmlyZShcInNlbGVjdGlvblN0YXJ0XCIsIHQpO1xuICB9XG4gIHNldFNlbGVjdGlvbkVuZCh0KSB7XG4gICAgdCA9IE1hdGgubWluKHQsIHRoaXMudGV4dC5sZW5ndGgpLCB0aGlzLl91cGRhdGVBbmRGaXJlKFwic2VsZWN0aW9uRW5kXCIsIHQpO1xuICB9XG4gIF91cGRhdGVBbmRGaXJlKHQsIGUpIHtcbiAgICB0aGlzW3RdICE9PSBlICYmICh0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpLCB0aGlzW3RdID0gZSksIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gIH1cbiAgX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCkge1xuICAgIHRoaXMuZmlyZShcInNlbGVjdGlvbjpjaGFuZ2VkXCIpLCB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5maXJlKFwidGV4dDpzZWxlY3Rpb246Y2hhbmdlZFwiLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgfVxuICBpbml0RGltZW5zaW9ucygpIHtcbiAgICB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCksIHN1cGVyLmluaXREaW1lbnNpb25zKCk7XG4gIH1cbiAgZ2V0U2VsZWN0aW9uU3R5bGVzKCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDAsIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0aW9uRW5kLCBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB2b2lkIDA7XG4gICAgcmV0dXJuIHN1cGVyLmdldFNlbGVjdGlvblN0eWxlcyh0LCBlLCBzKTtcbiAgfVxuICBzZXRTZWxlY3Rpb25TdHlsZXModCkge1xuICAgIGxldCBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDAsIHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIHJldHVybiBzdXBlci5zZXRTZWxlY3Rpb25TdHlsZXModCwgZSwgcyk7XG4gIH1cbiAgZ2V0MkRDdXJzb3JMb2NhdGlvbigpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogdGhpcy5zZWxlY3Rpb25TdGFydCwgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICAgIHJldHVybiBzdXBlci5nZXQyREN1cnNvckxvY2F0aW9uKHQsIGUpO1xuICB9XG4gIHJlbmRlcih0KSB7XG4gICAgc3VwZXIucmVuZGVyKHQpLCB0aGlzLmN1cnNvck9mZnNldENhY2hlID0ge30sIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgfVxuICB0b0NhbnZhc0VsZW1lbnQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmlzRWRpdGluZztcbiAgICB0aGlzLmlzRWRpdGluZyA9ICExO1xuICAgIGNvbnN0IHMgPSBzdXBlci50b0NhbnZhc0VsZW1lbnQodCk7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGl0aW5nID0gZSwgcztcbiAgfVxuICByZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuY2xlYXJDb250ZXh0VG9wKCEwKTtcbiAgICBpZiAoIXQpIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcygpO1xuICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kIHx8IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPyB0aGlzLnJlbmRlclNlbGVjdGlvbih0LCBlKSA6IHRoaXMucmVuZGVyQ3Vyc29yKHQsIGUpLCB0aGlzLmNhbnZhcy5jb250ZXh0VG9wRGlydHkgPSAhMCwgdC5yZXN0b3JlKCk7XG4gIH1cbiAgX2dldEN1cnNvckJvdW5kYXJpZXMoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICBjb25zdCBzID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLCByID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksIG4gPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0cyh0LCBlKTtcbiAgICByZXR1cm4geyBsZWZ0OiBzLCB0b3A6IHIsIGxlZnRPZmZzZXQ6IG4ubGVmdCwgdG9wT2Zmc2V0OiBuLnRvcCB9O1xuICB9XG4gIF9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0cyh0LCBlKSB7XG4gICAgcmV0dXJuIGUgPyB0aGlzLl9fZ2V0Q3Vyc29yQm91bmRhcmllc09mZnNldHModCkgOiB0aGlzLmN1cnNvck9mZnNldENhY2hlICYmIFwidG9wXCIgaW4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA/IHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgOiB0aGlzLmN1cnNvck9mZnNldENhY2hlID0gdGhpcy5fX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzKHQpO1xuICB9XG4gIF9fZ2V0Q3Vyc29yQm91bmRhcmllc09mZnNldHModCkge1xuICAgIGxldCBlID0gMCwgcyA9IDA7XG4gICAgY29uc3QgeyBjaGFySW5kZXg6IHIsIGxpbmVJbmRleDogbiB9ID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHQpO1xuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgbjsgbCsrKSBlICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGwpO1xuICAgIGNvbnN0IG8gPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChuKSwgYSA9IHRoaXMuX19jaGFyQm91bmRzW25dW3JdO1xuICAgIGEgJiYgKHMgPSBhLmxlZnQpLCB0aGlzLmNoYXJTcGFjaW5nICE9PSAwICYmIHIgPT09IHRoaXMuX3RleHRMaW5lc1tuXS5sZW5ndGggJiYgKHMgLT0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCkpO1xuICAgIGNvbnN0IGMgPSB7IHRvcDogZSwgbGVmdDogbyArIChzID4gMCA/IHMgOiAwKSB9O1xuICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gXCJydGxcIiAmJiAodGhpcy50ZXh0QWxpZ24gPT09IFogfHwgdGhpcy50ZXh0QWxpZ24gPT09IEh0IHx8IHRoaXMudGV4dEFsaWduID09PSBWcyA/IGMubGVmdCAqPSAtMSA6IHRoaXMudGV4dEFsaWduID09PSBMIHx8IHRoaXMudGV4dEFsaWduID09PSBuaSA/IGMubGVmdCA9IG8gLSAocyA+IDAgPyBzIDogMCkgOiB0aGlzLnRleHRBbGlnbiAhPT0gaiAmJiB0aGlzLnRleHRBbGlnbiAhPT0gR3MgfHwgKGMubGVmdCA9IG8gLSAocyA+IDAgPyBzIDogMCkpKSwgYztcbiAgfVxuICByZW5kZXJDdXJzb3JBdCh0KSB7XG4gICAgdGhpcy5fcmVuZGVyQ3Vyc29yKHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXModCwgITApLCB0KTtcbiAgfVxuICByZW5kZXJDdXJzb3IodCwgZSkge1xuICAgIHRoaXMuX3JlbmRlckN1cnNvcih0LCBlLCB0aGlzLnNlbGVjdGlvblN0YXJ0KTtcbiAgfVxuICBnZXRDdXJzb3JSZW5kZXJpbmdEYXRhKCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnNlbGVjdGlvblN0YXJ0LCBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzKHQpO1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24odCksIHIgPSBzLmxpbmVJbmRleCwgbiA9IHMuY2hhckluZGV4ID4gMCA/IHMuY2hhckluZGV4IC0gMSA6IDAsIG8gPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KHIsIG4sIFwiZm9udFNpemVcIiksIGEgPSB0aGlzLmdldE9iamVjdFNjYWxpbmcoKS54ICogdGhpcy5jYW52YXMuZ2V0Wm9vbSgpLCBjID0gdGhpcy5jdXJzb3JXaWR0aCAvIGEsIGwgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KHIsIG4sIFwiZGVsdGFZXCIpLCBoID0gZS50b3BPZmZzZXQgKyAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pICogdGhpcy5nZXRIZWlnaHRPZkxpbmUocikgLyB0aGlzLmxpbmVIZWlnaHQgLSBvICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKTtcbiAgICByZXR1cm4geyBjb2xvcjogdGhpcy5jdXJzb3JDb2xvciB8fCB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KHIsIG4sIFwiZmlsbFwiKSwgb3BhY2l0eTogdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHksIGxlZnQ6IGUubGVmdCArIGUubGVmdE9mZnNldCAtIGMgLyAyLCB0b3A6IGggKyBlLnRvcCArIGwsIHdpZHRoOiBjLCBoZWlnaHQ6IG8gfTtcbiAgfVxuICBfcmVuZGVyQ3Vyc29yKHQsIGUsIHMpIHtcbiAgICBjb25zdCB7IGNvbG9yOiByLCBvcGFjaXR5OiBuLCBsZWZ0OiBvLCB0b3A6IGEsIHdpZHRoOiBjLCBoZWlnaHQ6IGwgfSA9IHRoaXMuZ2V0Q3Vyc29yUmVuZGVyaW5nRGF0YShzLCBlKTtcbiAgICB0LmZpbGxTdHlsZSA9IHIsIHQuZ2xvYmFsQWxwaGEgPSBuLCB0LmZpbGxSZWN0KG8sIGEsIGMsIGwpO1xuICB9XG4gIHJlbmRlclNlbGVjdGlvbih0LCBlKSB7XG4gICAgY29uc3QgcyA9IHsgc2VsZWN0aW9uU3RhcnQ6IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPyB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0IDogdGhpcy5zZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kOiB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQgOiB0aGlzLnNlbGVjdGlvbkVuZCB9O1xuICAgIHRoaXMuX3JlbmRlclNlbGVjdGlvbih0LCBzLCBlKTtcbiAgfVxuICByZW5kZXJEcmFnU291cmNlRWZmZWN0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmRyYWdnYWJsZVRleHREZWxlZ2F0ZS5nZXREcmFnU3RhcnRTZWxlY3Rpb24oKTtcbiAgICB0aGlzLl9yZW5kZXJTZWxlY3Rpb24odGhpcy5jYW52YXMuY29udGV4dFRvcCwgdCwgdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcyh0LnNlbGVjdGlvblN0YXJ0LCAhMCkpO1xuICB9XG4gIHJlbmRlckRyb3BUYXJnZXRFZmZlY3QodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIodCk7XG4gICAgdGhpcy5yZW5kZXJDdXJzb3JBdChlKTtcbiAgfVxuICBfcmVuZGVyU2VsZWN0aW9uKHQsIGUsIHMpIHtcbiAgICBjb25zdCByID0gZS5zZWxlY3Rpb25TdGFydCwgbiA9IGUuc2VsZWN0aW9uRW5kLCBvID0gdGhpcy50ZXh0QWxpZ24uaW5jbHVkZXMoSHQpLCBhID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHIpLCBjID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKG4pLCBsID0gYS5saW5lSW5kZXgsIGggPSBjLmxpbmVJbmRleCwgdSA9IGEuY2hhckluZGV4IDwgMCA/IDAgOiBhLmNoYXJJbmRleCwgZCA9IGMuY2hhckluZGV4IDwgMCA/IDAgOiBjLmNoYXJJbmRleDtcbiAgICBmb3IgKGxldCBmID0gbDsgZiA8PSBoOyBmKyspIHtcbiAgICAgIGNvbnN0IGcgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChmKSB8fCAwO1xuICAgICAgbGV0IHAgPSB0aGlzLmdldEhlaWdodE9mTGluZShmKSwgbSA9IDAsIGIgPSAwLCBTID0gMDtcbiAgICAgIGlmIChmID09PSBsICYmIChiID0gdGhpcy5fX2NoYXJCb3VuZHNbbF1bdV0ubGVmdCksIGYgPj0gbCAmJiBmIDwgaCkgUyA9IG8gJiYgIXRoaXMuaXNFbmRPZldyYXBwaW5nKGYpID8gdGhpcy53aWR0aCA6IHRoaXMuZ2V0TGluZVdpZHRoKGYpIHx8IDU7XG4gICAgICBlbHNlIGlmIChmID09PSBoKSBpZiAoZCA9PT0gMCkgUyA9IHRoaXMuX19jaGFyQm91bmRzW2hdW2RdLmxlZnQ7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgSSA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICBTID0gdGhpcy5fX2NoYXJCb3VuZHNbaF1bZCAtIDFdLmxlZnQgKyB0aGlzLl9fY2hhckJvdW5kc1toXVtkIC0gMV0ud2lkdGggLSBJO1xuICAgICAgfVxuICAgICAgbSA9IHAsICh0aGlzLmxpbmVIZWlnaHQgPCAxIHx8IGYgPT09IGggJiYgdGhpcy5saW5lSGVpZ2h0ID4gMSkgJiYgKHAgLz0gdGhpcy5saW5lSGVpZ2h0KTtcbiAgICAgIGxldCB3ID0gcy5sZWZ0ICsgZyArIGIsIGsgPSBwLCBPID0gMDtcbiAgICAgIGNvbnN0IHggPSBTIC0gYjtcbiAgICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPyAodC5maWxsU3R5bGUgPSB0aGlzLmNvbXBvc2l0aW9uQ29sb3IgfHwgXCJibGFja1wiLCBrID0gMSwgTyA9IHApIDogdC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkNvbG9yLCB0aGlzLmRpcmVjdGlvbiA9PT0gXCJydGxcIiAmJiAodGhpcy50ZXh0QWxpZ24gPT09IFogfHwgdGhpcy50ZXh0QWxpZ24gPT09IEh0IHx8IHRoaXMudGV4dEFsaWduID09PSBWcyA/IHcgPSB0aGlzLndpZHRoIC0gdyAtIHggOiB0aGlzLnRleHRBbGlnbiA9PT0gTCB8fCB0aGlzLnRleHRBbGlnbiA9PT0gbmkgPyB3ID0gcy5sZWZ0ICsgZyAtIFMgOiB0aGlzLnRleHRBbGlnbiAhPT0gaiAmJiB0aGlzLnRleHRBbGlnbiAhPT0gR3MgfHwgKHcgPSBzLmxlZnQgKyBnIC0gUykpLCB0LmZpbGxSZWN0KHcsIHMudG9wICsgcy50b3BPZmZzZXQgKyBPLCB4LCBrKSwgcy50b3BPZmZzZXQgKz0gbTtcbiAgICB9XG4gIH1cbiAgZ2V0Q3VycmVudENoYXJGb250U2l6ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0Q3VycmVudENoYXJJbmRleCgpO1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KHQubCwgdC5jLCBcImZvbnRTaXplXCIpO1xuICB9XG4gIGdldEN1cnJlbnRDaGFyQ29sb3IoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldEN1cnJlbnRDaGFySW5kZXgoKTtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdCh0LmwsIHQuYywgcnQpO1xuICB9XG4gIF9nZXRDdXJyZW50Q2hhckluZGV4KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24odGhpcy5zZWxlY3Rpb25TdGFydCwgITApLCBlID0gdC5jaGFySW5kZXggPiAwID8gdC5jaGFySW5kZXggLSAxIDogMDtcbiAgICByZXR1cm4geyBsOiB0LmxpbmVJbmRleCwgYzogZSB9O1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5leGl0RWRpdGluZ0ltcGwoKSwgdGhpcy5kcmFnZ2FibGVUZXh0RGVsZWdhdGUuZGlzcG9zZSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbn1cbnkob2UsIFwib3duRGVmYXVsdHNcIiwgamQpLCB5KG9lLCBcInR5cGVcIiwgXCJJVGV4dFwiKSwgQy5zZXRDbGFzcyhvZSksIEMuc2V0Q2xhc3Mob2UsIFwiaS10ZXh0XCIpO1xuY2xhc3MgTGUgZXh0ZW5kcyBvZSB7XG4gIHN0YXRpYyBnZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4gdih2KHt9LCBzdXBlci5nZXREZWZhdWx0cygpKSwgTGUub3duRGVmYXVsdHMpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcih0LCB2KHYoe30sIExlLm93bkRlZmF1bHRzKSwgZSkpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVDb250cm9scygpIHtcbiAgICByZXR1cm4geyBjb250cm9sczogT2MoKSB9O1xuICB9XG4gIGluaXREaW1lbnNpb25zKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgJiYgKHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKSwgdGhpcy5fY2xlYXJDYWNoZSgpLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IDAsIHRoaXMuX3N0eWxlTWFwID0gdGhpcy5fZ2VuZXJhdGVTdHlsZU1hcCh0aGlzLl9zcGxpdFRleHQoKSksIHRoaXMuZHluYW1pY01pbldpZHRoID4gdGhpcy53aWR0aCAmJiB0aGlzLl9zZXQoXCJ3aWR0aFwiLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCksIHRoaXMudGV4dEFsaWduLmluY2x1ZGVzKEh0KSAmJiB0aGlzLmVubGFyZ2VTcGFjZXMoKSwgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbGNUZXh0SGVpZ2h0KCkpO1xuICB9XG4gIF9nZW5lcmF0ZVN0eWxlTWFwKHQpIHtcbiAgICBsZXQgZSA9IDAsIHMgPSAwLCByID0gMDtcbiAgICBjb25zdCBuID0ge307XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCB0LmdyYXBoZW1lTGluZXMubGVuZ3RoOyBvKyspIHQuZ3JhcGhlbWVUZXh0W3JdID09PSBgXG5gICYmIG8gPiAwID8gKHMgPSAwLCByKyssIGUrKykgOiAhdGhpcy5zcGxpdEJ5R3JhcGhlbWUgJiYgdGhpcy5fcmVTcGFjZUFuZFRhYi50ZXN0KHQuZ3JhcGhlbWVUZXh0W3JdKSAmJiBvID4gMCAmJiAocysrLCByKyspLCBuW29dID0geyBsaW5lOiBlLCBvZmZzZXQ6IHMgfSwgciArPSB0LmdyYXBoZW1lTGluZXNbb10ubGVuZ3RoLCBzICs9IHQuZ3JhcGhlbWVMaW5lc1tvXS5sZW5ndGg7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgc3R5bGVIYXModCwgZSkge1xuICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5fc3R5bGVNYXBbZV07XG4gICAgICBzICYmIChlID0gcy5saW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnN0eWxlSGFzKHQsIGUpO1xuICB9XG4gIGlzRW1wdHlTdHlsZXModCkge1xuICAgIGlmICghdGhpcy5zdHlsZXMpIHJldHVybiAhMDtcbiAgICBsZXQgZSwgcyA9IDAsIHIgPSB0ICsgMSwgbiA9ICExO1xuICAgIGNvbnN0IG8gPSB0aGlzLl9zdHlsZU1hcFt0XSwgYSA9IHRoaXMuX3N0eWxlTWFwW3QgKyAxXTtcbiAgICBvICYmICh0ID0gby5saW5lLCBzID0gby5vZmZzZXQpLCBhICYmIChyID0gYS5saW5lLCBuID0gciA9PT0gdCwgZSA9IGEub2Zmc2V0KTtcbiAgICBjb25zdCBjID0gdCA9PT0gdm9pZCAwID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW3RdIH07XG4gICAgZm9yIChjb25zdCBsIGluIGMpIGZvciAoY29uc3QgaCBpbiBjW2xdKSB7XG4gICAgICBjb25zdCB1ID0gcGFyc2VJbnQoaCwgMTApO1xuICAgICAgaWYgKHUgPj0gcyAmJiAoIW4gfHwgdSA8IGUpKSBmb3IgKGNvbnN0IGQgaW4gY1tsXVtoXSkgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgX2dldFN0eWxlRGVjbGFyYXRpb24odCwgZSkge1xuICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5fc3R5bGVNYXBbdF07XG4gICAgICBpZiAoIXMpIHJldHVybiB7fTtcbiAgICAgIHQgPSBzLmxpbmUsIGUgPSBzLm9mZnNldCArIGU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fZ2V0U3R5bGVEZWNsYXJhdGlvbih0LCBlKTtcbiAgfVxuICBfc2V0U3R5bGVEZWNsYXJhdGlvbih0LCBlLCBzKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX3N0eWxlTWFwW3RdO1xuICAgIHN1cGVyLl9zZXRTdHlsZURlY2xhcmF0aW9uKHIubGluZSwgci5vZmZzZXQgKyBlLCBzKTtcbiAgfVxuICBfZGVsZXRlU3R5bGVEZWNsYXJhdGlvbih0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuX3N0eWxlTWFwW3RdO1xuICAgIHN1cGVyLl9kZWxldGVTdHlsZURlY2xhcmF0aW9uKHMubGluZSwgcy5vZmZzZXQgKyBlKTtcbiAgfVxuICBfZ2V0TGluZVN0eWxlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fc3R5bGVNYXBbdF07XG4gICAgcmV0dXJuICEhdGhpcy5zdHlsZXNbZS5saW5lXTtcbiAgfVxuICBfc2V0TGluZVN0eWxlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fc3R5bGVNYXBbdF07XG4gICAgc3VwZXIuX3NldExpbmVTdHlsZShlLmxpbmUpO1xuICB9XG4gIF93cmFwVGV4dCh0LCBlKSB7XG4gICAgdGhpcy5pc1dyYXBwaW5nID0gITA7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0R3JhcGhlbWVEYXRhRm9yUmVuZGVyKHQpLCByID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLndvcmRzRGF0YS5sZW5ndGg7IG4rKykgci5wdXNoKC4uLnRoaXMuX3dyYXBMaW5lKG4sIGUsIHMpKTtcbiAgICByZXR1cm4gdGhpcy5pc1dyYXBwaW5nID0gITEsIHI7XG4gIH1cbiAgZ2V0R3JhcGhlbWVEYXRhRm9yUmVuZGVyKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5zcGxpdEJ5R3JhcGhlbWUsIHMgPSBlID8gXCJcIiA6IFwiIFwiO1xuICAgIGxldCByID0gMDtcbiAgICByZXR1cm4geyB3b3Jkc0RhdGE6IHQubWFwKChuLCBvKSA9PiB7XG4gICAgICBsZXQgYSA9IDA7XG4gICAgICBjb25zdCBjID0gZSA/IHRoaXMuZ3JhcGhlbWVTcGxpdChuKSA6IHRoaXMud29yZFNwbGl0KG4pO1xuICAgICAgcmV0dXJuIGMubGVuZ3RoID09PSAwID8gW3sgd29yZDogW10sIHdpZHRoOiAwIH1dIDogYy5tYXAoKGwpID0+IHtcbiAgICAgICAgY29uc3QgaCA9IGUgPyBbbF0gOiB0aGlzLmdyYXBoZW1lU3BsaXQobCksIHUgPSB0aGlzLl9tZWFzdXJlV29yZChoLCBvLCBhKTtcbiAgICAgICAgcmV0dXJuIHIgPSBNYXRoLm1heCh1LCByKSwgYSArPSBoLmxlbmd0aCArIHMubGVuZ3RoLCB7IHdvcmQ6IGgsIHdpZHRoOiB1IH07XG4gICAgICB9KTtcbiAgICB9KSwgbGFyZ2VzdFdvcmRXaWR0aDogciB9O1xuICB9XG4gIF9tZWFzdXJlV29yZCh0LCBlKSB7XG4gICAgbGV0IHMsIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IDAsIG4gPSAwO1xuICAgIGZvciAobGV0IG8gPSAwLCBhID0gdC5sZW5ndGg7IG8gPCBhOyBvKyspXG4gICAgICBuICs9IHRoaXMuX2dldEdyYXBoZW1lQm94KHRbb10sIGUsIG8gKyByLCBzLCAhMCkua2VybmVkV2lkdGgsIHMgPSB0W29dO1xuICAgIHJldHVybiBuO1xuICB9XG4gIHdvcmRTcGxpdCh0KSB7XG4gICAgcmV0dXJuIHQuc3BsaXQodGhpcy5fd29yZEpvaW5lcnMpO1xuICB9XG4gIF93cmFwTGluZSh0LCBlLCBzKSB7XG4gICAgbGV0IHsgbGFyZ2VzdFdvcmRXaWR0aDogciwgd29yZHNEYXRhOiBuIH0gPSBzLCBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgIGNvbnN0IGEgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKSwgYyA9IHRoaXMuc3BsaXRCeUdyYXBoZW1lLCBsID0gW10sIGggPSBjID8gXCJcIiA6IFwiIFwiO1xuICAgIGxldCB1ID0gMCwgZCA9IFtdLCBmID0gMCwgZyA9IDAsIHAgPSAhMDtcbiAgICBlIC09IG87XG4gICAgY29uc3QgbSA9IE1hdGgubWF4KGUsIHIsIHRoaXMuZHluYW1pY01pbldpZHRoKSwgYiA9IG5bdF07XG4gICAgbGV0IFM7XG4gICAgZm9yIChmID0gMCwgUyA9IDA7IFMgPCBiLmxlbmd0aDsgUysrKSB7XG4gICAgICBjb25zdCB7IHdvcmQ6IHcsIHdpZHRoOiBrIH0gPSBiW1NdO1xuICAgICAgZiArPSB3Lmxlbmd0aCwgdSArPSBnICsgayAtIGEsIHUgPiBtICYmICFwID8gKGwucHVzaChkKSwgZCA9IFtdLCB1ID0gaywgcCA9ICEwKSA6IHUgKz0gYSwgcCB8fCBjIHx8IGQucHVzaChoKSwgZCA9IGQuY29uY2F0KHcpLCBnID0gYyA/IDAgOiB0aGlzLl9tZWFzdXJlV29yZChbaF0sIHQsIGYpLCBmKyssIHAgPSAhMTtcbiAgICB9XG4gICAgcmV0dXJuIFMgJiYgbC5wdXNoKGQpLCByICsgbyA+IHRoaXMuZHluYW1pY01pbldpZHRoICYmICh0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IHIgLSBhICsgbyksIGw7XG4gIH1cbiAgaXNFbmRPZldyYXBwaW5nKHQpIHtcbiAgICByZXR1cm4gIXRoaXMuX3N0eWxlTWFwW3QgKyAxXSB8fCB0aGlzLl9zdHlsZU1hcFt0ICsgMV0ubGluZSAhPT0gdGhpcy5fc3R5bGVNYXBbdF0ubGluZTtcbiAgfVxuICBtaXNzaW5nTmV3bGluZU9mZnNldCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaXRCeUdyYXBoZW1lICYmICFlID8gdGhpcy5pc0VuZE9mV3JhcHBpbmcodCkgPyAxIDogMCA6IDE7XG4gIH1cbiAgX3NwbGl0VGV4dEludG9MaW5lcyh0KSB7XG4gICAgY29uc3QgZSA9IHN1cGVyLl9zcGxpdFRleHRJbnRvTGluZXModCksIHMgPSB0aGlzLl93cmFwVGV4dChlLmxpbmVzLCB0aGlzLndpZHRoKSwgciA9IG5ldyBBcnJheShzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbisrKSByW25dID0gc1tuXS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBlLmxpbmVzID0gciwgZS5ncmFwaGVtZUxpbmVzID0gcywgZTtcbiAgfVxuICBnZXRNaW5XaWR0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5taW5XaWR0aCwgdGhpcy5keW5hbWljTWluV2lkdGgpO1xuICB9XG4gIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzKCkge1xuICAgIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZSBpbiB0aGlzLl9zdHlsZU1hcCkge1xuICAgICAgY29uc3QgcyA9IHBhcnNlSW50KGUsIDEwKTtcbiAgICAgIGlmICh0aGlzLl90ZXh0TGluZXNbc10pIHtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuX3N0eWxlTWFwW2VdLmxpbmU7XG4gICAgICAgIHQuc2V0KFwiXCIuY29uY2F0KHIpLCAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZSBpbiB0aGlzLnN0eWxlcykgdC5oYXMoZSkgfHwgZGVsZXRlIHRoaXMuc3R5bGVzW2VdO1xuICB9XG4gIHRvT2JqZWN0KCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICByZXR1cm4gc3VwZXIudG9PYmplY3QoW1wibWluV2lkdGhcIiwgXCJzcGxpdEJ5R3JhcGhlbWVcIiwgLi4udF0pO1xuICB9XG59XG55KExlLCBcInR5cGVcIiwgXCJUZXh0Ym94XCIpLCB5KExlLCBcInRleHRMYXlvdXRQcm9wZXJ0aWVzXCIsIFsuLi5vZS50ZXh0TGF5b3V0UHJvcGVydGllcywgXCJ3aWR0aFwiXSksIHkoTGUsIFwib3duRGVmYXVsdHNcIiwgeyBtaW5XaWR0aDogMjAsIGR5bmFtaWNNaW5XaWR0aDogMiwgbG9ja1NjYWxpbmdGbGlwOiAhMCwgbm9TY2FsZUNhY2hlOiAhMSwgX3dvcmRKb2luZXJzOiAvWyBcXHRcXHJdLywgc3BsaXRCeUdyYXBoZW1lOiAhMSB9KSwgQy5zZXRDbGFzcyhMZSk7XG5jbGFzcyBZbyBleHRlbmRzIENpIHtcbiAgc2hvdWxkUGVyZm9ybUxheW91dCh0KSB7XG4gICAgcmV0dXJuICEhdC50YXJnZXQuY2xpcFBhdGggJiYgc3VwZXIuc2hvdWxkUGVyZm9ybUxheW91dCh0KTtcbiAgfVxuICBzaG91bGRMYXlvdXRDbGlwUGF0aCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgY2FsY0xheW91dFJlc3VsdCh0LCBlKSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IHMgfSA9IHQsIHsgY2xpcFBhdGg6IHIsIGdyb3VwOiBuIH0gPSBzO1xuICAgIGlmICghciB8fCAhdGhpcy5zaG91bGRQZXJmb3JtTGF5b3V0KHQpKSByZXR1cm47XG4gICAgY29uc3QgeyB3aWR0aDogbywgaGVpZ2h0OiBhIH0gPSBHdChGYyhzLCByKSksIGMgPSBuZXcgXyhvLCBhKTtcbiAgICBpZiAoci5hYnNvbHV0ZVBvc2l0aW9uZWQpXG4gICAgICByZXR1cm4geyBjZW50ZXI6IGFlKHIuZ2V0UmVsYXRpdmVDZW50ZXJQb2ludCgpLCB2b2lkIDAsIG4gPyBuLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSA6IHZvaWQgMCksIHNpemU6IGMgfTtcbiAgICB7XG4gICAgICBjb25zdCBsID0gci5nZXRSZWxhdGl2ZUNlbnRlclBvaW50KCkudHJhbnNmb3JtKHMuY2FsY093bk1hdHJpeCgpLCAhMCk7XG4gICAgICBpZiAodGhpcy5zaG91bGRQZXJmb3JtTGF5b3V0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgY2VudGVyOiBoID0gbmV3IF8oKSwgY29ycmVjdGlvbjogdSA9IG5ldyBfKCkgfSA9IHRoaXMuY2FsY0JvdW5kaW5nQm94KGUsIHQpIHx8IHt9O1xuICAgICAgICByZXR1cm4geyBjZW50ZXI6IGguYWRkKGwpLCBjb3JyZWN0aW9uOiB1LnN1YnRyYWN0KGwpLCBzaXplOiBjIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjZW50ZXI6IHMuZ2V0UmVsYXRpdmVDZW50ZXJQb2ludCgpLmFkZChsKSwgc2l6ZTogYyB9O1xuICAgIH1cbiAgfVxufVxueShZbywgXCJ0eXBlXCIsIFwiY2xpcC1wYXRoXCIpLCBDLnNldENsYXNzKFlvKTtcbmNsYXNzIFZvIGV4dGVuZHMgQ2kge1xuICBnZXRJbml0aWFsU2l6ZSh0LCBlKSB7XG4gICAgbGV0IHsgdGFyZ2V0OiBzIH0gPSB0LCB7IHNpemU6IHIgfSA9IGU7XG4gICAgcmV0dXJuIG5ldyBfKHMud2lkdGggfHwgci54LCBzLmhlaWdodCB8fCByLnkpO1xuICB9XG59XG55KFZvLCBcInR5cGVcIiwgXCJmaXhlZFwiKSwgQy5zZXRDbGFzcyhWbyk7XG5jbGFzcyBFZCBleHRlbmRzIFpzIHtcbiAgc3Vic2NyaWJlVGFyZ2V0cyh0KSB7XG4gICAgY29uc3QgZSA9IHQudGFyZ2V0O1xuICAgIHQudGFyZ2V0cy5yZWR1Y2UoKHMsIHIpID0+IChyLnBhcmVudCAmJiBzLmFkZChyLnBhcmVudCksIHMpLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBzLmxheW91dE1hbmFnZXIuc3Vic2NyaWJlVGFyZ2V0cyh7IHRhcmdldDogcywgdGFyZ2V0czogW2VdIH0pO1xuICAgIH0pO1xuICB9XG4gIHVuc3Vic2NyaWJlVGFyZ2V0cyh0KSB7XG4gICAgY29uc3QgZSA9IHQudGFyZ2V0LCBzID0gZS5nZXRPYmplY3RzKCk7XG4gICAgdC50YXJnZXRzLnJlZHVjZSgociwgbikgPT4gKG4ucGFyZW50ICYmIHIuYWRkKG4ucGFyZW50KSwgciksIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLmZvckVhY2goKHIpID0+IHtcbiAgICAgICFzLnNvbWUoKG4pID0+IG4ucGFyZW50ID09PSByKSAmJiByLmxheW91dE1hbmFnZXIudW5zdWJzY3JpYmVUYXJnZXRzKHsgdGFyZ2V0OiByLCB0YXJnZXRzOiBbZV0gfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIE90IGV4dGVuZHMgTnQge1xuICBzdGF0aWMgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHYodih7fSwgc3VwZXIuZ2V0RGVmYXVsdHMoKSksIE90Lm93bkRlZmF1bHRzKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogW10sIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHN1cGVyKCksIE9iamVjdC5hc3NpZ24odGhpcywgT3Qub3duRGVmYXVsdHMpLCB0aGlzLnNldE9wdGlvbnMoZSk7XG4gICAgY29uc3QgeyBsZWZ0OiBzLCB0b3A6IHIsIGxheW91dE1hbmFnZXI6IG4gfSA9IGU7XG4gICAgdGhpcy5ncm91cEluaXQodCwgeyBsZWZ0OiBzLCB0b3A6IHIsIGxheW91dE1hbmFnZXI6IG4gPz8gbmV3IEVkKCkgfSk7XG4gIH1cbiAgX3Nob3VsZFNldE5lc3RlZENvb3JkcygpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgX19vYmplY3RTZWxlY3Rpb25Nb25pdG9yKCkge1xuICB9XG4gIG11bHRpU2VsZWN0QWRkKCkge1xuICAgIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBlID0gbmV3IEFycmF5KHQpLCBzID0gMDsgcyA8IHQ7IHMrKykgZVtzXSA9IGFyZ3VtZW50c1tzXTtcbiAgICB0aGlzLm11bHRpU2VsZWN0aW9uU3RhY2tpbmcgPT09IFwic2VsZWN0aW9uLW9yZGVyXCIgPyB0aGlzLmFkZCguLi5lKSA6IGUuZm9yRWFjaCgocikgPT4ge1xuICAgICAgY29uc3QgbiA9IHRoaXMuX29iamVjdHMuZmluZEluZGV4KChhKSA9PiBhLmlzSW5Gcm9udE9mKHIpKSwgbyA9IG4gPT09IC0xID8gdGhpcy5zaXplKCkgOiBuO1xuICAgICAgdGhpcy5pbnNlcnRBdChvLCByKTtcbiAgICB9KTtcbiAgfVxuICBjYW5FbnRlckdyb3VwKHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RzKCkuc29tZSgoZSkgPT4gZS5pc0Rlc2NlbmRhbnRPZih0KSB8fCB0LmlzRGVzY2VuZGFudE9mKGUpKSA/IChUZShcImVycm9yXCIsIFwiQWN0aXZlU2VsZWN0aW9uOiBjaXJjdWxhciBvYmplY3QgdHJlZXMgYXJlIG5vdCBzdXBwb3J0ZWQsIHRoaXMgY2FsbCBoYXMgbm8gZWZmZWN0XCIpLCAhMSkgOiBzdXBlci5jYW5FbnRlckdyb3VwKHQpO1xuICB9XG4gIGVudGVyR3JvdXAodCwgZSkge1xuICAgIHQucGFyZW50ICYmIHQucGFyZW50ID09PSB0Lmdyb3VwID8gdC5wYXJlbnQuX2V4aXRHcm91cCh0KSA6IHQuZ3JvdXAgJiYgdC5wYXJlbnQgIT09IHQuZ3JvdXAgJiYgdC5ncm91cC5yZW1vdmUodCksIHRoaXMuX2VudGVyR3JvdXAodCwgZSk7XG4gIH1cbiAgZXhpdEdyb3VwKHQsIGUpIHtcbiAgICB0aGlzLl9leGl0R3JvdXAodCwgZSksIHQucGFyZW50ICYmIHQucGFyZW50Ll9lbnRlckdyb3VwKHQsICEwKTtcbiAgfVxuICBfb25BZnRlck9iamVjdHNDaGFuZ2UodCwgZSkge1xuICAgIHN1cGVyLl9vbkFmdGVyT2JqZWN0c0NoYW5nZSh0LCBlKTtcbiAgICBjb25zdCBzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBlLmZvckVhY2goKHIpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFyZW50OiBuIH0gPSByO1xuICAgICAgbiAmJiBzLmFkZChuKTtcbiAgICB9KSwgdCA9PT0gWm4gPyBzLmZvckVhY2goKHIpID0+IHtcbiAgICAgIHIuX29uQWZ0ZXJPYmplY3RzQ2hhbmdlKGVpLCBlKTtcbiAgICB9KSA6IHMuZm9yRWFjaCgocikgPT4ge1xuICAgICAgci5fc2V0KFwiZGlydHlcIiwgITApO1xuICAgIH0pO1xuICB9XG4gIG9uRGVzZWxlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsKCksICExO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIiM8QWN0aXZlU2VsZWN0aW9uOiAoXCIuY29uY2F0KHRoaXMuY29tcGxleGl0eSgpLCBcIik+XCIpO1xuICB9XG4gIHNob3VsZENhY2hlKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBpc09uQUNhY2hlKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBfcmVuZGVyQ29udHJvbHModCwgZSwgcykge1xuICAgIHQuc2F2ZSgpLCB0Lmdsb2JhbEFscGhhID0gdGhpcy5pc01vdmluZyA/IHRoaXMuYm9yZGVyT3BhY2l0eVdoZW5Nb3ZpbmcgOiAxO1xuICAgIGNvbnN0IHIgPSB2KHYoeyBoYXNDb250cm9sczogITEgfSwgcyksIHt9LCB7IGZvckFjdGl2ZVNlbGVjdGlvbjogITAgfSk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0aGlzLl9vYmplY3RzLmxlbmd0aDsgbisrKSB0aGlzLl9vYmplY3RzW25dLl9yZW5kZXJDb250cm9scyh0LCByKTtcbiAgICBzdXBlci5fcmVuZGVyQ29udHJvbHModCwgZSksIHQucmVzdG9yZSgpO1xuICB9XG59XG55KE90LCBcInR5cGVcIiwgXCJBY3RpdmVTZWxlY3Rpb25cIiksIHkoT3QsIFwib3duRGVmYXVsdHNcIiwgeyBtdWx0aVNlbGVjdGlvblN0YWNraW5nOiBcImNhbnZhcy1zdGFja2luZ1wiIH0pLCBDLnNldENsYXNzKE90KSwgQy5zZXRDbGFzcyhPdCwgXCJhY3RpdmVTZWxlY3Rpb25cIik7XG5jbGFzcyBQZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHkodGhpcywgXCJyZXNvdXJjZXNcIiwge30pO1xuICB9XG4gIGFwcGx5RmlsdGVycyh0LCBlLCBzLCByLCBuKSB7XG4gICAgY29uc3QgbyA9IG4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIG8uZHJhd0ltYWdlKGUsIDAsIDAsIHMsIHIpO1xuICAgIGNvbnN0IGEgPSB7IHNvdXJjZVdpZHRoOiBzLCBzb3VyY2VIZWlnaHQ6IHIsIGltYWdlRGF0YTogby5nZXRJbWFnZURhdGEoMCwgMCwgcywgciksIG9yaWdpbmFsRWw6IGUsIG9yaWdpbmFsSW1hZ2VEYXRhOiBvLmdldEltYWdlRGF0YSgwLCAwLCBzLCByKSwgY2FudmFzRWw6IG4sIGN0eDogbywgZmlsdGVyQmFja2VuZDogdGhpcyB9O1xuICAgIHQuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgbC5hcHBseVRvKGEpO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgaW1hZ2VEYXRhOiBjIH0gPSBhO1xuICAgIHJldHVybiBjLndpZHRoID09PSBzICYmIGMuaGVpZ2h0ID09PSByIHx8IChuLndpZHRoID0gYy53aWR0aCwgbi5oZWlnaHQgPSBjLmhlaWdodCksIG8ucHV0SW1hZ2VEYXRhKGMsIDAsIDApLCBhO1xuICB9XG59XG5jbGFzcyBvbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB7IHRpbGVTaXplOiB0ID0gQS50ZXh0dXJlU2l6ZSB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB5KHRoaXMsIFwiYVBvc2l0aW9uXCIsIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdKSksIHkodGhpcywgXCJyZXNvdXJjZXNcIiwge30pLCB0aGlzLnRpbGVTaXplID0gdCwgdGhpcy5zZXR1cEdMQ29udGV4dCh0LCB0KSwgdGhpcy5jYXB0dXJlR1BVSW5mbygpO1xuICB9XG4gIHNldHVwR0xDb250ZXh0KHQsIGUpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKSwgdGhpcy5jcmVhdGVXZWJHTENhbnZhcyh0LCBlKTtcbiAgfVxuICBjcmVhdGVXZWJHTENhbnZhcyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IFd0KHsgd2lkdGg6IHQsIGhlaWdodDogZSB9KSwgciA9IHMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHsgYWxwaGE6ICEwLCBwcmVtdWx0aXBsaWVkQWxwaGE6ICExLCBkZXB0aDogITEsIHN0ZW5jaWw6ICExLCBhbnRpYWxpYXM6ICExIH0pO1xuICAgIHIgJiYgKHIuY2xlYXJDb2xvcigwLCAwLCAwLCAwKSwgdGhpcy5jYW52YXMgPSBzLCB0aGlzLmdsID0gcik7XG4gIH1cbiAgYXBwbHlGaWx0ZXJzKHQsIGUsIHMsIHIsIG4sIG8pIHtcbiAgICBjb25zdCBhID0gdGhpcy5nbCwgYyA9IG4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICghYSB8fCAhYykgcmV0dXJuO1xuICAgIGxldCBsO1xuICAgIG8gJiYgKGwgPSB0aGlzLmdldENhY2hlZFRleHR1cmUobywgZSkpO1xuICAgIGNvbnN0IGggPSB7IG9yaWdpbmFsV2lkdGg6IGUud2lkdGggfHwgZS5uYXR1cmFsV2lkdGggfHwgMCwgb3JpZ2luYWxIZWlnaHQ6IGUuaGVpZ2h0IHx8IGUubmF0dXJhbEhlaWdodCB8fCAwLCBzb3VyY2VXaWR0aDogcywgc291cmNlSGVpZ2h0OiByLCBkZXN0aW5hdGlvbldpZHRoOiBzLCBkZXN0aW5hdGlvbkhlaWdodDogciwgY29udGV4dDogYSwgc291cmNlVGV4dHVyZTogdGhpcy5jcmVhdGVUZXh0dXJlKGEsIHMsIHIsIGwgPyB2b2lkIDAgOiBlKSwgdGFyZ2V0VGV4dHVyZTogdGhpcy5jcmVhdGVUZXh0dXJlKGEsIHMsIHIpLCBvcmlnaW5hbFRleHR1cmU6IGwgfHwgdGhpcy5jcmVhdGVUZXh0dXJlKGEsIHMsIHIsIGwgPyB2b2lkIDAgOiBlKSwgcGFzc2VzOiB0Lmxlbmd0aCwgd2ViZ2w6ICEwLCBhUG9zaXRpb246IHRoaXMuYVBvc2l0aW9uLCBwcm9ncmFtQ2FjaGU6IHRoaXMucHJvZ3JhbUNhY2hlLCBwYXNzOiAwLCBmaWx0ZXJCYWNrZW5kOiB0aGlzLCB0YXJnZXRDYW52YXM6IG4gfSwgdSA9IGEuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICByZXR1cm4gYS5iaW5kRnJhbWVidWZmZXIoYS5GUkFNRUJVRkZFUiwgdSksIHQuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgZCAmJiBkLmFwcGx5VG8oaCk7XG4gICAgfSksIGZ1bmN0aW9uKGQpIHtcbiAgICAgIGNvbnN0IGYgPSBkLnRhcmdldENhbnZhcywgZyA9IGYud2lkdGgsIHAgPSBmLmhlaWdodCwgbSA9IGQuZGVzdGluYXRpb25XaWR0aCwgYiA9IGQuZGVzdGluYXRpb25IZWlnaHQ7XG4gICAgICBnID09PSBtICYmIHAgPT09IGIgfHwgKGYud2lkdGggPSBtLCBmLmhlaWdodCA9IGIpO1xuICAgIH0oaCksIHRoaXMuY29weUdMVG8yRChhLCBoKSwgYS5iaW5kVGV4dHVyZShhLlRFWFRVUkVfMkQsIG51bGwpLCBhLmRlbGV0ZVRleHR1cmUoaC5zb3VyY2VUZXh0dXJlKSwgYS5kZWxldGVUZXh0dXJlKGgudGFyZ2V0VGV4dHVyZSksIGEuZGVsZXRlRnJhbWVidWZmZXIodSksIGMuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApLCBoO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jYW52YXMgJiYgKHRoaXMuY2FudmFzID0gbnVsbCwgdGhpcy5nbCA9IG51bGwpLCB0aGlzLmNsZWFyV2ViR0xDYWNoZXMoKTtcbiAgfVxuICBjbGVhcldlYkdMQ2FjaGVzKCkge1xuICAgIHRoaXMucHJvZ3JhbUNhY2hlID0ge30sIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gIH1cbiAgY3JlYXRlVGV4dHVyZSh0LCBlLCBzLCByLCBuKSB7XG4gICAgY29uc3QgeyBORUFSRVNUOiBvLCBURVhUVVJFXzJEOiBhLCBSR0JBOiBjLCBVTlNJR05FRF9CWVRFOiBsLCBDTEFNUF9UT19FREdFOiBoLCBURVhUVVJFX01BR19GSUxURVI6IHUsIFRFWFRVUkVfTUlOX0ZJTFRFUjogZCwgVEVYVFVSRV9XUkFQX1M6IGYsIFRFWFRVUkVfV1JBUF9UOiBnIH0gPSB0LCBwID0gdC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgcmV0dXJuIHQuYmluZFRleHR1cmUoYSwgcCksIHQudGV4UGFyYW1ldGVyaShhLCB1LCBuIHx8IG8pLCB0LnRleFBhcmFtZXRlcmkoYSwgZCwgbiB8fCBvKSwgdC50ZXhQYXJhbWV0ZXJpKGEsIGYsIGgpLCB0LnRleFBhcmFtZXRlcmkoYSwgZywgaCksIHIgPyB0LnRleEltYWdlMkQoYSwgMCwgYywgYywgbCwgcikgOiB0LnRleEltYWdlMkQoYSwgMCwgYywgZSwgcywgMCwgYywgbCwgbnVsbCksIHA7XG4gIH1cbiAgZ2V0Q2FjaGVkVGV4dHVyZSh0LCBlLCBzKSB7XG4gICAgY29uc3QgeyB0ZXh0dXJlQ2FjaGU6IHIgfSA9IHRoaXM7XG4gICAgaWYgKHJbdF0pIHJldHVybiByW3RdO1xuICAgIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmNyZWF0ZVRleHR1cmUodGhpcy5nbCwgZS53aWR0aCwgZS5oZWlnaHQsIGUsIHMpO1xuICAgICAgcmV0dXJuIG4gJiYgKHJbdF0gPSBuKSwgbjtcbiAgICB9XG4gIH1cbiAgZXZpY3RDYWNoZXNGb3JLZXkodCkge1xuICAgIHRoaXMudGV4dHVyZUNhY2hlW3RdICYmICh0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlQ2FjaGVbdF0pLCBkZWxldGUgdGhpcy50ZXh0dXJlQ2FjaGVbdF0pO1xuICB9XG4gIGNvcHlHTFRvMkQodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0LmNhbnZhcywgciA9IGUudGFyZ2V0Q2FudmFzLCBuID0gci5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFuKSByZXR1cm47XG4gICAgbi50cmFuc2xhdGUoMCwgci5oZWlnaHQpLCBuLnNjYWxlKDEsIC0xKTtcbiAgICBjb25zdCBvID0gcy5oZWlnaHQgLSByLmhlaWdodDtcbiAgICBuLmRyYXdJbWFnZShzLCAwLCBvLCByLndpZHRoLCByLmhlaWdodCwgMCwgMCwgci53aWR0aCwgci5oZWlnaHQpO1xuICB9XG4gIGNvcHlHTFRvMkRQdXRJbWFnZURhdGEodCwgZSkge1xuICAgIGNvbnN0IHMgPSBlLnRhcmdldENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksIHIgPSBlLmRlc3RpbmF0aW9uV2lkdGgsIG4gPSBlLmRlc3RpbmF0aW9uSGVpZ2h0LCBvID0gciAqIG4gKiA0O1xuICAgIGlmICghcykgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBuZXcgVWludDhBcnJheSh0aGlzLmltYWdlQnVmZmVyLCAwLCBvKSwgYyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLmltYWdlQnVmZmVyLCAwLCBvKTtcbiAgICB0LnJlYWRQaXhlbHMoMCwgMCwgciwgbiwgdC5SR0JBLCB0LlVOU0lHTkVEX0JZVEUsIGEpO1xuICAgIGNvbnN0IGwgPSBuZXcgSW1hZ2VEYXRhKGMsIHIsIG4pO1xuICAgIHMucHV0SW1hZ2VEYXRhKGwsIDAsIDApO1xuICB9XG4gIGNhcHR1cmVHUFVJbmZvKCkge1xuICAgIGlmICh0aGlzLmdwdUluZm8pIHJldHVybiB0aGlzLmdwdUluZm87XG4gICAgY29uc3QgdCA9IHRoaXMuZ2wsIGUgPSB7IHJlbmRlcmVyOiBcIlwiLCB2ZW5kb3I6IFwiXCIgfTtcbiAgICBpZiAoIXQpIHJldHVybiBlO1xuICAgIGNvbnN0IHMgPSB0LmdldEV4dGVuc2lvbihcIldFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm9cIik7XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IHIgPSB0LmdldFBhcmFtZXRlcihzLlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMKSwgbiA9IHQuZ2V0UGFyYW1ldGVyKHMuVU5NQVNLRURfVkVORE9SX1dFQkdMKTtcbiAgICAgIHIgJiYgKGUucmVuZGVyZXIgPSByLnRvTG93ZXJDYXNlKCkpLCBuICYmIChlLnZlbmRvciA9IG4udG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdUluZm8gPSBlLCBlO1xuICB9XG59XG5sZXQgVWk7XG5mdW5jdGlvbiBBZCgpIHtcbiAgY29uc3QgeyBXZWJHTFByb2JlOiBpIH0gPSAkdCgpO1xuICByZXR1cm4gaS5xdWVyeVdlYkdMKGt0KCkpLCBBLmVuYWJsZUdMRmlsdGVyaW5nICYmIGkuaXNTdXBwb3J0ZWQoQS50ZXh0dXJlU2l6ZSkgPyBuZXcgb2woeyB0aWxlU2l6ZTogQS50ZXh0dXJlU2l6ZSB9KSA6IG5ldyBQZCgpO1xufVxuZnVuY3Rpb24gJGkoKSB7XG4gIHJldHVybiAhVWkgJiYgKCEoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDApIHx8IGFyZ3VtZW50c1swXSkgJiYgKFVpID0gQWQoKSksIFVpO1xufVxuY29uc3QgRmQgPSBbXCJmaWx0ZXJzXCIsIFwicmVzaXplRmlsdGVyXCIsIFwic3JjXCIsIFwiY3Jvc3NPcmlnaW5cIiwgXCJ0eXBlXCJdLCBhbCA9IFtcImNyb3BYXCIsIFwiY3JvcFlcIl07XG5jbGFzcyB3dCBleHRlbmRzIG50IHtcbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB2KHYoe30sIHN1cGVyLmdldERlZmF1bHRzKCkpLCB3dC5vd25EZWZhdWx0cyk7XG4gIH1cbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKCksIHkodGhpcywgXCJfbGFzdFNjYWxlWFwiLCAxKSwgeSh0aGlzLCBcIl9sYXN0U2NhbGVZXCIsIDEpLCB5KHRoaXMsIFwiX2ZpbHRlclNjYWxpbmdYXCIsIDEpLCB5KHRoaXMsIFwiX2ZpbHRlclNjYWxpbmdZXCIsIDEpLCB0aGlzLmZpbHRlcnMgPSBbXSwgT2JqZWN0LmFzc2lnbih0aGlzLCB3dC5vd25EZWZhdWx0cyksIHRoaXMuc2V0T3B0aW9ucyhlKSwgdGhpcy5jYWNoZUtleSA9IFwidGV4dHVyZVwiLmNvbmNhdCh3ZSgpKSwgdGhpcy5zZXRFbGVtZW50KHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyAodGhpcy5jYW52YXMgJiYgQXQodGhpcy5jYW52YXMuZ2V0RWxlbWVudCgpKSB8fCBDcygpKS5nZXRFbGVtZW50QnlJZCh0KSA6IHQsIGUpO1xuICB9XG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgc2V0RWxlbWVudCh0KSB7XG4gICAgdmFyIGU7XG4gICAgbGV0IHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5KSwgdGhpcy5yZW1vdmVUZXh0dXJlKFwiXCIuY29uY2F0KHRoaXMuY2FjaGVLZXksIFwiX2ZpbHRlcmVkXCIpKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29yaWdpbmFsRWxlbWVudCA9IHQsIHRoaXMuX3NldFdpZHRoSGVpZ2h0KHMpLCAoZSA9IHQuY2xhc3NMaXN0KSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgfHwgZS5hZGQod3QuQ1NTX0NBTlZBUyksIHRoaXMuZmlsdGVycy5sZW5ndGggIT09IDAgJiYgdGhpcy5hcHBseUZpbHRlcnMoKSwgdGhpcy5yZXNpemVGaWx0ZXIgJiYgdGhpcy5hcHBseVJlc2l6ZUZpbHRlcnMoKTtcbiAgfVxuICByZW1vdmVUZXh0dXJlKHQpIHtcbiAgICBjb25zdCBlID0gJGkoITEpO1xuICAgIGUgaW5zdGFuY2VvZiBvbCAmJiBlLmV2aWN0Q2FjaGVzRm9yS2V5KHQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpLCB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSksIHRoaXMucmVtb3ZlVGV4dHVyZShcIlwiLmNvbmNhdCh0aGlzLmNhY2hlS2V5LCBcIl9maWx0ZXJlZFwiKSksIHRoaXMuX2NhY2hlQ29udGV4dCA9IG51bGwsIFtcIl9vcmlnaW5hbEVsZW1lbnRcIiwgXCJfZWxlbWVudFwiLCBcIl9maWx0ZXJlZEVsXCIsIFwiX2NhY2hlQ2FudmFzXCJdLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzW3RdO1xuICAgICAgZSAmJiAkdCgpLmRpc3Bvc2UoZSksIHRoaXNbdF0gPSB2b2lkIDA7XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q3Jvc3NPcmlnaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsRWxlbWVudCAmJiAodGhpcy5fb3JpZ2luYWxFbGVtZW50LmNyb3NzT3JpZ2luIHx8IG51bGwpO1xuICB9XG4gIGdldE9yaWdpbmFsU2l6ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgcmV0dXJuIHQgPyB7IHdpZHRoOiB0Lm5hdHVyYWxXaWR0aCB8fCB0LndpZHRoLCBoZWlnaHQ6IHQubmF0dXJhbEhlaWdodCB8fCB0LmhlaWdodCB9IDogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gIH1cbiAgX3N0cm9rZSh0KSB7XG4gICAgaWYgKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMud2lkdGggLyAyLCBzID0gdGhpcy5oZWlnaHQgLyAyO1xuICAgIHQuYmVnaW5QYXRoKCksIHQubW92ZVRvKC1lLCAtcyksIHQubGluZVRvKGUsIC1zKSwgdC5saW5lVG8oZSwgcyksIHQubGluZVRvKC1lLCBzKSwgdC5saW5lVG8oLWUsIC1zKSwgdC5jbG9zZVBhdGgoKTtcbiAgfVxuICB0b09iamVjdCgpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHJldHVybiB0aGlzLmZpbHRlcnMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgcyAmJiBlLnB1c2gocy50b09iamVjdCgpKTtcbiAgICB9KSwgdih2KHt9LCBzdXBlci50b09iamVjdChbLi4uYWwsIC4uLnRdKSksIHt9LCB7IHNyYzogdGhpcy5nZXRTcmMoKSwgY3Jvc3NPcmlnaW46IHRoaXMuZ2V0Q3Jvc3NPcmlnaW4oKSwgZmlsdGVyczogZSB9LCB0aGlzLnJlc2l6ZUZpbHRlciA/IHsgcmVzaXplRmlsdGVyOiB0aGlzLnJlc2l6ZUZpbHRlci50b09iamVjdCgpIH0gOiB7fSk7XG4gIH1cbiAgaGFzQ3JvcCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmNyb3BYIHx8ICEhdGhpcy5jcm9wWSB8fCB0aGlzLndpZHRoIDwgdGhpcy5fZWxlbWVudC53aWR0aCB8fCB0aGlzLmhlaWdodCA8IHRoaXMuX2VsZW1lbnQuaGVpZ2h0O1xuICB9XG4gIF90b1NWRygpIHtcbiAgICBjb25zdCB0ID0gW10sIGUgPSB0aGlzLl9lbGVtZW50LCBzID0gLXRoaXMud2lkdGggLyAyLCByID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICBsZXQgbiA9IFtdLCBvID0gW10sIGEgPSBcIlwiLCBjID0gXCJcIjtcbiAgICBpZiAoIWUpIHJldHVybiBbXTtcbiAgICBpZiAodGhpcy5oYXNDcm9wKCkpIHtcbiAgICAgIGNvbnN0IGwgPSB3ZSgpO1xuICAgICAgbi5wdXNoKCc8Y2xpcFBhdGggaWQ9XCJpbWFnZUNyb3BfJyArIGwgKyBgXCI+XG5gLCAnXHQ8cmVjdCB4PVwiJyArIHMgKyAnXCIgeT1cIicgKyByICsgJ1wiIHdpZHRoPVwiJyArIHRoaXMud2lkdGggKyAnXCIgaGVpZ2h0PVwiJyArIHRoaXMuaGVpZ2h0ICsgYFwiIC8+XG5gLCBgPC9jbGlwUGF0aD5cbmApLCBhID0gJyBjbGlwLXBhdGg9XCJ1cmwoI2ltYWdlQ3JvcF8nICsgbCArICcpXCIgJztcbiAgICB9XG4gICAgaWYgKHRoaXMuaW1hZ2VTbW9vdGhpbmcgfHwgKGMgPSAnIGltYWdlLXJlbmRlcmluZz1cIm9wdGltaXplU3BlZWRcIicpLCB0LnB1c2goXCJcdDxpbWFnZSBcIiwgXCJDT01NT05fUEFSVFNcIiwgJ3hsaW5rOmhyZWY9XCInLmNvbmNhdCh0aGlzLmdldFN2Z1NyYyghMCksICdcIiB4PVwiJykuY29uY2F0KHMgLSB0aGlzLmNyb3BYLCAnXCIgeT1cIicpLmNvbmNhdChyIC0gdGhpcy5jcm9wWSwgJ1wiIHdpZHRoPVwiJykuY29uY2F0KGUud2lkdGggfHwgZS5uYXR1cmFsV2lkdGgsICdcIiBoZWlnaHQ9XCInKS5jb25jYXQoZS5oZWlnaHQgfHwgZS5uYXR1cmFsSGVpZ2h0LCAnXCInKS5jb25jYXQoYykuY29uY2F0KGEsIGA+PC9pbWFnZT5cbmApKSwgdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VEYXNoQXJyYXkpIHtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLmZpbGw7XG4gICAgICB0aGlzLmZpbGwgPSBudWxsLCBvID0gWydcdDxyZWN0IHg9XCInLmNvbmNhdChzLCAnXCIgeT1cIicpLmNvbmNhdChyLCAnXCIgd2lkdGg9XCInKS5jb25jYXQodGhpcy53aWR0aCwgJ1wiIGhlaWdodD1cIicpLmNvbmNhdCh0aGlzLmhlaWdodCwgJ1wiIHN0eWxlPVwiJykuY29uY2F0KHRoaXMuZ2V0U3ZnU3R5bGVzKCksIGBcIiAvPlxuYCldLCB0aGlzLmZpbGwgPSBsO1xuICAgIH1cbiAgICByZXR1cm4gbiA9IHRoaXMucGFpbnRGaXJzdCAhPT0gcnQgPyBuLmNvbmNhdChvLCB0KSA6IG4uY29uY2F0KHQsIG8pLCBuO1xuICB9XG4gIGdldFNyYyh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyB0aGlzLl9lbGVtZW50IDogdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgIHJldHVybiBlID8gZS50b0RhdGFVUkwgPyBlLnRvRGF0YVVSTCgpIDogdGhpcy5zcmNGcm9tQXR0cmlidXRlID8gZS5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgfHwgXCJcIiA6IGUuc3JjIDogdGhpcy5zcmMgfHwgXCJcIjtcbiAgfVxuICBnZXRTdmdTcmModCkge1xuICAgIHJldHVybiB0aGlzLmdldFNyYyh0KTtcbiAgfVxuICBzZXRTcmModCkge1xuICAgIGxldCB7IGNyb3NzT3JpZ2luOiBlLCBzaWduYWw6IHMgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIFlzKHQsIHsgY3Jvc3NPcmlnaW46IGUsIHNpZ25hbDogcyB9KS50aGVuKChyKSA9PiB7XG4gICAgICBlICE9PSB2b2lkIDAgJiYgdGhpcy5zZXQoeyBjcm9zc09yaWdpbjogZSB9KSwgdGhpcy5zZXRFbGVtZW50KHIpO1xuICAgIH0pO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnIzxJbWFnZTogeyBzcmM6IFwiJy5jb25jYXQodGhpcy5nZXRTcmMoKSwgJ1wiIH0+Jyk7XG4gIH1cbiAgYXBwbHlSZXNpemVGaWx0ZXJzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnJlc2l6ZUZpbHRlciwgZSA9IHRoaXMubWluaW11bVNjYWxlVHJpZ2dlciwgcyA9IHRoaXMuZ2V0VG90YWxPYmplY3RTY2FsaW5nKCksIHIgPSBzLngsIG4gPSBzLnksIG8gPSB0aGlzLl9maWx0ZXJlZEVsIHx8IHRoaXMuX29yaWdpbmFsRWxlbWVudDtcbiAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLnNldChcImRpcnR5XCIsICEwKSwgIXQgfHwgciA+IGUgJiYgbiA+IGUpIHJldHVybiB0aGlzLl9lbGVtZW50ID0gbywgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxLCB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDEsIHRoaXMuX2xhc3RTY2FsZVggPSByLCB2b2lkICh0aGlzLl9sYXN0U2NhbGVZID0gbik7XG4gICAgY29uc3QgYSA9IFd0KG8pLCB7IHdpZHRoOiBjLCBoZWlnaHQ6IGwgfSA9IG87XG4gICAgdGhpcy5fZWxlbWVudCA9IGEsIHRoaXMuX2xhc3RTY2FsZVggPSB0LnNjYWxlWCA9IHIsIHRoaXMuX2xhc3RTY2FsZVkgPSB0LnNjYWxlWSA9IG4sICRpKCkuYXBwbHlGaWx0ZXJzKFt0XSwgbywgYywgbCwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2ZpbHRlclNjYWxpbmdYID0gYS53aWR0aCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aCwgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSBhLmhlaWdodCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC5oZWlnaHQ7XG4gIH1cbiAgYXBwbHlGaWx0ZXJzKCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmZpbHRlcnMgfHwgW107XG4gICAgaWYgKHQgPSB0LmZpbHRlcigobikgPT4gbiAmJiAhbi5pc05ldXRyYWxTdGF0ZSgpKSwgdGhpcy5zZXQoXCJkaXJ0eVwiLCAhMCksIHRoaXMucmVtb3ZlVGV4dHVyZShcIlwiLmNvbmNhdCh0aGlzLmNhY2hlS2V5LCBcIl9maWx0ZXJlZFwiKSksIHQubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZWxlbWVudCA9IHRoaXMuX29yaWdpbmFsRWxlbWVudCwgdGhpcy5fZmlsdGVyZWRFbCA9IHZvaWQgMCwgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxLCB2b2lkICh0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDEpO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9vcmlnaW5hbEVsZW1lbnQsIHMgPSBlLm5hdHVyYWxXaWR0aCB8fCBlLndpZHRoLCByID0gZS5uYXR1cmFsSGVpZ2h0IHx8IGUuaGVpZ2h0O1xuICAgIGlmICh0aGlzLl9lbGVtZW50ID09PSB0aGlzLl9vcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG4gPSBXdCh7IHdpZHRoOiBzLCBoZWlnaHQ6IHIgfSk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbiwgdGhpcy5fZmlsdGVyZWRFbCA9IG47XG4gICAgfSBlbHNlIHRoaXMuX2ZpbHRlcmVkRWwgJiYgKHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9maWx0ZXJlZEVsLCB0aGlzLl9maWx0ZXJlZEVsLmdldENvbnRleHQoXCIyZFwiKS5jbGVhclJlY3QoMCwgMCwgcywgciksIHRoaXMuX2xhc3RTY2FsZVggPSAxLCB0aGlzLl9sYXN0U2NhbGVZID0gMSk7XG4gICAgJGkoKS5hcHBseUZpbHRlcnModCwgdGhpcy5fb3JpZ2luYWxFbGVtZW50LCBzLCByLCB0aGlzLl9lbGVtZW50LCB0aGlzLmNhY2hlS2V5KSwgdGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoID09PSB0aGlzLl9lbGVtZW50LndpZHRoICYmIHRoaXMuX29yaWdpbmFsRWxlbWVudC5oZWlnaHQgPT09IHRoaXMuX2VsZW1lbnQuaGVpZ2h0IHx8ICh0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IHRoaXMuX2VsZW1lbnQud2lkdGggLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQud2lkdGgsIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gdGhpcy5fZWxlbWVudC5oZWlnaHQgLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0KTtcbiAgfVxuICBfcmVuZGVyKHQpIHtcbiAgICB0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRoaXMuaW1hZ2VTbW9vdGhpbmcsIHRoaXMuaXNNb3ZpbmcgIT09ICEwICYmIHRoaXMucmVzaXplRmlsdGVyICYmIHRoaXMuX25lZWRzUmVzaXplKCkgJiYgdGhpcy5hcHBseVJlc2l6ZUZpbHRlcnMoKSwgdGhpcy5fc3Ryb2tlKHQpLCB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIodCk7XG4gIH1cbiAgZHJhd0NhY2hlT25DYW52YXModCkge1xuICAgIHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdGhpcy5pbWFnZVNtb290aGluZywgc3VwZXIuZHJhd0NhY2hlT25DYW52YXModCk7XG4gIH1cbiAgc2hvdWxkQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVlZHNJdHNPd25DYWNoZSgpO1xuICB9XG4gIF9yZW5kZXJGaWxsKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZWxlbWVudDtcbiAgICBpZiAoIWUpIHJldHVybjtcbiAgICBjb25zdCBzID0gdGhpcy5fZmlsdGVyU2NhbGluZ1gsIHIgPSB0aGlzLl9maWx0ZXJTY2FsaW5nWSwgbiA9IHRoaXMud2lkdGgsIG8gPSB0aGlzLmhlaWdodCwgYSA9IE1hdGgubWF4KHRoaXMuY3JvcFgsIDApLCBjID0gTWF0aC5tYXgodGhpcy5jcm9wWSwgMCksIGwgPSBlLm5hdHVyYWxXaWR0aCB8fCBlLndpZHRoLCBoID0gZS5uYXR1cmFsSGVpZ2h0IHx8IGUuaGVpZ2h0LCB1ID0gYSAqIHMsIGQgPSBjICogciwgZiA9IE1hdGgubWluKG4gKiBzLCBsIC0gdSksIGcgPSBNYXRoLm1pbihvICogciwgaCAtIGQpLCBwID0gLW4gLyAyLCBtID0gLW8gLyAyLCBiID0gTWF0aC5taW4obiwgbCAvIHMgLSBhKSwgUyA9IE1hdGgubWluKG8sIGggLyByIC0gYyk7XG4gICAgZSAmJiB0LmRyYXdJbWFnZShlLCB1LCBkLCBmLCBnLCBwLCBtLCBiLCBTKTtcbiAgfVxuICBfbmVlZHNSZXNpemUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0VG90YWxPYmplY3RTY2FsaW5nKCk7XG4gICAgcmV0dXJuIHQueCAhPT0gdGhpcy5fbGFzdFNjYWxlWCB8fCB0LnkgIT09IHRoaXMuX2xhc3RTY2FsZVk7XG4gIH1cbiAgX3Jlc2V0V2lkdGhIZWlnaHQoKSB7XG4gICAgdGhpcy5zZXQodGhpcy5nZXRPcmlnaW5hbFNpemUoKSk7XG4gIH1cbiAgX3NldFdpZHRoSGVpZ2h0KCkge1xuICAgIGxldCB7IHdpZHRoOiB0LCBoZWlnaHQ6IGUgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0T3JpZ2luYWxTaXplKCk7XG4gICAgdGhpcy53aWR0aCA9IHQgfHwgcy53aWR0aCwgdGhpcy5oZWlnaHQgPSBlIHx8IHMuaGVpZ2h0O1xuICB9XG4gIHBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZSgpIHtcbiAgICBjb25zdCB0ID0gcWEodGhpcy5wcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8IFwiXCIpLCBlID0gdGhpcy53aWR0aCwgcyA9IHRoaXMuaGVpZ2h0LCByID0geyB3aWR0aDogZSwgaGVpZ2h0OiBzIH07XG4gICAgbGV0IG4sIG8gPSB0aGlzLl9lbGVtZW50LndpZHRoLCBhID0gdGhpcy5fZWxlbWVudC5oZWlnaHQsIGMgPSAxLCBsID0gMSwgaCA9IDAsIHUgPSAwLCBkID0gMCwgZiA9IDA7XG4gICAgcmV0dXJuICF0IHx8IHQuYWxpZ25YID09PSBwdCAmJiB0LmFsaWduWSA9PT0gcHQgPyAoYyA9IGUgLyBvLCBsID0gcyAvIGEpIDogKHQubWVldE9yU2xpY2UgPT09IFwibWVldFwiICYmIChjID0gbCA9IExjKHRoaXMuX2VsZW1lbnQsIHIpLCBuID0gKGUgLSBvICogYykgLyAyLCB0LmFsaWduWCA9PT0gXCJNaW5cIiAmJiAoaCA9IC1uKSwgdC5hbGlnblggPT09IFwiTWF4XCIgJiYgKGggPSBuKSwgbiA9IChzIC0gYSAqIGwpIC8gMiwgdC5hbGlnblkgPT09IFwiTWluXCIgJiYgKHUgPSAtbiksIHQuYWxpZ25ZID09PSBcIk1heFwiICYmICh1ID0gbikpLCB0Lm1lZXRPclNsaWNlID09PSBcInNsaWNlXCIgJiYgKGMgPSBsID0gQmModGhpcy5fZWxlbWVudCwgciksIG4gPSBvIC0gZSAvIGMsIHQuYWxpZ25YID09PSBcIk1pZFwiICYmIChkID0gbiAvIDIpLCB0LmFsaWduWCA9PT0gXCJNYXhcIiAmJiAoZCA9IG4pLCBuID0gYSAtIHMgLyBsLCB0LmFsaWduWSA9PT0gXCJNaWRcIiAmJiAoZiA9IG4gLyAyKSwgdC5hbGlnblkgPT09IFwiTWF4XCIgJiYgKGYgPSBuKSwgbyA9IGUgLyBjLCBhID0gcyAvIGwpKSwgeyB3aWR0aDogbywgaGVpZ2h0OiBhLCBzY2FsZVg6IGMsIHNjYWxlWTogbCwgb2Zmc2V0TGVmdDogaCwgb2Zmc2V0VG9wOiB1LCBjcm9wWDogZCwgY3JvcFk6IGYgfTtcbiAgfVxuICBzdGF0aWMgZnJvbU9iamVjdCh0LCBlKSB7XG4gICAgbGV0IHsgZmlsdGVyczogcywgcmVzaXplRmlsdGVyOiByLCBzcmM6IG4sIGNyb3NzT3JpZ2luOiBvLCB0eXBlOiBhIH0gPSB0LCBjID0gRyh0LCBGZCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtZcyhuLCB2KHYoe30sIGUpLCB7fSwgeyBjcm9zc09yaWdpbjogbyB9KSksIHMgJiYgYnMocywgZSksIHIgJiYgYnMoW3JdLCBlKSwgY3IoYywgZSldKS50aGVuKChsKSA9PiB7XG4gICAgICBsZXQgW2gsIHUgPSBbXSwgW2RdID0gW10sIGYgPSB7fV0gPSBsO1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKGgsIHYodih7fSwgYyksIHt9LCB7IHNyYzogbiwgZmlsdGVyczogdSwgcmVzaXplRmlsdGVyOiBkIH0sIGYpKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZnJvbVVSTCh0KSB7XG4gICAgbGV0IHsgY3Jvc3NPcmlnaW46IGUgPSBudWxsLCBzaWduYWw6IHMgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge30sIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHZvaWQgMDtcbiAgICByZXR1cm4gWXModCwgeyBjcm9zc09yaWdpbjogZSwgc2lnbmFsOiBzIH0pLnRoZW4oKG4pID0+IG5ldyB0aGlzKG4sIHIpKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVsZW1lbnQodCkge1xuICAgIGxldCBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fSwgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdm9pZCAwO1xuICAgIGNvbnN0IHIgPSBmZSh0LCB0aGlzLkFUVFJJQlVURV9OQU1FUywgcyk7XG4gICAgcmV0dXJuIHRoaXMuZnJvbVVSTChyW1wieGxpbms6aHJlZlwiXSwgZSwgcikuY2F0Y2goKG4pID0+IChUZShcImxvZ1wiLCBcIlVuYWJsZSB0byBwYXJzZSBJbWFnZVwiLCBuKSwgbnVsbCkpO1xuICB9XG59XG55KHd0LCBcInR5cGVcIiwgXCJJbWFnZVwiKSwgeSh3dCwgXCJjYWNoZVByb3BlcnRpZXNcIiwgWy4uLmRlLCAuLi5hbF0pLCB5KHd0LCBcIm93bkRlZmF1bHRzXCIsIHsgc3Ryb2tlV2lkdGg6IDAsIHNyY0Zyb21BdHRyaWJ1dGU6ICExLCBtaW5pbXVtU2NhbGVUcmlnZ2VyOiAwLjUsIGNyb3BYOiAwLCBjcm9wWTogMCwgaW1hZ2VTbW9vdGhpbmc6ICEwIH0pLCB5KHd0LCBcIkNTU19DQU5WQVNcIiwgXCJjYW52YXMtaW1nXCIpLCB5KHd0LCBcIkFUVFJJQlVURV9OQU1FU1wiLCBbLi4uRGUsIFwieFwiLCBcInlcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJ4bGluazpocmVmXCIsIFwiY3Jvc3NPcmlnaW5cIiwgXCJpbWFnZS1yZW5kZXJpbmdcIl0pLCBDLnNldENsYXNzKHd0KSwgQy5zZXRTVkdDbGFzcyh3dCk7XG5faShbXCJwYXR0ZXJuXCIsIFwiZGVmc1wiLCBcInN5bWJvbFwiLCBcIm1ldGFkYXRhXCIsIFwiY2xpcFBhdGhcIiwgXCJtYXNrXCIsIFwiZGVzY1wiXSk7XG5jb25zdCBjbCA9IFhhLCBHbyA9IChpKSA9PiBmdW5jdGlvbih0LCBlLCBzKSB7XG4gIGNvbnN0IHsgcG9pbnRzOiByLCBwYXRoT2Zmc2V0OiBuIH0gPSBzO1xuICByZXR1cm4gbmV3IF8ocltpXSkuc3VidHJhY3QobikudHJhbnNmb3JtKEoocy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLCBzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSkpO1xufSwgbGwgPSAoaSwgdCwgZSwgcykgPT4ge1xuICBjb25zdCB7IHRhcmdldDogciwgcG9pbnRJbmRleDogbiB9ID0gdCwgbyA9IHIsIGEgPSBhZShuZXcgXyhlLCBzKSwgdm9pZCAwLCBvLmNhbGNPd25NYXRyaXgoKSk7XG4gIHJldHVybiBvLnBvaW50c1tuXSA9IGEuYWRkKG8ucGF0aE9mZnNldCksIG8uc2V0RGltZW5zaW9ucygpLCAhMDtcbn0sIGhsID0gKGksIHQpID0+IGZ1bmN0aW9uKGUsIHMsIHIsIG4pIHtcbiAgY29uc3QgbyA9IHMudGFyZ2V0LCBhID0gbmV3IF8oby5wb2ludHNbKGkgPiAwID8gaSA6IG8ucG9pbnRzLmxlbmd0aCkgLSAxXSksIGMgPSBhLnN1YnRyYWN0KG8ucGF0aE9mZnNldCkudHJhbnNmb3JtKG8uY2FsY093bk1hdHJpeCgpKSwgbCA9IHQoZSwgdih2KHt9LCBzKSwge30sIHsgcG9pbnRJbmRleDogaSB9KSwgciwgbiksIGggPSBhLnN1YnRyYWN0KG8ucGF0aE9mZnNldCkudHJhbnNmb3JtKG8uY2FsY093bk1hdHJpeCgpKS5zdWJ0cmFjdChjKTtcbiAgcmV0dXJuIG8ubGVmdCAtPSBoLngsIG8udG9wIC09IGgueSwgbDtcbn0sIE5vID0gKGkpID0+IEllKGNsLCBobChpLCBsbCkpLCBibiA9IChpLCB0LCBlKSA9PiB7XG4gIGNvbnN0IHsgcGF0aDogcywgcGF0aE9mZnNldDogciB9ID0gaSwgbiA9IHNbdF07XG4gIHJldHVybiBuZXcgXyhuW2VdIC0gci54LCBuW2UgKyAxXSAtIHIueSkudHJhbnNmb3JtKEooaS5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLCBpLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSkpO1xufTtcbmZ1bmN0aW9uIFJkKGksIHQsIGUpIHtcbiAgY29uc3QgeyBjb21tYW5kSW5kZXg6IHMsIHBvaW50SW5kZXg6IHIgfSA9IHRoaXM7XG4gIHJldHVybiBibihlLCBzLCByKTtcbn1cbmZ1bmN0aW9uIExkKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyB0YXJnZXQ6IHIgfSA9IHQsIHsgY29tbWFuZEluZGV4OiBuLCBwb2ludEluZGV4OiBvIH0gPSB0aGlzLCBhID0gKChjLCBsLCBoLCB1LCBkKSA9PiB7XG4gICAgY29uc3QgeyBwYXRoOiBmLCBwYXRoT2Zmc2V0OiBnIH0gPSBjLCBwID0gZlsodSA+IDAgPyB1IDogZi5sZW5ndGgpIC0gMV0sIG0gPSBuZXcgXyhwW2RdLCBwW2QgKyAxXSksIGIgPSBtLnN1YnRyYWN0KGcpLnRyYW5zZm9ybShjLmNhbGNPd25NYXRyaXgoKSksIFMgPSBhZShuZXcgXyhsLCBoKSwgdm9pZCAwLCBjLmNhbGNPd25NYXRyaXgoKSk7XG4gICAgZlt1XVtkXSA9IFMueCArIGcueCwgZlt1XVtkICsgMV0gPSBTLnkgKyBnLnksIGMuc2V0RGltZW5zaW9ucygpO1xuICAgIGNvbnN0IHcgPSBtLnN1YnRyYWN0KGMucGF0aE9mZnNldCkudHJhbnNmb3JtKGMuY2FsY093bk1hdHJpeCgpKS5zdWJ0cmFjdChiKTtcbiAgICByZXR1cm4gYy5sZWZ0IC09IHcueCwgYy50b3AgLT0gdy55LCBjLnNldChcImRpcnR5XCIsICEwKSwgITA7XG4gIH0pKHIsIGUsIHMsIG4sIG8pO1xuICByZXR1cm4gSG4odGhpcy5hY3Rpb25OYW1lLCB2KHYoe30sIFluKGksIHQsIGUsIHMpKSwge30sIHsgY29tbWFuZEluZGV4OiBuLCBwb2ludEluZGV4OiBvIH0pKSwgYTtcbn1cbmNsYXNzIHVsIGV4dGVuZHMgVSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcih0KTtcbiAgfVxuICByZW5kZXIodCwgZSwgcywgciwgbikge1xuICAgIGNvbnN0IG8gPSB2KHYoe30sIHIpLCB7fSwgeyBjb3JuZXJDb2xvcjogdGhpcy5jb250cm9sRmlsbCwgY29ybmVyU3Ryb2tlQ29sb3I6IHRoaXMuY29udHJvbFN0cm9rZSwgdHJhbnNwYXJlbnRDb3JuZXJzOiAhdGhpcy5jb250cm9sRmlsbCB9KTtcbiAgICBzdXBlci5yZW5kZXIodCwgZSwgcywgbywgbik7XG4gIH1cbn1cbmNsYXNzIEJkIGV4dGVuZHMgdWwge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCk7XG4gIH1cbiAgcmVuZGVyKHQsIGUsIHMsIHIsIG4pIHtcbiAgICBjb25zdCB7IHBhdGg6IG8gfSA9IG4sIHsgY29tbWFuZEluZGV4OiBhLCBwb2ludEluZGV4OiBjLCBjb25uZWN0VG9Db21tYW5kSW5kZXg6IGwsIGNvbm5lY3RUb1BvaW50SW5kZXg6IGggfSA9IHRoaXM7XG4gICAgdC5zYXZlKCksIHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbnRyb2xTdHJva2UsIHRoaXMuY29ubmVjdGlvbkRhc2hBcnJheSAmJiB0LnNldExpbmVEYXNoKHRoaXMuY29ubmVjdGlvbkRhc2hBcnJheSk7XG4gICAgY29uc3QgW3VdID0gb1thXSwgZCA9IGJuKG4sIGwsIGgpO1xuICAgIGlmICh1ID09PSBcIlFcIikge1xuICAgICAgY29uc3QgZiA9IGJuKG4sIGEsIGMgKyAyKTtcbiAgICAgIHQubW92ZVRvKGYueCwgZi55KSwgdC5saW5lVG8oZSwgcyk7XG4gICAgfSBlbHNlIHQubW92ZVRvKGUsIHMpO1xuICAgIHQubGluZVRvKGQueCwgZC55KSwgdC5zdHJva2UoKSwgdC5yZXN0b3JlKCksIHN1cGVyLnJlbmRlcih0LCBlLCBzLCByLCBuKTtcbiAgfVxufVxuY29uc3QgQ3IgPSAoaSwgdCwgZSwgcywgciwgbikgPT4gbmV3IChlID8gQmQgOiB1bCkodih2KHsgY29tbWFuZEluZGV4OiBpLCBwb2ludEluZGV4OiB0LCBhY3Rpb25OYW1lOiBcIm1vZGlmeVBhdGhcIiwgcG9zaXRpb25IYW5kbGVyOiBSZCwgYWN0aW9uSGFuZGxlcjogTGQsIGNvbm5lY3RUb0NvbW1hbmRJbmRleDogciwgY29ubmVjdFRvUG9pbnRJbmRleDogbiB9LCBzKSwgZSA/IHMuY29udHJvbFBvaW50U3R5bGUgOiBzLnBvaW50U3R5bGUpKTtcbnZhciBEcyA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGNoYW5nZVdpZHRoOiBobiwgY3JlYXRlT2JqZWN0RGVmYXVsdENvbnRyb2xzOiBxbiwgY3JlYXRlUGF0aENvbnRyb2xzOiBmdW5jdGlvbihpKSB7XG4gIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY29uc3QgZSA9IHt9O1xuICBsZXQgcyA9IFwiTVwiO1xuICByZXR1cm4gaS5wYXRoLmZvckVhY2goKHIsIG4pID0+IHtcbiAgICBjb25zdCBvID0gclswXTtcbiAgICBzd2l0Y2ggKG8gIT09IFwiWlwiICYmIChlW1wiY19cIi5jb25jYXQobiwgXCJfXCIpLmNvbmNhdChvKV0gPSBDcihuLCByLmxlbmd0aCAtIDIsICExLCB0KSksIG8pIHtcbiAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgIGVbXCJjX1wiLmNvbmNhdChuLCBcIl9DX0NQXzFcIildID0gQ3IobiwgMSwgITAsIHQsIG4gLSAxLCAvKiBAX19QVVJFX18gKi8gKChhKSA9PiBhID09PSBcIkNcIiA/IDUgOiBhID09PSBcIlFcIiA/IDMgOiAxKShzKSksIGVbXCJjX1wiLmNvbmNhdChuLCBcIl9DX0NQXzJcIildID0gQ3IobiwgMywgITAsIHQsIG4sIDUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgIGVbXCJjX1wiLmNvbmNhdChuLCBcIl9RX0NQXzFcIildID0gQ3IobiwgMSwgITAsIHQsIG4sIDMpO1xuICAgIH1cbiAgICBzID0gbztcbiAgfSksIGU7XG59LCBjcmVhdGVQb2x5QWN0aW9uSGFuZGxlcjogTm8sIGNyZWF0ZVBvbHlDb250cm9sczogZnVuY3Rpb24oaSkge1xuICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gIGNvbnN0IGUgPSB7fTtcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCAodHlwZW9mIGkgPT0gXCJudW1iZXJcIiA/IGkgOiBpLnBvaW50cy5sZW5ndGgpOyBzKyspIGVbXCJwXCIuY29uY2F0KHMpXSA9IG5ldyBVKHYoeyBhY3Rpb25OYW1lOiBjbCwgcG9zaXRpb25IYW5kbGVyOiBHbyhzKSwgYWN0aW9uSGFuZGxlcjogTm8ocykgfSwgdCkpO1xuICByZXR1cm4gZTtcbn0sIGNyZWF0ZVBvbHlQb3NpdGlvbkhhbmRsZXI6IEdvLCBjcmVhdGVSZXNpemVDb250cm9sczogQ2MsIGNyZWF0ZVRleHRib3hEZWZhdWx0Q29udHJvbHM6IE9jLCBkcmFnSGFuZGxlcjogb2MsIGZhY3RvcnlQb2x5QWN0aW9uSGFuZGxlcjogaGwsIGdldExvY2FsUG9pbnQ6IGJpLCBwb2x5QWN0aW9uSGFuZGxlcjogbGwsIHJlbmRlckNpcmNsZUNvbnRyb2w6IGZjLCByZW5kZXJTcXVhcmVDb250cm9sOiBnYywgcm90YXRpb25TdHlsZUhhbmRsZXI6IHBjLCByb3RhdGlvbldpdGhTbmFwcGluZzogbWMsIHNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyOiBaZSwgc2NhbGVPclNrZXdBY3Rpb25OYW1lOiBCcywgc2NhbGVTa2V3Q3Vyc29yU3R5bGVIYW5kbGVyOiBGZSwgc2NhbGluZ0VxdWFsbHk6IExzLCBzY2FsaW5nWDogYmMsIHNjYWxpbmdYT3JTa2V3aW5nWTogdW4sIHNjYWxpbmdZOiBfYywgc2NhbGluZ1lPclNrZXdpbmdYOiBkbiwgc2tld0N1cnNvclN0eWxlSGFuZGxlcjogU2MsIHNrZXdIYW5kbGVyWDogeGMsIHNrZXdIYW5kbGVyWTogd2MsIHdyYXBXaXRoRmlyZUV2ZW50OiBJZSwgd3JhcFdpdGhGaXhlZEFuY2hvcjogR2UgfSk7XG5jb25zdCBraSA9IChpKSA9PiBpLndlYmdsICE9PSB2b2lkIDAsIHRvID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXRcIiwgV2QgPSBgXG4gICAgYC5jb25jYXQodG8sIGA7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XG4gICAgfWApLCBYZCA9IFtcInR5cGVcIl0sIHpkID0gW1widHlwZVwiXSwgSGQgPSBuZXcgUmVnRXhwKHRvLCBcImdcIik7XG5jbGFzcyBpdCB7XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHQgPSBHKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge30sIFhkKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdHMsIHQpO1xuICB9XG4gIGdldEZyYWdtZW50U291cmNlKCkge1xuICAgIHJldHVybiBXZDtcbiAgfVxuICBnZXRWZXJ0ZXhTb3VyY2UoKSB7XG4gICAgcmV0dXJuIGBcbiAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2VGV4Q29vcmQgPSBhUG9zaXRpb247XG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XG4gICAgfWA7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbSh0KSB7XG4gICAgbGV0IGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuZ2V0RnJhZ21lbnRTb3VyY2UoKSwgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogdGhpcy5nZXRWZXJ0ZXhTb3VyY2UoKTtcbiAgICBjb25zdCB7IFdlYkdMUHJvYmU6IHsgR0xQcmVjaXNpb246IHIgPSBcImhpZ2hwXCIgfSB9ID0gJHQoKTtcbiAgICByICE9PSBcImhpZ2hwXCIgJiYgKGUgPSBlLnJlcGxhY2UoSGQsIHRvLnJlcGxhY2UoXCJoaWdocFwiLCByKSkpO1xuICAgIGNvbnN0IG4gPSB0LmNyZWF0ZVNoYWRlcih0LlZFUlRFWF9TSEFERVIpLCBvID0gdC5jcmVhdGVTaGFkZXIodC5GUkFHTUVOVF9TSEFERVIpLCBhID0gdC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgaWYgKCFuIHx8ICFvIHx8ICFhKSB0aHJvdyBuZXcgWXQoXCJWZXJ0ZXgsIGZyYWdtZW50IHNoYWRlciBvciBwcm9ncmFtIGNyZWF0aW9uIGVycm9yXCIpO1xuICAgIGlmICh0LnNoYWRlclNvdXJjZShuLCBzKSwgdC5jb21waWxlU2hhZGVyKG4pLCAhdC5nZXRTaGFkZXJQYXJhbWV0ZXIobiwgdC5DT01QSUxFX1NUQVRVUykpIHRocm93IG5ldyBZdChcIlZlcnRleCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgXCIuY29uY2F0KHRoaXMudHlwZSwgXCI6IFwiKS5jb25jYXQodC5nZXRTaGFkZXJJbmZvTG9nKG4pKSk7XG4gICAgaWYgKHQuc2hhZGVyU291cmNlKG8sIGUpLCB0LmNvbXBpbGVTaGFkZXIobyksICF0LmdldFNoYWRlclBhcmFtZXRlcihvLCB0LkNPTVBJTEVfU1RBVFVTKSkgdGhyb3cgbmV3IFl0KFwiRnJhZ21lbnQgc2hhZGVyIGNvbXBpbGUgZXJyb3IgZm9yIFwiLmNvbmNhdCh0aGlzLnR5cGUsIFwiOiBcIikuY29uY2F0KHQuZ2V0U2hhZGVySW5mb0xvZyhvKSkpO1xuICAgIGlmICh0LmF0dGFjaFNoYWRlcihhLCBuKSwgdC5hdHRhY2hTaGFkZXIoYSwgbyksIHQubGlua1Byb2dyYW0oYSksICF0LmdldFByb2dyYW1QYXJhbWV0ZXIoYSwgdC5MSU5LX1NUQVRVUykpIHRocm93IG5ldyBZdCgnU2hhZGVyIGxpbmsgZXJyb3IgZm9yIFwiJy5jb25jYXQodGhpcy50eXBlLCAnXCIgJykuY29uY2F0KHQuZ2V0UHJvZ3JhbUluZm9Mb2coYSkpKTtcbiAgICBjb25zdCBjID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb25zKHQsIGEpIHx8IHt9O1xuICAgIHJldHVybiBjLnVTdGVwVyA9IHQuZ2V0VW5pZm9ybUxvY2F0aW9uKGEsIFwidVN0ZXBXXCIpLCBjLnVTdGVwSCA9IHQuZ2V0VW5pZm9ybUxvY2F0aW9uKGEsIFwidVN0ZXBIXCIpLCB7IHByb2dyYW06IGEsIGF0dHJpYnV0ZUxvY2F0aW9uczogdGhpcy5nZXRBdHRyaWJ1dGVMb2NhdGlvbnModCwgYSksIHVuaWZvcm1Mb2NhdGlvbnM6IGMgfTtcbiAgfVxuICBnZXRBdHRyaWJ1dGVMb2NhdGlvbnModCwgZSkge1xuICAgIHJldHVybiB7IGFQb3NpdGlvbjogdC5nZXRBdHRyaWJMb2NhdGlvbihlLCBcImFQb3NpdGlvblwiKSB9O1xuICB9XG4gIGdldFVuaWZvcm1Mb2NhdGlvbnModCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmNvbnN0cnVjdG9yLnVuaWZvcm1Mb2NhdGlvbnMsIHIgPSB7fTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHMubGVuZ3RoOyBuKyspIHJbc1tuXV0gPSB0LmdldFVuaWZvcm1Mb2NhdGlvbihlLCBzW25dKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBzZW5kQXR0cmlidXRlRGF0YSh0LCBlLCBzKSB7XG4gICAgY29uc3QgciA9IGUuYVBvc2l0aW9uLCBuID0gdC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsIG4pLCB0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHIpLCB0LnZlcnRleEF0dHJpYlBvaW50ZXIociwgMiwgdC5GTE9BVCwgITEsIDAsIDApLCB0LmJ1ZmZlckRhdGEodC5BUlJBWV9CVUZGRVIsIHMsIHQuU1RBVElDX0RSQVcpO1xuICB9XG4gIF9zZXR1cEZyYW1lQnVmZmVyKHQpIHtcbiAgICBjb25zdCBlID0gdC5jb250ZXh0O1xuICAgIGlmICh0LnBhc3NlcyA+IDEpIHtcbiAgICAgIGNvbnN0IHMgPSB0LmRlc3RpbmF0aW9uV2lkdGgsIHIgPSB0LmRlc3RpbmF0aW9uSGVpZ2h0O1xuICAgICAgdC5zb3VyY2VXaWR0aCA9PT0gcyAmJiB0LnNvdXJjZUhlaWdodCA9PT0gciB8fCAoZS5kZWxldGVUZXh0dXJlKHQudGFyZ2V0VGV4dHVyZSksIHQudGFyZ2V0VGV4dHVyZSA9IHQuZmlsdGVyQmFja2VuZC5jcmVhdGVUZXh0dXJlKGUsIHMsIHIpKSwgZS5mcmFtZWJ1ZmZlclRleHR1cmUyRChlLkZSQU1FQlVGRkVSLCBlLkNPTE9SX0FUVEFDSE1FTlQwLCBlLlRFWFRVUkVfMkQsIHQudGFyZ2V0VGV4dHVyZSwgMCk7XG4gICAgfSBlbHNlIGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsIG51bGwpLCBlLmZpbmlzaCgpO1xuICB9XG4gIF9zd2FwVGV4dHVyZXModCkge1xuICAgIHQucGFzc2VzLS0sIHQucGFzcysrO1xuICAgIGNvbnN0IGUgPSB0LnRhcmdldFRleHR1cmU7XG4gICAgdC50YXJnZXRUZXh0dXJlID0gdC5zb3VyY2VUZXh0dXJlLCB0LnNvdXJjZVRleHR1cmUgPSBlO1xuICB9XG4gIGlzTmV1dHJhbFN0YXRlKHQpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgYXBwbHlUbyh0KSB7XG4gICAga2kodCkgPyAodGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcih0KSwgdGhpcy5hcHBseVRvV2ViR0wodCksIHRoaXMuX3N3YXBUZXh0dXJlcyh0KSkgOiB0aGlzLmFwcGx5VG8yZCh0KTtcbiAgfVxuICBhcHBseVRvMmQodCkge1xuICB9XG4gIGdldENhY2hlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cbiAgcmV0cmlldmVTaGFkZXIodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmdldENhY2hlS2V5KCk7XG4gICAgcmV0dXJuIHQucHJvZ3JhbUNhY2hlW2VdIHx8ICh0LnByb2dyYW1DYWNoZVtlXSA9IHRoaXMuY3JlYXRlUHJvZ3JhbSh0LmNvbnRleHQpKSwgdC5wcm9ncmFtQ2FjaGVbZV07XG4gIH1cbiAgYXBwbHlUb1dlYkdMKHQpIHtcbiAgICBjb25zdCBlID0gdC5jb250ZXh0LCBzID0gdGhpcy5yZXRyaWV2ZVNoYWRlcih0KTtcbiAgICB0LnBhc3MgPT09IDAgJiYgdC5vcmlnaW5hbFRleHR1cmUgPyBlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCwgdC5vcmlnaW5hbFRleHR1cmUpIDogZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsIHQuc291cmNlVGV4dHVyZSksIGUudXNlUHJvZ3JhbShzLnByb2dyYW0pLCB0aGlzLnNlbmRBdHRyaWJ1dGVEYXRhKGUsIHMuYXR0cmlidXRlTG9jYXRpb25zLCB0LmFQb3NpdGlvbiksIGUudW5pZm9ybTFmKHMudW5pZm9ybUxvY2F0aW9ucy51U3RlcFcsIDEgLyB0LnNvdXJjZVdpZHRoKSwgZS51bmlmb3JtMWYocy51bmlmb3JtTG9jYXRpb25zLnVTdGVwSCwgMSAvIHQuc291cmNlSGVpZ2h0KSwgdGhpcy5zZW5kVW5pZm9ybURhdGEoZSwgcy51bmlmb3JtTG9jYXRpb25zKSwgZS52aWV3cG9ydCgwLCAwLCB0LmRlc3RpbmF0aW9uV2lkdGgsIHQuZGVzdGluYXRpb25IZWlnaHQpLCBlLmRyYXdBcnJheXMoZS5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gIH1cbiAgYmluZEFkZGl0aW9uYWxUZXh0dXJlKHQsIGUsIHMpIHtcbiAgICB0LmFjdGl2ZVRleHR1cmUocyksIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELCBlKSwgdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTApO1xuICB9XG4gIHVuYmluZEFkZGl0aW9uYWxUZXh0dXJlKHQsIGUpIHtcbiAgICB0LmFjdGl2ZVRleHR1cmUoZSksIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELCBudWxsKSwgdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTApO1xuICB9XG4gIHNlbmRVbmlmb3JtRGF0YSh0LCBlKSB7XG4gIH1cbiAgY3JlYXRlSGVscExheWVyKHQpIHtcbiAgICBpZiAoIXQuaGVscExheWVyKSB7XG4gICAgICBjb25zdCB7IHNvdXJjZVdpZHRoOiBlLCBzb3VyY2VIZWlnaHQ6IHMgfSA9IHQsIHIgPSBXdCh7IHdpZHRoOiBlLCBoZWlnaHQ6IHMgfSk7XG4gICAgICB0LmhlbHBMYXllciA9IHI7XG4gICAgfVxuICB9XG4gIHRvT2JqZWN0KCkge1xuICAgIGNvbnN0IHQgPSBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzIHx8IHt9KTtcbiAgICByZXR1cm4gdih7IHR5cGU6IHRoaXMudHlwZSB9LCB0LnJlZHVjZSgoZSwgcykgPT4gKGVbc10gPSB0aGlzW3NdLCBlKSwge30pKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbU9iamVjdCh0LCBlKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKEcodCwgemQpKTtcbiAgfVxufVxueShpdCwgXCJ0eXBlXCIsIFwiQmFzZUZpbHRlclwiKSwgeShpdCwgXCJ1bmlmb3JtTG9jYXRpb25zXCIsIFtdKTtcbmNvbnN0IFlkID0geyBtdWx0aXBseTogYGdsX0ZyYWdDb2xvci5yZ2IgKj0gdUNvbG9yLnJnYjtcbmAsIHNjcmVlbjogYGdsX0ZyYWdDb2xvci5yZ2IgPSAxLjAgLSAoMS4wIC0gZ2xfRnJhZ0NvbG9yLnJnYikgKiAoMS4wIC0gdUNvbG9yLnJnYik7XG5gLCBhZGQ6IGBnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2I7XG5gLCBkaWZmZXJlbmNlOiBgZ2xfRnJhZ0NvbG9yLnJnYiA9IGFicyhnbF9GcmFnQ29sb3IucmdiIC0gdUNvbG9yLnJnYik7XG5gLCBzdWJ0cmFjdDogYGdsX0ZyYWdDb2xvci5yZ2IgLT0gdUNvbG9yLnJnYjtcbmAsIGxpZ2h0ZW46IGBnbF9GcmFnQ29sb3IucmdiID0gbWF4KGdsX0ZyYWdDb2xvci5yZ2IsIHVDb2xvci5yZ2IpO1xuYCwgZGFya2VuOiBgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1pbihnbF9GcmFnQ29sb3IucmdiLCB1Q29sb3IucmdiKTtcbmAsIGV4Y2x1c2lvbjogYGdsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYiAtIDIuMCAqICh1Q29sb3IucmdiICogZ2xfRnJhZ0NvbG9yLnJnYik7XG5gLCBvdmVybGF5OiBgXG4gICAgaWYgKHVDb2xvci5yIDwgMC41KSB7XG4gICAgICBnbF9GcmFnQ29sb3IuciAqPSAyLjAgKiB1Q29sb3IucjtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xfRnJhZ0NvbG9yLnIgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLnIpICogKDEuMCAtIHVDb2xvci5yKTtcbiAgICB9XG4gICAgaWYgKHVDb2xvci5nIDwgMC41KSB7XG4gICAgICBnbF9GcmFnQ29sb3IuZyAqPSAyLjAgKiB1Q29sb3IuZztcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xfRnJhZ0NvbG9yLmcgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLmcpICogKDEuMCAtIHVDb2xvci5nKTtcbiAgICB9XG4gICAgaWYgKHVDb2xvci5iIDwgMC41KSB7XG4gICAgICBnbF9GcmFnQ29sb3IuYiAqPSAyLjAgKiB1Q29sb3IuYjtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xfRnJhZ0NvbG9yLmIgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLmIpICogKDEuMCAtIHVDb2xvci5iKTtcbiAgICB9XG4gICAgYCwgdGludDogYFxuICAgIGdsX0ZyYWdDb2xvci5yZ2IgKj0gKDEuMCAtIHVDb2xvci5hKTtcbiAgICBnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2I7XG4gICAgYCB9O1xuY2xhc3MgT3IgZXh0ZW5kcyBpdCB7XG4gIGdldENhY2hlS2V5KCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnR5cGUsIFwiX1wiKS5jb25jYXQodGhpcy5tb2RlKTtcbiAgfVxuICBnZXRGcmFnbWVudFNvdXJjZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgICB1bmlmb3JtIHZlYzQgdUNvbG9yO1xuICAgICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gICAgICAgIGlmIChjb2xvci5hID4gMC4wKSB7XG4gICAgICAgICAgYC5jb25jYXQoWWRbdGhpcy5tb2RlXSwgYFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgKTtcbiAgfVxuICBhcHBseVRvMmQodCkge1xuICAgIGxldCB7IGltYWdlRGF0YTogeyBkYXRhOiBlIH0gfSA9IHQ7XG4gICAgY29uc3QgcyA9IG5ldyBXKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpLCByID0gdGhpcy5hbHBoYSwgbiA9IHNbMF0gKiByLCBvID0gc1sxXSAqIHIsIGEgPSBzWzJdICogciwgYyA9IDEgLSByO1xuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgZS5sZW5ndGg7IGwgKz0gNCkge1xuICAgICAgY29uc3QgaCA9IGVbbF0sIHUgPSBlW2wgKyAxXSwgZCA9IGVbbCArIDJdO1xuICAgICAgbGV0IGYsIGcsIHA7XG4gICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICBjYXNlIFwibXVsdGlwbHlcIjpcbiAgICAgICAgICBmID0gaCAqIG4gLyAyNTUsIGcgPSB1ICogbyAvIDI1NSwgcCA9IGQgKiBhIC8gMjU1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2NyZWVuXCI6XG4gICAgICAgICAgZiA9IDI1NSAtICgyNTUgLSBoKSAqICgyNTUgLSBuKSAvIDI1NSwgZyA9IDI1NSAtICgyNTUgLSB1KSAqICgyNTUgLSBvKSAvIDI1NSwgcCA9IDI1NSAtICgyNTUgLSBkKSAqICgyNTUgLSBhKSAvIDI1NTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgIGYgPSBoICsgbiwgZyA9IHUgKyBvLCBwID0gZCArIGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkaWZmZXJlbmNlXCI6XG4gICAgICAgICAgZiA9IE1hdGguYWJzKGggLSBuKSwgZyA9IE1hdGguYWJzKHUgLSBvKSwgcCA9IE1hdGguYWJzKGQgLSBhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN1YnRyYWN0XCI6XG4gICAgICAgICAgZiA9IGggLSBuLCBnID0gdSAtIG8sIHAgPSBkIC0gYTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhcmtlblwiOlxuICAgICAgICAgIGYgPSBNYXRoLm1pbihoLCBuKSwgZyA9IE1hdGgubWluKHUsIG8pLCBwID0gTWF0aC5taW4oZCwgYSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsaWdodGVuXCI6XG4gICAgICAgICAgZiA9IE1hdGgubWF4KGgsIG4pLCBnID0gTWF0aC5tYXgodSwgbyksIHAgPSBNYXRoLm1heChkLCBhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm92ZXJsYXlcIjpcbiAgICAgICAgICBmID0gbiA8IDEyOCA/IDIgKiBoICogbiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gaCkgKiAoMjU1IC0gbikgLyAyNTUsIGcgPSBvIDwgMTI4ID8gMiAqIHUgKiBvIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSB1KSAqICgyNTUgLSBvKSAvIDI1NSwgcCA9IGEgPCAxMjggPyAyICogZCAqIGEgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGQpICogKDI1NSAtIGEpIC8gMjU1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXhjbHVzaW9uXCI6XG4gICAgICAgICAgZiA9IG4gKyBoIC0gMiAqIG4gKiBoIC8gMjU1LCBnID0gbyArIHUgLSAyICogbyAqIHUgLyAyNTUsIHAgPSBhICsgZCAtIDIgKiBhICogZCAvIDI1NTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRpbnRcIjpcbiAgICAgICAgICBmID0gbiArIGggKiBjLCBnID0gbyArIHUgKiBjLCBwID0gYSArIGQgKiBjO1xuICAgICAgfVxuICAgICAgZVtsXSA9IGYsIGVbbCArIDFdID0gZywgZVtsICsgMl0gPSBwO1xuICAgIH1cbiAgfVxuICBzZW5kVW5pZm9ybURhdGEodCwgZSkge1xuICAgIGNvbnN0IHMgPSBuZXcgVyh0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcbiAgICBzWzBdID0gdGhpcy5hbHBoYSAqIHNbMF0gLyAyNTUsIHNbMV0gPSB0aGlzLmFscGhhICogc1sxXSAvIDI1NSwgc1syXSA9IHRoaXMuYWxwaGEgKiBzWzJdIC8gMjU1LCBzWzNdID0gdGhpcy5hbHBoYSwgdC51bmlmb3JtNGZ2KGUudUNvbG9yLCBzKTtcbiAgfVxufVxueShPciwgXCJkZWZhdWx0c1wiLCB7IGNvbG9yOiBcIiNGOTVDNjNcIiwgbW9kZTogXCJtdWx0aXBseVwiLCBhbHBoYTogMSB9KSwgeShPciwgXCJ0eXBlXCIsIFwiQmxlbmRDb2xvclwiKSwgeShPciwgXCJ1bmlmb3JtTG9jYXRpb25zXCIsIFtcInVDb2xvclwiXSksIEMuc2V0Q2xhc3MoT3IpO1xuY29uc3QgVmQgPSB7IG11bHRpcGx5OiBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVJbWFnZTtcbiAgICB1bmlmb3JtIHZlYzQgdUNvbG9yO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcbiAgICAgIHZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVJbWFnZSwgdlRleENvb3JkMik7XG4gICAgICBjb2xvci5yZ2JhICo9IGNvbG9yMi5yZ2JhO1xuICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gICAgfVxuICAgIGAsIG1hc2s6IGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdUltYWdlO1xuICAgIHVuaWZvcm0gdmVjNCB1Q29sb3I7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xuICAgICAgdmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodUltYWdlLCB2VGV4Q29vcmQyKTtcbiAgICAgIGNvbG9yLmEgPSBjb2xvcjIuYTtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBgIH0sIEdkID0gW1widHlwZVwiLCBcImltYWdlXCJdO1xuY2xhc3Mga3IgZXh0ZW5kcyBpdCB7XG4gIGdldENhY2hlS2V5KCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnR5cGUsIFwiX1wiKS5jb25jYXQodGhpcy5tb2RlKTtcbiAgfVxuICBnZXRGcmFnbWVudFNvdXJjZSgpIHtcbiAgICByZXR1cm4gVmRbdGhpcy5tb2RlXTtcbiAgfVxuICBnZXRWZXJ0ZXhTb3VyY2UoKSB7XG4gICAgcmV0dXJuIGBcbiAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcbiAgICB1bmlmb3JtIG1hdDMgdVRyYW5zZm9ybU1hdHJpeDtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2VGV4Q29vcmQgPSBhUG9zaXRpb247XG4gICAgICB2VGV4Q29vcmQyID0gKHVUcmFuc2Zvcm1NYXRyaXggKiB2ZWMzKGFQb3NpdGlvbiwgMS4wKSkueHk7XG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XG4gICAgfVxuICAgIGA7XG4gIH1cbiAgYXBwbHlUb1dlYkdMKHQpIHtcbiAgICBjb25zdCBlID0gdC5jb250ZXh0LCBzID0gdGhpcy5jcmVhdGVUZXh0dXJlKHQuZmlsdGVyQmFja2VuZCwgdGhpcy5pbWFnZSk7XG4gICAgdGhpcy5iaW5kQWRkaXRpb25hbFRleHR1cmUoZSwgcywgZS5URVhUVVJFMSksIHN1cGVyLmFwcGx5VG9XZWJHTCh0KSwgdGhpcy51bmJpbmRBZGRpdGlvbmFsVGV4dHVyZShlLCBlLlRFWFRVUkUxKTtcbiAgfVxuICBjcmVhdGVUZXh0dXJlKHQsIGUpIHtcbiAgICByZXR1cm4gdC5nZXRDYWNoZWRUZXh0dXJlKGUuY2FjaGVLZXksIGUuZ2V0RWxlbWVudCgpKTtcbiAgfVxuICBjYWxjdWxhdGVNYXRyaXgoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaW1hZ2UsIHsgd2lkdGg6IGUsIGhlaWdodDogcyB9ID0gdC5nZXRFbGVtZW50KCk7XG4gICAgcmV0dXJuIFsxIC8gdC5zY2FsZVgsIDAsIDAsIDAsIDEgLyB0LnNjYWxlWSwgMCwgLXQubGVmdCAvIGUsIC10LnRvcCAvIHMsIDFdO1xuICB9XG4gIGFwcGx5VG8yZCh0KSB7XG4gICAgbGV0IHsgaW1hZ2VEYXRhOiB7IGRhdGE6IGUsIHdpZHRoOiBzLCBoZWlnaHQ6IHIgfSwgZmlsdGVyQmFja2VuZDogeyByZXNvdXJjZXM6IG4gfSB9ID0gdDtcbiAgICBjb25zdCBvID0gdGhpcy5pbWFnZTtcbiAgICBuLmJsZW5kSW1hZ2UgfHwgKG4uYmxlbmRJbWFnZSA9IGt0KCkpO1xuICAgIGNvbnN0IGEgPSBuLmJsZW5kSW1hZ2UsIGMgPSBhLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBhLndpZHRoICE9PSBzIHx8IGEuaGVpZ2h0ICE9PSByID8gKGEud2lkdGggPSBzLCBhLmhlaWdodCA9IHIpIDogYy5jbGVhclJlY3QoMCwgMCwgcywgciksIGMuc2V0VHJhbnNmb3JtKG8uc2NhbGVYLCAwLCAwLCBvLnNjYWxlWSwgby5sZWZ0LCBvLnRvcCksIGMuZHJhd0ltYWdlKG8uZ2V0RWxlbWVudCgpLCAwLCAwLCBzLCByKTtcbiAgICBjb25zdCBsID0gYy5nZXRJbWFnZURhdGEoMCwgMCwgcywgcikuZGF0YTtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IGUubGVuZ3RoOyBoICs9IDQpIHtcbiAgICAgIGNvbnN0IHUgPSBlW2hdLCBkID0gZVtoICsgMV0sIGYgPSBlW2ggKyAyXSwgZyA9IGVbaCArIDNdLCBwID0gbFtoXSwgbSA9IGxbaCArIDFdLCBiID0gbFtoICsgMl0sIFMgPSBsW2ggKyAzXTtcbiAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgIGNhc2UgXCJtdWx0aXBseVwiOlxuICAgICAgICAgIGVbaF0gPSB1ICogcCAvIDI1NSwgZVtoICsgMV0gPSBkICogbSAvIDI1NSwgZVtoICsgMl0gPSBmICogYiAvIDI1NSwgZVtoICsgM10gPSBnICogUyAvIDI1NTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1hc2tcIjpcbiAgICAgICAgICBlW2ggKyAzXSA9IFM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNlbmRVbmlmb3JtRGF0YSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuY2FsY3VsYXRlTWF0cml4KCk7XG4gICAgdC51bmlmb3JtMWkoZS51SW1hZ2UsIDEpLCB0LnVuaWZvcm1NYXRyaXgzZnYoZS51VHJhbnNmb3JtTWF0cml4LCAhMSwgcyk7XG4gIH1cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHYodih7fSwgc3VwZXIudG9PYmplY3QoKSksIHt9LCB7IGltYWdlOiB0aGlzLmltYWdlICYmIHRoaXMuaW1hZ2UudG9PYmplY3QoKSB9KTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbU9iamVjdCh0LCBlKSB7XG4gICAgbGV0IHsgdHlwZTogcywgaW1hZ2U6IHIgfSA9IHQsIG4gPSBHKHQsIEdkKTtcbiAgICByZXR1cm4gd3QuZnJvbU9iamVjdChyLCBlKS50aGVuKChvKSA9PiBuZXcgdGhpcyh2KHYoe30sIG4pLCB7fSwgeyBpbWFnZTogbyB9KSkpO1xuICB9XG59XG55KGtyLCBcInR5cGVcIiwgXCJCbGVuZEltYWdlXCIpLCB5KGtyLCBcImRlZmF1bHRzXCIsIHsgbW9kZTogXCJtdWx0aXBseVwiLCBhbHBoYTogMSB9KSwgeShrciwgXCJ1bmlmb3JtTG9jYXRpb25zXCIsIFtcInVUcmFuc2Zvcm1NYXRyaXhcIiwgXCJ1SW1hZ2VcIl0pLCBDLnNldENsYXNzKGtyKTtcbmNsYXNzIE1yIGV4dGVuZHMgaXQge1xuICBnZXRGcmFnbWVudFNvdXJjZSgpIHtcbiAgICByZXR1cm4gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIHZlYzIgdURlbHRhO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG4gICAgY29uc3QgZmxvYXQgblNhbXBsZXMgPSAxNS4wO1xuICAgIHZlYzMgdjNvZmZzZXQgPSB2ZWMzKDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIpO1xuICAgIGZsb2F0IHJhbmRvbSh2ZWMzIHNjYWxlKSB7XG4gICAgICAvKiB1c2UgdGhlIGZyYWdtZW50IHBvc2l0aW9uIGZvciBhIGRpZmZlcmVudCBzZWVkIHBlci1waXhlbCAqL1xuICAgICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoZ2xfRnJhZ0Nvb3JkLnh5eiwgc2NhbGUpKSAqIDQzNzU4LjU0NTMpO1xuICAgIH1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xuICAgICAgZmxvYXQgdG90YWwgPSAwLjA7XG4gICAgICBmbG9hdCBvZmZzZXQgPSByYW5kb20odjNvZmZzZXQpO1xuICAgICAgZm9yIChmbG9hdCB0ID0gLW5TYW1wbGVzOyB0IDw9IG5TYW1wbGVzOyB0KyspIHtcbiAgICAgICAgZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIG5TYW1wbGVzO1xuICAgICAgICBmbG9hdCB3ZWlnaHQgPSAxLjAgLSBhYnMocGVyY2VudCk7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgdURlbHRhICogcGVyY2VudCkgKiB3ZWlnaHQ7XG4gICAgICAgIHRvdGFsICs9IHdlaWdodDtcbiAgICAgIH1cbiAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yIC8gdG90YWw7XG4gICAgfVxuICBgO1xuICB9XG4gIGFwcGx5VG8odCkge1xuICAgIGtpKHQpID8gKHRoaXMuYXNwZWN0UmF0aW8gPSB0LnNvdXJjZVdpZHRoIC8gdC5zb3VyY2VIZWlnaHQsIHQucGFzc2VzKyssIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIodCksIHRoaXMuaG9yaXpvbnRhbCA9ICEwLCB0aGlzLmFwcGx5VG9XZWJHTCh0KSwgdGhpcy5fc3dhcFRleHR1cmVzKHQpLCB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKHQpLCB0aGlzLmhvcml6b250YWwgPSAhMSwgdGhpcy5hcHBseVRvV2ViR0wodCksIHRoaXMuX3N3YXBUZXh0dXJlcyh0KSkgOiB0aGlzLmFwcGx5VG8yZCh0KTtcbiAgfVxuICBhcHBseVRvMmQodCkge1xuICAgIHQuaW1hZ2VEYXRhID0gdGhpcy5zaW1wbGVCbHVyKHQpO1xuICB9XG4gIHNpbXBsZUJsdXIodCkge1xuICAgIGxldCB7IGN0eDogZSwgaW1hZ2VEYXRhOiBzLCBmaWx0ZXJCYWNrZW5kOiB7IHJlc291cmNlczogciB9IH0gPSB0O1xuICAgIGNvbnN0IHsgd2lkdGg6IG4sIGhlaWdodDogbyB9ID0gcztcbiAgICByLmJsdXJMYXllcjEgfHwgKHIuYmx1ckxheWVyMSA9IGt0KCksIHIuYmx1ckxheWVyMiA9IGt0KCkpO1xuICAgIGNvbnN0IGEgPSByLmJsdXJMYXllcjEsIGMgPSByLmJsdXJMYXllcjI7XG4gICAgYS53aWR0aCA9PT0gbiAmJiBhLmhlaWdodCA9PT0gbyB8fCAoYy53aWR0aCA9IGEud2lkdGggPSBuLCBjLmhlaWdodCA9IGEuaGVpZ2h0ID0gbyk7XG4gICAgY29uc3QgbCA9IGEuZ2V0Q29udGV4dChcIjJkXCIpLCBoID0gYy5nZXRDb250ZXh0KFwiMmRcIiksIHUgPSAxNSwgZCA9IDAuMDYgKiB0aGlzLmJsdXIgKiAwLjU7XG4gICAgbGV0IGYsIGcsIHAsIG07XG4gICAgZm9yIChsLnB1dEltYWdlRGF0YShzLCAwLCAwKSwgaC5jbGVhclJlY3QoMCwgMCwgbiwgbyksIG0gPSAtMTU7IG0gPD0gdTsgbSsrKSBmID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpIC8gNCwgZyA9IG0gLyB1LCBwID0gZCAqIGcgKiBuICsgZiwgaC5nbG9iYWxBbHBoYSA9IDEgLSBNYXRoLmFicyhnKSwgaC5kcmF3SW1hZ2UoYSwgcCwgZiksIGwuZHJhd0ltYWdlKGMsIDAsIDApLCBoLmdsb2JhbEFscGhhID0gMSwgaC5jbGVhclJlY3QoMCwgMCwgYy53aWR0aCwgYy5oZWlnaHQpO1xuICAgIGZvciAobSA9IC0xNTsgbSA8PSB1OyBtKyspIGYgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA0LCBnID0gbSAvIHUsIHAgPSBkICogZyAqIG8gKyBmLCBoLmdsb2JhbEFscGhhID0gMSAtIE1hdGguYWJzKGcpLCBoLmRyYXdJbWFnZShhLCBmLCBwKSwgbC5kcmF3SW1hZ2UoYywgMCwgMCksIGguZ2xvYmFsQWxwaGEgPSAxLCBoLmNsZWFyUmVjdCgwLCAwLCBjLndpZHRoLCBjLmhlaWdodCk7XG4gICAgZS5kcmF3SW1hZ2UoYSwgMCwgMCk7XG4gICAgY29uc3QgYiA9IGUuZ2V0SW1hZ2VEYXRhKDAsIDAsIGEud2lkdGgsIGEuaGVpZ2h0KTtcbiAgICByZXR1cm4gbC5nbG9iYWxBbHBoYSA9IDEsIGwuY2xlYXJSZWN0KDAsIDAsIGEud2lkdGgsIGEuaGVpZ2h0KSwgYjtcbiAgfVxuICBzZW5kVW5pZm9ybURhdGEodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmNob29zZVJpZ2h0RGVsdGEoKTtcbiAgICB0LnVuaWZvcm0yZnYoZS51RGVsdGEsIHMpO1xuICB9XG4gIGlzTmV1dHJhbFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXIgPT09IDA7XG4gIH1cbiAgY2hvb3NlUmlnaHREZWx0YSgpIHtcbiAgICBsZXQgdCA9IDE7XG4gICAgY29uc3QgZSA9IFswLCAwXTtcbiAgICB0aGlzLmhvcml6b250YWwgPyB0aGlzLmFzcGVjdFJhdGlvID4gMSAmJiAodCA9IDEgLyB0aGlzLmFzcGVjdFJhdGlvKSA6IHRoaXMuYXNwZWN0UmF0aW8gPCAxICYmICh0ID0gdGhpcy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgcyA9IHQgKiB0aGlzLmJsdXIgKiAwLjEyO1xuICAgIHJldHVybiB0aGlzLmhvcml6b250YWwgPyBlWzBdID0gcyA6IGVbMV0gPSBzLCBlO1xuICB9XG59XG55KE1yLCBcInR5cGVcIiwgXCJCbHVyXCIpLCB5KE1yLCBcImRlZmF1bHRzXCIsIHsgYmx1cjogMCB9KSwgeShNciwgXCJ1bmlmb3JtTG9jYXRpb25zXCIsIFtcInVEZWx0YVwiXSksIEMuc2V0Q2xhc3MoTXIpO1xuY2xhc3MgSXIgZXh0ZW5kcyBpdCB7XG4gIGdldEZyYWdtZW50U291cmNlKCkge1xuICAgIHJldHVybiBgXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gIHVuaWZvcm0gZmxvYXQgdUJyaWdodG5lc3M7XG4gIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG4gIHZvaWQgbWFpbigpIHtcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xuICAgIGNvbG9yLnJnYiArPSB1QnJpZ2h0bmVzcztcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgfVxuYDtcbiAgfVxuICBhcHBseVRvMmQodCkge1xuICAgIGxldCB7IGltYWdlRGF0YTogeyBkYXRhOiBlIH0gfSA9IHQ7XG4gICAgY29uc3QgcyA9IE1hdGgucm91bmQoMjU1ICogdGhpcy5icmlnaHRuZXNzKTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByICs9IDQpIGVbcl0gKz0gcywgZVtyICsgMV0gKz0gcywgZVtyICsgMl0gKz0gcztcbiAgfVxuICBpc05ldXRyYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5icmlnaHRuZXNzID09PSAwO1xuICB9XG4gIHNlbmRVbmlmb3JtRGF0YSh0LCBlKSB7XG4gICAgdC51bmlmb3JtMWYoZS51QnJpZ2h0bmVzcywgdGhpcy5icmlnaHRuZXNzKTtcbiAgfVxufVxueShJciwgXCJ0eXBlXCIsIFwiQnJpZ2h0bmVzc1wiKSwgeShJciwgXCJkZWZhdWx0c1wiLCB7IGJyaWdodG5lc3M6IDAgfSksIHkoSXIsIFwidW5pZm9ybUxvY2F0aW9uc1wiLCBbXCJ1QnJpZ2h0bmVzc1wiXSksIEMuc2V0Q2xhc3MoSXIpO1xuY29uc3QgZGwgPSB7IG1hdHJpeDogWzEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDBdLCBjb2xvcnNPbmx5OiAhMCB9O1xuY2xhc3MgdHMgZXh0ZW5kcyBpdCB7XG4gIGdldEZyYWdtZW50U291cmNlKCkge1xuICAgIHJldHVybiBgXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG4gIHVuaWZvcm0gbWF0NCB1Q29sb3JNYXRyaXg7XG4gIHVuaWZvcm0gdmVjNCB1Q29uc3RhbnRzO1xuICB2b2lkIG1haW4oKSB7XG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcbiAgICBjb2xvciAqPSB1Q29sb3JNYXRyaXg7XG4gICAgY29sb3IgKz0gdUNvbnN0YW50cztcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgfWA7XG4gIH1cbiAgYXBwbHlUbzJkKHQpIHtcbiAgICBjb25zdCBlID0gdC5pbWFnZURhdGEuZGF0YSwgcyA9IHRoaXMubWF0cml4LCByID0gdGhpcy5jb2xvcnNPbmx5O1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4gKz0gNCkge1xuICAgICAgY29uc3QgbyA9IGVbbl0sIGEgPSBlW24gKyAxXSwgYyA9IGVbbiArIDJdO1xuICAgICAgaWYgKGVbbl0gPSBvICogc1swXSArIGEgKiBzWzFdICsgYyAqIHNbMl0gKyAyNTUgKiBzWzRdLCBlW24gKyAxXSA9IG8gKiBzWzVdICsgYSAqIHNbNl0gKyBjICogc1s3XSArIDI1NSAqIHNbOV0sIGVbbiArIDJdID0gbyAqIHNbMTBdICsgYSAqIHNbMTFdICsgYyAqIHNbMTJdICsgMjU1ICogc1sxNF0sICFyKSB7XG4gICAgICAgIGNvbnN0IGwgPSBlW24gKyAzXTtcbiAgICAgICAgZVtuXSArPSBsICogc1szXSwgZVtuICsgMV0gKz0gbCAqIHNbOF0sIGVbbiArIDJdICs9IGwgKiBzWzEzXSwgZVtuICsgM10gPSBvICogc1sxNV0gKyBhICogc1sxNl0gKyBjICogc1sxN10gKyBsICogc1sxOF0gKyAyNTUgKiBzWzE5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2VuZFVuaWZvcm1EYXRhKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5tYXRyaXgsIHIgPSBbc1swXSwgc1sxXSwgc1syXSwgc1szXSwgc1s1XSwgc1s2XSwgc1s3XSwgc1s4XSwgc1sxMF0sIHNbMTFdLCBzWzEyXSwgc1sxM10sIHNbMTVdLCBzWzE2XSwgc1sxN10sIHNbMThdXSwgbiA9IFtzWzRdLCBzWzldLCBzWzE0XSwgc1sxOV1dO1xuICAgIHQudW5pZm9ybU1hdHJpeDRmdihlLnVDb2xvck1hdHJpeCwgITEsIHIpLCB0LnVuaWZvcm00ZnYoZS51Q29uc3RhbnRzLCBuKTtcbiAgfVxuICB0b09iamVjdCgpIHtcbiAgICByZXR1cm4gdih2KHt9LCBzdXBlci50b09iamVjdCgpKSwge30sIHsgbWF0cml4OiBbLi4udGhpcy5tYXRyaXhdIH0pO1xuICB9XG59XG5mdW5jdGlvbiBOZShpLCB0KSB7XG4gIHZhciBlO1xuICBjb25zdCBzID0gKHkoZSA9IGNsYXNzIGV4dGVuZHMgdHMge1xuICAgIHRvT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogdGhpcy50eXBlLCBjb2xvcnNPbmx5OiB0aGlzLmNvbG9yc09ubHkgfTtcbiAgICB9XG4gIH0sIFwidHlwZVwiLCBpKSwgeShlLCBcImRlZmF1bHRzXCIsIHsgY29sb3JzT25seTogITEsIG1hdHJpeDogdCB9KSwgZSk7XG4gIHJldHVybiBDLnNldENsYXNzKHMsIGkpLCBzO1xufVxueSh0cywgXCJ0eXBlXCIsIFwiQ29sb3JNYXRyaXhcIiksIHkodHMsIFwiZGVmYXVsdHNcIiwgZGwpLCB5KHRzLCBcInVuaWZvcm1Mb2NhdGlvbnNcIiwgW1widUNvbG9yTWF0cml4XCIsIFwidUNvbnN0YW50c1wiXSksIEMuc2V0Q2xhc3ModHMpO1xuTmUoXCJCcm93bmllXCIsIFswLjU5OTcsIDAuMzQ1NTMsIC0wLjI3MDgyLCAwLCAwLjE4NiwgLTAuMDM3NywgMC44NjA5NSwgMC4xNTA1OSwgMCwgLTAuMTQ0OSwgMC4yNDExMywgLTAuMDc0NDEsIDAuNDQ5NzIsIDAsIC0wLjAyOTY1LCAwLCAwLCAwLCAxLCAwXSk7XG5OZShcIlZpbnRhZ2VcIiwgWzAuNjI3OTMsIDAuMzIwMjEsIC0wLjAzOTY1LCAwLCAwLjAzNzg0LCAwLjAyNTc4LCAwLjY0NDExLCAwLjAzMjU5LCAwLCAwLjAyOTI2LCAwLjA0NjYsIC0wLjA4NTEyLCAwLjUyNDE2LCAwLCAwLjAyMDIzLCAwLCAwLCAwLCAxLCAwXSk7XG5OZShcIktvZGFjaHJvbWVcIiwgWzEuMTI4NTUsIC0wLjM5NjczLCAtMC4wMzk5MiwgMCwgMC4yNDk5MSwgLTAuMTY0MDQsIDEuMDgzNTIsIC0wLjA1NDk4LCAwLCAwLjA5Njk4LCAtMC4xNjc4NiwgLTAuNTYwMzQsIDEuNjAxNDgsIDAsIDAuMTM5NzIsIDAsIDAsIDAsIDEsIDBdKTtcbk5lKFwiVGVjaG5pY29sb3JcIiwgWzEuOTEyNTIsIC0wLjg1NDUzLCAtMC4wOTE1NSwgMCwgMC4wNDYyNCwgLTAuMzA4NzgsIDEuNzY1ODksIC0wLjEwNjAxLCAwLCAtMC4yNzU4OSwgLTAuMjMxMSwgLTAuNzUwMTgsIDEuODQ3NTksIDAsIDAuMTIxMzcsIDAsIDAsIDAsIDEsIDBdKTtcbk5lKFwiUG9sYXJvaWRcIiwgWzEuNDM4LCAtMC4wNjIsIC0wLjA2MiwgMCwgMCwgLTAuMTIyLCAxLjM3OCwgLTAuMTIyLCAwLCAwLCAtMC4wMTYsIC0wLjAxNiwgMS40ODMsIDAsIDAsIDAsIDAsIDAsIDEsIDBdKTtcbk5lKFwiU2VwaWFcIiwgWzAuMzkzLCAwLjc2OSwgMC4xODksIDAsIDAsIDAuMzQ5LCAwLjY4NiwgMC4xNjgsIDAsIDAsIDAuMjcyLCAwLjUzNCwgMC4xMzEsIDAsIDAsIDAsIDAsIDAsIDEsIDBdKTtcbk5lKFwiQmxhY2tXaGl0ZVwiLCBbMS41LCAxLjUsIDEuNSwgMCwgLTEsIDEuNSwgMS41LCAxLjUsIDAsIC0xLCAxLjUsIDEuNSwgMS41LCAwLCAtMSwgMCwgMCwgMCwgMSwgMF0pO1xuY2xhc3MgVW8gZXh0ZW5kcyBpdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBzdXBlcih0KSwgdGhpcy5zdWJGaWx0ZXJzID0gdC5zdWJGaWx0ZXJzIHx8IFtdO1xuICB9XG4gIGFwcGx5VG8odCkge1xuICAgIGtpKHQpICYmICh0LnBhc3NlcyArPSB0aGlzLnN1YkZpbHRlcnMubGVuZ3RoIC0gMSksIHRoaXMuc3ViRmlsdGVycy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlLmFwcGx5VG8odCk7XG4gICAgfSk7XG4gIH1cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdGhpcy50eXBlLCBzdWJGaWx0ZXJzOiB0aGlzLnN1YkZpbHRlcnMubWFwKCh0KSA9PiB0LnRvT2JqZWN0KCkpIH07XG4gIH1cbiAgaXNOZXV0cmFsU3RhdGUoKSB7XG4gICAgcmV0dXJuICF0aGlzLnN1YkZpbHRlcnMuc29tZSgodCkgPT4gIXQuaXNOZXV0cmFsU3RhdGUoKSk7XG4gIH1cbiAgc3RhdGljIGZyb21PYmplY3QodCwgZSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbCgodC5zdWJGaWx0ZXJzIHx8IFtdKS5tYXAoKHMpID0+IEMuZ2V0Q2xhc3Mocy50eXBlKS5mcm9tT2JqZWN0KHMsIGUpKSkudGhlbigocykgPT4gbmV3IHRoaXMoeyBzdWJGaWx0ZXJzOiBzIH0pKTtcbiAgfVxufVxueShVbywgXCJ0eXBlXCIsIFwiQ29tcG9zZWRcIiksIEMuc2V0Q2xhc3MoVW8pO1xuY2xhc3MgRHIgZXh0ZW5kcyBpdCB7XG4gIGdldEZyYWdtZW50U291cmNlKCkge1xuICAgIHJldHVybiBgXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gIHVuaWZvcm0gZmxvYXQgdUNvbnRyYXN0O1xuICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuICB2b2lkIG1haW4oKSB7XG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcbiAgICBmbG9hdCBjb250cmFzdEYgPSAxLjAxNSAqICh1Q29udHJhc3QgKyAxLjApIC8gKDEuMCAqICgxLjAxNSAtIHVDb250cmFzdCkpO1xuICAgIGNvbG9yLnJnYiA9IGNvbnRyYXN0RiAqIChjb2xvci5yZ2IgLSAwLjUpICsgMC41O1xuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICB9YDtcbiAgfVxuICBpc05ldXRyYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cmFzdCA9PT0gMDtcbiAgfVxuICBhcHBseVRvMmQodCkge1xuICAgIGxldCB7IGltYWdlRGF0YTogeyBkYXRhOiBlIH0gfSA9IHQ7XG4gICAgY29uc3QgcyA9IE1hdGguZmxvb3IoMjU1ICogdGhpcy5jb250cmFzdCksIHIgPSAyNTkgKiAocyArIDI1NSkgLyAoMjU1ICogKDI1OSAtIHMpKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuICs9IDQpIGVbbl0gPSByICogKGVbbl0gLSAxMjgpICsgMTI4LCBlW24gKyAxXSA9IHIgKiAoZVtuICsgMV0gLSAxMjgpICsgMTI4LCBlW24gKyAyXSA9IHIgKiAoZVtuICsgMl0gLSAxMjgpICsgMTI4O1xuICB9XG4gIHNlbmRVbmlmb3JtRGF0YSh0LCBlKSB7XG4gICAgdC51bmlmb3JtMWYoZS51Q29udHJhc3QsIHRoaXMuY29udHJhc3QpO1xuICB9XG59XG55KERyLCBcInR5cGVcIiwgXCJDb250cmFzdFwiKSwgeShEciwgXCJkZWZhdWx0c1wiLCB7IGNvbnRyYXN0OiAwIH0pLCB5KERyLCBcInVuaWZvcm1Mb2NhdGlvbnNcIiwgW1widUNvbnRyYXN0XCJdKSwgQy5zZXRDbGFzcyhEcik7XG5jb25zdCBOZCA9IHsgQ29udm9sdXRlXzNfMTogYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIGZsb2F0IHVNYXRyaXhbOV07XG4gICAgdW5pZm9ybSBmbG9hdCB1U3RlcFc7XG4gICAgdW5pZm9ybSBmbG9hdCB1U3RlcEg7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcbiAgICAgIGZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDMuMDsgaCs9MS4wKSB7XG4gICAgICAgIGZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDMuMDsgdys9MS4wKSB7XG4gICAgICAgICAgdmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMSksIHVTdGVwSCAqIChoIC0gMSkpO1xuICAgICAgICAgIGNvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiAzLjAgKyB3KV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBgLCBDb252b2x1dGVfM18wOiBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgIHVuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcbiAgICB1bmlmb3JtIGZsb2F0IHVTdGVwVztcbiAgICB1bmlmb3JtIGZsb2F0IHVTdGVwSDtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xuICAgICAgZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcbiAgICAgICAgZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgMy4wOyB3Kz0xLjApIHtcbiAgICAgICAgICB2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAxLjApLCB1U3RlcEggKiAoaCAtIDEuMCkpO1xuICAgICAgICAgIGNvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgICAgZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcbiAgICB9XG4gICAgYCwgQ29udm9sdXRlXzVfMTogYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIGZsb2F0IHVNYXRyaXhbMjVdO1xuICAgIHVuaWZvcm0gZmxvYXQgdVN0ZXBXO1xuICAgIHVuaWZvcm0gZmxvYXQgdVN0ZXBIO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XG4gICAgICBmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA1LjA7IGgrPTEuMCkge1xuICAgICAgICBmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA1LjA7IHcrPTEuMCkge1xuICAgICAgICAgIHZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDIuMCksIHVTdGVwSCAqIChoIC0gMi4wKSk7XG4gICAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDUuMCArIHcpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gICAgfVxuICAgIGAsIENvbnZvbHV0ZV81XzA6IGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBmbG9hdCB1TWF0cml4WzI1XTtcbiAgICB1bmlmb3JtIGZsb2F0IHVTdGVwVztcbiAgICB1bmlmb3JtIGZsb2F0IHVTdGVwSDtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xuICAgICAgZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNS4wOyBoKz0xLjApIHtcbiAgICAgICAgZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNS4wOyB3Kz0xLjApIHtcbiAgICAgICAgICB2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAyLjApLCB1U3RlcEggKiAoaCAtIDIuMCkpO1xuICAgICAgICAgIGNvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDUuMCArIHcpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgICAgZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcbiAgICB9XG4gICAgYCwgQ29udm9sdXRlXzdfMTogYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIGZsb2F0IHVNYXRyaXhbNDldO1xuICAgIHVuaWZvcm0gZmxvYXQgdVN0ZXBXO1xuICAgIHVuaWZvcm0gZmxvYXQgdVN0ZXBIO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XG4gICAgICBmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA3LjA7IGgrPTEuMCkge1xuICAgICAgICBmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA3LjA7IHcrPTEuMCkge1xuICAgICAgICAgIHZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDMuMCksIHVTdGVwSCAqIChoIC0gMy4wKSk7XG4gICAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDcuMCArIHcpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gICAgfVxuICAgIGAsIENvbnZvbHV0ZV83XzA6IGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBmbG9hdCB1TWF0cml4WzQ5XTtcbiAgICB1bmlmb3JtIGZsb2F0IHVTdGVwVztcbiAgICB1bmlmb3JtIGZsb2F0IHVTdGVwSDtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xuICAgICAgZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNy4wOyBoKz0xLjApIHtcbiAgICAgICAgZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNy4wOyB3Kz0xLjApIHtcbiAgICAgICAgICB2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAzLjApLCB1U3RlcEggKiAoaCAtIDMuMCkpO1xuICAgICAgICAgIGNvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDcuMCArIHcpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgICAgZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcbiAgICB9XG4gICAgYCwgQ29udm9sdXRlXzlfMTogYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIGZsb2F0IHVNYXRyaXhbODFdO1xuICAgIHVuaWZvcm0gZmxvYXQgdVN0ZXBXO1xuICAgIHVuaWZvcm0gZmxvYXQgdVN0ZXBIO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XG4gICAgICBmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA5LjA7IGgrPTEuMCkge1xuICAgICAgICBmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA5LjA7IHcrPTEuMCkge1xuICAgICAgICAgIHZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDQuMCksIHVTdGVwSCAqIChoIC0gNC4wKSk7XG4gICAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDkuMCArIHcpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gICAgfVxuICAgIGAsIENvbnZvbHV0ZV85XzA6IGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBmbG9hdCB1TWF0cml4WzgxXTtcbiAgICB1bmlmb3JtIGZsb2F0IHVTdGVwVztcbiAgICB1bmlmb3JtIGZsb2F0IHVTdGVwSDtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xuICAgICAgZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgOS4wOyBoKz0xLjApIHtcbiAgICAgICAgZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgOS4wOyB3Kz0xLjApIHtcbiAgICAgICAgICB2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSA0LjApLCB1U3RlcEggKiAoaCAtIDQuMCkpO1xuICAgICAgICAgIGNvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDkuMCArIHcpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgICAgZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcbiAgICB9XG4gICAgYCB9O1xuY2xhc3MganIgZXh0ZW5kcyBpdCB7XG4gIGdldENhY2hlS2V5KCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnR5cGUsIFwiX1wiKS5jb25jYXQoTWF0aC5zcXJ0KHRoaXMubWF0cml4Lmxlbmd0aCksIFwiX1wiKS5jb25jYXQodGhpcy5vcGFxdWUgPyAxIDogMCk7XG4gIH1cbiAgZ2V0RnJhZ21lbnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIE5kW3RoaXMuZ2V0Q2FjaGVLZXkoKV07XG4gIH1cbiAgYXBwbHlUbzJkKHQpIHtcbiAgICBjb25zdCBlID0gdC5pbWFnZURhdGEsIHMgPSBlLmRhdGEsIHIgPSB0aGlzLm1hdHJpeCwgbiA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHIubGVuZ3RoKSksIG8gPSBNYXRoLmZsb29yKG4gLyAyKSwgYSA9IGUud2lkdGgsIGMgPSBlLmhlaWdodCwgbCA9IHQuY3R4LmNyZWF0ZUltYWdlRGF0YShhLCBjKSwgaCA9IGwuZGF0YSwgdSA9IHRoaXMub3BhcXVlID8gMSA6IDA7XG4gICAgbGV0IGQsIGYsIGcsIHAsIG0sIGIsIFMsIHcsIGssIE8sIHgsIEksIE07XG4gICAgZm9yICh4ID0gMDsgeCA8IGM7IHgrKykgZm9yIChPID0gMDsgTyA8IGE7IE8rKykge1xuICAgICAgZm9yIChtID0gNCAqICh4ICogYSArIE8pLCBkID0gMCwgZiA9IDAsIGcgPSAwLCBwID0gMCwgTSA9IDA7IE0gPCBuOyBNKyspIGZvciAoSSA9IDA7IEkgPCBuOyBJKyspIFMgPSB4ICsgTSAtIG8sIGIgPSBPICsgSSAtIG8sIFMgPCAwIHx8IFMgPj0gYyB8fCBiIDwgMCB8fCBiID49IGEgfHwgKHcgPSA0ICogKFMgKiBhICsgYiksIGsgPSByW00gKiBuICsgSV0sIGQgKz0gc1t3XSAqIGssIGYgKz0gc1t3ICsgMV0gKiBrLCBnICs9IHNbdyArIDJdICogaywgdSB8fCAocCArPSBzW3cgKyAzXSAqIGspKTtcbiAgICAgIGhbbV0gPSBkLCBoW20gKyAxXSA9IGYsIGhbbSArIDJdID0gZywgaFttICsgM10gPSB1ID8gc1ttICsgM10gOiBwO1xuICAgIH1cbiAgICB0LmltYWdlRGF0YSA9IGw7XG4gIH1cbiAgc2VuZFVuaWZvcm1EYXRhKHQsIGUpIHtcbiAgICB0LnVuaWZvcm0xZnYoZS51TWF0cml4LCB0aGlzLm1hdHJpeCk7XG4gIH1cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHYodih7fSwgc3VwZXIudG9PYmplY3QoKSksIHt9LCB7IG9wYXF1ZTogdGhpcy5vcGFxdWUsIG1hdHJpeDogWy4uLnRoaXMubWF0cml4XSB9KTtcbiAgfVxufVxueShqciwgXCJ0eXBlXCIsIFwiQ29udm9sdXRlXCIpLCB5KGpyLCBcImRlZmF1bHRzXCIsIHsgb3BhcXVlOiAhMSwgbWF0cml4OiBbMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMF0gfSksIHkoanIsIFwidW5pZm9ybUxvY2F0aW9uc1wiLCBbXCJ1TWF0cml4XCIsIFwidU9wYXF1ZVwiLCBcInVIYWxmU2l6ZVwiLCBcInVTaXplXCJdKSwgQy5zZXRDbGFzcyhqcik7XG5jb25zdCBmbCA9IFwiR2FtbWFcIjtcbmNsYXNzIEVyIGV4dGVuZHMgaXQge1xuICBnZXRGcmFnbWVudFNvdXJjZSgpIHtcbiAgICByZXR1cm4gYFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICB1bmlmb3JtIHZlYzMgdUdhbW1hO1xuICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuICB2b2lkIG1haW4oKSB7XG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcbiAgICB2ZWMzIGNvcnJlY3Rpb24gPSAoMS4wIC8gdUdhbW1hKTtcbiAgICBjb2xvci5yID0gcG93KGNvbG9yLnIsIGNvcnJlY3Rpb24ucik7XG4gICAgY29sb3IuZyA9IHBvdyhjb2xvci5nLCBjb3JyZWN0aW9uLmcpO1xuICAgIGNvbG9yLmIgPSBwb3coY29sb3IuYiwgY29ycmVjdGlvbi5iKTtcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgICBnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yLmE7XG4gIH1cbmA7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKHQpLCB0aGlzLmdhbW1hID0gdC5nYW1tYSB8fCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzLmdhbW1hLmNvbmNhdCgpO1xuICB9XG4gIGFwcGx5VG8yZCh0KSB7XG4gICAgbGV0IHsgaW1hZ2VEYXRhOiB7IGRhdGE6IGUgfSB9ID0gdDtcbiAgICBjb25zdCBzID0gdGhpcy5nYW1tYSwgciA9IDEgLyBzWzBdLCBuID0gMSAvIHNbMV0sIG8gPSAxIC8gc1syXTtcbiAgICB0aGlzLnJnYlZhbHVlcyB8fCAodGhpcy5yZ2JWYWx1ZXMgPSB7IHI6IG5ldyBVaW50OEFycmF5KDI1NiksIGc6IG5ldyBVaW50OEFycmF5KDI1NiksIGI6IG5ldyBVaW50OEFycmF5KDI1NikgfSk7XG4gICAgY29uc3QgYSA9IHRoaXMucmdiVmFsdWVzO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgMjU2OyBjKyspIGEucltjXSA9IDI1NSAqIE1hdGgucG93KGMgLyAyNTUsIHIpLCBhLmdbY10gPSAyNTUgKiBNYXRoLnBvdyhjIC8gMjU1LCBuKSwgYS5iW2NdID0gMjU1ICogTWF0aC5wb3coYyAvIDI1NSwgbyk7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBlLmxlbmd0aDsgYyArPSA0KSBlW2NdID0gYS5yW2VbY11dLCBlW2MgKyAxXSA9IGEuZ1tlW2MgKyAxXV0sIGVbYyArIDJdID0gYS5iW2VbYyArIDJdXTtcbiAgfVxuICBzZW5kVW5pZm9ybURhdGEodCwgZSkge1xuICAgIHQudW5pZm9ybTNmdihlLnVHYW1tYSwgdGhpcy5nYW1tYSk7XG4gIH1cbiAgaXNOZXV0cmFsU3RhdGUoKSB7XG4gICAgY29uc3QgeyBnYW1tYTogdCB9ID0gdGhpcztcbiAgICByZXR1cm4gdFswXSA9PT0gMSAmJiB0WzFdID09PSAxICYmIHRbMl0gPT09IDE7XG4gIH1cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogZmwsIGdhbW1hOiB0aGlzLmdhbW1hLmNvbmNhdCgpIH07XG4gIH1cbn1cbnkoRXIsIFwidHlwZVwiLCBmbCksIHkoRXIsIFwiZGVmYXVsdHNcIiwgeyBnYW1tYTogWzEsIDEsIDFdIH0pLCB5KEVyLCBcInVuaWZvcm1Mb2NhdGlvbnNcIiwgW1widUdhbW1hXCJdKSwgQy5zZXRDbGFzcyhFcik7XG5jb25zdCBVZCA9IHsgYXZlcmFnZTogYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XG4gICAgICBmbG9hdCBhdmVyYWdlID0gKGNvbG9yLnIgKyBjb2xvci5iICsgY29sb3IuZykgLyAzLjA7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGF2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGNvbG9yLmEpO1xuICAgIH1cbiAgICBgLCBsaWdodG5lc3M6IGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBpbnQgdU1vZGU7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IGNvbCA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcbiAgICAgIGZsb2F0IGF2ZXJhZ2UgPSAobWF4KG1heChjb2wuciwgY29sLmcpLGNvbC5iKSArIG1pbihtaW4oY29sLnIsIGNvbC5nKSxjb2wuYikpIC8gMi4wO1xuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2wuYSk7XG4gICAgfVxuICAgIGAsIGx1bWlub3NpdHk6IGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBpbnQgdU1vZGU7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IGNvbCA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcbiAgICAgIGZsb2F0IGF2ZXJhZ2UgPSAwLjIxICogY29sLnIgKyAwLjcyICogY29sLmcgKyAwLjA3ICogY29sLmI7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGF2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGNvbC5hKTtcbiAgICB9XG4gICAgYCB9O1xuY2xhc3MgUHIgZXh0ZW5kcyBpdCB7XG4gIGFwcGx5VG8yZCh0KSB7XG4gICAgbGV0IHsgaW1hZ2VEYXRhOiB7IGRhdGE6IGUgfSB9ID0gdDtcbiAgICBmb3IgKGxldCBzLCByID0gMDsgciA8IGUubGVuZ3RoOyByICs9IDQpIHtcbiAgICAgIGNvbnN0IG4gPSBlW3JdLCBvID0gZVtyICsgMV0sIGEgPSBlW3IgKyAyXTtcbiAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgIGNhc2UgXCJhdmVyYWdlXCI6XG4gICAgICAgICAgcyA9IChuICsgbyArIGEpIC8gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxpZ2h0bmVzc1wiOlxuICAgICAgICAgIHMgPSAoTWF0aC5taW4obiwgbywgYSkgKyBNYXRoLm1heChuLCBvLCBhKSkgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibHVtaW5vc2l0eVwiOlxuICAgICAgICAgIHMgPSAwLjIxICogbiArIDAuNzIgKiBvICsgMC4wNyAqIGE7XG4gICAgICB9XG4gICAgICBlW3IgKyAyXSA9IGVbciArIDFdID0gZVtyXSA9IHM7XG4gICAgfVxuICB9XG4gIGdldENhY2hlS2V5KCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnR5cGUsIFwiX1wiKS5jb25jYXQodGhpcy5tb2RlKTtcbiAgfVxuICBnZXRGcmFnbWVudFNvdXJjZSgpIHtcbiAgICByZXR1cm4gVWRbdGhpcy5tb2RlXTtcbiAgfVxuICBzZW5kVW5pZm9ybURhdGEodCwgZSkge1xuICAgIHQudW5pZm9ybTFpKGUudU1vZGUsIDEpO1xuICB9XG4gIGlzTmV1dHJhbFN0YXRlKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxueShQciwgXCJ0eXBlXCIsIFwiR3JheXNjYWxlXCIpLCB5KFByLCBcImRlZmF1bHRzXCIsIHsgbW9kZTogXCJhdmVyYWdlXCIgfSksIHkoUHIsIFwidW5pZm9ybUxvY2F0aW9uc1wiLCBbXCJ1TW9kZVwiXSksIEMuc2V0Q2xhc3MoUHIpO1xuY29uc3QgJGQgPSB2KHYoe30sIGRsKSwge30sIHsgcm90YXRpb246IDAgfSk7XG5jbGFzcyBxaSBleHRlbmRzIHRzIHtcbiAgY2FsY3VsYXRlTWF0cml4KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnJvdGF0aW9uICogTWF0aC5QSSwgZSA9IEx0KHQpLCBzID0gQnQodCksIHIgPSAxIC8gMywgbiA9IE1hdGguc3FydChyKSAqIHMsIG8gPSAxIC0gZTtcbiAgICB0aGlzLm1hdHJpeCA9IFtlICsgbyAvIDMsIHIgKiBvIC0gbiwgciAqIG8gKyBuLCAwLCAwLCByICogbyArIG4sIGUgKyByICogbywgciAqIG8gLSBuLCAwLCAwLCByICogbyAtIG4sIHIgKiBvICsgbiwgZSArIHIgKiBvLCAwLCAwLCAwLCAwLCAwLCAxLCAwXTtcbiAgfVxuICBpc05ldXRyYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGlvbiA9PT0gMDtcbiAgfVxuICBhcHBseVRvKHQpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpLCBzdXBlci5hcHBseVRvKHQpO1xuICB9XG4gIHRvT2JqZWN0KCkge1xuICAgIHJldHVybiB7IHR5cGU6IHRoaXMudHlwZSwgcm90YXRpb246IHRoaXMucm90YXRpb24gfTtcbiAgfVxufVxueShxaSwgXCJ0eXBlXCIsIFwiSHVlUm90YXRpb25cIiksIHkocWksIFwiZGVmYXVsdHNcIiwgJGQpLCBDLnNldENsYXNzKHFpKTtcbmNsYXNzIEFyIGV4dGVuZHMgaXQge1xuICBhcHBseVRvMmQodCkge1xuICAgIGxldCB7IGltYWdlRGF0YTogeyBkYXRhOiBlIH0gfSA9IHQ7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcyArPSA0KSBlW3NdID0gMjU1IC0gZVtzXSwgZVtzICsgMV0gPSAyNTUgLSBlW3MgKyAxXSwgZVtzICsgMl0gPSAyNTUgLSBlW3MgKyAyXSwgdGhpcy5hbHBoYSAmJiAoZVtzICsgM10gPSAyNTUgLSBlW3MgKyAzXSk7XG4gIH1cbiAgZ2V0RnJhZ21lbnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIGBcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgdW5pZm9ybSBpbnQgdUludmVydDtcbiAgdW5pZm9ybSBpbnQgdUFscGhhO1xuICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuICB2b2lkIG1haW4oKSB7XG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcbiAgICBpZiAodUludmVydCA9PSAxKSB7XG4gICAgICBpZiAodUFscGhhID09IDEpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAgLSBjb2xvci5yLDEuMCAtY29sb3IuZywxLjAgLWNvbG9yLmIsMS4wIC1jb2xvci5hKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wIC0gY29sb3IuciwxLjAgLWNvbG9yLmcsMS4wIC1jb2xvci5iLGNvbG9yLmEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgICB9XG4gIH1cbmA7XG4gIH1cbiAgaXNOZXV0cmFsU3RhdGUoKSB7XG4gICAgcmV0dXJuICF0aGlzLmludmVydDtcbiAgfVxuICBzZW5kVW5pZm9ybURhdGEodCwgZSkge1xuICAgIHQudW5pZm9ybTFpKGUudUludmVydCwgTnVtYmVyKHRoaXMuaW52ZXJ0KSksIHQudW5pZm9ybTFpKGUudUFscGhhLCBOdW1iZXIodGhpcy5hbHBoYSkpO1xuICB9XG59XG55KEFyLCBcInR5cGVcIiwgXCJJbnZlcnRcIiksIHkoQXIsIFwiZGVmYXVsdHNcIiwgeyBhbHBoYTogITEsIGludmVydDogITAgfSksIHkoQXIsIFwidW5pZm9ybUxvY2F0aW9uc1wiLCBbXCJ1SW52ZXJ0XCIsIFwidUFscGhhXCJdKSwgQy5zZXRDbGFzcyhBcik7XG5jbGFzcyBGciBleHRlbmRzIGl0IHtcbiAgZ2V0RnJhZ21lbnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIGBcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgdW5pZm9ybSBmbG9hdCB1U3RlcEg7XG4gIHVuaWZvcm0gZmxvYXQgdU5vaXNlO1xuICB1bmlmb3JtIGZsb2F0IHVTZWVkO1xuICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuICBmbG9hdCByYW5kKHZlYzIgY28sIGZsb2F0IHNlZWQsIGZsb2F0IHZTY2FsZSkge1xuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5ICogdlNjYWxlICx2ZWMyKDEyLjk4OTggLCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzICogKHNlZWQgKyAwLjAxKSAvIDIuMCk7XG4gIH1cbiAgdm9pZCBtYWluKCkge1xuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XG4gICAgY29sb3IucmdiICs9ICgwLjUgLSByYW5kKHZUZXhDb29yZCwgdVNlZWQsIDAuMSAvIHVTdGVwSCkpICogdU5vaXNlO1xuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICB9XG5gO1xuICB9XG4gIGFwcGx5VG8yZCh0KSB7XG4gICAgbGV0IHsgaW1hZ2VEYXRhOiB7IGRhdGE6IGUgfSB9ID0gdDtcbiAgICBjb25zdCBzID0gdGhpcy5ub2lzZTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByICs9IDQpIHtcbiAgICAgIGNvbnN0IG4gPSAoMC41IC0gTWF0aC5yYW5kb20oKSkgKiBzO1xuICAgICAgZVtyXSArPSBuLCBlW3IgKyAxXSArPSBuLCBlW3IgKyAyXSArPSBuO1xuICAgIH1cbiAgfVxuICBzZW5kVW5pZm9ybURhdGEodCwgZSkge1xuICAgIHQudW5pZm9ybTFmKGUudU5vaXNlLCB0aGlzLm5vaXNlIC8gMjU1KSwgdC51bmlmb3JtMWYoZS51U2VlZCwgTWF0aC5yYW5kb20oKSk7XG4gIH1cbiAgaXNOZXV0cmFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9pc2UgPT09IDA7XG4gIH1cbn1cbnkoRnIsIFwidHlwZVwiLCBcIk5vaXNlXCIpLCB5KEZyLCBcImRlZmF1bHRzXCIsIHsgbm9pc2U6IDAgfSksIHkoRnIsIFwidW5pZm9ybUxvY2F0aW9uc1wiLCBbXCJ1Tm9pc2VcIiwgXCJ1U2VlZFwiXSksIEMuc2V0Q2xhc3MoRnIpO1xuY2xhc3MgUnIgZXh0ZW5kcyBpdCB7XG4gIGFwcGx5VG8yZCh0KSB7XG4gICAgbGV0IHsgaW1hZ2VEYXRhOiB7IGRhdGE6IGUsIHdpZHRoOiBzLCBoZWlnaHQ6IHIgfSB9ID0gdDtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHI7IG4gKz0gdGhpcy5ibG9ja3NpemUpIGZvciAobGV0IG8gPSAwOyBvIDwgczsgbyArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuICAgICAgY29uc3QgYSA9IDQgKiBuICogcyArIDQgKiBvLCBjID0gZVthXSwgbCA9IGVbYSArIDFdLCBoID0gZVthICsgMl0sIHUgPSBlW2EgKyAzXTtcbiAgICAgIGZvciAobGV0IGQgPSBuOyBkIDwgTWF0aC5taW4obiArIHRoaXMuYmxvY2tzaXplLCByKTsgZCsrKSBmb3IgKGxldCBmID0gbzsgZiA8IE1hdGgubWluKG8gKyB0aGlzLmJsb2Nrc2l6ZSwgcyk7IGYrKykge1xuICAgICAgICBjb25zdCBnID0gNCAqIGQgKiBzICsgNCAqIGY7XG4gICAgICAgIGVbZ10gPSBjLCBlW2cgKyAxXSA9IGwsIGVbZyArIDJdID0gaCwgZVtnICsgM10gPSB1O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc05ldXRyYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3NpemUgPT09IDE7XG4gIH1cbiAgZ2V0RnJhZ21lbnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIGBcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgdW5pZm9ybSBmbG9hdCB1QmxvY2tzaXplO1xuICB1bmlmb3JtIGZsb2F0IHVTdGVwVztcbiAgdW5pZm9ybSBmbG9hdCB1U3RlcEg7XG4gIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG4gIHZvaWQgbWFpbigpIHtcbiAgICBmbG9hdCBibG9ja1cgPSB1QmxvY2tzaXplICogdVN0ZXBXO1xuICAgIGZsb2F0IGJsb2NrSCA9IHVCbG9ja3NpemUgKiB1U3RlcEg7XG4gICAgaW50IHBvc1ggPSBpbnQodlRleENvb3JkLnggLyBibG9ja1cpO1xuICAgIGludCBwb3NZID0gaW50KHZUZXhDb29yZC55IC8gYmxvY2tIKTtcbiAgICBmbG9hdCBmcG9zWCA9IGZsb2F0KHBvc1gpO1xuICAgIGZsb2F0IGZwb3NZID0gZmxvYXQocG9zWSk7XG4gICAgdmVjMiBzcXVhcmVDb29yZHMgPSB2ZWMyKGZwb3NYICogYmxvY2tXLCBmcG9zWSAqIGJsb2NrSCk7XG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgc3F1YXJlQ29vcmRzKTtcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgfVxuYDtcbiAgfVxuICBzZW5kVW5pZm9ybURhdGEodCwgZSkge1xuICAgIHQudW5pZm9ybTFmKGUudUJsb2Nrc2l6ZSwgdGhpcy5ibG9ja3NpemUpO1xuICB9XG59XG55KFJyLCBcInR5cGVcIiwgXCJQaXhlbGF0ZVwiKSwgeShSciwgXCJkZWZhdWx0c1wiLCB7IGJsb2Nrc2l6ZTogNCB9KSwgeShSciwgXCJ1bmlmb3JtTG9jYXRpb25zXCIsIFtcInVCbG9ja3NpemVcIl0pLCBDLnNldENsYXNzKFJyKTtcbmNsYXNzIExyIGV4dGVuZHMgaXQge1xuICBnZXRGcmFnbWVudFNvdXJjZSgpIHtcbiAgICByZXR1cm4gYFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG51bmlmb3JtIHZlYzQgdUxvdztcbnVuaWZvcm0gdmVjNCB1SGlnaDtcbnZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG52b2lkIG1haW4oKSB7XG4gIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcbiAgaWYoYWxsKGdyZWF0ZXJUaGFuKGdsX0ZyYWdDb2xvci5yZ2IsdUxvdy5yZ2IpKSAmJiBhbGwoZ3JlYXRlclRoYW4odUhpZ2gucmdiLGdsX0ZyYWdDb2xvci5yZ2IpKSkge1xuICAgIGdsX0ZyYWdDb2xvci5hID0gMC4wO1xuICB9XG59XG5gO1xuICB9XG4gIGFwcGx5VG8yZCh0KSB7XG4gICAgbGV0IHsgaW1hZ2VEYXRhOiB7IGRhdGE6IGUgfSB9ID0gdDtcbiAgICBjb25zdCBzID0gMjU1ICogdGhpcy5kaXN0YW5jZSwgciA9IG5ldyBXKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpLCBuID0gW3JbMF0gLSBzLCByWzFdIC0gcywgclsyXSAtIHNdLCBvID0gW3JbMF0gKyBzLCByWzFdICsgcywgclsyXSArIHNdO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgZS5sZW5ndGg7IGEgKz0gNCkge1xuICAgICAgY29uc3QgYyA9IGVbYV0sIGwgPSBlW2EgKyAxXSwgaCA9IGVbYSArIDJdO1xuICAgICAgYyA+IG5bMF0gJiYgbCA+IG5bMV0gJiYgaCA+IG5bMl0gJiYgYyA8IG9bMF0gJiYgbCA8IG9bMV0gJiYgaCA8IG9bMl0gJiYgKGVbYSArIDNdID0gMCk7XG4gICAgfVxuICB9XG4gIHNlbmRVbmlmb3JtRGF0YSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IG5ldyBXKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpLCByID0gdGhpcy5kaXN0YW5jZSwgbiA9IFswICsgc1swXSAvIDI1NSAtIHIsIDAgKyBzWzFdIC8gMjU1IC0gciwgMCArIHNbMl0gLyAyNTUgLSByLCAxXSwgbyA9IFtzWzBdIC8gMjU1ICsgciwgc1sxXSAvIDI1NSArIHIsIHNbMl0gLyAyNTUgKyByLCAxXTtcbiAgICB0LnVuaWZvcm00ZnYoZS51TG93LCBuKSwgdC51bmlmb3JtNGZ2KGUudUhpZ2gsIG8pO1xuICB9XG59XG55KExyLCBcInR5cGVcIiwgXCJSZW1vdmVDb2xvclwiKSwgeShMciwgXCJkZWZhdWx0c1wiLCB7IGNvbG9yOiBcIiNGRkZGRkZcIiwgZGlzdGFuY2U6IDAuMDIsIHVzZUFscGhhOiAhMSB9KSwgeShMciwgXCJ1bmlmb3JtTG9jYXRpb25zXCIsIFtcInVMb3dcIiwgXCJ1SGlnaFwiXSksIEMuc2V0Q2xhc3MoTHIpO1xuY2xhc3MgQnIgZXh0ZW5kcyBpdCB7XG4gIHNlbmRVbmlmb3JtRGF0YSh0LCBlKSB7XG4gICAgdC51bmlmb3JtMmZ2KGUudURlbHRhLCB0aGlzLmhvcml6b250YWwgPyBbMSAvIHRoaXMud2lkdGgsIDBdIDogWzAsIDEgLyB0aGlzLmhlaWdodF0pLCB0LnVuaWZvcm0xZnYoZS51VGFwcywgdGhpcy50YXBzKTtcbiAgfVxuICBnZXRGaWx0ZXJXaW5kb3coKSB7XG4gICAgY29uc3QgdCA9IHRoaXMudGVtcFNjYWxlO1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5sYW5jem9zTG9iZXMgLyB0KTtcbiAgfVxuICBnZXRDYWNoZUtleSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRGaWx0ZXJXaW5kb3coKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy50eXBlLCBcIl9cIikuY29uY2F0KHQpO1xuICB9XG4gIGdldEZyYWdtZW50U291cmNlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldEZpbHRlcldpbmRvdygpO1xuICAgIHJldHVybiB0aGlzLmdlbmVyYXRlU2hhZGVyKHQpO1xuICB9XG4gIGdldFRhcHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksIGUgPSB0aGlzLnRlbXBTY2FsZSwgcyA9IHRoaXMuZ2V0RmlsdGVyV2luZG93KCksIHIgPSBuZXcgQXJyYXkocyk7XG4gICAgZm9yIChsZXQgbiA9IDE7IG4gPD0gczsgbisrKSByW24gLSAxXSA9IHQobiAqIGUpO1xuICAgIHJldHVybiByO1xuICB9XG4gIGdlbmVyYXRlU2hhZGVyKHQpIHtcbiAgICBjb25zdCBlID0gbmV3IEFycmF5KHQpO1xuICAgIGZvciAobGV0IHMgPSAxOyBzIDw9IHQ7IHMrKykgZVtzIC0gMV0gPSBcIlwiLmNvbmNhdChzLCBcIi4wICogdURlbHRhXCIpO1xuICAgIHJldHVybiBgXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICAgIHVuaWZvcm0gdmVjMiB1RGVsdGE7XG4gICAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1VGFwc1tgLmNvbmNhdCh0LCBgXTtcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcbiAgICAgICAgZmxvYXQgc3VtID0gMS4wO1xuICAgICAgICBgKS5jb25jYXQoZS5tYXAoKHMsIHIpID0+IGBcbiAgICAgICAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBgLmNvbmNhdChzLCBcIikgKiB1VGFwc1tcIikuY29uY2F0KHIsIFwiXSArIHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkIC0gXCIpLmNvbmNhdChzLCBcIikgKiB1VGFwc1tcIikuY29uY2F0KHIsIGBdO1xuICAgICAgICAgICAgICBzdW0gKz0gMi4wICogdVRhcHNbYCkuY29uY2F0KHIsIGBdO1xuICAgICAgICAgICAgYCkpLmpvaW4oYFxuYCksIGBcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyBzdW07XG4gICAgICB9XG4gICAgYCk7XG4gIH1cbiAgYXBwbHlUb0ZvcldlYmdsKHQpIHtcbiAgICB0LnBhc3NlcysrLCB0aGlzLndpZHRoID0gdC5zb3VyY2VXaWR0aCwgdGhpcy5ob3Jpem9udGFsID0gITAsIHRoaXMuZFcgPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiB0aGlzLnNjYWxlWCksIHRoaXMuZEggPSB0LnNvdXJjZUhlaWdodCwgdGhpcy50ZW1wU2NhbGUgPSB0aGlzLmRXIC8gdGhpcy53aWR0aCwgdGhpcy50YXBzID0gdGhpcy5nZXRUYXBzKCksIHQuZGVzdGluYXRpb25XaWR0aCA9IHRoaXMuZFcsIHN1cGVyLmFwcGx5VG8odCksIHQuc291cmNlV2lkdGggPSB0LmRlc3RpbmF0aW9uV2lkdGgsIHRoaXMuaGVpZ2h0ID0gdC5zb3VyY2VIZWlnaHQsIHRoaXMuaG9yaXpvbnRhbCA9ICExLCB0aGlzLmRIID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHRoaXMuc2NhbGVZKSwgdGhpcy50ZW1wU2NhbGUgPSB0aGlzLmRIIC8gdGhpcy5oZWlnaHQsIHRoaXMudGFwcyA9IHRoaXMuZ2V0VGFwcygpLCB0LmRlc3RpbmF0aW9uSGVpZ2h0ID0gdGhpcy5kSCwgc3VwZXIuYXBwbHlUbyh0KSwgdC5zb3VyY2VIZWlnaHQgPSB0LmRlc3RpbmF0aW9uSGVpZ2h0O1xuICB9XG4gIGFwcGx5VG8odCkge1xuICAgIGtpKHQpID8gdGhpcy5hcHBseVRvRm9yV2ViZ2wodCkgOiB0aGlzLmFwcGx5VG8yZCh0KTtcbiAgfVxuICBpc05ldXRyYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZVggPT09IDEgJiYgdGhpcy5zY2FsZVkgPT09IDE7XG4gIH1cbiAgbGFuY3pvc0NyZWF0ZSh0KSB7XG4gICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICBpZiAoZSA+PSB0IHx8IGUgPD0gLXQpIHJldHVybiAwO1xuICAgICAgaWYgKGUgPCAxMTkyMDkyOWUtMTQgJiYgZSA+IC0xMTkyMDkyOWUtMTQpIHJldHVybiAxO1xuICAgICAgY29uc3QgcyA9IChlICo9IE1hdGguUEkpIC8gdDtcbiAgICAgIHJldHVybiBNYXRoLnNpbihlKSAvIGUgKiBNYXRoLnNpbihzKSAvIHM7XG4gICAgfTtcbiAgfVxuICBhcHBseVRvMmQodCkge1xuICAgIGNvbnN0IGUgPSB0LmltYWdlRGF0YSwgcyA9IHRoaXMuc2NhbGVYLCByID0gdGhpcy5zY2FsZVk7XG4gICAgdGhpcy5yY3BTY2FsZVggPSAxIC8gcywgdGhpcy5yY3BTY2FsZVkgPSAxIC8gcjtcbiAgICBjb25zdCBuID0gZS53aWR0aCwgbyA9IGUuaGVpZ2h0LCBhID0gTWF0aC5yb3VuZChuICogcyksIGMgPSBNYXRoLnJvdW5kKG8gKiByKTtcbiAgICBsZXQgbDtcbiAgICBsID0gdGhpcy5yZXNpemVUeXBlID09PSBcInNsaWNlSGFja1wiID8gdGhpcy5zbGljZUJ5VHdvKHQsIG4sIG8sIGEsIGMpIDogdGhpcy5yZXNpemVUeXBlID09PSBcImhlcm1pdGVcIiA/IHRoaXMuaGVybWl0ZUZhc3RSZXNpemUodCwgbiwgbywgYSwgYykgOiB0aGlzLnJlc2l6ZVR5cGUgPT09IFwiYmlsaW5lYXJcIiA/IHRoaXMuYmlsaW5lYXJGaWx0ZXJpbmcodCwgbiwgbywgYSwgYykgOiB0aGlzLnJlc2l6ZVR5cGUgPT09IFwibGFuY3pvc1wiID8gdGhpcy5sYW5jem9zUmVzaXplKHQsIG4sIG8sIGEsIGMpIDogbmV3IEltYWdlRGF0YShhLCBjKSwgdC5pbWFnZURhdGEgPSBsO1xuICB9XG4gIHNsaWNlQnlUd28odCwgZSwgcywgciwgbikge1xuICAgIGNvbnN0IG8gPSB0LmltYWdlRGF0YSwgYSA9IDAuNTtcbiAgICBsZXQgYyA9ICExLCBsID0gITEsIGggPSBlICogYSwgdSA9IHMgKiBhO1xuICAgIGNvbnN0IGQgPSB0LmZpbHRlckJhY2tlbmQucmVzb3VyY2VzO1xuICAgIGxldCBmID0gMCwgZyA9IDA7XG4gICAgY29uc3QgcCA9IGU7XG4gICAgbGV0IG0gPSAwO1xuICAgIGQuc2xpY2VCeVR3byB8fCAoZC5zbGljZUJ5VHdvID0ga3QoKSk7XG4gICAgY29uc3QgYiA9IGQuc2xpY2VCeVR3bztcbiAgICAoYi53aWR0aCA8IDEuNSAqIGUgfHwgYi5oZWlnaHQgPCBzKSAmJiAoYi53aWR0aCA9IDEuNSAqIGUsIGIuaGVpZ2h0ID0gcyk7XG4gICAgY29uc3QgUyA9IGIuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGZvciAoUy5jbGVhclJlY3QoMCwgMCwgMS41ICogZSwgcyksIFMucHV0SW1hZ2VEYXRhKG8sIDAsIDApLCByID0gTWF0aC5mbG9vcihyKSwgbiA9IE1hdGguZmxvb3Iobik7ICFjIHx8ICFsOyApIGUgPSBoLCBzID0gdSwgciA8IE1hdGguZmxvb3IoaCAqIGEpID8gaCA9IE1hdGguZmxvb3IoaCAqIGEpIDogKGggPSByLCBjID0gITApLCBuIDwgTWF0aC5mbG9vcih1ICogYSkgPyB1ID0gTWF0aC5mbG9vcih1ICogYSkgOiAodSA9IG4sIGwgPSAhMCksIFMuZHJhd0ltYWdlKGIsIGYsIGcsIGUsIHMsIHAsIG0sIGgsIHUpLCBmID0gcCwgZyA9IG0sIG0gKz0gdTtcbiAgICByZXR1cm4gUy5nZXRJbWFnZURhdGEoZiwgZywgciwgbik7XG4gIH1cbiAgbGFuY3pvc1Jlc2l6ZSh0LCBlLCBzLCByLCBuKSB7XG4gICAgY29uc3QgbyA9IHQuaW1hZ2VEYXRhLmRhdGEsIGEgPSB0LmN0eC5jcmVhdGVJbWFnZURhdGEociwgbiksIGMgPSBhLmRhdGEsIGwgPSB0aGlzLmxhbmN6b3NDcmVhdGUodGhpcy5sYW5jem9zTG9iZXMpLCBoID0gdGhpcy5yY3BTY2FsZVgsIHUgPSB0aGlzLnJjcFNjYWxlWSwgZCA9IDIgLyB0aGlzLnJjcFNjYWxlWCwgZiA9IDIgLyB0aGlzLnJjcFNjYWxlWSwgZyA9IE1hdGguY2VpbChoICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSwgcCA9IE1hdGguY2VpbCh1ICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSwgbSA9IHt9LCBiID0geyB4OiAwLCB5OiAwIH0sIFMgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdyhrKSB7XG4gICAgICBsZXQgTywgeCwgSSwgTSwgRSwgUiwgdHQsIEYsIEIsICQsIHl0O1xuICAgICAgZm9yIChiLnggPSAoayArIDAuNSkgKiBoLCBTLnggPSBNYXRoLmZsb29yKGIueCksIE8gPSAwOyBPIDwgbjsgTysrKSB7XG4gICAgICAgIGZvciAoYi55ID0gKE8gKyAwLjUpICogdSwgUy55ID0gTWF0aC5mbG9vcihiLnkpLCBFID0gMCwgUiA9IDAsIHR0ID0gMCwgRiA9IDAsIEIgPSAwLCB4ID0gUy54IC0gZzsgeCA8PSBTLnggKyBnOyB4KyspIGlmICghKHggPCAwIHx8IHggPj0gZSkpIHtcbiAgICAgICAgICAkID0gTWF0aC5mbG9vcigxZTMgKiBNYXRoLmFicyh4IC0gYi54KSksIG1bJF0gfHwgKG1bJF0gPSB7fSk7XG4gICAgICAgICAgZm9yIChsZXQgZHQgPSBTLnkgLSBwOyBkdCA8PSBTLnkgKyBwOyBkdCsrKSBkdCA8IDAgfHwgZHQgPj0gcyB8fCAoeXQgPSBNYXRoLmZsb29yKDFlMyAqIE1hdGguYWJzKGR0IC0gYi55KSksIG1bJF1beXRdIHx8IChtWyRdW3l0XSA9IGwoTWF0aC5zcXJ0KE1hdGgucG93KCQgKiBkLCAyKSArIE1hdGgucG93KHl0ICogZiwgMikpIC8gMWUzKSksIEkgPSBtWyRdW3l0XSwgSSA+IDAgJiYgKE0gPSA0ICogKGR0ICogZSArIHgpLCBFICs9IEksIFIgKz0gSSAqIG9bTV0sIHR0ICs9IEkgKiBvW00gKyAxXSwgRiArPSBJICogb1tNICsgMl0sIEIgKz0gSSAqIG9bTSArIDNdKSk7XG4gICAgICAgIH1cbiAgICAgICAgTSA9IDQgKiAoTyAqIHIgKyBrKSwgY1tNXSA9IFIgLyBFLCBjW00gKyAxXSA9IHR0IC8gRSwgY1tNICsgMl0gPSBGIC8gRSwgY1tNICsgM10gPSBCIC8gRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiArK2sgPCByID8gdyhrKSA6IGE7XG4gICAgfSgwKTtcbiAgfVxuICBiaWxpbmVhckZpbHRlcmluZyh0LCBlLCBzLCByLCBuKSB7XG4gICAgbGV0IG8sIGEsIGMsIGwsIGgsIHUsIGQsIGYsIGcsIHAsIG0sIGIsIFMsIHcgPSAwO1xuICAgIGNvbnN0IGsgPSB0aGlzLnJjcFNjYWxlWCwgTyA9IHRoaXMucmNwU2NhbGVZLCB4ID0gNCAqIChlIC0gMSksIEkgPSB0LmltYWdlRGF0YS5kYXRhLCBNID0gdC5jdHguY3JlYXRlSW1hZ2VEYXRhKHIsIG4pLCBFID0gTS5kYXRhO1xuICAgIGZvciAoZCA9IDA7IGQgPCBuOyBkKyspIGZvciAoZiA9IDA7IGYgPCByOyBmKyspIGZvciAoaCA9IE1hdGguZmxvb3IoayAqIGYpLCB1ID0gTWF0aC5mbG9vcihPICogZCksIGcgPSBrICogZiAtIGgsIHAgPSBPICogZCAtIHUsIFMgPSA0ICogKHUgKiBlICsgaCksIG0gPSAwOyBtIDwgNDsgbSsrKSBvID0gSVtTICsgbV0sIGEgPSBJW1MgKyA0ICsgbV0sIGMgPSBJW1MgKyB4ICsgbV0sIGwgPSBJW1MgKyB4ICsgNCArIG1dLCBiID0gbyAqICgxIC0gZykgKiAoMSAtIHApICsgYSAqIGcgKiAoMSAtIHApICsgYyAqIHAgKiAoMSAtIGcpICsgbCAqIGcgKiBwLCBFW3crK10gPSBiO1xuICAgIHJldHVybiBNO1xuICB9XG4gIGhlcm1pdGVGYXN0UmVzaXplKHQsIGUsIHMsIHIsIG4pIHtcbiAgICBjb25zdCBvID0gdGhpcy5yY3BTY2FsZVgsIGEgPSB0aGlzLnJjcFNjYWxlWSwgYyA9IE1hdGguY2VpbChvIC8gMiksIGwgPSBNYXRoLmNlaWwoYSAvIDIpLCBoID0gdC5pbWFnZURhdGEuZGF0YSwgdSA9IHQuY3R4LmNyZWF0ZUltYWdlRGF0YShyLCBuKSwgZCA9IHUuZGF0YTtcbiAgICBmb3IgKGxldCBmID0gMDsgZiA8IG47IGYrKykgZm9yIChsZXQgZyA9IDA7IGcgPCByOyBnKyspIHtcbiAgICAgIGNvbnN0IHAgPSA0ICogKGcgKyBmICogcik7XG4gICAgICBsZXQgbSA9IDAsIGIgPSAwLCBTID0gMCwgdyA9IDAsIGsgPSAwLCBPID0gMCwgeCA9IDA7XG4gICAgICBjb25zdCBJID0gKGYgKyAwLjUpICogYTtcbiAgICAgIGZvciAobGV0IE0gPSBNYXRoLmZsb29yKGYgKiBhKTsgTSA8IChmICsgMSkgKiBhOyBNKyspIHtcbiAgICAgICAgY29uc3QgRSA9IE1hdGguYWJzKEkgLSAoTSArIDAuNSkpIC8gbCwgUiA9IChnICsgMC41KSAqIG8sIHR0ID0gRSAqIEU7XG4gICAgICAgIGZvciAobGV0IEYgPSBNYXRoLmZsb29yKGcgKiBvKTsgRiA8IChnICsgMSkgKiBvOyBGKyspIHtcbiAgICAgICAgICBsZXQgQiA9IE1hdGguYWJzKFIgLSAoRiArIDAuNSkpIC8gYztcbiAgICAgICAgICBjb25zdCAkID0gTWF0aC5zcXJ0KHR0ICsgQiAqIEIpO1xuICAgICAgICAgICQgPiAxICYmICQgPCAtMSB8fCAobSA9IDIgKiAkICogJCAqICQgLSAzICogJCAqICQgKyAxLCBtID4gMCAmJiAoQiA9IDQgKiAoRiArIE0gKiBlKSwgeCArPSBtICogaFtCICsgM10sIFMgKz0gbSwgaFtCICsgM10gPCAyNTUgJiYgKG0gPSBtICogaFtCICsgM10gLyAyNTApLCB3ICs9IG0gKiBoW0JdLCBrICs9IG0gKiBoW0IgKyAxXSwgTyArPSBtICogaFtCICsgMl0sIGIgKz0gbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkW3BdID0gdyAvIGIsIGRbcCArIDFdID0gayAvIGIsIGRbcCArIDJdID0gTyAvIGIsIGRbcCArIDNdID0geCAvIFM7XG4gICAgfVxuICAgIHJldHVybiB1O1xuICB9XG59XG55KEJyLCBcInR5cGVcIiwgXCJSZXNpemVcIiksIHkoQnIsIFwiZGVmYXVsdHNcIiwgeyByZXNpemVUeXBlOiBcImhlcm1pdGVcIiwgc2NhbGVYOiAxLCBzY2FsZVk6IDEsIGxhbmN6b3NMb2JlczogMyB9KSwgeShCciwgXCJ1bmlmb3JtTG9jYXRpb25zXCIsIFtcInVEZWx0YVwiLCBcInVUYXBzXCJdKSwgQy5zZXRDbGFzcyhCcik7XG5jbGFzcyBXciBleHRlbmRzIGl0IHtcbiAgZ2V0RnJhZ21lbnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIGBcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgdW5pZm9ybSBmbG9hdCB1U2F0dXJhdGlvbjtcbiAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbiAgdm9pZCBtYWluKCkge1xuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XG4gICAgZmxvYXQgcmdNYXggPSBtYXgoY29sb3IuciwgY29sb3IuZyk7XG4gICAgZmxvYXQgcmdiTWF4ID0gbWF4KHJnTWF4LCBjb2xvci5iKTtcbiAgICBjb2xvci5yICs9IHJnYk1heCAhPSBjb2xvci5yID8gKHJnYk1heCAtIGNvbG9yLnIpICogdVNhdHVyYXRpb24gOiAwLjAwO1xuICAgIGNvbG9yLmcgKz0gcmdiTWF4ICE9IGNvbG9yLmcgPyAocmdiTWF4IC0gY29sb3IuZykgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XG4gICAgY29sb3IuYiArPSByZ2JNYXggIT0gY29sb3IuYiA/IChyZ2JNYXggLSBjb2xvci5iKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgfVxuYDtcbiAgfVxuICBhcHBseVRvMmQodCkge1xuICAgIGxldCB7IGltYWdlRGF0YTogeyBkYXRhOiBlIH0gfSA9IHQ7XG4gICAgY29uc3QgcyA9IC10aGlzLnNhdHVyYXRpb247XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmxlbmd0aDsgciArPSA0KSB7XG4gICAgICBjb25zdCBuID0gZVtyXSwgbyA9IGVbciArIDFdLCBhID0gZVtyICsgMl0sIGMgPSBNYXRoLm1heChuLCBvLCBhKTtcbiAgICAgIGVbcl0gKz0gYyAhPT0gbiA/IChjIC0gbikgKiBzIDogMCwgZVtyICsgMV0gKz0gYyAhPT0gbyA/IChjIC0gbykgKiBzIDogMCwgZVtyICsgMl0gKz0gYyAhPT0gYSA/IChjIC0gYSkgKiBzIDogMDtcbiAgICB9XG4gIH1cbiAgc2VuZFVuaWZvcm1EYXRhKHQsIGUpIHtcbiAgICB0LnVuaWZvcm0xZihlLnVTYXR1cmF0aW9uLCAtdGhpcy5zYXR1cmF0aW9uKTtcbiAgfVxuICBpc05ldXRyYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zYXR1cmF0aW9uID09PSAwO1xuICB9XG59XG55KFdyLCBcInR5cGVcIiwgXCJTYXR1cmF0aW9uXCIpLCB5KFdyLCBcImRlZmF1bHRzXCIsIHsgc2F0dXJhdGlvbjogMCB9KSwgeShXciwgXCJ1bmlmb3JtTG9jYXRpb25zXCIsIFtcInVTYXR1cmF0aW9uXCJdKSwgQy5zZXRDbGFzcyhXcik7XG5jbGFzcyBYciBleHRlbmRzIGl0IHtcbiAgZ2V0RnJhZ21lbnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIGBcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgdW5pZm9ybSBmbG9hdCB1VmlicmFuY2U7XG4gIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG4gIHZvaWQgbWFpbigpIHtcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xuICAgIGZsb2F0IG1heCA9IG1heChjb2xvci5yLCBtYXgoY29sb3IuZywgY29sb3IuYikpO1xuICAgIGZsb2F0IGF2ZyA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xuICAgIGZsb2F0IGFtdCA9IChhYnMobWF4IC0gYXZnKSAqIDIuMCkgKiB1VmlicmFuY2U7XG4gICAgY29sb3IuciArPSBtYXggIT0gY29sb3IuciA/IChtYXggLSBjb2xvci5yKSAqIGFtdCA6IDAuMDA7XG4gICAgY29sb3IuZyArPSBtYXggIT0gY29sb3IuZyA/IChtYXggLSBjb2xvci5nKSAqIGFtdCA6IDAuMDA7XG4gICAgY29sb3IuYiArPSBtYXggIT0gY29sb3IuYiA/IChtYXggLSBjb2xvci5iKSAqIGFtdCA6IDAuMDA7XG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gIH1cbmA7XG4gIH1cbiAgYXBwbHlUbzJkKHQpIHtcbiAgICBsZXQgeyBpbWFnZURhdGE6IHsgZGF0YTogZSB9IH0gPSB0O1xuICAgIGNvbnN0IHMgPSAtdGhpcy52aWJyYW5jZTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByICs9IDQpIHtcbiAgICAgIGNvbnN0IG4gPSBlW3JdLCBvID0gZVtyICsgMV0sIGEgPSBlW3IgKyAyXSwgYyA9IE1hdGgubWF4KG4sIG8sIGEpLCBsID0gKG4gKyBvICsgYSkgLyAzLCBoID0gMiAqIE1hdGguYWJzKGMgLSBsKSAvIDI1NSAqIHM7XG4gICAgICBlW3JdICs9IGMgIT09IG4gPyAoYyAtIG4pICogaCA6IDAsIGVbciArIDFdICs9IGMgIT09IG8gPyAoYyAtIG8pICogaCA6IDAsIGVbciArIDJdICs9IGMgIT09IGEgPyAoYyAtIGEpICogaCA6IDA7XG4gICAgfVxuICB9XG4gIHNlbmRVbmlmb3JtRGF0YSh0LCBlKSB7XG4gICAgdC51bmlmb3JtMWYoZS51VmlicmFuY2UsIC10aGlzLnZpYnJhbmNlKTtcbiAgfVxuICBpc05ldXRyYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52aWJyYW5jZSA9PT0gMDtcbiAgfVxufVxueShYciwgXCJ0eXBlXCIsIFwiVmlicmFuY2VcIiksIHkoWHIsIFwiZGVmYXVsdHNcIiwgeyB2aWJyYW5jZTogMCB9KSwgeShYciwgXCJ1bmlmb3JtTG9jYXRpb25zXCIsIFtcInVWaWJyYW5jZVwiXSksIEMuc2V0Q2xhc3MoWHIpO1xuZnVuY3Rpb24gcXQoaSwgdCwgZSwgcywgcikge1xuICBjb25zdCBjID0gci5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gIGkuc2F2ZSgpLCB0aGlzLmNvbnRyb2xPcmllbnRhdGlvbiA9PT0gXCJsZWZ0XCIgPyBpLnRyYW5zbGF0ZShcbiAgICByLmxlZnQgKyBjWzRdLFxuICAgIHIudG9wICsgY1s1XSArIHIuaGVpZ2h0IC8gMlxuICApIDogaS50cmFuc2xhdGUoXG4gICAgci5sZWZ0ICsgci53aWR0aCArIGNbNF0sXG4gICAgci50b3AgKyBjWzVdICsgci5oZWlnaHQgLyAyXG4gICksIGkucm90YXRlKHNkLmRlZ3JlZXNUb1JhZGlhbnMoOTAgKyByLmFuZ2xlKSksIGkubGluZVdpZHRoID0gNiwgaS5saW5lQ2FwID0gXCJyb3VuZFwiLCBpLnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiLCBpLmJlZ2luUGF0aCgpLCBpLm1vdmVUbygtNiwgMCksIGkubGluZVRvKDYsIDApLCBpLnN0cm9rZSgpLCBpLmxpbmVXaWR0aCA9IDQsIGkuc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCIsIGkuYmVnaW5QYXRoKCksIGkubW92ZVRvKC02LCAwKSwgaS5saW5lVG8oNiwgMCksIGkuc3Ryb2tlKCksIGkucmVzdG9yZSgpO1xufVxuY29uc3QgSXQgPSAxLCB2dCA9IFwicmdiYSgyNTUsIDI1NSwgMjU1LDEuMClcIiwgJG8gPSBbXG4gIFwiSW1hZ2VcIixcbiAgXCJUZXh0XCIsXG4gIFwiVmlkZW9cIixcbiAgXCJBdWRpb1wiLFxuICBcIkNhcHRpb25cIixcbiAgXCJUZW1wbGF0ZVwiLFxuICBcIkNvbXBvc2l0aW9uXCIsXG4gIFwiSWxsdXN0cmF0aW9uXCIsXG4gIFwiU2hhcGVcIlxuXSwgcWQgPSBbXG4gIFwiaW1hZ2VcIixcbiAgXCJ0ZXh0XCIsXG4gIFwidmlkZW9cIixcbiAgXCJhdWRpb1wiLFxuICBcImNhcHRpb25cIixcbiAgXCJ0ZW1wbGF0ZVwiLFxuICBcImNvbXBvc2l0aW9uXCIsXG4gIFwiaWxsdXN0cmF0aW9uXCIsXG4gIFwic2hhcGVcIlxuXSwgS2QgPSB7XG4gIGxlZnQ6IC0wLjUsXG4gIHRvcDogLTAuNSxcbiAgY2VudGVyOiAwLFxuICBib3R0b206IDAuNSxcbiAgcmlnaHQ6IDAuNVxufSwgUCA9IChpKSA9PiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gS2RbaV0gOiBpIC0gMC41LCBIZSA9IFwiY2VudGVyXCIsIHVyID0gXCJsZWZ0XCIsIFEwID0gXCJ0b3BcIiwgdGIgPSBcImJvdHRvbVwiLCBkciA9IFwicmlnaHRcIiwgZWIgPSBcIm5vbmVcIjtcbmZ1bmN0aW9uIGZyKGkpIHtcbiAgcmV0dXJuIFAoaS5vcmlnaW5YKSA9PT0gUChIZSkgJiYgUChpLm9yaWdpblkpID09PSBQKEhlKTtcbn1cbmZ1bmN0aW9uIE1pKGkpIHtcbiAgcmV0dXJuICh0LCBlLCBzLCByKSA9PiB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IG4sIG9yaWdpblg6IG8sIG9yaWdpblk6IGEgfSA9IGUsIGMgPSBuLmdldFJlbGF0aXZlQ2VudGVyUG9pbnQoKSwgbCA9IG4udHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjLCBvLCBhKSwgaCA9IGkodCwgZSwgcywgcik7XG4gICAgcmV0dXJuIG4uc2V0UG9zaXRpb25CeU9yaWdpbihcbiAgICAgIGwsXG4gICAgICBlLm9yaWdpblgsXG4gICAgICBlLm9yaWdpbllcbiAgICApLCBoO1xuICB9O1xufVxuY29uc3QgcW8gPSAzLCBKZCA9IDQsIGdsID0gMTg4LCBaZCA9IDYwLCBRZCA9IDFlMyAvIFpkO1xuZnVuY3Rpb24gRChpLCB0ID0gMSwgZSA9IDEpIHtcbiAgY29uc3QgcyA9IGdsICogdDtcbiAgcmV0dXJuIGkgKiAoNjAgLyAxZTMpICogcyAvIGU7XG59XG5mdW5jdGlvbiBZKGksIHQgPSAxLCBlID0gMSkge1xuICBjb25zdCBzID0gZ2wgKiB0O1xuICByZXR1cm4gaSAvIHMgKiBRZCAqIGU7XG59XG5mdW5jdGlvbiBzYihpLCB0ID0gMSkge1xuICByZXR1cm4gRChpLCB0KTtcbn1cbmNvbnN0IHBsID0gKGkpID0+IE9iamVjdC5rZXlzKGkpLnJlZHVjZSgodCwgZSkgPT4ge1xuICBjb25zdCB7IGRpc3BsYXk6IHMsIHBsYXliYWNrUmF0ZTogciB9ID0gaVtlXTtcbiAgcmV0dXJuIE1hdGgubWF4KHQsIHMudG8gLyAociB8fCAxKSk7XG59LCAwKSwgeyB3cmFwV2l0aEZpcmVFdmVudDogdGYsIGdldExvY2FsUG9pbnQ6IGVmIH0gPSBEcywgc2YgPSAoaSwgdCwgZSwgcykgPT4ge1xuICBjb25zdCByID0gZWYoXG4gICAgdCxcbiAgICB0Lm9yaWdpblgsXG4gICAgdC5vcmlnaW5ZLFxuICAgIGUsXG4gICAgc1xuICApO1xuICBpZiAoUCh0Lm9yaWdpblgpID09PSBQKEhlKSB8fCBQKHQub3JpZ2luWCkgPT09IFAoZHIpICYmIHIueCA8IDAgfHwgUCh0Lm9yaWdpblgpID09PSBQKHVyKSAmJiByLnggPiAwKSB7XG4gICAgbGV0IHsgdGFyZ2V0OiBuIH0gPSB0LCBvID0gbi5zdHJva2VXaWR0aCAvIChuLnN0cm9rZVVuaWZvcm0gPyBuLnNjYWxlWCA6IDEpLCBhID0gZnIodCkgPyAyIDogMSwgYyA9IG4ud2lkdGgsIGwgPSBNYXRoLmNlaWwoXG4gICAgICBNYXRoLmFicyhyLnggKiBhIC8gbi5zY2FsZVgpIC0gb1xuICAgICk7XG4gICAgaWYgKHQuY29ybmVyID09PSBcIm1yXCIpIHtcbiAgICAgIGNvbnN0IHUgPSBuLnRyaW0udG8sIGQgPSBsIC0gYywgZiA9IFkoXG4gICAgICAgIGQsXG4gICAgICAgIG4udFNjYWxlLFxuICAgICAgICBuLnBsYXliYWNrUmF0ZVxuICAgICAgKSwgZyA9IHUgKyBmO1xuICAgICAgaWYgKGcgPiBuLmR1cmF0aW9uKSByZXR1cm4gITE7XG4gICAgICBuLnNldChcIndpZHRoXCIsIE1hdGgubWF4KGwsIDApKSwgbi50cmltLnRvID0gZztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG4ubGVmdCA8IDApIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHUgPSBjIC0gbDtcbiAgICAgIGlmIChuLmxlZnQgKyB1IDwgMCkge1xuICAgICAgICBjb25zdCBiID0gRChcbiAgICAgICAgICBuLmR1cmF0aW9uLFxuICAgICAgICAgIG4udFNjYWxlLFxuICAgICAgICAgIG4ucGxheWJhY2tSYXRlXG4gICAgICAgICksIFMgPSBuLndpZHRoICsgbi5sZWZ0O1xuICAgICAgICBpZiAoUyA8PSBiKSB7XG4gICAgICAgICAgbi5zZXQoXCJ3aWR0aFwiLCBTKTtcbiAgICAgICAgICBjb25zdCB3ID0gWShcbiAgICAgICAgICAgIGIgLSBTLFxuICAgICAgICAgICAgbi50U2NhbGUsXG4gICAgICAgICAgICBuLnBsYXliYWNrUmF0ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG4udHJpbS5mcm9tID0gdywgITA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgY29uc3QgZiA9IGwgLSBjLCBnID0gbi50cmltLmZyb20sIHAgPSBZKFxuICAgICAgICBmLFxuICAgICAgICBuLnRTY2FsZSxcbiAgICAgICAgbi5wbGF5YmFja1JhdGVcbiAgICAgICksIG0gPSBnIC0gcDtcbiAgICAgIGlmIChtIDwgMCkgcmV0dXJuICExO1xuICAgICAgbi5zZXQoXCJ3aWR0aFwiLCBNYXRoLm1heChsLCAwKSksIG4udHJpbS5mcm9tID0gbSwgbi5vblJlc2l6ZSAmJiBuLm9uUmVzaXplKCk7XG4gICAgfVxuICAgIHJldHVybiBjICE9PSBuLndpZHRoO1xuICB9XG4gIHJldHVybiAhMTtcbn0sIF9uID0gdGYoXG4gIFwicmVzaXppbmdcIixcbiAgTWkoc2YpXG4pLCB7IHdyYXBXaXRoRmlyZUV2ZW50OiByZiwgZ2V0TG9jYWxQb2ludDogbmYsIHdyYXBXaXRoRml4ZWRBbmNob3I6IG9mIH0gPSBEcywgYWYgPSAoaSwgdCwgZSwgcykgPT4ge1xuICBjb25zdCByID0gbmYoXG4gICAgdCxcbiAgICB0Lm9yaWdpblgsXG4gICAgdC5vcmlnaW5ZLFxuICAgIGUsXG4gICAgc1xuICApO1xuICBpZiAoUCh0Lm9yaWdpblgpID09PSBQKEhlKSB8fCBQKHQub3JpZ2luWCkgPT09IFAoZHIpICYmIHIueCA8IDAgfHwgUCh0Lm9yaWdpblgpID09PSBQKHVyKSAmJiByLnggPiAwKSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IG4gfSA9IHQsIG8gPSBuLnN0cm9rZVdpZHRoIC8gKG4uc3Ryb2tlVW5pZm9ybSA/IG4uc2NhbGVYIDogMSksIGEgPSBmcih0KSA/IDIgOiAxLCBjID0gbi53aWR0aCwgbCA9IE1hdGguY2VpbChcbiAgICAgIE1hdGguYWJzKHIueCAqIGEgLyBuLnNjYWxlWCkgLSBvXG4gICAgKSwgaCA9IHQuY29ybmVyID09PSBcIm1sXCI7XG4gICAgaWYgKG4ubGVmdCA8IDApIHJldHVybiAhMTtcbiAgICBpZiAoaCkge1xuICAgICAgY29uc3QgdSA9IGMgLSBsO1xuICAgICAgaWYgKG4ubGVmdCArIHUgPCAwKVxuICAgICAgICByZXR1cm4gbi5zZXQoXCJ3aWR0aFwiLCBuLndpZHRoICsgbi5sZWZ0KSwgITA7XG4gICAgfVxuICAgIHJldHVybiBuLnNldChcIndpZHRoXCIsIE1hdGgubWF4KGwsIDApKSwgYyAhPT0gbi53aWR0aDtcbiAgfVxuICByZXR1cm4gITE7XG59LCBTbiA9IHJmKFxuICBcInJlc2l6aW5nXCIsXG4gIG9mKGFmKVxuKSwgeyB3cmFwV2l0aEZpcmVFdmVudDogY2YsIGdldExvY2FsUG9pbnQ6IGxmIH0gPSBEcywgaGYgPSAoaSwgdCwgZSwgcykgPT4ge1xuICBjb25zdCByID0gbGYoXG4gICAgdCxcbiAgICB0Lm9yaWdpblgsXG4gICAgdC5vcmlnaW5ZLFxuICAgIGUsXG4gICAgc1xuICApO1xuICBpZiAoUCh0Lm9yaWdpblgpID09PSBQKEhlKSB8fCBQKHQub3JpZ2luWCkgPT09IFAoZHIpICYmIHIueCA8IDAgfHwgUCh0Lm9yaWdpblgpID09PSBQKHVyKSAmJiByLnggPiAwKSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IG4gfSA9IHQsIG8gPSBuLnN0cm9rZVdpZHRoIC8gKG4uc3Ryb2tlVW5pZm9ybSA/IG4uc2NhbGVYIDogMSksIGEgPSBmcih0KSA/IDIgOiAxLCBjID0gbi53aWR0aCwgbCA9IE1hdGguY2VpbChcbiAgICAgIE1hdGguYWJzKHIueCAqIGEgLyBuLnNjYWxlWCkgLSBvXG4gICAgKSwgaCA9IFkoXG4gICAgICBsLFxuICAgICAgbi50U2NhbGUsXG4gICAgICBuLnBsYXliYWNrUmF0ZVxuICAgICk7XG4gICAgcmV0dXJuIGggPj0gMTUwMCB8fCBoIDwgNTAwID8gITEgOiAobi5zZXQoXCJ3aWR0aFwiLCBNYXRoLm1heChsLCAwKSksIG4uc2V0KFwiZHVyYXRpb25cIiwgaCksIGMgIT09IG4ud2lkdGgpO1xuICB9XG4gIHJldHVybiAhMTtcbn0sIFRuID0gY2YoXG4gIFwicmVzaXppbmdcIixcbiAgTWkoaGYpXG4pLCB7IHdyYXBXaXRoRmlyZUV2ZW50OiB1ZiwgZ2V0TG9jYWxQb2ludDogZGYgfSA9IERzLCBmZiA9IChpLCB0LCBlLCBzKSA9PiB7XG4gIGNvbnN0IHIgPSBkZihcbiAgICB0LFxuICAgIHQub3JpZ2luWCxcbiAgICB0Lm9yaWdpblksXG4gICAgZSxcbiAgICBzXG4gICk7XG4gIGlmIChQKHQub3JpZ2luWCkgPT09IFAoSGUpIHx8IFAodC5vcmlnaW5YKSA9PT0gUChkcikgJiYgci54IDwgMCB8fCBQKHQub3JpZ2luWCkgPT09IFAodXIpICYmIHIueCA+IDApIHtcbiAgICBsZXQgeyB0YXJnZXQ6IG4gfSA9IHQsIG8gPSBuLnN0cm9rZVdpZHRoIC8gKG4uc3Ryb2tlVW5pZm9ybSA/IG4uc2NhbGVYIDogMSksIGEgPSBmcih0KSA/IDIgOiAxLCBjID0gbi53aWR0aCwgbCA9IE1hdGguY2VpbChcbiAgICAgIE1hdGguYWJzKHIueCAqIGEgLyBuLnNjYWxlWCkgLSBvXG4gICAgKTtcbiAgICBpZiAodC5jb3JuZXIgPT09IFwibXJcIikge1xuICAgICAgY29uc3QgdSA9IG4udHJpbS50bywgZCA9IGwgLSBjLCBmID0gWShcbiAgICAgICAgZCxcbiAgICAgICAgbi50U2NhbGUsXG4gICAgICAgIG4ucGxheWJhY2tSYXRlXG4gICAgICApLCBnID0gdSArIGY7XG4gICAgICBpZiAoZyA+IG4uZHVyYXRpb24pIHJldHVybiAhMTtcbiAgICAgIG4uc2V0KFwid2lkdGhcIiwgTWF0aC5tYXgobCwgMCkpLCBuLnRyaW0udG8gPSBnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobi5sZWZ0IDwgMCkgcmV0dXJuICExO1xuICAgICAgY29uc3QgdSA9IGMgLSBsO1xuICAgICAgaWYgKG4ubGVmdCArIHUgPCAwKSByZXR1cm4gITE7XG4gICAgICBjb25zdCBmID0gbCAtIGMsIGcgPSBuLnRyaW0uZnJvbSwgcCA9IFkoXG4gICAgICAgIGYsXG4gICAgICAgIG4udFNjYWxlLFxuICAgICAgICBuLnBsYXliYWNrUmF0ZVxuICAgICAgKSwgbSA9IGcgLSBwO1xuICAgICAgaWYgKG0gPCAwKSByZXR1cm4gITE7XG4gICAgICBuLnNldChcIndpZHRoXCIsIE1hdGgubWF4KGwsIDApKSwgbi50cmltLmZyb20gPSBtO1xuICAgIH1cbiAgICByZXR1cm4gYyAhPT0gbi53aWR0aDtcbiAgfVxuICByZXR1cm4gITE7XG59LCBLbyA9IHVmKFxuICBcInJlc2l6aW5nXCIsXG4gIE1pKGZmKVxuKSwgeyBzY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXI6IEt0IH0gPSBEcywganMgPSAoKSA9PiAoe1xuICBtcjogbmV3IFUoe1xuICAgIHg6IDAuNSxcbiAgICB5OiAwLFxuICAgIGFjdGlvbkhhbmRsZXI6IFNuLFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogS3QsXG4gICAgYWN0aW9uTmFtZTogXCJyZXNpemluZ1wiLFxuICAgIHJlbmRlcjogcXQsXG4gICAgY29udHJvbE9yaWVudGF0aW9uOiBcInJpZ2h0XCJcbiAgfSksXG4gIG1sOiBuZXcgVSh7XG4gICAgeDogLTAuNSxcbiAgICB5OiAwLFxuICAgIGFjdGlvbkhhbmRsZXI6IFNuLFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogS3QsXG4gICAgYWN0aW9uTmFtZTogXCJyZXNpemluZ1wiLFxuICAgIHJlbmRlcjogcXQsXG4gICAgY29udHJvbE9yaWVudGF0aW9uOiBcImxlZnRcIlxuICB9KVxufSksIGdmID0gKCkgPT4gKHtcbiAgbXI6IG5ldyBVKHtcbiAgICB4OiAwLjUsXG4gICAgeTogMCxcbiAgICByZW5kZXI6IHF0LFxuICAgIGFjdGlvbkhhbmRsZXI6IEtvLFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogS3QsXG4gICAgYWN0aW9uTmFtZTogXCJyZXNpemluZ1wiLFxuICAgIGNvbnRyb2xPcmllbnRhdGlvbjogXCJyaWdodFwiXG4gIH0pLFxuICBtbDogbmV3IFUoe1xuICAgIHg6IC0wLjUsXG4gICAgeTogMCxcbiAgICByZW5kZXI6IHF0LFxuICAgIGFjdGlvbkhhbmRsZXI6IEtvLFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogS3QsXG4gICAgYWN0aW9uTmFtZTogXCJyZXNpemluZ1wiLFxuICAgIGNvbnRyb2xPcmllbnRhdGlvbjogXCJsZWZ0XCJcbiAgfSlcbn0pLCBwZiA9ICgpID0+ICh7XG4gIG1yOiBuZXcgVSh7XG4gICAgeDogMC41LFxuICAgIHk6IDAsXG4gICAgcmVuZGVyOiBxdCxcbiAgICBhY3Rpb25IYW5kbGVyOiBfbixcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IEt0LFxuICAgIGFjdGlvbk5hbWU6IFwicmVzaXppbmdcIixcbiAgICBjb250cm9sT3JpZW50YXRpb246IFwicmlnaHRcIlxuICB9KSxcbiAgbWw6IG5ldyBVKHtcbiAgICB4OiAtMC41LFxuICAgIHk6IDAsXG4gICAgcmVuZGVyOiBxdCxcbiAgICBhY3Rpb25IYW5kbGVyOiBfbixcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IEt0LFxuICAgIGFjdGlvbk5hbWU6IFwicmVzaXppbmdcIixcbiAgICBjb250cm9sT3JpZW50YXRpb246IFwibGVmdFwiXG4gIH0pXG59KSwgbWYgPSAoKSA9PiAoe1xuICBtcjogbmV3IFUoe1xuICAgIHg6IDAuNSxcbiAgICB5OiAwLFxuICAgIHJlbmRlcjogcXQsXG4gICAgYWN0aW9uSGFuZGxlcjogeG4sXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBLdCxcbiAgICBhY3Rpb25OYW1lOiBcInJlc2l6aW5nXCIsXG4gICAgY29udHJvbE9yaWVudGF0aW9uOiBcInJpZ2h0XCJcbiAgfSksXG4gIG1sOiBuZXcgVSh7XG4gICAgeDogLTAuNSxcbiAgICB5OiAwLFxuICAgIHJlbmRlcjogcXQsXG4gICAgYWN0aW9uSGFuZGxlcjogeG4sXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBLdCxcbiAgICBhY3Rpb25OYW1lOiBcInJlc2l6aW5nXCIsXG4gICAgY29udHJvbE9yaWVudGF0aW9uOiBcImxlZnRcIlxuICB9KVxufSksIG1sID0gKCkgPT4gKHtcbiAgbXI6IG5ldyBVKHtcbiAgICB4OiAwLjUsXG4gICAgeTogMCxcbiAgICBhY3Rpb25IYW5kbGVyOiBUbixcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IEt0LFxuICAgIGFjdGlvbk5hbWU6IFwicmVzaXppbmdcIixcbiAgICByZW5kZXI6IHF0LFxuICAgIGNvbnRyb2xPcmllbnRhdGlvbjogXCJyaWdodFwiXG4gIH0pLFxuICBtbDogbmV3IFUoe1xuICAgIHg6IC0wLjUsXG4gICAgeTogMCxcbiAgICBhY3Rpb25IYW5kbGVyOiBUbixcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IEt0LFxuICAgIGFjdGlvbk5hbWU6IFwicmVzaXppbmdcIixcbiAgICByZW5kZXI6IHF0LFxuICAgIGNvbnRyb2xPcmllbnRhdGlvbjogXCJsZWZ0XCJcbiAgfSlcbn0pLCB2ZiA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xubGV0IGdyID0gKGkgPSAyMSkgPT4ge1xuICBsZXQgdCA9IFwiXCIsIGUgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGkgfD0gMCkpO1xuICBmb3IgKDsgaS0tOyApXG4gICAgdCArPSB2ZltlW2ldICYgNjNdO1xuICByZXR1cm4gdDtcbn07XG5mdW5jdGlvbiBXcyhpID0gMTYpIHtcbiAgY29uc3QgdCA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiLCBlID0gdC5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdC5sZW5ndGgpKTtcbiAgbGV0IHMgPSBncihpIC0gMSk7XG4gIHJldHVybiBzID0gcy5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgXCJcIikuc2xpY2UoMCwgaSAtIDEpLCBlICsgcztcbn1cbmNvbnN0IHsgd3JhcFdpdGhGaXJlRXZlbnQ6IHlmLCBnZXRMb2NhbFBvaW50OiBiZiB9ID0gRHMsIF9mID0gKGksIHQsIGUsIHMpID0+IHtcbiAgY29uc3QgciA9IGJmKFxuICAgIHQsXG4gICAgdC5vcmlnaW5YLFxuICAgIHQub3JpZ2luWSxcbiAgICBlLFxuICAgIHNcbiAgKTtcbiAgaWYgKFAodC5vcmlnaW5YKSA9PT0gUChIZSkgfHwgUCh0Lm9yaWdpblgpID09PSBQKGRyKSAmJiByLnggPCAwIHx8IFAodC5vcmlnaW5YKSA9PT0gUCh1cikgJiYgci54ID4gMCkge1xuICAgIGxldCB7IHRhcmdldDogbiB9ID0gdCwgbyA9IG4uc3Ryb2tlV2lkdGggLyAobi5zdHJva2VVbmlmb3JtID8gbi5zY2FsZVggOiAxKSwgYSA9IGZyKHQpID8gMiA6IDEsIGMgPSBuLndpZHRoLCBsID0gTWF0aC5jZWlsKFxuICAgICAgTWF0aC5hYnMoci54ICogYSAvIG4uc2NhbGVYKSAtIG9cbiAgICApO1xuICAgIGlmICh0LmNvcm5lciA9PT0gXCJtclwiKSB7XG4gICAgICBjb25zdCB1ID0gbi50cmltLnRvLCBkID0gbCAtIGMsIGYgPSBZKFxuICAgICAgICBkLFxuICAgICAgICBuLnRTY2FsZSxcbiAgICAgICAgbi5wbGF5YmFja1JhdGVcbiAgICAgICksIGcgPSB1ICsgZjtcbiAgICAgIGlmIChnID4gbi5kdXJhdGlvbikgcmV0dXJuICExO1xuICAgICAgbi5zZXQoXCJ3aWR0aFwiLCBNYXRoLm1heChsLCAwKSksIG4udHJpbS50byA9IGc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuLmxlZnQgPCAwKSByZXR1cm4gITE7XG4gICAgICBjb25zdCB1ID0gYyAtIGw7XG4gICAgICBpZiAobi5sZWZ0ICsgdSA8IDApIHtcbiAgICAgICAgY29uc3QgYiA9IEQoXG4gICAgICAgICAgbi5kdXJhdGlvbixcbiAgICAgICAgICBuLnRTY2FsZSxcbiAgICAgICAgICBuLnBsYXliYWNrUmF0ZVxuICAgICAgICApLCBTID0gbi53aWR0aCArIG4ubGVmdDtcbiAgICAgICAgaWYgKFMgPD0gYikge1xuICAgICAgICAgIG4uc2V0KFwid2lkdGhcIiwgUyk7XG4gICAgICAgICAgY29uc3QgdyA9IFkoXG4gICAgICAgICAgICBiIC0gUyxcbiAgICAgICAgICAgIG4udFNjYWxlLFxuICAgICAgICAgICAgbi5wbGF5YmFja1JhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBuLnRyaW0uZnJvbSA9IHcsICEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGYgPSBsIC0gYywgZyA9IG4udHJpbS5mcm9tLCBwID0gWShcbiAgICAgICAgZixcbiAgICAgICAgbi50U2NhbGUsXG4gICAgICAgIG4ucGxheWJhY2tSYXRlXG4gICAgICApLCBtID0gZyAtIHA7XG4gICAgICBpZiAobSA8IDApIHJldHVybiAhMTtcbiAgICAgIG4uc2V0KFwid2lkdGhcIiwgTWF0aC5tYXgobCwgMCkpLCBuLnRyaW0uZnJvbSA9IG0sIG4ub25SZXNpemUgJiYgbi5vblJlc2l6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gYyAhPT0gbi53aWR0aDtcbiAgfVxuICByZXR1cm4gITE7XG59LCB4biA9IHlmKFxuICBcInJlc2l6aW5nXCIsXG4gIE1pKF9mKVxuKSwgZXMgPSBjbGFzcyBlcyBleHRlbmRzIFgge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSk7XG4gICAgVCh0aGlzLCBcIml0ZW1UeXBlXCIsIFwiaW1hZ2VcIik7XG4gICAgVCh0aGlzLCBcInNyY1wiKTtcbiAgICBUKHRoaXMsIFwiaXNTZWxlY3RlZFwiLCAhMSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBlcy5vd25EZWZhdWx0cyksIHRoaXMuaWQgPSBlLmlkLCB0aGlzLnNyYyA9IGUuc3JjLCB0aGlzLmRpc3BsYXkgPSBlLmRpc3BsYXksIHRoaXMudFNjYWxlID0gZS50U2NhbGU7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUNvbnRyb2xzKCkge1xuICAgIHJldHVybiB7IGNvbnRyb2xzOiBqcygpIH07XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXREZWZhdWx0cygpLFxuICAgICAgLi4uZXMub3duRGVmYXVsdHNcbiAgICB9O1xuICB9XG4gIC8vIGFkZCBjdXN0b20gdGV4dCB0byB0aGUgdHJhY2sgaXRlbVxuICBfcmVuZGVyKGUpIHtcbiAgICBzdXBlci5fcmVuZGVyKGUpLCB0aGlzLnVwZGF0ZVNlbGVjdGVkKGUpO1xuICB9XG4gIHNldFNlbGVjdGVkKGUpIHtcbiAgICB0aGlzLmlzU2VsZWN0ZWQgPSBlLCB0aGlzLnNldCh7IGRpcnR5OiAhMCB9KTtcbiAgfVxuICB1cGRhdGVTZWxlY3RlZChlKSB7XG4gICAgdGhpcy5pc1NlbGVjdGVkICYmIChlLnNhdmUoKSwgZS5iZWdpblBhdGgoKSwgZS5yb3VuZFJlY3QoXG4gICAgICAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgdGhpcy53aWR0aCxcbiAgICAgIHRoaXMuaGVpZ2h0LFxuICAgICAgdGhpcy5yeFxuICAgICksIGUubGluZVdpZHRoID0gSXQsIGUuc3Ryb2tlU3R5bGUgPSB2dCwgZS5zdHJva2UoKSwgZS5yZXN0b3JlKCkpO1xuICB9XG4gIHNldFNyYyhlKSB7XG4gICAgdGhpcy5zcmMgPSBlO1xuICB9XG59O1xuVChlcywgXCJ0eXBlXCIsIFwiSW1hZ2VcIiksIFQoZXMsIFwib3duRGVmYXVsdHNcIiwge1xuICByeDogOCxcbiAgcnk6IDgsXG4gIG9iamVjdENhY2hpbmc6ICExLFxuICBib3JkZXJDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICBzdHJva2U6IFwidHJhbnNwYXJlbnRcIixcbiAgc3Ryb2tlV2lkdGg6IDAsXG4gIGJvcmRlck9wYWNpdHlXaGVuTW92aW5nOiAxLFxuICBob3ZlckN1cnNvcjogXCJkZWZhdWx0XCIsXG4gIGZpbGw6IFwiIzI3MjcyYVwiXG59KTtcbmxldCBRcyA9IGVzO1xuQy5zZXRDbGFzcyhRcywgXCJJbWFnZVwiKTtcbmNsYXNzIF90IGV4dGVuZHMgWCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKTtcbiAgICBUKHRoaXMsIFwiaWRcIik7XG4gICAgVCh0aGlzLCBcInJlc291cmNlSWRcIiwgXCJcIik7XG4gICAgVCh0aGlzLCBcInRTY2FsZVwiKTtcbiAgICBUKHRoaXMsIFwiaXNTZWxlY3RlZFwiLCAhMSk7XG4gICAgVCh0aGlzLCBcImRpc3BsYXlcIik7XG4gICAgVCh0aGlzLCBcInRyaW1cIik7XG4gICAgVCh0aGlzLCBcImR1cmF0aW9uXCIpO1xuICAgIFQodGhpcywgXCJzcmNcIik7XG4gICAgdGhpcy5pZCA9IGUuaWQsIHRoaXMudFNjYWxlID0gZS50U2NhbGUsIHRoaXMub2JqZWN0Q2FjaGluZyA9ICExLCB0aGlzLnJ4ID0gOCwgdGhpcy5yeSA9IDgsIHRoaXMuZGlzcGxheSA9IGUuZGlzcGxheSwgdGhpcy50cmltID0gZS50cmltLCB0aGlzLmR1cmF0aW9uID0gZS5kdXJhdGlvbiwgdGhpcy5maWxsID0gXCIjMjcyNzJhXCI7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUNvbnRyb2xzKCkge1xuICAgIHJldHVybiB7IGNvbnRyb2xzOiBtZigpIH07XG4gIH1cbiAgLy8gYWRkIGN1c3RvbSB0ZXh0IHRvIHRoZSB0cmFjayBpdGVtXG4gIF9yZW5kZXIoZSkge1xuICAgIHN1cGVyLl9yZW5kZXIoZSksIHRoaXMudXBkYXRlU2VsZWN0ZWQoZSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZSkge1xuICAgIHRoaXMuaXNTZWxlY3RlZCA9IGUsIHRoaXMuc2V0KHsgZGlydHk6ICEwIH0pO1xuICB9XG4gIHVwZGF0ZVNlbGVjdGVkKGUpIHtcbiAgICB0aGlzLmlzU2VsZWN0ZWQgJiYgKGUuc2F2ZSgpLCBlLmJlZ2luUGF0aCgpLCBlLnJvdW5kUmVjdChcbiAgICAgIC10aGlzLndpZHRoIC8gMixcbiAgICAgIC10aGlzLmhlaWdodCAvIDIsXG4gICAgICB0aGlzLndpZHRoLFxuICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICB0aGlzLnJ4XG4gICAgKSwgZS5saW5lV2lkdGggPSBJdCwgZS5zdHJva2VTdHlsZSA9IHZ0LCBlLnN0cm9rZSgpLCBlLnJlc3RvcmUoKSk7XG4gIH1cbiAgb25SZXNpemVTbmFwKCkge1xuICB9XG4gIHNldFNyYyhlKSB7XG4gICAgdGhpcy5zcmMgPSBlO1xuICB9XG59XG5UKF90LCBcInR5cGVcIiwgXCJWaWRlb1wiKTtcbkMuc2V0Q2xhc3MoX3QsIFwiVmlkZW9cIik7XG5jb25zdCBzcyA9IGNsYXNzIHNzIGV4dGVuZHMgWCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKTtcbiAgICBUKHRoaXMsIFwiaXRlbVR5cGVcIiwgXCJhdWRpb1wiKTtcbiAgICBUKHRoaXMsIFwiaXNTZWxlY3RlZFwiLCAhMSk7XG4gICAgVCh0aGlzLCBcInRyaW1cIik7XG4gICAgVCh0aGlzLCBcInNyY1wiKTtcbiAgICBUKHRoaXMsIFwiZHVyYXRpb25cIik7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBzcy5vd25EZWZhdWx0cyksIHRoaXMuaWQgPSBlLmlkLCB0aGlzLmJvcmRlckNvbG9yID0gXCJ0cmFuc3BhcmVudFwiLCB0aGlzLnN0cm9rZSA9IFwidHJhbnNwYXJlbnRcIiwgdGhpcy5zdHJva2VXaWR0aCA9IDAsIHRoaXMudFNjYWxlID0gZS50U2NhbGUsIHRoaXMuZGlzcGxheSA9IGUuZGlzcGxheSwgdGhpcy50cmltID0gZS50cmltLCB0aGlzLnNyYyA9IGUuc3JjLCB0aGlzLmR1cmF0aW9uID0gZS5kdXJhdGlvbjtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmdldERlZmF1bHRzKCksXG4gICAgICAuLi5zcy5vd25EZWZhdWx0c1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUNvbnRyb2xzKCkge1xuICAgIHJldHVybiB7IGNvbnRyb2xzOiBwZigpIH07XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZSkge1xuICAgIHRoaXMuaXNTZWxlY3RlZCA9IGUsIHRoaXMuc2V0KHsgZGlydHk6ICEwIH0pO1xuICB9XG4gIC8vIGFkZCBjdXN0b20gQXVkaW8gdG8gdGhlIHRyYWNrIGl0ZW1cbiAgX3JlbmRlcihlKSB7XG4gICAgc3VwZXIuX3JlbmRlcihlKSwgdGhpcy51cGRhdGVTZWxlY3RlZChlKTtcbiAgfVxuICB1cGRhdGVTZWxlY3RlZChlKSB7XG4gICAgdGhpcy5pc1NlbGVjdGVkICYmIChlLnNhdmUoKSwgZS5iZWdpblBhdGgoKSwgZS5yb3VuZFJlY3QoXG4gICAgICAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgdGhpcy53aWR0aCxcbiAgICAgIHRoaXMuaGVpZ2h0LFxuICAgICAgNlxuICAgICksIGUubGluZVdpZHRoID0gSXQsIGUuc3Ryb2tlU3R5bGUgPSB2dCwgZS5zdHJva2UoKSwgZS5yZXN0b3JlKCkpO1xuICB9XG4gIHNldFNyYyhlKSB7XG4gICAgdGhpcy5zcmMgPSBlO1xuICB9XG59O1xuVChzcywgXCJ0eXBlXCIsIFwiQXVkaW9cIiksIFQoc3MsIFwib3duRGVmYXVsdHNcIiwge1xuICByeDogNixcbiAgcnk6IDYsXG4gIG9iamVjdENhY2hpbmc6ICExLFxuICBib3JkZXJDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICBzdHJva2U6IFwidHJhbnNwYXJlbnRcIixcbiAgc3Ryb2tlV2lkdGg6IDAsXG4gIGZpbGw6IFwiIzI3MjcyYVwiLFxuICBib3JkZXJPcGFjaXR5V2hlbk1vdmluZzogMSxcbiAgaG92ZXJDdXJzb3I6IFwiZGVmYXVsdFwiXG59KTtcbmxldCBmdCA9IHNzO1xuQy5zZXRDbGFzcyhmdCwgXCJBdWRpb1wiKTtcbmNvbnN0IHJzID0gY2xhc3MgcnMgZXh0ZW5kcyBYIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpO1xuICAgIFQodGhpcywgXCJpc1NlbGVjdGVkXCIsICExKTtcbiAgICBUKHRoaXMsIFwidGV4dFwiKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJzLm93bkRlZmF1bHRzKSwgdGhpcy5pZCA9IGUuaWQsIHRoaXMuYm9yZGVyQ29sb3IgPSBcInRyYW5zcGFyZW50XCIsIHRoaXMuc3Ryb2tlID0gXCJ0cmFuc3BhcmVudFwiLCB0aGlzLnN0cm9rZVdpZHRoID0gMCwgdGhpcy50U2NhbGUgPSBlLnRTY2FsZSwgdGhpcy5kaXNwbGF5ID0gZS5kaXNwbGF5LCB0aGlzLnRleHQgPSBlLnRleHQ7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUNvbnRyb2xzKCkge1xuICAgIHJldHVybiB7IGNvbnRyb2xzOiBqcygpIH07XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXREZWZhdWx0cygpLFxuICAgICAgLi4ucnMub3duRGVmYXVsdHNcbiAgICB9O1xuICB9XG4gIHNldFNlbGVjdGVkKGUpIHtcbiAgICB0aGlzLmlzU2VsZWN0ZWQgPSBlLCB0aGlzLnNldCh7IGRpcnR5OiAhMCB9KTtcbiAgfVxuICAvLyBhZGQgY3VzdG9tIHRleHQgdG8gdGhlIHRyYWNrIGl0ZW1cbiAgX3JlbmRlcihlKSB7XG4gICAgc3VwZXIuX3JlbmRlcihlKSwgdGhpcy51cGRhdGVTZWxlY3RlZChlKTtcbiAgfVxuICB1cGRhdGVTZWxlY3RlZChlKSB7XG4gICAgdGhpcy5pc1NlbGVjdGVkICYmIChlLnNhdmUoKSwgZS5iZWdpblBhdGgoKSwgZS5yb3VuZFJlY3QoXG4gICAgICAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgdGhpcy53aWR0aCxcbiAgICAgIHRoaXMuaGVpZ2h0LFxuICAgICAgNlxuICAgICksIGUubGluZVdpZHRoID0gSXQsIGUuc3Ryb2tlU3R5bGUgPSB2dCwgZS5zdHJva2UoKSwgZS5yZXN0b3JlKCkpO1xuICB9XG59O1xuVChycywgXCJ0eXBlXCIsIFwiVGV4dFwiKSwgVChycywgXCJvd25EZWZhdWx0c1wiLCB7XG4gIHJ4OiA2LFxuICByeTogNixcbiAgb2JqZWN0Q2FjaGluZzogITEsXG4gIGJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLFxuICBzdHJva2VXaWR0aDogMCxcbiAgZmlsbDogXCIjMjcyNzJhXCIsXG4gIGJvcmRlck9wYWNpdHlXaGVuTW92aW5nOiAxLFxuICBob3ZlckN1cnNvcjogXCJkZWZhdWx0XCJcbn0pO1xubGV0IHRyID0gcnM7XG5DLnNldENsYXNzKHRyLCBcIlRleHRcIik7XG5jb25zdCBTZiA9IHtcbiAgc2VsZWN0YWJsZTogITEsXG4gIGV2ZW50ZWQ6ICExLFxuICBzdHJva2VXaWR0aDogMCxcbiAgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCJcbn0sIGlzID0gY2xhc3MgaXMgZXh0ZW5kcyBYIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpO1xuICAgIFQodGhpcywgXCJpZFwiKTtcbiAgICBUKHRoaXMsIFwiYWNjZXB0c1wiLCBbXG4gICAgICBcImF1ZGlvXCIsXG4gICAgICBcInZpZGVvXCIsXG4gICAgICBcImltYWdlXCIsXG4gICAgICBcInRleHRcIixcbiAgICAgIFwiY2FwdGlvblwiLFxuICAgICAgXCJ0ZW1wbGF0ZVwiXG4gICAgXSk7XG4gICAgVCh0aGlzLCBcIm1ldGFkYXRhXCIpO1xuICAgIFQodGhpcywgXCJpdGVtc1wiLCBbXSk7XG4gICAgVCh0aGlzLCBcIm1hZ25ldGljXCIpO1xuICAgIFQodGhpcywgXCJzdGF0aWNcIik7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpcy5vd25EZWZhdWx0cyksIHRoaXMuaWQgPSBlLmlkLCB0aGlzLmFjY2VwdHMgPSBlLmFjY2VwdHMgfHwgW10sIHRoaXMuaXRlbXMgPSBlLml0ZW1zIHx8IFtdLCB0aGlzLm1hZ25ldGljID0gZS5tYWduZXRpYywgdGhpcy5zdGF0aWMgPSBlLnN0YXRpYywgdGhpcy5tZXRhZGF0YSA9IGUubWV0YWRhdGEsIHRoaXMuZmlsbCA9IFwicmdiYSgzNCwgMzQsIDM3LCAwLjgpXCI7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXREZWZhdWx0cygpLFxuICAgICAgLi4uaXMub3duRGVmYXVsdHNcbiAgICB9O1xuICB9XG4gIHVwZGF0ZUNvb3JkcyhlKSB7XG4gICAgdGhpcy53aWR0aCA9IGU7XG4gIH1cbn07XG5UKGlzLCBcIm93bkRlZmF1bHRzXCIsIFNmKSwgVChpcywgXCJ0eXBlXCIsIFwiVHJhY2tcIik7XG5sZXQgdWUgPSBpcztcbkMuc2V0Q2xhc3ModWUsIFwiVHJhY2tcIik7XG5jb25zdCBUZiA9IHtcbiAgdG9wOiB7XG4gICAgdG9wOiAzNSxcbiAgICBndWlkZTogMixcbiAgICBib3R0b206IDNcbiAgfSxcbiAgY2VudGVyOiB7XG4gICAgdG9wOiAzLFxuICAgIGd1aWRlOiAyLFxuICAgIGJvdHRvbTogM1xuICB9LFxuICBib3R0b206IHtcbiAgICB0b3A6IDMsXG4gICAgZ3VpZGU6IDIsXG4gICAgYm90dG9tOiAzNVxuICB9XG59LCB4ZiA9IChpLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBUZltpXTtcbiAgcmV0dXJuIGkgPT09IFwidG9wXCIgPyB7XG4gICAgdG9wOiB0IC0gKGUuZ3VpZGUgKyBlLmJvdHRvbSksXG4gICAgZ3VpZGU6IGUuZ3VpZGUsXG4gICAgYm90dG9tOiBlLmJvdHRvbVxuICB9IDogaSA9PT0gXCJjZW50ZXJcIiA/IHtcbiAgICB0b3A6IGUudG9wLFxuICAgIGd1aWRlOiBlLmd1aWRlLFxuICAgIGJvdHRvbTogZS5ib3R0b21cbiAgfSA6IHtcbiAgICB0b3A6IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudG9wLFxuICAgIGd1aWRlOiBlID09IG51bGwgPyB2b2lkIDAgOiBlLmd1aWRlLFxuICAgIGJvdHRvbTogdCAtICgoZSA9PSBudWxsID8gdm9pZCAwIDogZS5ndWlkZSkgKyAoZSA9PSBudWxsID8gdm9pZCAwIDogZS50b3ApKVxuICB9O1xufSwgbnMgPSBjbGFzcyBucyBleHRlbmRzIE50IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGNvbnN0IHMgPSB4ZihlLmtpbmQsIGUuaGVpZ2h0KSwgciA9IG5ldyBYKHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgIGZpbGw6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgIHNlbGVjdGFibGU6ICEwLFxuICAgICAgaGVpZ2h0OiBzLnRvcCxcbiAgICAgIHdpZHRoOiBlLndpZHRoXG4gICAgfSksIG4gPSBuZXcgWCh7XG4gICAgICB0b3A6IHMudG9wLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgZmlsbDogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgc2VsZWN0YWJsZTogITAsXG4gICAgICBoZWlnaHQ6IHMuZ3VpZGUsXG4gICAgICB3aWR0aDogZS53aWR0aFxuICAgIH0pLCBvID0gbmV3IFgoe1xuICAgICAgdG9wOiBzLnRvcCArIHMuZ3VpZGUsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBzZWxlY3RhYmxlOiAhMCxcbiAgICAgIGhlaWdodDogcy5ib3R0b20sXG4gICAgICB3aWR0aDogZS53aWR0aFxuICAgIH0pO1xuICAgIHN1cGVyKFtyLCBuLCBvXSwgZSk7XG4gICAgVCh0aGlzLCBcImd1aWRlXCIpO1xuICAgIFQodGhpcywgXCJ0b3BHdWlkZVwiKTtcbiAgICBUKHRoaXMsIFwiYm90dG9tR3VpZGVcIik7XG4gICAgVCh0aGlzLCBcIm1ldGFkYXRhXCIpO1xuICAgIFQodGhpcywgXCJhY2NlcHRzXCIsIFtdKTtcbiAgICBUKHRoaXMsIFwia2luZFwiKTtcbiAgICBUKHRoaXMsIFwiYWN0aXZlR3VpZGVGaWxsXCIpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgbnMub3duRGVmYXVsdHMpLCB0aGlzLmd1aWRlID0gbiwgdGhpcy50b3BHdWlkZSA9IHIsIHRoaXMuYm90dG9tR3VpZGUgPSBvLCB0aGlzLmlkID0gZS5pZCwgdGhpcy5tZXRhZGF0YSA9IGUubWV0YWRhdGEsIHRoaXMudFNjYWxlID0gZS50U2NhbGUsIHRoaXMua2luZCA9IGUua2luZCwgdGhpcy5hY3RpdmVHdWlkZUZpbGwgPSBlLmFjdGl2ZUd1aWRlRmlsbCB8fCB2dDtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmdldERlZmF1bHRzKCksXG4gICAgICAuLi5ucy5vd25EZWZhdWx0c1xuICAgIH07XG4gIH1cbiAgdXBkYXRlQ29vcmRzKGUpIHtcbiAgICB0aGlzLnNjYWxlVG9XaWR0aChlKSwgdGhpcy5zZXQoXCJzY2FsZVlcIiwgMSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZSkge1xuICAgIGUgPyB0aGlzLmd1aWRlLnNldChcImZpbGxcIiwgdGhpcy5hY3RpdmVHdWlkZUZpbGwpIDogdGhpcy5ndWlkZS5zZXQoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gIH1cbn07XG5UKG5zLCBcInR5cGVcIiwgXCJIZWxwZXJcIiksIFQobnMsIFwib3duRGVmYXVsdHNcIiwge1xuICBzZWxlY3RhYmxlOiAhMSxcbiAgZXZlbnRlZDogITFcbn0pO1xubGV0IFNzID0gbnM7XG5DLnNldENsYXNzKFNzLCBcIkhlbHBlclwiKTtcbmNvbnN0IG9zID0gY2xhc3Mgb3MgZXh0ZW5kcyBYIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpO1xuICAgIFQodGhpcywgXCJndWlkZUl0ZW1JZFwiKTtcbiAgICBUKHRoaXMsIFwiZGlzdFhUb0FjdENlbnRlclwiKTtcbiAgICBUKHRoaXMsIFwidHJhY2tJdGVtVHlwZVwiKTtcbiAgICBUKHRoaXMsIFwiZGVmYXVsdFBvc1wiKTtcbiAgICBUKHRoaXMsIFwiZHJhZ2dlZE9iamVjdFwiKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9zLm93bkRlZmF1bHRzKSwgdGhpcy5pZCA9IGUuaWQ7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXREZWZhdWx0cygpLFxuICAgICAgLi4ub3Mub3duRGVmYXVsdHNcbiAgICB9O1xuICB9XG4gIC8vIGFkZCBjdXN0b20gdGV4dCB0byB0aGUgdHJhY2sgaXRlbVxuICBfcmVuZGVyKGUpIHtcbiAgICBzdXBlci5fcmVuZGVyKGUpLCB0aGlzLnVwZGF0ZVNlbGVjdGVkKGUpO1xuICB9XG4gIHVwZGF0ZVNlbGVjdGVkKGUpIHtcbiAgICBlLnNhdmUoKSwgZS5iZWdpblBhdGgoKSwgZS5yb3VuZFJlY3QoXG4gICAgICAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgdGhpcy53aWR0aCxcbiAgICAgIHRoaXMuaGVpZ2h0LFxuICAgICAgdGhpcy5yeFxuICAgICksIGUubGluZVdpZHRoID0gSXQsIGUuc2V0TGluZURhc2godGhpcy5zdHJva2VEYXNoQXJyYXkpLCBlLnN0cm9rZVN0eWxlID0gdnQsIGUuc3Ryb2tlKCksIGUucmVzdG9yZSgpO1xuICB9XG59O1xuVChvcywgXCJ0eXBlXCIsIFwiUGxhY2Vob2xkZXJcIiksIFQob3MsIFwib3duRGVmYXVsdHNcIiwge1xuICByeDogNixcbiAgcnk6IDYsXG4gIG9iamVjdENhY2hpbmc6ICExLFxuICBib3JkZXJDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICBzdHJva2VXaWR0aDogMCxcbiAgZmlsbDogXCJyZ2JhKDI1NSwgMjExLCA0MiwwLjEpXCIsXG4gIHN0cm9rZTogXCJyZ2JhKDI1NSwgMjExLCA0MiwxLjApXCIsXG4gIHNlbGVjdGFibGU6ICExLFxuICBib3JkZXJPcGFjaXR5V2hlbk1vdmluZzogMSxcbiAgaG92ZXJDdXJzb3I6IFwiZGVmYXVsdFwiLFxuICBzdHJva2VEYXNoQXJyYXk6IFs1LCAxXSxcbiAgZXZlbnRlZDogITFcbn0pO1xubGV0IGVyID0gb3M7XG5DLnNldENsYXNzKGVyLCBcIlBsYWNlaG9sZGVyXCIpO1xuY29uc3QgYXMgPSBjbGFzcyBhcyBleHRlbmRzIFgge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSk7XG4gICAgVCh0aGlzLCBcImR1cmF0aW9uXCIpO1xuICAgIFQodGhpcywgXCJmcm9tSWRcIik7XG4gICAgVCh0aGlzLCBcInRvSWRcIik7XG4gICAgVCh0aGlzLCBcImtpbmRcIiwgXCJub25lXCIpO1xuICAgIFQodGhpcywgXCJpc1NlbGVjdGVkXCIsICExKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGFzLm93bkRlZmF1bHRzKSwgdGhpcy5pZCA9IGUuaWQsIHRoaXMuY2VudGVyZWRTY2FsaW5nID0gITAsIHRoaXMuc3Ryb2tlV2lkdGggPSAwLCB0aGlzLnRTY2FsZSA9IGUudFNjYWxlLCB0aGlzLmR1cmF0aW9uID0gZS5kdXJhdGlvbiwgdGhpcy5mcm9tSWQgPSBlLmZyb21JZCwgdGhpcy50b0lkID0gZS50b0lkLCB0aGlzLmtpbmQgPSBlLmtpbmQsIHRoaXMuc3Ryb2tlRGFzaEFycmF5ID0gZS5zdHJva2VEYXNoQXJyYXkgfHwgW107XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUNvbnRyb2xzKCkge1xuICAgIHJldHVybiB7IGNvbnRyb2xzOiBtbCgpIH07XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXREZWZhdWx0cygpLFxuICAgICAgLi4uYXMub3duRGVmYXVsdHNcbiAgICB9O1xuICB9XG4gIHVwZGF0ZUNvb3JkcygpIHtcbiAgfVxuICAvLyBhZGQgY3VzdG9tIHRleHQgdG8gdGhlIHRyYWNrIGl0ZW1cbiAgX3JlbmRlcihlKSB7XG4gICAgc3VwZXIuX3JlbmRlcihlKSwgdGhpcy51cGRhdGVTZWxlY3RlZChlKTtcbiAgfVxuICBzZXRTZWxlY3RlZChlKSB7XG4gICAgdGhpcy5pc1NlbGVjdGVkID0gZSwgdGhpcy5zZXQoeyBkaXJ0eTogITAgfSk7XG4gIH1cbiAgdXBkYXRlU2VsZWN0ZWQoZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmlzU2VsZWN0ZWQgPyB2dCA6IFwicmdiYSgyNTUsIDI1NSwgMjU1LDAuMTUpXCI7XG4gICAgZS5zYXZlKCksIGUuYmVnaW5QYXRoKCksIGUucm91bmRSZWN0KFxuICAgICAgLXRoaXMud2lkdGggLyAyLFxuICAgICAgLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgIHRoaXMud2lkdGgsXG4gICAgICB0aGlzLmhlaWdodCxcbiAgICAgIHRoaXMucnhcbiAgICApLCBlLmxpbmVXaWR0aCA9IEl0LCBlLnNldExpbmVEYXNoKHRoaXMuc3Ryb2tlRGFzaEFycmF5KSwgZS5zdHJva2VTdHlsZSA9IHMsIGUuc3Ryb2tlKCksIGUucmVzdG9yZSgpO1xuICB9XG59O1xuVChhcywgXCJ0eXBlXCIsIFwiVHJhbnNpdGlvblwiKSwgVChhcywgXCJvd25EZWZhdWx0c1wiLCB7XG4gIG9iamVjdENhY2hpbmc6ICExLFxuICBib3JkZXJDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICBzdHJva2U6IFwidHJhbnNwYXJlbnRcIixcbiAgc3Ryb2tlV2lkdGg6IDEuNSxcbiAgZmlsbDogXCJyZ2JhKDAsMCwwLCAwLjUpXCIsXG4gIGJvcmRlck9wYWNpdHlXaGVuTW92aW5nOiAxLFxuICBob3ZlckN1cnNvcjogXCJkZWZhdWx0XCIsXG4gIGxvY2tNb3ZlbWVudFg6ICEwLFxuICBsb2NrTW92ZW1lbnRZOiAhMCxcbiAgZHVyYXRpb246IDE1MDAsXG4gIHJ4OiA4LFxuICByeTogOFxufSk7XG5sZXQgSnQgPSBhcztcbkMuc2V0Q2xhc3MoSnQsIFwiVHJhbnNpdGlvblwiKTtcbmNvbnN0IGNzID0gY2xhc3MgY3MgZXh0ZW5kcyBYIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpO1xuICAgIFQodGhpcywgXCJpc1NlbGVjdGVkXCIsICExKTtcbiAgICBUKHRoaXMsIFwidGV4dFwiKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNzLm93bkRlZmF1bHRzKSwgdGhpcy5pZCA9IGUuaWQsIHRoaXMuYm9yZGVyQ29sb3IgPSBcInRyYW5zcGFyZW50XCIsIHRoaXMuc3Ryb2tlID0gXCJ0cmFuc3BhcmVudFwiLCB0aGlzLnN0cm9rZVdpZHRoID0gMCwgdGhpcy50U2NhbGUgPSBlLnRTY2FsZSwgdGhpcy5kaXNwbGF5ID0gZS5kaXNwbGF5LCB0aGlzLnRleHQgPSBlLnRleHQ7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUNvbnRyb2xzKCkge1xuICAgIHJldHVybiB7IGNvbnRyb2xzOiBqcygpIH07XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXREZWZhdWx0cygpLFxuICAgICAgLi4uY3Mub3duRGVmYXVsdHNcbiAgICB9O1xuICB9XG4gIHNldFNlbGVjdGVkKGUpIHtcbiAgICB0aGlzLmlzU2VsZWN0ZWQgPSBlLCB0aGlzLnNldCh7IGRpcnR5OiAhMCB9KTtcbiAgfVxuICAvLyBhZGQgY3VzdG9tIHRleHQgdG8gdGhlIHRyYWNrIGl0ZW1cbiAgX3JlbmRlcihlKSB7XG4gICAgc3VwZXIuX3JlbmRlcihlKSwgdGhpcy51cGRhdGVTZWxlY3RlZChlKTtcbiAgfVxuICB1cGRhdGVTZWxlY3RlZChlKSB7XG4gICAgdGhpcy5pc1NlbGVjdGVkICYmIChlLnNhdmUoKSwgZS5iZWdpblBhdGgoKSwgZS5yb3VuZFJlY3QoXG4gICAgICAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgdGhpcy53aWR0aCxcbiAgICAgIHRoaXMuaGVpZ2h0LFxuICAgICAgNlxuICAgICksIGUubGluZVdpZHRoID0gSXQsIGUuc3Ryb2tlU3R5bGUgPSB2dCwgZS5zdHJva2UoKSwgZS5yZXN0b3JlKCkpO1xuICB9XG59O1xuVChjcywgXCJ0eXBlXCIsIFwiQ2FwdGlvblwiKSwgVChjcywgXCJvd25EZWZhdWx0c1wiLCB7XG4gIHJ4OiA2LFxuICByeTogNixcbiAgb2JqZWN0Q2FjaGluZzogITEsXG4gIGJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLFxuICBzdHJva2VXaWR0aDogMCxcbiAgZmlsbDogXCIjMjcyNzJhXCIsXG4gIGJvcmRlck9wYWNpdHlXaGVuTW92aW5nOiAxLFxuICBob3ZlckN1cnNvcjogXCJkZWZhdWx0XCJcbn0pO1xubGV0IHNyID0gY3M7XG5DLnNldENsYXNzKHNyLCBcIkNhcHRpb25cIik7XG5jb25zdCBscyA9IGNsYXNzIGxzIGV4dGVuZHMgWCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKTtcbiAgICBUKHRoaXMsIFwiaXRlbVR5cGVcIiwgXCJ0ZW1wbGF0ZVwiKTtcbiAgICBUKHRoaXMsIFwiaXNTZWxlY3RlZFwiLCAhMSk7XG4gICAgVCh0aGlzLCBcInRyaW1cIik7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBscy5vd25EZWZhdWx0cyksIHRoaXMuaWQgPSBlLmlkLCB0aGlzLmJvcmRlckNvbG9yID0gXCJ0cmFuc3BhcmVudFwiLCB0aGlzLnN0cm9rZSA9IFwidHJhbnNwYXJlbnRcIiwgdGhpcy5zdHJva2VXaWR0aCA9IDAsIHRoaXMudFNjYWxlID0gZS50U2NhbGUsIHRoaXMuZGlzcGxheSA9IGUuZGlzcGxheSwgdGhpcy50cmltID0gZS50cmltO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZ2V0RGVmYXVsdHMoKSxcbiAgICAgIC4uLmxzLm93bkRlZmF1bHRzXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIHsgY29udHJvbHM6IGdmKCkgfTtcbiAgfVxuICBzZXRTZWxlY3RlZChlKSB7XG4gICAgdGhpcy5pc1NlbGVjdGVkID0gZSwgdGhpcy5zZXQoeyBkaXJ0eTogITAgfSk7XG4gIH1cbiAgLy8gYWRkIGN1c3RvbSBBdWRpbyB0byB0aGUgdHJhY2sgaXRlbVxuICBfcmVuZGVyKGUpIHtcbiAgICBzdXBlci5fcmVuZGVyKGUpLCB0aGlzLnVwZGF0ZVNlbGVjdGVkKGUpO1xuICB9XG4gIHVwZGF0ZVNlbGVjdGVkKGUpIHtcbiAgICB0aGlzLmlzU2VsZWN0ZWQgJiYgKGUuc2F2ZSgpLCBlLmJlZ2luUGF0aCgpLCBlLnJvdW5kUmVjdChcbiAgICAgIC10aGlzLndpZHRoIC8gMixcbiAgICAgIC10aGlzLmhlaWdodCAvIDIsXG4gICAgICB0aGlzLndpZHRoLFxuICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICA2XG4gICAgKSwgZS5saW5lV2lkdGggPSBJdCwgZS5zdHJva2VTdHlsZSA9IHZ0LCBlLnN0cm9rZSgpLCBlLnJlc3RvcmUoKSk7XG4gIH1cbn07XG5UKGxzLCBcInR5cGVcIiwgXCJUZW1wbGF0ZVwiKSwgVChscywgXCJvd25EZWZhdWx0c1wiLCB7XG4gIHJ4OiA2LFxuICByeTogNixcbiAgb2JqZWN0Q2FjaGluZzogITEsXG4gIGJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLFxuICBzdHJva2VXaWR0aDogMCxcbiAgZmlsbDogXCIjMjcyNzJhXCIsXG4gIGJvcmRlck9wYWNpdHlXaGVuTW92aW5nOiAxLFxuICBob3ZlckN1cnNvcjogXCJkZWZhdWx0XCJcbn0pO1xubGV0IFZ0ID0gbHM7XG5DLnNldENsYXNzKFZ0LCBcIlRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gd2YoaSkge1xuICBjb25zdCB0ID0gTWF0aC5mbG9vcihpIC8gMWUzKSwgZSA9IE1hdGguZmxvb3IodCAvIDYwKSwgcyA9IHQgJSA2MCwgciA9IFN0cmluZyhlKS5wYWRTdGFydCgyLCBcIjBcIiksIG4gPSBTdHJpbmcocykucGFkU3RhcnQoMiwgXCIwXCIpO1xuICByZXR1cm4gYCR7cn06JHtufWA7XG59XG5jb25zdCBocyA9IGNsYXNzIGhzIGV4dGVuZHMgWCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKTtcbiAgICBUKHRoaXMsIFwiZHVyYXRpb25cIik7XG4gICAgVCh0aGlzLCBcImZyb21JZFwiKTtcbiAgICBUKHRoaXMsIFwidG9JZFwiKTtcbiAgICBUKHRoaXMsIFwiaXNTZWxlY3RlZFwiLCAhMSk7XG4gICAgVCh0aGlzLCBcIm5hbWVcIik7XG4gICAgVCh0aGlzLCBcImR1cmF0aW9uU3RyaW5nXCIpO1xuICAgIFQodGhpcywgXCJpdGVtVHlwZVwiKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGhzLm93bkRlZmF1bHRzKSwgdGhpcy5pZCA9IGUuaWQsIHRoaXMuZmlsbCA9IFwiIzI3MjcyYVwiLCB0aGlzLm5hbWUgPSBlLnR5cGUudG9VcHBlckNhc2UoKSwgdGhpcy5kdXJhdGlvblN0cmluZyA9IHdmKGUuZHVyYXRpb24pLCB0aGlzLml0ZW1UeXBlID0gZS50eXBlO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZ2V0RGVmYXVsdHMoKSxcbiAgICAgIC4uLmhzLm93bkRlZmF1bHRzXG4gICAgfTtcbiAgfVxuICBfcmVuZGVyKGUpIHtcbiAgICBlLnNhdmUoKSwgc3VwZXIuX3JlbmRlcihlKSwgZS5iZWdpblBhdGgoKSwgZS5yZWN0KC10aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCBlLmNsaXAoKSwgdGhpcy5kcmF3VGV4dElkZW50aXR5KGUpLCBlLnJlc3RvcmUoKTtcbiAgfVxuICBkcmF3VGV4dElkZW50aXR5KGUpIHtcbiAgICBlLmZvbnQgPSBcIjYwMCAxMnB4ICdHZWlzdCB2YXJpYWJsZSdcIiwgZS50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICBjb25zdCBzID0gZS5tZWFzdXJlVGV4dCh0aGlzLm5hbWUpLndpZHRoLCByID0gZS5tZWFzdXJlVGV4dCh0aGlzLmR1cmF0aW9uU3RyaW5nKS53aWR0aCwgbiA9IDgsIG8gPSA0LCBhID0gNCAtIHRoaXMuaGVpZ2h0IC8gMiwgYyA9IDIwLCBsID0gNCwgaCA9IDQgLSB0aGlzLndpZHRoIC8gMiwgdSA9IHMgKyBuICogMjtcbiAgICB0aGlzLmRyYXdSb3VuZGVkUmVjdChcbiAgICAgIGUsXG4gICAgICBoLFxuICAgICAgYSxcbiAgICAgIHUsXG4gICAgICBjLFxuICAgICAgbFxuICAgICksIGUuZmlsbFN0eWxlID0gXCIjZjRmNGY1XCIsIGUuZmlsbFRleHQodGhpcy5uYW1lLCBoICsgbiwgYSArIDE0KTtcbiAgICBjb25zdCBkID0gaCArIHUgKyBvLCBmID0gciArIG4gKiAyO1xuICAgIHRoaXMuZHJhd1JvdW5kZWRSZWN0KFxuICAgICAgZSxcbiAgICAgIGQsXG4gICAgICBhLFxuICAgICAgZixcbiAgICAgIGMsXG4gICAgICBsXG4gICAgKSwgZS5maWxsU3R5bGUgPSBcIiNmNGY0ZjVcIiwgZS5maWxsVGV4dCh0aGlzLmR1cmF0aW9uU3RyaW5nLCBkICsgbiwgYSArIDE0KTtcbiAgfVxuICBkcmF3Um91bmRlZFJlY3QoZSwgcywgciwgbiwgbywgYSkge1xuICAgIGUuZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDAuNSlcIiwgZS5yb3VuZFJlY3QgPyAoZS5iZWdpblBhdGgoKSwgZS5yb3VuZFJlY3QocywgciwgbiwgbywgYSksIGUuZmlsbCgpKSA6IGUuZmlsbFJlY3Qocywgciwgbiwgbyk7XG4gIH1cbn07XG5UKGhzLCBcInR5cGVcIiwgXCJQcmV2aWV3VHJhY2tJdGVtXCIpLCBUKGhzLCBcIm93bkRlZmF1bHRzXCIsIHtcbiAgb2JqZWN0Q2FjaGluZzogITEsXG4gIGJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLFxuICBzdHJva2VXaWR0aDogMCxcbiAgYm9yZGVyT3BhY2l0eVdoZW5Nb3Zpbmc6IDEsXG4gIGhvdmVyQ3Vyc29yOiBcImRlZmF1bHRcIixcbiAgcng6IDQsXG4gIHJ5OiA0XG59KTtcbmxldCBPZSA9IGhzO1xuQy5zZXRDbGFzcyhPZSwgXCJQcmV2aWV3VHJhY2tJdGVtXCIpO1xuY2xhc3MgQ2Yge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBUKHRoaXMsIFwiX19fZXZlbnRMaXN0ZW5lcnNcIiwge30pO1xuICAgIFQodGhpcywgXCJfX19hY3RpdmVPYmplY3RzXCIsIFtdKTtcbiAgfVxuICByZXNpemUodCwgeyBmb3JjZTogZSB9ID0geyBmb3JjZTogITEgfSkge1xuICAgIHZhciBzO1xuICAgIHRoaXMubG93ZXJDYW52YXNFbCAmJiAodGhpcy5zZXREaW1lbnNpb25zKHQpLCBlICYmIHRoaXMucmVuZGVyVHJhY2tzKCksIChzID0gdGhpcy5vblJlc2l6ZUNhbnZhcykgPT0gbnVsbCB8fCBzLmNhbGwodGhpcywge1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfSkpO1xuICB9XG4gIHBhdXNlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fX19ldmVudExpc3RlbmVycyA9IHRoaXMuX19ldmVudExpc3RlbmVycywgdGhpcy5fX2V2ZW50TGlzdGVuZXJzID0ge307XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpO1xuICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdCgpLCB0aGlzLl9fX2FjdGl2ZU9iamVjdHMgPSB0O1xuICB9XG4gIHJlc3VtZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX19ldmVudExpc3RlbmVycyA9IHRoaXMuX19fZXZlbnRMaXN0ZW5lcnMsIHRoaXMuX19fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgICBjb25zdCB0ID0gdGhpcy5fX19hY3RpdmVPYmplY3RzO1xuICAgIGlmICghdC5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCksICExO1xuICAgIGlmICh0Lmxlbmd0aCA9PT0gMSlcbiAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KHRbMF0pO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgZSA9IG5ldyBPdCh0KTtcbiAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KGUpO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfVxuICB1cGRhdGVDYWNoaW5nQWN0aXZlT2JqZWN0cyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX19fYWN0aXZlT2JqZWN0cztcbiAgICB0aGlzLl9fX2FjdGl2ZU9iamVjdHMgPSBlLm1hcCgocykgPT4ge1xuICAgICAgY29uc3QgciA9IHQuZmluZCgobikgPT4gbi5pZCA9PT0gcy5pZCk7XG4gICAgICByZXR1cm4gciB8fCBzO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBycihpLCB0KSB7XG4gIHJldHVybiBpLm1hcCgoZSkgPT4gKHtcbiAgICAuLi5lLFxuICAgIGl0ZW1zOiBlLml0ZW1zLmZpbHRlcigocykgPT4gIXQuaW5jbHVkZXMocykpXG4gIH0pKTtcbn1cbmNvbnN0IHVzID0gY2xhc3MgdXMgZXh0ZW5kcyBYIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpO1xuICAgIFQodGhpcywgXCJpdGVtVHlwZVwiLCBcImNvbXBvc2l0aW9uXCIpO1xuICAgIFQodGhpcywgXCJpc1NlbGVjdGVkXCIsICExKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHVzLm93bkRlZmF1bHRzKSwgdGhpcy5pZCA9IGUuaWQsIHRoaXMuYm9yZGVyQ29sb3IgPSBcInRyYW5zcGFyZW50XCIsIHRoaXMuc3Ryb2tlID0gXCJ0cmFuc3BhcmVudFwiLCB0aGlzLnN0cm9rZVdpZHRoID0gMCwgdGhpcy50U2NhbGUgPSBlLnRTY2FsZSwgdGhpcy5kaXNwbGF5ID0gZS5kaXNwbGF5O1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZ2V0RGVmYXVsdHMoKSxcbiAgICAgIC4uLnVzLm93bkRlZmF1bHRzXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIHsgY29udHJvbHM6IGpzKCkgfTtcbiAgfVxuICBzZXRTZWxlY3RlZChlKSB7XG4gICAgdGhpcy5pc1NlbGVjdGVkID0gZSwgdGhpcy5zZXQoeyBkaXJ0eTogITAgfSk7XG4gIH1cbiAgLy8gYWRkIGN1c3RvbSB0ZXh0IHRvIHRoZSB0cmFjayBpdGVtXG4gIF9yZW5kZXIoZSkge1xuICAgIHN1cGVyLl9yZW5kZXIoZSksIHRoaXMudXBkYXRlU2VsZWN0ZWQoZSk7XG4gIH1cbiAgdXBkYXRlU2VsZWN0ZWQoZSkge1xuICAgIHRoaXMuaXNTZWxlY3RlZCAmJiAoZS5zYXZlKCksIGUuYmVnaW5QYXRoKCksIGUucm91bmRSZWN0KFxuICAgICAgLXRoaXMud2lkdGggLyAyLFxuICAgICAgLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgIHRoaXMud2lkdGgsXG4gICAgICB0aGlzLmhlaWdodCxcbiAgICAgIDZcbiAgICApLCBlLmxpbmVXaWR0aCA9IEl0LCBlLnN0cm9rZVN0eWxlID0gdnQsIGUuc3Ryb2tlKCksIGUucmVzdG9yZSgpKTtcbiAgfVxufTtcblQodXMsIFwidHlwZVwiLCBcIkNvbXBvc2l0aW9uXCIpLCBUKHVzLCBcIm93bkRlZmF1bHRzXCIsIHtcbiAgcng6IDYsXG4gIHJ5OiA2LFxuICBvYmplY3RDYWNoaW5nOiAhMSxcbiAgYm9yZGVyQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsXG4gIHN0cm9rZVdpZHRoOiAwLFxuICBmaWxsOiBcIiMyNzI3MmFcIixcbiAgYm9yZGVyT3BhY2l0eVdoZW5Nb3Zpbmc6IDEsXG4gIGhvdmVyQ3Vyc29yOiBcImRlZmF1bHRcIlxufSk7XG5sZXQgb2kgPSB1cztcbkMuc2V0Q2xhc3Mob2ksIFwiQ29tcG9zaXRpb25cIik7XG5jb25zdCBkcyA9IGNsYXNzIGRzIGV4dGVuZHMgWCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKTtcbiAgICBUKHRoaXMsIFwiaXRlbVR5cGVcIiwgXCJpbGx1c3RyYXRpb25cIik7XG4gICAgVCh0aGlzLCBcInNyY1wiKTtcbiAgICBUKHRoaXMsIFwiaXNTZWxlY3RlZFwiLCAhMSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkcy5vd25EZWZhdWx0cyksIHRoaXMuaWQgPSBlLmlkLCB0aGlzLmJvcmRlckNvbG9yID0gXCJ0cmFuc3BhcmVudFwiLCB0aGlzLnN0cm9rZSA9IFwidHJhbnNwYXJlbnRcIiwgdGhpcy5zdHJva2VXaWR0aCA9IDAsIHRoaXMudFNjYWxlID0gZS50U2NhbGUsIHRoaXMuZGlzcGxheSA9IGUuZGlzcGxheSwgdGhpcy5zcmMgPSBlLnNyYztcbiAgfVxuICBzdGF0aWMgY3JlYXRlQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIHsgY29udHJvbHM6IGpzKCkgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmdldERlZmF1bHRzKCksXG4gICAgICAuLi5kcy5vd25EZWZhdWx0c1xuICAgIH07XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZSkge1xuICAgIHRoaXMuaXNTZWxlY3RlZCA9IGUsIHRoaXMuc2V0KHsgZGlydHk6ICEwIH0pO1xuICB9XG4gIC8vIGFkZCBjdXN0b20gdGV4dCB0byB0aGUgdHJhY2sgaXRlbVxuICBfcmVuZGVyKGUpIHtcbiAgICBzdXBlci5fcmVuZGVyKGUpLCB0aGlzLnVwZGF0ZVNlbGVjdGVkKGUpO1xuICB9XG4gIHVwZGF0ZVNlbGVjdGVkKGUpIHtcbiAgICB0aGlzLmlzU2VsZWN0ZWQgJiYgKGUuc2F2ZSgpLCBlLmJlZ2luUGF0aCgpLCBlLnJvdW5kUmVjdChcbiAgICAgIC10aGlzLndpZHRoIC8gMixcbiAgICAgIC10aGlzLmhlaWdodCAvIDIsXG4gICAgICB0aGlzLndpZHRoLFxuICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICA2XG4gICAgKSwgZS5saW5lV2lkdGggPSBJdCwgZS5zdHJva2VTdHlsZSA9IHZ0LCBlLnN0cm9rZSgpLCBlLnJlc3RvcmUoKSk7XG4gIH1cbiAgc2V0U3JjKGUpIHtcbiAgICB0aGlzLnNyYyA9IGUsIHRoaXMuc2V0KHsgZGlydHk6ICEwIH0pO1xuICB9XG59O1xuVChkcywgXCJ0eXBlXCIsIFwiSWxsdXN0cmF0aW9uXCIpLCBUKGRzLCBcIm93bkRlZmF1bHRzXCIsIHtcbiAgcng6IDYsXG4gIHJ5OiA2LFxuICBvYmplY3RDYWNoaW5nOiAhMSxcbiAgYm9yZGVyQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsXG4gIHN0cm9rZVdpZHRoOiAwLFxuICBmaWxsOiBcIiMyNzI3MmFcIixcbiAgYm9yZGVyT3BhY2l0eVdoZW5Nb3Zpbmc6IDEsXG4gIGhvdmVyQ3Vyc29yOiBcImRlZmF1bHRcIlxufSk7XG5sZXQgYWkgPSBkcztcbkMuc2V0Q2xhc3MoYWksIFwiSWxsdXN0cmF0aW9uXCIpO1xuY29uc3QgZnMgPSBjbGFzcyBmcyBleHRlbmRzIFgge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSk7XG4gICAgVCh0aGlzLCBcIml0ZW1UeXBlXCIsIFwic2hhcGVcIik7XG4gICAgVCh0aGlzLCBcInNyY1wiKTtcbiAgICBUKHRoaXMsIFwiaXNTZWxlY3RlZFwiLCAhMSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBmcy5vd25EZWZhdWx0cyksIHRoaXMuaWQgPSBlLmlkLCB0aGlzLmJvcmRlckNvbG9yID0gXCJ0cmFuc3BhcmVudFwiLCB0aGlzLnN0cm9rZSA9IFwidHJhbnNwYXJlbnRcIiwgdGhpcy5zdHJva2VXaWR0aCA9IDAsIHRoaXMudFNjYWxlID0gZS50U2NhbGUsIHRoaXMuZGlzcGxheSA9IGUuZGlzcGxheSwgdGhpcy5zcmMgPSBlLnNyYztcbiAgfVxuICBzdGF0aWMgY3JlYXRlQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIHsgY29udHJvbHM6IGpzKCkgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmdldERlZmF1bHRzKCksXG4gICAgICAuLi5mcy5vd25EZWZhdWx0c1xuICAgIH07XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZSkge1xuICAgIHRoaXMuaXNTZWxlY3RlZCA9IGUsIHRoaXMuc2V0KHsgZGlydHk6ICEwIH0pO1xuICB9XG4gIC8vIGFkZCBjdXN0b20gdGV4dCB0byB0aGUgdHJhY2sgaXRlbVxuICBfcmVuZGVyKGUpIHtcbiAgICBzdXBlci5fcmVuZGVyKGUpLCB0aGlzLnVwZGF0ZVNlbGVjdGVkKGUpO1xuICB9XG4gIHVwZGF0ZVNlbGVjdGVkKGUpIHtcbiAgICB0aGlzLmlzU2VsZWN0ZWQgJiYgKGUuc2F2ZSgpLCBlLmJlZ2luUGF0aCgpLCBlLnJvdW5kUmVjdChcbiAgICAgIC10aGlzLndpZHRoIC8gMixcbiAgICAgIC10aGlzLmhlaWdodCAvIDIsXG4gICAgICB0aGlzLndpZHRoLFxuICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICA2XG4gICAgKSwgZS5saW5lV2lkdGggPSBJdCwgZS5zdHJva2VTdHlsZSA9IHZ0LCBlLnN0cm9rZSgpLCBlLnJlc3RvcmUoKSk7XG4gIH1cbiAgc2V0U3JjKGUpIHtcbiAgICB0aGlzLnNyYyA9IGUsIHRoaXMuc2V0KHsgZGlydHk6ICEwIH0pO1xuICB9XG59O1xuVChmcywgXCJ0eXBlXCIsIFwiU2hhcGVcIiksIFQoZnMsIFwib3duRGVmYXVsdHNcIiwge1xuICByeDogNixcbiAgcnk6IDYsXG4gIG9iamVjdENhY2hpbmc6ICExLFxuICBib3JkZXJDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICBzdHJva2U6IFwidHJhbnNwYXJlbnRcIixcbiAgc3Ryb2tlV2lkdGg6IDAsXG4gIGZpbGw6IFwiIzI3MjcyYVwiLFxuICBib3JkZXJPcGFjaXR5V2hlbk1vdmluZzogMSxcbiAgaG92ZXJDdXJzb3I6IFwiZGVmYXVsdFwiXG59KTtcbmxldCBjaSA9IGZzO1xuQy5zZXRDbGFzcyhjaSwgXCJTaGFwZVwiKTtcbmNvbnN0IE9mID0gKGksIHQpID0+IHtcbiAgdmFyIGE7XG4gIGNvbnN0IGUgPSBEKGkuZGlzcGxheS5mcm9tLCB0LnRTY2FsZSksIHMgPSBEKFxuICAgIGkuZHVyYXRpb24sXG4gICAgdC50U2NhbGUsXG4gICAgaS5wbGF5YmFja1JhdGVcbiAgKSwgciA9IHQuc2l6ZXNNYXAudmlkZW8sIG4gPSBDLmdldENsYXNzKFwiVmlkZW9cIikgfHwgX3Q7XG4gIHJldHVybiBuZXcgbih7XG4gICAgd2lkdGg6IHMsXG4gICAgaGVpZ2h0OiByLFxuICAgIGlkOiBpLmlkLFxuICAgIHRTY2FsZTogdC50U2NhbGUsXG4gICAgZmlsbDogXCIjMzMzMzMzXCIsXG4gICAgcmVzb3VyY2VJZDogKGEgPSBpLm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogYS5yZXNvdXJjZUlkLFxuICAgIGR1cmF0aW9uOiBpLmR1cmF0aW9uLFxuICAgIHRvcDogMTAsXG4gICAgbGVmdDogZSxcbiAgICBkaXNwbGF5OiBpLmRpc3BsYXksXG4gICAgdHJpbTogaS50cmltLFxuICAgIHNyYzogaS5kZXRhaWxzLnNyYyxcbiAgICBtZXRhZGF0YTogaS5tZXRhZGF0YVxuICB9KTtcbn0sIGtmID0gKGksIHQpID0+IHtcbiAgY29uc3QgZSA9IGkuZGlzcGxheSwgcyA9IEQoZS5mcm9tLCB0LnRTY2FsZSksIHIgPSBEKGUudG8gLSBlLmZyb20sIHQudFNjYWxlKSwgbiA9IHQuc2l6ZXNNYXAudGV4dCwgbyA9IEMuZ2V0Q2xhc3MoXCJUZXh0XCIpIHx8IHRyO1xuICByZXR1cm4gbmV3IG8oe1xuICAgIHdpZHRoOiByLFxuICAgIGhlaWdodDogbixcbiAgICBpZDogaS5pZCxcbiAgICBkaXNwbGF5OiBlLFxuICAgIHRvcDogMTAsXG4gICAgbGVmdDogcyxcbiAgICB0ZXh0OiBpLmRldGFpbHMudGV4dCxcbiAgICB0U2NhbGU6IHQudFNjYWxlXG4gIH0pO1xufSwgTWYgPSAoaSwgdCkgPT4ge1xuICBjb25zdCBlID0gaS5kaXNwbGF5LCBzID0gRChlLmZyb20sIHQudFNjYWxlKSwgciA9IEQoZS50byAtIGUuZnJvbSwgdC50U2NhbGUpLCBuID0gdC5zaXplc01hcC5jYXB0aW9uLCBvID0gQy5nZXRDbGFzcyhcIkNhcHRpb25cIikgfHwgc3I7XG4gIHJldHVybiBuZXcgbyh7XG4gICAgd2lkdGg6IHIsXG4gICAgaGVpZ2h0OiBuLFxuICAgIGlkOiBpLmlkLFxuICAgIGRpc3BsYXk6IGUsXG4gICAgdG9wOiAxMCxcbiAgICBsZWZ0OiBzLFxuICAgIHRleHQ6IGkuZGV0YWlscy50ZXh0LFxuICAgIHRTY2FsZTogdC50U2NhbGVcbiAgfSk7XG59LCBJZiA9IChpLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBEKGkuZGlzcGxheS5mcm9tLCB0LnRTY2FsZSksIHMgPSBEKFxuICAgIGkuZGlzcGxheS50byAtIChpLmRpc3BsYXkuZnJvbSB8fCA1ZTMpLFxuICAgIHQudFNjYWxlXG4gICksIHIgPSB0LnNpemVzTWFwLmltYWdlLCBuID0gQy5nZXRDbGFzcyhcIkltYWdlXCIpIHx8IFFzO1xuICByZXR1cm4gbmV3IG4oe1xuICAgIHdpZHRoOiBzLFxuICAgIGhlaWdodDogcixcbiAgICBpZDogaS5pZCxcbiAgICBzcmM6IGkuZGV0YWlscy5zcmMsXG4gICAgdFNjYWxlOiB0LnRTY2FsZSxcbiAgICB0b3A6IDEwLFxuICAgIGxlZnQ6IGUsXG4gICAgZGlzcGxheTogaS5kaXNwbGF5XG4gIH0pO1xufSwgRGYgPSAoaSwgdCkgPT4ge1xuICBjb25zdCBlID0gaS5kaXNwbGF5LCBzID0gRChlLmZyb20sIHQudFNjYWxlKSwgciA9IEQoXG4gICAgZS50byAtIGUuZnJvbSxcbiAgICB0LnRTY2FsZSxcbiAgICBpLnBsYXliYWNrUmF0ZVxuICApLCBuID0gdC5zaXplc01hcC5hdWRpbywgbyA9IEMuZ2V0Q2xhc3MoXCJBdWRpb1wiKSB8fCBmdDtcbiAgcmV0dXJuIG5ldyBvKHtcbiAgICB3aWR0aDogcixcbiAgICBoZWlnaHQ6IG4sXG4gICAgdG9wOiAxMCxcbiAgICBsZWZ0OiBzLFxuICAgIGlkOiBpLmlkLFxuICAgIGRpc3BsYXk6IGUsXG4gICAgdHJpbTogaS50cmltIHx8IHsgZnJvbTogMCwgdG86IGkuZHVyYXRpb24gfSxcbiAgICBkdXJhdGlvbjogaS5kdXJhdGlvbixcbiAgICBzcmM6IGkuZGV0YWlscy5zcmMsXG4gICAgdFNjYWxlOiB0LnRTY2FsZVxuICB9KTtcbn0sIGpmID0gKGksIHQpID0+IHtcbiAgY29uc3QgZSA9IGkuZGlzcGxheSwgcyA9IEQoZS5mcm9tLCB0LnRTY2FsZSksIHIgPSBEKGUudG8gLSBlLmZyb20sIHQudFNjYWxlKSwgbiA9IDQyLCBvID0gQy5nZXRDbGFzcyhcIlRlbXBsYXRlXCIpIHx8IFZ0O1xuICByZXR1cm4gbmV3IG8oe1xuICAgIHdpZHRoOiByLFxuICAgIGhlaWdodDogbixcbiAgICB0b3A6IDEwLFxuICAgIGxlZnQ6IHMsXG4gICAgaWQ6IGkuaWQsXG4gICAgZGlzcGxheTogZSxcbiAgICBkdXJhdGlvbjogZS50byAtIGUuZnJvbSxcbiAgICB0U2NhbGU6IHQudFNjYWxlLFxuICAgIHRyaW06IGkudHJpbSB8fCBpLmRpc3BsYXlcbiAgfSk7XG59LCBFZiA9IChpLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBpLmRpc3BsYXksIHMgPSBEKGUuZnJvbSwgdC50U2NhbGUpLCByID0gRChlLnRvIC0gZS5mcm9tLCB0LnRTY2FsZSksIG4gPSAzMiwgbyA9IEMuZ2V0Q2xhc3MoXCJDb21wb3NpdGlvblwiKSB8fCBvaTtcbiAgcmV0dXJuIG5ldyBvKHtcbiAgICB3aWR0aDogcixcbiAgICBoZWlnaHQ6IG4sXG4gICAgaWQ6IGkuaWQsXG4gICAgZGlzcGxheTogZSxcbiAgICB0b3A6IDEwLFxuICAgIGxlZnQ6IHMsXG4gICAgZHVyYXRpb246IGUudG8gLSBlLmZyb20sXG4gICAgdFNjYWxlOiB0LnRTY2FsZVxuICB9KTtcbn0sIFBmID0gKGksIHQpID0+IHtcbiAgY29uc3QgZSA9IEQoaS5kaXNwbGF5LmZyb20sIHQudFNjYWxlKSwgcyA9IEQoXG4gICAgaS5kaXNwbGF5LnRvIC0gKGkuZGlzcGxheS5mcm9tIHx8IDVlMyksXG4gICAgdC50U2NhbGVcbiAgKSwgciA9IHQuc2l6ZXNNYXAuaWxsdXN0cmF0aW9uLCBuID0gQy5nZXRDbGFzcyhcIklsbHVzdHJhdGlvblwiKSB8fCBhaTtcbiAgcmV0dXJuIG5ldyBuKHtcbiAgICB3aWR0aDogcyxcbiAgICBoZWlnaHQ6IHIsXG4gICAgaWQ6IGkuaWQsXG4gICAgc3JjOiBpLmRldGFpbHMuc3JjLFxuICAgIHRTY2FsZTogdC50U2NhbGUsXG4gICAgdG9wOiAxMCxcbiAgICBsZWZ0OiBlLFxuICAgIGRpc3BsYXk6IGkuZGlzcGxheVxuICB9KTtcbn0sIEFmID0gKGksIHQpID0+IHtcbiAgY29uc3QgZSA9IEQoaS5kaXNwbGF5LmZyb20sIHQudFNjYWxlKSwgcyA9IEQoXG4gICAgaS5kaXNwbGF5LnRvIC0gKGkuZGlzcGxheS5mcm9tIHx8IDVlMyksXG4gICAgdC50U2NhbGVcbiAgKSwgciA9IHQuc2l6ZXNNYXAuc2hhcGUsIG4gPSBDLmdldENsYXNzKFwiU2hhcGVcIikgfHwgY2k7XG4gIHJldHVybiBuZXcgbih7XG4gICAgd2lkdGg6IHMsXG4gICAgaGVpZ2h0OiByLFxuICAgIGlkOiBpLmlkLFxuICAgIHNyYzogaS5kZXRhaWxzLnNyYyxcbiAgICB0U2NhbGU6IHQudFNjYWxlLFxuICAgIHRvcDogMTAsXG4gICAgbGVmdDogZSxcbiAgICBkaXNwbGF5OiBpLmRpc3BsYXlcbiAgfSk7XG59LCBGZiA9IChpLCB0KSA9PiB7XG4gIGlmIChpLnR5cGUgPT09IFwiY2FwdGlvblwiKSByZXR1cm4gTWYoaSwgdCk7XG4gIGlmIChpLnR5cGUgPT09IFwidGV4dFwiKSByZXR1cm4ga2YoaSwgdCk7XG4gIGlmIChpLnR5cGUgPT09IFwiaW1hZ2VcIikgcmV0dXJuIElmKGksIHQpO1xuICBpZiAoaS50eXBlID09PSBcInZpZGVvXCIpIHJldHVybiBPZihpLCB0KTtcbiAgaWYgKGkudHlwZSA9PT0gXCJhdWRpb1wiKSByZXR1cm4gRGYoaSwgdCk7XG4gIGlmIChpLnR5cGUgPT09IFwidGVtcGxhdGVcIikgcmV0dXJuIGpmKGksIHQpO1xuICBpZiAoaS50eXBlID09PSBcInNoYXBlXCIpIHJldHVybiBBZihpLCB0KTtcbiAgaWYgKGkudHlwZSA9PT0gXCJpbGx1c3RyYXRpb25cIilcbiAgICByZXR1cm4gUGYoaSwgdCk7XG4gIGlmIChpLnR5cGUgPT09IFwiY29tcG9zaXRpb25cIilcbiAgICByZXR1cm4gRWYoaSwgdCk7XG59O1xudmFyIHZsID0gdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsLCBSZiA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGYsIFh0ID0gdmwgfHwgUmYgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpLCBNdCA9IFh0LlN5bWJvbCwgeWwgPSBPYmplY3QucHJvdG90eXBlLCBMZiA9IHlsLmhhc093blByb3BlcnR5LCBCZiA9IHlsLnRvU3RyaW5nLCBScyA9IE10ID8gTXQudG9TdHJpbmdUYWcgOiB2b2lkIDA7XG5mdW5jdGlvbiBXZihpKSB7XG4gIHZhciB0ID0gTGYuY2FsbChpLCBScyksIGUgPSBpW1JzXTtcbiAgdHJ5IHtcbiAgICBpW1JzXSA9IHZvaWQgMDtcbiAgICB2YXIgcyA9ICEwO1xuICB9IGNhdGNoIHtcbiAgfVxuICB2YXIgciA9IEJmLmNhbGwoaSk7XG4gIHJldHVybiBzICYmICh0ID8gaVtSc10gPSBlIDogZGVsZXRlIGlbUnNdKSwgcjtcbn1cbnZhciBYZiA9IE9iamVjdC5wcm90b3R5cGUsIHpmID0gWGYudG9TdHJpbmc7XG5mdW5jdGlvbiBIZihpKSB7XG4gIHJldHVybiB6Zi5jYWxsKGkpO1xufVxudmFyIFlmID0gXCJbb2JqZWN0IE51bGxdXCIsIFZmID0gXCJbb2JqZWN0IFVuZGVmaW5lZF1cIiwgSm8gPSBNdCA/IE10LnRvU3RyaW5nVGFnIDogdm9pZCAwO1xuZnVuY3Rpb24gRXMoaSkge1xuICByZXR1cm4gaSA9PSBudWxsID8gaSA9PT0gdm9pZCAwID8gVmYgOiBZZiA6IEpvICYmIEpvIGluIE9iamVjdChpKSA/IFdmKGkpIDogSGYoaSk7XG59XG5mdW5jdGlvbiBrZShpKSB7XG4gIHJldHVybiBpICE9IG51bGwgJiYgdHlwZW9mIGkgPT0gXCJvYmplY3RcIjtcbn1cbnZhciBHZiA9IFwiW29iamVjdCBTeW1ib2xdXCI7XG5mdW5jdGlvbiBJaShpKSB7XG4gIHJldHVybiB0eXBlb2YgaSA9PSBcInN5bWJvbFwiIHx8IGtlKGkpICYmIEVzKGkpID09IEdmO1xufVxuZnVuY3Rpb24gTmYoaSwgdCkge1xuICBmb3IgKHZhciBlID0gLTEsIHMgPSBpID09IG51bGwgPyAwIDogaS5sZW5ndGgsIHIgPSBBcnJheShzKTsgKytlIDwgczsgKVxuICAgIHJbZV0gPSB0KGlbZV0sIGUsIGkpO1xuICByZXR1cm4gcjtcbn1cbnZhciBadCA9IEFycmF5LmlzQXJyYXksIFpvID0gTXQgPyBNdC5wcm90b3R5cGUgOiB2b2lkIDAsIFFvID0gWm8gPyBaby50b1N0cmluZyA6IHZvaWQgMDtcbmZ1bmN0aW9uIGJsKGkpIHtcbiAgaWYgKHR5cGVvZiBpID09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGk7XG4gIGlmIChadChpKSlcbiAgICByZXR1cm4gTmYoaSwgYmwpICsgXCJcIjtcbiAgaWYgKElpKGkpKVxuICAgIHJldHVybiBRbyA/IFFvLmNhbGwoaSkgOiBcIlwiO1xuICB2YXIgdCA9IGkgKyBcIlwiO1xuICByZXR1cm4gdCA9PSBcIjBcIiAmJiAxIC8gaSA9PSAtMSAvIDAgPyBcIi0wXCIgOiB0O1xufVxudmFyIFVmID0gL1xccy87XG5mdW5jdGlvbiAkZihpKSB7XG4gIGZvciAodmFyIHQgPSBpLmxlbmd0aDsgdC0tICYmIFVmLnRlc3QoaS5jaGFyQXQodCkpOyApXG4gICAgO1xuICByZXR1cm4gdDtcbn1cbnZhciBxZiA9IC9eXFxzKy87XG5mdW5jdGlvbiBLZihpKSB7XG4gIHJldHVybiBpICYmIGkuc2xpY2UoMCwgJGYoaSkgKyAxKS5yZXBsYWNlKHFmLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIFF0KGkpIHtcbiAgdmFyIHQgPSB0eXBlb2YgaTtcbiAgcmV0dXJuIGkgIT0gbnVsbCAmJiAodCA9PSBcIm9iamVjdFwiIHx8IHQgPT0gXCJmdW5jdGlvblwiKTtcbn1cbnZhciB0YSA9IE5hTiwgSmYgPSAvXlstK10weFswLTlhLWZdKyQvaSwgWmYgPSAvXjBiWzAxXSskL2ksIFFmID0gL14wb1swLTddKyQvaSwgdGcgPSBwYXJzZUludDtcbmZ1bmN0aW9uIGVhKGkpIHtcbiAgaWYgKHR5cGVvZiBpID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGk7XG4gIGlmIChJaShpKSlcbiAgICByZXR1cm4gdGE7XG4gIGlmIChRdChpKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIGkudmFsdWVPZiA9PSBcImZ1bmN0aW9uXCIgPyBpLnZhbHVlT2YoKSA6IGk7XG4gICAgaSA9IFF0KHQpID8gdCArIFwiXCIgOiB0O1xuICB9XG4gIGlmICh0eXBlb2YgaSAhPSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBpID09PSAwID8gaSA6ICtpO1xuICBpID0gS2YoaSk7XG4gIHZhciBlID0gWmYudGVzdChpKTtcbiAgcmV0dXJuIGUgfHwgUWYudGVzdChpKSA/IHRnKGkuc2xpY2UoMiksIGUgPyAyIDogOCkgOiBKZi50ZXN0KGkpID8gdGEgOiAraTtcbn1cbmZ1bmN0aW9uIGVnKGkpIHtcbiAgcmV0dXJuIGk7XG59XG52YXIgc2cgPSBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIiwgcmcgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsIGlnID0gXCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiLCBuZyA9IFwiW29iamVjdCBQcm94eV1cIjtcbmZ1bmN0aW9uIF9sKGkpIHtcbiAgaWYgKCFRdChpKSlcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gRXMoaSk7XG4gIHJldHVybiB0ID09IHJnIHx8IHQgPT0gaWcgfHwgdCA9PSBzZyB8fCB0ID09IG5nO1xufVxudmFyIEtpID0gWHRbXCJfX2NvcmUtanNfc2hhcmVkX19cIl0sIHNhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpID0gL1teLl0rJC8uZXhlYyhLaSAmJiBLaS5rZXlzICYmIEtpLmtleXMuSUVfUFJPVE8gfHwgXCJcIik7XG4gIHJldHVybiBpID8gXCJTeW1ib2woc3JjKV8xLlwiICsgaSA6IFwiXCI7XG59KCk7XG5mdW5jdGlvbiBvZyhpKSB7XG4gIHJldHVybiAhIXNhICYmIHNhIGluIGk7XG59XG52YXIgYWcgPSBGdW5jdGlvbi5wcm90b3R5cGUsIGNnID0gYWcudG9TdHJpbmc7XG5mdW5jdGlvbiBVZShpKSB7XG4gIGlmIChpICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNnLmNhbGwoaSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaSArIFwiXCI7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlwiO1xufVxudmFyIGxnID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLCBoZyA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC8sIHVnID0gRnVuY3Rpb24ucHJvdG90eXBlLCBkZyA9IE9iamVjdC5wcm90b3R5cGUsIGZnID0gdWcudG9TdHJpbmcsIGdnID0gZGcuaGFzT3duUHJvcGVydHksIHBnID0gUmVnRXhwKFxuICBcIl5cIiArIGZnLmNhbGwoZ2cpLnJlcGxhY2UobGcsIFwiXFxcXCQmXCIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csIFwiJDEuKj9cIikgKyBcIiRcIlxuKTtcbmZ1bmN0aW9uIG1nKGkpIHtcbiAgaWYgKCFRdChpKSB8fCBvZyhpKSlcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gX2woaSkgPyBwZyA6IGhnO1xuICByZXR1cm4gdC50ZXN0KFVlKGkpKTtcbn1cbmZ1bmN0aW9uIHZnKGksIHQpIHtcbiAgcmV0dXJuIGkgPT0gbnVsbCA/IHZvaWQgMCA6IGlbdF07XG59XG5mdW5jdGlvbiAkZShpLCB0KSB7XG4gIHZhciBlID0gdmcoaSwgdCk7XG4gIHJldHVybiBtZyhlKSA/IGUgOiB2b2lkIDA7XG59XG52YXIgd24gPSAkZShYdCwgXCJXZWFrTWFwXCIpLCByYSA9IE9iamVjdC5jcmVhdGUsIHlnID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBpKCkge1xuICB9XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgaWYgKCFRdCh0KSlcbiAgICAgIHJldHVybiB7fTtcbiAgICBpZiAocmEpXG4gICAgICByZXR1cm4gcmEodCk7XG4gICAgaS5wcm90b3R5cGUgPSB0O1xuICAgIHZhciBlID0gbmV3IGkoKTtcbiAgICByZXR1cm4gaS5wcm90b3R5cGUgPSB2b2lkIDAsIGU7XG4gIH07XG59KCk7XG5mdW5jdGlvbiBiZyhpLCB0LCBlKSB7XG4gIHN3aXRjaCAoZS5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gaS5jYWxsKHQpO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBpLmNhbGwodCwgZVswXSk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGkuY2FsbCh0LCBlWzBdLCBlWzFdKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gaS5jYWxsKHQsIGVbMF0sIGVbMV0sIGVbMl0pO1xuICB9XG4gIHJldHVybiBpLmFwcGx5KHQsIGUpO1xufVxudmFyIF9nID0gODAwLCBTZyA9IDE2LCBUZyA9IERhdGUubm93O1xuZnVuY3Rpb24geGcoaSkge1xuICB2YXIgdCA9IDAsIGUgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHMgPSBUZygpLCByID0gU2cgLSAocyAtIGUpO1xuICAgIGlmIChlID0gcywgciA+IDApIHtcbiAgICAgIGlmICgrK3QgPj0gX2cpXG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlXG4gICAgICB0ID0gMDtcbiAgICByZXR1cm4gaS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiB3ZyhpKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaTtcbiAgfTtcbn1cbnZhciBsaSA9IGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBpID0gJGUoT2JqZWN0LCBcImRlZmluZVByb3BlcnR5XCIpO1xuICAgIHJldHVybiBpKHt9LCBcIlwiLCB7fSksIGk7XG4gIH0gY2F0Y2gge1xuICB9XG59KCksIENnID0gbGkgPyBmdW5jdGlvbihpLCB0KSB7XG4gIHJldHVybiBsaShpLCBcInRvU3RyaW5nXCIsIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIGVudW1lcmFibGU6ICExLFxuICAgIHZhbHVlOiB3Zyh0KSxcbiAgICB3cml0YWJsZTogITBcbiAgfSk7XG59IDogZWcsIE9nID0geGcoQ2cpO1xuZnVuY3Rpb24ga2coaSwgdCkge1xuICBmb3IgKHZhciBlID0gLTEsIHMgPSBpID09IG51bGwgPyAwIDogaS5sZW5ndGg7ICsrZSA8IHMgJiYgdChpW2VdLCBlLCBpKSAhPT0gITE7IClcbiAgICA7XG4gIHJldHVybiBpO1xufVxudmFyIE1nID0gOTAwNzE5OTI1NDc0MDk5MSwgSWcgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuZnVuY3Rpb24gZW8oaSwgdCkge1xuICB2YXIgZSA9IHR5cGVvZiBpO1xuICByZXR1cm4gdCA9IHQgPz8gTWcsICEhdCAmJiAoZSA9PSBcIm51bWJlclwiIHx8IGUgIT0gXCJzeW1ib2xcIiAmJiBJZy50ZXN0KGkpKSAmJiBpID4gLTEgJiYgaSAlIDEgPT0gMCAmJiBpIDwgdDtcbn1cbmZ1bmN0aW9uIERnKGksIHQsIGUpIHtcbiAgdCA9PSBcIl9fcHJvdG9fX1wiICYmIGxpID8gbGkoaSwgdCwge1xuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgdmFsdWU6IGUsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogaVt0XSA9IGU7XG59XG5mdW5jdGlvbiBzbyhpLCB0KSB7XG4gIHJldHVybiBpID09PSB0IHx8IGkgIT09IGkgJiYgdCAhPT0gdDtcbn1cbnZhciBqZyA9IE9iamVjdC5wcm90b3R5cGUsIEVnID0gamcuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBTbChpLCB0LCBlKSB7XG4gIHZhciBzID0gaVt0XTtcbiAgKCEoRWcuY2FsbChpLCB0KSAmJiBzbyhzLCBlKSkgfHwgZSA9PT0gdm9pZCAwICYmICEodCBpbiBpKSkgJiYgRGcoaSwgdCwgZSk7XG59XG52YXIgaWEgPSBNYXRoLm1heDtcbmZ1bmN0aW9uIFBnKGksIHQsIGUpIHtcbiAgcmV0dXJuIHQgPSBpYSh0ID09PSB2b2lkIDAgPyBpLmxlbmd0aCAtIDEgOiB0LCAwKSwgZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcyA9IGFyZ3VtZW50cywgciA9IC0xLCBuID0gaWEocy5sZW5ndGggLSB0LCAwKSwgbyA9IEFycmF5KG4pOyArK3IgPCBuOyApXG4gICAgICBvW3JdID0gc1t0ICsgcl07XG4gICAgciA9IC0xO1xuICAgIGZvciAodmFyIGEgPSBBcnJheSh0ICsgMSk7ICsrciA8IHQ7IClcbiAgICAgIGFbcl0gPSBzW3JdO1xuICAgIHJldHVybiBhW3RdID0gZShvKSwgYmcoaSwgdGhpcywgYSk7XG4gIH07XG59XG52YXIgQWcgPSA5MDA3MTk5MjU0NzQwOTkxO1xuZnVuY3Rpb24gcm8oaSkge1xuICByZXR1cm4gdHlwZW9mIGkgPT0gXCJudW1iZXJcIiAmJiBpID4gLTEgJiYgaSAlIDEgPT0gMCAmJiBpIDw9IEFnO1xufVxuZnVuY3Rpb24gRmcoaSkge1xuICByZXR1cm4gaSAhPSBudWxsICYmIHJvKGkubGVuZ3RoKSAmJiAhX2woaSk7XG59XG52YXIgUmcgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gVGwoaSkge1xuICB2YXIgdCA9IGkgJiYgaS5jb25zdHJ1Y3RvciwgZSA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiAmJiB0LnByb3RvdHlwZSB8fCBSZztcbiAgcmV0dXJuIGkgPT09IGU7XG59XG5mdW5jdGlvbiBMZyhpLCB0KSB7XG4gIGZvciAodmFyIGUgPSAtMSwgcyA9IEFycmF5KGkpOyArK2UgPCBpOyApXG4gICAgc1tlXSA9IHQoZSk7XG4gIHJldHVybiBzO1xufVxudmFyIEJnID0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIjtcbmZ1bmN0aW9uIG5hKGkpIHtcbiAgcmV0dXJuIGtlKGkpICYmIEVzKGkpID09IEJnO1xufVxudmFyIHhsID0gT2JqZWN0LnByb3RvdHlwZSwgV2cgPSB4bC5oYXNPd25Qcm9wZXJ0eSwgWGcgPSB4bC5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgaW8gPSBuYSgvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBhcmd1bWVudHM7XG59KCkpID8gbmEgOiBmdW5jdGlvbihpKSB7XG4gIHJldHVybiBrZShpKSAmJiBXZy5jYWxsKGksIFwiY2FsbGVlXCIpICYmICFYZy5jYWxsKGksIFwiY2FsbGVlXCIpO1xufTtcbmZ1bmN0aW9uIHpnKCkge1xuICByZXR1cm4gITE7XG59XG52YXIgd2wgPSB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cywgb2EgPSB3bCAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlLCBIZyA9IG9hICYmIG9hLmV4cG9ydHMgPT09IHdsLCBhYSA9IEhnID8gWHQuQnVmZmVyIDogdm9pZCAwLCBZZyA9IGFhID8gYWEuaXNCdWZmZXIgOiB2b2lkIDAsIGhpID0gWWcgfHwgemcsIFZnID0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIiwgR2cgPSBcIltvYmplY3QgQXJyYXldXCIsIE5nID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIFVnID0gXCJbb2JqZWN0IERhdGVdXCIsICRnID0gXCJbb2JqZWN0IEVycm9yXVwiLCBxZyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIiwgS2cgPSBcIltvYmplY3QgTWFwXVwiLCBKZyA9IFwiW29iamVjdCBOdW1iZXJdXCIsIFpnID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgUWcgPSBcIltvYmplY3QgUmVnRXhwXVwiLCB0cCA9IFwiW29iamVjdCBTZXRdXCIsIGVwID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgc3AgPSBcIltvYmplY3QgV2Vha01hcF1cIiwgcnAgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsIGlwID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCBucCA9IFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCIsIG9wID0gXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIiwgYXAgPSBcIltvYmplY3QgSW50OEFycmF5XVwiLCBjcCA9IFwiW29iamVjdCBJbnQxNkFycmF5XVwiLCBscCA9IFwiW29iamVjdCBJbnQzMkFycmF5XVwiLCBocCA9IFwiW29iamVjdCBVaW50OEFycmF5XVwiLCB1cCA9IFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIiwgZHAgPSBcIltvYmplY3QgVWludDE2QXJyYXldXCIsIGZwID0gXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiLCBIID0ge307XG5IW25wXSA9IEhbb3BdID0gSFthcF0gPSBIW2NwXSA9IEhbbHBdID0gSFtocF0gPSBIW3VwXSA9IEhbZHBdID0gSFtmcF0gPSAhMDtcbkhbVmddID0gSFtHZ10gPSBIW3JwXSA9IEhbTmddID0gSFtpcF0gPSBIW1VnXSA9IEhbJGddID0gSFtxZ10gPSBIW0tnXSA9IEhbSmddID0gSFtaZ10gPSBIW1FnXSA9IEhbdHBdID0gSFtlcF0gPSBIW3NwXSA9ICExO1xuZnVuY3Rpb24gZ3AoaSkge1xuICByZXR1cm4ga2UoaSkgJiYgcm8oaS5sZW5ndGgpICYmICEhSFtFcyhpKV07XG59XG5mdW5jdGlvbiBubyhpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGkodCk7XG4gIH07XG59XG52YXIgQ2wgPSB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cywgTnMgPSBDbCAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlLCBwcCA9IE5zICYmIE5zLmV4cG9ydHMgPT09IENsLCBKaSA9IHBwICYmIHZsLnByb2Nlc3MsIFRzID0gZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGkgPSBOcyAmJiBOcy5yZXF1aXJlICYmIE5zLnJlcXVpcmUoXCJ1dGlsXCIpLnR5cGVzO1xuICAgIHJldHVybiBpIHx8IEppICYmIEppLmJpbmRpbmcgJiYgSmkuYmluZGluZyhcInV0aWxcIik7XG4gIH0gY2F0Y2gge1xuICB9XG59KCksIGNhID0gVHMgJiYgVHMuaXNUeXBlZEFycmF5LCBPbCA9IGNhID8gbm8oY2EpIDogZ3AsIG1wID0gT2JqZWN0LnByb3RvdHlwZSwgdnAgPSBtcC5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHlwKGksIHQpIHtcbiAgdmFyIGUgPSBadChpKSwgcyA9ICFlICYmIGlvKGkpLCByID0gIWUgJiYgIXMgJiYgaGkoaSksIG4gPSAhZSAmJiAhcyAmJiAhciAmJiBPbChpKSwgbyA9IGUgfHwgcyB8fCByIHx8IG4sIGEgPSBvID8gTGcoaS5sZW5ndGgsIFN0cmluZykgOiBbXSwgYyA9IGEubGVuZ3RoO1xuICBmb3IgKHZhciBsIGluIGkpXG4gICAgdnAuY2FsbChpLCBsKSAmJiAhKG8gJiYgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgIChsID09IFwibGVuZ3RoXCIgfHwgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgciAmJiAobCA9PSBcIm9mZnNldFwiIHx8IGwgPT0gXCJwYXJlbnRcIikgfHwgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgIG4gJiYgKGwgPT0gXCJidWZmZXJcIiB8fCBsID09IFwiYnl0ZUxlbmd0aFwiIHx8IGwgPT0gXCJieXRlT2Zmc2V0XCIpIHx8IC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICBlbyhsLCBjKSkpICYmIGEucHVzaChsKTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBrbChpLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGkodChlKSk7XG4gIH07XG59XG52YXIgYnAgPSBrbChPYmplY3Qua2V5cywgT2JqZWN0KSwgX3AgPSBPYmplY3QucHJvdG90eXBlLCBTcCA9IF9wLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gVHAoaSkge1xuICBpZiAoIVRsKGkpKVxuICAgIHJldHVybiBicChpKTtcbiAgdmFyIHQgPSBbXTtcbiAgZm9yICh2YXIgZSBpbiBPYmplY3QoaSkpXG4gICAgU3AuY2FsbChpLCBlKSAmJiBlICE9IFwiY29uc3RydWN0b3JcIiAmJiB0LnB1c2goZSk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24geHAoaSkge1xuICByZXR1cm4gRmcoaSkgPyB5cChpKSA6IFRwKGkpO1xufVxudmFyIHdwID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLywgQ3AgPSAvXlxcdyokLztcbmZ1bmN0aW9uIE9wKGksIHQpIHtcbiAgaWYgKFp0KGkpKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIGUgPSB0eXBlb2YgaTtcbiAgcmV0dXJuIGUgPT0gXCJudW1iZXJcIiB8fCBlID09IFwic3ltYm9sXCIgfHwgZSA9PSBcImJvb2xlYW5cIiB8fCBpID09IG51bGwgfHwgSWkoaSkgPyAhMCA6IENwLnRlc3QoaSkgfHwgIXdwLnRlc3QoaSkgfHwgdCAhPSBudWxsICYmIGkgaW4gT2JqZWN0KHQpO1xufVxudmFyIGlyID0gJGUoT2JqZWN0LCBcImNyZWF0ZVwiKTtcbmZ1bmN0aW9uIGtwKCkge1xuICB0aGlzLl9fZGF0YV9fID0gaXIgPyBpcihudWxsKSA6IHt9LCB0aGlzLnNpemUgPSAwO1xufVxuZnVuY3Rpb24gTXAoaSkge1xuICB2YXIgdCA9IHRoaXMuaGFzKGkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2ldO1xuICByZXR1cm4gdGhpcy5zaXplIC09IHQgPyAxIDogMCwgdDtcbn1cbnZhciBJcCA9IFwiX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfX1wiLCBEcCA9IE9iamVjdC5wcm90b3R5cGUsIGpwID0gRHAuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBFcChpKSB7XG4gIHZhciB0ID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGlyKSB7XG4gICAgdmFyIGUgPSB0W2ldO1xuICAgIHJldHVybiBlID09PSBJcCA/IHZvaWQgMCA6IGU7XG4gIH1cbiAgcmV0dXJuIGpwLmNhbGwodCwgaSkgPyB0W2ldIDogdm9pZCAwO1xufVxudmFyIFBwID0gT2JqZWN0LnByb3RvdHlwZSwgQXAgPSBQcC5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIEZwKGkpIHtcbiAgdmFyIHQgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gaXIgPyB0W2ldICE9PSB2b2lkIDAgOiBBcC5jYWxsKHQsIGkpO1xufVxudmFyIFJwID0gXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCI7XG5mdW5jdGlvbiBMcChpLCB0KSB7XG4gIHZhciBlID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhpKSA/IDAgOiAxLCBlW2ldID0gaXIgJiYgdCA9PT0gdm9pZCAwID8gUnAgOiB0LCB0aGlzO1xufVxuZnVuY3Rpb24gWWUoaSkge1xuICB2YXIgdCA9IC0xLCBlID0gaSA9PSBudWxsID8gMCA6IGkubGVuZ3RoO1xuICBmb3IgKHRoaXMuY2xlYXIoKTsgKyt0IDwgZTsgKSB7XG4gICAgdmFyIHMgPSBpW3RdO1xuICAgIHRoaXMuc2V0KHNbMF0sIHNbMV0pO1xuICB9XG59XG5ZZS5wcm90b3R5cGUuY2xlYXIgPSBrcDtcblllLnByb3RvdHlwZS5kZWxldGUgPSBNcDtcblllLnByb3RvdHlwZS5nZXQgPSBFcDtcblllLnByb3RvdHlwZS5oYXMgPSBGcDtcblllLnByb3RvdHlwZS5zZXQgPSBMcDtcbmZ1bmN0aW9uIEJwKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW10sIHRoaXMuc2l6ZSA9IDA7XG59XG5mdW5jdGlvbiBEaShpLCB0KSB7XG4gIGZvciAodmFyIGUgPSBpLmxlbmd0aDsgZS0tOyApXG4gICAgaWYgKHNvKGlbZV1bMF0sIHQpKVxuICAgICAgcmV0dXJuIGU7XG4gIHJldHVybiAtMTtcbn1cbnZhciBXcCA9IEFycmF5LnByb3RvdHlwZSwgWHAgPSBXcC5zcGxpY2U7XG5mdW5jdGlvbiB6cChpKSB7XG4gIHZhciB0ID0gdGhpcy5fX2RhdGFfXywgZSA9IERpKHQsIGkpO1xuICBpZiAoZSA8IDApXG4gICAgcmV0dXJuICExO1xuICB2YXIgcyA9IHQubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGUgPT0gcyA/IHQucG9wKCkgOiBYcC5jYWxsKHQsIGUsIDEpLCAtLXRoaXMuc2l6ZSwgITA7XG59XG5mdW5jdGlvbiBIcChpKSB7XG4gIHZhciB0ID0gdGhpcy5fX2RhdGFfXywgZSA9IERpKHQsIGkpO1xuICByZXR1cm4gZSA8IDAgPyB2b2lkIDAgOiB0W2VdWzFdO1xufVxuZnVuY3Rpb24gWXAoaSkge1xuICByZXR1cm4gRGkodGhpcy5fX2RhdGFfXywgaSkgPiAtMTtcbn1cbmZ1bmN0aW9uIFZwKGksIHQpIHtcbiAgdmFyIGUgPSB0aGlzLl9fZGF0YV9fLCBzID0gRGkoZSwgaSk7XG4gIHJldHVybiBzIDwgMCA/ICgrK3RoaXMuc2l6ZSwgZS5wdXNoKFtpLCB0XSkpIDogZVtzXVsxXSA9IHQsIHRoaXM7XG59XG5mdW5jdGlvbiBnZShpKSB7XG4gIHZhciB0ID0gLTEsIGUgPSBpID09IG51bGwgPyAwIDogaS5sZW5ndGg7XG4gIGZvciAodGhpcy5jbGVhcigpOyArK3QgPCBlOyApIHtcbiAgICB2YXIgcyA9IGlbdF07XG4gICAgdGhpcy5zZXQoc1swXSwgc1sxXSk7XG4gIH1cbn1cbmdlLnByb3RvdHlwZS5jbGVhciA9IEJwO1xuZ2UucHJvdG90eXBlLmRlbGV0ZSA9IHpwO1xuZ2UucHJvdG90eXBlLmdldCA9IEhwO1xuZ2UucHJvdG90eXBlLmhhcyA9IFlwO1xuZ2UucHJvdG90eXBlLnNldCA9IFZwO1xudmFyIG5yID0gJGUoWHQsIFwiTWFwXCIpO1xuZnVuY3Rpb24gR3AoKSB7XG4gIHRoaXMuc2l6ZSA9IDAsIHRoaXMuX19kYXRhX18gPSB7XG4gICAgaGFzaDogbmV3IFllKCksXG4gICAgbWFwOiBuZXcgKG5yIHx8IGdlKSgpLFxuICAgIHN0cmluZzogbmV3IFllKClcbiAgfTtcbn1cbmZ1bmN0aW9uIE5wKGkpIHtcbiAgdmFyIHQgPSB0eXBlb2YgaTtcbiAgcmV0dXJuIHQgPT0gXCJzdHJpbmdcIiB8fCB0ID09IFwibnVtYmVyXCIgfHwgdCA9PSBcInN5bWJvbFwiIHx8IHQgPT0gXCJib29sZWFuXCIgPyBpICE9PSBcIl9fcHJvdG9fX1wiIDogaSA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGppKGksIHQpIHtcbiAgdmFyIGUgPSBpLl9fZGF0YV9fO1xuICByZXR1cm4gTnAodCkgPyBlW3R5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBcInN0cmluZ1wiIDogXCJoYXNoXCJdIDogZS5tYXA7XG59XG5mdW5jdGlvbiBVcChpKSB7XG4gIHZhciB0ID0gamkodGhpcywgaSkuZGVsZXRlKGkpO1xuICByZXR1cm4gdGhpcy5zaXplIC09IHQgPyAxIDogMCwgdDtcbn1cbmZ1bmN0aW9uICRwKGkpIHtcbiAgcmV0dXJuIGppKHRoaXMsIGkpLmdldChpKTtcbn1cbmZ1bmN0aW9uIHFwKGkpIHtcbiAgcmV0dXJuIGppKHRoaXMsIGkpLmhhcyhpKTtcbn1cbmZ1bmN0aW9uIEtwKGksIHQpIHtcbiAgdmFyIGUgPSBqaSh0aGlzLCBpKSwgcyA9IGUuc2l6ZTtcbiAgcmV0dXJuIGUuc2V0KGksIHQpLCB0aGlzLnNpemUgKz0gZS5zaXplID09IHMgPyAwIDogMSwgdGhpcztcbn1cbmZ1bmN0aW9uIHBlKGkpIHtcbiAgdmFyIHQgPSAtMSwgZSA9IGkgPT0gbnVsbCA/IDAgOiBpLmxlbmd0aDtcbiAgZm9yICh0aGlzLmNsZWFyKCk7ICsrdCA8IGU7ICkge1xuICAgIHZhciBzID0gaVt0XTtcbiAgICB0aGlzLnNldChzWzBdLCBzWzFdKTtcbiAgfVxufVxucGUucHJvdG90eXBlLmNsZWFyID0gR3A7XG5wZS5wcm90b3R5cGUuZGVsZXRlID0gVXA7XG5wZS5wcm90b3R5cGUuZ2V0ID0gJHA7XG5wZS5wcm90b3R5cGUuaGFzID0gcXA7XG5wZS5wcm90b3R5cGUuc2V0ID0gS3A7XG52YXIgSnAgPSBcIkV4cGVjdGVkIGEgZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIG9vKGksIHQpIHtcbiAgaWYgKHR5cGVvZiBpICE9IFwiZnVuY3Rpb25cIiB8fCB0ICE9IG51bGwgJiYgdHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoSnApO1xuICB2YXIgZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzID0gYXJndW1lbnRzLCByID0gdCA/IHQuYXBwbHkodGhpcywgcykgOiBzWzBdLCBuID0gZS5jYWNoZTtcbiAgICBpZiAobi5oYXMocikpXG4gICAgICByZXR1cm4gbi5nZXQocik7XG4gICAgdmFyIG8gPSBpLmFwcGx5KHRoaXMsIHMpO1xuICAgIHJldHVybiBlLmNhY2hlID0gbi5zZXQociwgbykgfHwgbiwgbztcbiAgfTtcbiAgcmV0dXJuIGUuY2FjaGUgPSBuZXcgKG9vLkNhY2hlIHx8IHBlKSgpLCBlO1xufVxub28uQ2FjaGUgPSBwZTtcbnZhciBacCA9IDUwMDtcbmZ1bmN0aW9uIFFwKGkpIHtcbiAgdmFyIHQgPSBvbyhpLCBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIGUuc2l6ZSA9PT0gWnAgJiYgZS5jbGVhcigpLCBzO1xuICB9KSwgZSA9IHQuY2FjaGU7XG4gIHJldHVybiB0O1xufVxudmFyIHRtID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nLCBlbSA9IC9cXFxcKFxcXFwpPy9nLCBzbSA9IFFwKGZ1bmN0aW9uKGkpIHtcbiAgdmFyIHQgPSBbXTtcbiAgcmV0dXJuIGkuY2hhckNvZGVBdCgwKSA9PT0gNDYgJiYgdC5wdXNoKFwiXCIpLCBpLnJlcGxhY2UodG0sIGZ1bmN0aW9uKGUsIHMsIHIsIG4pIHtcbiAgICB0LnB1c2gociA/IG4ucmVwbGFjZShlbSwgXCIkMVwiKSA6IHMgfHwgZSk7XG4gIH0pLCB0O1xufSk7XG5mdW5jdGlvbiBybShpKSB7XG4gIHJldHVybiBpID09IG51bGwgPyBcIlwiIDogYmwoaSk7XG59XG5mdW5jdGlvbiBFaShpLCB0KSB7XG4gIHJldHVybiBadChpKSA/IGkgOiBPcChpLCB0KSA/IFtpXSA6IHNtKHJtKGkpKTtcbn1cbmZ1bmN0aW9uIGFvKGkpIHtcbiAgaWYgKHR5cGVvZiBpID09IFwic3RyaW5nXCIgfHwgSWkoaSkpXG4gICAgcmV0dXJuIGk7XG4gIHZhciB0ID0gaSArIFwiXCI7XG4gIHJldHVybiB0ID09IFwiMFwiICYmIDEgLyBpID09IC0xIC8gMCA/IFwiLTBcIiA6IHQ7XG59XG5mdW5jdGlvbiBpbShpLCB0KSB7XG4gIHQgPSBFaSh0LCBpKTtcbiAgZm9yICh2YXIgZSA9IDAsIHMgPSB0Lmxlbmd0aDsgaSAhPSBudWxsICYmIGUgPCBzOyApXG4gICAgaSA9IGlbYW8odFtlKytdKV07XG4gIHJldHVybiBlICYmIGUgPT0gcyA/IGkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBNbChpLCB0KSB7XG4gIGZvciAodmFyIGUgPSAtMSwgcyA9IHQubGVuZ3RoLCByID0gaS5sZW5ndGg7ICsrZSA8IHM7IClcbiAgICBpW3IgKyBlXSA9IHRbZV07XG4gIHJldHVybiBpO1xufVxudmFyIGxhID0gTXQgPyBNdC5pc0NvbmNhdFNwcmVhZGFibGUgOiB2b2lkIDA7XG5mdW5jdGlvbiBubShpKSB7XG4gIHJldHVybiBadChpKSB8fCBpbyhpKSB8fCAhIShsYSAmJiBpICYmIGlbbGFdKTtcbn1cbmZ1bmN0aW9uIG9tKGksIHQsIGUsIHMsIHIpIHtcbiAgdmFyIG4gPSAtMSwgbyA9IGkubGVuZ3RoO1xuICBmb3IgKGUgfHwgKGUgPSBubSksIHIgfHwgKHIgPSBbXSk7ICsrbiA8IG87ICkge1xuICAgIHZhciBhID0gaVtuXTtcbiAgICBlKGEpID8gTWwociwgYSkgOiByW3IubGVuZ3RoXSA9IGE7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBjbyhpKSB7XG4gIHZhciB0ID0gaSA9PSBudWxsID8gMCA6IGkubGVuZ3RoO1xuICByZXR1cm4gdCA/IG9tKGkpIDogW107XG59XG5mdW5jdGlvbiBhbShpKSB7XG4gIHJldHVybiBPZyhQZyhpLCB2b2lkIDAsIGNvKSwgaSArIFwiXCIpO1xufVxudmFyIGNtID0ga2woT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuZnVuY3Rpb24gbG0oKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgZ2UoKSwgdGhpcy5zaXplID0gMDtcbn1cbmZ1bmN0aW9uIGhtKGkpIHtcbiAgdmFyIHQgPSB0aGlzLl9fZGF0YV9fLCBlID0gdC5kZWxldGUoaSk7XG4gIHJldHVybiB0aGlzLnNpemUgPSB0LnNpemUsIGU7XG59XG5mdW5jdGlvbiB1bShpKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChpKTtcbn1cbmZ1bmN0aW9uIGRtKGkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGkpO1xufVxudmFyIGZtID0gMjAwO1xuZnVuY3Rpb24gZ20oaSwgdCkge1xuICB2YXIgZSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChlIGluc3RhbmNlb2YgZ2UpIHtcbiAgICB2YXIgcyA9IGUuX19kYXRhX187XG4gICAgaWYgKCFuciB8fCBzLmxlbmd0aCA8IGZtIC0gMSlcbiAgICAgIHJldHVybiBzLnB1c2goW2ksIHRdKSwgdGhpcy5zaXplID0gKytlLnNpemUsIHRoaXM7XG4gICAgZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgcGUocyk7XG4gIH1cbiAgcmV0dXJuIGUuc2V0KGksIHQpLCB0aGlzLnNpemUgPSBlLnNpemUsIHRoaXM7XG59XG5mdW5jdGlvbiBsZShpKSB7XG4gIHZhciB0ID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBnZShpKTtcbiAgdGhpcy5zaXplID0gdC5zaXplO1xufVxubGUucHJvdG90eXBlLmNsZWFyID0gbG07XG5sZS5wcm90b3R5cGUuZGVsZXRlID0gaG07XG5sZS5wcm90b3R5cGUuZ2V0ID0gdW07XG5sZS5wcm90b3R5cGUuaGFzID0gZG07XG5sZS5wcm90b3R5cGUuc2V0ID0gZ207XG52YXIgSWwgPSB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cywgaGEgPSBJbCAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlLCBwbSA9IGhhICYmIGhhLmV4cG9ydHMgPT09IElsLCB1YSA9IHBtID8gWHQuQnVmZmVyIDogdm9pZCAwO1xudWEgJiYgdWEuYWxsb2NVbnNhZmU7XG5mdW5jdGlvbiBtbShpLCB0KSB7XG4gIHJldHVybiBpLnNsaWNlKCk7XG59XG5mdW5jdGlvbiB2bShpLCB0KSB7XG4gIGZvciAodmFyIGUgPSAtMSwgcyA9IGkgPT0gbnVsbCA/IDAgOiBpLmxlbmd0aCwgciA9IDAsIG4gPSBbXTsgKytlIDwgczsgKSB7XG4gICAgdmFyIG8gPSBpW2VdO1xuICAgIHQobywgZSwgaSkgJiYgKG5bcisrXSA9IG8pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24geW0oKSB7XG4gIHJldHVybiBbXTtcbn1cbnZhciBibSA9IE9iamVjdC5wcm90b3R5cGUsIF9tID0gYm0ucHJvcGVydHlJc0VudW1lcmFibGUsIGRhID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgU20gPSBkYSA/IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIGkgPT0gbnVsbCA/IFtdIDogKGkgPSBPYmplY3QoaSksIHZtKGRhKGkpLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIF9tLmNhbGwoaSwgdCk7XG4gIH0pKTtcbn0gOiB5bTtcbmZ1bmN0aW9uIFRtKGksIHQsIGUpIHtcbiAgdmFyIHMgPSB0KGkpO1xuICByZXR1cm4gWnQoaSkgPyBzIDogTWwocywgZShpKSk7XG59XG5mdW5jdGlvbiBDbihpKSB7XG4gIHJldHVybiBUbShpLCB4cCwgU20pO1xufVxudmFyIE9uID0gJGUoWHQsIFwiRGF0YVZpZXdcIiksIGtuID0gJGUoWHQsIFwiUHJvbWlzZVwiKSwgTW4gPSAkZShYdCwgXCJTZXRcIiksIGZhID0gXCJbb2JqZWN0IE1hcF1cIiwgeG0gPSBcIltvYmplY3QgT2JqZWN0XVwiLCBnYSA9IFwiW29iamVjdCBQcm9taXNlXVwiLCBwYSA9IFwiW29iamVjdCBTZXRdXCIsIG1hID0gXCJbb2JqZWN0IFdlYWtNYXBdXCIsIHZhID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCB3bSA9IFVlKE9uKSwgQ20gPSBVZShuciksIE9tID0gVWUoa24pLCBrbSA9IFVlKE1uKSwgTW0gPSBVZSh3biksIFB0ID0gRXM7XG4oT24gJiYgUHQobmV3IE9uKG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IHZhIHx8IG5yICYmIFB0KG5ldyBucigpKSAhPSBmYSB8fCBrbiAmJiBQdChrbi5yZXNvbHZlKCkpICE9IGdhIHx8IE1uICYmIFB0KG5ldyBNbigpKSAhPSBwYSB8fCB3biAmJiBQdChuZXcgd24oKSkgIT0gbWEpICYmIChQdCA9IGZ1bmN0aW9uKGkpIHtcbiAgdmFyIHQgPSBFcyhpKSwgZSA9IHQgPT0geG0gPyBpLmNvbnN0cnVjdG9yIDogdm9pZCAwLCBzID0gZSA/IFVlKGUpIDogXCJcIjtcbiAgaWYgKHMpXG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIHdtOlxuICAgICAgICByZXR1cm4gdmE7XG4gICAgICBjYXNlIENtOlxuICAgICAgICByZXR1cm4gZmE7XG4gICAgICBjYXNlIE9tOlxuICAgICAgICByZXR1cm4gZ2E7XG4gICAgICBjYXNlIGttOlxuICAgICAgICByZXR1cm4gcGE7XG4gICAgICBjYXNlIE1tOlxuICAgICAgICByZXR1cm4gbWE7XG4gICAgfVxuICByZXR1cm4gdDtcbn0pO1xudmFyIEltID0gT2JqZWN0LnByb3RvdHlwZSwgRG0gPSBJbS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGptKGkpIHtcbiAgdmFyIHQgPSBpLmxlbmd0aCwgZSA9IG5ldyBpLmNvbnN0cnVjdG9yKHQpO1xuICByZXR1cm4gdCAmJiB0eXBlb2YgaVswXSA9PSBcInN0cmluZ1wiICYmIERtLmNhbGwoaSwgXCJpbmRleFwiKSAmJiAoZS5pbmRleCA9IGkuaW5kZXgsIGUuaW5wdXQgPSBpLmlucHV0KSwgZTtcbn1cbnZhciB1aSA9IFh0LlVpbnQ4QXJyYXk7XG5mdW5jdGlvbiBsbyhpKSB7XG4gIHZhciB0ID0gbmV3IGkuY29uc3RydWN0b3IoaS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIG5ldyB1aSh0KS5zZXQobmV3IHVpKGkpKSwgdDtcbn1cbmZ1bmN0aW9uIEVtKGksIHQpIHtcbiAgdmFyIGUgPSBsbyhpLmJ1ZmZlcik7XG4gIHJldHVybiBuZXcgaS5jb25zdHJ1Y3RvcihlLCBpLmJ5dGVPZmZzZXQsIGkuYnl0ZUxlbmd0aCk7XG59XG52YXIgUG0gPSAvXFx3KiQvO1xuZnVuY3Rpb24gQW0oaSkge1xuICB2YXIgdCA9IG5ldyBpLmNvbnN0cnVjdG9yKGkuc291cmNlLCBQbS5leGVjKGkpKTtcbiAgcmV0dXJuIHQubGFzdEluZGV4ID0gaS5sYXN0SW5kZXgsIHQ7XG59XG52YXIgeWEgPSBNdCA/IE10LnByb3RvdHlwZSA6IHZvaWQgMCwgYmEgPSB5YSA/IHlhLnZhbHVlT2YgOiB2b2lkIDA7XG5mdW5jdGlvbiBGbShpKSB7XG4gIHJldHVybiBiYSA/IE9iamVjdChiYS5jYWxsKGkpKSA6IHt9O1xufVxuZnVuY3Rpb24gUm0oaSwgdCkge1xuICB2YXIgZSA9IGxvKGkuYnVmZmVyKTtcbiAgcmV0dXJuIG5ldyBpLmNvbnN0cnVjdG9yKGUsIGkuYnl0ZU9mZnNldCwgaS5sZW5ndGgpO1xufVxudmFyIExtID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIEJtID0gXCJbb2JqZWN0IERhdGVdXCIsIFdtID0gXCJbb2JqZWN0IE1hcF1cIiwgWG0gPSBcIltvYmplY3QgTnVtYmVyXVwiLCB6bSA9IFwiW29iamVjdCBSZWdFeHBdXCIsIEhtID0gXCJbb2JqZWN0IFNldF1cIiwgWW0gPSBcIltvYmplY3QgU3RyaW5nXVwiLCBWbSA9IFwiW29iamVjdCBTeW1ib2xdXCIsIEdtID0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiLCBObSA9IFwiW29iamVjdCBEYXRhVmlld11cIiwgVW0gPSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiLCAkbSA9IFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCIsIHFtID0gXCJbb2JqZWN0IEludDhBcnJheV1cIiwgS20gPSBcIltvYmplY3QgSW50MTZBcnJheV1cIiwgSm0gPSBcIltvYmplY3QgSW50MzJBcnJheV1cIiwgWm0gPSBcIltvYmplY3QgVWludDhBcnJheV1cIiwgUW0gPSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsIHR2ID0gXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiLCBldiA9IFwiW29iamVjdCBVaW50MzJBcnJheV1cIjtcbmZ1bmN0aW9uIHN2KGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIEdtOlxuICAgICAgcmV0dXJuIGxvKGkpO1xuICAgIGNhc2UgTG06XG4gICAgY2FzZSBCbTpcbiAgICAgIHJldHVybiBuZXcgcygraSk7XG4gICAgY2FzZSBObTpcbiAgICAgIHJldHVybiBFbShpKTtcbiAgICBjYXNlIFVtOlxuICAgIGNhc2UgJG06XG4gICAgY2FzZSBxbTpcbiAgICBjYXNlIEttOlxuICAgIGNhc2UgSm06XG4gICAgY2FzZSBabTpcbiAgICBjYXNlIFFtOlxuICAgIGNhc2UgdHY6XG4gICAgY2FzZSBldjpcbiAgICAgIHJldHVybiBSbShpKTtcbiAgICBjYXNlIFdtOlxuICAgICAgcmV0dXJuIG5ldyBzKCk7XG4gICAgY2FzZSBYbTpcbiAgICBjYXNlIFltOlxuICAgICAgcmV0dXJuIG5ldyBzKGkpO1xuICAgIGNhc2Ugem06XG4gICAgICByZXR1cm4gQW0oaSk7XG4gICAgY2FzZSBIbTpcbiAgICAgIHJldHVybiBuZXcgcygpO1xuICAgIGNhc2UgVm06XG4gICAgICByZXR1cm4gRm0oaSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJ2KGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpLmNvbnN0cnVjdG9yID09IFwiZnVuY3Rpb25cIiAmJiAhVGwoaSkgPyB5ZyhjbShpKSkgOiB7fTtcbn1cbnZhciBpdiA9IFwiW29iamVjdCBNYXBdXCI7XG5mdW5jdGlvbiBudihpKSB7XG4gIHJldHVybiBrZShpKSAmJiBQdChpKSA9PSBpdjtcbn1cbnZhciBfYSA9IFRzICYmIFRzLmlzTWFwLCBvdiA9IF9hID8gbm8oX2EpIDogbnYsIGF2ID0gXCJbb2JqZWN0IFNldF1cIjtcbmZ1bmN0aW9uIGN2KGkpIHtcbiAgcmV0dXJuIGtlKGkpICYmIFB0KGkpID09IGF2O1xufVxudmFyIFNhID0gVHMgJiYgVHMuaXNTZXQsIGx2ID0gU2EgPyBubyhTYSkgOiBjdiwgRGwgPSBcIltvYmplY3QgQXJndW1lbnRzXVwiLCBodiA9IFwiW29iamVjdCBBcnJheV1cIiwgdXYgPSBcIltvYmplY3QgQm9vbGVhbl1cIiwgZHYgPSBcIltvYmplY3QgRGF0ZV1cIiwgZnYgPSBcIltvYmplY3QgRXJyb3JdXCIsIGpsID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLCBndiA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiwgcHYgPSBcIltvYmplY3QgTWFwXVwiLCBtdiA9IFwiW29iamVjdCBOdW1iZXJdXCIsIEVsID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgdnYgPSBcIltvYmplY3QgUmVnRXhwXVwiLCB5diA9IFwiW29iamVjdCBTZXRdXCIsIGJ2ID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgX3YgPSBcIltvYmplY3QgU3ltYm9sXVwiLCBTdiA9IFwiW29iamVjdCBXZWFrTWFwXVwiLCBUdiA9IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiwgeHYgPSBcIltvYmplY3QgRGF0YVZpZXddXCIsIHd2ID0gXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIiwgQ3YgPSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiLCBPdiA9IFwiW29iamVjdCBJbnQ4QXJyYXldXCIsIGt2ID0gXCJbb2JqZWN0IEludDE2QXJyYXldXCIsIE12ID0gXCJbb2JqZWN0IEludDMyQXJyYXldXCIsIEl2ID0gXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIsIER2ID0gXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiLCBqdiA9IFwiW29iamVjdCBVaW50MTZBcnJheV1cIiwgRXYgPSBcIltvYmplY3QgVWludDMyQXJyYXldXCIsIHogPSB7fTtcbnpbRGxdID0geltodl0gPSB6W1R2XSA9IHpbeHZdID0gelt1dl0gPSB6W2R2XSA9IHpbd3ZdID0geltDdl0gPSB6W092XSA9IHpba3ZdID0geltNdl0gPSB6W3B2XSA9IHpbbXZdID0geltFbF0gPSB6W3Z2XSA9IHpbeXZdID0geltidl0gPSB6W192XSA9IHpbSXZdID0geltEdl0gPSB6W2p2XSA9IHpbRXZdID0gITA7XG56W2Z2XSA9IHpbamxdID0geltTdl0gPSAhMTtcbmZ1bmN0aW9uIE5yKGksIHQsIGUsIHMsIHIsIG4pIHtcbiAgdmFyIG87XG4gIGlmIChvICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIG87XG4gIGlmICghUXQoaSkpXG4gICAgcmV0dXJuIGk7XG4gIHZhciBhID0gWnQoaSk7XG4gIGlmIChhKVxuICAgIG8gPSBqbShpKTtcbiAgZWxzZSB7XG4gICAgdmFyIGMgPSBQdChpKSwgbCA9IGMgPT0gamwgfHwgYyA9PSBndjtcbiAgICBpZiAoaGkoaSkpXG4gICAgICByZXR1cm4gbW0oaSk7XG4gICAgaWYgKGMgPT0gRWwgfHwgYyA9PSBEbCB8fCBsICYmICFyKVxuICAgICAgbyA9IGwgPyB7fSA6IHJ2KGkpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKCF6W2NdKVxuICAgICAgICByZXR1cm4gciA/IGkgOiB7fTtcbiAgICAgIG8gPSBzdihpLCBjKTtcbiAgICB9XG4gIH1cbiAgbiB8fCAobiA9IG5ldyBsZSgpKTtcbiAgdmFyIGggPSBuLmdldChpKTtcbiAgaWYgKGgpXG4gICAgcmV0dXJuIGg7XG4gIG4uc2V0KGksIG8pLCBsdihpKSA/IGkuZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgby5hZGQoTnIoZiwgdCwgZSwgZiwgaSwgbikpO1xuICB9KSA6IG92KGkpICYmIGkuZm9yRWFjaChmdW5jdGlvbihmLCBnKSB7XG4gICAgby5zZXQoZywgTnIoZiwgdCwgZSwgZywgaSwgbikpO1xuICB9KTtcbiAgdmFyIHUgPSBDbiwgZCA9IGEgPyB2b2lkIDAgOiB1KGkpO1xuICByZXR1cm4ga2coZCB8fCBpLCBmdW5jdGlvbihmLCBnKSB7XG4gICAgZCAmJiAoZyA9IGYsIGYgPSBpW2ddKSwgU2wobywgZywgTnIoZiwgdCwgZSwgZywgaSwgbikpO1xuICB9KSwgbztcbn1cbnZhciBQdiA9IDEsIEF2ID0gNDtcbmZ1bmN0aW9uIFV0KGkpIHtcbiAgcmV0dXJuIE5yKGksIFB2IHwgQXYpO1xufVxudmFyIEZ2ID0gXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCI7XG5mdW5jdGlvbiBSdihpKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLnNldChpLCBGdiksIHRoaXM7XG59XG5mdW5jdGlvbiBMdihpKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhpKTtcbn1cbmZ1bmN0aW9uIGRpKGkpIHtcbiAgdmFyIHQgPSAtMSwgZSA9IGkgPT0gbnVsbCA/IDAgOiBpLmxlbmd0aDtcbiAgZm9yICh0aGlzLl9fZGF0YV9fID0gbmV3IHBlKCk7ICsrdCA8IGU7IClcbiAgICB0aGlzLmFkZChpW3RdKTtcbn1cbmRpLnByb3RvdHlwZS5hZGQgPSBkaS5wcm90b3R5cGUucHVzaCA9IFJ2O1xuZGkucHJvdG90eXBlLmhhcyA9IEx2O1xuZnVuY3Rpb24gQnYoaSwgdCkge1xuICBmb3IgKHZhciBlID0gLTEsIHMgPSBpID09IG51bGwgPyAwIDogaS5sZW5ndGg7ICsrZSA8IHM7IClcbiAgICBpZiAodChpW2VdLCBlLCBpKSlcbiAgICAgIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gV3YoaSwgdCkge1xuICByZXR1cm4gaS5oYXModCk7XG59XG52YXIgWHYgPSAxLCB6diA9IDI7XG5mdW5jdGlvbiBQbChpLCB0LCBlLCBzLCByLCBuKSB7XG4gIHZhciBvID0gZSAmIFh2LCBhID0gaS5sZW5ndGgsIGMgPSB0Lmxlbmd0aDtcbiAgaWYgKGEgIT0gYyAmJiAhKG8gJiYgYyA+IGEpKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIGwgPSBuLmdldChpKSwgaCA9IG4uZ2V0KHQpO1xuICBpZiAobCAmJiBoKVxuICAgIHJldHVybiBsID09IHQgJiYgaCA9PSBpO1xuICB2YXIgdSA9IC0xLCBkID0gITAsIGYgPSBlICYgenYgPyBuZXcgZGkoKSA6IHZvaWQgMDtcbiAgZm9yIChuLnNldChpLCB0KSwgbi5zZXQodCwgaSk7ICsrdSA8IGE7ICkge1xuICAgIHZhciBnID0gaVt1XSwgcCA9IHRbdV07XG4gICAgaWYgKHMpXG4gICAgICB2YXIgbSA9IG8gPyBzKHAsIGcsIHUsIHQsIGksIG4pIDogcyhnLCBwLCB1LCBpLCB0LCBuKTtcbiAgICBpZiAobSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAobSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBkID0gITE7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGYpIHtcbiAgICAgIGlmICghQnYodCwgZnVuY3Rpb24oYiwgUykge1xuICAgICAgICBpZiAoIVd2KGYsIFMpICYmIChnID09PSBiIHx8IHIoZywgYiwgZSwgcywgbikpKVxuICAgICAgICAgIHJldHVybiBmLnB1c2goUyk7XG4gICAgICB9KSkge1xuICAgICAgICBkID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShnID09PSBwIHx8IHIoZywgcCwgZSwgcywgbikpKSB7XG4gICAgICBkID0gITE7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG4uZGVsZXRlKGkpLCBuLmRlbGV0ZSh0KSwgZDtcbn1cbmZ1bmN0aW9uIEh2KGkpIHtcbiAgdmFyIHQgPSAtMSwgZSA9IEFycmF5KGkuc2l6ZSk7XG4gIHJldHVybiBpLmZvckVhY2goZnVuY3Rpb24ocywgcikge1xuICAgIGVbKyt0XSA9IFtyLCBzXTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBZdihpKSB7XG4gIHZhciB0ID0gLTEsIGUgPSBBcnJheShpLnNpemUpO1xuICByZXR1cm4gaS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICBlWysrdF0gPSBzO1xuICB9KSwgZTtcbn1cbnZhciBWdiA9IDEsIEd2ID0gMiwgTnYgPSBcIltvYmplY3QgQm9vbGVhbl1cIiwgVXYgPSBcIltvYmplY3QgRGF0ZV1cIiwgJHYgPSBcIltvYmplY3QgRXJyb3JdXCIsIHF2ID0gXCJbb2JqZWN0IE1hcF1cIiwgS3YgPSBcIltvYmplY3QgTnVtYmVyXVwiLCBKdiA9IFwiW29iamVjdCBSZWdFeHBdXCIsIFp2ID0gXCJbb2JqZWN0IFNldF1cIiwgUXYgPSBcIltvYmplY3QgU3RyaW5nXVwiLCB0eSA9IFwiW29iamVjdCBTeW1ib2xdXCIsIGV5ID0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiLCBzeSA9IFwiW29iamVjdCBEYXRhVmlld11cIiwgVGEgPSBNdCA/IE10LnByb3RvdHlwZSA6IHZvaWQgMCwgWmkgPSBUYSA/IFRhLnZhbHVlT2YgOiB2b2lkIDA7XG5mdW5jdGlvbiByeShpLCB0LCBlLCBzLCByLCBuLCBvKSB7XG4gIHN3aXRjaCAoZSkge1xuICAgIGNhc2Ugc3k6XG4gICAgICBpZiAoaS5ieXRlTGVuZ3RoICE9IHQuYnl0ZUxlbmd0aCB8fCBpLmJ5dGVPZmZzZXQgIT0gdC5ieXRlT2Zmc2V0KVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpID0gaS5idWZmZXIsIHQgPSB0LmJ1ZmZlcjtcbiAgICBjYXNlIGV5OlxuICAgICAgcmV0dXJuICEoaS5ieXRlTGVuZ3RoICE9IHQuYnl0ZUxlbmd0aCB8fCAhbihuZXcgdWkoaSksIG5ldyB1aSh0KSkpO1xuICAgIGNhc2UgTnY6XG4gICAgY2FzZSBVdjpcbiAgICBjYXNlIEt2OlxuICAgICAgcmV0dXJuIHNvKCtpLCArdCk7XG4gICAgY2FzZSAkdjpcbiAgICAgIHJldHVybiBpLm5hbWUgPT0gdC5uYW1lICYmIGkubWVzc2FnZSA9PSB0Lm1lc3NhZ2U7XG4gICAgY2FzZSBKdjpcbiAgICBjYXNlIFF2OlxuICAgICAgcmV0dXJuIGkgPT0gdCArIFwiXCI7XG4gICAgY2FzZSBxdjpcbiAgICAgIHZhciBhID0gSHY7XG4gICAgY2FzZSBadjpcbiAgICAgIHZhciBjID0gcyAmIFZ2O1xuICAgICAgaWYgKGEgfHwgKGEgPSBZdiksIGkuc2l6ZSAhPSB0LnNpemUgJiYgIWMpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIHZhciBsID0gby5nZXQoaSk7XG4gICAgICBpZiAobClcbiAgICAgICAgcmV0dXJuIGwgPT0gdDtcbiAgICAgIHMgfD0gR3YsIG8uc2V0KGksIHQpO1xuICAgICAgdmFyIGggPSBQbChhKGkpLCBhKHQpLCBzLCByLCBuLCBvKTtcbiAgICAgIHJldHVybiBvLmRlbGV0ZShpKSwgaDtcbiAgICBjYXNlIHR5OlxuICAgICAgaWYgKFppKVxuICAgICAgICByZXR1cm4gWmkuY2FsbChpKSA9PSBaaS5jYWxsKHQpO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbnZhciBpeSA9IDEsIG55ID0gT2JqZWN0LnByb3RvdHlwZSwgb3kgPSBueS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGF5KGksIHQsIGUsIHMsIHIsIG4pIHtcbiAgdmFyIG8gPSBlICYgaXksIGEgPSBDbihpKSwgYyA9IGEubGVuZ3RoLCBsID0gQ24odCksIGggPSBsLmxlbmd0aDtcbiAgaWYgKGMgIT0gaCAmJiAhbylcbiAgICByZXR1cm4gITE7XG4gIGZvciAodmFyIHUgPSBjOyB1LS07ICkge1xuICAgIHZhciBkID0gYVt1XTtcbiAgICBpZiAoIShvID8gZCBpbiB0IDogb3kuY2FsbCh0LCBkKSkpXG4gICAgICByZXR1cm4gITE7XG4gIH1cbiAgdmFyIGYgPSBuLmdldChpKSwgZyA9IG4uZ2V0KHQpO1xuICBpZiAoZiAmJiBnKVxuICAgIHJldHVybiBmID09IHQgJiYgZyA9PSBpO1xuICB2YXIgcCA9ICEwO1xuICBuLnNldChpLCB0KSwgbi5zZXQodCwgaSk7XG4gIGZvciAodmFyIG0gPSBvOyArK3UgPCBjOyApIHtcbiAgICBkID0gYVt1XTtcbiAgICB2YXIgYiA9IGlbZF0sIFMgPSB0W2RdO1xuICAgIGlmIChzKVxuICAgICAgdmFyIHcgPSBvID8gcyhTLCBiLCBkLCB0LCBpLCBuKSA6IHMoYiwgUywgZCwgaSwgdCwgbik7XG4gICAgaWYgKCEodyA9PT0gdm9pZCAwID8gYiA9PT0gUyB8fCByKGIsIFMsIGUsIHMsIG4pIDogdykpIHtcbiAgICAgIHAgPSAhMTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtIHx8IChtID0gZCA9PSBcImNvbnN0cnVjdG9yXCIpO1xuICB9XG4gIGlmIChwICYmICFtKSB7XG4gICAgdmFyIGsgPSBpLmNvbnN0cnVjdG9yLCBPID0gdC5jb25zdHJ1Y3RvcjtcbiAgICBrICE9IE8gJiYgXCJjb25zdHJ1Y3RvclwiIGluIGkgJiYgXCJjb25zdHJ1Y3RvclwiIGluIHQgJiYgISh0eXBlb2YgayA9PSBcImZ1bmN0aW9uXCIgJiYgayBpbnN0YW5jZW9mIGsgJiYgdHlwZW9mIE8gPT0gXCJmdW5jdGlvblwiICYmIE8gaW5zdGFuY2VvZiBPKSAmJiAocCA9ICExKTtcbiAgfVxuICByZXR1cm4gbi5kZWxldGUoaSksIG4uZGVsZXRlKHQpLCBwO1xufVxudmFyIGN5ID0gMSwgeGEgPSBcIltvYmplY3QgQXJndW1lbnRzXVwiLCB3YSA9IFwiW29iamVjdCBBcnJheV1cIiwgenIgPSBcIltvYmplY3QgT2JqZWN0XVwiLCBseSA9IE9iamVjdC5wcm90b3R5cGUsIENhID0gbHkuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoeShpLCB0LCBlLCBzLCByLCBuKSB7XG4gIHZhciBvID0gWnQoaSksIGEgPSBadCh0KSwgYyA9IG8gPyB3YSA6IFB0KGkpLCBsID0gYSA/IHdhIDogUHQodCk7XG4gIGMgPSBjID09IHhhID8genIgOiBjLCBsID0gbCA9PSB4YSA/IHpyIDogbDtcbiAgdmFyIGggPSBjID09IHpyLCB1ID0gbCA9PSB6ciwgZCA9IGMgPT0gbDtcbiAgaWYgKGQgJiYgaGkoaSkpIHtcbiAgICBpZiAoIWhpKHQpKVxuICAgICAgcmV0dXJuICExO1xuICAgIG8gPSAhMCwgaCA9ICExO1xuICB9XG4gIGlmIChkICYmICFoKVxuICAgIHJldHVybiBuIHx8IChuID0gbmV3IGxlKCkpLCBvIHx8IE9sKGkpID8gUGwoaSwgdCwgZSwgcywgciwgbikgOiByeShpLCB0LCBjLCBlLCBzLCByLCBuKTtcbiAgaWYgKCEoZSAmIGN5KSkge1xuICAgIHZhciBmID0gaCAmJiBDYS5jYWxsKGksIFwiX193cmFwcGVkX19cIiksIGcgPSB1ICYmIENhLmNhbGwodCwgXCJfX3dyYXBwZWRfX1wiKTtcbiAgICBpZiAoZiB8fCBnKSB7XG4gICAgICB2YXIgcCA9IGYgPyBpLnZhbHVlKCkgOiBpLCBtID0gZyA/IHQudmFsdWUoKSA6IHQ7XG4gICAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBsZSgpKSwgcihwLCBtLCBlLCBzLCBuKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGQgPyAobiB8fCAobiA9IG5ldyBsZSgpKSwgYXkoaSwgdCwgZSwgcywgciwgbikpIDogITE7XG59XG5mdW5jdGlvbiBBbChpLCB0LCBlLCBzLCByKSB7XG4gIHJldHVybiBpID09PSB0ID8gITAgOiBpID09IG51bGwgfHwgdCA9PSBudWxsIHx8ICFrZShpKSAmJiAha2UodCkgPyBpICE9PSBpICYmIHQgIT09IHQgOiBoeShpLCB0LCBlLCBzLCBBbCwgcik7XG59XG5mdW5jdGlvbiB1eShpLCB0KSB7XG4gIHJldHVybiBpICE9IG51bGwgJiYgdCBpbiBPYmplY3QoaSk7XG59XG5mdW5jdGlvbiBkeShpLCB0LCBlKSB7XG4gIHQgPSBFaSh0LCBpKTtcbiAgZm9yICh2YXIgcyA9IC0xLCByID0gdC5sZW5ndGgsIG4gPSAhMTsgKytzIDwgcjsgKSB7XG4gICAgdmFyIG8gPSBhbyh0W3NdKTtcbiAgICBpZiAoIShuID0gaSAhPSBudWxsICYmIGUoaSwgbykpKVxuICAgICAgYnJlYWs7XG4gICAgaSA9IGlbb107XG4gIH1cbiAgcmV0dXJuIG4gfHwgKytzICE9IHIgPyBuIDogKHIgPSBpID09IG51bGwgPyAwIDogaS5sZW5ndGgsICEhciAmJiBybyhyKSAmJiBlbyhvLCByKSAmJiAoWnQoaSkgfHwgaW8oaSkpKTtcbn1cbmZ1bmN0aW9uIGZ5KGksIHQpIHtcbiAgcmV0dXJuIGkgIT0gbnVsbCAmJiBkeShpLCB0LCB1eSk7XG59XG52YXIgUWkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFh0LkRhdGUubm93KCk7XG59LCBneSA9IFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiLCBweSA9IE1hdGgubWF4LCBteSA9IE1hdGgubWluO1xuZnVuY3Rpb24gdnkoaSwgdCwgZSkge1xuICB2YXIgcywgciwgbiwgbywgYSwgYywgbCA9IDAsIGggPSAhMSwgdSA9ICExLCBkID0gITA7XG4gIGlmICh0eXBlb2YgaSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihneSk7XG4gIHQgPSBlYSh0KSB8fCAwLCBRdChlKSAmJiAoaCA9ICEhZS5sZWFkaW5nLCB1ID0gXCJtYXhXYWl0XCIgaW4gZSwgbiA9IHUgPyBweShlYShlLm1heFdhaXQpIHx8IDAsIHQpIDogbiwgZCA9IFwidHJhaWxpbmdcIiBpbiBlID8gISFlLnRyYWlsaW5nIDogZCk7XG4gIGZ1bmN0aW9uIGYoeCkge1xuICAgIHZhciBJID0gcywgTSA9IHI7XG4gICAgcmV0dXJuIHMgPSByID0gdm9pZCAwLCBsID0geCwgbyA9IGkuYXBwbHkoTSwgSSksIG87XG4gIH1cbiAgZnVuY3Rpb24gZyh4KSB7XG4gICAgcmV0dXJuIGwgPSB4LCBhID0gc2V0VGltZW91dChiLCB0KSwgaCA/IGYoeCkgOiBvO1xuICB9XG4gIGZ1bmN0aW9uIHAoeCkge1xuICAgIHZhciBJID0geCAtIGMsIE0gPSB4IC0gbCwgRSA9IHQgLSBJO1xuICAgIHJldHVybiB1ID8gbXkoRSwgbiAtIE0pIDogRTtcbiAgfVxuICBmdW5jdGlvbiBtKHgpIHtcbiAgICB2YXIgSSA9IHggLSBjLCBNID0geCAtIGw7XG4gICAgcmV0dXJuIGMgPT09IHZvaWQgMCB8fCBJID49IHQgfHwgSSA8IDAgfHwgdSAmJiBNID49IG47XG4gIH1cbiAgZnVuY3Rpb24gYigpIHtcbiAgICB2YXIgeCA9IFFpKCk7XG4gICAgaWYgKG0oeCkpXG4gICAgICByZXR1cm4gUyh4KTtcbiAgICBhID0gc2V0VGltZW91dChiLCBwKHgpKTtcbiAgfVxuICBmdW5jdGlvbiBTKHgpIHtcbiAgICByZXR1cm4gYSA9IHZvaWQgMCwgZCAmJiBzID8gZih4KSA6IChzID0gciA9IHZvaWQgMCwgbyk7XG4gIH1cbiAgZnVuY3Rpb24gdygpIHtcbiAgICBhICE9PSB2b2lkIDAgJiYgY2xlYXJUaW1lb3V0KGEpLCBsID0gMCwgcyA9IGMgPSByID0gYSA9IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBrKCkge1xuICAgIHJldHVybiBhID09PSB2b2lkIDAgPyBvIDogUyhRaSgpKTtcbiAgfVxuICBmdW5jdGlvbiBPKCkge1xuICAgIHZhciB4ID0gUWkoKSwgSSA9IG0oeCk7XG4gICAgaWYgKHMgPSBhcmd1bWVudHMsIHIgPSB0aGlzLCBjID0geCwgSSkge1xuICAgICAgaWYgKGEgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIGcoYyk7XG4gICAgICBpZiAodSlcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChhKSwgYSA9IHNldFRpbWVvdXQoYiwgdCksIGYoYyk7XG4gICAgfVxuICAgIHJldHVybiBhID09PSB2b2lkIDAgJiYgKGEgPSBzZXRUaW1lb3V0KGIsIHQpKSwgbztcbiAgfVxuICByZXR1cm4gTy5jYW5jZWwgPSB3LCBPLmZsdXNoID0gaywgTztcbn1cbmZ1bmN0aW9uIHl5KGksIHQpIHtcbiAgcmV0dXJuIEFsKGksIHQpO1xufVxuZnVuY3Rpb24gYnkoaSwgdCwgZSwgcykge1xuICBpZiAoIVF0KGkpKVxuICAgIHJldHVybiBpO1xuICB0ID0gRWkodCwgaSk7XG4gIGZvciAodmFyIHIgPSAtMSwgbiA9IHQubGVuZ3RoLCBvID0gbiAtIDEsIGEgPSBpOyBhICE9IG51bGwgJiYgKytyIDwgbjsgKSB7XG4gICAgdmFyIGMgPSBhbyh0W3JdKSwgbCA9IGU7XG4gICAgaWYgKGMgPT09IFwiX19wcm90b19fXCIgfHwgYyA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IGMgPT09IFwicHJvdG90eXBlXCIpXG4gICAgICByZXR1cm4gaTtcbiAgICBpZiAociAhPSBvKSB7XG4gICAgICB2YXIgaCA9IGFbY107XG4gICAgICBsID0gdm9pZCAwLCBsID09PSB2b2lkIDAgJiYgKGwgPSBRdChoKSA/IGggOiBlbyh0W3IgKyAxXSkgPyBbXSA6IHt9KTtcbiAgICB9XG4gICAgU2woYSwgYywgbCksIGEgPSBhW2NdO1xuICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gX3koaSwgdCwgZSkge1xuICBmb3IgKHZhciBzID0gLTEsIHIgPSB0Lmxlbmd0aCwgbiA9IHt9OyArK3MgPCByOyApIHtcbiAgICB2YXIgbyA9IHRbc10sIGEgPSBpbShpLCBvKTtcbiAgICBlKGEsIG8pICYmIGJ5KG4sIEVpKG8sIGkpLCBhKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFN5KGksIHQpIHtcbiAgcmV0dXJuIF95KGksIHQsIGZ1bmN0aW9uKGUsIHMpIHtcbiAgICByZXR1cm4gZnkoaSwgcyk7XG4gIH0pO1xufVxudmFyIFR5ID0gYW0oZnVuY3Rpb24oaSwgdCkge1xuICByZXR1cm4gaSA9PSBudWxsID8ge30gOiBTeShpLCB0KTtcbn0pLCB4eSA9IFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiO1xuZnVuY3Rpb24gd3koaSwgdCwgZSkge1xuICB2YXIgcyA9ICEwLCByID0gITA7XG4gIGlmICh0eXBlb2YgaSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih4eSk7XG4gIHJldHVybiBRdChlKSAmJiAocyA9IFwibGVhZGluZ1wiIGluIGUgPyAhIWUubGVhZGluZyA6IHMsIHIgPSBcInRyYWlsaW5nXCIgaW4gZSA/ICEhZS50cmFpbGluZyA6IHIpLCB2eShpLCB0LCB7XG4gICAgbGVhZGluZzogcyxcbiAgICBtYXhXYWl0OiB0LFxuICAgIHRyYWlsaW5nOiByXG4gIH0pO1xufVxuY29uc3QgQ3kgPSAoaSwgdCkgPT4ge1xuICBpZiAoaS5sZW5ndGggIT09IHQubGVuZ3RoKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgZSA9IG5ldyBTZXQoaS5tYXAoKHIpID0+IHIuaWQpKSwgcyA9IG5ldyBTZXQodC5tYXAoKHIpID0+IHIuaWQpKTtcbiAgaWYgKGUuc2l6ZSAhPT0gcy5zaXplKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChjb25zdCByIG9mIGUpXG4gICAgaWYgKCFzLmhhcyhyKSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufSwgeHMgPSAoaSkgPT4ge1xuICBjb25zdCB7IHRyYWNrSXRlbUlkczogdCwgdHJhbnNpdGlvbnNNYXA6IGUsIHRyYWNrSXRlbXNNYXA6IHMgfSA9IGksIHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBPYmplY3QudmFsdWVzKGUpLmZvckVhY2goKGMpID0+IHtcbiAgICB2YXIgdSwgZDtcbiAgICBpZiAoYy5raW5kID09PSBcIm5vbmVcIikgcmV0dXJuO1xuICAgIGNvbnN0IHsgZnJvbUlkOiBsLCB0b0lkOiBoIH0gPSBjO1xuICAgIHIuaGFzKGwpIHx8IHIuc2V0KGwsIFtdKSwgci5oYXMoaCkgfHwgci5zZXQoaCwgW10pLCAodSA9IHIuZ2V0KGwpKSA9PSBudWxsIHx8IHUucHVzaChjKSwgKGQgPSByLmdldChoKSkgPT0gbnVsbCB8fCBkLnB1c2goYyk7XG4gIH0pO1xuICBjb25zdCBuID0gW10sIG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBhID0gKGMpID0+IHtcbiAgICBjb25zdCBsID0gW107XG4gICAgbGV0IGggPSBjO1xuICAgIGZvciAoOyBoICYmICFvLmhhcyhoKTsgKSB7XG4gICAgICBvLmFkZChoKTtcbiAgICAgIGNvbnN0IHUgPSBzW2hdO1xuICAgICAgbC5wdXNoKHUpO1xuICAgICAgY29uc3QgZCA9IE9iamVjdC52YWx1ZXMoZSkuZmluZChcbiAgICAgICAgKGYpID0+IGYuZnJvbUlkID09PSBoICYmIGYua2luZCAhPT0gXCJub25lXCJcbiAgICAgICk7XG4gICAgICBpZiAoIWQpIGJyZWFrO1xuICAgICAgbC5wdXNoKGQpLCBoID0gZC50b0lkO1xuICAgIH1cbiAgICByZXR1cm4gbDtcbiAgfTtcbiAgZm9yIChjb25zdCBjIG9mIHQpXG4gICAgaWYgKCFvLmhhcyhjKSAmJiAoIXIuaGFzKGMpIHx8ICFPYmplY3QudmFsdWVzKGUpLnNvbWUoXG4gICAgICAobCkgPT4gbC50b0lkID09PSBjICYmIGwua2luZCAhPT0gXCJub25lXCJcbiAgICApKSkge1xuICAgICAgY29uc3QgbCA9IGEoYyk7XG4gICAgICBsLmxlbmd0aCA+IDAgJiYgbi5wdXNoKGwpO1xuICAgIH1cbiAgcmV0dXJuIG4uZm9yRWFjaCgoYykgPT4ge1xuICAgIGMuc29ydCgobCwgaCkgPT4gXCJkaXNwbGF5XCIgaW4gbCAmJiBcImRpc3BsYXlcIiBpbiBoID8gbC5kaXNwbGF5LmZyb20gLSBoLmRpc3BsYXkuZnJvbSA6IDApO1xuICB9KSwgbjtcbn07XG5mdW5jdGlvbiBPeShpLCB0LCBlLCBzLCByKSB7XG4gIGNvbnN0IG4gPSBpWzBdLmNhbnZhcywgbyA9IE9iamVjdC5rZXlzKHMpLCBhID0ge30sIGMgPSBbXTtcbiAgcmV0dXJuIGkuZm9yRWFjaCgobCkgPT4ge1xuICAgIGNvbnN0IGggPSB0LmZpbHRlcigodSkgPT4gbC5pdGVtcy5pbmNsdWRlcyh1LmlkKSkubWFwKCh1KSA9PiB7XG4gICAgICBpZiAoci5pbmNsdWRlcyh1LmlkKSkge1xuICAgICAgICBjb25zdCBkID0gbi5nZXRPYmplY3RzKCkuZmluZCgoZikgPT4gZi5pZCA9PT0gYCR7dS5pZH0tcGxhY2Vob2xkZXJgKTtcbiAgICAgICAgcmV0dXJuIChkID09IG51bGwgPyB2b2lkIDAgOiBkLm9wYWNpdHkpID09PSAxICYmICh1LmxlZnQgPSAoZCA9PSBudWxsID8gdm9pZCAwIDogZC5sZWZ0KSB8fCB1LmxlZnQpLCB1O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiB1O1xuICAgIH0pLnNvcnQoKHUsIGQpID0+IHUubGVmdCAtIGQubGVmdCk7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCBoLmxlbmd0aCAtIDE7IHUrKykge1xuICAgICAgY29uc3QgZCA9IGhbdV07XG4gICAgICBsZXQgZiA9IGQubGVmdDtcbiAgICAgIGNvbnN0IGcgPSBoW3UgKyAxXTtcbiAgICAgIGxldCBwID0gZy5sZWZ0O1xuICAgICAgaWYgKG8uaW5jbHVkZXMoZC5pZCkgJiYgKGYgPSBzW2QuaWRdLmxlZnQpLCBvLmluY2x1ZGVzKGcuaWQpICYmIChwID0gc1tnLmlkXS5sZWZ0KSwgTWF0aC5hYnMoZiArIGQud2lkdGggLSBwKSA8PSAxKSB7XG4gICAgICAgIGNvbnN0IG0gPSBgJHtkLmlkfS0ke2cuaWR9YDtcbiAgICAgICAgaWYgKGUuaGFzT3duUHJvcGVydHkobSkpIHtcbiAgICAgICAgICBjb25zdCBTID0gZVttXTtcbiAgICAgICAgICBhW21dID0gUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBTID0ge1xuICAgICAgICAgICAgaWQ6IG0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMTUwMCxcbiAgICAgICAgICAgIGZyb21JZDogZC5pZCxcbiAgICAgICAgICAgIHRvSWQ6IGcuaWQsXG4gICAgICAgICAgICBraW5kOiBcIm5vbmVcIixcbiAgICAgICAgICAgIHRyYWNrSWQ6IGwuaWQsXG4gICAgICAgICAgICB0eXBlOiBcInRyYW5zaXRpb25cIlxuICAgICAgICAgIH07XG4gICAgICAgICAgYVttXSA9IFM7XG4gICAgICAgIH1cbiAgICAgICAgYy5wdXNoKG0pO1xuICAgICAgfVxuICAgIH1cbiAgfSksIHtcbiAgICBuZXdUcmFuc2l0aW9uSWRzOiBjLFxuICAgIG5ld1RyYW5zaXRpb25zTWFwOiBhXG4gIH07XG59XG5jb25zdCBfZSA9IChpLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSB0LmZpbmRJbmRleCgoaCkgPT4gaC5pZCA9PT0gaSksIHMgPSB0W2UgLSAxXSwgciA9IHRbZSArIDFdLCBuID0gdC5maWx0ZXIoXG4gICAgKGgpID0+IGgudHlwZSA9PT0gXCJ0cmFuc2l0aW9uXCJcbiAgKSwgbyA9IG4uaW5kZXhPZihzKSwgYyA9IG4uc2xpY2UoXG4gICAgMCxcbiAgICBvXG4gICkucmVkdWNlKChoLCB1KSA9PiBoICsgKHUuZHVyYXRpb24gfHwgMCksIDApO1xuICBsZXQgbCA9IDA7XG4gIHJldHVybiBzICYmICFyID8gbCA9IChzLmR1cmF0aW9uIHx8IDApIC8gMiA6IHIgJiYgIXMgPyBsID0gKHIuZHVyYXRpb24gfHwgMCkgLyAyIDogcyAmJiByICYmIChsID0gKHIuZHVyYXRpb24gfHwgMCkgLyAyICsgKHMuZHVyYXRpb24gfHwgMCkgLyAyKSwge1xuICAgIGR1cmF0aW9uRGlmZjogbCxcbiAgICBvZmZzZXRUcmFuc2l0aW9uczogY1xuICB9O1xufSwgaG8gPSAoaSkgPT4ge1xuICBjb25zdCB7IHRyYWNrSXRlbUlkczogdCwgdHJhbnNpdGlvbnNNYXA6IGUsIHRyYWNrSXRlbXNNYXA6IHMgfSA9IGksIHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBPYmplY3QudmFsdWVzKGUpLmZvckVhY2goKGwpID0+IHtcbiAgICB2YXIgZiwgZztcbiAgICBjb25zdCB7IGZyb21JZDogaCwgdG9JZDogdSwga2luZDogZCB9ID0gbDtcbiAgICBkICE9PSBcIm5vbmVcIiAmJiAoci5oYXMoaCkgfHwgci5zZXQoaCwgW10pLCByLmhhcyh1KSB8fCByLnNldCh1LCBbXSksIChmID0gci5nZXQoaCkpID09IG51bGwgfHwgZi5wdXNoKGwpLCAoZyA9IHIuZ2V0KHUpKSA9PSBudWxsIHx8IGcucHVzaChsKSk7XG4gIH0pO1xuICBjb25zdCBuID0gW10sIG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBhID0gKGwpID0+IHtcbiAgICBjb25zdCBoID0gW107XG4gICAgbGV0IHUgPSBsO1xuICAgIGZvciAoOyB1ICYmICFvLmhhcyh1KTsgKSB7XG4gICAgICBvLmFkZCh1KTtcbiAgICAgIGNvbnN0IGQgPSBzW3VdO1xuICAgICAgaC5wdXNoKGQpO1xuICAgICAgY29uc3QgZiA9IE9iamVjdC52YWx1ZXMoZSkuZmluZChcbiAgICAgICAgKGcpID0+IGcuZnJvbUlkID09PSB1ICYmIGcua2luZCAhPT0gXCJub25lXCJcbiAgICAgICAgLy8gRmlsdGVyIGhlcmVcbiAgICAgICk7XG4gICAgICBpZiAoIWYpIGJyZWFrO1xuICAgICAgaC5wdXNoKGYpLCB1ID0gZi50b0lkO1xuICAgIH1cbiAgICByZXR1cm4gaDtcbiAgfSwgYyA9IE9iamVjdC52YWx1ZXMoZSkuZmlsdGVyKFxuICAgIChsKSA9PiBsLmtpbmQgIT09IFwibm9uZVwiXG4gICk7XG4gIGZvciAoY29uc3QgbCBvZiB0KVxuICAgIGlmICghby5oYXMobCkgJiYgKCFyLmhhcyhsKSB8fCAhYy5zb21lKChoKSA9PiBoLnRvSWQgPT09IGwpKSkge1xuICAgICAgY29uc3QgaCA9IGEobCk7XG4gICAgICBoLmxlbmd0aCA+IDAgJiYgbi5wdXNoKGgpO1xuICAgIH1cbiAgcmV0dXJuIG4uZm9yRWFjaCgobCkgPT4ge1xuICAgIGwuc29ydCgoaCwgdSkgPT4gXCJkaXNwbGF5XCIgaW4gaCAmJiBcImRpc3BsYXlcIiBpbiB1ID8gaC5kaXNwbGF5LmZyb20gLSB1LmRpc3BsYXkuZnJvbSA6IDApO1xuICB9KSwgbjtcbn07XG5jbGFzcyBreSB7XG4gIGFkZFRyYWNrSXRlbSh0KSB7XG4gICAgY29uc3QgZSA9IEZmKHQsIHtcbiAgICAgIHRTY2FsZTogdGhpcy50U2NhbGUsXG4gICAgICBzaXplc01hcDogdGhpcy5zaXplc01hcFxuICAgIH0pO1xuICAgIHRoaXMuYWRkKGUpO1xuICB9XG4gIGFsaWduSXRlbXNUb1RyYWNrKCkge1xuICAgIHRoaXMucGF1c2VFdmVudExpc3RlbmVycygpO1xuICAgIGNvbnN0IHQgPSBuZXcgTWFwKFxuICAgICAgdGhpcy5nZXRPYmplY3RzKFwiVHJhY2tcIikubWFwKChyKSA9PiBbci5pZCwgcl0pXG4gICAgKSwgZSA9IHRoaXMuZ2V0VHJhY2tJdGVtcygpLCBzID0gdGhpcy5nZXRPYmplY3RzKFwiVHJhbnNpdGlvblwiKTtcbiAgICB0aGlzLnRyYWNrSXRlbUlkcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBjb25zdCBuID0gdGhpcy50cmFja3MuZmluZChcbiAgICAgICAgKGMpID0+IGMuaXRlbXMuaW5jbHVkZXMocilcbiAgICAgICk7XG4gICAgICBpZiAoIW4pIHJldHVybjtcbiAgICAgIGNvbnN0IG8gPSB0LmdldChuLmlkKSwgYSA9IHRoaXMuZ2V0VHJhY2tJdGVtcygpLmZpbmQoKGMpID0+IGMuaWQgPT09IHIpO1xuICAgICAgYSAmJiBvICYmIChhLmlzTWFpbiA9IG8ubWFnbmV0aWMsIHRoaXMudHJhY2tJdGVtc01hcFtyXS5pc01haW4gPSBvLm1hZ25ldGljLCBhLnNldCh7IHRvcDogby50b3AgfSksIGEuc2V0Q29vcmRzKCkpO1xuICAgIH0pLCB0LmZvckVhY2goKHIpID0+IHtcbiAgICAgIHIuaXRlbXMgPSBlLmZpbHRlcigobikgPT4gbi50b3AgPT09IHIudG9wKS5tYXAoKG4pID0+IG4uaWQpO1xuICAgIH0pLCBzLmZvckVhY2goKHIpID0+IHtcbiAgICAgIGNvbnN0IG4gPSByLmZyb21JZCwgbyA9IGUuZmluZCgoYSkgPT4gYS5pZCA9PT0gbik7XG4gICAgICBvICYmIChyLnNldCh7IHRvcDogby50b3AgfSksIHIuc2V0Q29vcmRzKCkpO1xuICAgIH0pLCB0aGlzLnJlc3VtZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgdXBkYXRlVHJhY2tJdGVtc1RvSGlzdG9yeSgpIHtcbiAgICB0aGlzLnBhdXNlRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy50cmFja0l0ZW1JZHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHRoaXMudHJhY2tzLmZpbmQoKGMpID0+IGMuaXRlbXMuaW5jbHVkZXModCkpLCBzID0gdGhpcy5nZXRPYmplY3RzKCkuZmluZCgoYykgPT4gYy5pZCA9PT0gKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuaWQpKS50b3AsIHIgPSB0aGlzLnRyYWNrSXRlbXNNYXBbdF0sIG4gPSB0aGlzLmdldE9iamVjdHMoKS5maW5kKChjKSA9PiBjLmlkID09PSB0KSwgbyA9IEQoci5kaXNwbGF5LmZyb20sIHRoaXMudFNjYWxlKSwgYSA9IEQoXG4gICAgICAgIHIuZGlzcGxheS50byAtIHIuZGlzcGxheS5mcm9tLFxuICAgICAgICB0aGlzLnRTY2FsZSxcbiAgICAgICAgci5wbGF5YmFja1JhdGVcbiAgICAgICk7XG4gICAgICBpZiAobi5zZXQoeyBsZWZ0OiBvLCB3aWR0aDogYSwgdG9wOiBzIH0pLCBuIGluc3RhbmNlb2YgX3QgfHwgbiBpbnN0YW5jZW9mIGZ0KSB7XG4gICAgICAgIGNvbnN0IGMgPSBuLmRpc3BsYXkudG8gLSBuLmRpc3BsYXkuZnJvbTtcbiAgICAgICAgbi5zZXREdXJhdGlvbiA/IG4uc2V0RHVyYXRpb24oYykgOiBuLnNldCh7IGR1cmF0aW9uOiBjIH0pLCByLnRyaW0gPSBuLnRyaW0sIHIuZGlzcGxheSA9IG4uZGlzcGxheTtcbiAgICAgIH1cbiAgICAgIG4uc2V0Q29vcmRzKCk7XG4gICAgfSksIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpLCB0aGlzLnJlc3VtZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgZGVsZXRlVHJhY2tJdGVtVG9IaXN0b3J5KHQpIHtcbiAgICB0aGlzLmdldE9iamVjdHMoKS5maWx0ZXIoKGUpID0+IHQuaW5jbHVkZXMoZS5pZCkpLm1hcCgoZSkgPT4gdGhpcy5yZW1vdmUoZSkpLCB0aGlzLmFsaWduSXRlbXNUb1RyYWNrKCksIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9XG4gIHVvZGF0ZVRyYWNrSXRlbUlkc09yZGVyaW5nKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFRyYWNrSXRlbXMoKTtcbiAgICB0LnNvcnQoKGUsIHMpID0+IGUudG9wIC0gcy50b3ApLCB0aGlzLnRyYWNrSXRlbUlkcyA9IHQubWFwKChlKSA9PiBlLmlkKS5yZXZlcnNlKCk7XG4gIH1cbiAgc2VsZWN0VHJhY2tJdGVtQnlJZHModCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKS5tYXAoKG4pID0+IG4uaWQpO1xuICAgIGlmICh5eShlLCB0KSkgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldE9iamVjdHMoLi4uJG8sIFwiVHJhbnNpdGlvblwiKS5maWx0ZXIoKG4pID0+IHQuaW5jbHVkZXMobi5pZCkpO1xuICAgIGlmICghci5sZW5ndGgpXG4gICAgICB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoKTtcbiAgICBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMSlcbiAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KHJbMF0pO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbiA9IG5ldyBPdChyKTtcbiAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KG4pO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfVxuICBzeW5jaHJvbml6ZVRyYWNrSXRlbXNTdGF0ZSgpIHtcbiAgICB0aGlzLnBhdXNlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUcmFja0l0ZW1zKCksIGUgPSB7fSwgcyA9IGhvKHtcbiAgICAgIHRyYWNrSXRlbUlkczogdGhpcy50cmFja0l0ZW1JZHMsXG4gICAgICB0cmFuc2l0aW9uc01hcDogdGhpcy50cmFuc2l0aW9uc01hcCxcbiAgICAgIHRyYWNrSXRlbXNNYXA6IHRoaXMudHJhY2tJdGVtc01hcFxuICAgIH0pO1xuICAgIHQuZm9yRWFjaCgocikgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiwgbGVmdDogbywgd2lkdGg6IGEgfSA9IHIsIGMgPSB0aGlzLnRyYWNrSXRlbXNNYXBbbl0sIGwgPSB0aGlzLnRyYW5zaXRpb25Hcm91cHMuZmluZCgoaCkgPT4gaC5maW5kKCh1KSA9PiB1LmlkID09PSBuKSkgfHwgW107XG4gICAgICBpZiAobC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgaCA9IFkobywgdGhpcy50U2NhbGUpLCB1ID0gWShhLCB0aGlzLnRTY2FsZSwgci5wbGF5YmFja1JhdGUpLCBkID0ge1xuICAgICAgICAgIGZyb206IGgsXG4gICAgICAgICAgdG86IGggKyB1XG4gICAgICAgIH0sIGYgPSB7XG4gICAgICAgICAgZGlzcGxheTogZFxuICAgICAgICB9O1xuICAgICAgICAociBpbnN0YW5jZW9mIF90IHx8IHIgaW5zdGFuY2VvZiBmdCB8fCByIGluc3RhbmNlb2YgVnQpICYmIChmLnRyaW0gPSByLnRyaW0sIGYuZHVyYXRpb24gPSBkLnRvIC0gZC5mcm9tKSwgci5kaXNwbGF5ID0gZCwgZVtuXSA9IHtcbiAgICAgICAgICAuLi5jLFxuICAgICAgICAgIC4uLmZcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGggPSBsLmZpbmRJbmRleCgoZikgPT4gZi5pZCA9PT0gbiksIHUgPSBsW2ggLSAxXSwgZCA9IGxbaCArIDFdO1xuICAgICAgICBpZiAodSAmJiAhZCkge1xuICAgICAgICAgIGNvbnN0IGYgPSBfZShuLCBsKSwgZyA9IFkobywgdGhpcy50U2NhbGUpICsgdS5kdXJhdGlvbiAvIDIgKyBmLm9mZnNldFRyYW5zaXRpb25zLCBwID0gWShhLCB0aGlzLnRTY2FsZSwgci5wbGF5YmFja1JhdGUpICsgKHUuZHVyYXRpb24gfHwgMCkgLyAyLCBtID0ge1xuICAgICAgICAgICAgZnJvbTogZyxcbiAgICAgICAgICAgIHRvOiBnICsgcFxuICAgICAgICAgIH0sIGIgPSB7XG4gICAgICAgICAgICBkaXNwbGF5OiBtXG4gICAgICAgICAgfTtcbiAgICAgICAgICAociBpbnN0YW5jZW9mIF90IHx8IHIgaW5zdGFuY2VvZiBmdCB8fCByIGluc3RhbmNlb2YgVnQpICYmIChiLnRyaW0gPSByLnRyaW0pLCByLmRpc3BsYXkgPSBtLCBlW25dID0ge1xuICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgIC4uLmJcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGQgJiYgIXUpIHtcbiAgICAgICAgICBjb25zdCBmID0gWShvLCB0aGlzLnRTY2FsZSksIGcgPSBZKFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIHRoaXMudFNjYWxlLFxuICAgICAgICAgICAgci5wbGF5YmFja1JhdGVcbiAgICAgICAgICApLCBwID0ge1xuICAgICAgICAgICAgZnJvbTogZixcbiAgICAgICAgICAgIHRvOiBmICsgZyArIChkLmR1cmF0aW9uIHx8IDApIC8gMlxuICAgICAgICAgIH0sIG0gPSB7XG4gICAgICAgICAgICBkaXNwbGF5OiBwXG4gICAgICAgICAgfTtcbiAgICAgICAgICAociBpbnN0YW5jZW9mIF90IHx8IHIgaW5zdGFuY2VvZiBmdCB8fCByIGluc3RhbmNlb2YgVnQpICYmIChtLnRyaW0gPSByLnRyaW0pLCByLmRpc3BsYXkgPSBwLCBlW25dID0ge1xuICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgIC4uLm1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHUgJiYgZCkge1xuICAgICAgICAgIGNvbnN0IGYgPSBZKG8sIHRoaXMudFNjYWxlKSwgZyA9IHMuZmluZChcbiAgICAgICAgICAgIChPKSA9PiBPLmZpbmQoKHgpID0+IHguaWQgPT09IHIuaWQpXG4gICAgICAgICAgKSwgYiA9IChnID09IG51bGwgPyB2b2lkIDAgOiBnLmZpbHRlcigoTykgPT4gTy50eXBlID09PSBcInRyYW5zaXRpb25cIikubWFwKFxuICAgICAgICAgICAgKE8pID0+IHRoaXMuZ2V0T2JqZWN0cygpLmZpbmQoKHgpID0+IHguaWQgPT09IE8uaWQpXG4gICAgICAgICAgKSkuZmlsdGVyKChPKSA9PiBPLnRvcCA9PT0gci50b3ApLmZpbHRlcigoTykgPT4gTy5sZWZ0ICsgTy53aWR0aCA8PSByLmxlZnQpLnJlZHVjZSgoTywgeCkgPT4gTyArICh4LmR1cmF0aW9uIHx8IDApLCAwKSwgUyA9IFkoXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgdGhpcy50U2NhbGUsXG4gICAgICAgICAgICByLnBsYXliYWNrUmF0ZVxuICAgICAgICAgICksIHcgPSB7XG4gICAgICAgICAgICBmcm9tOiBmICsgYiArICh1LmR1cmF0aW9uIHx8IDApIC8gMixcbiAgICAgICAgICAgIHRvOiBmICsgYiArIFMgKyAoZC5kdXJhdGlvbiB8fCAwKSAvIDIgKyAodS5kdXJhdGlvbiB8fCAwKVxuICAgICAgICAgIH0sIGsgPSB7XG4gICAgICAgICAgICBkaXNwbGF5OiB3XG4gICAgICAgICAgfTtcbiAgICAgICAgICAociBpbnN0YW5jZW9mIF90IHx8IHIgaW5zdGFuY2VvZiBmdCB8fCByIGluc3RhbmNlb2YgVnQpICYmIChrLnRyaW0gPSByLnRyaW0pLCByLmRpc3BsYXkgPSB3LCBlW25dID0ge1xuICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgIC4uLmtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksIHRoaXMudHJhY2tJdGVtc01hcCA9IHtcbiAgICAgIC4uLnRoaXMudHJhY2tJdGVtc01hcCxcbiAgICAgIC4uLmVcbiAgICB9LCB0aGlzLnJlc3VtZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgZGVsZXRlVHJhY2tJdGVtQnlJZCh0KSB7XG4gICAgY29uc3QgZSA9IHQsIHMgPSB0aGlzLmdldE9iamVjdHMoKS5maWx0ZXIoXG4gICAgICAoYSkgPT4gdC5pbmNsdWRlcyhhLmlkKVxuICAgICksIHIgPSBycih0aGlzLnRyYWNrcywgZSksIG4gPSB7fTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLnRyYWNrSXRlbXNNYXApLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGUuaW5jbHVkZXMoYSkgfHwgKG5bYV0gPSB0aGlzLnRyYWNrSXRlbXNNYXBbYV0pO1xuICAgIH0pO1xuICAgIGNvbnN0IG8gPSB0aGlzLnRyYWNrSXRlbUlkcy5maWx0ZXIoXG4gICAgICAoYSkgPT4gIWUuaW5jbHVkZXMoYSlcbiAgICApO1xuICAgIHRoaXMudHJhY2tzID0gciwgdGhpcy50cmFja0l0ZW1zTWFwID0gbiwgdGhpcy50cmFja0l0ZW1JZHMgPSBvLCB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoKSwgdGhpcy5yZW1vdmUoLi4ucyksIHRoaXMucmVuZGVyVHJhY2tzKCksIHRoaXMuYWxpZ25JdGVtc1RvVHJhY2soKTtcbiAgfVxuICBkZWxldGVBY3RpdmVUcmFja0l0ZW0oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpO1xuICAgIGlmICghdC5sZW5ndGgpIHJldHVybiAhMTtcbiAgICBjb25zdCBlID0gdC5tYXAoKG8pID0+IG8uaWQpLCBzID0gcnIodGhpcy50cmFja3MsIGUpLCByID0ge307XG4gICAgT2JqZWN0LmtleXModGhpcy50cmFja0l0ZW1zTWFwKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBlLmluY2x1ZGVzKG8pIHx8IChyW29dID0gdGhpcy50cmFja0l0ZW1zTWFwW29dKTtcbiAgICB9KTtcbiAgICBjb25zdCBuID0gdGhpcy50cmFja0l0ZW1JZHMuZmlsdGVyKFxuICAgICAgKG8pID0+ICFlLmluY2x1ZGVzKG8pXG4gICAgKTtcbiAgICB0aGlzLnRyYWNrcyA9IHMsIHRoaXMudHJhY2tJdGVtc01hcCA9IHIsIHRoaXMudHJhY2tJdGVtSWRzID0gbiwgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KCksIHRoaXMucmVtb3ZlKC4uLnQpLCB0aGlzLnNldEFjdGl2ZUlkcyhbXSksIHRoaXMucmVuZGVyVHJhY2tzKCksIHRoaXMuYWxpZ25JdGVtc1RvVHJhY2soKSwgdGhpcy51cGRhdGVTdGF0ZSh7IHVwZGF0ZUhpc3Rvcnk6ICEwLCBraW5kOiBcInJlbW92ZVwiIH0pO1xuICB9XG4gIC8qXG4gICAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGNvb3JkaW5hdGVzIG9mIGFsbCB0cmFjayBpdGVtcyBpbiB0aGUgdGltZWxpbmUuXG4gICAqL1xuICB1cGRhdGVUcmFja0l0ZW1Db29yZHModCkge1xuICAgIGNvbnN0IGUgPSB0ID8gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCkubWFwKChzKSA9PiBzLmlkKSA6IFtdO1xuICAgIHRoaXMudHJhY2tJdGVtSWRzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGlmIChlLmluY2x1ZGVzKHMpKSByZXR1cm47XG4gICAgICBjb25zdCByID0gdGhpcy50cmFuc2l0aW9uR3JvdXBzLmZpbmQoKGMpID0+IGMuZmluZCgobCkgPT4gbC5pZCA9PT0gcykpIHx8IFtdO1xuICAgICAgaWYgKChyID09IG51bGwgPyB2b2lkIDAgOiByLmxlbmd0aCkgPT09IDEpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0T2JqZWN0cygpLmZpbmQoKGQpID0+IGQuaWQgPT09IHMpLCBsID0gdGhpcy50cmFja0l0ZW1zTWFwW3NdLCBoID0gRChsLmRpc3BsYXkuZnJvbSwgdGhpcy50U2NhbGUpLCB1ID0gRChcbiAgICAgICAgICBsLmRpc3BsYXkudG8gLSBsLmRpc3BsYXkuZnJvbSxcbiAgICAgICAgICB0aGlzLnRTY2FsZSxcbiAgICAgICAgICBsLnBsYXliYWNrUmF0ZVxuICAgICAgICApO1xuICAgICAgICBjLnNldCh7XG4gICAgICAgICAgbGVmdDogaCxcbiAgICAgICAgICB3aWR0aDogdVxuICAgICAgICB9KSwgYy5zZXRDb29yZHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbiA9IHIuZmluZEluZGV4KChjKSA9PiBjLmlkID09PSBzKSwgbyA9IHJbbiAtIDFdLCBhID0gcltuICsgMV07XG4gICAgICBpZiAobyAmJiAhYSkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRPYmplY3RzKCkuZmluZCgoZikgPT4gZi5pZCA9PT0gcyksIGwgPSB0aGlzLnRyYWNrSXRlbXNNYXBbc10sIGggPSBfZShzLCByKSwgdSA9IEQoXG4gICAgICAgICAgbC5kaXNwbGF5LmZyb20gLSAoby5kdXJhdGlvbiB8fCAwKSAvIDIgLSBoLm9mZnNldFRyYW5zaXRpb25zLFxuICAgICAgICAgIHRoaXMudFNjYWxlXG4gICAgICAgICksIGQgPSBEKFxuICAgICAgICAgIGwuZGlzcGxheS50byAtIGwuZGlzcGxheS5mcm9tIC0gKG8uZHVyYXRpb24gfHwgMCkgLyAyLFxuICAgICAgICAgIHRoaXMudFNjYWxlLFxuICAgICAgICAgIGwucGxheWJhY2tSYXRlXG4gICAgICAgICk7XG4gICAgICAgIGMuc2V0KHtcbiAgICAgICAgICBsZWZ0OiB1LFxuICAgICAgICAgIHdpZHRoOiBkXG4gICAgICAgIH0pLCBjLnNldENvb3JkcygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYSAmJiAhbykge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRPYmplY3RzKCkuZmluZCgoZCkgPT4gZC5pZCA9PT0gcyksIGwgPSB0aGlzLnRyYWNrSXRlbXNNYXBbc10sIGggPSBEKGwuZGlzcGxheS5mcm9tLCB0aGlzLnRTY2FsZSksIHUgPSBEKFxuICAgICAgICAgIGwuZGlzcGxheS50byAtIGwuZGlzcGxheS5mcm9tIC0gKGEuZHVyYXRpb24gfHwgMCkgLyAyLFxuICAgICAgICAgIHRoaXMudFNjYWxlLFxuICAgICAgICAgIGwucGxheWJhY2tSYXRlXG4gICAgICAgICk7XG4gICAgICAgIGMuc2V0KHtcbiAgICAgICAgICBsZWZ0OiBoLFxuICAgICAgICAgIHdpZHRoOiB1XG4gICAgICAgIH0pLCBjLnNldENvb3JkcygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobyAmJiBhKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldE9iamVjdHMoKS5maW5kKChmKSA9PiBmLmlkID09PSBzKSwgbCA9IHRoaXMudHJhY2tJdGVtc01hcFtzXSwgaCA9IF9lKHMsIHIpLCB1ID0gRChcbiAgICAgICAgICBsLmRpc3BsYXkuZnJvbSAtIChvLmR1cmF0aW9uIHx8IDApIC8gMiAtIGgub2Zmc2V0VHJhbnNpdGlvbnMsXG4gICAgICAgICAgdGhpcy50U2NhbGVcbiAgICAgICAgKSwgZCA9IEQoXG4gICAgICAgICAgbC5kaXNwbGF5LnRvIC0gbC5kaXNwbGF5LmZyb20gLSAoYS5kdXJhdGlvbiB8fCAwKSAvIDIgLSAoby5kdXJhdGlvbiB8fCAwKSAvIDIsXG4gICAgICAgICAgdGhpcy50U2NhbGUsXG4gICAgICAgICAgbC5wbGF5YmFja1JhdGVcbiAgICAgICAgKTtcbiAgICAgICAgYy5zZXQoe1xuICAgICAgICAgIGxlZnQ6IHUsXG4gICAgICAgICAgd2lkdGg6IGRcbiAgICAgICAgfSksIGMuc2V0Q29vcmRzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyBSZXN0b3JlIHRyYWNrIGl0ZW1zIHNpemVzIHRoYXQgYXJlIG5vdCBhZmZlY3RlZCBieSB0cmFuc2l0aW9uc1xuICByZWZyZXNoVHJhY2tJdGVtc0ZvclRyYW5zaXRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKS5tYXAoKGwpID0+IGwuaWQpO1xuICAgIHRoaXMucGF1c2VFdmVudExpc3RlbmVycygpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmdldE9iamVjdHMoXCJUcmFja1wiKSwgcyA9IHRoaXMuZ2V0T2JqZWN0cyhcIlZpZGVvXCIsIFwiSW1hZ2VcIiksIHIgPSB0aGlzLmdldE9iamVjdHMoXCJUcmFuc2l0aW9uXCIpLCBuID0gcy5jb25jYXQociksIG8gPSBPYmplY3Qua2V5cyh0aGlzLnBvc2l0aW9uQWZ0ZXJUcmFuc2Zvcm0pO1xuICAgIGUuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgby5mb3JFYWNoKChoKSA9PiB7XG4gICAgICAgIGlmIChsLml0ZW1zLmluY2x1ZGVzKGgpKSB7XG4gICAgICAgICAgY29uc3QgdSA9IHRoaXMuZ2V0T2JqZWN0cygpLmZpbmQoKGQpID0+IGQuaWQgPT09IGgpO1xuICAgICAgICAgIHQuaW5jbHVkZXMoaCkgfHwgKHRoaXMucG9zaXRpb25BZnRlclRyYW5zZm9ybVtoXS5sZWZ0ID0gdS5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgeyBuZXdUcmFuc2l0aW9uc01hcDogYSB9ID0gT3koXG4gICAgICBlLFxuICAgICAgcyxcbiAgICAgIHRoaXMudHJhbnNpdGlvbnNNYXAsXG4gICAgICB0aGlzLnBvc2l0aW9uQWZ0ZXJUcmFuc2Zvcm0sXG4gICAgICB0XG4gICAgKSwgYyA9IHhzKHtcbiAgICAgIHRyYWNrSXRlbUlkczogdGhpcy50cmFja0l0ZW1JZHMsXG4gICAgICB0cmFuc2l0aW9uc01hcDogYSxcbiAgICAgIHRyYWNrSXRlbXNNYXA6IHRoaXMudHJhY2tJdGVtc01hcFxuICAgIH0pO1xuICAgIHMuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgY29uc3QgaCA9IGwuaWQsIHUgPSBjLmZpbmQoKG0pID0+IG0uZmluZCgoYikgPT4gYi5pZCA9PT0gaCkpIHx8IFtdLCBkID0gdGhpcy50cmFuc2l0aW9uR3JvdXBzLmZpbmQoKG0pID0+IG0uZmluZCgoYikgPT4gYi5pZCA9PT0gaCkpIHx8IFtdO1xuICAgICAgaWYgKEN5KGQsIHUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBmID0gdS5maW5kSW5kZXgoKG0pID0+IG0uaWQgPT09IGgpLCBnID0gdVtmIC0gMV0sIHAgPSB1W2YgKyAxXTtcbiAgICAgIGlmIChnICYmICFwKSB7XG4gICAgICAgIGNvbnN0IG0gPSBfZShcbiAgICAgICAgICBoLFxuICAgICAgICAgIGRcbiAgICAgICAgKSwgYiA9IF9lKFxuICAgICAgICAgIGgsXG4gICAgICAgICAgdVxuICAgICAgICApLCBTID0gRChcbiAgICAgICAgICBtLmR1cmF0aW9uRGlmZiAtIGIuZHVyYXRpb25EaWZmLFxuICAgICAgICAgIHRoaXMudFNjYWxlXG4gICAgICAgICk7XG4gICAgICAgIGwuc2V0KHtcbiAgICAgICAgICB3aWR0aDogbC53aWR0aCArIFNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHAgJiYgIWcpIHtcbiAgICAgICAgY29uc3QgbSA9IF9lKFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZFxuICAgICAgICApLCBiID0gX2UoXG4gICAgICAgICAgaCxcbiAgICAgICAgICB1XG4gICAgICAgICk7XG4gICAgICAgIGlmIChtLmR1cmF0aW9uRGlmZiA+IDApIHtcbiAgICAgICAgICBjb25zdCBTID0gRChcbiAgICAgICAgICAgIG0uZHVyYXRpb25EaWZmIC0gYi5kdXJhdGlvbkRpZmYsXG4gICAgICAgICAgICB0aGlzLnRTY2FsZVxuICAgICAgICAgICk7XG4gICAgICAgICAgbC5zZXQoe1xuICAgICAgICAgICAgd2lkdGg6IGwud2lkdGggKyBTXG4gICAgICAgICAgfSksIHUuZm9yRWFjaCgodykgPT4ge1xuICAgICAgICAgICAgaWYgKHcuaWQgIT09IGwuaWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgayA9IG4uZmluZChcbiAgICAgICAgICAgICAgICAoTykgPT4gTy5pZCA9PT0gdy5pZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBrID09IG51bGwgfHwgay5zZXQoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IGsubGVmdCArIFNcbiAgICAgICAgICAgICAgfSksIGsgPT0gbnVsbCB8fCBrLnNldENvb3JkcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGcgJiYgcClcbiAgICAgICAgY29uc29sZS53YXJuKFwiaW52YWxpZCBzcG90XCIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG0gPSBfZShcbiAgICAgICAgICBoLFxuICAgICAgICAgIGRcbiAgICAgICAgKSwgYiA9IEQobS5kdXJhdGlvbkRpZmYsIHRoaXMudFNjYWxlKTtcbiAgICAgICAgbC5zZXQoe1xuICAgICAgICAgIHdpZHRoOiBsLndpZHRoICsgYlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5yZXN1bWVFdmVudExpc3RlbmVycygpO1xuICB9XG4gIGdldFRyYWNrSXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cyguLi4kbyk7XG4gIH1cbiAgc2V0VHJhY2tJdGVtQ29vcmRzKCkge1xuICAgIHRoaXMuZ2V0VHJhY2tJdGVtcygpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuc2V0Q29vcmRzKCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0QWN0aXZlVHJhY2tJdGVtQ29vcmRzKCkge1xuICAgIHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLmZvckVhY2goKGUpID0+IGUuc2V0Q29vcmRzKCkpO1xuICB9XG59XG5jb25zdCBKZSA9IHtcbiAgdGV4dDogMzIsXG4gIGltYWdlOiA0MCxcbiAgdmlkZW86IDQwLFxuICBhdWRpbzogMzIsXG4gIG1haW46IDQwXG59LCBPYSA9IChpKSA9PiB7XG4gIHN3aXRjaCAoaSkge1xuICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICByZXR1cm4gSmUudGV4dDtcbiAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIHJldHVybiBKZS5pbWFnZTtcbiAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgIHJldHVybiBKZS52aWRlbztcbiAgICBjYXNlIFwiYXVkaW9cIjpcbiAgICAgIHJldHVybiBKZS5hdWRpbztcbiAgICBjYXNlIFwiaGVscGVyVG9wXCI6XG4gICAgICByZXR1cm4gMWUzO1xuICAgIGNhc2UgXCJoZWxwZXJCb3R0b21cIjpcbiAgICAgIHJldHVybiAxZTM7XG4gICAgY2FzZSBcImhlbHBlckNlbnRlclwiOlxuICAgICAgcmV0dXJuIDg7XG4gICAgY2FzZSBcIm1haW5cIjpcbiAgICAgIHJldHVybiBKZS5tYWluO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSmUudGV4dDtcbiAgfVxufTtcbmNsYXNzIE15IHtcbiAgZmluZE9yQ3JlYXRlVHJhY2sodCwgeyB0cmFja0lkOiBlLCB0cmFja0luZGV4OiBzIH0pIHtcbiAgICBpZiAoZSkge1xuICAgICAgY29uc3QgbiA9IHRoaXMudHJhY2tzLmZpbmQoKG8pID0+IG8uaWQgPT09IGUpO1xuICAgICAgaWYgKG4pXG4gICAgICAgIHJldHVybiBuLml0ZW1zLnB1c2godC5pZCksIGU7XG4gICAgfVxuICAgIGNvbnN0IHIgPSB7XG4gICAgICBpZDogZ3IoKSxcbiAgICAgIGl0ZW1zOiBbdC5pZF0sXG4gICAgICB0eXBlOiB0LnR5cGUsXG4gICAgICBhY2NlcHRzOiB0aGlzLmFjY2VwdHNNYXBbdC50eXBlXSxcbiAgICAgIG1hZ25ldGljOiAhMSxcbiAgICAgIHN0YXRpYzogITFcbiAgICB9O1xuICAgIHJldHVybiBzICE9PSB2b2lkIDAgPyB0aGlzLnRyYWNrcy5zcGxpY2UocywgMCwgcikgOiB0aGlzLnRyYWNrcy5wdXNoKHIpLCB0aGlzLnJlbmRlclRyYWNrcygpLCByLmlkO1xuICB9XG4gIHJlbW92ZVRyYWNrcygpIHtcbiAgICB0aGlzLmdldE9iamVjdHMoXCJUcmFja1wiLCBcIkhlbHBlclwiKS5mb3JFYWNoKChlKSA9PiB0aGlzLnJlbW92ZShlKSk7XG4gIH1cbiAgcmVuZGVyVHJhY2tzKCkge1xuICAgIHRoaXMuZmlsdGVyRW1wdHlUcmFja3MoKSwgdGhpcy5yZW1vdmVUcmFja3MoKTtcbiAgICBjb25zdCB0ID0gdGhpcy53aWR0aCwgZSA9IHRoaXMudHJhY2tzLmZsYXRNYXAoXG4gICAgICAoYSkgPT4gW1xuICAgICAgICBhLFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IGBoZWxwZXItJHthLmlkfWAsXG4gICAgICAgICAgdHlwZTogXCJoZWxwZXJcIixcbiAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgYWNjZXB0czogW11cbiAgICAgICAgfVxuICAgICAgXVxuICAgICkuc2xpY2UoMCwgLTEpO1xuICAgIGxldCBzID0gLTk3MDtcbiAgICBjb25zdCByID0gQy5nZXRDbGFzcyhcIkhlbHBlclwiKSB8fCBTcywgbiA9IG5ldyByKHtcbiAgICAgIHRvcDogcyxcbiAgICAgIHNlbGVjdGFibGU6ICExLFxuICAgICAgZXZlbnRlZDogITEsXG4gICAgICB0U2NhbGU6IHRoaXMudFNjYWxlLFxuICAgICAgaWQ6IFwiaGVscGVyLWxpbmUtdG9wXCIsXG4gICAgICB3aWR0aDogdCxcbiAgICAgIGtpbmQ6IFwidG9wXCIsXG4gICAgICBoZWlnaHQ6IDFlMyxcbiAgICAgIG1ldGFkYXRhOiB7fVxuICAgIH0pO1xuICAgIHMgKz0gT2EoXCJoZWxwZXJUb3BcIiksIHRoaXMuaW5zZXJ0QXQoMCwgbiksIGUuZm9yRWFjaCgoYSwgYykgPT4ge1xuICAgICAgaWYgKGEudHlwZSA9PT0gXCJoZWxwZXJcIikge1xuICAgICAgICBjb25zdCBsID0gT2EoXCJoZWxwZXJDZW50ZXJcIiksIGggPSBuZXcgcih7XG4gICAgICAgICAgaWQ6IGEuaWQsXG4gICAgICAgICAgdG9wOiBzLFxuICAgICAgICAgIHRTY2FsZTogdGhpcy50U2NhbGUsXG4gICAgICAgICAgd2lkdGg6IHQsXG4gICAgICAgICAgaGVpZ2h0OiBsLFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICBvcmRlcjogKGMgKyAxKSAvIDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtpbmQ6IFwiY2VudGVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHMgKz0gbCwgdGhpcy5pbnNlcnRBdCgwLCBoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLnNpemVzTWFwW2EudHlwZV0sIGggPSBDLmdldENsYXNzKFwiVHJhY2tcIikgfHwgdWUsIHUgPSBuZXcgaCh7XG4gICAgICAgICAgaWQ6IGEuaWQsXG4gICAgICAgICAgdG9wOiBzLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgaGVpZ2h0OiBsLFxuICAgICAgICAgIHdpZHRoOiB0LFxuICAgICAgICAgIHRTY2FsZTogdGhpcy50U2NhbGUsXG4gICAgICAgICAgYWNjZXB0czogdGhpcy5hY2NlcHRzTWFwW2EudHlwZV0gfHwgW10sXG4gICAgICAgICAgaXRlbXM6IGEuaXRlbXMsXG4gICAgICAgICAgbWFnbmV0aWM6IGEubWFnbmV0aWMsXG4gICAgICAgICAgc3RhdGljOiBhLnN0YXRpY1xuICAgICAgICB9KTtcbiAgICAgICAgcyArPSBsLCB0aGlzLmluc2VydEF0KDAsIHUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG8gPSBuZXcgcih7XG4gICAgICBpZDogXCJoZWxwZXItbGluZS1ib3R0b21cIixcbiAgICAgIHRvcDogcyxcbiAgICAgIHNlbGVjdGFibGU6ICExLFxuICAgICAgZXZlbnRlZDogITEsXG4gICAgICB0U2NhbGU6IHRoaXMudFNjYWxlLFxuICAgICAgd2lkdGg6IHQsXG4gICAgICBraW5kOiBcImJvdHRvbVwiLFxuICAgICAgaGVpZ2h0OiAxZTMsXG4gICAgICBtZXRhZGF0YToge31cbiAgICB9KTtcbiAgICB0aGlzLmluc2VydEF0KDAsIG8pO1xuICB9XG4gIGZpbHRlckVtcHR5VHJhY2tzKCkge1xuICAgIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMudHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKChlKSA9PiAoZS5pdGVtcy5sZW5ndGggfHwgZS5zdGF0aWMpICYmICF0LmhhcyhlLmlkKSA/ICh0LmFkZChlLmlkKSwgITApIDogITEpO1xuICB9XG4gIHJlZnJlc2hUcmFja0xheW91dCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5ib3VuZGluZy53aWR0aCArIHRoaXMuc3BhY2luZy5yaWdodDtcbiAgICB0aGlzLmdldE9iamVjdHMoXCJUcmFja1wiLCBcIkhlbHBlclwiKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlLnVwZGF0ZUNvb3Jkcyh0KSwgZS5zZXRDb29yZHMoKTtcbiAgICB9KTtcbiAgfVxuICBhZGp1c3RNYWduZXRpY1RyYWNrKCkge1xuICAgIHRoaXMucGF1c2VFdmVudExpc3RlbmVycygpO1xuICAgIGNvbnN0IHQgPSB0aGlzLnRyYWNrcy5maWx0ZXIoKGUpID0+IGUubWFnbmV0aWMpO1xuICAgIHQubGVuZ3RoID4gMCAmJiB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBlLmFjY2VwdHMgfHwgW10sIHIgPSB0aGlzLmdldE9iamVjdHMoLi4ucykuZmlsdGVyKChvKSA9PiBlLml0ZW1zLmluY2x1ZGVzKG8uaWQpKS5zb3J0KChvLCBhKSA9PiBvLmxlZnQgLSBhLmxlZnQpO1xuICAgICAgbGV0IG4gPSAwO1xuICAgICAgci5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIG8ubGVmdCA9IG4sIG4gKz0gby53aWR0aDtcbiAgICAgIH0pO1xuICAgIH0pLCB0aGlzLnJlc3VtZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEZsKGkpIHtcbiAgY29uc3QgdCA9IHRoaXMsIGUgPSBpLnRhcmdldCwgcyA9IGkudHJhbnNmb3JtO1xuICBpZiAocy5hY3Rpb24gPT09IFwicmVzaXppbmdcIikge1xuICAgIGNvbnN0IHIgPSB0LmdldE9iamVjdHMoKS5maWx0ZXIoKGgpID0+IGggIT09IGUgJiYgIVtcIlRyYWNrXCIsIFwiSGVscGVyXCIsIFwiVHJhbnNpdGlvblwiLCBcIlBsYWNlaG9sZGVyXCJdLmluY2x1ZGVzKGgudHlwZSkpLCBuID0gMTAsIG8gPSBlLmxlZnQsIGEgPSBlLndpZHRoICogZS5zY2FsZVgsIGMgPSBvICsgYTtcbiAgICBsZXQgbCA9ICExO1xuICAgIHIuZm9yRWFjaCgoaCkgPT4ge1xuICAgICAgaWYgKGwpIHJldHVybjtcbiAgICAgIGNvbnN0IHUgPSBoLmdldEJvdW5kaW5nUmVjdCgpLCBkID0gdS5sZWZ0LCBmID0gdS5sZWZ0ICsgdS53aWR0aDtcbiAgICAgIGlmIChzLmNvcm5lciA9PT0gXCJtclwiKSB7XG4gICAgICAgIGNvbnN0IGcgPSBNYXRoLmFicyhjIC0gZiksIHAgPSBNYXRoLmFicyhjIC0gZCk7XG4gICAgICAgIGlmIChnIDwgbilcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIF90IHx8IGUgaW5zdGFuY2VvZiBmdCkge1xuICAgICAgICAgICAgY29uc3QgbSA9IGYgLSBlLmxlZnQsIGIgPSBtIC0gYSwgUyA9IFkoXG4gICAgICAgICAgICAgIGIsXG4gICAgICAgICAgICAgIGUudFNjYWxlLFxuICAgICAgICAgICAgICBlLnBsYXliYWNrUmF0ZVxuICAgICAgICAgICAgKSwgdyA9IGUudHJpbS50byArIFM7XG4gICAgICAgICAgICB3IDw9IGUuZHVyYXRpb24gJiYgKGUuc2V0KHtcbiAgICAgICAgICAgICAgd2lkdGg6IG0sXG4gICAgICAgICAgICAgIHNjYWxlWDogMVxuICAgICAgICAgICAgfSksIGUudHJpbS50byA9IHcsIGUub25SZXNpemVTbmFwICYmIGUub25SZXNpemVTbmFwKCksIGwgPSAhMCk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBlLnNldCh7XG4gICAgICAgICAgICAgIHdpZHRoOiBmIC0gZS5sZWZ0LFxuICAgICAgICAgICAgICBzY2FsZVg6IDFcbiAgICAgICAgICAgIH0pLCBlLm9uUmVzaXplU25hcCAmJiBlLm9uUmVzaXplU25hcCgpLCBsID0gITA7XG4gICAgICAgIGVsc2UgaWYgKHAgPCBuKVxuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX3QgfHwgZSBpbnN0YW5jZW9mIGZ0KSB7XG4gICAgICAgICAgICBjb25zdCBtID0gZCAtIGUubGVmdCwgYiA9IG0gLSBhLCBTID0gWShcbiAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgZS50U2NhbGUsXG4gICAgICAgICAgICAgIGUucGxheWJhY2tSYXRlXG4gICAgICAgICAgICApLCB3ID0gZS50cmltLnRvICsgUztcbiAgICAgICAgICAgIHcgPD0gZS5kdXJhdGlvbiAmJiAoZS5zZXQoe1xuICAgICAgICAgICAgICB3aWR0aDogbSxcbiAgICAgICAgICAgICAgc2NhbGVYOiAxXG4gICAgICAgICAgICB9KSwgZS50cmltLnRvID0gdywgZS5vblJlc2l6ZVNuYXAgJiYgZS5vblJlc2l6ZVNuYXAoKSwgbCA9ICEwKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGUuc2V0KHtcbiAgICAgICAgICAgICAgd2lkdGg6IGQgLSBlLmxlZnQsXG4gICAgICAgICAgICAgIHNjYWxlWDogMVxuICAgICAgICAgICAgfSksIGUub25SZXNpemVTbmFwICYmIGUub25SZXNpemVTbmFwKCksIGwgPSAhMDtcbiAgICAgIH0gZWxzZSBpZiAocy5jb3JuZXIgPT09IFwibWxcIikge1xuICAgICAgICBjb25zdCBnID0gTWF0aC5hYnMobyAtIGQpLCBwID0gTWF0aC5hYnMobyAtIGYpO1xuICAgICAgICBpZiAoZyA8IG4pXG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBfdCB8fCBlIGluc3RhbmNlb2YgZnQgfHwgZSBpbnN0YW5jZW9mIFZ0KSB7XG4gICAgICAgICAgICBjb25zdCBtID0gYyAtIGQsIGIgPSBtIC0gYSwgUyA9IFkoXG4gICAgICAgICAgICAgIGIsXG4gICAgICAgICAgICAgIGUudFNjYWxlLFxuICAgICAgICAgICAgICBlLnBsYXliYWNrUmF0ZVxuICAgICAgICAgICAgKSwgdyA9IGUudHJpbS5mcm9tIC0gUztcbiAgICAgICAgICAgIHcgPj0gMCAmJiAoZS5zZXQoe1xuICAgICAgICAgICAgICBsZWZ0OiBkLFxuICAgICAgICAgICAgICB3aWR0aDogbSxcbiAgICAgICAgICAgICAgc2NhbGVYOiAxXG4gICAgICAgICAgICB9KSwgZS50cmltLmZyb20gPSB3LCBlLm9uUmVzaXplU25hcCAmJiBlLm9uUmVzaXplU25hcCgpLCBsID0gITApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgZS5zZXQoe1xuICAgICAgICAgICAgICBsZWZ0OiBkLFxuICAgICAgICAgICAgICB3aWR0aDogYyAtIGQsXG4gICAgICAgICAgICAgIHNjYWxlWDogMVxuICAgICAgICAgICAgfSksIGUub25SZXNpemVTbmFwICYmIGUub25SZXNpemVTbmFwKCksIGwgPSAhMDtcbiAgICAgICAgZWxzZSBpZiAocCA8IG4pXG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBfdCB8fCBlIGluc3RhbmNlb2YgZnQgfHwgZSBpbnN0YW5jZW9mIFZ0KSB7XG4gICAgICAgICAgICBjb25zdCBtID0gYyAtIGYsIGIgPSBtIC0gYSwgUyA9IFkoXG4gICAgICAgICAgICAgIGIsXG4gICAgICAgICAgICAgIGUudFNjYWxlLFxuICAgICAgICAgICAgICBlLnBsYXliYWNrUmF0ZVxuICAgICAgICAgICAgKSwgdyA9IGUudHJpbS5mcm9tIC0gUztcbiAgICAgICAgICAgIHcgPj0gMCAmJiAoZS5zZXQoe1xuICAgICAgICAgICAgICBsZWZ0OiBmLFxuICAgICAgICAgICAgICB3aWR0aDogbSxcbiAgICAgICAgICAgICAgc2NhbGVYOiAxXG4gICAgICAgICAgICB9KSwgZS50cmltLmZyb20gPSB3LCBlLm9uUmVzaXplU25hcCAmJiBlLm9uUmVzaXplU25hcCgpLCBsID0gITApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgZS5zZXQoe1xuICAgICAgICAgICAgICBsZWZ0OiBmLFxuICAgICAgICAgICAgICB3aWR0aDogYyAtIGYsXG4gICAgICAgICAgICAgIHNjYWxlWDogMVxuICAgICAgICAgICAgfSksIGUub25SZXNpemVTbmFwICYmIGUub25SZXNpemVTbmFwKCksIGwgPSAhMDtcbiAgICAgIH1cbiAgICB9KSwgbCAmJiAoZS5zZXRDb29yZHMoKSwgdC5yZXF1ZXN0UmVuZGVyQWxsKCkpO1xuICB9XG59XG5mdW5jdGlvbiBJeShpKSB7XG4gIGkub24oXCJvYmplY3Q6cmVzaXppbmdcIiwgRmwuYmluZChpKSk7XG59XG5mdW5jdGlvbiBEeShpKSB7XG4gIGkub2ZmKFwib2JqZWN0OnJlc2l6aW5nXCIsIEZsLmJpbmQoaSkpO1xufVxuY29uc3QgVXMgPSAxMDAsIHRuID0gMCwgSHIgPSA1LCBrYSA9IDMsIGp5ID0gMjUsIHZzID0ge1xuICBzY3JvbGxJbnRlcnZhbDogbnVsbFxufTtcbmZ1bmN0aW9uIE1hKGkpIHtcbiAgY29uc3QgdCA9IGp5IC0ga2EsIGUgPSAoVXMgLSBpKSAvIFVzO1xuICByZXR1cm4ga2EgKyB0ICogZTtcbn1cbmZ1bmN0aW9uIEV5KGksIHQpIHtcbiAgdnMuc2Nyb2xsSW50ZXJ2YWwgJiYgY2xlYXJJbnRlcnZhbCh2cy5zY3JvbGxJbnRlcnZhbCk7XG4gIGNvbnN0IGUgPSB0LnRhcmdldCwgcyA9IGUuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIHZzLnNjcm9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGNvbnN0IHIgPSBpLnZpZXdwb3J0VHJhbnNmb3JtLCBuID0gaS5nZXRWaWV3cG9ydFBvaW50KHQuZSk7XG4gICAgaWYgKG4ueCA+IGkud2lkdGggLSBVcyAmJiBlLmxlZnQgKyBzLndpZHRoIDwgaS5ib3VuZGluZy53aWR0aCkge1xuICAgICAgY29uc3QgbyA9IE1hKGkud2lkdGggLSBuLngpO1xuICAgICAgZS5zZXQoXCJsZWZ0XCIsIGUubGVmdCArIG8pLCBpLnNldFZpZXdwb3J0UG9zKHJbNF0gLSBvLCByWzVdKTtcbiAgICB9XG4gICAgaWYgKG4ueCA8IFVzICYmIGUubGVmdCA+IDAgJiYgcls0XSA8IFVzKSB7XG4gICAgICBjb25zdCBvID0gTWEobi54KTtcbiAgICAgIGUuc2V0KFwibGVmdFwiLCBlLmxlZnQgLSBvKSwgaS5zZXRWaWV3cG9ydFBvcyhyWzRdICsgbywgcls1XSk7XG4gICAgfVxuICAgIG4ueSA+IGkuaGVpZ2h0IC0gdG4gJiYgZS50b3AgKyBzLmhlaWdodCA8IGkuYm91bmRpbmcuaGVpZ2h0ICsgODAgJiYgKGUuc2V0KFwidG9wXCIsIGUudG9wICsgSHIpLCBpLnNldFZpZXdwb3J0UG9zKHJbNF0sIHJbNV0gLSBIcikpLCBuLnkgPCB0biAmJiBlLnRvcCA+IC04MCAmJiAtcls1XSA+IHRuICYmIChlLnNldChcInRvcFwiLCBlLnRvcCAtIEhyKSwgaS5zZXRWaWV3cG9ydFBvcyhyWzRdLCByWzVdICsgSHIpKSwgZS5zZXRDb29yZHMoKSwgaS5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH0sIDE2KTtcbn1cbmZ1bmN0aW9uIFB5KCkge1xuICB2cy5zY3JvbGxJbnRlcnZhbCAmJiAoY2xlYXJJbnRlcnZhbCh2cy5zY3JvbGxJbnRlcnZhbCksIHZzLnNjcm9sbEludGVydmFsID0gbnVsbCk7XG59XG5mdW5jdGlvbiBSbCgpIHtcbiAgUHkoKTtcbn1cbmZ1bmN0aW9uIExsKGkpIHtcbiAgRXkodGhpcywgaSk7XG59XG5mdW5jdGlvbiBBeShpKSB7XG4gIGkub24oXCJtb3VzZTp1cFwiLCBSbCksIGkub24oXCJvYmplY3Q6bW92aW5nXCIsIExsLmJpbmQoaSkpO1xufVxuZnVuY3Rpb24gRnkoaSkge1xuICBpLm9mZihcIm1vdXNlOnVwXCIsIFJsKSwgaS5vZmYoXCJvYmplY3Q6bW92aW5nXCIsIExsLmJpbmQoaSkpO1xufVxuZnVuY3Rpb24gQmwoaSkge1xuICBjb25zdCB0ID0gaS50YXJnZXQsIGUgPSBpLnRhcmdldC5jYW52YXM7XG4gIGlmIChpLmFjdGlvbiA9PT0gXCJyZXNpemluZ1wiICYmIHQgaW5zdGFuY2VvZiBKdCAmJiBlKSB7XG4gICAgY29uc3QgcyA9IHQuaWQsIHIgPSBlLmdldE9iamVjdHMoXCJUcmFuc2l0aW9uXCIpLmZpbmQoKG4pID0+IG4uaWQgPT09IHMpO1xuICAgIGlmIChyICYmIHIgaW5zdGFuY2VvZiBKdCkge1xuICAgICAgY29uc3QgbiA9IFV0KHRoaXMudHJhbnNpdGlvbnNNYXApLCBvID0ge1xuICAgICAgICAuLi5uLFxuICAgICAgICBbc106IHtcbiAgICAgICAgICAuLi5uW3NdLFxuICAgICAgICAgIHdpZHRoOiByLndpZHRoLFxuICAgICAgICAgIGR1cmF0aW9uOiByLmR1cmF0aW9uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnRyYW5zaXRpb25zTWFwID0gbywgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gUnkoaSkge1xuICBpLm9uKFwib2JqZWN0Om1vZGlmaWVkXCIsIEJsKTtcbn1cbmZ1bmN0aW9uIEx5KGkpIHtcbiAgaS5vZmYoXCJvYmplY3Q6bW9kaWZpZWRcIiwgQmwpO1xufVxuY29uc3QgV2wgPSB7XG4gIGNhbnZhczogbnVsbCxcbiAgZW5hYmxlR3VpZGVSZWRyYXc6ICEwLFxuICBpc1BvaW50ZXJPdmVySGVscGVyVHJhY2s6ICExLFxuICBkcmFnZ2luZ092ZXJUcmFjazogbnVsbCxcbiAgcGxhY2Vob2xkZXJNb3ZpbmdPYmplY3RzOiBbXSxcbiAgcHJpbWFyeU1vdmluZ09iamVjdHM6IFtdLFxuICBzZWNvbmRhcnlNb3ZpbmdPYmplY3RzOiBbXSxcbiAgb2JqZWN0SW5pdGlhbFBvc2l0aW9uczoge30sXG4gIG9yaWdpblRyYWNrOiB7fSxcbiAgdHJhY2tUb0l0ZW1zTWFwOiB7fSxcbiAgYWN0aXZlVHJhY2tUb0l0ZW1zTWFwOiB7fSxcbiAgdHJhY2tUb3BUb0lkTWFwOiB7fSxcbiAgdHJhY2tUb3BzOiBbXSxcbiAgYWN0aXZlT2JqZWN0czogW10sXG4gIHByaW1hcnlUcmFja3M6IHt9LFxuICBzZWNvbmRhcnlUcmFja3M6IHt9LFxuICBpc0RyYWdPdmVyOiAhMSxcbiAgaW5pdGlhbFRyYWNrUG9pbnRzOiBbXSxcbiAgdXBkYXRlSXRlbXNJblRyYWNrOiBudWxsLFxuICBvcmRlck5vcm1hbFRyYWNrOiAhMVxufSwgUSA9ICgpID0+IFdsLCBhdCA9IChpKSA9PiB7XG4gIE9iamVjdC5hc3NpZ24oV2wsIGkpO1xufSwgSWEgPSAxMCwgUGkgPSAoaSwgdCkgPT4ge1xuICB0LmZvckVhY2goKGUpID0+IGUuaXNBbGlnbm1lbnRBdXhpbGlhcnkgJiYgaS5yZW1vdmUoZSkpO1xufSwgWGwgPSAoaSwgdCkgPT4ge1xuICBjb25zdCBlID0gW10sIHMgPSBbXTtcbiAgcmV0dXJuIHQuZ2V0T2JqZWN0cygpLmZpbHRlcigocikgPT4gci52aXNpYmxlKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgaWYgKGkuZmluZCgobykgPT4gby5pZCA9PT0gci5pZCkgfHwgci5pc0FsaWdubWVudEF1eGlsaWFyeSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gci5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICBlLnB1c2goXG4gICAgICBqYShuLmxlZnQsIG4ud2lkdGgsIG4udG9wLCBuLmhlaWdodClcbiAgICApLCBzLnB1c2goXG4gICAgICBqYShuLnRvcCwgbi5oZWlnaHQsIG4ubGVmdCwgbi53aWR0aClcbiAgICApO1xuICB9KSwge1xuICAgIHZlcnRpY2FsOiBlLmZsYXQoKSxcbiAgICBob3Jpem9udGFsOiBbXVxuICB9O1xufSwgemwgPSAoaSwgdCkgPT4ge1xuICBjb25zdCBlID0gW10sIHMgPSBbXTtcbiAgaS52ZXJ0aWNhbC5mb3JFYWNoKChhKSA9PiB7XG4gICAgdC52ZXJ0aWNhbC5mb3JFYWNoKChjKSA9PiB7XG4gICAgICBjb25zdCBsID0gTWF0aC5hYnMoYS52YWwgLSBjLmd1aWRlKTtcbiAgICAgIGwgPCBJYSAmJiBlLnB1c2goe1xuICAgICAgICBsaW5lR3VpZGU6IGEudmFsLFxuICAgICAgICBkaWZmOiBsLFxuICAgICAgICBvcmllbnRhdGlvbjogXCJWXCIsXG4gICAgICAgIHNuYXA6IGMuc25hcCxcbiAgICAgICAgb2Zmc2V0OiBjLm9mZnNldCxcbiAgICAgICAgdGFyZ2V0RGltOiB7IHN0YXJ0OiBhLnN0YXJ0LCBlbmQ6IGEuZW5kIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KSwgaS5ob3Jpem9udGFsLmZvckVhY2goKGEpID0+IHtcbiAgICB0Lmhvcml6b250YWwuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgY29uc3QgbCA9IE1hdGguYWJzKGEudmFsIC0gYy5ndWlkZSk7XG4gICAgICBsIDwgSWEgJiYgcy5wdXNoKHtcbiAgICAgICAgbGluZUd1aWRlOiBhLnZhbCxcbiAgICAgICAgZGlmZjogbCxcbiAgICAgICAgb3JpZW50YXRpb246IFwiSFwiLFxuICAgICAgICBzbmFwOiBjLnNuYXAsXG4gICAgICAgIG9mZnNldDogYy5vZmZzZXQsXG4gICAgICAgIHRhcmdldERpbTogeyBzdGFydDogYS5zdGFydCwgZW5kOiBhLmVuZCB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHIgPSBbXSwgbiA9IGUuc29ydCgoYSwgYykgPT4gYS5kaWZmIC0gYy5kaWZmKVswXSwgbyA9IHMuc29ydCgoYSwgYykgPT4gYS5kaWZmIC0gYy5kaWZmKVswXTtcbiAgcmV0dXJuIG4gJiYgci5wdXNoKHtcbiAgICBsaW5lR3VpZGU6IG4ubGluZUd1aWRlLFxuICAgIG9mZnNldDogbi5vZmZzZXQsXG4gICAgb3JpZW50YXRpb246IFwiVlwiLFxuICAgIHNuYXA6IG4uc25hcCxcbiAgICB0YXJnZXREaW06IG4udGFyZ2V0RGltXG4gIH0pLCBvICYmIHIucHVzaCh7XG4gICAgbGluZUd1aWRlOiBvLmxpbmVHdWlkZSxcbiAgICBvZmZzZXQ6IG8ub2Zmc2V0LFxuICAgIG9yaWVudGF0aW9uOiBcIkhcIixcbiAgICBzbmFwOiBvLnNuYXAsXG4gICAgdGFyZ2V0RGltOiBvLnRhcmdldERpbVxuICB9KSwgcjtcbn0sIEhsID0gKGksIHQsIGUpID0+IHtcbiAgaS5mb3JFYWNoKChzKSA9PiB7XG4gICAgY29uc3QgciA9IEJ5KGUuZ2V0Wm9vbSgpKTtcbiAgICBzLm9yaWVudGF0aW9uID09PSBcIkhcIiA/IGUuYWRkKFxuICAgICAgRGEoXG4gICAgICAgIFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIHMubGluZUd1aWRlIC0gci5zdHJva2VXaWR0aCAvIDIsXG4gICAgICAgICAgMmUzLFxuICAgICAgICAgIHMubGluZUd1aWRlIC0gci5zdHJva2VXaWR0aCAvIDJcbiAgICAgICAgXSxcbiAgICAgICAgeyAuLi5yLCBzdHJva2U6IGUuZ3VpZGVMaW5lQ29sb3IgfVxuICAgICAgKVxuICAgICkgOiBzLm9yaWVudGF0aW9uID09PSBcIlZcIiAmJiBlLmFkZChcbiAgICAgIERhKFxuICAgICAgICBbXG4gICAgICAgICAgcy5saW5lR3VpZGUgLSByLnN0cm9rZVdpZHRoIC8gMixcbiAgICAgICAgICAwLFxuICAgICAgICAgIHMubGluZUd1aWRlIC0gci5zdHJva2VXaWR0aCAvIDIsXG4gICAgICAgICAgMmUzXG4gICAgICAgIF0sXG4gICAgICAgIHsgLi4uciwgc3Ryb2tlOiBlLmd1aWRlTGluZUNvbG9yIH1cbiAgICAgIClcbiAgICApO1xuICB9KTtcbn0sIEJ5ID0gKGkpID0+ICh7XG4gIHN0cm9rZVdpZHRoOiAyIC8gaVxufSksIERhID0gKGksIHQpID0+IG5ldyBTZShpLCB7XG4gIC4uLnQsXG4gIHN0cm9rZUxpbmVDYXA6IFwic3F1YXJlXCIsXG4gIGV4Y2x1ZGVGcm9tRXhwb3J0OiAhMCxcbiAgaXNBbGlnbm1lbnRBdXhpbGlhcnk6ICEwLFxuICBzZWxlY3RhYmxlOiAhMSxcbiAgb2JqZWN0Q2FjaGluZzogITFcbn0pLCBZbCA9IChpKSA9PiB7XG4gIGNvbnN0IHQgPSBpLmdldEJvdW5kaW5nUmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHZlcnRpY2FsOiBbXG4gICAgICB7XG4gICAgICAgIGd1aWRlOiBNYXRoLnJvdW5kKHQubGVmdCksXG4gICAgICAgIG9mZnNldDogTWF0aC5yb3VuZChpLmxlZnQgLSB0LmxlZnQpLFxuICAgICAgICBzbmFwOiBcInN0YXJ0XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGd1aWRlOiBNYXRoLnJvdW5kKHQubGVmdCArIHQud2lkdGgpLFxuICAgICAgICBvZmZzZXQ6IE1hdGgucm91bmQoaS5sZWZ0IC0gdC5sZWZ0IC0gdC53aWR0aCksXG4gICAgICAgIHNuYXA6IFwiZW5kXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGhvcml6b250YWw6IFtcbiAgICAgIHtcbiAgICAgICAgZ3VpZGU6IE1hdGgucm91bmQodC50b3ApLFxuICAgICAgICBvZmZzZXQ6IE1hdGgucm91bmQoaS50b3AgLSB0LnRvcCksXG4gICAgICAgIHNuYXA6IFwic3RhcnRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZ3VpZGU6IE1hdGgucm91bmQodC50b3AgKyB0LmhlaWdodCksXG4gICAgICAgIG9mZnNldDogTWF0aC5yb3VuZChpLnRvcCAtIHQudG9wIC0gdC5oZWlnaHQpLFxuICAgICAgICBzbmFwOiBcImVuZFwiXG4gICAgICB9XG4gICAgXVxuICB9O1xufSwgamEgPSAoaSwgdCwgZSwgcykgPT4gW2ksIGkgKyB0XS5tYXAoKG4pID0+ICh7XG4gIHZhbDogbixcbiAgc3RhcnQ6IGUsXG4gIGVuZDogZSArIHNcbn0pKSwgVmwgPSAoaSwgdCkgPT4ge1xuICBpLnJlbW92ZSguLi50KSwgdCA9IFtdO1xufSwgR2wgPSAoaSkgPT4ge1xuICBpLmZvckVhY2goKHQpID0+IHQuc2V0U2VsZWN0ZWQoITEpKTtcbn0sIEVhID0gKGkpID0+IGkgaW5zdGFuY2VvZiBTcywgV3kgPSAoaSkgPT4gT2JqZWN0LmFzc2lnbih7fSwge1xuICBsZWZ0OiAxNixcbiAgcmlnaHQ6IDgwXG59LCBpKSwgWHkgPSBbXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIl0sIHp5ID0gKGkpID0+IFh5LmluY2x1ZGVzKGkudHlwZSkgfHwgaS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiO1xuZnVuY3Rpb24gTmwoaSkge1xuICBjb25zdCB0ID0gdGhpcztcbiAgaWYgKCF0KSByZXR1cm47XG4gIGNvbnN0IHMgPSBRKCkuZW5hYmxlR3VpZGVSZWRyYXcsIHIgPSB0LmdldFNjZW5lUG9pbnQoaS5lKSwgbiA9IHQuZ2V0T2JqZWN0cyhcIkhlbHBlclwiLCBcIlRyYWNrXCIpLCBvID0gbi5maW5kKChnKSA9PiB7XG4gICAgY29uc3QgcCA9IGcuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmV0dXJuIHIueCA+PSBwLmxlZnQgJiYgci54IDw9IHAubGVmdCArIHAud2lkdGggJiYgci55ID49IHAudG9wICYmIHIueSA8PSBwLnRvcCArIHAuaGVpZ2h0O1xuICB9KTtcbiAgYXQoeyBkcmFnZ2luZ092ZXJUcmFjazogbyB9KSwgbi5mb3JFYWNoKChnKSA9PiB7XG4gICAgRWEoZykgJiYgKGcgPT09IG8gPyBnLnNldFNlbGVjdGVkKCEwKSA6IGcuc2V0U2VsZWN0ZWQoITEpKTtcbiAgfSksIEVhKG8pID8gYXQoeyBpc1BvaW50ZXJPdmVySGVscGVyVHJhY2s6ICEwIH0pIDogYXQoeyBpc1BvaW50ZXJPdmVySGVscGVyVHJhY2s6ICExIH0pO1xuICBjb25zdCBhID0gdC5nZXRPYmplY3RzKCksIGMgPSBpLnRhcmdldCwgbCA9IGMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIGMuc2V0Q29vcmRzKCk7XG4gIGNvbnN0IGggPSBbXG4gICAgYyxcbiAgICAuLi50LmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAuLi50LmdldE9iamVjdHMoXCJUcmFja1wiLCBcIkhlbHBlclwiLCBcIlRyYW5zaXRpb25cIiwgXCJQbGFjZWhvbGRlclwiKVxuICBdLCB1ID0gWGwoaCwgdCksIGQgPSBZbChjKSwgZiA9IHpsKHUsIGQpO1xuICBzICYmIChQaSh0LCBhKSwgZi5sZW5ndGggJiYgSGwoZiwgbCwgdCksIGF0KHsgZW5hYmxlR3VpZGVSZWRyYXc6ICExIH0pLCBzZXRUaW1lb3V0KCgpID0+IGF0KHsgZW5hYmxlR3VpZGVSZWRyYXc6ICEwIH0pLCA1MCkpLCBmLmZvckVhY2goKGcpID0+IHtcbiAgICBnLm9yaWVudGF0aW9uID09PSBcIlZcIiA/IGMubGVmdCA9IGcubGluZUd1aWRlICsgZy5vZmZzZXQgOiBjLnRvcCA9IGcubGluZUd1aWRlICsgZy5vZmZzZXQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gVWwoaSkge1xuICBjb25zdCB0ID0gaS50YXJnZXQuY2FudmFzO1xuICB0ICYmIChQaSh0LCB0LmdldE9iamVjdHMoKSksIEdsKHQuZ2V0T2JqZWN0cyhcIkhlbHBlclwiKSksIGF0KHsgZHJhZ2dpbmdPdmVyVHJhY2s6IG51bGwsIGlzUG9pbnRlck92ZXJIZWxwZXJUcmFjazogITEgfSkpO1xufVxuZnVuY3Rpb24gJGwoaSkge1xuICB2YXIgYTtcbiAgY29uc3QgdCA9IHRoaXMsIGUgPSB0LmdldE9iamVjdHMoKSwgcyA9IGkudGFyZ2V0LCByID0gaS50cmFuc2Zvcm0sIG4gPSAoYSA9IHQuX2N1cnJlbnRUcmFuc2Zvcm0pID09IG51bGwgPyB2b2lkIDAgOiBhLmNvcm5lciwgbyA9IHMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIGlmIChyLmFjdGlvbiA9PT0gXCJyZXNpemluZ1wiKSB7XG4gICAgY29uc3QgYyA9IFtcbiAgICAgIHMsXG4gICAgICAuLi50LmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgIC4uLnQuZ2V0T2JqZWN0cyhcIlRyYWNrXCIsIFwiSGVscGVyXCIsIFwiVHJhbnNpdGlvblwiLCBcIlBsYWNlaG9sZGVyXCIpXG4gICAgXSwgbCA9IFhsKGMsIHQpLCBoID0gbC52ZXJ0aWNhbC5maWx0ZXIoXG4gICAgICAoZikgPT4ge1xuICAgICAgICBjb25zdCBnID0gZi52YWw7XG4gICAgICAgIGlmIChuID09PSBcIm1sXCIpXG4gICAgICAgICAgcmV0dXJuIGcgPD0gby5sZWZ0O1xuICAgICAgICBpZiAobiA9PT0gXCJtclwiKVxuICAgICAgICAgIHJldHVybiBnID49IG8ubGVmdCArIG8ud2lkdGg7XG4gICAgICB9XG4gICAgKTtcbiAgICBsLnZlcnRpY2FsID0gaDtcbiAgICBjb25zdCB1ID0gWWwocyksIGQgPSB6bChsLCB1KTtcbiAgICBQaSh0LCBlKSwgZC5sZW5ndGggJiYgSGwoZCwgbywgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEh5KGkpIHtcbiAgaS5vbihcIm9iamVjdDptb3ZpbmdcIiwgTmwuYmluZChpKSksIGkub24oXCJvYmplY3Q6bW9kaWZpZWRcIiwgVWwuYmluZChpKSksIGkub24oXCJvYmplY3Q6cmVzaXppbmdcIiwgJGwuYmluZChpKSk7XG59XG5mdW5jdGlvbiBZeShpKSB7XG4gIGkub2ZmKFwib2JqZWN0Om1vdmluZ1wiLCBObC5iaW5kKGkpKSwgaS5vZmYoXCJvYmplY3Q6bW9kaWZpZWRcIiwgVWwuYmluZChpKSksIGkub2ZmKFwib2JqZWN0OnJlc2l6aW5nXCIsICRsLmJpbmQoaSkpO1xufVxuZnVuY3Rpb24gSW4oaSwgdCwgZSkge1xuICBjb25zdCBzID0gaS5pbmRleE9mKHQpLCByID0gaS5pbmRleE9mKGUpO1xuICByZXR1cm4gcyA9PT0gLTEgfHwgciA9PT0gLTEgPyBudWxsIDogciAtIHM7XG59XG5mdW5jdGlvbiBxbChpLCB0KSB7XG4gIGNvbnN0IGUgPSB0LnNvcnQoKHIsIG4pID0+IHIudGVtcEluZGV4IC0gbi50ZW1wSW5kZXgpLCBzID0gW107XG4gIGZvciAoY29uc3QgciBvZiBlKVxuICAgIHIudGVtcEluZGV4IDwgMCAmJiBzLnB1c2gocik7XG4gIHMucHVzaChpKTtcbiAgZm9yIChjb25zdCByIG9mIGUpXG4gICAgci50ZW1wSW5kZXggPj0gMCAmJiBzLnB1c2gocik7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gS2woaSkge1xuICBjb25zdCB0ID0gUSgpLCBlID0gdC5jYW52YXM7XG4gIGF0KHtcbiAgICBhY3RpdmVUcmFja1RvSXRlbXNNYXA6IHt9LFxuICAgIHByaW1hcnlUcmFja3M6IHt9LFxuICAgIHNlY29uZGFyeVRyYWNrczoge30sXG4gICAgdHJhY2tUb3BzOiBbXSxcbiAgICB0cmFja1RvSXRlbXNNYXA6IHt9LFxuICAgIGFjdGl2ZU9iamVjdHM6IFtdLFxuICAgIHRyYWNrVG9wVG9JZE1hcDoge30sXG4gICAgaXNEcmFnT3ZlcjogITEsXG4gICAgaW5pdGlhbFRyYWNrUG9pbnRzOiBbXSxcbiAgICB1cGRhdGVJdGVtc0luVHJhY2s6IG51bGxcbiAgfSksIGUudHJhY2tJZEFmdGVyVHJhbnNmb3JtID0gXCJcIiwgZS5wb3NpdGlvbkFmdGVyVHJhbnNmb3JtID0ge307XG4gIGNvbnN0IHMgPSBlLmdldEFjdGl2ZU9iamVjdCgpLCByID0gcyBpbnN0YW5jZW9mIE90ID8gcy5nZXRPYmplY3RzKCkgOiBbc107XG4gIGF0KHsgYWN0aXZlT2JqZWN0czogciB9KTtcbiAgY29uc3QgbiA9IGUuZ2V0U2NlbmVQb2ludChpLmUpLCBvID0gZS5nZXRPYmplY3RzKFwiVHJhY2tcIiksIGEgPSBlLmdldEFjdGl2ZU9iamVjdHMoKS5tYXAoKHUpID0+IHUuaWQpO1xuICBsZXQgbCA9IG8uZmlsdGVyKCh1KSA9PiB7XG4gICAgY29uc3QgZCA9IHUuaXRlbXM7XG4gICAgcmV0dXJuIGEuc29tZSgoZikgPT4gZC5pbmNsdWRlcyhmKSk7XG4gIH0pLmZpbmQoKHUpID0+IHtcbiAgICBjb25zdCBkID0gdS5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICByZXR1cm4gbi54ID49IGQubGVmdCAmJiBuLnggPD0gZC5sZWZ0ICsgZC53aWR0aCAmJiBuLnkgPj0gZC50b3AgJiYgbi55IDw9IGQudG9wICsgZC5oZWlnaHQ7XG4gIH0pO1xuICBhdCh7IG9yaWdpblRyYWNrOiBsIH0pO1xuICBjb25zdCBoID0gZS5nZXRPYmplY3RzKFxuICAgIFwiVmlkZW9cIixcbiAgICBcIkltYWdlXCIsXG4gICAgXCJBdWRpb1wiLFxuICAgIFwiVGV4dFwiLFxuICAgIFwiRWxlbWVudFwiLFxuICAgIFwiVGVtcGxhdGVcIlxuICApO1xuICBvLmZvckVhY2goKHUpID0+IHtcbiAgICBjb25zdCBkID0gaC5maWx0ZXIoKGYpID0+IHUuaXRlbXMuaW5jbHVkZXMoZi5pZCkpO1xuICAgIHQudHJhY2tUb0l0ZW1zTWFwW3UuaWRdID0gZCwgdC50cmFja1RvcFRvSWRNYXBbdS50b3BdID0gdS5pZCwgdC50cmFja1RvcHMucHVzaCh1LnRvcCk7XG4gIH0pLCB0LnRyYWNrVG9wcy5zb3J0KCh1LCBkKSA9PiB1IC0gZCksIHIuZm9yRWFjaCgodSkgPT4ge1xuICAgIGNvbnN0IGQgPSBvLmZpbmQoKGcpID0+IGcuaXRlbXMuaW5jbHVkZXModS5pZCkpO1xuICAgIGlmICghZCkgcmV0dXJuO1xuICAgIGNvbnN0IGYgPSBkLmlkO1xuICAgIHQuYWN0aXZlVHJhY2tUb0l0ZW1zTWFwW2ZdID8gdC5hY3RpdmVUcmFja1RvSXRlbXNNYXBbZl0ucHVzaCh1KSA6IHQuYWN0aXZlVHJhY2tUb0l0ZW1zTWFwW2ZdID0gW3VdO1xuICB9KSwgdC5wcmltYXJ5TW92aW5nT2JqZWN0cyA9IHIuZmlsdGVyKCh1KSA9PiB7XG4gICAgY29uc3QgZCA9IHUuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmV0dXJuIG4ueSA+PSBkLnRvcCAmJiBuLnkgPD0gZC50b3AgKyBkLmhlaWdodCAmJiAhKHUgaW5zdGFuY2VvZiBKdCk7XG4gIH0pLCB0LnByaW1hcnlNb3ZpbmdPYmplY3RzLmxlbmd0aCAhPT0gMCAmJiAodC5wcmltYXJ5TW92aW5nT2JqZWN0cy5mb3JFYWNoKCh1KSA9PiB7XG4gICAgY29uc3QgZCA9IHUuZ2V0Qm91bmRpbmdSZWN0KCkudG9wLCBmID0gdC50cmFja1RvcFRvSWRNYXBbZF07XG4gICAgaWYgKHQucHJpbWFyeVRyYWNrc1tmXSlcbiAgICAgIHQucHJpbWFyeVRyYWNrc1tmXS5vYmplY3RzLnB1c2godSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBnID0gSW4oXG4gICAgICAgIHQudHJhY2tUb3BzLFxuICAgICAgICBsID09IG51bGwgPyB2b2lkIDAgOiBsLnRvcCxcbiAgICAgICAgZFxuICAgICAgKTtcbiAgICAgIHQucHJpbWFyeVRyYWNrc1tmXSA9IHtcbiAgICAgICAgb2JqZWN0czogW3VdLFxuICAgICAgICBpbmRleDogZ1xuICAgICAgfTtcbiAgICB9XG4gIH0pLCB0LnByaW1hcnlNb3ZpbmdPYmplY3RzID0gdC5wcmltYXJ5TW92aW5nT2JqZWN0cy5zb3J0KFxuICAgICh1LCBkKSA9PiB1LmxlZnQgLSBkLmxlZnRcbiAgKSwgdC5zZWNvbmRhcnlNb3ZpbmdPYmplY3RzID0gci5maWx0ZXIoXG4gICAgKHUpID0+ICF0LnByaW1hcnlNb3ZpbmdPYmplY3RzLmluY2x1ZGVzKHUpXG4gICksIHQuc2Vjb25kYXJ5TW92aW5nT2JqZWN0cy5mb3JFYWNoKCh1KSA9PiB7XG4gICAgY29uc3QgZCA9IHUuZ2V0Qm91bmRpbmdSZWN0KCkudG9wLCBmID0gdC50cmFja1RvcFRvSWRNYXBbdS5nZXRCb3VuZGluZ1JlY3QoKS50b3BdO1xuICAgIGlmICh0LnNlY29uZGFyeVRyYWNrc1tmXSlcbiAgICAgIHQuc2Vjb25kYXJ5VHJhY2tzW2ZdLm9iamVjdHMucHVzaCh1KTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGcgPSBJbihcbiAgICAgICAgdC50cmFja1RvcHMsXG4gICAgICAgIGwudG9wLFxuICAgICAgICBkXG4gICAgICApO1xuICAgICAgdC5zZWNvbmRhcnlUcmFja3NbZl0gPSB7XG4gICAgICAgIG9iamVjdHM6IFt1XSxcbiAgICAgICAgaW5kZXg6IGdcbiAgICAgIH07XG4gICAgfVxuICB9KSwgbCAmJiAoZS50cmFja09yaWdpbkJlZm9yZVRyYW5zZm9ybSA9IGwuaWQpLCBzICYmIChlLnBvc2l0aW9uQmVmb3JlVHJhbnNmb3JtID0ge1xuICAgIHRvcDogcy50b3AsXG4gICAgbGVmdDogcy5sZWZ0XG4gIH0pLCBpLnRyYW5zZm9ybS5hY3Rpb24gPT09IFwiZHJhZ1wiICYmICh0LnBsYWNlaG9sZGVyTW92aW5nT2JqZWN0cyA9IHQucHJpbWFyeU1vdmluZ09iamVjdHMubWFwKCh1KSA9PiB7XG4gICAgY29uc3QgZCA9IHUuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdC5vYmplY3RJbml0aWFsUG9zaXRpb25zW3UuaWRdID0ge1xuICAgICAgdG9wOiBkLnRvcCxcbiAgICAgIGxlZnQ6IGQubGVmdFxuICAgIH07XG4gICAgY29uc3QgZiA9IG5ldyBlcih7XG4gICAgICBpZDogYCR7dS5pZH0tcGxhY2Vob2xkZXJgLFxuICAgICAgbGVmdDogZC5sZWZ0LFxuICAgICAgdG9wOiBkLnRvcCxcbiAgICAgIHdpZHRoOiBkLndpZHRoLFxuICAgICAgaGVpZ2h0OiBkLmhlaWdodFxuICAgIH0pO1xuICAgIHJldHVybiBmLmRyYWdnZWRPYmplY3QgPSB1LCBmO1xuICB9KSwgZS5hZGQoLi4udC5wbGFjZWhvbGRlck1vdmluZ09iamVjdHMpKSk7XG59XG5mdW5jdGlvbiBWeShpKSB7XG4gIGkub24oXCJiZWZvcmU6dHJhbnNmb3JtXCIsIEtsLmJpbmQoaSkpO1xufVxuZnVuY3Rpb24gR3koaSkge1xuICBpLm9mZihcImJlZm9yZTp0cmFuc2Zvcm1cIiwgS2wuYmluZChpKSk7XG59XG5jb25zdCBncyA9IGNsYXNzIGdzIGV4dGVuZHMgWCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKTtcbiAgICBUKHRoaXMsIFwiZHVyYXRpb25cIik7XG4gICAgVCh0aGlzLCBcImZyb21JZFwiKTtcbiAgICBUKHRoaXMsIFwidG9JZFwiKTtcbiAgICBUKHRoaXMsIFwiaXRlbVR5cGVcIiwgXCJub25lXCIpO1xuICAgIFQodGhpcywgXCJpc1NlbGVjdGVkXCIsICExKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGdzLm93bkRlZmF1bHRzKSwgdGhpcy5pZCA9IGUuaWQ7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUNvbnRyb2xzKCkge1xuICAgIHJldHVybiB7IGNvbnRyb2xzOiBtbCgpIH07XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXREZWZhdWx0cygpLFxuICAgICAgLi4uZ3Mub3duRGVmYXVsdHNcbiAgICB9O1xuICB9XG4gIHVwZGF0ZUNvb3JkcygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jYW52YXM7XG4gICAgaWYgKCFlKSByZXR1cm47XG4gICAgY29uc3QgcyA9IGUuZ2V0T2JqZWN0cygpLmZpbmQoKG8pID0+IG8uaWQgPT09IHRoaXMuZnJvbUlkKTtcbiAgICBpZiAoIXMpIHJldHVybjtcbiAgICBjb25zdCByID0gRCh0aGlzLmR1cmF0aW9uLCB0aGlzLnRTY2FsZSksIG4gPSBzLmxlZnQgKyBzLndpZHRoIC0gciAvIDI7XG4gICAgdGhpcy5zZXQoe1xuICAgICAgd2lkdGg6IHIsXG4gICAgICBsZWZ0OiBuXG4gICAgfSk7XG4gIH1cbiAgLy8gYWRkIGN1c3RvbSB0ZXh0IHRvIHRoZSB0cmFjayBpdGVtXG4gIF9yZW5kZXIoZSkge1xuICAgIHN1cGVyLl9yZW5kZXIoZSksIHRoaXMuZHJhd1RleHRJZGVudGl0eShlKSwgdGhpcy51cGRhdGVTZWxlY3RlZChlKTtcbiAgfVxuICBkcmF3VGV4dElkZW50aXR5KGUpIHtcbiAgICBjb25zdCBzID0gbmV3IFBhdGgyRChcbiAgICAgIFwiTTMgNS4zMDM1OUMzIDMuOTMxNTkgNC42NTkgMy4yNDM1OSA1LjYyOSA0LjIxMzU5TDExLjk5NyAxMC41ODI2TDEwLjU4MyAxMS45OTY2TDUgNi40MTM1OVYxNy41ODU2TDEwLjU4NiAxMS45OTk2TDEwLjU4MyAxMS45OTY2TDExLjk5NyAxMC41ODI2TDEyIDEwLjU4NTZMMTguMzcxIDQuMjE0NTlDMTkuMzQxIDMuMjQ0NTkgMjEgMy45MzE1OSAyMSA1LjMwMzU5VjE4LjY5NTZDMjEgMjAuMDY3NiAxOS4zNDEgMjAuNzU1NiAxOC4zNzEgMTkuNzg1NkwxMiAxMy41TDEzLjQxNCAxMS45OTk2TDE5IDE3LjU4NjZWNi40MTM1OUwxMy40MTQgMTEuOTk5NkwxMy40MjEgMTIuMDA1NkwxMi4wMDYgMTMuNDIwNkwxMiAxMy40MTM2TDUuNjI5IDE5Ljc4NDZDNC42NTkgMjAuNzU0NiAzIDIwLjA2NzYgMyAxOC42OTU2VjUuMzAzNTlaXCJcbiAgICApO1xuICAgIGUuc2F2ZSgpLCBlLnRyYW5zbGF0ZSgtMTIsIC0xMiksIGUuZmlsbFN0eWxlID0gXCIjZmZmZmZmXCIsIGUuZmlsbChzKSwgZS5yZXN0b3JlKCk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZSkge1xuICAgIHRoaXMuaXNTZWxlY3RlZCA9IGUsIHRoaXMuc2V0KHsgZGlydHk6ICEwIH0pO1xuICB9XG4gIHVwZGF0ZVNlbGVjdGVkKGUpIHtcbiAgICB0aGlzLmlzU2VsZWN0ZWQgJiYgKGUuc2F2ZSgpLCBlLmJlZ2luUGF0aCgpLCBlLnJvdW5kUmVjdChcbiAgICAgIC10aGlzLndpZHRoIC8gMixcbiAgICAgIC10aGlzLmhlaWdodCAvIDIsXG4gICAgICB0aGlzLndpZHRoLFxuICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICB0aGlzLnJ4XG4gICAgKSwgZS5saW5lV2lkdGggPSBJdCwgZS5zdHJva2VTdHlsZSA9IHZ0LCBlLnN0cm9rZSgpLCBlLnJlc3RvcmUoKSk7XG4gIH1cbn07XG5UKGdzLCBcInR5cGVcIiwgXCJUcmFuc2l0aW9uR3VpZGVcIiksIFQoZ3MsIFwib3duRGVmYXVsdHNcIiwge1xuICBvYmplY3RDYWNoaW5nOiAhMSxcbiAgYm9yZGVyQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsXG4gIHN0cm9rZVdpZHRoOiAxLjUsXG4gIGZpbGw6IFwicmdiYSgwLDAsMCwgMC44NSlcIixcbiAgYm9yZGVyT3BhY2l0eVdoZW5Nb3Zpbmc6IDEsXG4gIGhvdmVyQ3Vyc29yOiBcImRlZmF1bHRcIixcbiAgbG9ja01vdmVtZW50WDogITAsXG4gIGxvY2tNb3ZlbWVudFk6ICEwLFxuICBkdXJhdGlvbjogMTUwMCxcbiAgcng6IDgsXG4gIHJ5OiA4XG59KTtcbmxldCBvciA9IGdzO1xuY29uc3QgTnkgPSBbXG4gIFwidGV4dFwiLFxuICBcImltYWdlXCIsXG4gIFwidmlkZW9cIixcbiAgXCJhdWRpb1wiLFxuICBcImNhcHRpb25cIixcbiAgXCJ0ZW1wbGF0ZVwiXG5dO1xuZnVuY3Rpb24gSmwoKSB7XG4gIGNvbnN0IGkgPSBRKCk7XG4gIFZsKHRoaXMsIGkucGxhY2Vob2xkZXJNb3ZpbmdPYmplY3RzKTtcbn1cbmZ1bmN0aW9uIFV5KGkpIHtcbiAgY29uc3QgdCA9IGkudGFyZ2V0LmxlZnQ7XG4gIGkudGFyZ2V0LmxlZnQgPSBNYXRoLm1heCh0LCAwKTtcbn1cbmZ1bmN0aW9uIFpsKGksIHQpIHtcbiAgcmV0dXJuIGkuZmluZCgocykgPT4ge1xuICAgIGNvbnN0IHIgPSBzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHJldHVybiB0LmxlZnQgPCByLmxlZnQgKyByLndpZHRoICYmIHQubGVmdCArIHQud2lkdGggLSAxID4gci5sZWZ0ICYmIHQudG9wIDwgci50b3AgKyByLmhlaWdodCAmJiB0LnRvcCArIHQuaGVpZ2h0ID4gci50b3A7XG4gIH0pO1xufVxuZnVuY3Rpb24gJHkoaSwgdCkge1xuICBjb25zdCBzID0gaS5jYW52YXMuZ2V0QWN0aXZlT2JqZWN0KCksIHIgPSBzLmxlZnQgKyBzLndpZHRoIC8gMiwgbiA9IHQubGVmdCArIHQud2lkdGggLyAyO1xuICByZXR1cm4gciA8IG4gPyB0LmxlZnQgLSBzLndpZHRoIDogKHIgPiBuLCB0LmxlZnQgKyB0LndpZHRoKTtcbn1cbmNvbnN0IHF5ID0gKGksIHQsIGUpID0+ICEoZSA8IDAgfHwgWmwoaSwge1xuICAuLi50LmdldEJvdW5kaW5nUmVjdCgpLFxuICBsZWZ0OiBlXG59KSksIFFsID0gKGkpID0+IHtcbiAgY29uc3QgZSA9IFEoKS5kcmFnZ2luZ092ZXJUcmFjaztcbiAgcmV0dXJuIGkgaW5zdGFuY2VvZiBPZSA/IGUgJiYgZS5hY2NlcHRzLmluY2x1ZGVzKGkuaXRlbVR5cGUpIDogZSAmJiBlLmFjY2VwdHMuaW5jbHVkZXMoaS50eXBlKTtcbn07XG5mdW5jdGlvbiBLeShpKSB7XG4gIFEoKS5pc1BvaW50ZXJPdmVySGVscGVyVHJhY2sgPyBpLm9wYWNpdHkgPSAwIDogaS5vcGFjaXR5ID0gMTtcbn1cbmZ1bmN0aW9uIEp5KCkge1xuICBjb25zdCBpID0gUSgpLCB0ID0gaS5wcmltYXJ5TW92aW5nT2JqZWN0c1swXTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGkub2JqZWN0SW5pdGlhbFBvc2l0aW9uc1t0LmlkXS50b3AsXG4gICAgbGVmdDogaS5vYmplY3RJbml0aWFsUG9zaXRpb25zW3QuaWRdLmxlZnRcbiAgfTtcbn1cbmZ1bmN0aW9uIFp5KGkpIHtcbiAgY29uc3QgdCA9IGkuZ2V0Qm91bmRpbmdSZWN0KCksIGUgPSBRKCksIHMgPSBlLmRyYWdnaW5nT3ZlclRyYWNrO1xuICBpZiAoZS5wcmltYXJ5TW92aW5nT2JqZWN0cy5tYXAoKG4pID0+IG4uaWQpLmluY2x1ZGVzKGkuaWQpKSB7XG4gICAgY29uc3QgbyA9IGUucHJpbWFyeU1vdmluZ09iamVjdHNbMF0uZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcy50b3AsXG4gICAgICBsZWZ0OiBvLmxlZnRcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9wOiBzLnRvcCxcbiAgICBsZWZ0OiB0LmxlZnRcbiAgfTtcbn1cbmZ1bmN0aW9uIFF5KGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IGkuY2FudmFzLmdldEFjdGl2ZU9iamVjdHMoKS5tYXAoKGgpID0+IGguaWQpLCBvID0gJHkoaSwgdCksIGEgPSBlLmZpbHRlcihcbiAgICAoaCkgPT4gIW4uaW5jbHVkZXMoaC5pZClcbiAgKSwgYyA9IHF5KFxuICAgIGEsXG4gICAgaSxcbiAgICBvXG4gICksIGwgPSBRKCk7XG4gIGlmIChsLm9yZGVyTm9ybWFsVHJhY2sgPSAhMCwgIWMgfHwgcy54IC0gMjAgPCAwKSB7XG4gICAgY29uc3QgaCA9IGwuZHJhZ2dpbmdPdmVyVHJhY2s7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGwuaW5pdGlhbFRyYWNrUG9pbnRzLnJlZHVjZShcbiAgICAgICAgKGQsIGYpID0+IE1hdGguYWJzKGYgLSBzLngpIDwgTWF0aC5hYnMoZCAtIHMueCkgPyBmIDogZFxuICAgICAgKSxcbiAgICAgIHRvcDogaC50b3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbGVmdDogbyxcbiAgICB0b3A6IHQudG9wXG4gIH07XG59XG5jb25zdCB0MCA9IChpLCB0KSA9PiB7XG4gIGkuZm9yRWFjaCgoZSwgcykgPT4ge1xuICAgIGUuc2V0KHsgbGVmdDogdFtzXSB9KTtcbiAgfSk7XG59LCB0aCA9IHd5KFxuICAoaSkgPT4ge1xuICAgIGNvbnN0IHQgPSBpLnRhcmdldC5jYW52YXM7XG4gICAgVXkoaSk7XG4gICAgY29uc3QgZSA9IFEoKSwgcyA9IGUuZHJhZ2dpbmdPdmVyVHJhY2s7XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IGEgPSBlLnByaW1hcnlNb3ZpbmdPYmplY3RzWzBdO1xuICAgICAgTnkuaW5jbHVkZXMoYS50eXBlKSAmJiBlLnBsYWNlaG9sZGVyTW92aW5nT2JqZWN0cy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIGMudmlzaWJsZSA9ICEwO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGUucGxhY2Vob2xkZXJNb3ZpbmdPYmplY3RzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgYS52aXNpYmxlID0gITE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgciA9IGUucGxhY2Vob2xkZXJNb3ZpbmdPYmplY3RzLm1hcChcbiAgICAgIChhKSA9PiBhLmRyYWdnZWRPYmplY3RcbiAgICApLCBuID0gKGUudHJhY2tUb0l0ZW1zTWFwW3MuaWRdIHx8IFtdKS5maWx0ZXIoKGEpID0+ICFyLmluY2x1ZGVzKGEpKSwgbyA9IFFsKGUucHJpbWFyeU1vdmluZ09iamVjdHNbMF0pO1xuICAgIGlmIChzLm1hZ25ldGljICYmIG8pIHtcbiAgICAgIGUudXBkYXRlSXRlbXNJblRyYWNrID8gZS51cGRhdGVJdGVtc0luVHJhY2sgIT09IHMuaWQgJiYgKGUudXBkYXRlSXRlbXNJblRyYWNrID0gcy5pZCwgZS5pbml0aWFsVHJhY2tQb2ludHMgPSBbXSkgOiAoZS51cGRhdGVJdGVtc0luVHJhY2sgPSBzLmlkLCBlLmluaXRpYWxUcmFja1BvaW50cyA9IFtdKSwgZS5pbml0aWFsVHJhY2tQb2ludHMubGVuZ3RoID09PSAwICYmIChlLnVwZGF0ZUl0ZW1zSW5UcmFjayA9IHMuaWQsIGUuaW5pdGlhbFRyYWNrUG9pbnRzID0gUGEoXG4gICAgICAgIGUsXG4gICAgICAgIHNcbiAgICAgICkpO1xuICAgICAgbGV0IGEgPSAwO1xuICAgICAgZm9yIChjb25zdCBbYywgbF0gb2YgZS5pbml0aWFsVHJhY2tQb2ludHMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGggPSBsLCB1ID0gZS5pbml0aWFsVHJhY2tQb2ludHNbYyArIDFdLCBkID0gZS5pbml0aWFsVHJhY2tQb2ludHNbYyAtIDFdLCBmID0gdSAtIGgsIGcgPSBoIC0gZDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgIGEgPSBoO1xuICAgICAgICBlbHNlIGlmIChoIDw9IGkucG9pbnRlci54ICYmIGggKyBmIC8gMiA+PSBpLnBvaW50ZXIueCkge1xuICAgICAgICAgIGEgPSBoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGggLSBnIC8gMiA8PSBpLnBvaW50ZXIueCAmJiBpLnBvaW50ZXIueCA8PSBoKSB7XG4gICAgICAgICAgYSA9IGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGUucGxhY2Vob2xkZXJNb3ZpbmdPYmplY3RzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgYy5vcGFjaXR5ID0gMSwgYy5sZWZ0ID0gYSwgYy50b3AgPSBzLnRvcCwgYSArPSBjLndpZHRoO1xuICAgICAgfSksIGUucGxhY2Vob2xkZXJNb3ZpbmdPYmplY3RzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgY29uc3QgbCA9IGMuZHJhZ2dlZE9iamVjdDtcbiAgICAgICAgdC5wb3NpdGlvbkFmdGVyVHJhbnNmb3JtW2wuaWRdID0ge1xuICAgICAgICAgIHRvcDogYy50b3AsXG4gICAgICAgICAgbGVmdDogYy5sZWZ0XG4gICAgICAgIH07XG4gICAgICB9KSwgdC50cmFja0lkQWZ0ZXJUcmFuc2Zvcm0gPSBlLnRyYWNrVG9wVG9JZE1hcFtzLnRvcF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGUub3JkZXJOb3JtYWxUcmFjayA9ICExLCBlLnVwZGF0ZUl0ZW1zSW5UcmFjayAmJiBlLnVwZGF0ZUl0ZW1zSW5UcmFjayAhPT0gcy5pZCAmJiAodC5nZXRPYmplY3RzKCkuZmluZCgoZikgPT4gZi5pZCA9PT0gZS51cGRhdGVJdGVtc0luVHJhY2spLm1hZ25ldGljID8gZTAodCwgZSkgOiB0LnVwZGF0ZVRyYWNrSXRlbUNvb3JkcyghMCksIGUudXBkYXRlSXRlbXNJblRyYWNrID0gbnVsbCwgZS5pbml0aWFsVHJhY2tQb2ludHMgPSBbXSksIGUuaW5pdGlhbFRyYWNrUG9pbnRzLmxlbmd0aCA9PT0gMCAmJiBzIGluc3RhbmNlb2YgdWUgJiYgKGUudXBkYXRlSXRlbXNJblRyYWNrID0gcy5pZCwgZS5pbml0aWFsVHJhY2tQb2ludHMgPSBQYShcbiAgICAgICAgZSxcbiAgICAgICAgc1xuICAgICAgKSk7XG4gICAgICBjb25zdCBhID0gbi5maW5kKChkKSA9PiBabChcbiAgICAgICAgcixcbiAgICAgICAgZC5nZXRCb3VuZGluZ1JlY3QoKVxuICAgICAgKSksIGMgPSBbXSwgaCA9IGUucHJpbWFyeU1vdmluZ09iamVjdHMuc29ydCgoZCwgZikgPT4gZC5sZWZ0IC0gZi5sZWZ0KSwgdSA9IGhbMF07XG4gICAgICBoLmZvckVhY2goKGQsIGYpID0+IHtcbiAgICAgICAgaWYgKCFoW2YgLSAxXSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBnID0gZC5sZWZ0IC0gdS5sZWZ0O1xuICAgICAgICBjLnB1c2goZyk7XG4gICAgICB9KSwgZS5wbGFjZWhvbGRlck1vdmluZ09iamVjdHMuZm9yRWFjaCgoZCwgZikgPT4ge1xuICAgICAgICBjb25zdCBnID0gZC5kcmFnZ2VkT2JqZWN0O1xuICAgICAgICBpZiAoZyBpbnN0YW5jZW9mIG9yKSB7XG4gICAgICAgICAgZC52aXNpYmxlID0gITE7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGcuc2V0Q29vcmRzKCksIEt5KGQpO1xuICAgICAgICBsZXQgcCA9IG4wKFxuICAgICAgICAgIGcsXG4gICAgICAgICAgbixcbiAgICAgICAgICBpLnBvaW50ZXIsXG4gICAgICAgICAgYVxuICAgICAgICApO1xuICAgICAgICBpZiAoZyBpbnN0YW5jZW9mIE9lICYmIHAuaXNJbnZhbGlkRHJvcCAmJiBlLmRyYWdnaW5nT3ZlclRyYWNrIGluc3RhbmNlb2YgdWUpIHtcbiAgICAgICAgICBkLm9wYWNpdHkgPSAwO1xuICAgICAgICAgIGNvbnN0IG0gPSBpLnBvaW50ZXIsIGIgPSBbLi4udC52aWV3cG9ydFRyYW5zZm9ybV0sIFMgPSBtLnkgLSBiWzVdO1xuICAgICAgICAgIGkwKHQsIFMpO1xuICAgICAgICB9IGVsc2UgZS5wcmltYXJ5TW92aW5nT2JqZWN0cy5sZW5ndGggPiAxID8gKHQudHJhY2tJZEFmdGVyVHJhbnNmb3JtID0gZS50cmFja1RvcFRvSWRNYXBbcC50b3BdLCB0LnBvc2l0aW9uQWZ0ZXJUcmFuc2Zvcm1bZy5pZF0gPSB7XG4gICAgICAgICAgdG9wOiBwLnRvcCxcbiAgICAgICAgICBsZWZ0OiBwLmxlZnQgKyAoY1tmIC0gMV0gfHwgMClcbiAgICAgICAgfSwgZC5sZWZ0ID0gcC5sZWZ0ICsgKGNbZiAtIDFdIHx8IDApLCBkLnRvcCA9IHAudG9wKSA6ICh0LnRyYWNrSWRBZnRlclRyYW5zZm9ybSA9IGUudHJhY2tUb3BUb0lkTWFwW3AudG9wXSwgdC5wb3NpdGlvbkFmdGVyVHJhbnNmb3JtW2cuaWRdID0ge1xuICAgICAgICAgIHRvcDogcC50b3AsXG4gICAgICAgICAgbGVmdDogcC5sZWZ0XG4gICAgICAgIH0sIGQubGVmdCA9IHAubGVmdCwgZC50b3AgPSBwLnRvcCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiksIFBhID0gKGksIHQpID0+IHtcbiAgY29uc3QgZSA9IGkuY2FudmFzLCBzID0gW107XG4gIHQuaXRlbXMuZm9yRWFjaCgobCkgPT4ge1xuICAgIGNvbnN0IGggPSBlLmdldE9iamVjdHMoKS5maW5kKCh1KSA9PiB1LmlkID09PSBsKTtcbiAgICBoICYmIHMucHVzaChoKTtcbiAgfSk7XG4gIGNvbnN0IHIgPSBpLmFjdGl2ZU9iamVjdHMubWFwKChsKSA9PiBsLmlkKSwgbyA9IHMuZmlsdGVyKFxuICAgIChsKSA9PiAhci5pbmNsdWRlcyhsLmlkKVxuICApLnNvcnQoXG4gICAgKGwsIGgpID0+IGwubGVmdCAtIGgubGVmdFxuICApO1xuICBsZXQgYSA9IDA7XG4gIGNvbnN0IGMgPSBbXTtcbiAgcmV0dXJuIHQubWFnbmV0aWMgPyBzMChvLCBhLCBjKSA6IHIwKHQsIGMsIGUpLCBjO1xufTtcbmZ1bmN0aW9uIGUwKGksIHQpIHtcbiAgY29uc3QgZSA9IFtdO1xuICBpLmdldE9iamVjdHMoKS5maW5kKChhKSA9PiBhLmlkID09PSB0LnVwZGF0ZUl0ZW1zSW5UcmFjaykuaXRlbXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgIGNvbnN0IGMgPSBpLmdldE9iamVjdHMoKS5maW5kKChsKSA9PiBsLmlkID09PSBhKTtcbiAgICBjICYmIGUucHVzaChjKTtcbiAgfSk7XG4gIGNvbnN0IHIgPSB0LmFjdGl2ZU9iamVjdHMubWFwKChhKSA9PiBhLmlkKSwgbyA9IGUuZmlsdGVyKFxuICAgIChhKSA9PiAhci5pbmNsdWRlcyhhLmlkKVxuICApLnNvcnQoXG4gICAgKGEsIGMpID0+IGEubGVmdCAtIGMubGVmdFxuICApO1xuICB0LmluaXRpYWxUcmFja1BvaW50cy5sZW5ndGggPiBvLmxlbmd0aCAmJiB0MChvLCB0LmluaXRpYWxUcmFja1BvaW50cyk7XG59XG5mdW5jdGlvbiBzMChpLCB0LCBlKSB7XG4gIHZhciBsO1xuICBjb25zdCBzID0gUSgpLCByID0gKGwgPSBpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogbC5jYW52YXMsIG4gPSBzLmRyYWdnaW5nT3ZlclRyYWNrLCBvID0gcy5wcmltYXJ5TW92aW5nT2JqZWN0cy5tYXAoKGgpID0+IGguaWQpO1xuICBpZiAoIXIpIHJldHVybjtcbiAgY29uc3QgYSA9IHIudHJhbnNpdGlvbklkcy5maWx0ZXIoXG4gICAgKGgpID0+IHIudHJhbnNpdGlvbnNNYXBbaF0ua2luZCAhPT0gXCJub25lXCJcbiAgKTtcbiAgaS5mb3JFYWNoKChoKSA9PiB7XG4gICAgaC5zZXQoeyBsZWZ0OiB0IH0pLCB0ICs9IGgud2lkdGgsIGEuZmluZChcbiAgICAgIChkKSA9PiByLnRyYW5zaXRpb25zTWFwW2RdLnRvSWQgPT09IGguaWRcbiAgICApIHx8IGUucHVzaChoLmxlZnQpO1xuICB9KTtcbiAgY29uc3QgYyA9IGlbaS5sZW5ndGggLSAxXTtcbiAgaWYgKGUucHVzaCgoKGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMubGVmdCkgfHwgMCkgKyAoKGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMud2lkdGgpIHx8IDApKSwgbiAhPSBudWxsICYmIG4uaXRlbXMuaW5jbHVkZXMob1swXSkpIHtcbiAgICBjb25zdCBoID0gci5nZXRBY3RpdmVPYmplY3QoKSwgdSA9IFsuLi5lXTtcbiAgICBpZiAoaCkge1xuICAgICAgY29uc3QgZCA9IHUuZmluZEluZGV4KChmKSA9PiBmID4gKGggPT0gbnVsbCA/IHZvaWQgMCA6IGgubGVmdCkpO1xuICAgICAgZCAhPT0gLTEgJiYgZS5zcGxpY2UoZCwgMCwgaC5sZWZ0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHIwKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGkuaXRlbXMsIHIgPSB7fSwgbiA9IHt9LCBvID0gZS5nZXRBY3RpdmVPYmplY3RzKCkubWFwKChsKSA9PiBsLmlkKTtcbiAgT2JqZWN0LnZhbHVlcyhlLnRyYWNrSXRlbXNNYXApLmZvckVhY2goKGwpID0+IHtcbiAgICBzLmluY2x1ZGVzKGwuaWQpICYmIChyW2wuaWRdID0gbCk7XG4gIH0pO1xuICBjb25zdCBhID0gZS5nZXRPYmplY3RzKFwiVHJhbnNpdGlvblwiKS5maWx0ZXIoKGwpID0+IGwudG9wID09PSBpLnRvcCkubWFwKChsKSA9PiBsLmlkKTtcbiAgT2JqZWN0LnZhbHVlcyhlLnRyYW5zaXRpb25zTWFwKS5mb3JFYWNoKChsKSA9PiB7XG4gICAgYS5pbmNsdWRlcyhsLmlkKSAmJiAobltsLmlkXSA9IGwpO1xuICB9KTtcbiAgY29uc3QgYyA9IGhvKHtcbiAgICB0cmFja0l0ZW1JZHM6IFV0KHMpLFxuICAgIHRyYW5zaXRpb25zTWFwOiBVdChuKSxcbiAgICB0cmFja0l0ZW1zTWFwOiBVdChyKVxuICB9KTtcbiAgdC5wdXNoKDApLCBjLmZvckVhY2goKGwpID0+IHtcbiAgICBpZiAobC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGggPSBlLmdldE9iamVjdHMoKS5maW5kKCh1KSA9PiB1LmlkID09PSBsWzBdLmlkKTtcbiAgICAgIG8uaW5jbHVkZXMoaC5pZCkgfHwgdC5wdXNoKGgubGVmdCArIGgud2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoID0gbFtsLmxlbmd0aCAtIDFdLCB1ID0gZS5nZXRPYmplY3RzKCkuZmluZCgoZCkgPT4gZC5pZCA9PT0gaC5pZCk7XG4gICAgICB0LnB1c2godS53aWR0aCArIHUubGVmdCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGkwKGksIHQpIHtcbiAgaS5nZXRPYmplY3RzKFwiSGVscGVyXCIpLnJlZHVjZShcbiAgICAociwgbikgPT4gTWF0aC5hYnMobi50b3AgLSB0KSA8IE1hdGguYWJzKHIudG9wIC0gdCkgPyBuIDogclxuICApLnNldFNlbGVjdGVkKCEwKTtcbn1cbmNvbnN0IG4wID0gKGksIHQsIGUsIHMpID0+IHtcbiAgY29uc3QgciA9IFFsKGkpO1xuICByZXR1cm4gIXIgJiYgaSBpbnN0YW5jZW9mIE9lID8ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIGlzSW52YWxpZERyb3A6ICEwXG4gIH0gOiByID8gcyA/IGkgaW5zdGFuY2VvZiBPZSA/IHtcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBpc0ludmFsaWREcm9wOiAhMFxuICB9IDogUXkoXG4gICAgaSxcbiAgICBzLFxuICAgIHQsXG4gICAgZVxuICApIDogWnkoaSkgOiBKeSgpO1xufTtcbmZ1bmN0aW9uIG8wKGkpIHtcbiAgaS5vbihcIm1vdXNlOnVwXCIsIEpsLmJpbmQoaSkpLCBpLm9uKFwib2JqZWN0Om1vdmluZ1wiLCB0aCk7XG59XG5mdW5jdGlvbiBhMChpKSB7XG4gIGkub2ZmKFwibW91c2U6dXBcIiwgSmwuYmluZChpKSksIGkub2ZmKFwib2JqZWN0Om1vdmluZ1wiLCB0aCk7XG59XG5jb25zdCBjMCA9IChpKSA9PiB7XG4gIFEoKS5jYW52YXMuZmlyZShcInRyYWNrOmNyZWF0ZVwiLCBpKTtcbn0sIGwwID0gKGkpID0+IHtcbiAgUSgpLmNhbnZhcy5maXJlKFwidHJhY2staXRlbXM6bW92ZWRcIiwgaSk7XG59LCBlaCA9IChpKSA9PiB7XG4gIHZhciBhLCBjLCBsO1xuICBjb25zdCB0ID0gKGEgPSBpLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2FudmFzO1xuICBpZiAoIXQpIHJldHVybjtcbiAgY29uc3QgZSA9IFEoKSwgcyA9IHQuZ2V0QWN0aXZlT2JqZWN0KCk7XG4gIGlmICghcyB8fCAhdC5wb3NpdGlvbkJlZm9yZVRyYW5zZm9ybSkgcmV0dXJuO1xuICBjb25zdCByID0gdC5nZXRTY2VuZVBvaW50KGkuZSksIG8gPSB0LmdldE9iamVjdHMoXCJUcmFja1wiLCBcIkhlbHBlclwiKS5maW5kKChoKSA9PiB7XG4gICAgY29uc3QgdSA9IGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmV0dXJuIHIueCA+PSB1LmxlZnQgJiYgci54IDw9IHUubGVmdCArIHUud2lkdGggJiYgci55ID49IHUudG9wICYmIHIueSA8PSB1LnRvcCArIHUuaGVpZ2h0O1xuICB9KTtcbiAgaWYgKGkuYWN0aW9uID09PSBcInJlc2l6aW5nXCIpIHtcbiAgICBjb25zdCBoID0gKGUudHJhY2tUb0l0ZW1zTWFwWyhjID0gZS5vcmlnaW5UcmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IGMuaWRdIHx8IFtdKS5maWx0ZXIoKGQpID0+IGQgIT09IHMpO1xuICAgIHMuc2V0Q29vcmRzKCk7XG4gICAgY29uc3QgdSA9IHNoKFxuICAgICAgaCxcbiAgICAgIHMuZ2V0Qm91bmRpbmdSZWN0KClcbiAgICApO1xuICAgIHJldHVybiB0LmZpcmUoXCJ0cmFjay1pdGVtczpyZXNpemVkXCIsIHtcbiAgICAgIHRyYWNrSWQ6IChsID0gZS5vcmlnaW5UcmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IGwuaWQsXG4gICAgICB0cmFja0l0ZW1JZHM6IFtzLmlkXSxcbiAgICAgIGlzT3ZlcmxhcHBlZDogISF1XG4gICAgfSksICExO1xuICB9XG4gIGlmICghbylcbiAgICByZXR1cm4gcyA9PSBudWxsIHx8IHMuc2V0KHQucG9zaXRpb25CZWZvcmVUcmFuc2Zvcm0pLCBzID09IG51bGwgfHwgcy5zZXRDb29yZHMoKSwgITE7XG4gIGlmIChvIGluc3RhbmNlb2YgU3MpIHtcbiAgICBsZXQgaDtcbiAgICBzd2l0Y2ggKG8ua2luZCkge1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICBoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgIGggPSBvLm1ldGFkYXRhLm9yZGVyIHx8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICBoID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1ID0ge1xuICAgICAgaXNTZWNvbmRhcnlPdmVybGFwcGVkOiAhMSxcbiAgICAgIHNlY29uZGFyeVRyYWNrczogZS5zZWNvbmRhcnlUcmFja3MsXG4gICAgICBwcmltYXJ5VHJhY2tzOiBlLnByaW1hcnlUcmFja3MsXG4gICAgICBwcmltYXJ5UG9zaXRpb25zOiB7XG4gICAgICAgIHRyYWNrSW5kZXg6IGgsXG4gICAgICAgIHRyYWNrSWQ6IHQudHJhY2tJZEFmdGVyVHJhbnNmb3JtLFxuICAgICAgICBwb3NpdGlvbnM6IHQucG9zaXRpb25BZnRlclRyYW5zZm9ybVxuICAgICAgfVxuICAgIH07XG4gICAgYzAodSk7XG4gIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIHVlKSB7XG4gICAgY29uc3QgdSA9IHtcbiAgICAgIGlzU2Vjb25kYXJ5T3ZlcmxhcHBlZDogdTAoKSxcbiAgICAgIHNlY29uZGFyeVRyYWNrczogZS5zZWNvbmRhcnlUcmFja3MsXG4gICAgICBwcmltYXJ5VHJhY2tzOiBlLnByaW1hcnlUcmFja3MsXG4gICAgICBwcmltYXJ5UG9zaXRpb25zOiB7XG4gICAgICAgIHRyYWNrSWQ6IHQudHJhY2tJZEFmdGVyVHJhbnNmb3JtLFxuICAgICAgICBwb3NpdGlvbnM6IHQucG9zaXRpb25BZnRlclRyYW5zZm9ybVxuICAgICAgfVxuICAgIH07XG4gICAgbDAodSk7XG4gIH1cbn07XG5mdW5jdGlvbiBoMCgpIHtcbiAgY29uc3QgaSA9IFEoKSwgdCA9IGkuY2FudmFzLCBbZV0gPSBpLnByaW1hcnlNb3ZpbmdPYmplY3RzLCBzID0gZS5pZCwgciA9IHQucG9zaXRpb25BZnRlclRyYW5zZm9ybVtzXSwgbiA9IGUuZ2V0Qm91bmRpbmdSZWN0KCkudG9wLCBvID0gci50b3AgLSBuLCBhID0ge307XG4gIHJldHVybiBpLnNlY29uZGFyeU1vdmluZ09iamVjdHMuZm9yRWFjaCgoYykgPT4ge1xuICAgIGNvbnN0IGwgPSBjLmdldEJvdW5kaW5nUmVjdCgpLnRvcCArIG8sIGggPSBpLnRyYWNrVG9wVG9JZE1hcFtsXSwgdSA9IEluKFxuICAgICAgaS50cmFja1RvcHMsXG4gICAgICBpLm9yaWdpblRyYWNrLnRvcCxcbiAgICAgIGxcbiAgICApO1xuICAgIGFbaF0gPyBhW2hdLm9iamVjdHMucHVzaChjKSA6IGFbaF0gPSB7XG4gICAgICBvYmplY3RzOiBbY10sXG4gICAgICBpbmRleDogdVxuICAgIH07XG4gIH0pLCBhO1xufVxuZnVuY3Rpb24gdTAoKSB7XG4gIGNvbnN0IGkgPSBoMCgpLCB0ID0gUSgpO1xuICByZXR1cm4gT2JqZWN0LmtleXMoaSkuc29tZSgoZSkgPT4ge1xuICAgIGNvbnN0IHMgPSB0LnRyYWNrVG9JdGVtc01hcFtlXSwgciA9IGlbZV0ub2JqZWN0cztcbiAgICByZXR1cm4gIXMgfHwgIXMubGVuZ3RoID8gITAgOiBzLmZpbHRlcigobikgPT4gIXIuaW5jbHVkZXMobikpLnNvbWUoKG4pID0+IHNoKFxuICAgICAgcixcbiAgICAgIG4uZ2V0Qm91bmRpbmdSZWN0KClcbiAgICApKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzaChpLCB0KSB7XG4gIHJldHVybiBpLmZpbmQoKHMpID0+IHtcbiAgICBjb25zdCByID0gcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICByZXR1cm4gdC5sZWZ0IDwgci5sZWZ0ICsgci53aWR0aCAmJiB0LmxlZnQgKyB0LndpZHRoID4gci5sZWZ0ICYmIHQudG9wIDwgci50b3AgKyByLmhlaWdodCAmJiB0LnRvcCArIHQuaGVpZ2h0ID4gci50b3A7XG4gIH0pO1xufVxuY29uc3QgZDAgPSAoaSkgPT4ge1xuICBpLm9uKFwib2JqZWN0Om1vZGlmaWVkXCIsIGVoKTtcbn0sIGYwID0gKGkpID0+IHtcbiAgaS5vZmYoXCJvYmplY3Q6bW9kaWZpZWRcIiwgZWgpO1xufSwgcmggPSBcImRyYWdcIiwgZzAgPSBgJHtyaH06c3RhcnRgLCBpaCA9IGAke3JofTplbmRgLCBuaCA9IFwidGltZWxpbmVcIiwgcDAgPSBgJHtuaH06Ym91bmRpbmdDaGFuZ2VkYCwgbTAgPSBgJHtuaH06c2Vla2AsIHYwID0gXCJhZGQ6YXVkaW9cIiwgeTAgPSBcImFkZDp2aWRlb1wiLCBiMCA9IFwiYWRkOmltYWdlXCIsIF8wID0gXCJhZGQ6dGV4dFwiLCBTMCA9IFtcbiAgXCJ0cmFuc2l0aW9uXCIsXG4gIFwiaW1hZ2VcIixcbiAgXCJ2aWRlb1wiLFxuICBcImF1ZGlvXCIsXG4gIFwiY2FwdGlvblwiLFxuICBcInRleHRcIlxuXTtcbmxldCBldCwgWHMsIHdzID0gW107XG5mdW5jdGlvbiBUMChpLCB0KSB7XG4gIGxldCBlID0gMSAvIDAsIHMgPSBudWxsO1xuICBjb25zdCByID0gbmV3IF8oaS54LCBpLnkpO1xuICByZXR1cm4gdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgY29uc3QgbyA9IE1hdGguc3FydChcbiAgICAgIE1hdGgucG93KG4ubGVmdCAtIHIueCwgMikgKyBNYXRoLnBvdyhuLnRvcCAtIHIueSwgMilcbiAgICApO1xuICAgIG8gPCBlICYmIChlID0gbywgcyA9IG4pO1xuICB9KSwgcztcbn1cbmNvbnN0IHgwID0gKHtcbiAgd2lkdGg6IGksXG4gIGhlaWdodDogdCxcbiAgaWQ6IGUsXG4gIGxlZnQ6IHMsXG4gIHRvcDogcixcbiAgdHlwZTogbixcbiAgZHVyYXRpb246IG9cbn0pID0+IHtcbiAgaWYgKG4gPT09IFwidHJhbnNpdGlvblwiKVxuICAgIHJldHVybiBuZXcgb3Ioe1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGhlaWdodDogNDgsXG4gICAgICB3aWR0aDogNDgsXG4gICAgICBpZDogXCJUcmFuc2l0aW9uR3VpZGVcIlxuICAgIH0pO1xuICBjb25zdCBhID0gQy5nZXRDbGFzcyhcIlByZXZpZXdUcmFja0l0ZW1cIikgfHwgT2U7XG4gIHJldHVybiBuZXcgYSh7XG4gICAgdG9wOiByLFxuICAgIGxlZnQ6IHMsXG4gICAgaGVpZ2h0OiB0LFxuICAgIHdpZHRoOiBpLFxuICAgIGlkOiBlLFxuICAgIHR5cGU6IG4sXG4gICAgZHVyYXRpb246IG9cbiAgfSk7XG59O1xuZnVuY3Rpb24gb2goaSkge1xuICB2YXIgZjtcbiAgY29uc3QgdCA9IChmID0gaS5lLmRhdGFUcmFuc2ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGYudHlwZXNbMF07XG4gIGlmICghdCkgcmV0dXJuO1xuICBjb25zdCBlID0gSlNPTi5wYXJzZSh0KSwgcyA9IGUudHlwZTtcbiAgaWYgKCFTMC5pbmNsdWRlcyhzKSkgcmV0dXJuO1xuICBjb25zdCByID0gZS5kdXJhdGlvbiB8fCA1ZTMsIG4gPSB0aGlzO1xuICBuLmRpc2NhcmRBY3RpdmVPYmplY3QoKSwgbi5zZXRBY3RpdmVJZHMoW10pO1xuICBjb25zdCBvID0gRChyLCB0aGlzLnRTY2FsZSksIGEgPSB0aGlzLnNpemVzTWFwW3NdO1xuICBldCA9IHgwKHtcbiAgICB3aWR0aDogbyxcbiAgICBoZWlnaHQ6IGEsXG4gICAgaWQ6IFwiVHJhbnNpdGlvbkd1aWRlXCIsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgdHlwZTogcyxcbiAgICBkdXJhdGlvbjogclxuICB9KSwgZXQudmlzaWJsZSA9ICExLCBzID09PSBcInRyYW5zaXRpb25cIiAmJiAod3MgPSBuLmdldE9iamVjdHMoXCJUcmFuc2l0aW9uXCIpLCB3cy5mb3JFYWNoKChnKSA9PiB7XG4gICAgZy52aXNpYmxlID0gITA7XG4gIH0pKTtcbiAgY29uc3QgYyA9IFEoKTtcbiAgbi50cmFja0lkQWZ0ZXJUcmFuc2Zvcm0gPSBcIlwiLCBuLnBvc2l0aW9uQWZ0ZXJUcmFuc2Zvcm0gPSB7fTtcbiAgY29uc3QgbCA9IGV0LCBoID0gW2V0XTtcbiAgYXQoe1xuICAgIGFjdGl2ZVRyYWNrVG9JdGVtc01hcDoge30sXG4gICAgcHJpbWFyeVRyYWNrczoge30sXG4gICAgc2Vjb25kYXJ5VHJhY2tzOiB7fSxcbiAgICB0cmFja1RvcHM6IFtdLFxuICAgIHRyYWNrVG9JdGVtc01hcDoge30sXG4gICAgYWN0aXZlT2JqZWN0czogW10sXG4gICAgdHJhY2tUb3BUb0lkTWFwOiB7fSxcbiAgICBpc0RyYWdPdmVyOiAhMVxuICB9KSwgYXQoeyBhY3RpdmVPYmplY3RzOiBoIH0pO1xuICBjb25zdCB1ID0gbi5nZXRPYmplY3RzKFwiVHJhY2tcIiksIGQgPSBuLmdldFRyYWNrSXRlbXMoKTtcbiAgdS5mb3JFYWNoKChnKSA9PiB7XG4gICAgY29uc3QgcCA9IGQuZmlsdGVyKChtKSA9PiBnLml0ZW1zLmluY2x1ZGVzKG0uaWQpKTtcbiAgICBjLnRyYWNrVG9JdGVtc01hcFtnLmlkXSA9IHAsIGMudHJhY2tUb3BUb0lkTWFwW2cudG9wXSA9IGcuaWQsIGMudHJhY2tUb3BzLnB1c2goZy50b3ApO1xuICB9KSwgYy50cmFja1RvcHMuc29ydCgoZywgcCkgPT4gZyAtIHApLCBjLnByaW1hcnlNb3ZpbmdPYmplY3RzID0gaCwgYy5wcmltYXJ5TW92aW5nT2JqZWN0cyA9IGMucHJpbWFyeU1vdmluZ09iamVjdHMuc29ydChcbiAgICAoZywgcCkgPT4gZy5sZWZ0IC0gcC5sZWZ0XG4gICksIGwgJiYgKG4ucG9zaXRpb25CZWZvcmVUcmFuc2Zvcm0gPSB7XG4gICAgdG9wOiBsLnRvcCxcbiAgICBsZWZ0OiBsLmxlZnRcbiAgfSksIGMucGxhY2Vob2xkZXJNb3ZpbmdPYmplY3RzID0gYy5wcmltYXJ5TW92aW5nT2JqZWN0cy5tYXAoKGcpID0+IHtcbiAgICBjb25zdCBwID0gZy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICBjLm9iamVjdEluaXRpYWxQb3NpdGlvbnNbZy5pZF0gPSB7XG4gICAgICB0b3A6IHAudG9wLFxuICAgICAgbGVmdDogcC5sZWZ0XG4gICAgfTtcbiAgICBjb25zdCBtID0gbmV3IGVyKHtcbiAgICAgIGlkOiBgJHtnLmlkfS1wbGFjZWhvbGRlcmAsXG4gICAgICBsZWZ0OiBwLmxlZnQsXG4gICAgICB0b3A6IHAudG9wLFxuICAgICAgd2lkdGg6IHAud2lkdGgsXG4gICAgICBoZWlnaHQ6IHAuaGVpZ2h0XG4gICAgfSk7XG4gICAgcmV0dXJuIG0udmlzaWJsZSA9ICExLCBtLmRyYWdnZWRPYmplY3QgPSBnLCBtO1xuICB9KSwgbi5hZGQoLi4uYy5wbGFjZWhvbGRlck1vdmluZ09iamVjdHMpLCBuLmFkZChldCksIGllKGcwKTtcbn1cbmNvbnN0IGFoID0gKGkpID0+IHtcbiAgY29uc3QgdCA9IFEoKTtcbiAgVmwoaSwgdC5wbGFjZWhvbGRlck1vdmluZ09iamVjdHMpLCBpICYmIChQaShpLCBpLmdldE9iamVjdHMoKSksIEdsKGkuZ2V0T2JqZWN0cyhcIkhlbHBlclwiKSkpO1xufTtcbmZ1bmN0aW9uIGNoKCkge1xuICBpZiAoYWgodGhpcyksIGF0KHsgZHJhZ2dpbmdPdmVyVHJhY2s6IG51bGwsIGlzUG9pbnRlck92ZXJIZWxwZXJUcmFjazogITEgfSksICFldCkgcmV0dXJuO1xuICBpZShpaCk7XG4gIGNvbnN0IGkgPSB0aGlzO1xuICB3cy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgdC5zdHJva2VEYXNoQXJyYXkgPSBbXSwgdC5zZXRTZWxlY3RlZCghMSksIHQua2luZCA9PT0gXCJub25lXCIgJiYgKHQudmlzaWJsZSA9ICExKTtcbiAgfSksIGkuZ2V0T2JqZWN0cyhcIkhlbHBlclwiLCBcIlRyYWNrXCIpLmZvckVhY2goKHQpID0+IHtcbiAgICB0LnNldFNlbGVjdGVkICYmIHQuc2V0U2VsZWN0ZWQoITEpO1xuICB9KSwgaS5yZW1vdmUoZXQpO1xufVxuZnVuY3Rpb24gbGgoaSkge1xuICBjb25zdCB0ID0gUSgpLCBlID0gdC5wbGFjZWhvbGRlck1vdmluZ09iamVjdHNbMF07XG4gIGlmIChlLnZpc2libGUgfHwgKGV0LnZpc2libGUgPSAhMCwgZS52aXNpYmxlID0gITApLCB0LmFjdGl2ZU9iamVjdHNbMF0gaW5zdGFuY2VvZiBvciAmJiAoZS52aXNpYmxlID0gITEpLCAhZXQpIHJldHVybiAhMTtcbiAgaS5lLnByZXZlbnREZWZhdWx0KCk7XG4gIGNvbnN0IHMgPSB0aGlzLCByID0gcy5nZXRWaWV3cG9ydFBvaW50KGkuZSksIG4gPSBbLi4udGhpcy52aWV3cG9ydFRyYW5zZm9ybV07XG4gIGV0LnNldCh7XG4gICAgbGVmdDogci54IC0gMTYgLSBuWzRdLFxuICAgIHRvcDogci55IC0gbls1XSAtIGV0LmhlaWdodCAvIDJcbiAgfSk7XG4gIGNvbnN0IG8gPSBUMChyLCB3cyk7XG4gIG8gJiYgKFhzID0gbywgby5zdHJva2VEYXNoQXJyYXkgPSBbNSwgMV0sIG8uc2V0U2VsZWN0ZWQoITApKSwgd3MuZm9yRWFjaCgoYykgPT4ge1xuICAgIGMgIT09IG8gJiYgYy5zZXRTZWxlY3RlZCghMSk7XG4gIH0pLCBhdCh7IGlzRHJhZ092ZXI6ICEwIH0pLCBldC5zZXRDb29yZHMoKTtcbiAgY29uc3QgYSA9IHtcbiAgICB0YXJnZXQ6IGV0LFxuICAgIGFjdGlvbjogXCJkcmFnXCIsXG4gICAgb3JpZ2luWDogXCJjZW50ZXJcIixcbiAgICBvcmlnaW5ZOiBcImNlbnRlclwiLFxuICAgIG9mZnNldFg6IHIueCAtIGV0LmxlZnQsXG4gICAgb2Zmc2V0WTogci55IC0gZXQudG9wLFxuICAgIHNjYWxlWDogZXQuc2NhbGVYLFxuICAgIHNjYWxlWTogZXQuc2NhbGVZXG4gIH07XG4gIHMuZmlyZShcIm9iamVjdDptb3ZpbmdcIiwge1xuICAgIHRhcmdldDogZXQsXG4gICAgZTogaS5lLFxuICAgIHBvaW50ZXI6IHIsXG4gICAgdHJhbnNmb3JtOiBhXG4gIH0pLCBzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbn1cbmZ1bmN0aW9uIGhoKGkpIHtcbiAgdmFyIG87XG4gIGNvbnN0IHQgPSB0aGlzO1xuICBhaCh0KTtcbiAgY29uc3QgZSA9IFEoKSwgcyA9IGUuZHJhZ2dpbmdPdmVyVHJhY2s7XG4gIGF0KHsgZHJhZ2dpbmdPdmVyVHJhY2s6IG51bGwsIGlzUG9pbnRlck92ZXJIZWxwZXJUcmFjazogITEgfSk7XG4gIGNvbnN0IHIgPSAobyA9IGkuZS5kYXRhVHJhbnNmZXIpID09IG51bGwgPyB2b2lkIDAgOiBvLnR5cGVzWzBdLCBuID0gSlNPTi5wYXJzZShpLmUuZGF0YVRyYW5zZmVyLmdldERhdGEocikpO1xuICBpZiAobi50eXBlICE9PSBcInRyYW5zaXRpb25cIikge1xuICAgIGNvbnN0IGEgPSBlLmFjdGl2ZU9iamVjdHNbMF0sIGMgPSBZKGEubGVmdCwgdC50U2NhbGUpO1xuICAgIGlmIChzIGluc3RhbmNlb2YgdWUpXG4gICAgICBpZiAoZS5wbGFjZWhvbGRlck1vdmluZ09iamVjdHNbMF0ub3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBjb25zdCBoID0gZW4ocywgdGhpcy5nZXRPYmplY3RzKFwiVHJhY2tcIikpO1xuICAgICAgICBpZiAocy5tYWduZXRpYykge1xuICAgICAgICAgIGNvbnN0IHUgPSBlLmluaXRpYWxUcmFja1BvaW50c1tlLmluaXRpYWxUcmFja1BvaW50cy5sZW5ndGggLSAxXSwgZCA9IFkodSwgdC50U2NhbGUpO1xuICAgICAgICAgIFlyKG4sIGgsIGQpO1xuICAgICAgICB9IGVsc2UgWXIobiwgaCwgYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBoID0gaS52aWV3cG9ydFBvaW50LCB1ID0gWy4uLnQudmlld3BvcnRUcmFuc2Zvcm1dLCBkID0gaC55IC0gdVs1XSwgZyA9IHQuZ2V0T2JqZWN0cyhcIkhlbHBlclwiKS5yZWR1Y2UoXG4gICAgICAgICAgKG0sIGIpID0+IE1hdGguYWJzKGIudG9wIC0gZCkgPCBNYXRoLmFicyhtLnRvcCAtIGQpID8gYiA6IG1cbiAgICAgICAgKSwgcCA9IGVuKGcsIHRoaXMuZ2V0T2JqZWN0cyhcIlRyYWNrXCIpKTtcbiAgICAgICAgWXIobiwgcCwgYywgITApO1xuICAgICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbCA9IGVuKFxuICAgICAgICBzLFxuICAgICAgICB0aGlzLmdldE9iamVjdHMoXCJUcmFja1wiKVxuICAgICAgKTtcbiAgICAgIFlyKG4sIGwsIGMsICEwKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmUoYSksIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZXQpIHtcbiAgICBpZiAoWHMpIHtcbiAgICAgIGNvbnN0IGEgPSBYcy5pZCwgYyA9IFR5KG4sIFtcImtpbmRcIiwgXCJkaXJlY3Rpb25cIl0pO1xuICAgICAgT2JqZWN0LmtleXMoYykuZm9yRWFjaCgoUykgPT4ge1xuICAgICAgICBTID09PSBcImtpbmRcIiA/IFhzLmtpbmQgPSBjW1NdIDogWHNbU10gPSBjW1NdO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBsID0gVXQodGhpcy50cmFja0l0ZW1JZHMpLCBoID0gVXQodGhpcy50cmFuc2l0aW9uc01hcCksIHUgPSBVdCh0aGlzLnRyYWNrSXRlbXNNYXApO1xuICAgICAgaFthXSA9IHtcbiAgICAgICAgLi4uaFthXSxcbiAgICAgICAgLi4uY1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGQgPSB4cyh7XG4gICAgICAgIHRyYWNrSXRlbUlkczogbCxcbiAgICAgICAgdHJhbnNpdGlvbnNNYXA6IGgsXG4gICAgICAgIHRyYWNrSXRlbXNNYXA6IHVcbiAgICAgIH0pLCBnID0gaFthXS5mcm9tSWQsIHAgPSBkLmZpbmQoKFMpID0+IFMuZmluZCgodykgPT4gdy5pZCA9PT0gZykpIHx8IFtdLCBtID0gdzAoXG4gICAgICAgIHBcbiAgICAgICksIGIgPSBDMChcbiAgICAgICAgdGhpcy50cmFja0l0ZW1zTWFwLFxuICAgICAgICBtXG4gICAgICApO1xuICAgICAgdGhpcy50cmFja0l0ZW1zTWFwID0gYiwgdGhpcy50cmFuc2l0aW9uc01hcFthXSA9IHtcbiAgICAgICAgLi4udGhpcy50cmFuc2l0aW9uc01hcFthXSxcbiAgICAgICAgLi4uY1xuICAgICAgfSwgdGhpcy50cmFuc2l0aW9uR3JvdXBzID0geHMoe1xuICAgICAgICB0cmFja0l0ZW1JZHM6IHRoaXMudHJhY2tJdGVtSWRzLFxuICAgICAgICB0cmFuc2l0aW9uc01hcDogdGhpcy50cmFuc2l0aW9uc01hcCxcbiAgICAgICAgdHJhY2tJdGVtc01hcDogdGhpcy50cmFja0l0ZW1zTWFwXG4gICAgICB9KSwgdGhpcy51cGRhdGVUcmFja0l0ZW1Db29yZHMoKSwgdGhpcy5hZGp1c3RNYWduZXRpY1RyYWNrKCksIHRoaXMuY2FsY0JvdW5kaW5nKCksIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoKSwgdGhpcy5yZWZyZXNoVHJhY2tMYXlvdXQoKSwgdGhpcy51cGRhdGVTdGF0ZSh7IGtpbmQ6IFwiYWRkOnRyYW5zaXRpb25cIiwgdXBkYXRlSGlzdG9yeTogITAgfSk7XG4gICAgfVxuICAgIHdzLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGEuc3Ryb2tlRGFzaEFycmF5ID0gW10sIGEuc2V0U2VsZWN0ZWQoITEpLCBhLmtpbmQgPT09IFwibm9uZVwiICYmIChhLnZpc2libGUgPSAhMSk7XG4gICAgfSksIHQucmVtb3ZlKGV0KSwgdC5yZXF1ZXN0UmVuZGVyQWxsKCksIGllKGloKTtcbiAgfVxufVxuY29uc3QgdzAgPSAoaSkgPT4ge1xuICBjb25zdCBbdF0gPSBpLCBlID0gaS5maWx0ZXIoXG4gICAgKHIpID0+IHIudHlwZSAhPT0gXCJ0cmFuc2l0aW9uXCJcbiAgKTtcbiAgbGV0IHMgPSB0LmRpc3BsYXkuZnJvbTtcbiAgcmV0dXJuIGUubWFwKChyKSA9PiB7XG4gICAgY29uc3QgbiA9IHIuZGlzcGxheS50byAtIHIuZGlzcGxheS5mcm9tLCBvID0ge1xuICAgICAgZnJvbTogcyxcbiAgICAgIHRvOiBzICsgblxuICAgIH07XG4gICAgcmV0dXJuIHMgPSBvLnRvLCB7XG4gICAgICAuLi5yLFxuICAgICAgZGlzcGxheTogb1xuICAgIH07XG4gIH0pO1xufSwgQzAgPSAoaSwgdCkgPT4ge1xuICBsZXQgZSA9IGk7XG4gIHJldHVybiB0LmZvckVhY2goKHMpID0+IHtcbiAgICBlW3MuaWRdID0gcztcbiAgfSksIGU7XG59LCBlbiA9IChpLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSB0LnNvcnQoKG8sIGEpID0+IG8udG9wIC0gYS50b3ApO1xuICBpZiAoZS5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICBjb25zdCBzID0gZVtlLmxlbmd0aCAtIDFdO1xuICBpZiAocy50b3AgKyBzLmhlaWdodCA8PSBpLnRvcClcbiAgICByZXR1cm4gZS5sZW5ndGg7XG4gIGNvbnN0IHIgPSBpLnRvcDtcbiAgcmV0dXJuIGUucmVkdWNlKChvLCBhLCBjKSA9PiB7XG4gICAgY29uc3QgbCA9IE1hdGguYWJzKGEudG9wIC0gciksIGggPSBNYXRoLmFicyhlW29dLnRvcCAtIHIpO1xuICAgIHJldHVybiBsIDwgaCA/IGMgOiBvO1xuICB9LCAwKTtcbn0sIFlyID0gKGksIHQsIGUsIHMpID0+IHtcbiAgaS50eXBlID09PSBcImltYWdlXCIgPyBpZShiMCwge1xuICAgIHBheWxvYWQ6IHtcbiAgICAgIC4uLmksXG4gICAgICBpZDogV3MoKSxcbiAgICAgIGRpc3BsYXk6IHsgZnJvbTogZSB9XG4gICAgfSxcbiAgICBvcHRpb25zOiB7IHRyYWNrSW5kZXg6IHQsIGlzTmV3VHJhY2s6IHMgfVxuICB9KSA6IGkudHlwZSA9PT0gXCJ2aWRlb1wiID8gaWUoeTAsIHtcbiAgICBwYXlsb2FkOiB7XG4gICAgICAuLi5pLFxuICAgICAgaWQ6IFdzKCksXG4gICAgICBkaXNwbGF5OiB7IGZyb206IGUgfVxuICAgIH0sXG4gICAgb3B0aW9uczogeyB0cmFja0luZGV4OiB0LCBpc05ld1RyYWNrOiBzIH1cbiAgfSkgOiBpLnR5cGUgPT09IFwiYXVkaW9cIiA/IGllKHYwLCB7XG4gICAgcGF5bG9hZDoge1xuICAgICAgLi4uaSxcbiAgICAgIGlkOiBXcygpLFxuICAgICAgZGlzcGxheTogeyBmcm9tOiBlIH1cbiAgICB9LFxuICAgIG9wdGlvbnM6IHsgdHJhY2tJbmRleDogdCwgaXNOZXdUcmFjazogcyB9XG4gIH0pIDogaS50eXBlID09PSBcInRleHRcIiAmJiBpZShfMCwge1xuICAgIHBheWxvYWQ6IHtcbiAgICAgIC4uLmksXG4gICAgICBpZDogV3MoKSxcbiAgICAgIGRpc3BsYXk6IHsgZnJvbTogZSB9XG4gICAgfSxcbiAgICBvcHRpb25zOiB7IHRyYWNrSW5kZXg6IHQsIGlzTmV3VHJhY2s6IHMgfVxuICB9KTtcbn07XG5mdW5jdGlvbiBPMChpKSB7XG4gIGkub24oXCJkcmFnb3ZlclwiLCBsaCksIGkub24oXCJkcmFnZW50ZXJcIiwgb2gpLCBpLm9uKFwiZHJhZ2xlYXZlXCIsIGNoKSwgaS5vbihcImRyb3BcIiwgaGgpO1xufVxuZnVuY3Rpb24gazAoaSkge1xuICBpLm9mZihcImRyYWdvdmVyXCIsIGxoKSwgaS5vZmYoXCJkcmFnZW50ZXJcIiwgb2gpLCBpLm9mZihcImRyYWdsZWF2ZVwiLCBjaCksIGkub2ZmKFwiZHJvcFwiLCBoaCk7XG59XG5mdW5jdGlvbiB1aChpKSB7XG4gIGNvbnN0IHQgPSB0aGlzLmhlaWdodCA8IHRoaXMuYm91bmRpbmcuaGVpZ2h0O1xuICBpZiAoISh0aGlzLndpZHRoIDwgdGhpcy5ib3VuZGluZy53aWR0aCkgJiYgIXQpIHJldHVybjtcbiAgY29uc3QgcyA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG4gIGxldCByID0gc1s0XSwgbiA9IHNbNV07XG4gIGNvbnN0IG8gPSAyO1xuICBpLmUuc2hpZnRLZXkgPyByID0gciAtIGkuZS5kZWx0YVkgKiBvIDogKHQgJiYgKG4gPSBuIC0gaS5lLmRlbHRhWSAqIG8pLCByID0gciAtIGkuZS5kZWx0YVggKiBvKSwgdGhpcy5zZXRWaWV3cG9ydFBvcyhyLCBuKTtcbn1cbmZ1bmN0aW9uIGRoKCkge1xuICBjb25zdCBpID0gdGhpcywgdCA9IGkuZ2V0QWN0aXZlT2JqZWN0KCksIGUgPSBpLmdldEFjdGl2ZU9iamVjdHMoKSwgcyA9IGUubWFwKChuKSA9PiBuLmlkKSwgciA9IGUuZmlsdGVyKChuKSA9PiB7XG4gICAgaWYgKGUubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmIChuLmlkICYmICEobiBpbnN0YW5jZW9mIEp0KSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBpZiAobiBpbnN0YW5jZW9mIEp0ICYmIHMuaW5jbHVkZXMobi5mcm9tSWQpICYmIHMuaW5jbHVkZXMobi50b0lkKSlcbiAgICAgIHJldHVybiAhMDtcbiAgfSkubWFwKChuKSA9PiBuLmlkKTtcbiAgdCBpbnN0YW5jZW9mIE90ID8gKHQuYm9yZGVyQ29sb3IgPSBcInJnYmEoMCwgMjE2LCAyMTQsMC43NSlcIiwgdC5oYXNDb250cm9scyA9ICExLCB0LmhvdmVyQ3Vyc29yID0gXCJkZWZhdWx0XCIsIHQuYm9yZGVyU2NhbGVGYWN0b3IgPSAxLCB0LnBhZGRpbmcgPSAwLCB0LmdldE9iamVjdHMoKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgbi5zZXRTZWxlY3RlZCghMCk7XG4gIH0pKSA6IHQgPT0gbnVsbCB8fCB0LnNldFNlbGVjdGVkKCEwKSwgdGhpcy5zZXRBY3RpdmVJZHMocik7XG59XG5mdW5jdGlvbiBmaChpKSB7XG4gIGNvbnN0IHQgPSB0aGlzLCBlID0gdC5nZXRBY3RpdmVPYmplY3QoKTtcbiAgZSBpbnN0YW5jZW9mIE90ICYmIChlLmJvcmRlckNvbG9yID0gXCJ0cmFuc3BhcmVudFwiLCBlLmhhc0NvbnRyb2xzID0gITEsIGUuaG92ZXJDdXJzb3IgPSBcImRlZmF1bHRcIiksIGkuc2VsZWN0ZWQuZm9yRWFjaCgobikgPT4ge1xuICAgIG4uc2V0U2VsZWN0ZWQoITApO1xuICB9KSwgaS5kZXNlbGVjdGVkLmZvckVhY2goKG4pID0+IHtcbiAgICBuLnNldFNlbGVjdGVkKCExKTtcbiAgfSk7XG4gIGNvbnN0IHIgPSB0LmdldEFjdGl2ZU9iamVjdHMoKS5tYXAoKG4pID0+IG4uaWQpO1xuICB0aGlzLnNldEFjdGl2ZUlkcyhyKTtcbn1cbmZ1bmN0aW9uIGdoKGkpIHtcbiAgaS5kZXNlbGVjdGVkLmZvckVhY2goKHQpID0+IHtcbiAgICB0LnNldFNlbGVjdGVkKCExKTtcbiAgfSk7XG59XG5jb25zdCBNMCA9IChpKSA9PiB7XG4gIGkub24oXCJzZWxlY3Rpb246Y3JlYXRlZFwiLCBkaCksIGkub24oXCJzZWxlY3Rpb246dXBkYXRlZFwiLCBmaCksIGkub24oXCJzZWxlY3Rpb246Y2xlYXJlZFwiLCBnaCksIGkub24oXCJtb3VzZTp3aGVlbFwiLCB1aCk7XG59LCBJMCA9IChpKSA9PiB7XG4gIGkub2ZmKFwibW91c2U6d2hlZWxcIiwgdWgpLCBpLm9mZihcInNlbGVjdGlvbjpjcmVhdGVkXCIsIGRoKSwgaS5vZmYoXCJzZWxlY3Rpb246dXBkYXRlZFwiLCBmaCksIGkub2ZmKFwic2VsZWN0aW9uOmNsZWFyZWRcIiwgZ2gpO1xufSwgcGggPSAoKSA9PiB7XG4gIHZhciBuLCBvO1xuICBjb25zdCBpID0gUSgpLCB0ID0gaS5jYW52YXMsIGUgPSBpLmRyYWdnaW5nT3ZlclRyYWNrO1xuICB0LnVwZGF0ZVRyYWNrSXRlbUNvb3JkcyghMCk7XG4gIGNvbnN0IHMgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLm1hZ25ldGljLCByID0gbmV3IFNldChpLmFjdGl2ZU9iamVjdHMubWFwKChhKSA9PiBhLmlkKSk7XG4gIGlmIChzKSB7XG4gICAgY29uc3QgYSA9IGUuaWQsIGwgPSBpLnRyYWNrVG9JdGVtc01hcFthXS5zb3J0KChwLCBtKSA9PiBwLmxlZnQgLSBtLmxlZnQpLCBoID0gaS5wbGFjZWhvbGRlck1vdmluZ09iamVjdHMsIHUgPSAoKG4gPSBoWzBdKSA9PSBudWxsID8gdm9pZCAwIDogbi50b3ApIHx8IDAsIGQgPSBoLnJlZHVjZShcbiAgICAgIChwLCBtKSA9PiBwICsgbS53aWR0aCxcbiAgICAgIDBcbiAgICApLCBmID0gTWF0aC5taW4oLi4uaC5tYXAoKHApID0+IHAubGVmdCkpO1xuICAgIGxldCBnID0gMDtcbiAgICBsLmZvckVhY2goKHApID0+IHtcbiAgICAgIHIuaGFzKHAuaWQpIHx8IHAudG9wID09PSB1ICYmIChNYXRoLmFicyhmIC0gZykgPCAxICYmIChnICs9IGQpLCBwLmxlZnQgPSBnLCBnICs9IHAud2lkdGgpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiB1ZSAmJiBpLm9yZGVyTm9ybWFsVHJhY2spIHtcbiAgICBjb25zdCBhID0gZS5pdGVtcywgYyA9IHQuZ2V0VHJhY2tJdGVtcygpLmZpbHRlcihcbiAgICAgICh4KSA9PiAhci5oYXMoeC5pZCkgJiYgYS5pbmNsdWRlcyh4LmlkKVxuICAgICksIGwgPSBjLnNvcnQoKHgsIEkpID0+IHgubGVmdCAtIEkubGVmdCksIGggPSBpLnBsYWNlaG9sZGVyTW92aW5nT2JqZWN0c1swXSwgdSA9IGkucGxhY2Vob2xkZXJNb3ZpbmdPYmplY3RzW2kucGxhY2Vob2xkZXJNb3ZpbmdPYmplY3RzLmxlbmd0aCAtIDFdLCBkID0gaC5sZWZ0LCBmID0gdS5sZWZ0IC0gaC5sZWZ0ICsgdS53aWR0aCwgZyA9IGwuZmluZCgoeCwgSSkgPT4ge1xuICAgICAgaWYgKHgubGVmdCA+PSBkIC0gMSkgcmV0dXJuIGxbSV07XG4gICAgfSksIHAgPSBEKFxuICAgICAgKChvID0gZyA9PSBudWxsID8gdm9pZCAwIDogZy5kaXNwbGF5KSA9PSBudWxsID8gdm9pZCAwIDogby5mcm9tKSB8fCAwLFxuICAgICAgdC50U2NhbGVcbiAgICApLCBtID0gYy5tYXAoKHgpID0+IHguaWQpLCBiID0ge30sIFMgPSB7fTtcbiAgICBPYmplY3QudmFsdWVzKHQudHJhY2tJdGVtc01hcCkuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgbS5pbmNsdWRlcyh4LmlkKSAmJiAoYlt4LmlkXSA9IHgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHcgPSB0LmdldE9iamVjdHMoXCJUcmFuc2l0aW9uXCIpLmZpbHRlcigoeCkgPT4geC50b3AgPT09IGNbMF0udG9wKS5tYXAoKHgpID0+IHguaWQpO1xuICAgIE9iamVjdC52YWx1ZXModC50cmFuc2l0aW9uc01hcCkuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgdy5pbmNsdWRlcyh4LmlkKSAmJiAoU1t4LmlkXSA9IHgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGsgPSBobyh7XG4gICAgICB0cmFja0l0ZW1JZHM6IFV0KGMubWFwKCh4KSA9PiB4LmlkKSksXG4gICAgICB0cmFuc2l0aW9uc01hcDogVXQoUyksXG4gICAgICB0cmFja0l0ZW1zTWFwOiBVdChiKVxuICAgIH0pO1xuICAgIGMuZmlsdGVyKFxuICAgICAgKHgpID0+IHgubGVmdCA+PSBkIC0gMVxuICAgICkuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgY29uc3QgSSA9IEQoeC5kaXNwbGF5LmZyb20sIHQudFNjYWxlKSwgTSA9IE9iamVjdC52YWx1ZXModC50cmFuc2l0aW9uc01hcCkuZmluZChcbiAgICAgICAgKFIpID0+IFIua2luZCAhPT0gXCJub25lXCIgJiYgUi50b0lkID09PSB4LmlkXG4gICAgICApO1xuICAgICAgbGV0IEUgPSAwO1xuICAgICAgay5mb3JFYWNoKChSKSA9PiB7XG4gICAgICAgIGlmIChSLm1hcCgoRikgPT4gRiA9PSBudWxsID8gdm9pZCAwIDogRi5pZCkuaW5jbHVkZXMoeC5pZCkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IEYgb2YgUilcbiAgICAgICAgICAgIGlmIChGLnR5cGUgPT09IFwidHJhbnNpdGlvblwiKVxuICAgICAgICAgICAgICBpZiAoKE0gPT0gbnVsbCA/IHZvaWQgMCA6IE0uaWQpID09PSBGLmlkKSB7XG4gICAgICAgICAgICAgICAgRSA9IEUgKyBEKEYuZHVyYXRpb24sIHQudFNjYWxlKSAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIEUgPSBFICsgRChGLmR1cmF0aW9uLCB0LnRTY2FsZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChGLmlkID09PSB4LmlkKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSksIHAgPD0gZCArIGYgJiYgKHgubGVmdCA9IEkgKyBmIC0gRSArIGQgLSBwKTtcbiAgICB9KTtcbiAgfVxuICB0LmFsaWduVHJhbnNpdGlvbnNUb1RyYWNrKCExKTtcbn07XG5mdW5jdGlvbiBEMChpKSB7XG4gIGkub24oXCJvYmplY3Q6bW92aW5nXCIsIHBoKTtcbn1cbmZ1bmN0aW9uIGowKGkpIHtcbiAgaS5vZmYoXCJvYmplY3Q6bW92aW5nXCIsIHBoKTtcbn1cbmxldCBGdCwgdW8gPSAhMTtcbmZ1bmN0aW9uIEUwKGksIHQpIHtcbiAgY29uc3QgZSA9IGkuY2FudmFzO1xuICBpZiAocWQuaW5jbHVkZXMoaS50eXBlKSkge1xuICAgIEZ0IHx8IChGdCA9IGkpO1xuICAgIGNvbnN0IHMgPSBpLnRvcCwgciA9IGkuaGVpZ2h0LCBuID0gaS5sZWZ0LCBvID0gaS53aWR0aCwgYSA9IHQueCwgYyA9IHQueSwgbCA9IE1hdGguYWJzKGMgLSAocyArIHIgLyAyKSkgPD0gSmQ7XG4gICAgTWF0aC5hYnMoYSAtIG4pIDw9IHFvICYmIGwgfHwgTWF0aC5hYnMoYSAtIG4gLSBvKSA8PSBxbyAmJiBsID8gKGUuaG92ZXJDb3JuZXJJdGVtID0gITAsIGkuaG92ZXJDdXJzb3IgPSBcImV3LXJlc2l6ZVwiKSA6IChlLmhvdmVyQ29ybmVySXRlbSA9ICExLCBpLmhvdmVyQ3Vyc29yID0gXCJtb3ZlXCIpLCBlLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfVxufVxuZnVuY3Rpb24gbWgoaSkge1xuICBjb25zdCB0ID0gdGhpcywgZSA9IHQuZmluZFRhcmdldChpLmUpLCBzID0gdC5nZXRTY2VuZVBvaW50KGkuZSk7XG4gIGUgJiYgKGUuaXNTZWxlY3RlZCAmJiBGdCAmJiAoZS5ob3ZlckN1cnNvciA9IFwiZGVmYXVsdFwiKSwgRTAoZSwgcykpO1xufVxuZnVuY3Rpb24gdmgoKSB7XG4gIEZ0ICYmIChGdC5sb2NrTW92ZW1lbnRYID0gITEsIEZ0LmxvY2tNb3ZlbWVudFkgPSAhMSwgRnQgPSB2b2lkIDApO1xufVxuZnVuY3Rpb24geWgoaSkge1xuICBGdCAmJiAodW8gfHwgRnQuX3JlbmRlckNvbnRyb2xzKGkuY3R4KSk7XG59XG5mdW5jdGlvbiBiaCgpIHtcbiAgRnQgJiYgKEZ0ID0gdm9pZCAwLCB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKSk7XG59XG5mdW5jdGlvbiBfaCgpIHtcbiAgdW8gPSAhMDtcbn1cbmZ1bmN0aW9uIFNoKCkge1xuICB1byA9ICExO1xufVxuZnVuY3Rpb24gUDAoaSkge1xuICBpLm9uKFwibW91c2U6b3V0XCIsIGJoLmJpbmQoaSkpLCBpLm9uKFwibW91c2U6dXBcIiwgdmguYmluZChpKSksIGkub24oXCJtb3VzZTptb3ZlXCIsIG1oLmJpbmQoaSkpLCBpLm9uKFwiYWZ0ZXI6cmVuZGVyXCIsIHloLmJpbmQoaSkpLCBpLm9uKFwib2JqZWN0OnJlc2l6aW5nXCIsIF9oLmJpbmQoaSkpLCBpLm9uKFwib2JqZWN0Om1vZGlmaWVkXCIsIFNoLmJpbmQoaSkpO1xufVxuZnVuY3Rpb24gQTAoaSkge1xuICBpLm9mZihcIm1vdXNlOm91dFwiLCBiaC5iaW5kKGkpKSwgaS5vZmYoXCJtb3VzZTp1cFwiLCB2aC5iaW5kKGkpKSwgaS5vZmYoXCJtb3VzZTptb3ZlXCIsIG1oLmJpbmQoaSkpLCBpLm9mZihcImFmdGVyOnJlbmRlclwiLCB5aC5iaW5kKGkpKSwgaS5vZmYoXCJvYmplY3Q6cmVzaXppbmdcIiwgX2guYmluZChpKSksIGkub2ZmKFwib2JqZWN0Om1vZGlmaWVkXCIsIFNoLmJpbmQoaSkpO1xufVxuY29uc3QgRjAgPSAoaSkgPT4ge1xuICBhdCh7IGNhbnZhczogaSB9KSwgQXkoaSksIEl5KGkpLCBSeShpKSwgSHkoaSksIFZ5KGkpLCBvMChpKSwgZDAoaSksIE8wKGkpLCBNMChpKSwgRDAoaSksIFAwKGkpO1xufSwgUjAgPSAoaSkgPT4ge1xuICBhdCh7IGNhbnZhczogbnVsbCB9KSwgRnkoaSksIER5KGkpLCBMeShpKSwgWXkoaSksIEd5KGkpLCBhMChpKSwgZjAoaSksIGswKGkpLCBJMChpKSwgajAoaSksIEEwKGkpO1xufTtcbmNsYXNzIEwwIHtcbiAgcmVtb3ZlVHJhbnNpdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0T2JqZWN0cyhcIlRyYW5zaXRpb25cIik7XG4gICAgdGhpcy5yZW1vdmUoLi4udCk7XG4gIH1cbiAgcmVuZGVyVHJhbnNpdGlvbnMoKSB7XG4gICAgdGhpcy5yZW1vdmVUcmFuc2l0aW9ucygpLCB0aGlzLnRyYW5zaXRpb25JZHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHRoaXMudHJhbnNpdGlvbnNNYXBbdF0sIHMgPSBlLmZyb21JZCwgciA9IGUudG9JZCwgbiA9IHRoaXMuZ2V0T2JqZWN0cygpLCBvID0gbi5maW5kKChkKSA9PiBkLmlkID09PSBzKSwgYSA9IG4uZmluZCgoZCkgPT4gZC5pZCA9PT0gcik7XG4gICAgICBpZiAoIW8gfHwgIWEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGMgPSBEKGUuZHVyYXRpb24sIHRoaXMudFNjYWxlKSwgbCA9IG8ubGVmdCArIG8ud2lkdGggLSBjIC8gMiwgaCA9IG8uaGVpZ2h0LCB1ID0gbmV3IEp0KHtcbiAgICAgICAgaWQ6IGUuaWQsXG4gICAgICAgIGxlZnQ6IGwsXG4gICAgICAgIHRvcDogby50b3AsXG4gICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgd2lkdGg6IGMsXG4gICAgICAgIHRTY2FsZTogdGhpcy50U2NhbGUsXG4gICAgICAgIGR1cmF0aW9uOiBlLmR1cmF0aW9uLFxuICAgICAgICBmcm9tSWQ6IG8uaWQsXG4gICAgICAgIHRvSWQ6IGEuaWQsXG4gICAgICAgIGtpbmQ6IGUua2luZFxuICAgICAgfSk7XG4gICAgICBlLmtpbmQgPT09IFwibm9uZVwiICYmICh1LnZpc2libGUgPSAhMSksIHUgJiYgdGhpcy5hZGQodSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVHJhY2tUcmFuc2l0aW9uc0l0ZW1Db29yZHMoKSB7XG4gICAgdGhpcy5wYXVzZUV2ZW50TGlzdGVuZXJzKCksIHRoaXMuZ2V0T2JqZWN0cyhcIlRyYW5zaXRpb25cIikuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS50U2NhbGUgPSB0aGlzLnRTY2FsZSwgZS51cGRhdGVDb29yZHMoKSwgZS5zZXRDb29yZHMoKTtcbiAgICB9KSwgdGhpcy5yZXN1bWVFdmVudExpc3RlbmVycygpO1xuICB9XG4gIGFsaWduVHJhbnNpdGlvbnNUb1RyYWNrKHQgPSAhMCkge1xuICAgIGNvbnN0IGUgPSB0ID8gW10gOiB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKS5tYXAoKHMpID0+IHMuaWQpO1xuICAgIHRoaXMudHJhbnNpdGlvbklkcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBjb25zdCByID0gdGhpcy5nZXRPYmplY3RzKFwiVHJhbnNpdGlvblwiKS5maW5kKFxuICAgICAgICAobikgPT4gbi5pZCA9PT0gc1xuICAgICAgKTtcbiAgICAgIGlmIChyIGluc3RhbmNlb2YgSnQpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0T2JqZWN0cygpLmZpbmQoXG4gICAgICAgICAgKGMpID0+IGMuaWQgPT09IHIuZnJvbUlkICYmICFlLmluY2x1ZGVzKGMuaWQpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghbikgcmV0dXJuO1xuICAgICAgICBjb25zdCBvID0gRChyLmR1cmF0aW9uLCB0aGlzLnRTY2FsZSksIGEgPSBuLmxlZnQgKyBuLndpZHRoIC0gbyAvIDI7XG4gICAgICAgIHIuc2V0KHtcbiAgICAgICAgICBsZWZ0OiBhLFxuICAgICAgICAgIHRvcDogbi50b3BcbiAgICAgICAgfSksIHIuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVHJhbnNpdGlvbnModCA9ICEwKSB7XG4gICAgdCAmJiB0aGlzLnBhdXNlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRPYmplY3RzKFwiVHJhY2tcIiksIHMgPSB0aGlzLmdldE9iamVjdHMoXCJWaWRlb1wiLCBcIkltYWdlXCIpO1xuICAgIHRoaXMucmVtb3ZlVHJhbnNpdGlvbnMoKTtcbiAgICBjb25zdCByID0ge30sIG4gPSBbXTtcbiAgICBlLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBzLmZpbHRlcigobCkgPT4gYS5pdGVtcy5pbmNsdWRlcyhsLmlkKSkuc29ydCgobCwgaCkgPT4gbC5sZWZ0IC0gaC5sZWZ0KTtcbiAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgYy5sZW5ndGggLSAxOyBsKyspIHtcbiAgICAgICAgY29uc3QgaCA9IGNbbF0sIHUgPSBjW2wgKyAxXTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGgubGVmdCArIGgud2lkdGggLSB1LmxlZnQpIDw9IDEpIHtcbiAgICAgICAgICBjb25zdCBkID0gYCR7aC5pZH0tJHt1LmlkfWA7XG4gICAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbklkcy5pbmNsdWRlcyhkKSkge1xuICAgICAgICAgICAgY29uc3QgZyA9IHRoaXMudHJhbnNpdGlvbnNNYXBbZF07XG4gICAgICAgICAgICByW2RdID0gZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZyA9IHtcbiAgICAgICAgICAgICAgaWQ6IGQsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAxNTAwLFxuICAgICAgICAgICAgICBmcm9tSWQ6IGguaWQsXG4gICAgICAgICAgICAgIHRvSWQ6IHUuaWQsXG4gICAgICAgICAgICAgIGtpbmQ6IFwibm9uZVwiLFxuICAgICAgICAgICAgICB0cmFja0lkOiBhLmlkLFxuICAgICAgICAgICAgICB0eXBlOiBcInRyYW5zaXRpb25cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJbZF0gPSBnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuLnB1c2goZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgdGhpcy50cmFuc2l0aW9uSWRzID0gbiwgdGhpcy50cmFuc2l0aW9uc01hcCA9IHIsIHRoaXMucmVuZGVyVHJhbnNpdGlvbnMoKTtcbiAgICBjb25zdCBvID0gdGhpcy5nZXRPYmplY3RzKFwiVHJhbnNpdGlvblwiKTtcbiAgICB0aGlzLnVwZGF0ZUNhY2hpbmdBY3RpdmVPYmplY3RzKG8pLCB0aGlzLnRyYW5zaXRpb25Hcm91cHMgPSB4cyh7XG4gICAgICB0cmFja0l0ZW1JZHM6IHRoaXMudHJhY2tJdGVtSWRzLFxuICAgICAgdHJhbnNpdGlvbnNNYXA6IHRoaXMudHJhbnNpdGlvbnNNYXAsXG4gICAgICB0cmFja0l0ZW1zTWFwOiB0aGlzLnRyYWNrSXRlbXNNYXBcbiAgICB9KSwgdCAmJiB0aGlzLnJlc3VtZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIFRoKGkpIHtcbiAgY29uc3QgeyBzZWNvbmRhcnlUcmFja3M6IHQsIHByaW1hcnlUcmFja3M6IGUsIHByaW1hcnlQb3NpdGlvbnM6IHMgfSA9IGksIHsgcG9zaXRpb25zOiByLCB0cmFja0luZGV4OiBuIH0gPSBzLCBvID0gbiA9PT0gLTEgPyB0aGlzLnRyYWNrcy5sZW5ndGggOiBuLCBbYV0gPSBPYmplY3Qua2V5cyhlKSwgYyA9IHRoaXMudHJhY2tzLmZpbmQoXG4gICAgKHApID0+IHAuaWQgPT09IGFcbiAgKSwgbCA9IGVbYV0sIGggPSB7XG4gICAgaWQ6IFdzKCksXG4gICAgaXRlbXM6IGwub2JqZWN0cy5tYXAoKHApID0+IHAuaWQpLFxuICAgIHR5cGU6IGMudHlwZSxcbiAgICBhY2NlcHRzOiBjLmFjY2VwdHNcbiAgfSwgdSA9IGNvKFxuICAgIE9iamVjdC5rZXlzKHQpLm1hcCgocCkgPT4gdFtwXS5vYmplY3RzLm1hcCgobSkgPT4gbS5pZCkpXG4gICk7XG4gIGxldCBkID0gcnIodGhpcy50cmFja3MsIFtcbiAgICAuLi5PYmplY3Qua2V5cyhyKSxcbiAgICAuLi51XG4gIF0pO1xuICBjb25zdCBmID0gW107XG4gIE9iamVjdC5rZXlzKHQpLmZvckVhY2goKHApID0+IHtcbiAgICBjb25zdCB7IG9iamVjdHM6IG0sIGluZGV4OiBiIH0gPSB0W3BdLCBTID0gdGhpcy50cmFja3MuZmluZChcbiAgICAgIChPKSA9PiBPLmlkID09PSBwXG4gICAgKSwgdyA9IG0ubWFwKChPKSA9PiBPLmlkKS5maWx0ZXIoKE8pID0+ICF0aGlzLnRyYW5zaXRpb25JZHMuaW5jbHVkZXMoTykpLCBrID0ge1xuICAgICAgaWQ6IGdyKCksXG4gICAgICBpdGVtczogdyxcbiAgICAgIHR5cGU6IFMudHlwZSxcbiAgICAgIGFjY2VwdHM6IFMuYWNjZXB0cyxcbiAgICAgIHRlbXBJbmRleDogYlxuICAgIH07XG4gICAgZi5wdXNoKGspO1xuICB9KTtcbiAgY29uc3QgZyA9IHFsKGgsIGYpO1xuICBnLmxlbmd0aCAmJiBkLnNwbGljZShvLCAwLCAuLi5nKSwgdGhpcy50cmFja3MgPSBkLCB0aGlzLnJlbmRlclRyYWNrcygpLCB0aGlzLnJlZnJlc2hUcmFja0xheW91dCgpLCB0aGlzLmFsaWduSXRlbXNUb1RyYWNrKCksIHRoaXMudW9kYXRlVHJhY2tJdGVtSWRzT3JkZXJpbmcoKSwgdGhpcy5yZWZyZXNoVHJhY2tJdGVtc0ZvclRyYW5zaXRpb25zKCksIHRoaXMuYWRqdXN0TWFnbmV0aWNUcmFjaygpLCB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKCEwKSwgdGhpcy51cGRhdGVTdGF0ZSh7IHVwZGF0ZUhpc3Rvcnk6ICEwLCBraW5kOiBcInVwZGF0ZVwiIH0pO1xufVxuZnVuY3Rpb24geGgoaSkge1xuICBjb25zdCB7XG4gICAgaXNTZWNvbmRhcnlPdmVybGFwcGVkOiB0LFxuICAgIHNlY29uZGFyeVRyYWNrczogZSxcbiAgICBwcmltYXJ5VHJhY2tzOiBzLFxuICAgIHByaW1hcnlQb3NpdGlvbnM6IHJcbiAgfSA9IGksIHsgdHJhY2tJZDogbiwgcG9zaXRpb25zOiBvIH0gPSByLCBhID0gdGhpcy50cmFja3MuZmluZCgoYikgPT4gYi5pZCA9PT0gbiksIGggPSBRKCkucHJpbWFyeU1vdmluZ09iamVjdHMuc29ydCgoYiwgUykgPT4gYi5sZWZ0IC0gUy5sZWZ0KTtcbiAgaC5mb3JFYWNoKChiLCBTKSA9PiB7XG4gICAgaFtTIC0gMV0gJiYgYi5sZWZ0IC0gaFtTIC0gMV0ubGVmdDtcbiAgfSk7XG4gIGNvbnN0IHUgPSB0aGlzLnRyYWNrcy5maW5kSW5kZXgoKGIpID0+IGIuaWQgPT09IG4pLCBkID0gY28oXG4gICAgT2JqZWN0LmtleXMoZSkubWFwKChiKSA9PiBlW2JdLm9iamVjdHMubWFwKChTKSA9PiBTLmlkKSlcbiAgKTtcbiAgbGV0IGYgPSBycih0aGlzLnRyYWNrcywgW1xuICAgIC4uLk9iamVjdC5rZXlzKG8pLFxuICAgIC4uLmRcbiAgXSk7XG4gIE9iamVjdC5rZXlzKHMpLmZvckVhY2goKGIpID0+IHtcbiAgICB0aGlzLnBhdXNlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB7IG9iamVjdHM6IFMgfSA9IHNbYl07XG4gICAgUy5mb3JFYWNoKChPKSA9PiB7XG4gICAgICBpZiAoTy5pc01haW4gJiYgKGEgIT0gbnVsbCAmJiBhLm1hZ25ldGljKSkgcmV0dXJuO1xuICAgICAgY29uc3QgeCA9IG9bTy5pZF07XG4gICAgICBPLmxlZnQgPSB4ID09IG51bGwgPyB2b2lkIDAgOiB4LmxlZnQ7XG4gICAgfSksIHRoaXMucmVzdW1lRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB3ID0gci50cmFja0lkLCBrID0gZi5maW5kKChPKSA9PiBPLmlkID09PSB3KTtcbiAgICBrID09IG51bGwgfHwgay5pdGVtcy5wdXNoKC4uLk9iamVjdC5rZXlzKG8pKSwgdGhpcy50cmFja3MgPSBmO1xuICB9KTtcbiAgY29uc3QgZyA9IHRoaXMudHJhY2tzW3VdLCBwID0gW107XG4gIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGIpID0+IHtcbiAgICBjb25zdCB7IG9iamVjdHM6IFMsIGluZGV4OiB3IH0gPSBlW2JdLCBrID0gUy5maWx0ZXIoKEkpID0+IEkudHlwZSAhPT0gXCJ0cmFuc2l0aW9uXCIpLm1hcCgoSSkgPT4gSS5pZCksIFtPXSA9IGssIHggPSB0aGlzLnRyYWNrSXRlbXNNYXBbT107XG4gICAgaWYgKHQgJiYgeCkge1xuICAgICAgY29uc3QgSSA9IHtcbiAgICAgICAgaWQ6IGdyKCksXG4gICAgICAgIGl0ZW1zOiBrLFxuICAgICAgICB0eXBlOiB4LnR5cGUsXG4gICAgICAgIGFjY2VwdHM6IHRoaXMuYWNjZXB0c01hcFt4LnR5cGVdLFxuICAgICAgICB0ZW1wSW5kZXg6IHdcbiAgICAgIH07XG4gICAgICBwLnB1c2goSSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IEkgPSBmW3UgKyB3XTtcbiAgICAgIEkgPT0gbnVsbCB8fCBJLml0ZW1zLnB1c2goLi4uayksIHRoaXMudHJhY2tzID0gZjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBtID0gcWwoZywgcCk7XG4gIG0ubGVuZ3RoICYmIGYuc3BsaWNlKHUsIDEsIC4uLm0pLCB0aGlzLnRyYWNrcyA9IGYsIHRoaXMucmVuZGVyVHJhY2tzKCksIHRoaXMuYWxpZ25JdGVtc1RvVHJhY2soKSwgdGhpcy51b2RhdGVUcmFja0l0ZW1JZHNPcmRlcmluZygpLCB0aGlzLnJlZnJlc2hUcmFja0l0ZW1zRm9yVHJhbnNpdGlvbnMoKSwgdGhpcy5hZGp1c3RNYWduZXRpY1RyYWNrKCksIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoITApLCB0aGlzLnVwZGF0ZVN0YXRlKHsgdXBkYXRlSGlzdG9yeTogITAsIGtpbmQ6IFwidXBkYXRlXCIgfSk7XG59XG5mdW5jdGlvbiB3aCh7XG4gIHRyYWNrSXRlbUlkczogaSxcbiAgaXNPdmVybGFwcGVkOiB0XG59KSB7XG4gIGNvbnN0IFtlXSA9IGk7XG4gIGlmICghZSkgcmV0dXJuO1xuICBpZiAoIXRoaXMuZ2V0T2JqZWN0cyhcIlRyYW5zaXRpb25cIikuZmluZChcbiAgICAocikgPT4gci5pZCA9PT0gZVxuICApKSB7XG4gICAgY29uc3QgciA9IHRoaXMudHJhY2tzLmZpbmQoXG4gICAgICAobikgPT4gbi5pdGVtcy5pbmNsdWRlcyhlKVxuICAgICk7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNvbnN0IG4gPSBycih0aGlzLnRyYWNrcywgaSksIG8gPSB7XG4gICAgICAgIGlkOiBncigpLFxuICAgICAgICBpdGVtczogW2VdLFxuICAgICAgICB0eXBlOiByLnR5cGUsXG4gICAgICAgIGFjY2VwdHM6IHIuYWNjZXB0c1xuICAgICAgfSwgYSA9IHRoaXMudHJhY2tzLmZpbmRJbmRleChcbiAgICAgICAgKGMpID0+IGMuaWQgPT09IHIuaWRcbiAgICAgICk7XG4gICAgICBuLnNwbGljZShhLCAwLCBvKSwgdGhpcy50cmFja3MgPSBuO1xuICAgIH1cbiAgfVxuICB0aGlzLnJlbmRlclRyYWNrcygpLCB0aGlzLmFsaWduSXRlbXNUb1RyYWNrKCksIHRoaXMucmVmcmVzaFRyYWNrSXRlbXNGb3JUcmFuc2l0aW9ucygpLCB0aGlzLmFkanVzdE1hZ25ldGljVHJhY2soKSwgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyghMCksIHRoaXMudW9kYXRlVHJhY2tJdGVtSWRzT3JkZXJpbmcoKSwgdGhpcy51cGRhdGVTdGF0ZSh7IHVwZGF0ZUhpc3Rvcnk6ICEwLCBraW5kOiBcInVwZGF0ZVwiIH0pO1xufVxubGV0IERuID0geyB4OiAwLCB5OiAwIH07XG5mdW5jdGlvbiBCMChpKSB7XG4gIERuID0gaS5zY2VuZVBvaW50O1xufVxuZnVuY3Rpb24gQ2goaSkge1xuICBjb25zdCB0ID0gaS5zY2VuZVBvaW50O1xuICBpZiAoKERuLnggPT09IHQueCB8fCBEbi55ID09PSB0LnkpICYmICFpLnRhcmdldCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldEVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgciA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIG4gPSBpLmUuY2xpZW50WCAtIHMubGVmdCAtIHJbNF0sIG8gPSBZKG4sIHRoaXMuc2NhbGUuem9vbSk7XG4gICAgaWUobTAsIHsgcGF5bG9hZDogeyB0aW1lOiBvIH0gfSk7XG4gIH1cbn1cbmNvbnN0IFcwID0gKGkpID0+IHtcbiAgaS5vbihcInRyYWNrOmNyZWF0ZVwiLCBUaC5iaW5kKGkpKSwgaS5vbihcInRyYWNrLWl0ZW1zOnJlc2l6ZWRcIiwgd2guYmluZChpKSksIGkub24oXCJ0cmFjay1pdGVtczptb3ZlZFwiLCB4aC5iaW5kKGkpKSwgaS5vbihcIm1vdXNlOnVwXCIsIENoLmJpbmQoaSkpLCBpLm9uKFwibW91c2U6ZG93blwiLCBCMC5iaW5kKGkpKTtcbn07XG5mdW5jdGlvbiBYMChpKSB7XG4gIGkub2ZmKFwidHJhY2s6Y3JlYXRlXCIsIFRoLmJpbmQoaSkpLCBpLm9mZihcInRyYWNrLWl0ZW1zOnJlc2l6ZWRcIiwgd2guYmluZChpKSksIGkub2ZmKFwidHJhY2staXRlbXM6bW92ZWRcIiwgeGguYmluZChpKSksIGkub2ZmKFwibW91c2U6dXBcIiwgQ2guYmluZChpKSk7XG59XG5mdW5jdGlvbiB6MChpLCB0KSB7XG4gIHJldHVybiB0LmZvckVhY2goKGUpID0+IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlLnByb3RvdHlwZSkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgcyAhPT0gXCJjb25zdHJ1Y3RvclwiICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgaS5wcm90b3R5cGUsXG4gICAgICAgIHMsXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZS5wcm90b3R5cGUsIHMpIHx8IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICApO1xuICAgIH0pO1xuICB9KSwgaTtcbn1cbmNvbnN0IEgwID0ge1xuICB2aWRlbzogW1wiKlwiXSxcbiAgaW1hZ2U6IFtcIipcIl0sXG4gIGF1ZGlvOiBbXCIqXCJdLFxuICB0ZXh0OiBbXCIqXCJdLFxuICBjYXB0aW9uOiBbXCIqXCJdLFxuICB0ZW1wbGF0ZTogW1wiKlwiXSxcbiAgY29tcG9zaXRpb246IFtcIipcIl0sXG4gIGlsbHVzdHJhdGlvbjogW1wiKlwiXSxcbiAgc2hhcGU6IFtcIipcIl1cbn0sIFkwID0ge1xuICB2aWRlbzogNDIsXG4gIGltYWdlOiA0MixcbiAgYXVkaW86IDQyLFxuICB0ZXh0OiA0MixcbiAgY2FwdGlvbjogNDIsXG4gIHRlbXBsYXRlOiA0MixcbiAgaWxsdXN0cmF0aW9uOiA0MixcbiAgY29tcG9zaXRpb246IDQyLFxuICBzaGFwZTogNDJcbn0sIFYwID0gW1xuICBcInZpZGVvXCIsXG4gIFwiaW1hZ2VcIixcbiAgXCJhdWRpb1wiLFxuICBcInRleHRcIixcbiAgXCJjYXB0aW9uXCIsXG4gIFwidGVtcGxhdGVcIixcbiAgXCJpbGx1c3RyYXRpb25cIixcbiAgXCJjb21wb3NpdGlvblwiXG5dLCBHMCA9IChpID0ge30pID0+IHtcbiAgY29uc3QgdCA9IE9iamVjdC5hc3NpZ24oe30sIEgwLCBpKSwgZSA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXModCkuZm9yRWFjaCgocykgPT4ge1xuICAgIGNvbnN0IHIgPSB0W3NdO1xuICAgIGVbc10gPSByLmluY2x1ZGVzKFwiKlwiKSA/IFYwIDogcjtcbiAgfSksIGU7XG59LCBOMCA9IChpID0ge30pID0+IHtcbiAgY29uc3QgdCA9IE9iamVjdC5hc3NpZ24oe30sIFkwLCBpKSwgZSA9IHt9O1xuICByZXR1cm4gaSA/IChPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChzKSA9PiB7XG4gICAgY29uc3QgciA9IHRbc107XG4gICAgZVtzXSA9IHI7XG4gIH0pLCBlKSA6IHQ7XG59O1xubGV0IE9oLCBraCwgTWgsIEloLCBEaCwgamgsIEVoLCBQaDtcbmNvbnN0IFUwID0gKGkpID0+IHtcbiAgT2ggPSBpLnN0YXRlLnN1YnNjcmliZVRvQWN0aXZlSWRzKFxuICAgICh7IGFjdGl2ZUlkczogdCB9KSA9PiB7XG4gICAgICBjb25zdCBlID0gaS5hY3RpdmVJZHM7XG4gICAgICBpZiAodC5sZW5ndGggPT09IDEgJiYgZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgcyA9IHRbMF0sIHIgPSBlWzBdLCBvID0gaS5zdGF0ZS5nZXRTdGF0ZSgpLnN0cnVjdHVyZTtcbiAgICAgICAgbGV0IGEgPSBcIlwiO1xuICAgICAgICBpZiAoby5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgYy5pZCA9PT0gciAmJiBjLml0ZW1zLmluY2x1ZGVzKHMpICYmIChhID0gYy5pZCk7XG4gICAgICAgIH0pLCBhICE9PSBcIlwiKSByZXR1cm47XG4gICAgICAgIGkuc2VsZWN0VHJhY2tJdGVtQnlJZHMoW3NdKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBpLnNlbGVjdFRyYWNrSXRlbUJ5SWRzKHQpO1xuICAgIH1cbiAgKSwgUGggPSBpLnN0YXRlLnN1YnNjcmliZVRvVHJhY2tzKFxuICAgICh7IHRyYWNrczogdCwgY2hhbmdlZFRyYWNrczogZSB9KSA9PiB7XG4gICAgICBlLmxlbmd0aCAmJiAoaS50cmFja3MgPSB0LCBpLnJlbmRlclRyYWNrcygpLCBpLnJlZnJlc2hUcmFja0xheW91dCgpKTtcbiAgICB9XG4gICksIEVoID0gaS5zdGF0ZS5zdWJzY3JpYmVUb1VwZGF0ZUFuaW1hdGlvbnMoXG4gICAgKHsgdHJhY2tJdGVtc01hcDogdCwgY2hhbmdlZEFuaW1hdGlvbklkczogZSB9KSA9PiB7XG4gICAgICBpZiAoZSAhPSBudWxsICYmIGUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHMgPSBpLmdldFRyYWNrSXRlbXMoKTtcbiAgICAgICAgaS50cmFja0l0ZW1zTWFwID0gdCwgcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgICAgaWYgKGUuaW5jbHVkZXMoci5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0W3IuaWRdLmFuaW1hdGlvbnM7XG4gICAgICAgICAgICBuICYmIHIuc2V0KHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uczogblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICksIGpoID0gaS5zdGF0ZS5zdWJzY3JpYmVUb1VwZGF0ZVRyYWNrSXRlbVRpbWluZyhcbiAgICAoeyB0cmFja0l0ZW1zTWFwOiB0LCBjaGFuZ2VkVHJpbUlkczogZSwgY2hhbmdlZERpc3BsYXlJZHM6IHMgfSkgPT4ge1xuICAgICAgaWYgKGUgJiYgaS5nZXRUcmFja0l0ZW1zKCkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBpZiAoZS5pbmNsdWRlcyhuLmlkKSkge1xuICAgICAgICAgIGNvbnN0IG8gPSB0W24uaWRdLnRyaW07XG4gICAgICAgICAgbyAmJiBuLnNldCh7XG4gICAgICAgICAgICB0cmltOiB7XG4gICAgICAgICAgICAgIGZyb206IG8uZnJvbSxcbiAgICAgICAgICAgICAgdG86IG8udG9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIHMpIHtcbiAgICAgICAgY29uc3QgciA9IGkuZ2V0VHJhY2tJdGVtcygpO1xuICAgICAgICBpLnBhdXNlRXZlbnRMaXN0ZW5lcnMoKSwgci5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgICAgaWYgKHMuaW5jbHVkZXMobi5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSB0W24uaWRdLmRpc3BsYXk7XG4gICAgICAgICAgICBvICYmIG4uc2V0KHtcbiAgICAgICAgICAgICAgZGlzcGxheTogb1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgaS5yZXN1bWVFdmVudExpc3RlbmVycygpO1xuICAgICAgfVxuICAgICAgaS5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfVxuICApLCBEaCA9IGkuc3RhdGUuc3Vic2NyaWJlVG9TY2FsZSgodCkgPT4ge1xuICAgIGkuc2V0U2NhbGUodC5zY2FsZSk7XG4gIH0pLCBJaCA9IGkuc3RhdGUuc3Vic2NyaWJlVG9VcGRhdGVJdGVtRGV0YWlscygodCkgPT4ge1xuICAgIGNvbnN0IGUgPSBpLmdldFRyYWNrSXRlbXMoKTtcbiAgICBpZiAoZS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBjb25zdCBzID0gaS5zdGF0ZS5nZXRTdGF0ZSgpLCByID0gdC50cmFja0l0ZW1EZXRhaWxzTWFwLCBuID0gcy50cmFja0l0ZW1zTWFwO1xuICAgIGUuZm9yRWFjaCgobykgPT4ge1xuICAgICAgY29uc3QgYSA9IHJbby5pZF07XG4gICAgICBpZiAoYSlcbiAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBfdCB8fCBvIGluc3RhbmNlb2YgUXMgfHwgbyBpbnN0YW5jZW9mIGZ0KSB7XG4gICAgICAgICAgaWYgKGEudHlwZSA9PT0gXCJ2aWRlb1wiIHx8IGEudHlwZSA9PT0gXCJpbWFnZVwiIHx8IGEudHlwZSA9PT0gXCJhdWRpb1wiKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gbltvLmlkXTtcbiAgICAgICAgICAgIGlmIChvLnNyYyAhPT0gYS5kZXRhaWxzLnNyYyAmJiBvLnNldFNyYyAmJiBvLnNldFNyYyhhLmRldGFpbHMuc3JjKSwgYS50eXBlID09PSBcInZpZGVvXCIgfHwgYS50eXBlID09PSBcImF1ZGlvXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgaCA9IGMuZGlzcGxheS50byAtIGMuZGlzcGxheS5mcm9tLCB1ID0gRChcbiAgICAgICAgICAgICAgICBoLFxuICAgICAgICAgICAgICAgIGkuc2NhbGUuem9vbSxcbiAgICAgICAgICAgICAgICBjLnBsYXliYWNrUmF0ZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBvLnNldCh7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgZGlzcGxheTogYy5kaXNwbGF5LFxuICAgICAgICAgICAgICAgIHRyaW06IGMudHJpbSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdVxuICAgICAgICAgICAgICB9KSwgby5zZXRDb29yZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSAobyBpbnN0YW5jZW9mIHRyIHx8IG8gaW5zdGFuY2VvZiBzcikgJiYgKGEudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgYS50eXBlID09PSBcImNhcHRpb25cIikgJiYgby5zZXQoeyB0ZXh0OiBhLmRldGFpbHMudGV4dCB9KTtcbiAgICB9KSwgaS5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH0pLCBNaCA9IGkuc3RhdGUuc3Vic2NyaWJlVG9IaXN0b3J5KCh0KSA9PiB7XG4gICAgaS50cmFja3MgPSB0LnRyYWNrcywgaS50cmFja0l0ZW1zTWFwID0gdC50cmFja0l0ZW1zTWFwLCBpLnRyYWNrSXRlbUlkcyA9IHQudHJhY2tJdGVtSWRzLCBpLnRyYWNrSXRlbURldGFpbHNNYXAgPSB0LnRyYWNrSXRlbURldGFpbHNNYXAsIGkudHJhbnNpdGlvbklkcyA9IHQudHJhbnNpdGlvbklkcywgaS50cmFuc2l0aW9uc01hcCA9IHQudHJhbnNpdGlvbnNNYXAsIGkudHJhbnNpdGlvbkdyb3VwcyA9IHhzKHtcbiAgICAgIHRyYWNrSXRlbUlkczogaS50cmFja0l0ZW1JZHMsXG4gICAgICB0cmFuc2l0aW9uc01hcDogaS50cmFuc2l0aW9uc01hcCxcbiAgICAgIHRyYWNrSXRlbXNNYXA6IGkudHJhY2tJdGVtc01hcFxuICAgIH0pLCBpLnJlbmRlclRyYWNrcygpLCBpLnJlZnJlc2hUcmFja0xheW91dCgpLCBpLnVwZGF0ZVRyYWNrSXRlbUNvb3JkcygpLCBpLmFsaWduSXRlbXNUb1RyYWNrKCksIGkuYWxpZ25UcmFuc2l0aW9uc1RvVHJhY2soKSwgaS5hZGp1c3RNYWduZXRpY1RyYWNrKCksIGkudXBkYXRlVHJhbnNpdGlvbnMoKSwgaS5jYWxjQm91bmRpbmcoKSwgaS5kdXJhdGlvbiA9IHBsKGkudHJhY2tJdGVtc01hcCk7XG4gIH0pLCBraCA9IGkuc3RhdGUuc3Vic2NyaWJlVG9BZGRPclJlbW92ZUl0ZW1zKCgpID0+IHtcbiAgICBjb25zdCB0ID0gaS5nZXRUcmFja0l0ZW1zKCkubWFwKChuKSA9PiBuLmlkKSwgZSA9IGkuc3RhdGUuZ2V0U3RhdGUoKSwgcyA9IGUudHJhY2tJdGVtSWRzLCByID0gW107XG4gICAgdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBzLmluY2x1ZGVzKG4pIHx8IHIucHVzaChuKTtcbiAgICB9KSwgaS5kZWxldGVUcmFja0l0ZW1CeUlkKHIpLCBpLnRyYWNrcyA9IGUudHJhY2tzLCBpLnRyYWNrSXRlbXNNYXAgPSBlLnRyYWNrSXRlbXNNYXAsIGkudHJhY2tJdGVtRGV0YWlsc01hcCA9IGUudHJhY2tJdGVtRGV0YWlsc01hcCwgaS50cmFuc2l0aW9uSWRzID0gZS50cmFuc2l0aW9uSWRzLCBpLnRyYW5zaXRpb25zTWFwID0gZS50cmFuc2l0aW9uc01hcCwgcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBpZiAoIXQuaW5jbHVkZXMobikpIHtcbiAgICAgICAgY29uc3QgYSA9IHtcbiAgICAgICAgICAuLi5lLnRyYWNrSXRlbXNNYXBbbl0sXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgLi4uZS50cmFja0l0ZW1EZXRhaWxzTWFwW25dLmRldGFpbHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGkuYWRkVHJhY2tJdGVtKGEpO1xuICAgICAgfVxuICAgIH0pLCBpLnRyYWNrSXRlbUlkcyA9IGUudHJhY2tJdGVtSWRzLCBpLmFjdGl2ZUlkcyA9IGUuYWN0aXZlSWRzLCBpLnRyYW5zaXRpb25Hcm91cHMgPSB4cyh7XG4gICAgICB0cmFja0l0ZW1JZHM6IGkudHJhY2tJdGVtSWRzLFxuICAgICAgdHJhbnNpdGlvbnNNYXA6IGkudHJhbnNpdGlvbnNNYXAsXG4gICAgICB0cmFja0l0ZW1zTWFwOiBpLnRyYWNrSXRlbXNNYXBcbiAgICB9KSwgaS5yZW5kZXJUcmFja3MoKSwgaS5hbGlnbkl0ZW1zVG9UcmFjaygpLCBpLnVwZGF0ZVRyYWNrSXRlbUNvb3JkcygpLCBpLmNhbGNCb3VuZGluZygpLCBpLnVwZGF0ZVRyYW5zaXRpb25zKCksIGkucmVmcmVzaFRyYWNrTGF5b3V0KCksIGkuc2VsZWN0VHJhY2tJdGVtQnlJZHMoZS5hY3RpdmVJZHMpO1xuICB9KTtcbn0sICQwID0gKGkpID0+IHtcbiAgT2gudW5zdWJzY3JpYmUoKSwga2gudW5zdWJzY3JpYmUoKSwgTWgudW5zdWJzY3JpYmUoKSwgSWgudW5zdWJzY3JpYmUoKSwgRGgudW5zdWJzY3JpYmUoKSwgamgudW5zdWJzY3JpYmUoKSwgRWgudW5zdWJzY3JpYmUoKSwgUGgudW5zdWJzY3JpYmUoKTtcbn0sIEFhID0gKGksIHQpID0+IHtcbiAgbGV0IGUgPSAhMTtcbiAgY29uc3QgcyA9IFtdO1xuICByZXR1cm4gdC5mb3JFYWNoKChyKSA9PiB7XG4gICAgci5jb250YWluc1BvaW50KGkpICYmIChzLnB1c2gociksIGUgPSAhMCk7XG4gIH0pLCB7IGlzT3Zlck9iamVjdDogZSwgb3Zlck9iamVjdHM6IHMgfTtcbn07XG5mdW5jdGlvbiBxMChpKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGkpKTtcbn1cbmNsYXNzIEswIGV4dGVuZHMgdm4ge1xuICBjb25zdHJ1Y3RvcihlLCBzKSB7XG4gICAgdmFyIHI7XG4gICAgc3VwZXIoZSwgcyk7XG4gICAgVCh0aGlzLCBcImFjY2VwdHNNYXBcIik7XG4gICAgVCh0aGlzLCBcInNpemVzTWFwXCIsIHt9KTtcbiAgICAvLyBEZWNsYXJlIHByb3BlcnRpZXMgZnJvbSBzdGF0ZVxuICAgIFQodGhpcywgXCJ0cmFja3NcIiwgW10pO1xuICAgIFQodGhpcywgXCJob3ZlckNvcm5lckl0ZW1cIiwgITEpO1xuICAgIFQodGhpcywgXCJ0cmFja0l0ZW1zTWFwXCIsIHt9KTtcbiAgICBUKHRoaXMsIFwidHJhY2tJdGVtSWRzXCIsIFtdKTtcbiAgICBUKHRoaXMsIFwidHJhbnNpdGlvbklkc1wiLCBbXSk7XG4gICAgVCh0aGlzLCBcInRyYW5zaXRpb25zTWFwXCIsIHt9KTtcbiAgICBUKHRoaXMsIFwidHJhY2tJdGVtRGV0YWlsc01hcFwiLCB7fSk7XG4gICAgVCh0aGlzLCBcInNjYWxlXCIpO1xuICAgIFQodGhpcywgXCJkdXJhdGlvblwiKTtcbiAgICBUKHRoaXMsIFwiYm91bmRpbmdcIik7XG4gICAgVCh0aGlzLCBcIm9uU2Nyb2xsXCIpO1xuICAgIFQodGhpcywgXCJvblJlc2l6ZUNhbnZhc1wiKTtcbiAgICBUKHRoaXMsIFwidFNjYWxlXCIpO1xuICAgIFQodGhpcywgXCJzdGF0ZVwiKTtcbiAgICBUKHRoaXMsIFwiYWN0aXZlSWRzXCIsIFtdKTtcbiAgICBUKHRoaXMsIFwic3BhY2luZ1wiKTtcbiAgICBUKHRoaXMsIFwiZ3VpZGVMaW5lQ29sb3JcIik7XG4gICAgVCh0aGlzLCBcInRyYW5zaXRpb25Hcm91cHNcIiwgW10pO1xuICAgIHRoaXMuYm91bmRpbmcgPSBzLmJvdW5kaW5nIHx8IHtcbiAgICAgIHdpZHRoOiBzLndpZHRoIHx8IDAsXG4gICAgICBoZWlnaHQ6IHMuaGVpZ2h0IHx8IDBcbiAgICB9LCB0aGlzLnRTY2FsZSA9ICgociA9IHMuc2NhbGUpID09IG51bGwgPyB2b2lkIDAgOiByLnpvb20pIHx8IDEsIHRoaXMuc3RhdGUgPSBzLnN0YXRlLCB0aGlzLm9uU2Nyb2xsID0gcy5vblNjcm9sbCwgdGhpcy5vblJlc2l6ZUNhbnZhcyA9IHMub25SZXNpemVDYW52YXMsIHRoaXMuYWNjZXB0c01hcCA9IEcwKHMuYWNjZXB0c01hcCksIHRoaXMuc2l6ZXNNYXAgPSBOMChzLnNpemVzTWFwKSwgdGhpcy5zcGFjaW5nID0gV3kocy5zcGFjaW5nKSwgdGhpcy5wb3NpdGlvbkFmdGVyVHJhbnNmb3JtID0ge30sIHRoaXMuaW5pdGlhbGl6ZUNhbnZhc0RlZmF1bHRzKCksIHRoaXMuc2NhbGUgPSBzLnNjYWxlLCB0aGlzLmR1cmF0aW9uID0gcy5kdXJhdGlvbiwgdGhpcy5ndWlkZUxpbmVDb2xvciA9IHMuZ3VpZGVMaW5lQ29sb3IgfHwgdnQsIHRoaXMuaW5pdEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgc3RhdGljIHJlZ2lzdGVySXRlbXMoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKHMpID0+IHtcbiAgICAgIEMuc2V0Q2xhc3MoZVtzXSwgcyk7XG4gICAgfSk7XG4gIH1cbiAgaW5pdGlhbGl6ZUNhbnZhc0RlZmF1bHRzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgIGVbNF0gPSB0aGlzLnNwYWNpbmcubGVmdCwgT2JqZWN0LmFzc2lnbihudC5vd25EZWZhdWx0cywge1xuICAgICAgYm9yZGVyQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgIGNvcm5lckNvbG9yOiBcIndoaXRlXCIsXG4gICAgICBjb3JuZXJTdHJva2VDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICBib3JkZXJPcGFjaXR5V2hlbk1vdmluZzogMSxcbiAgICAgIGJvcmRlclNjYWxlRmFjdG9yOiAxLFxuICAgICAgY29ybmVyU2l6ZTogOCxcbiAgICAgIGNvcm5lclN0eWxlOiBcInJlY3RcIixcbiAgICAgIGNlbnRlcmVkU2NhbGluZzogITEsXG4gICAgICBjZW50ZXJlZFJvdGF0aW9uOiAhMCxcbiAgICAgIHRyYW5zcGFyZW50Q29ybmVyczogITFcbiAgICB9KTtcbiAgfVxuICAvLyBkZXRlY3QgaWYgdGhlIG1vdXNlIGNsaWNrIGRvZXMgbm90IGxhbmQgb24gYW55IGl0ZW0gLT4gY2xlYW4gdGhlIHNlbGVjdGlvbiBhbmQgZ2VuZXJhdGUgYW5vdGhlciBzZWxlY3Rpb25cbiAgX19vbk1vdXNlRG93bihlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0U2NlbmVQb2ludChlKSwgciA9IHRoaXMuX2FjdGl2ZU9iamVjdCwgbiA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpO1xuICAgIGlmIChuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc3VwZXIuX19vbk1vdXNlRG93bihlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBpc092ZXJPYmplY3Q6IG8gfSA9IEFhKFxuICAgICAgcyxcbiAgICAgIG5cbiAgICApO1xuICAgIGlmIChyICYmIChyID09IG51bGwgPyB2b2lkIDAgOiByLmZpbmRDb250cm9sKFxuICAgICAgdGhpcy5nZXRWaWV3cG9ydFBvaW50KGUpLFxuICAgICAgenkoZSlcbiAgICApKSkge1xuICAgICAgc3VwZXIuX19vbk1vdXNlRG93bihlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYSA9IHRoaXMuZ2V0VHJhY2tJdGVtcygpLCBjID0gdGhpcy5nZXRPYmplY3RzKFwiVHJhbnNpdGlvblwiKSwgeyBpc092ZXJPYmplY3Q6IGwsIG92ZXJPYmplY3RzOiBoIH0gPSBBYShcbiAgICAgIHMsXG4gICAgICBbLi4uYywgLi4uYV1cbiAgICApO1xuICAgIGwgPyBvID8gc3VwZXIuX19vbk1vdXNlRG93bihlKSA6ICh0aGlzLnNldEFjdGl2ZUlkcyhbaFswXS5pZF0pLCBzdXBlci5fX29uTW91c2VEb3duKGUpKSA6ICh0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoKSwgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCksIHRoaXMuc2V0QWN0aXZlSWRzKFtdKSwgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IHtcbiAgICAgIHg6IHMueCxcbiAgICAgIHk6IHMueSxcbiAgICAgIGRlbHRhWTogMCxcbiAgICAgIGRlbHRhWDogMFxuICAgIH0sIHN1cGVyLl9fb25Nb3VzZURvd24oZSkpO1xuICB9XG4gIF9zZXR1cEN1cnJlbnRUcmFuc2Zvcm0oZSwgcywgcikge1xuICAgIHZhciBuO1xuICAgIGlmICh0aGlzLmhvdmVyQ29ybmVySXRlbSkge1xuICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0U2NlbmVQb2ludChlKSwgeyBrZXk6IGEgPSBcIlwiLCBjb250cm9sOiBjIH0gPSBzLmdldEFjdGl2ZUNvbnRyb2woKSB8fCB7fSwgbCA9IGMgJiYgKChuID0gYy5nZXRBY3Rpb25IYW5kbGVyKGUsIHMsIGMpKSA9PSBudWxsID8gdm9pZCAwIDogbi5iaW5kKGMpKSwgaCA9IHRoaXMuX2dldE9yaWdpbkZyb21Db3JuZXIocywgYSksIHUgPSB7XG4gICAgICAgIHRhcmdldDogcyxcbiAgICAgICAgYWN0aW9uOiBcInJlc2l6aW5nXCIsXG4gICAgICAgIGFjdGlvbkhhbmRsZXI6IGwsXG4gICAgICAgIGFjdGlvblBlcmZvcm1lZDogITEsXG4gICAgICAgIGNvcm5lcjogYSxcbiAgICAgICAgc2NhbGVYOiBzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiBzLnNjYWxlWSxcbiAgICAgICAgc2tld1g6IHMuc2tld1gsXG4gICAgICAgIHNrZXdZOiBzLnNrZXdZLFxuICAgICAgICBvZmZzZXRYOiBvLnggLSBzLmxlZnQsXG4gICAgICAgIG9mZnNldFk6IG8ueSAtIHMudG9wLFxuICAgICAgICBvcmlnaW5YOiBoLngsXG4gICAgICAgIG9yaWdpblk6IGgueSxcbiAgICAgICAgZXg6IG8ueCxcbiAgICAgICAgZXk6IG8ueSxcbiAgICAgICAgbGFzdFg6IG8ueCxcbiAgICAgICAgbGFzdFk6IG8ueSxcbiAgICAgICAgdGhldGE6IHMuYW5nbGUgKiBNYXRoLlBJIC8gMTgwLFxuICAgICAgICB3aWR0aDogcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzLmhlaWdodCxcbiAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXksXG4gICAgICAgIGFsdEtleTogITEsXG4gICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgc2NhbGVYOiBzLnNjYWxlWCxcbiAgICAgICAgICBzY2FsZVk6IHMuc2NhbGVZLFxuICAgICAgICAgIHNrZXdYOiBzLnNrZXdYLFxuICAgICAgICAgIHNrZXdZOiBzLnNrZXdZLFxuICAgICAgICAgIGFuZ2xlOiBzLmFuZ2xlLFxuICAgICAgICAgIGxlZnQ6IHMubGVmdCxcbiAgICAgICAgICBmbGlwWDogcy5mbGlwWCxcbiAgICAgICAgICBmbGlwWTogcy5mbGlwWSxcbiAgICAgICAgICB0b3A6IHMudG9wLFxuICAgICAgICAgIG9yaWdpblg6IGgueCxcbiAgICAgICAgICBvcmlnaW5ZOiBoLnlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSB1LCB0aGlzLmZpcmUoXCJiZWZvcmU6dHJhbnNmb3JtXCIsIHtcbiAgICAgICAgZSxcbiAgICAgICAgdHJhbnNmb3JtOiB1XG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICAgIHN1cGVyLl9zZXR1cEN1cnJlbnRUcmFuc2Zvcm0oZSwgcywgcik7XG4gIH1cbiAgaW5pdEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIFcwKHRoaXMpLCBGMCh0aGlzKSwgVTAodGhpcyk7XG4gIH1cbiAgc2V0QWN0aXZlSWRzKGUpIHtcbiAgICB0aGlzLmFjdGl2ZUlkcyA9IGUsIHRoaXMuc3RhdGUudXBkYXRlU3RhdGUoXG4gICAgICB7XG4gICAgICAgIGFjdGl2ZUlkczogcTAodGhpcy5hY3RpdmVJZHMpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBraW5kOiBcImxheWVyOnNlbGVjdGlvblwiLFxuICAgICAgICB1cGRhdGVIaXN0b3J5OiAhMVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgdXBkYXRlU3RhdGUoZSA9IHsgdXBkYXRlSGlzdG9yeTogITEgfSkge1xuICAgIHRoaXMuZmlsdGVyRW1wdHlUcmFja3MoKSwgdGhpcy5zeW5jaHJvbml6ZVRyYWNrSXRlbXNTdGF0ZSgpLCB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKSwgdGhpcy5kdXJhdGlvbiA9IHRoaXMuZ2V0RHVyYXRpb25CYXNlZE9uVHJhY2tJdGVtc1Bvc2l0aW9uKCksIHRoaXMuY2FsY0JvdW5kaW5nKCksIHRoaXMucmVmcmVzaFRyYWNrTGF5b3V0KCksIHRoaXMuc2V0VHJhY2tJdGVtQ29vcmRzKCk7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0VXBkYXRlZFN0YXRlKCk7XG4gICAgdGhpcy5zdGF0ZS51cGRhdGVTdGF0ZShzLCBlKTtcbiAgfVxuICBnZXRVcGRhdGVkU3RhdGUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0RHVyYXRpb25CYXNlZE9uVHJhY2tJdGVtc1Bvc2l0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNrczogdGhpcy50cmFja3MsXG4gICAgICB0cmFja0l0ZW1JZHM6IHRoaXMudHJhY2tJdGVtSWRzLFxuICAgICAgdHJhY2tJdGVtc01hcDogdGhpcy50cmFja0l0ZW1zTWFwLFxuICAgICAgdHJhbnNpdGlvbklkczogdGhpcy50cmFuc2l0aW9uSWRzLFxuICAgICAgdHJhbnNpdGlvbnNNYXA6IHRoaXMudHJhbnNpdGlvbnNNYXAsXG4gICAgICBzY2FsZTogdGhpcy5zY2FsZSxcbiAgICAgIGR1cmF0aW9uOiBlXG4gICAgfTtcbiAgfVxuICBnZXREdXJhdGlvbkJhc2VkT25UcmFja0l0ZW1zUG9zaXRpb24oKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0VHJhY2tJdGVtcygpLm1hcCgobikgPT4gbi5nZXRCb3VuZGluZ1JlY3QoKSksIHMgPSBlLnJlZHVjZSgobiwgbykgPT4gbi5sZWZ0ICsgbi53aWR0aCA8IG8ubGVmdCArIG8ud2lkdGggPyBvIDogbiwgZVswXSksIHIgPSBzLmxlZnQgKyBzLndpZHRoO1xuICAgIHJldHVybiBZKHIsIHRoaXMudFNjYWxlKTtcbiAgfVxuICBub3RpZnkoZSA9IHsgdXBkYXRlSGlzdG9yeTogITEgfSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldFVwZGF0ZWRTdGF0ZSgpO1xuICAgIHRoaXMuc3RhdGUudXBkYXRlU3RhdGUocywgZSk7XG4gIH1cbiAgZ2V0U3RhdGUoKSB7XG4gICAgY29uc3QgZSA9IHBsKHRoaXMudHJhY2tJdGVtc01hcCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNrczogdGhpcy50cmFja3MsXG4gICAgICB0cmFja0l0ZW1JZHM6IHRoaXMudHJhY2tJdGVtSWRzLFxuICAgICAgdHJhY2tJdGVtc01hcDogdGhpcy50cmFja0l0ZW1zTWFwLFxuICAgICAgdHJhbnNpdGlvbklkczogdGhpcy50cmFuc2l0aW9uSWRzLFxuICAgICAgdHJhbnNpdGlvbnNNYXA6IHRoaXMudHJhbnNpdGlvbnNNYXAsXG4gICAgICB0cmFja0l0ZW1EZXRhaWxzTWFwOiB0aGlzLnRyYWNrSXRlbURldGFpbHNNYXAsXG4gICAgICBzY2FsZTogdGhpcy5zY2FsZSxcbiAgICAgIGR1cmF0aW9uOiBlXG4gICAgfTtcbiAgfVxuICBwdXJnZSgpIHtcbiAgICBSMCh0aGlzKSwgWDAodGhpcyksICQwKCksIHRoaXMuZGlzcG9zZSgpO1xuICB9XG4gIHNjcm9sbFRvKHtcbiAgICBzY3JvbGxMZWZ0OiBlLFxuICAgIHNjcm9sbFRvcDogc1xuICB9KSB7XG4gICAgdmFyIG87XG4gICAgY29uc3QgciA9IFsuLi50aGlzLnZpZXdwb3J0VHJhbnNmb3JtXTtcbiAgICBsZXQgbiA9ICExO1xuICAgIHR5cGVvZiBlID09IFwibnVtYmVyXCIgJiYgKHJbNF0gPSAtZSArIHRoaXMuc3BhY2luZy5sZWZ0LCBuID0gITApLCB0eXBlb2YgcyA9PSBcIm51bWJlclwiICYmIChyWzVdID0gLXMsIG4gPSAhMCksIG4gJiYgKHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSByLCAobyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0KCkpID09IG51bGwgfHwgby5zZXRDb29yZHMoKSwgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCkpO1xuICB9XG4gIHNldEJvdW5kaW5nKGUpIHtcbiAgICB0aGlzLmJvdW5kaW5nID0gZTtcbiAgfVxuICBjYWxjQm91bmRpbmcoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0T2JqZWN0cyhcIlRyYWNrXCIpLmZpbHRlcihcbiAgICAgIChjKSA9PiBjLnN0YXRpY1xuICAgICksIHMgPSBbLi4udGhpcy5nZXRUcmFja0l0ZW1zKCksIC4uLmVdLnJlZHVjZShcbiAgICAgIChjLCBsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdG9wOiBoLCBoZWlnaHQ6IHUgfSA9IGwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiBNYXRoLm1pbihjLnRvcCwgaCksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChjLmhlaWdodCwgaCArIHUpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0b3A6IDEgLyAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH1cbiAgICApLCByID0gWy4uLnRoaXMuZ2V0VHJhY2tJdGVtcygpXS5yZWR1Y2UoXG4gICAgICAoYywgbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGxlZnQ6IGgsIHdpZHRoOiB1IH0gPSBsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6IE1hdGgubWluKGMubGVmdCwgaCksXG4gICAgICAgICAgd2lkdGg6IE1hdGgubWF4KGMud2lkdGgsIGggKyB1KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbGVmdDogMSAvIDAsXG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoXG4gICAgICB9XG4gICAgKSwgbiA9IHRoaXMuYm91bmRpbmcud2lkdGgsIG8gPSByLndpZHRoLCBhID0gbyAtIG47XG4gICAgaWYgKGEgPCAwKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5nZXRUcmFja0l0ZW1zKCksIGwgPSB0aGlzLmdldEVsZW1lbnQoKS5jbGllbnRXaWR0aCwgaCA9IGMucmVkdWNlKFxuICAgICAgICAodSwgZCkgPT4gZC5sZWZ0ICsgZC53aWR0aCA+IHUubGVmdCArIHUud2lkdGggPyBkIDogdSxcbiAgICAgICAgY1swXVxuICAgICAgKTtcbiAgICAgIE1hdGguYWJzKGEpID4gbCA/IHRoaXMuc2V0Vmlld3BvcnRQb3MoXG4gICAgICAgIC0obyAtIGwpIC0gdGhpcy5zcGFjaW5nLnJpZ2h0LFxuICAgICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzVdXG4gICAgICApIDogaC5sZWZ0ICsgaC53aWR0aCA8PSBsID8gdGhpcy5zZXRWaWV3cG9ydFBvcygxNiwgdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs1XSkgOiB0aGlzLnNldFZpZXdwb3J0UG9zKFxuICAgICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzRdIC0gYSxcbiAgICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs1XVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5ib3VuZGluZyA9IHtcbiAgICAgIC4uLnMsXG4gICAgICAuLi5yXG4gICAgfSwgaWUocDAsIHtcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgYm91bmRpbmc6IHtcbiAgICAgICAgICAuLi5zLFxuICAgICAgICAgIC4uLnJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFZpZXdwb3J0UG9zKGUsIHMpIHtcbiAgICB2YXIgbztcbiAgICBjb25zdCByID0gdGhpcy5nZXRWaWV3cG9ydFBvcyhlLCBzKSwgbiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgbls0XSA9IHIueCwgbls1XSA9IHIueSwgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCksIHRoaXMuc2V0QWN0aXZlVHJhY2tJdGVtQ29vcmRzKCksIChvID0gdGhpcy5vblNjcm9sbCkgPT0gbnVsbCB8fCBvLmNhbGwodGhpcywge1xuICAgICAgc2Nyb2xsVG9wOiByLnksXG4gICAgICBzY3JvbGxMZWZ0OiByLnggLSB0aGlzLnNwYWNpbmcubGVmdFxuICAgIH0pO1xuICB9XG4gIGdldFZpZXdwb3J0UG9zKGUsIHMpIHtcbiAgICBjb25zdCByID0gdGhpcywgbiA9IHRoaXMuYm91bmRpbmcud2lkdGggLSAxMDAgPj0gci53aWR0aCA/IHRoaXMuc3BhY2luZy5yaWdodCA6IDAsIG8gPSByLndpZHRoIC0gdGhpcy5ib3VuZGluZy53aWR0aCAtIG4sIGEgPSB0aGlzLnNwYWNpbmcubGVmdCwgYyA9IE1hdGgubWF4KG8sIE1hdGgubWluKGUsIGEpKTtcbiAgICBpZiAodGhpcy5ib3VuZGluZy5oZWlnaHQgPCB0aGlzLmhlaWdodClcbiAgICAgIHJldHVybiB7IHg6IGMsIHk6IDAgfTtcbiAgICBjb25zdCBsID0gci5oZWlnaHQgLSB0aGlzLmJvdW5kaW5nLmhlaWdodCAtIDQwLCB1ID0gTWF0aC5tYXgobCwgTWF0aC5taW4ocywgMCkpO1xuICAgIHJldHVybiB7IHg6IGMsIHk6IHUgfTtcbiAgfVxuICBzZXRTY2FsZShlKSB7XG4gICAgdGhpcy5wYXVzZUV2ZW50TGlzdGVuZXJzKCksIHRoaXMudFNjYWxlID0gZS56b29tLCB0aGlzLnNjYWxlID0gZSwgdGhpcy5nZXRPYmplY3RzKFxuICAgICAgXCJWaWRlb1wiLFxuICAgICAgXCJJbWFnZVwiLFxuICAgICAgXCJUZXh0XCIsXG4gICAgICBcIkF1ZGlvXCIsXG4gICAgICBcIkNhcHRpb25cIixcbiAgICAgIFwiVGVtcGxhdGVcIlxuICAgICkuZm9yRWFjaCgocikgPT4ge1xuICAgICAgY29uc3QgbiA9IHRoaXMudHJhbnNpdGlvbkdyb3Vwcy5maW5kKChvKSA9PiBvLmZpbmQoKGEpID0+IGEuaWQgPT09IHIuaWQpKSB8fCBbXTtcbiAgICAgIGlmICgobiA9PSBudWxsID8gdm9pZCAwIDogbi5sZW5ndGgpID09PSAxKSB7XG4gICAgICAgIGNvbnN0IG8gPSBEKHIuZGlzcGxheS5mcm9tLCB0aGlzLnRTY2FsZSksIGEgPSBEKFxuICAgICAgICAgIHIuZGlzcGxheS50byAtIHIuZGlzcGxheS5mcm9tLFxuICAgICAgICAgIHRoaXMudFNjYWxlLFxuICAgICAgICAgIHIucGxheWJhY2tSYXRlXG4gICAgICAgICk7XG4gICAgICAgIHIuc2V0KHsgbGVmdDogbywgd2lkdGg6IGEsIHRTY2FsZTogZS56b29tIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbyA9IG4uZmluZEluZGV4KCh1KSA9PiB1LmlkID09PSByLmlkKSwgYSA9IG5bbyAtIDFdLCBjID0gbltvICsgMV0sIGwgPSBuLmZpbHRlcihcbiAgICAgICAgICAodSkgPT4gdS50eXBlID09PSBcInRyYW5zaXRpb25cIlxuICAgICAgICApLCBoID0gdGhpcy50cmFja0l0ZW1zTWFwW3IuaWRdO1xuICAgICAgICBpZiAoYSAmJiAhYykge1xuICAgICAgICAgIGNvbnN0IHUgPSBsLmluZGV4T2YoYSksIGYgPSBsLnNsaWNlKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHVcbiAgICAgICAgICApLnJlZHVjZSgobSwgYikgPT4gbSArIChiLmR1cmF0aW9uIHx8IDApLCAwKSwgZyA9IEQoXG4gICAgICAgICAgICBoLmRpc3BsYXkuZnJvbSAtIChhLmR1cmF0aW9uIHx8IDApIC8gMiAtIGYsXG4gICAgICAgICAgICB0aGlzLnRTY2FsZVxuICAgICAgICAgICksIHAgPSBEKFxuICAgICAgICAgICAgaC5kaXNwbGF5LnRvIC0gaC5kaXNwbGF5LmZyb20gLSAoYS5kdXJhdGlvbiB8fCAwKSAvIDIsXG4gICAgICAgICAgICB0aGlzLnRTY2FsZSxcbiAgICAgICAgICAgIGgucGxheWJhY2tSYXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByLnNldCh7IGxlZnQ6IGcsIHdpZHRoOiBwLCB0U2NhbGU6IGUuem9vbSB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjICYmICFhKSB7XG4gICAgICAgICAgY29uc3QgdSA9IEQoaC5kaXNwbGF5LmZyb20sIHRoaXMudFNjYWxlKSwgZCA9IEQoXG4gICAgICAgICAgICBoLmRpc3BsYXkudG8gLSBoLmRpc3BsYXkuZnJvbSAtIChjLmR1cmF0aW9uIHx8IDApIC8gMixcbiAgICAgICAgICAgIHRoaXMudFNjYWxlLFxuICAgICAgICAgICAgaC5wbGF5YmFja1JhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHIuc2V0KHsgbGVmdDogdSwgd2lkdGg6IGQsIHRTY2FsZTogZS56b29tIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGEgJiYgYykge1xuICAgICAgICAgIGNvbnN0IHUgPSBEKFxuICAgICAgICAgICAgaC5kaXNwbGF5LmZyb20gLSAoYS5kdXJhdGlvbiB8fCAwKSAvIDIsXG4gICAgICAgICAgICB0aGlzLnRTY2FsZVxuICAgICAgICAgICksIGQgPSBEKFxuICAgICAgICAgICAgaC5kaXNwbGF5LnRvIC0gaC5kaXNwbGF5LmZyb20gLSAoYy5kdXJhdGlvbiB8fCAwKSAvIDIgLSAoYS5kdXJhdGlvbiB8fCAwKSAvIDIsXG4gICAgICAgICAgICB0aGlzLnRTY2FsZSxcbiAgICAgICAgICAgIHIucGxheWJhY2tSYXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByLnNldCh7IGxlZnQ6IHUsIHdpZHRoOiBkLCB0U2NhbGU6IGUuem9vbSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgci5vblNjYWxlICYmIHIub25TY2FsZSgpLCByLnNldENvb3JkcygpO1xuICAgIH0pLCB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKSwgdGhpcy5jYWxjQm91bmRpbmcoKSwgdGhpcy5yZWZyZXNoVHJhY2tMYXlvdXQoKSwgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyghMSksIHRoaXMucmVzdW1lRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxufVxuejAoSzAsIFtcbiAgQ2YsXG4gIE15LFxuICBreSxcbiAgTDBcbl0pO1xuY29uc3QgcmIgPSB7XG4gIGF1ZGlvOiBfbixcbiAgbWVkaWE6IHhuLFxuICBjb21tb246IFNuLFxuICB0cmFuc2l0aW9uOiBUblxufTtcbmV4cG9ydCB7XG4gIEgwIGFzIEFDQ0VQVFNfTUFQLFxuICBmdCBhcyBBdWRpbyxcbiAgdGIgYXMgQk9UVE9NLFxuICBIZSBhcyBDRU5URVIsXG4gIHNyIGFzIENhcHRpb24sXG4gIFUgYXMgQ29udHJvbCxcbiAgaWggYXMgRFJBR19FTkQsXG4gIHJoIGFzIERSQUdfUFJFRklYLFxuICBnMCBhcyBEUkFHX1NUQVJULFxuICBudCBhcyBGYWJyaWNPYmplY3QsXG4gIFNzIGFzIEhlbHBlcixcbiAgUXMgYXMgSW1hZ2UsXG4gIHVyIGFzIExFRlQsXG4gIGViIGFzIE5PTkUsXG4gIFlpIGFzIFBhdHRlcm4sXG4gIGVyIGFzIFBsYWNlaG9sZGVyLFxuICBPZSBhcyBQcmV2aWV3VHJhY2tJdGVtLFxuICBkciBhcyBSSUdIVCxcbiAgWCBhcyBSZWN0LFxuICBZMCBhcyBTSVpFU19NQVAsXG4gIHAwIGFzIFRJTUVMSU5FX0JPVU5ESU5HX0NIQU5HRUQsXG4gIG5oIGFzIFRJTUVMSU5FX1BSRUZJWCxcbiAgbTAgYXMgVElNRUxJTkVfU0VFSyxcbiAgUTAgYXMgVE9QLFxuICBWdCBhcyBUZW1wbGF0ZSxcbiAgdHIgYXMgVGV4dCxcbiAgdWUgYXMgVHJhY2ssXG4gIEp0IGFzIFRyYW5zaXRpb24sXG4gIF90IGFzIFZpZGVvLFxuICBzYiBhcyBjYWxjdWxhdGVUaW1lbGluZVdpZHRoLFxuICBTbiBhcyBjaGFuZ2VXaWR0aCxcbiAgQyBhcyBjbGFzc1JlZ2lzdHJ5LFxuICBEcyBhcyBjb250cm9sc1V0aWxzLFxuICBwZiBhcyBjcmVhdGVBdWRpb0NvbnRyb2xzLFxuICBtZiBhcyBjcmVhdGVNZWRpYUNvbnRyb2xzLFxuICBqcyBhcyBjcmVhdGVSZXNpemVDb250cm9scyxcbiAgZ2YgYXMgY3JlYXRlVGVtcGxhdGVDb250cm9scyxcbiAgbWwgYXMgY3JlYXRlVHJhbnNpdGlvbkNvbnRyb2xzLFxuICBLMCBhcyBkZWZhdWx0LFxuICBxdCBhcyBkcmF3VmVydGljYWxMaW5lLFxuICBXcyBhcyBnZW5lcmF0ZUlkLFxuICBwbCBhcyBnZXREdXJhdGlvbixcbiAgZnIgYXMgaXNUcmFuc2Zvcm1DZW50ZXJlZCxcbiAgcmIgYXMgcmVzaXplLFxuICBQIGFzIHJlc29sdmVPcmlnaW4sXG4gIEQgYXMgdGltZU1zVG9Vbml0cyxcbiAgWSBhcyB1bml0c1RvVGltZU1zLFxuICBzZCBhcyB1dGlsLFxuICBNaSBhcyB3cmFwV2l0aEZpeGVkQW5jaG9yXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@designcombo/timeline/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@designcombo/frames/dist/frames.js":
/*!*********************************************************!*\
  !*** ./node_modules/@designcombo/frames/dist/frames.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_AUDIO_CONF: () => (/* binding */ q),\n/* harmony export */   EventTool: () => (/* binding */ Ri),\n/* harmony export */   Log: () => (/* binding */ z),\n/* harmony export */   MP4Clip: () => (/* binding */ sn),\n/* harmony export */   adjustAudioDataVolume: () => (/* binding */ en),\n/* harmony export */   audioResample: () => (/* binding */ bi),\n/* harmony export */   autoReadStream: () => (/* binding */ fe),\n/* harmony export */   concatFloat32Array: () => (/* binding */ Me),\n/* harmony export */   concatPCMFragments: () => (/* binding */ mi),\n/* harmony export */   createEl: () => (/* binding */ Ve),\n/* harmony export */   decodeImg: () => (/* binding */ nn),\n/* harmony export */   extractPCM4AudioBuffer: () => (/* binding */ Oe),\n/* harmony export */   extractPCM4AudioData: () => (/* binding */ le),\n/* harmony export */   fastConcatMP4: () => (/* binding */ Xi),\n/* harmony export */   file2stream: () => (/* binding */ Wi),\n/* harmony export */   fixFMP4Duration: () => (/* binding */ an),\n/* harmony export */   mixinMP4AndAudio: () => (/* binding */ on),\n/* harmony export */   mixinPCM: () => (/* binding */ be),\n/* harmony export */   recodemux: () => (/* binding */ rn),\n/* harmony export */   renderTxt2Img: () => (/* binding */ We),\n/* harmony export */   renderTxt2ImgBitmap: () => (/* binding */ tn),\n/* harmony export */   ringSliceFloat32Array: () => (/* binding */ Si),\n/* harmony export */   workerTimer: () => (/* binding */ De)\n/* harmony export */ });\nvar He = Object.defineProperty;\nvar pe = (l) => {\n  throw TypeError(l);\n};\nvar Ye = (l, r, h) => r in l ? He(l, r, { enumerable: !0, configurable: !0, writable: !0, value: h }) : l[r] = h;\nvar R = (l, r, h) => Ye(l, typeof r != \"symbol\" ? r + \"\" : r, h), _e = (l, r, h) => r.has(l) || pe(\"Cannot \" + h);\nvar m = (l, r, h) => (_e(l, r, \"read from private field\"), h ? h.call(l) : r.get(l)), A = (l, r, h) => r.has(l) ? pe(\"Cannot add the same private member more than once\") : r instanceof WeakSet ? r.add(l) : r.set(l, h), E = (l, r, h, a) => (_e(l, r, \"write to private field\"), a ? a.call(l, h) : r.set(l, h), h);\nfunction Ve(l) {\n  return document.createElement(l);\n}\nfunction We(l, r) {\n  const h = Ve(\"pre\");\n  h.style.cssText = `margin: 0; ${r}; visibility: hidden; position: fixed;`, h.textContent = l, document.body.appendChild(h);\n  const { width: a, height: f } = h.getBoundingClientRect();\n  h.remove(), h.style.visibility = \"visible\";\n  const d = new Image();\n  d.width = a, d.height = f;\n  const p = `\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${a}\" height=\"${f}\">\n    <foreignObject width=\"100%\" height=\"100%\">\n        <div xmlns=\"http://www.w3.org/1999/xhtml\">${h.outerHTML}</div>\n    </foreignObject>\n    </svg>\n  `.replace(/\\t/g, \"\").replace(/#/g, \"%23\");\n  return d.src = `data:image/svg+xml;charset=utf-8,${p}`, d;\n}\nasync function tn(l, r) {\n  const h = We(l, r);\n  await new Promise((d) => {\n    h.onload = d;\n  });\n  const a = new OffscreenCanvas(h.width, h.height), f = a.getContext(\"2d\");\n  return f == null || f.drawImage(h, 0, 0, h.width, h.height), await createImageBitmap(a);\n}\nvar Be = (l) => {\n  throw TypeError(l);\n}, Fe = (l, r, h) => r.has(l) || Be(\"Cannot \" + h), I = (l, r, h) => (Fe(l, r, \"read from private field\"), h ? h.call(l) : r.get(l)), N = (l, r, h) => r.has(l) ? Be(\"Cannot add the same private member more than once\") : r instanceof WeakSet ? r.add(l) : r.set(l, h), M = (l, r, h, a) => (Fe(l, r, \"write to private field\"), r.set(l, h), h);\nconst Ie = \"KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHUobil7aWYobj09PSIvIilyZXR1cm57cGFyZW50Om51bGwsbmFtZToiIn07Y29uc3QgZT1uLnNwbGl0KCIvIikuZmlsdGVyKGk9PmkubGVuZ3RoPjApO2lmKGUubGVuZ3RoPT09MCl0aHJvdyBFcnJvcigiSW52YWxpZCBwYXRoIik7Y29uc3QgYT1lW2UubGVuZ3RoLTFdLHI9Ii8iK2Uuc2xpY2UoMCwtMSkuam9pbigiLyIpO3JldHVybntuYW1lOmEscGFyZW50OnJ9fWFzeW5jIGZ1bmN0aW9uIHcobixlKXtjb25zdHtwYXJlbnQ6YSxuYW1lOnJ9PXUobik7aWYoYT09bnVsbClyZXR1cm4gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7Y29uc3QgaT1hLnNwbGl0KCIvIikuZmlsdGVyKHQ9PnQubGVuZ3RoPjApO3RyeXtsZXQgdD1hd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtmb3IoY29uc3QgcyBvZiBpKXQ9YXdhaXQgdC5nZXREaXJlY3RvcnlIYW5kbGUocyx7Y3JlYXRlOmUuY3JlYXRlfSk7aWYoZS5pc0ZpbGUpcmV0dXJuIGF3YWl0IHQuZ2V0RmlsZUhhbmRsZShyLHtjcmVhdGU6ZS5jcmVhdGV9KX1jYXRjaCh0KXtpZih0Lm5hbWU9PT0iTm90Rm91bmRFcnJvciIpcmV0dXJuIG51bGw7dGhyb3cgdH19Y29uc3QgZj17fTtzZWxmLm9ubWVzc2FnZT1hc3luYyBuPT57dmFyIGk7Y29uc3R7ZXZ0VHlwZTplLGFyZ3M6YX09bi5kYXRhO2xldCByPWZbYS5maWxlSWRdO3RyeXtsZXQgdDtjb25zdCBzPVtdO2lmKGU9PT0icmVnaXN0ZXIiKXtjb25zdCBsPWF3YWl0IHcoYS5maWxlUGF0aCx7Y3JlYXRlOiEwLGlzRmlsZTohMH0pO2lmKGw9PW51bGwpdGhyb3cgRXJyb3IoYG5vdCBmb3VuZCBmaWxlOiAke2EuZmlsZUlkfWApO3I9YXdhaXQgbC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKHttb2RlOmEubW9kZX0pLGZbYS5maWxlSWRdPXJ9ZWxzZSBpZihlPT09ImNsb3NlIilhd2FpdCByLmNsb3NlKCksZGVsZXRlIGZbYS5maWxlSWRdO2Vsc2UgaWYoZT09PSJ0cnVuY2F0ZSIpYXdhaXQgci50cnVuY2F0ZShhLm5ld1NpemUpO2Vsc2UgaWYoZT09PSJ3cml0ZSIpe2NvbnN0e2RhdGE6bCxvcHRzOm99PW4uZGF0YS5hcmdzO3Q9YXdhaXQgci53cml0ZShsLG8pfWVsc2UgaWYoZT09PSJyZWFkIil7Y29uc3R7b2Zmc2V0Omwsc2l6ZTpvfT1uLmRhdGEuYXJncyxnPW5ldyBVaW50OEFycmF5KG8pLGQ9YXdhaXQgci5yZWFkKGcse2F0Omx9KSxjPWcuYnVmZmVyO3Q9ZD09PW8/YzooKGk9Yy50cmFuc2Zlcik9PW51bGw/dm9pZCAwOmkuY2FsbChjLGQpKT8/Yy5zbGljZSgwLGQpLHMucHVzaCh0KX1lbHNlIGU9PT0iZ2V0U2l6ZSI/dD1hd2FpdCByLmdldFNpemUoKTplPT09ImZsdXNoIiYmYXdhaXQgci5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2V2dFR5cGU6ImNhbGxiYWNrIixjYklkOm4uZGF0YS5jYklkLHJldHVyblZhbDp0fSxzKX1jYXRjaCh0KXtjb25zdCBzPXQ7c2VsZi5wb3N0TWVzc2FnZSh7ZXZ0VHlwZToidGhyb3dFcnJvciIsY2JJZDpuLmRhdGEuY2JJZCxlcnJNc2c6cy5uYW1lKyI6ICIrcy5tZXNzYWdlK2AKYCtKU09OLnN0cmluZ2lmeShuLmRhdGEpfSl9fX0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZnMtd29ya2VyLUY0UldscWNfLmpzLm1hcAo=\", Ze = (l) => Uint8Array.from(atob(l), (r) => r.charCodeAt(0)), ge = typeof self < \"u\" && self.Blob && new Blob([Ze(Ie)], { type: \"text/javascript;charset=utf-8\" });\nfunction Xe(l) {\n  let r;\n  try {\n    if (r = ge && (self.URL || self.webkitURL).createObjectURL(ge), !r) throw \"\";\n    const h = new Worker(r, {\n      name: l == null ? void 0 : l.name\n    });\n    return h.addEventListener(\"error\", () => {\n      (self.URL || self.webkitURL).revokeObjectURL(r);\n    }), h;\n  } catch {\n    return new Worker(\n      \"data:text/javascript;base64,\" + Ie,\n      {\n        name: l == null ? void 0 : l.name\n      }\n    );\n  } finally {\n    r && (self.URL || self.webkitURL).revokeObjectURL(r);\n  }\n}\nasync function je(l, r, h) {\n  const a = Ke();\n  return await a(\"register\", { fileId: l, filePath: r, mode: h }), {\n    read: async (f, d) => await a(\"read\", {\n      fileId: l,\n      offset: f,\n      size: d\n    }),\n    write: async (f, d) => await a(\n      \"write\",\n      {\n        fileId: l,\n        data: f,\n        opts: d\n      },\n      [ArrayBuffer.isView(f) ? f.buffer : f]\n    ),\n    close: async () => await a(\"close\", {\n      fileId: l\n    }),\n    truncate: async (f) => await a(\"truncate\", {\n      fileId: l,\n      newSize: f\n    }),\n    getSize: async () => await a(\"getSize\", {\n      fileId: l\n    }),\n    flush: async () => await a(\"flush\", {\n      fileId: l\n    })\n  };\n}\nconst Yt = [];\nlet ie = 0;\nfunction Ke() {\n  if (Yt.length < 3) {\n    const r = l();\n    return Yt.push(r), r;\n  } else {\n    const r = Yt[ie];\n    return ie = (ie + 1) % Yt.length, r;\n  }\n  function l() {\n    const r = new Xe();\n    let h = 0, a = {};\n    return r.onmessage = ({\n      data: f\n    }) => {\n      var d, p;\n      f.evtType === \"callback\" ? (d = a[f.cbId]) == null || d.resolve(f.returnVal) : f.evtType === \"throwError\" && ((p = a[f.cbId]) == null || p.reject(Error(f.errMsg))), delete a[f.cbId];\n    }, async function(f, d, p = []) {\n      h += 1;\n      const n = new Promise((v, b) => {\n        a[h] = { resolve: v, reject: b };\n      });\n      return r.postMessage(\n        {\n          cbId: h,\n          evtType: f,\n          args: d\n        },\n        p\n      ), n;\n    };\n  }\n}\nfunction te(l) {\n  if (l === \"/\") return { parent: null, name: \"\" };\n  const r = l.split(\"/\").filter((f) => f.length > 0);\n  if (r.length === 0) throw Error(\"Invalid path\");\n  const h = r[r.length - 1], a = \"/\" + r.slice(0, -1).join(\"/\");\n  return { name: h, parent: a };\n}\nasync function ot(l, r) {\n  const { parent: h, name: a } = te(l);\n  if (h == null) return await navigator.storage.getDirectory();\n  const f = h.split(\"/\").filter((d) => d.length > 0);\n  try {\n    let d = await navigator.storage.getDirectory();\n    for (const p of f)\n      d = await d.getDirectoryHandle(p, {\n        create: r.create\n      });\n    return r.isFile ? await d.getFileHandle(a, {\n      create: r.create\n    }) : await d.getDirectoryHandle(a, {\n      create: r.create\n    });\n  } catch (d) {\n    if (d.name === \"NotFoundError\")\n      return null;\n    throw d;\n  }\n}\nasync function Ce(l) {\n  const { parent: r, name: h } = te(l);\n  if (r == null) {\n    const f = await navigator.storage.getDirectory();\n    for await (const d of f.keys())\n      await f.removeEntry(d, { recursive: !0 });\n    return;\n  }\n  const a = await ot(r, {\n    create: !1,\n    isFile: !1\n  });\n  a != null && await a.removeEntry(h, { recursive: !0 });\n}\nfunction se(l, r) {\n  return `${l}/${r}`.replace(\"//\", \"/\");\n}\nfunction vt(l) {\n  return new ze(l);\n}\nvar H, Vt, At;\nclass ze {\n  constructor(r) {\n    N(this, H), N(this, Vt), N(this, At), M(this, H, r);\n    const { parent: h, name: a } = te(r);\n    M(this, Vt, a), M(this, At, h);\n  }\n  get kind() {\n    return \"dir\";\n  }\n  get name() {\n    return I(this, Vt);\n  }\n  get path() {\n    return I(this, H);\n  }\n  get parent() {\n    return I(this, At) == null ? null : vt(I(this, At));\n  }\n  /**\n   * Creates the directory.\n   * return A promise that resolves when the directory is created.\n   */\n  async create() {\n    return await ot(I(this, H), {\n      create: !0,\n      isFile: !1\n    }), vt(I(this, H));\n  }\n  /**\n   * Checks if the directory exists.\n   * return A promise that resolves to true if the directory exists, otherwise false.\n   */\n  async exists() {\n    return await ot(I(this, H), {\n      create: !1,\n      isFile: !1\n    }) instanceof FileSystemDirectoryHandle;\n  }\n  /**\n   * Removes the directory.\n   * return A promise that resolves when the directory is removed.\n   */\n  async remove() {\n    for (const r of await this.children())\n      try {\n        await r.remove();\n      } catch (h) {\n        console.warn(h);\n      }\n    try {\n      await Ce(I(this, H));\n    } catch (r) {\n      console.warn(r);\n    }\n  }\n  /**\n   * Retrieves the children of the directory.\n   * return A promise that resolves to an array of objects representing the children.\n   */\n  async children() {\n    const r = await ot(I(this, H), {\n      create: !1,\n      isFile: !1\n    });\n    if (r == null) return [];\n    const h = [];\n    for await (const a of r.values())\n      h.push((a.kind === \"file\" ? _t : vt)(se(I(this, H), a.name)));\n    return h;\n  }\n  /**\n   * If the dest folder exists, copy the current directory into the dest folder;\n   * if the dest folder does not exist, rename the current directory to dest name.\n   */\n  async copyTo(r) {\n    if (!await this.exists())\n      throw Error(`dir ${this.path} not exists`);\n    const h = await r.exists() ? vt(se(r.path, this.name)) : r;\n    return await h.create(), await Promise.all((await this.children()).map((a) => a.copyTo(h))), h;\n  }\n  /**\n   * move directory, copy then remove current\n   */\n  async moveTo(r) {\n    const h = await this.copyTo(r);\n    return await this.remove(), h;\n  }\n}\nH = /* @__PURE__ */ new WeakMap(), Vt = /* @__PURE__ */ new WeakMap(), At = /* @__PURE__ */ new WeakMap();\nconst ye = /* @__PURE__ */ new Map();\nfunction _t(l, r = \"rw\") {\n  if (r === \"rw\") {\n    const h = ye.get(l) ?? new jt(l, r);\n    return ye.set(l, h), h;\n  }\n  return new jt(l, r);\n}\nasync function Ct(l, r, h = { overwrite: !0 }) {\n  if (r instanceof jt) {\n    await Ct(l, await r.stream(), h);\n    return;\n  }\n  const a = await (l instanceof jt ? l : _t(l, \"rw\")).createWriter();\n  try {\n    if (h.overwrite && await a.truncate(0), r instanceof ReadableStream) {\n      const f = r.getReader();\n      for (; ; ) {\n        const { done: d, value: p } = await f.read();\n        if (d) break;\n        await a.write(p);\n      }\n    } else\n      await a.write(r);\n  } catch (f) {\n    throw f;\n  } finally {\n    await a.close();\n  }\n}\nlet Qe = 0;\nconst Je = () => ++Qe;\nvar Y, Bt, Wt, Ft, Zt, it, Xt, It;\nconst $e = class Te {\n  constructor(r, h) {\n    N(this, Y), N(this, Bt), N(this, Wt), N(this, Ft), N(this, Zt), N(this, it, 0), N(this, Xt, /* @__PURE__ */ (() => {\n      let d = null;\n      return () => (M(this, it, I(this, it) + 1), d ?? (d = new Promise(async (p, n) => {\n        try {\n          const v = await je(\n            I(this, Zt),\n            I(this, Y),\n            I(this, Ft)\n          );\n          p([\n            v,\n            async () => {\n              M(this, it, I(this, it) - 1), !(I(this, it) > 0) && (d = null, await v.close());\n            }\n          ]);\n        } catch (v) {\n          n(v);\n        }\n      })));\n    })()), N(this, It, !1), M(this, Zt, Je()), M(this, Y, r), M(this, Ft, {\n      r: \"read-only\",\n      rw: \"readwrite\",\n      \"rw-unsafe\": \"readwrite-unsafe\"\n    }[h]);\n    const { parent: a, name: f } = te(r);\n    M(this, Wt, f), M(this, Bt, a);\n  }\n  get kind() {\n    return \"file\";\n  }\n  get path() {\n    return I(this, Y);\n  }\n  get name() {\n    return I(this, Wt);\n  }\n  get parent() {\n    return I(this, Bt) == null ? null : vt(I(this, Bt));\n  }\n  /**\n   * Random write to file\n   */\n  async createWriter() {\n    if (I(this, Ft) === \"read-only\") throw Error(\"file is read-only\");\n    if (I(this, It)) throw Error(\"Other writer have not been closed\");\n    M(this, It, !0);\n    const r = new TextEncoder(), [h, a] = await I(this, Xt).call(this);\n    let f = await h.getSize(), d = !1;\n    return {\n      write: async (p, n = {}) => {\n        if (d) throw Error(\"Writer is closed\");\n        const v = typeof p == \"string\" ? r.encode(p) : p, b = n.at ?? f, y = v.byteLength;\n        return f = b + y, await h.write(v, { at: b });\n      },\n      truncate: async (p) => {\n        if (d) throw Error(\"Writer is closed\");\n        await h.truncate(p), f > p && (f = p);\n      },\n      flush: async () => {\n        if (d) throw Error(\"Writer is closed\");\n        await h.flush();\n      },\n      close: async () => {\n        if (d) throw Error(\"Writer is closed\");\n        d = !0, M(this, It, !1), await a();\n      }\n    };\n  }\n  /**\n   * Random access to file\n   */\n  async createReader() {\n    const [r, h] = await I(this, Xt).call(this);\n    let a = !1, f = 0;\n    return {\n      read: async (d, p = {}) => {\n        if (a) throw Error(\"Reader is closed\");\n        const n = p.at ?? f, v = await r.read(n, d);\n        return f = n + v.byteLength, v;\n      },\n      getSize: async () => {\n        if (a) throw Error(\"Reader is closed\");\n        return await r.getSize();\n      },\n      close: async () => {\n        a || (a = !0, await h());\n      }\n    };\n  }\n  async text() {\n    return new TextDecoder().decode(await this.arrayBuffer());\n  }\n  async arrayBuffer() {\n    const r = await ot(I(this, Y), { create: !1, isFile: !0 });\n    return r == null ? new ArrayBuffer(0) : (await r.getFile()).arrayBuffer();\n  }\n  async stream() {\n    const r = await this.getOriginFile();\n    return r == null ? new ReadableStream({\n      pull: (h) => {\n        h.close();\n      }\n    }) : r.stream();\n  }\n  async getOriginFile() {\n    var r;\n    return (r = await ot(I(this, Y), { create: !1, isFile: !0 })) == null ? void 0 : r.getFile();\n  }\n  async getSize() {\n    const r = await ot(I(this, Y), { create: !1, isFile: !0 });\n    return r == null ? 0 : (await r.getFile()).size;\n  }\n  async exists() {\n    return await ot(I(this, Y), {\n      create: !1,\n      isFile: !0\n    }) instanceof FileSystemFileHandle;\n  }\n  async remove() {\n    if (I(this, it)) throw Error(\"exists unclosed reader/writer\");\n    await Ce(I(this, Y));\n  }\n  /**\n   * If the target is a file, use current overwrite the target;\n   * if the target is a folder, copy the current file into that folder.\n   */\n  async copyTo(r) {\n    if (!await this.exists())\n      throw Error(`file ${this.path} not exists`);\n    if (r instanceof Te)\n      return _t(r.path) === this ? this : (await Ct(r.path, this), _t(r.path));\n    if (r instanceof ze)\n      return await this.copyTo(_t(se(r.path, this.name)));\n    throw Error(\"Illegal target type\");\n  }\n  /**\n   * move file, copy then remove current\n   */\n  async moveTo(r) {\n    const h = await this.copyTo(r);\n    return await this.remove(), h;\n  }\n};\nY = /* @__PURE__ */ new WeakMap(), Bt = /* @__PURE__ */ new WeakMap(), Wt = /* @__PURE__ */ new WeakMap(), Ft = /* @__PURE__ */ new WeakMap(), Zt = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakMap(), Xt = /* @__PURE__ */ new WeakMap(), It = /* @__PURE__ */ new WeakMap();\nlet jt = $e;\nconst he = \"/.opfs-tools-temp-dir\";\nasync function Pe(l) {\n  try {\n    if (l.kind === \"file\") {\n      if (!await l.exists()) return !0;\n      const r = await l.createWriter();\n      await r.truncate(0), await r.close(), await l.remove();\n    } else\n      await l.remove();\n    return !0;\n  } catch (r) {\n    return console.warn(r), !1;\n  }\n}\nfunction qe() {\n  setInterval(async () => {\n    for (const l of await vt(he).children()) {\n      const r = /^\\d+-(\\d+)$/.exec(l.name);\n      (r == null || Date.now() - Number(r[1]) > 2592e5) && await Pe(l);\n    }\n  }, 60 * 1e3);\n}\nconst re = [];\nlet me = !1;\nasync function ti() {\n  if (globalThis.localStorage == null) return;\n  const l = \"OPFS_TOOLS_EXPIRES_TMP_FILES\";\n  me || (me = !0, globalThis.addEventListener(\"unload\", () => {\n    re.length !== 0 && localStorage.setItem(\n      l,\n      `${localStorage.getItem(l) ?? \"\"},${re.join(\",\")}`\n    );\n  }));\n  let r = localStorage.getItem(l) ?? \"\";\n  for (const h of r.split(\",\"))\n    h.length !== 0 && await Pe(_t(`${he}/${h}`)) && (r = r.replace(h, \"\"));\n  localStorage.setItem(l, r.replace(/,{2,}/g, \",\"));\n}\n(async function() {\n  var l;\n  globalThis.__opfs_tools_tmpfile_init__ !== !0 && (globalThis.__opfs_tools_tmpfile_init__ = !0, !(globalThis.FileSystemDirectoryHandle == null || globalThis.FileSystemFileHandle == null || ((l = globalThis.navigator) == null ? void 0 : l.storage.getDirectory) == null) && (qe(), await ti()));\n})();\nfunction Kt() {\n  const l = `${Math.random().toString().slice(2)}-${Date.now()}`;\n  return re.push(l), _t(`${he}/${l}`);\n}\nfunction ei(l) {\n  return l instanceof Error ? String(l) : typeof l == \"object\" ? JSON.stringify(l, (r, h) => h instanceof Error ? String(h) : h) : String(l);\n}\nfunction ii() {\n  const l = /* @__PURE__ */ new Date();\n  return `${l.getHours()}:${l.getMinutes()}:${l.getSeconds()}.${l.getMilliseconds()}`;\n}\nlet Le = 1;\nconst ke = Kt();\nlet gt = null;\nconst ve = [\"debug\", \"info\", \"warn\", \"error\"].reduce(\n  (l, r, h) => Object.assign(l, {\n    [r]: (...a) => {\n      Le <= h && (console[r](...a), gt == null || gt.write(\n        `[${r}][${ii()}]  ${a.map((f) => ei(f)).join(\" \")}\n`\n      ));\n    }\n  }),\n  {}\n), Gt = /* @__PURE__ */ new Map(), z = {\n  setLogLevel: (l) => {\n    Le = Gt.get(l) ?? 1;\n  },\n  ...ve,\n  create: (l) => Object.fromEntries(\n    Object.entries(ve).map(([r, h]) => [\n      r,\n      (...a) => h(l, ...a)\n    ])\n  ),\n  async dump() {\n    return await si, await (gt == null ? void 0 : gt.flush()), await ke.text();\n  }\n};\nGt.set(z.debug, 0);\nGt.set(z.info, 1);\nGt.set(z.warn, 2);\nGt.set(z.error, 3);\nasync function ni() {\n  try {\n    gt = await ke.createWriter(), z.info(navigator.userAgent), z.info(\"date: \" + (/* @__PURE__ */ new Date()).toLocaleDateString());\n  } catch (l) {\n    if (!(l instanceof Error)) throw l;\n    if (l.message.includes(\"createSyncAccessHandle is not a function\"))\n      console.warn(l);\n    else\n      throw l;\n  }\n}\nconst si = globalThis.navigator == null ? null : ni(), ri = () => {\n  let l, r = 16.6;\n  self.onmessage = (h) => {\n    h.data.event === \"start\" && (self.clearInterval(l), l = self.setInterval(() => {\n      self.postMessage({});\n    }, r)), h.data.event === \"stop\" && self.clearInterval(l);\n  };\n}, ai = () => {\n  const l = new Blob([`(${ri.toString()})()`]), r = URL.createObjectURL(l);\n  return new Worker(r);\n}, mt = /* @__PURE__ */ new Map();\nlet ae = 1, nt = null;\nglobalThis.Worker != null && (nt = ai(), nt.onmessage = () => {\n  ae += 1;\n  for (const [l, r] of mt)\n    if (ae % l === 0) for (const h of r) h();\n});\nconst De = (l, r) => {\n  const h = Math.round(r / 16.6), a = mt.get(h) ?? /* @__PURE__ */ new Set();\n  return a.add(l), mt.set(h, a), mt.size === 1 && a.size === 1 && (nt == null || nt.postMessage({ event: \"start\" })), () => {\n    a.delete(l), a.size === 0 && mt.delete(h), mt.size === 0 && (ae = 0, nt == null || nt.postMessage({ event: \"stop\" }));\n  };\n};\nclass oi {\n  /**\n   * @param {number} scaleFrom the length of the original array.\n   * @param {number} scaleTo The length of the new array.\n   * @param {?Object} details The extra configuration, if needed.\n   */\n  constructor(r, h, a) {\n    this.length_ = r, this.scaleFactor_ = (r - 1) / h, this.interpolate = this.cubic, a.method === \"point\" ? this.interpolate = this.point : a.method === \"linear\" ? this.interpolate = this.linear : a.method === \"sinc\" && (this.interpolate = this.sinc), this.tangentFactor_ = 1 - Math.max(0, Math.min(1, a.tension || 0)), this.sincFilterSize_ = a.sincFilterSize || 1, this.kernel_ = li(a.sincWindow || hi);\n  }\n  /**\n   * @param {number} t The index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The interpolated value.\n   */\n  point(r, h) {\n    return this.getClippedInput_(Math.round(this.scaleFactor_ * r), h);\n  }\n  /**\n   * @param {number} t The index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The interpolated value.\n   */\n  linear(r, h) {\n    r = this.scaleFactor_ * r;\n    let a = Math.floor(r);\n    return r -= a, (1 - r) * this.getClippedInput_(a, h) + r * this.getClippedInput_(a + 1, h);\n  }\n  /**\n   * @param {number} t The index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The interpolated value.\n   */\n  cubic(r, h) {\n    r = this.scaleFactor_ * r;\n    let a = Math.floor(r), f = [this.getTangent_(a, h), this.getTangent_(a + 1, h)], d = [\n      this.getClippedInput_(a, h),\n      this.getClippedInput_(a + 1, h)\n    ];\n    r -= a;\n    let p = r * r, n = r * p;\n    return (2 * n - 3 * p + 1) * d[0] + (n - 2 * p + r) * f[0] + (-2 * n + 3 * p) * d[1] + (n - p) * f[1];\n  }\n  /**\n   * @param {number} t The index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The interpolated value.\n   */\n  sinc(r, h) {\n    r = this.scaleFactor_ * r;\n    let a = Math.floor(r), f = a - this.sincFilterSize_ + 1, d = a + this.sincFilterSize_, p = 0;\n    for (let n = f; n <= d; n++)\n      p += this.kernel_(r - n) * this.getClippedInput_(n, h);\n    return p;\n  }\n  /**\n   * @param {number} k The scaled index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The tangent.\n   * @private\n   */\n  getTangent_(r, h) {\n    return this.tangentFactor_ * (this.getClippedInput_(r + 1, h) - this.getClippedInput_(r - 1, h)) / 2;\n  }\n  /**\n   * @param {number} t The scaled index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The interpolated value.\n   * @private\n   */\n  getClippedInput_(r, h) {\n    return 0 <= r && r < this.length_ ? h[r] : 0;\n  }\n}\nfunction hi(l) {\n  return Math.exp(-l / 2 * l / 2);\n}\nfunction li(l) {\n  return function(r) {\n    return fi(r) * l(r);\n  };\n}\nfunction fi(l) {\n  return l === 0 ? 1 : Math.sin(Math.PI * l) / (Math.PI * l);\n}\nclass di {\n  /**\n   * @param {number} order The order of the filter.\n   * @param {number} sampleRate The sample rate.\n   * @param {number} cutOff The cut off frequency.\n   */\n  constructor(r, h, a) {\n    let f = 2 * Math.PI * a / h, d = 0;\n    this.filters = [];\n    for (let p = 0; p <= r; p++)\n      p - r / 2 === 0 ? this.filters[p] = f : (this.filters[p] = Math.sin(f * (p - r / 2)) / (p - r / 2), this.filters[p] *= 0.54 - 0.46 * Math.cos(2 * Math.PI * p / r)), d = d + this.filters[p];\n    for (let p = 0; p <= r; p++)\n      this.filters[p] /= d;\n    this.z = this.initZ_();\n  }\n  /**\n   * @param {number} sample A sample of a sequence.\n   * @return {number}\n   */\n  filter(r) {\n    this.z.buf[this.z.pointer] = r;\n    let h = 0;\n    for (let a = 0, f = this.z.buf.length; a < f; a++)\n      h += this.filters[a] * this.z.buf[(this.z.pointer + a) % this.z.buf.length];\n    return this.z.pointer = (this.z.pointer + 1) % this.z.buf.length, h;\n  }\n  /**\n   * Reset the filter.\n   */\n  reset() {\n    this.z = this.initZ_();\n  }\n  /**\n   * Return the default value for z.\n   * @private\n   */\n  initZ_() {\n    let r = [];\n    for (let h = 0; h < this.filters.length - 1; h++)\n      r.push(0);\n    return {\n      buf: r,\n      pointer: 0\n    };\n  }\n}\nclass ci {\n  /**\n   * @param {number} order The order of the filter.\n   * @param {number} sampleRate The sample rate.\n   * @param {number} cutOff The cut off frequency.\n   */\n  constructor(r, h, a) {\n    let f = [];\n    for (let d = 0; d < r; d++)\n      f.push(this.getCoeffs_({\n        Fs: h,\n        Fc: a,\n        Q: 0.5 / Math.sin(Math.PI / (r * 2) * (d + 0.5))\n      }));\n    this.stages = [];\n    for (let d = 0; d < f.length; d++)\n      this.stages[d] = {\n        b0: f[d].b[0],\n        b1: f[d].b[1],\n        b2: f[d].b[2],\n        a1: f[d].a[0],\n        a2: f[d].a[1],\n        k: f[d].k,\n        z: [0, 0]\n      };\n  }\n  /**\n   * @param {number} sample A sample of a sequence.\n   * @return {number}\n   */\n  filter(r) {\n    let h = r;\n    for (let a = 0, f = this.stages.length; a < f; a++)\n      h = this.runStage_(a, h);\n    return h;\n  }\n  getCoeffs_(r) {\n    let h = {};\n    h.z = [0, 0], h.a = [], h.b = [];\n    let a = this.preCalc_(r, h);\n    return h.k = 1, h.b.push((1 - a.cw) / (2 * a.a0)), h.b.push(2 * h.b[0]), h.b.push(h.b[0]), h;\n  }\n  preCalc_(r, h) {\n    let a = {}, f = 2 * Math.PI * r.Fc / r.Fs;\n    return a.alpha = Math.sin(f) / (2 * r.Q), a.cw = Math.cos(f), a.a0 = 1 + a.alpha, h.a0 = a.a0, h.a.push(-2 * a.cw / a.a0), h.k = 1, h.a.push((1 - a.alpha) / a.a0), a;\n  }\n  runStage_(r, h) {\n    let a = h * this.stages[r].k - this.stages[r].a1 * this.stages[r].z[0] - this.stages[r].a2 * this.stages[r].z[1], f = this.stages[r].b0 * a + this.stages[r].b1 * this.stages[r].z[0] + this.stages[r].b2 * this.stages[r].z[1];\n    return this.stages[r].z[1] = this.stages[r].z[0], this.stages[r].z[0] = a, f;\n  }\n  /**\n   * Reset the filter.\n   */\n  reset() {\n    for (let r = 0; r < this.stages.length; r++)\n      this.stages[r].z = [0, 0];\n  }\n}\nconst ui = {\n  point: !1,\n  linear: !1,\n  cubic: !0,\n  sinc: !0\n}, we = {\n  IIR: 16,\n  FIR: 71\n}, pi = {\n  IIR: ci,\n  FIR: di\n};\nfunction _i(l, r, h, a = {}) {\n  let f = (h - r) / r + 1, d = new Float64Array(l.length * f);\n  a.method = a.method || \"cubic\";\n  let p = new oi(\n    l.length,\n    d.length,\n    {\n      method: a.method,\n      tension: a.tension || 0,\n      sincFilterSize: a.sincFilterSize || 6,\n      sincWindow: a.sincWindow || void 0\n    }\n  );\n  if (a.LPF === void 0 && (a.LPF = ui[a.method]), a.LPF) {\n    a.LPFType = a.LPFType || \"IIR\";\n    const n = pi[a.LPFType];\n    if (h > r) {\n      let v = new n(\n        a.LPFOrder || we[a.LPFType],\n        h,\n        r / 2\n      );\n      gi(\n        l,\n        d,\n        p,\n        v\n      );\n    } else {\n      let v = new n(\n        a.LPFOrder || we[a.LPFType],\n        r,\n        h / 2\n      );\n      yi(\n        l,\n        d,\n        p,\n        v\n      );\n    }\n  } else\n    Re(l, d, p);\n  return d;\n}\nfunction Re(l, r, h) {\n  for (let a = 0, f = r.length; a < f; a++)\n    r[a] = h.interpolate(a, l);\n}\nfunction gi(l, r, h, a) {\n  for (let f = 0, d = r.length; f < d; f++)\n    r[f] = a.filter(h.interpolate(f, l));\n  a.reset();\n  for (let f = r.length - 1; f >= 0; f--)\n    r[f] = a.filter(r[f]);\n}\nfunction yi(l, r, h, a) {\n  for (let f = 0, d = l.length; f < d; f++)\n    l[f] = a.filter(l[f]);\n  a.reset();\n  for (let f = l.length - 1; f >= 0; f--)\n    l[f] = a.filter(l[f]);\n  Re(l, r, h);\n}\nfunction Me(l) {\n  const r = new Float32Array(\n    l.map((a) => a.length).reduce((a, f) => a + f)\n  );\n  let h = 0;\n  for (const a of l)\n    r.set(a, h), h += a.length;\n  return r;\n}\nfunction mi(l) {\n  const r = [];\n  for (let h = 0; h < l.length; h += 1)\n    for (let a = 0; a < l[h].length; a += 1)\n      r[a] == null && (r[a] = []), r[a].push(l[h][a]);\n  return r.map(Me);\n}\nfunction le(l) {\n  if (l.format === \"f32-planar\") {\n    const r = [];\n    for (let h = 0; h < l.numberOfChannels; h += 1) {\n      const a = l.allocationSize({ planeIndex: h }), f = new ArrayBuffer(a);\n      l.copyTo(f, { planeIndex: h }), r.push(new Float32Array(f));\n    }\n    return r;\n  } else if (l.format === \"f32\") {\n    const r = new ArrayBuffer(l.allocationSize({ planeIndex: 0 }));\n    return l.copyTo(r, { planeIndex: 0 }), wi(new Float32Array(r), l.numberOfChannels);\n  } else if (l.format === \"s16\") {\n    const r = new ArrayBuffer(l.allocationSize({ planeIndex: 0 }));\n    return l.copyTo(r, { planeIndex: 0 }), vi(new Int16Array(r), l.numberOfChannels);\n  }\n  throw Error(\"Unsupported audio data format\");\n}\nfunction vi(l, r) {\n  const h = l.length / r, a = Array.from(\n    { length: r },\n    () => new Float32Array(h)\n  );\n  for (let f = 0; f < h; f++)\n    for (let d = 0; d < r; d++) {\n      const p = l[f * r + d];\n      a[d][f] = p / 32768;\n    }\n  return a;\n}\nfunction wi(l, r) {\n  const h = l.length / r, a = Array.from(\n    { length: r },\n    () => new Float32Array(h)\n  );\n  for (let f = 0; f < h; f++)\n    for (let d = 0; d < r; d++)\n      a[d][f] = l[f * r + d];\n  return a;\n}\nfunction Oe(l) {\n  return Array(l.numberOfChannels).fill(0).map((r, h) => l.getChannelData(h));\n}\nfunction en(l, r) {\n  const h = new Float32Array(\n    Me(le(l))\n  ).map((f) => f * r), a = new AudioData({\n    sampleRate: l.sampleRate,\n    numberOfChannels: l.numberOfChannels,\n    timestamp: l.timestamp,\n    format: l.format,\n    numberOfFrames: l.numberOfFrames,\n    data: h\n  });\n  return l.close(), a;\n}\nasync function nn(l, r) {\n  var p;\n  const h = {\n    type: r,\n    data: l\n  }, a = new ImageDecoder(h);\n  await Promise.all([a.completed, a.tracks.ready]);\n  let f = ((p = a.tracks.selectedTrack) == null ? void 0 : p.frameCount) ?? 1;\n  const d = [];\n  for (let n = 0; n < f; n += 1)\n    d.push((await a.decode({ frameIndex: n })).image);\n  return d;\n}\nfunction be(l) {\n  var a, f;\n  const r = Math.max(...l.map((d) => {\n    var p;\n    return ((p = d[0]) == null ? void 0 : p.length) ?? 0;\n  })), h = new Float32Array(r * 2);\n  for (let d = 0; d < r; d++) {\n    let p = 0, n = 0;\n    for (let v = 0; v < l.length; v++) {\n      const b = ((a = l[v][0]) == null ? void 0 : a[d]) ?? 0, y = ((f = l[v][1]) == null ? void 0 : f[d]) ?? b;\n      p += b, n += y;\n    }\n    h[d] = p, h[d + r] = n;\n  }\n  return h;\n}\nasync function bi(l, r, h) {\n  const a = l.length, f = Array(h.chanCount).fill(0).map(() => new Float32Array(0));\n  if (a === 0) return f;\n  const d = Math.max(...l.map((b) => b.length));\n  if (d === 0) return f;\n  if (globalThis.OfflineAudioContext == null)\n    return l.map(\n      (b) => new Float32Array(\n        _i(b, r, h.rate, { method: \"sinc\", LPF: !1 })\n      )\n    );\n  const p = new globalThis.OfflineAudioContext(\n    h.chanCount,\n    d * h.rate / r,\n    h.rate\n  ), n = p.createBufferSource(), v = p.createBuffer(a, d, r);\n  return l.forEach((b, y) => v.copyToChannel(b, y)), n.buffer = v, n.connect(p.destination), n.start(), Oe(await p.startRendering());\n}\nfunction Ne(l) {\n  return new Promise((r) => {\n    const h = De(() => {\n      h(), r();\n    }, l);\n  });\n}\nfunction Si(l, r, h) {\n  const a = h - r, f = new Float32Array(a);\n  let d = 0;\n  for (; d < a; )\n    f[d] = l[(r + d) % l.length], d += 1;\n  return f;\n}\nfunction fe(l, r) {\n  let h = !1;\n  async function a() {\n    const f = l.getReader();\n    for (; !h; ) {\n      const { value: d, done: p } = await f.read();\n      if (p) {\n        r.onDone();\n        return;\n      }\n      await r.onChunk(d);\n    }\n    f.releaseLock(), await l.cancel();\n  }\n  return a().catch(z.error), () => {\n    h = !0;\n  };\n}\nfunction xi(l) {\n  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, \"default\") ? l.default : l;\n}\nvar Ge = {};\n(function(l) {\n  var r = /* @__PURE__ */ function() {\n    var t = /* @__PURE__ */ new Date(), e = 4, i = 3, s = 2, o = 1, c = e, u = {\n      setLogLevel: function(_) {\n        _ == this.debug ? c = o : _ == this.info ? c = s : _ == this.warn ? c = i : (_ == this.error, c = e);\n      },\n      debug: function(_, g) {\n        console.debug === void 0 && (console.debug = console.log), o >= c && console.debug(\"[\" + r.getDurationString(/* @__PURE__ */ new Date() - t, 1e3) + \"]\", \"[\" + _ + \"]\", g);\n      },\n      log: function(_, g) {\n        this.debug(_.msg);\n      },\n      info: function(_, g) {\n        s >= c && console.info(\"[\" + r.getDurationString(/* @__PURE__ */ new Date() - t, 1e3) + \"]\", \"[\" + _ + \"]\", g);\n      },\n      warn: function(_, g) {\n        i >= c && console.warn(\"[\" + r.getDurationString(/* @__PURE__ */ new Date() - t, 1e3) + \"]\", \"[\" + _ + \"]\", g);\n      },\n      error: function(_, g) {\n        e >= c && console.error(\"[\" + r.getDurationString(/* @__PURE__ */ new Date() - t, 1e3) + \"]\", \"[\" + _ + \"]\", g);\n      }\n    };\n    return u;\n  }();\n  r.getDurationString = function(t, e) {\n    var i;\n    function s(w, S) {\n      for (var U = \"\" + w, C = U.split(\".\"); C[0].length < S; )\n        C[0] = \"0\" + C[0];\n      return C.join(\".\");\n    }\n    t < 0 ? (i = !0, t = -t) : i = !1;\n    var o = e || 1, c = t / o, u = Math.floor(c / 3600);\n    c -= u * 3600;\n    var _ = Math.floor(c / 60);\n    c -= _ * 60;\n    var g = c * 1e3;\n    return c = Math.floor(c), g -= c * 1e3, g = Math.floor(g), (i ? \"-\" : \"\") + u + \":\" + s(_, 2) + \":\" + s(c, 2) + \".\" + s(g, 3);\n  }, r.printRanges = function(t) {\n    var e = t.length;\n    if (e > 0) {\n      for (var i = \"\", s = 0; s < e; s++)\n        s > 0 && (i += \",\"), i += \"[\" + r.getDurationString(t.start(s)) + \",\" + r.getDurationString(t.end(s)) + \"]\";\n      return i;\n    } else\n      return \"(empty)\";\n  }, l.Log = r;\n  var h = function(t) {\n    if (t instanceof ArrayBuffer)\n      this.buffer = t, this.dataview = new DataView(t);\n    else\n      throw \"Needs an array buffer\";\n    this.position = 0;\n  };\n  h.prototype.getPosition = function() {\n    return this.position;\n  }, h.prototype.getEndPosition = function() {\n    return this.buffer.byteLength;\n  }, h.prototype.getLength = function() {\n    return this.buffer.byteLength;\n  }, h.prototype.seek = function(t) {\n    var e = Math.max(0, Math.min(this.buffer.byteLength, t));\n    return this.position = isNaN(e) || !isFinite(e) ? 0 : e, !0;\n  }, h.prototype.isEos = function() {\n    return this.getPosition() >= this.getEndPosition();\n  }, h.prototype.readAnyInt = function(t, e) {\n    var i = 0;\n    if (this.position + t <= this.buffer.byteLength) {\n      switch (t) {\n        case 1:\n          e ? i = this.dataview.getInt8(this.position) : i = this.dataview.getUint8(this.position);\n          break;\n        case 2:\n          e ? i = this.dataview.getInt16(this.position) : i = this.dataview.getUint16(this.position);\n          break;\n        case 3:\n          if (e)\n            throw \"No method for reading signed 24 bits values\";\n          i = this.dataview.getUint8(this.position) << 16, i |= this.dataview.getUint8(this.position + 1) << 8, i |= this.dataview.getUint8(this.position + 2);\n          break;\n        case 4:\n          e ? i = this.dataview.getInt32(this.position) : i = this.dataview.getUint32(this.position);\n          break;\n        case 8:\n          if (e)\n            throw \"No method for reading signed 64 bits values\";\n          i = this.dataview.getUint32(this.position) << 32, i |= this.dataview.getUint32(this.position + 4);\n          break;\n        default:\n          throw \"readInt method not implemented for size: \" + t;\n      }\n      return this.position += t, i;\n    } else\n      throw \"Not enough bytes in buffer\";\n  }, h.prototype.readUint8 = function() {\n    return this.readAnyInt(1, !1);\n  }, h.prototype.readUint16 = function() {\n    return this.readAnyInt(2, !1);\n  }, h.prototype.readUint24 = function() {\n    return this.readAnyInt(3, !1);\n  }, h.prototype.readUint32 = function() {\n    return this.readAnyInt(4, !1);\n  }, h.prototype.readUint64 = function() {\n    return this.readAnyInt(8, !1);\n  }, h.prototype.readString = function(t) {\n    if (this.position + t <= this.buffer.byteLength) {\n      for (var e = \"\", i = 0; i < t; i++)\n        e += String.fromCharCode(this.readUint8());\n      return e;\n    } else\n      throw \"Not enough bytes in buffer\";\n  }, h.prototype.readCString = function() {\n    for (var t = []; ; ) {\n      var e = this.readUint8();\n      if (e !== 0)\n        t.push(e);\n      else\n        break;\n    }\n    return String.fromCharCode.apply(null, t);\n  }, h.prototype.readInt8 = function() {\n    return this.readAnyInt(1, !0);\n  }, h.prototype.readInt16 = function() {\n    return this.readAnyInt(2, !0);\n  }, h.prototype.readInt32 = function() {\n    return this.readAnyInt(4, !0);\n  }, h.prototype.readInt64 = function() {\n    return this.readAnyInt(8, !1);\n  }, h.prototype.readUint8Array = function(t) {\n    for (var e = new Uint8Array(t), i = 0; i < t; i++)\n      e[i] = this.readUint8();\n    return e;\n  }, h.prototype.readInt16Array = function(t) {\n    for (var e = new Int16Array(t), i = 0; i < t; i++)\n      e[i] = this.readInt16();\n    return e;\n  }, h.prototype.readUint16Array = function(t) {\n    for (var e = new Int16Array(t), i = 0; i < t; i++)\n      e[i] = this.readUint16();\n    return e;\n  }, h.prototype.readUint32Array = function(t) {\n    for (var e = new Uint32Array(t), i = 0; i < t; i++)\n      e[i] = this.readUint32();\n    return e;\n  }, h.prototype.readInt32Array = function(t) {\n    for (var e = new Int32Array(t), i = 0; i < t; i++)\n      e[i] = this.readInt32();\n    return e;\n  }, l.MP4BoxStream = h;\n  var a = function(t, e, i) {\n    this._byteOffset = e || 0, t instanceof ArrayBuffer ? this.buffer = t : typeof t == \"object\" ? (this.dataView = t, e && (this._byteOffset += e)) : this.buffer = new ArrayBuffer(t || 0), this.position = 0, this.endianness = i ?? a.LITTLE_ENDIAN;\n  };\n  a.prototype = {}, a.prototype.getPosition = function() {\n    return this.position;\n  }, a.prototype._realloc = function(t) {\n    if (this._dynamicSize) {\n      var e = this._byteOffset + this.position + t, i = this._buffer.byteLength;\n      if (e <= i) {\n        e > this._byteLength && (this._byteLength = e);\n        return;\n      }\n      for (i < 1 && (i = 1); e > i; )\n        i *= 2;\n      var s = new ArrayBuffer(i), o = new Uint8Array(this._buffer), c = new Uint8Array(s, 0, o.length);\n      c.set(o), this.buffer = s, this._byteLength = e;\n    }\n  }, a.prototype._trimAlloc = function() {\n    if (this._byteLength != this._buffer.byteLength) {\n      var t = new ArrayBuffer(this._byteLength), e = new Uint8Array(t), i = new Uint8Array(this._buffer, 0, e.length);\n      e.set(i), this.buffer = t;\n    }\n  }, a.BIG_ENDIAN = !1, a.LITTLE_ENDIAN = !0, a.prototype._byteLength = 0, Object.defineProperty(\n    a.prototype,\n    \"byteLength\",\n    { get: function() {\n      return this._byteLength - this._byteOffset;\n    } }\n  ), Object.defineProperty(\n    a.prototype,\n    \"buffer\",\n    {\n      get: function() {\n        return this._trimAlloc(), this._buffer;\n      },\n      set: function(t) {\n        this._buffer = t, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength;\n      }\n    }\n  ), Object.defineProperty(\n    a.prototype,\n    \"byteOffset\",\n    {\n      get: function() {\n        return this._byteOffset;\n      },\n      set: function(t) {\n        this._byteOffset = t, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength;\n      }\n    }\n  ), Object.defineProperty(\n    a.prototype,\n    \"dataView\",\n    {\n      get: function() {\n        return this._dataView;\n      },\n      set: function(t) {\n        this._byteOffset = t.byteOffset, this._buffer = t.buffer, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._byteOffset + t.byteLength;\n      }\n    }\n  ), a.prototype.seek = function(t) {\n    var e = Math.max(0, Math.min(this.byteLength, t));\n    this.position = isNaN(e) || !isFinite(e) ? 0 : e;\n  }, a.prototype.isEof = function() {\n    return this.position >= this._byteLength;\n  }, a.prototype.mapUint8Array = function(t) {\n    this._realloc(t * 1);\n    var e = new Uint8Array(this._buffer, this.byteOffset + this.position, t);\n    return this.position += t * 1, e;\n  }, a.prototype.readInt32Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 4;\n    var i = new Int32Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readInt16Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 2;\n    var i = new Int16Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readInt8Array = function(t) {\n    t = t ?? this.byteLength - this.position;\n    var e = new Int8Array(t);\n    return a.memcpy(\n      e.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * e.BYTES_PER_ELEMENT\n    ), this.position += e.byteLength, e;\n  }, a.prototype.readUint32Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 4;\n    var i = new Uint32Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readUint16Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 2;\n    var i = new Uint16Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readUint8Array = function(t) {\n    t = t ?? this.byteLength - this.position;\n    var e = new Uint8Array(t);\n    return a.memcpy(\n      e.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * e.BYTES_PER_ELEMENT\n    ), this.position += e.byteLength, e;\n  }, a.prototype.readFloat64Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 8;\n    var i = new Float64Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readFloat32Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 4;\n    var i = new Float32Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readInt32 = function(t) {\n    var e = this._dataView.getInt32(this.position, t ?? this.endianness);\n    return this.position += 4, e;\n  }, a.prototype.readInt16 = function(t) {\n    var e = this._dataView.getInt16(this.position, t ?? this.endianness);\n    return this.position += 2, e;\n  }, a.prototype.readInt8 = function() {\n    var t = this._dataView.getInt8(this.position);\n    return this.position += 1, t;\n  }, a.prototype.readUint32 = function(t) {\n    var e = this._dataView.getUint32(this.position, t ?? this.endianness);\n    return this.position += 4, e;\n  }, a.prototype.readUint16 = function(t) {\n    var e = this._dataView.getUint16(this.position, t ?? this.endianness);\n    return this.position += 2, e;\n  }, a.prototype.readUint8 = function() {\n    var t = this._dataView.getUint8(this.position);\n    return this.position += 1, t;\n  }, a.prototype.readFloat32 = function(t) {\n    var e = this._dataView.getFloat32(this.position, t ?? this.endianness);\n    return this.position += 4, e;\n  }, a.prototype.readFloat64 = function(t) {\n    var e = this._dataView.getFloat64(this.position, t ?? this.endianness);\n    return this.position += 8, e;\n  }, a.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0, a.memcpy = function(t, e, i, s, o) {\n    var c = new Uint8Array(t, e, o), u = new Uint8Array(i, s, o);\n    c.set(u);\n  }, a.arrayToNative = function(t, e) {\n    return e == this.endianness ? t : this.flipArrayEndianness(t);\n  }, a.nativeToEndian = function(t, e) {\n    return this.endianness == e ? t : this.flipArrayEndianness(t);\n  }, a.flipArrayEndianness = function(t) {\n    for (var e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength), i = 0; i < t.byteLength; i += t.BYTES_PER_ELEMENT)\n      for (var s = i + t.BYTES_PER_ELEMENT - 1, o = i; s > o; s--, o++) {\n        var c = e[o];\n        e[o] = e[s], e[s] = c;\n      }\n    return t;\n  }, a.prototype.failurePosition = 0, String.fromCharCodeUint8 = function(t) {\n    for (var e = [], i = 0; i < t.length; i++)\n      e[i] = t[i];\n    return String.fromCharCode.apply(null, e);\n  }, a.prototype.readString = function(t, e) {\n    return e == null || e == \"ASCII\" ? String.fromCharCodeUint8.apply(null, [this.mapUint8Array(t ?? this.byteLength - this.position)]) : new TextDecoder(e).decode(this.mapUint8Array(t));\n  }, a.prototype.readCString = function(t) {\n    var e = this.byteLength - this.position, i = new Uint8Array(this._buffer, this._byteOffset + this.position), s = e;\n    t != null && (s = Math.min(t, e));\n    for (var o = 0; o < s && i[o] !== 0; o++) ;\n    var c = String.fromCharCodeUint8.apply(null, [this.mapUint8Array(o)]);\n    return t != null ? this.position += s - o : o != e && (this.position += 1), c;\n  };\n  var f = Math.pow(2, 32);\n  a.prototype.readInt64 = function() {\n    return this.readInt32() * f + this.readUint32();\n  }, a.prototype.readUint64 = function() {\n    return this.readUint32() * f + this.readUint32();\n  }, a.prototype.readInt64 = function() {\n    return this.readUint32() * f + this.readUint32();\n  }, a.prototype.readUint24 = function() {\n    return (this.readUint8() << 16) + (this.readUint8() << 8) + this.readUint8();\n  }, l.DataStream = a, a.prototype.save = function(t) {\n    var e = new Blob([this.buffer]);\n    if (window.URL && URL.createObjectURL) {\n      var i = window.URL.createObjectURL(e), s = document.createElement(\"a\");\n      document.body.appendChild(s), s.setAttribute(\"href\", i), s.setAttribute(\"download\", t), s.setAttribute(\"target\", \"_self\"), s.click(), window.URL.revokeObjectURL(i);\n    } else\n      throw \"DataStream.save: Can't create object URL.\";\n  }, a.prototype._dynamicSize = !0, Object.defineProperty(\n    a.prototype,\n    \"dynamicSize\",\n    {\n      get: function() {\n        return this._dynamicSize;\n      },\n      set: function(t) {\n        t || this._trimAlloc(), this._dynamicSize = t;\n      }\n    }\n  ), a.prototype.shift = function(t) {\n    var e = new ArrayBuffer(this._byteLength - t), i = new Uint8Array(e), s = new Uint8Array(this._buffer, t, i.length);\n    i.set(s), this.buffer = e, this.position -= t;\n  }, a.prototype.writeInt32Array = function(t, e) {\n    if (this._realloc(t.length * 4), t instanceof Int32Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapInt32Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeInt32(t[i], e);\n  }, a.prototype.writeInt16Array = function(t, e) {\n    if (this._realloc(t.length * 2), t instanceof Int16Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapInt16Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeInt16(t[i], e);\n  }, a.prototype.writeInt8Array = function(t) {\n    if (this._realloc(t.length * 1), t instanceof Int8Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapInt8Array(t.length);\n    else\n      for (var e = 0; e < t.length; e++)\n        this.writeInt8(t[e]);\n  }, a.prototype.writeUint32Array = function(t, e) {\n    if (this._realloc(t.length * 4), t instanceof Uint32Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapUint32Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeUint32(t[i], e);\n  }, a.prototype.writeUint16Array = function(t, e) {\n    if (this._realloc(t.length * 2), t instanceof Uint16Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapUint16Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeUint16(t[i], e);\n  }, a.prototype.writeUint8Array = function(t) {\n    if (this._realloc(t.length * 1), t instanceof Uint8Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapUint8Array(t.length);\n    else\n      for (var e = 0; e < t.length; e++)\n        this.writeUint8(t[e]);\n  }, a.prototype.writeFloat64Array = function(t, e) {\n    if (this._realloc(t.length * 8), t instanceof Float64Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapFloat64Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeFloat64(t[i], e);\n  }, a.prototype.writeFloat32Array = function(t, e) {\n    if (this._realloc(t.length * 4), t instanceof Float32Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapFloat32Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeFloat32(t[i], e);\n  }, a.prototype.writeInt32 = function(t, e) {\n    this._realloc(4), this._dataView.setInt32(this.position, t, e ?? this.endianness), this.position += 4;\n  }, a.prototype.writeInt16 = function(t, e) {\n    this._realloc(2), this._dataView.setInt16(this.position, t, e ?? this.endianness), this.position += 2;\n  }, a.prototype.writeInt8 = function(t) {\n    this._realloc(1), this._dataView.setInt8(this.position, t), this.position += 1;\n  }, a.prototype.writeUint32 = function(t, e) {\n    this._realloc(4), this._dataView.setUint32(this.position, t, e ?? this.endianness), this.position += 4;\n  }, a.prototype.writeUint16 = function(t, e) {\n    this._realloc(2), this._dataView.setUint16(this.position, t, e ?? this.endianness), this.position += 2;\n  }, a.prototype.writeUint8 = function(t) {\n    this._realloc(1), this._dataView.setUint8(this.position, t), this.position += 1;\n  }, a.prototype.writeFloat32 = function(t, e) {\n    this._realloc(4), this._dataView.setFloat32(this.position, t, e ?? this.endianness), this.position += 4;\n  }, a.prototype.writeFloat64 = function(t, e) {\n    this._realloc(8), this._dataView.setFloat64(this.position, t, e ?? this.endianness), this.position += 8;\n  }, a.prototype.writeUCS2String = function(t, e, i) {\n    i == null && (i = t.length);\n    for (var s = 0; s < t.length && s < i; s++)\n      this.writeUint16(t.charCodeAt(s), e);\n    for (; s < i; s++)\n      this.writeUint16(0);\n  }, a.prototype.writeString = function(t, e, i) {\n    var s = 0;\n    if (e == null || e == \"ASCII\")\n      if (i != null) {\n        var o = Math.min(t.length, i);\n        for (s = 0; s < o; s++)\n          this.writeUint8(t.charCodeAt(s));\n        for (; s < i; s++)\n          this.writeUint8(0);\n      } else\n        for (s = 0; s < t.length; s++)\n          this.writeUint8(t.charCodeAt(s));\n    else\n      this.writeUint8Array(new TextEncoder(e).encode(t.substring(0, i)));\n  }, a.prototype.writeCString = function(t, e) {\n    var i = 0;\n    if (e != null) {\n      var s = Math.min(t.length, e);\n      for (i = 0; i < s; i++)\n        this.writeUint8(t.charCodeAt(i));\n      for (; i < e; i++)\n        this.writeUint8(0);\n    } else {\n      for (i = 0; i < t.length; i++)\n        this.writeUint8(t.charCodeAt(i));\n      this.writeUint8(0);\n    }\n  }, a.prototype.writeStruct = function(t, e) {\n    for (var i = 0; i < t.length; i += 2) {\n      var s = t[i + 1];\n      this.writeType(s, e[t[i]], e);\n    }\n  }, a.prototype.writeType = function(t, e, i) {\n    var s;\n    if (typeof t == \"function\")\n      return t(this, e);\n    if (typeof t == \"object\" && !(t instanceof Array))\n      return t.set(this, e, i);\n    var o = null, c = \"ASCII\", u = this.position;\n    switch (typeof t == \"string\" && /:/.test(t) && (s = t.split(\":\"), t = s[0], o = parseInt(s[1])), typeof t == \"string\" && /,/.test(t) && (s = t.split(\",\"), t = s[0], c = parseInt(s[1])), t) {\n      case \"uint8\":\n        this.writeUint8(e);\n        break;\n      case \"int8\":\n        this.writeInt8(e);\n        break;\n      case \"uint16\":\n        this.writeUint16(e, this.endianness);\n        break;\n      case \"int16\":\n        this.writeInt16(e, this.endianness);\n        break;\n      case \"uint32\":\n        this.writeUint32(e, this.endianness);\n        break;\n      case \"int32\":\n        this.writeInt32(e, this.endianness);\n        break;\n      case \"float32\":\n        this.writeFloat32(e, this.endianness);\n        break;\n      case \"float64\":\n        this.writeFloat64(e, this.endianness);\n        break;\n      case \"uint16be\":\n        this.writeUint16(e, a.BIG_ENDIAN);\n        break;\n      case \"int16be\":\n        this.writeInt16(e, a.BIG_ENDIAN);\n        break;\n      case \"uint32be\":\n        this.writeUint32(e, a.BIG_ENDIAN);\n        break;\n      case \"int32be\":\n        this.writeInt32(e, a.BIG_ENDIAN);\n        break;\n      case \"float32be\":\n        this.writeFloat32(e, a.BIG_ENDIAN);\n        break;\n      case \"float64be\":\n        this.writeFloat64(e, a.BIG_ENDIAN);\n        break;\n      case \"uint16le\":\n        this.writeUint16(e, a.LITTLE_ENDIAN);\n        break;\n      case \"int16le\":\n        this.writeInt16(e, a.LITTLE_ENDIAN);\n        break;\n      case \"uint32le\":\n        this.writeUint32(e, a.LITTLE_ENDIAN);\n        break;\n      case \"int32le\":\n        this.writeInt32(e, a.LITTLE_ENDIAN);\n        break;\n      case \"float32le\":\n        this.writeFloat32(e, a.LITTLE_ENDIAN);\n        break;\n      case \"float64le\":\n        this.writeFloat64(e, a.LITTLE_ENDIAN);\n        break;\n      case \"cstring\":\n        this.writeCString(e, o);\n        break;\n      case \"string\":\n        this.writeString(e, c, o);\n        break;\n      case \"u16string\":\n        this.writeUCS2String(e, this.endianness, o);\n        break;\n      case \"u16stringle\":\n        this.writeUCS2String(e, a.LITTLE_ENDIAN, o);\n        break;\n      case \"u16stringbe\":\n        this.writeUCS2String(e, a.BIG_ENDIAN, o);\n        break;\n      default:\n        if (t.length == 3) {\n          for (var _ = t[1], g = 0; g < e.length; g++)\n            this.writeType(_, e[g]);\n          break;\n        } else {\n          this.writeStruct(t, e);\n          break;\n        }\n    }\n    o != null && (this.position = u, this._realloc(o), this.position = u + o);\n  }, a.prototype.writeUint64 = function(t) {\n    var e = Math.floor(t / f);\n    this.writeUint32(e), this.writeUint32(t & 4294967295);\n  }, a.prototype.writeUint24 = function(t) {\n    this.writeUint8((t & 16711680) >> 16), this.writeUint8((t & 65280) >> 8), this.writeUint8(t & 255);\n  }, a.prototype.adjustUint32 = function(t, e) {\n    var i = this.position;\n    this.seek(t), this.writeUint32(e), this.seek(i);\n  }, a.prototype.mapInt32Array = function(t, e) {\n    this._realloc(t * 4);\n    var i = new Int32Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 4, i;\n  }, a.prototype.mapInt16Array = function(t, e) {\n    this._realloc(t * 2);\n    var i = new Int16Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 2, i;\n  }, a.prototype.mapInt8Array = function(t) {\n    this._realloc(t * 1);\n    var e = new Int8Array(this._buffer, this.byteOffset + this.position, t);\n    return this.position += t * 1, e;\n  }, a.prototype.mapUint32Array = function(t, e) {\n    this._realloc(t * 4);\n    var i = new Uint32Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 4, i;\n  }, a.prototype.mapUint16Array = function(t, e) {\n    this._realloc(t * 2);\n    var i = new Uint16Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 2, i;\n  }, a.prototype.mapFloat64Array = function(t, e) {\n    this._realloc(t * 8);\n    var i = new Float64Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 8, i;\n  }, a.prototype.mapFloat32Array = function(t, e) {\n    this._realloc(t * 4);\n    var i = new Float32Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 4, i;\n  };\n  var d = function(t) {\n    this.buffers = [], this.bufferIndex = -1, t && (this.insertBuffer(t), this.bufferIndex = 0);\n  };\n  d.prototype = new a(new ArrayBuffer(), 0, a.BIG_ENDIAN), d.prototype.initialized = function() {\n    var t;\n    return this.bufferIndex > -1 ? !0 : this.buffers.length > 0 ? (t = this.buffers[0], t.fileStart === 0 ? (this.buffer = t, this.bufferIndex = 0, r.debug(\"MultiBufferStream\", \"Stream ready for parsing\"), !0) : (r.warn(\"MultiBufferStream\", \"The first buffer should have a fileStart of 0\"), this.logBufferLevel(), !1)) : (r.warn(\"MultiBufferStream\", \"No buffer to start parsing from\"), this.logBufferLevel(), !1);\n  }, ArrayBuffer.concat = function(t, e) {\n    r.debug(\"ArrayBuffer\", \"Trying to create a new buffer of size: \" + (t.byteLength + e.byteLength));\n    var i = new Uint8Array(t.byteLength + e.byteLength);\n    return i.set(new Uint8Array(t), 0), i.set(new Uint8Array(e), t.byteLength), i.buffer;\n  }, d.prototype.reduceBuffer = function(t, e, i) {\n    var s;\n    return s = new Uint8Array(i), s.set(new Uint8Array(t, e, i)), s.buffer.fileStart = t.fileStart + e, s.buffer.usedBytes = 0, s.buffer;\n  }, d.prototype.insertBuffer = function(t) {\n    for (var e = !0, i = 0; i < this.buffers.length; i++) {\n      var s = this.buffers[i];\n      if (t.fileStart <= s.fileStart) {\n        if (t.fileStart === s.fileStart)\n          if (t.byteLength > s.byteLength) {\n            this.buffers.splice(i, 1), i--;\n            continue;\n          } else\n            r.warn(\"MultiBufferStream\", \"Buffer (fileStart: \" + t.fileStart + \" - Length: \" + t.byteLength + \") already appended, ignoring\");\n        else\n          t.fileStart + t.byteLength <= s.fileStart || (t = this.reduceBuffer(t, 0, s.fileStart - t.fileStart)), r.debug(\"MultiBufferStream\", \"Appending new buffer (fileStart: \" + t.fileStart + \" - Length: \" + t.byteLength + \")\"), this.buffers.splice(i, 0, t), i === 0 && (this.buffer = t);\n        e = !1;\n        break;\n      } else if (t.fileStart < s.fileStart + s.byteLength) {\n        var o = s.fileStart + s.byteLength - t.fileStart, c = t.byteLength - o;\n        if (c > 0)\n          t = this.reduceBuffer(t, o, c);\n        else {\n          e = !1;\n          break;\n        }\n      }\n    }\n    e && (r.debug(\"MultiBufferStream\", \"Appending new buffer (fileStart: \" + t.fileStart + \" - Length: \" + t.byteLength + \")\"), this.buffers.push(t), i === 0 && (this.buffer = t));\n  }, d.prototype.logBufferLevel = function(t) {\n    var e, i, s, o, c = [], u, _ = \"\";\n    for (s = 0, o = 0, e = 0; e < this.buffers.length; e++)\n      i = this.buffers[e], e === 0 ? (u = {}, c.push(u), u.start = i.fileStart, u.end = i.fileStart + i.byteLength, _ += \"[\" + u.start + \"-\") : u.end === i.fileStart ? u.end = i.fileStart + i.byteLength : (u = {}, u.start = i.fileStart, _ += c[c.length - 1].end - 1 + \"], [\" + u.start + \"-\", u.end = i.fileStart + i.byteLength, c.push(u)), s += i.usedBytes, o += i.byteLength;\n    c.length > 0 && (_ += u.end - 1 + \"]\");\n    var g = t ? r.info : r.debug;\n    this.buffers.length === 0 ? g(\"MultiBufferStream\", \"No more buffer in memory\") : g(\"MultiBufferStream\", \"\" + this.buffers.length + \" stored buffer(s) (\" + s + \"/\" + o + \" bytes), continuous ranges: \" + _);\n  }, d.prototype.cleanBuffers = function() {\n    var t, e;\n    for (t = 0; t < this.buffers.length; t++)\n      e = this.buffers[t], e.usedBytes === e.byteLength && (r.debug(\"MultiBufferStream\", \"Removing buffer #\" + t), this.buffers.splice(t, 1), t--);\n  }, d.prototype.mergeNextBuffer = function() {\n    var t;\n    if (this.bufferIndex + 1 < this.buffers.length)\n      if (t = this.buffers[this.bufferIndex + 1], t.fileStart === this.buffer.fileStart + this.buffer.byteLength) {\n        var e = this.buffer.byteLength, i = this.buffer.usedBytes, s = this.buffer.fileStart;\n        return this.buffers[this.bufferIndex] = ArrayBuffer.concat(this.buffer, t), this.buffer = this.buffers[this.bufferIndex], this.buffers.splice(this.bufferIndex + 1, 1), this.buffer.usedBytes = i, this.buffer.fileStart = s, r.debug(\"ISOFile\", \"Concatenating buffer for box parsing (length: \" + e + \"->\" + this.buffer.byteLength + \")\"), !0;\n      } else\n        return !1;\n    else\n      return !1;\n  }, d.prototype.findPosition = function(t, e, i) {\n    var s, o = null, c = -1;\n    for (t === !0 ? s = 0 : s = this.bufferIndex; s < this.buffers.length && (o = this.buffers[s], o.fileStart <= e); ) {\n      c = s, i && (o.fileStart + o.byteLength <= e ? o.usedBytes = o.byteLength : o.usedBytes = e - o.fileStart, this.logBufferLevel());\n      s++;\n    }\n    return c !== -1 ? (o = this.buffers[c], o.fileStart + o.byteLength >= e ? (r.debug(\"MultiBufferStream\", \"Found position in existing buffer #\" + c), c) : -1) : -1;\n  }, d.prototype.findEndContiguousBuf = function(t) {\n    var e, i, s, o = t !== void 0 ? t : this.bufferIndex;\n    if (i = this.buffers[o], this.buffers.length > o + 1)\n      for (e = o + 1; e < this.buffers.length && (s = this.buffers[e], s.fileStart === i.fileStart + i.byteLength); e++)\n        i = s;\n    return i.fileStart + i.byteLength;\n  }, d.prototype.getEndFilePositionAfter = function(t) {\n    var e = this.findPosition(!0, t, !1);\n    return e !== -1 ? this.findEndContiguousBuf(e) : t;\n  }, d.prototype.addUsedBytes = function(t) {\n    this.buffer.usedBytes += t, this.logBufferLevel();\n  }, d.prototype.setAllUsedBytes = function() {\n    this.buffer.usedBytes = this.buffer.byteLength, this.logBufferLevel();\n  }, d.prototype.seek = function(t, e, i) {\n    var s;\n    return s = this.findPosition(e, t, i), s !== -1 ? (this.buffer = this.buffers[s], this.bufferIndex = s, this.position = t - this.buffer.fileStart, r.debug(\"MultiBufferStream\", \"Repositioning parser at buffer position: \" + this.position), !0) : (r.debug(\"MultiBufferStream\", \"Position \" + t + \" not found in buffered data\"), !1);\n  }, d.prototype.getPosition = function() {\n    if (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null)\n      throw \"Error accessing position in the MultiBufferStream\";\n    return this.buffers[this.bufferIndex].fileStart + this.position;\n  }, d.prototype.getLength = function() {\n    return this.byteLength;\n  }, d.prototype.getEndPosition = function() {\n    if (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null)\n      throw \"Error accessing position in the MultiBufferStream\";\n    return this.buffers[this.bufferIndex].fileStart + this.byteLength;\n  }, l.MultiBufferStream = d;\n  var p = function() {\n    var t = 3, e = 4, i = 5, s = 6, o = [];\n    o[t] = \"ES_Descriptor\", o[e] = \"DecoderConfigDescriptor\", o[i] = \"DecoderSpecificInfo\", o[s] = \"SLConfigDescriptor\", this.getDescriptorName = function(_) {\n      return o[_];\n    };\n    var c = this, u = {};\n    return this.parseOneDescriptor = function(_) {\n      var g = 0, w, S, U;\n      for (w = _.readUint8(), U = _.readUint8(); U & 128; )\n        g = (U & 127) << 7, U = _.readUint8();\n      return g += U & 127, r.debug(\"MPEG4DescriptorParser\", \"Found \" + (o[w] || \"Descriptor \" + w) + \", size \" + g + \" at position \" + _.getPosition()), o[w] ? S = new u[o[w]](g) : S = new u.Descriptor(g), S.parse(_), S;\n    }, u.Descriptor = function(_, g) {\n      this.tag = _, this.size = g, this.descs = [];\n    }, u.Descriptor.prototype.parse = function(_) {\n      this.data = _.readUint8Array(this.size);\n    }, u.Descriptor.prototype.findDescriptor = function(_) {\n      for (var g = 0; g < this.descs.length; g++)\n        if (this.descs[g].tag == _)\n          return this.descs[g];\n      return null;\n    }, u.Descriptor.prototype.parseRemainingDescriptors = function(_) {\n      for (var g = _.position; _.position < g + this.size; ) {\n        var w = c.parseOneDescriptor(_);\n        this.descs.push(w);\n      }\n    }, u.ES_Descriptor = function(_) {\n      u.Descriptor.call(this, t, _);\n    }, u.ES_Descriptor.prototype = new u.Descriptor(), u.ES_Descriptor.prototype.parse = function(_) {\n      if (this.ES_ID = _.readUint16(), this.flags = _.readUint8(), this.size -= 3, this.flags & 128 ? (this.dependsOn_ES_ID = _.readUint16(), this.size -= 2) : this.dependsOn_ES_ID = 0, this.flags & 64) {\n        var g = _.readUint8();\n        this.URL = _.readString(g), this.size -= g + 1;\n      } else\n        this.URL = \"\";\n      this.flags & 32 ? (this.OCR_ES_ID = _.readUint16(), this.size -= 2) : this.OCR_ES_ID = 0, this.parseRemainingDescriptors(_);\n    }, u.ES_Descriptor.prototype.getOTI = function(_) {\n      var g = this.findDescriptor(e);\n      return g ? g.oti : 0;\n    }, u.ES_Descriptor.prototype.getAudioConfig = function(_) {\n      var g = this.findDescriptor(e);\n      if (!g) return null;\n      var w = g.findDescriptor(i);\n      if (w && w.data) {\n        var S = (w.data[0] & 248) >> 3;\n        return S === 31 && w.data.length >= 2 && (S = 32 + ((w.data[0] & 7) << 3) + ((w.data[1] & 224) >> 5)), S;\n      } else\n        return null;\n    }, u.DecoderConfigDescriptor = function(_) {\n      u.Descriptor.call(this, e, _);\n    }, u.DecoderConfigDescriptor.prototype = new u.Descriptor(), u.DecoderConfigDescriptor.prototype.parse = function(_) {\n      this.oti = _.readUint8(), this.streamType = _.readUint8(), this.bufferSize = _.readUint24(), this.maxBitrate = _.readUint32(), this.avgBitrate = _.readUint32(), this.size -= 13, this.parseRemainingDescriptors(_);\n    }, u.DecoderSpecificInfo = function(_) {\n      u.Descriptor.call(this, i, _);\n    }, u.DecoderSpecificInfo.prototype = new u.Descriptor(), u.SLConfigDescriptor = function(_) {\n      u.Descriptor.call(this, s, _);\n    }, u.SLConfigDescriptor.prototype = new u.Descriptor(), this;\n  };\n  l.MPEG4DescriptorParser = p;\n  var n = {\n    ERR_INVALID_DATA: -1,\n    ERR_NOT_ENOUGH_DATA: 0,\n    OK: 1,\n    // Boxes to be created with default parsing\n    BASIC_BOXES: [\"mdat\", \"idat\", \"free\", \"skip\", \"meco\", \"strk\"],\n    FULL_BOXES: [\"hmhd\", \"nmhd\", \"iods\", \"xml \", \"bxml\", \"ipro\", \"mere\"],\n    CONTAINER_BOXES: [\n      [\"moov\", [\"trak\", \"pssh\"]],\n      [\"trak\"],\n      [\"edts\"],\n      [\"mdia\"],\n      [\"minf\"],\n      [\"dinf\"],\n      [\"stbl\", [\"sgpd\", \"sbgp\"]],\n      [\"mvex\", [\"trex\"]],\n      [\"moof\", [\"traf\"]],\n      [\"traf\", [\"trun\", \"sgpd\", \"sbgp\"]],\n      [\"vttc\"],\n      [\"tref\"],\n      [\"iref\"],\n      [\"mfra\", [\"tfra\"]],\n      [\"meco\"],\n      [\"hnti\"],\n      [\"hinf\"],\n      [\"strk\"],\n      [\"strd\"],\n      [\"sinf\"],\n      [\"rinf\"],\n      [\"schi\"],\n      [\"trgr\"],\n      [\"udta\", [\"kind\"]],\n      [\"iprp\", [\"ipma\"]],\n      [\"ipco\"]\n    ],\n    // Boxes effectively created\n    boxCodes: [],\n    fullBoxCodes: [],\n    containerBoxCodes: [],\n    sampleEntryCodes: {},\n    sampleGroupEntryCodes: [],\n    trackGroupTypes: [],\n    UUIDBoxes: {},\n    UUIDs: [],\n    initialize: function() {\n      n.FullBox.prototype = new n.Box(), n.ContainerBox.prototype = new n.Box(), n.SampleEntry.prototype = new n.Box(), n.TrackGroupTypeBox.prototype = new n.FullBox(), n.BASIC_BOXES.forEach(function(t) {\n        n.createBoxCtor(t);\n      }), n.FULL_BOXES.forEach(function(t) {\n        n.createFullBoxCtor(t);\n      }), n.CONTAINER_BOXES.forEach(function(t) {\n        n.createContainerBoxCtor(t[0], null, t[1]);\n      });\n    },\n    Box: function(t, e, i) {\n      this.type = t, this.size = e, this.uuid = i;\n    },\n    FullBox: function(t, e, i) {\n      n.Box.call(this, t, e, i), this.flags = 0, this.version = 0;\n    },\n    ContainerBox: function(t, e, i) {\n      n.Box.call(this, t, e, i), this.boxes = [];\n    },\n    SampleEntry: function(t, e, i, s) {\n      n.ContainerBox.call(this, t, e), this.hdr_size = i, this.start = s;\n    },\n    SampleGroupEntry: function(t) {\n      this.grouping_type = t;\n    },\n    TrackGroupTypeBox: function(t, e) {\n      n.FullBox.call(this, t, e);\n    },\n    createBoxCtor: function(t, e) {\n      n.boxCodes.push(t), n[t + \"Box\"] = function(i) {\n        n.Box.call(this, t, i);\n      }, n[t + \"Box\"].prototype = new n.Box(), e && (n[t + \"Box\"].prototype.parse = e);\n    },\n    createFullBoxCtor: function(t, e) {\n      n[t + \"Box\"] = function(i) {\n        n.FullBox.call(this, t, i);\n      }, n[t + \"Box\"].prototype = new n.FullBox(), n[t + \"Box\"].prototype.parse = function(i) {\n        this.parseFullHeader(i), e && e.call(this, i);\n      };\n    },\n    addSubBoxArrays: function(t) {\n      if (t) {\n        this.subBoxNames = t;\n        for (var e = t.length, i = 0; i < e; i++)\n          this[t[i] + \"s\"] = [];\n      }\n    },\n    createContainerBoxCtor: function(t, e, i) {\n      n[t + \"Box\"] = function(s) {\n        n.ContainerBox.call(this, t, s), n.addSubBoxArrays.call(this, i);\n      }, n[t + \"Box\"].prototype = new n.ContainerBox(), e && (n[t + \"Box\"].prototype.parse = e);\n    },\n    createMediaSampleEntryCtor: function(t, e, i) {\n      n.sampleEntryCodes[t] = [], n[t + \"SampleEntry\"] = function(s, o) {\n        n.SampleEntry.call(this, s, o), n.addSubBoxArrays.call(this, i);\n      }, n[t + \"SampleEntry\"].prototype = new n.SampleEntry(), e && (n[t + \"SampleEntry\"].prototype.parse = e);\n    },\n    createSampleEntryCtor: function(t, e, i, s) {\n      n.sampleEntryCodes[t].push(e), n[e + \"SampleEntry\"] = function(o) {\n        n[t + \"SampleEntry\"].call(this, e, o), n.addSubBoxArrays.call(this, s);\n      }, n[e + \"SampleEntry\"].prototype = new n[t + \"SampleEntry\"](), i && (n[e + \"SampleEntry\"].prototype.parse = i);\n    },\n    createEncryptedSampleEntryCtor: function(t, e, i) {\n      n.createSampleEntryCtor.call(this, t, e, i, [\"sinf\"]);\n    },\n    createSampleGroupCtor: function(t, e) {\n      n[t + \"SampleGroupEntry\"] = function(i) {\n        n.SampleGroupEntry.call(this, t, i);\n      }, n[t + \"SampleGroupEntry\"].prototype = new n.SampleGroupEntry(), e && (n[t + \"SampleGroupEntry\"].prototype.parse = e);\n    },\n    createTrackGroupCtor: function(t, e) {\n      n[t + \"TrackGroupTypeBox\"] = function(i) {\n        n.TrackGroupTypeBox.call(this, t, i);\n      }, n[t + \"TrackGroupTypeBox\"].prototype = new n.TrackGroupTypeBox(), e && (n[t + \"TrackGroupTypeBox\"].prototype.parse = e);\n    },\n    createUUIDBox: function(t, e, i, s) {\n      n.UUIDs.push(t), n.UUIDBoxes[t] = function(o) {\n        e ? n.FullBox.call(this, \"uuid\", o, t) : i ? n.ContainerBox.call(this, \"uuid\", o, t) : n.Box.call(this, \"uuid\", o, t);\n      }, n.UUIDBoxes[t].prototype = e ? new n.FullBox() : i ? new n.ContainerBox() : new n.Box(), s && (e ? n.UUIDBoxes[t].prototype.parse = function(o) {\n        this.parseFullHeader(o), s && s.call(this, o);\n      } : n.UUIDBoxes[t].prototype.parse = s);\n    }\n  };\n  n.initialize(), n.TKHD_FLAG_ENABLED = 1, n.TKHD_FLAG_IN_MOVIE = 2, n.TKHD_FLAG_IN_PREVIEW = 4, n.TFHD_FLAG_BASE_DATA_OFFSET = 1, n.TFHD_FLAG_SAMPLE_DESC = 2, n.TFHD_FLAG_SAMPLE_DUR = 8, n.TFHD_FLAG_SAMPLE_SIZE = 16, n.TFHD_FLAG_SAMPLE_FLAGS = 32, n.TFHD_FLAG_DUR_EMPTY = 65536, n.TFHD_FLAG_DEFAULT_BASE_IS_MOOF = 131072, n.TRUN_FLAGS_DATA_OFFSET = 1, n.TRUN_FLAGS_FIRST_FLAG = 4, n.TRUN_FLAGS_DURATION = 256, n.TRUN_FLAGS_SIZE = 512, n.TRUN_FLAGS_FLAGS = 1024, n.TRUN_FLAGS_CTS_OFFSET = 2048, n.Box.prototype.add = function(t) {\n    return this.addBox(new n[t + \"Box\"]());\n  }, n.Box.prototype.addBox = function(t) {\n    return this.boxes.push(t), this[t.type + \"s\"] ? this[t.type + \"s\"].push(t) : this[t.type] = t, t;\n  }, n.Box.prototype.set = function(t, e) {\n    return this[t] = e, this;\n  }, n.Box.prototype.addEntry = function(t, e) {\n    var i = e || \"entries\";\n    return this[i] || (this[i] = []), this[i].push(t), this;\n  }, l.BoxParser = n, n.parseUUID = function(t) {\n    return n.parseHex16(t);\n  }, n.parseHex16 = function(t) {\n    for (var e = \"\", i = 0; i < 16; i++) {\n      var s = t.readUint8().toString(16);\n      e += s.length === 1 ? \"0\" + s : s;\n    }\n    return e;\n  }, n.parseOneBox = function(t, e, i) {\n    var s, o = t.getPosition(), c = 0, u, _;\n    if (t.getEndPosition() - o < 8)\n      return r.debug(\"BoxParser\", \"Not enough data in stream to parse the type and size of the box\"), { code: n.ERR_NOT_ENOUGH_DATA };\n    if (i && i < 8)\n      return r.debug(\"BoxParser\", \"Not enough bytes left in the parent box to parse a new box\"), { code: n.ERR_NOT_ENOUGH_DATA };\n    var g = t.readUint32(), w = t.readString(4), S = w;\n    if (r.debug(\"BoxParser\", \"Found box of type '\" + w + \"' and size \" + g + \" at position \" + o), c = 8, w == \"uuid\") {\n      if (t.getEndPosition() - t.getPosition() < 16 || i - c < 16)\n        return t.seek(o), r.debug(\"BoxParser\", \"Not enough bytes left in the parent box to parse a UUID box\"), { code: n.ERR_NOT_ENOUGH_DATA };\n      _ = n.parseUUID(t), c += 16, S = _;\n    }\n    if (g == 1) {\n      if (t.getEndPosition() - t.getPosition() < 8 || i && i - c < 8)\n        return t.seek(o), r.warn(\"BoxParser\", 'Not enough data in stream to parse the extended size of the \"' + w + '\" box'), { code: n.ERR_NOT_ENOUGH_DATA };\n      g = t.readUint64(), c += 8;\n    } else if (g === 0) {\n      if (i)\n        g = i;\n      else if (w !== \"mdat\")\n        return r.error(\"BoxParser\", \"Unlimited box size not supported for type: '\" + w + \"'\"), s = new n.Box(w, g), { code: n.OK, box: s, size: s.size };\n    }\n    return g !== 0 && g < c ? (r.error(\"BoxParser\", \"Box of type \" + w + \" has an invalid size \" + g + \" (too small to be a box)\"), { code: n.ERR_NOT_ENOUGH_DATA, type: w, size: g, hdr_size: c, start: o }) : g !== 0 && i && g > i ? (r.error(\"BoxParser\", \"Box of type '\" + w + \"' has a size \" + g + \" greater than its container size \" + i), { code: n.ERR_NOT_ENOUGH_DATA, type: w, size: g, hdr_size: c, start: o }) : g !== 0 && o + g > t.getEndPosition() ? (t.seek(o), r.info(\"BoxParser\", \"Not enough data in stream to parse the entire '\" + w + \"' box\"), { code: n.ERR_NOT_ENOUGH_DATA, type: w, size: g, hdr_size: c, start: o }) : e ? { code: n.OK, type: w, size: g, hdr_size: c, start: o } : (n[w + \"Box\"] ? s = new n[w + \"Box\"](g) : w !== \"uuid\" ? (r.warn(\"BoxParser\", \"Unknown box type: '\" + w + \"'\"), s = new n.Box(w, g), s.has_unparsed_data = !0) : n.UUIDBoxes[_] ? s = new n.UUIDBoxes[_](g) : (r.warn(\"BoxParser\", \"Unknown uuid type: '\" + _ + \"'\"), s = new n.Box(w, g), s.uuid = _, s.has_unparsed_data = !0), s.hdr_size = c, s.start = o, s.write === n.Box.prototype.write && s.type !== \"mdat\" && (r.info(\"BoxParser\", \"'\" + S + \"' box writing not yet implemented, keeping unparsed data in memory for later write\"), s.parseDataAndRewind(t)), s.parse(t), u = t.getPosition() - (s.start + s.size), u < 0 ? (r.warn(\"BoxParser\", \"Parsing of box '\" + S + \"' did not read the entire indicated box data size (missing \" + -u + \" bytes), seeking forward\"), t.seek(s.start + s.size)) : u > 0 && (r.error(\"BoxParser\", \"Parsing of box '\" + S + \"' read \" + u + \" more bytes than the indicated box data size, seeking backwards\"), s.size !== 0 && t.seek(s.start + s.size)), { code: n.OK, box: s, size: s.size });\n  }, n.Box.prototype.parse = function(t) {\n    this.type != \"mdat\" ? this.data = t.readUint8Array(this.size - this.hdr_size) : this.size === 0 ? t.seek(t.getEndPosition()) : t.seek(this.start + this.size);\n  }, n.Box.prototype.parseDataAndRewind = function(t) {\n    this.data = t.readUint8Array(this.size - this.hdr_size), t.position -= this.size - this.hdr_size;\n  }, n.FullBox.prototype.parseDataAndRewind = function(t) {\n    this.parseFullHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 4, t.position -= this.size - this.hdr_size;\n  }, n.FullBox.prototype.parseFullHeader = function(t) {\n    this.version = t.readUint8(), this.flags = t.readUint24(), this.hdr_size += 4;\n  }, n.FullBox.prototype.parse = function(t) {\n    this.parseFullHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size);\n  }, n.ContainerBox.prototype.parse = function(t) {\n    for (var e, i; t.getPosition() < this.start + this.size; )\n      if (e = n.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), e.code === n.OK)\n        if (i = e.box, this.boxes.push(i), this.subBoxNames && this.subBoxNames.indexOf(i.type) != -1)\n          this[this.subBoxNames[this.subBoxNames.indexOf(i.type)] + \"s\"].push(i);\n        else {\n          var s = i.type !== \"uuid\" ? i.type : i.uuid;\n          this[s] ? r.warn(\"Box of type \" + s + \" already stored in field of this type\") : this[s] = i;\n        }\n      else\n        return;\n  }, n.Box.prototype.parseLanguage = function(t) {\n    this.language = t.readUint16();\n    var e = [];\n    e[0] = this.language >> 10 & 31, e[1] = this.language >> 5 & 31, e[2] = this.language & 31, this.languageString = String.fromCharCode(e[0] + 96, e[1] + 96, e[2] + 96);\n  }, n.SAMPLE_ENTRY_TYPE_VISUAL = \"Visual\", n.SAMPLE_ENTRY_TYPE_AUDIO = \"Audio\", n.SAMPLE_ENTRY_TYPE_HINT = \"Hint\", n.SAMPLE_ENTRY_TYPE_METADATA = \"Metadata\", n.SAMPLE_ENTRY_TYPE_SUBTITLE = \"Subtitle\", n.SAMPLE_ENTRY_TYPE_SYSTEM = \"System\", n.SAMPLE_ENTRY_TYPE_TEXT = \"Text\", n.SampleEntry.prototype.parseHeader = function(t) {\n    t.readUint8Array(6), this.data_reference_index = t.readUint16(), this.hdr_size += 8;\n  }, n.SampleEntry.prototype.parse = function(t) {\n    this.parseHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size);\n  }, n.SampleEntry.prototype.parseDataAndRewind = function(t) {\n    this.parseHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 8, t.position -= this.size - this.hdr_size;\n  }, n.SampleEntry.prototype.parseFooter = function(t) {\n    n.ContainerBox.prototype.parse.call(this, t);\n  }, n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_HINT), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_METADATA), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SYSTEM), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_TEXT), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, function(t) {\n    var e;\n    this.parseHeader(t), t.readUint16(), t.readUint16(), t.readUint32Array(3), this.width = t.readUint16(), this.height = t.readUint16(), this.horizresolution = t.readUint32(), this.vertresolution = t.readUint32(), t.readUint32(), this.frame_count = t.readUint16(), e = Math.min(31, t.readUint8()), this.compressorname = t.readString(e), e < 31 && t.readString(31 - e), this.depth = t.readUint16(), t.readUint16(), this.parseFooter(t);\n  }), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, function(t) {\n    this.parseHeader(t), t.readUint32Array(2), this.channel_count = t.readUint16(), this.samplesize = t.readUint16(), t.readUint16(), t.readUint16(), this.samplerate = t.readUint32() / 65536, this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"avc1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"avc2\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"avc3\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"avc4\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"av01\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"hvc1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"hev1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vvc1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vvi1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vvs1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vvcN\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vp08\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vp09\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, \"mp4a\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, \"ac-3\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, \"ec-3\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, \"Opus\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"encv\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, \"enca\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE, \"encu\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SYSTEM, \"encs\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_TEXT, \"enct\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_METADATA, \"encm\"), n.createBoxCtor(\"a1lx\", function(t) {\n    var e = t.readUint8() & 1, i = ((e & 1) + 1) * 16;\n    this.layer_size = [];\n    for (var s = 0; s < 3; s++)\n      i == 16 ? this.layer_size[s] = t.readUint16() : this.layer_size[s] = t.readUint32();\n  }), n.createBoxCtor(\"a1op\", function(t) {\n    this.op_index = t.readUint8();\n  }), n.createFullBoxCtor(\"auxC\", function(t) {\n    this.aux_type = t.readCString();\n    var e = this.size - this.hdr_size - (this.aux_type.length + 1);\n    this.aux_subtype = t.readUint8Array(e);\n  }), n.createBoxCtor(\"av1C\", function(t) {\n    var e = t.readUint8();\n    if (e >> 7 & !1) {\n      r.error(\"av1C marker problem\");\n      return;\n    }\n    if (this.version = e & 127, this.version !== 1) {\n      r.error(\"av1C version \" + this.version + \" not supported\");\n      return;\n    }\n    if (e = t.readUint8(), this.seq_profile = e >> 5 & 7, this.seq_level_idx_0 = e & 31, e = t.readUint8(), this.seq_tier_0 = e >> 7 & 1, this.high_bitdepth = e >> 6 & 1, this.twelve_bit = e >> 5 & 1, this.monochrome = e >> 4 & 1, this.chroma_subsampling_x = e >> 3 & 1, this.chroma_subsampling_y = e >> 2 & 1, this.chroma_sample_position = e & 3, e = t.readUint8(), this.reserved_1 = e >> 5 & 7, this.reserved_1 !== 0) {\n      r.error(\"av1C reserved_1 parsing problem\");\n      return;\n    }\n    if (this.initial_presentation_delay_present = e >> 4 & 1, this.initial_presentation_delay_present === 1)\n      this.initial_presentation_delay_minus_one = e & 15;\n    else if (this.reserved_2 = e & 15, this.reserved_2 !== 0) {\n      r.error(\"av1C reserved_2 parsing problem\");\n      return;\n    }\n    var i = this.size - this.hdr_size - 4;\n    this.configOBUs = t.readUint8Array(i);\n  }), n.createBoxCtor(\"avcC\", function(t) {\n    var e, i;\n    for (this.configurationVersion = t.readUint8(), this.AVCProfileIndication = t.readUint8(), this.profile_compatibility = t.readUint8(), this.AVCLevelIndication = t.readUint8(), this.lengthSizeMinusOne = t.readUint8() & 3, this.nb_SPS_nalus = t.readUint8() & 31, i = this.size - this.hdr_size - 6, this.SPS = [], e = 0; e < this.nb_SPS_nalus; e++)\n      this.SPS[e] = {}, this.SPS[e].length = t.readUint16(), this.SPS[e].nalu = t.readUint8Array(this.SPS[e].length), i -= 2 + this.SPS[e].length;\n    for (this.nb_PPS_nalus = t.readUint8(), i--, this.PPS = [], e = 0; e < this.nb_PPS_nalus; e++)\n      this.PPS[e] = {}, this.PPS[e].length = t.readUint16(), this.PPS[e].nalu = t.readUint8Array(this.PPS[e].length), i -= 2 + this.PPS[e].length;\n    i > 0 && (this.ext = t.readUint8Array(i));\n  }), n.createBoxCtor(\"btrt\", function(t) {\n    this.bufferSizeDB = t.readUint32(), this.maxBitrate = t.readUint32(), this.avgBitrate = t.readUint32();\n  }), n.createBoxCtor(\"clap\", function(t) {\n    this.cleanApertureWidthN = t.readUint32(), this.cleanApertureWidthD = t.readUint32(), this.cleanApertureHeightN = t.readUint32(), this.cleanApertureHeightD = t.readUint32(), this.horizOffN = t.readUint32(), this.horizOffD = t.readUint32(), this.vertOffN = t.readUint32(), this.vertOffD = t.readUint32();\n  }), n.createBoxCtor(\"clli\", function(t) {\n    this.max_content_light_level = t.readUint16(), this.max_pic_average_light_level = t.readUint16();\n  }), n.createFullBoxCtor(\"co64\", function(t) {\n    var e, i;\n    if (e = t.readUint32(), this.chunk_offsets = [], this.version === 0)\n      for (i = 0; i < e; i++)\n        this.chunk_offsets.push(t.readUint64());\n  }), n.createFullBoxCtor(\"CoLL\", function(t) {\n    this.maxCLL = t.readUint16(), this.maxFALL = t.readUint16();\n  }), n.createBoxCtor(\"colr\", function(t) {\n    if (this.colour_type = t.readString(4), this.colour_type === \"nclx\") {\n      this.colour_primaries = t.readUint16(), this.transfer_characteristics = t.readUint16(), this.matrix_coefficients = t.readUint16();\n      var e = t.readUint8();\n      this.full_range_flag = e >> 7;\n    } else this.colour_type === \"rICC\" ? this.ICC_profile = t.readUint8Array(this.size - 4) : this.colour_type === \"prof\" && (this.ICC_profile = t.readUint8Array(this.size - 4));\n  }), n.createFullBoxCtor(\"cprt\", function(t) {\n    this.parseLanguage(t), this.notice = t.readCString();\n  }), n.createFullBoxCtor(\"cslg\", function(t) {\n    this.version === 0 && (this.compositionToDTSShift = t.readInt32(), this.leastDecodeToDisplayDelta = t.readInt32(), this.greatestDecodeToDisplayDelta = t.readInt32(), this.compositionStartTime = t.readInt32(), this.compositionEndTime = t.readInt32());\n  }), n.createFullBoxCtor(\"ctts\", function(t) {\n    var e, i;\n    if (e = t.readUint32(), this.sample_counts = [], this.sample_offsets = [], this.version === 0)\n      for (i = 0; i < e; i++) {\n        this.sample_counts.push(t.readUint32());\n        var s = t.readInt32();\n        s < 0 && r.warn(\"BoxParser\", \"ctts box uses negative values without using version 1\"), this.sample_offsets.push(s);\n      }\n    else if (this.version == 1)\n      for (i = 0; i < e; i++)\n        this.sample_counts.push(t.readUint32()), this.sample_offsets.push(t.readInt32());\n  }), n.createBoxCtor(\"dac3\", function(t) {\n    var e = t.readUint8(), i = t.readUint8(), s = t.readUint8();\n    this.fscod = e >> 6, this.bsid = e >> 1 & 31, this.bsmod = (e & 1) << 2 | i >> 6 & 3, this.acmod = i >> 3 & 7, this.lfeon = i >> 2 & 1, this.bit_rate_code = i & 3 | s >> 5 & 7;\n  }), n.createBoxCtor(\"dec3\", function(t) {\n    var e = t.readUint16();\n    this.data_rate = e >> 3, this.num_ind_sub = e & 7, this.ind_subs = [];\n    for (var i = 0; i < this.num_ind_sub + 1; i++) {\n      var s = {};\n      this.ind_subs.push(s);\n      var o = t.readUint8(), c = t.readUint8(), u = t.readUint8();\n      s.fscod = o >> 6, s.bsid = o >> 1 & 31, s.bsmod = (o & 1) << 4 | c >> 4 & 15, s.acmod = c >> 1 & 7, s.lfeon = c & 1, s.num_dep_sub = u >> 1 & 15, s.num_dep_sub > 0 && (s.chan_loc = (u & 1) << 8 | t.readUint8());\n    }\n  }), n.createFullBoxCtor(\"dfLa\", function(t) {\n    var e = 127, i = 128, s = [], o = [\n      \"STREAMINFO\",\n      \"PADDING\",\n      \"APPLICATION\",\n      \"SEEKTABLE\",\n      \"VORBIS_COMMENT\",\n      \"CUESHEET\",\n      \"PICTURE\",\n      \"RESERVED\"\n    ];\n    this.parseFullHeader(t);\n    do {\n      var c = t.readUint8(), u = Math.min(\n        c & e,\n        o.length - 1\n      );\n      if (u ? t.readUint8Array(t.readUint24()) : (t.readUint8Array(13), this.samplerate = t.readUint32() >> 12, t.readUint8Array(20)), s.push(o[u]), c & i)\n        break;\n    } while (!0);\n    this.numMetadataBlocks = s.length + \" (\" + s.join(\", \") + \")\";\n  }), n.createBoxCtor(\"dimm\", function(t) {\n    this.bytessent = t.readUint64();\n  }), n.createBoxCtor(\"dmax\", function(t) {\n    this.time = t.readUint32();\n  }), n.createBoxCtor(\"dmed\", function(t) {\n    this.bytessent = t.readUint64();\n  }), n.createBoxCtor(\"dOps\", function(t) {\n    if (this.Version = t.readUint8(), this.OutputChannelCount = t.readUint8(), this.PreSkip = t.readUint16(), this.InputSampleRate = t.readUint32(), this.OutputGain = t.readInt16(), this.ChannelMappingFamily = t.readUint8(), this.ChannelMappingFamily !== 0) {\n      this.StreamCount = t.readUint8(), this.CoupledCount = t.readUint8(), this.ChannelMapping = [];\n      for (var e = 0; e < this.OutputChannelCount; e++)\n        this.ChannelMapping[e] = t.readUint8();\n    }\n  }), n.createFullBoxCtor(\"dref\", function(t) {\n    var e, i;\n    this.entries = [];\n    for (var s = t.readUint32(), o = 0; o < s; o++)\n      if (e = n.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), e.code === n.OK)\n        i = e.box, this.entries.push(i);\n      else\n        return;\n  }), n.createBoxCtor(\"drep\", function(t) {\n    this.bytessent = t.readUint64();\n  }), n.createFullBoxCtor(\"elng\", function(t) {\n    this.extended_language = t.readString(this.size - this.hdr_size);\n  }), n.createFullBoxCtor(\"elst\", function(t) {\n    this.entries = [];\n    for (var e = t.readUint32(), i = 0; i < e; i++) {\n      var s = {};\n      this.entries.push(s), this.version === 1 ? (s.segment_duration = t.readUint64(), s.media_time = t.readInt64()) : (s.segment_duration = t.readUint32(), s.media_time = t.readInt32()), s.media_rate_integer = t.readInt16(), s.media_rate_fraction = t.readInt16();\n    }\n  }), n.createFullBoxCtor(\"emsg\", function(t) {\n    this.version == 1 ? (this.timescale = t.readUint32(), this.presentation_time = t.readUint64(), this.event_duration = t.readUint32(), this.id = t.readUint32(), this.scheme_id_uri = t.readCString(), this.value = t.readCString()) : (this.scheme_id_uri = t.readCString(), this.value = t.readCString(), this.timescale = t.readUint32(), this.presentation_time_delta = t.readUint32(), this.event_duration = t.readUint32(), this.id = t.readUint32());\n    var e = this.size - this.hdr_size - (4 * 4 + (this.scheme_id_uri.length + 1) + (this.value.length + 1));\n    this.version == 1 && (e -= 4), this.message_data = t.readUint8Array(e);\n  }), n.createFullBoxCtor(\"esds\", function(t) {\n    var e = t.readUint8Array(this.size - this.hdr_size);\n    if (typeof p < \"u\") {\n      var i = new p();\n      this.esd = i.parseOneDescriptor(new a(e.buffer, 0, a.BIG_ENDIAN));\n    }\n  }), n.createBoxCtor(\"fiel\", function(t) {\n    this.fieldCount = t.readUint8(), this.fieldOrdering = t.readUint8();\n  }), n.createBoxCtor(\"frma\", function(t) {\n    this.data_format = t.readString(4);\n  }), n.createBoxCtor(\"ftyp\", function(t) {\n    var e = this.size - this.hdr_size;\n    this.major_brand = t.readString(4), this.minor_version = t.readUint32(), e -= 8, this.compatible_brands = [];\n    for (var i = 0; e >= 4; )\n      this.compatible_brands[i] = t.readString(4), e -= 4, i++;\n  }), n.createFullBoxCtor(\"hdlr\", function(t) {\n    this.version === 0 && (t.readUint32(), this.handler = t.readString(4), t.readUint32Array(3), this.name = t.readString(this.size - this.hdr_size - 20), this.name[this.name.length - 1] === \"\\0\" && (this.name = this.name.slice(0, -1)));\n  }), n.createBoxCtor(\"hvcC\", function(t) {\n    var e, i, s, o;\n    this.configurationVersion = t.readUint8(), o = t.readUint8(), this.general_profile_space = o >> 6, this.general_tier_flag = (o & 32) >> 5, this.general_profile_idc = o & 31, this.general_profile_compatibility = t.readUint32(), this.general_constraint_indicator = t.readUint8Array(6), this.general_level_idc = t.readUint8(), this.min_spatial_segmentation_idc = t.readUint16() & 4095, this.parallelismType = t.readUint8() & 3, this.chroma_format_idc = t.readUint8() & 3, this.bit_depth_luma_minus8 = t.readUint8() & 7, this.bit_depth_chroma_minus8 = t.readUint8() & 7, this.avgFrameRate = t.readUint16(), o = t.readUint8(), this.constantFrameRate = o >> 6, this.numTemporalLayers = (o & 13) >> 3, this.temporalIdNested = (o & 4) >> 2, this.lengthSizeMinusOne = o & 3, this.nalu_arrays = [];\n    var c = t.readUint8();\n    for (e = 0; e < c; e++) {\n      var u = [];\n      this.nalu_arrays.push(u), o = t.readUint8(), u.completeness = (o & 128) >> 7, u.nalu_type = o & 63;\n      var _ = t.readUint16();\n      for (i = 0; i < _; i++) {\n        var g = {};\n        u.push(g), s = t.readUint16(), g.data = t.readUint8Array(s);\n      }\n    }\n  }), n.createFullBoxCtor(\"iinf\", function(t) {\n    var e;\n    this.version === 0 ? this.entry_count = t.readUint16() : this.entry_count = t.readUint32(), this.item_infos = [];\n    for (var i = 0; i < this.entry_count; i++)\n      if (e = n.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), e.code === n.OK)\n        e.box.type !== \"infe\" && r.error(\"BoxParser\", \"Expected 'infe' box, got \" + e.box.type), this.item_infos[i] = e.box;\n      else\n        return;\n  }), n.createFullBoxCtor(\"iloc\", function(t) {\n    var e;\n    e = t.readUint8(), this.offset_size = e >> 4 & 15, this.length_size = e & 15, e = t.readUint8(), this.base_offset_size = e >> 4 & 15, this.version === 1 || this.version === 2 ? this.index_size = e & 15 : this.index_size = 0, this.items = [];\n    var i = 0;\n    if (this.version < 2)\n      i = t.readUint16();\n    else if (this.version === 2)\n      i = t.readUint32();\n    else\n      throw \"version of iloc box not supported\";\n    for (var s = 0; s < i; s++) {\n      var o = {};\n      if (this.items.push(o), this.version < 2)\n        o.item_ID = t.readUint16();\n      else if (this.version === 2)\n        o.item_ID = t.readUint16();\n      else\n        throw \"version of iloc box not supported\";\n      switch (this.version === 1 || this.version === 2 ? o.construction_method = t.readUint16() & 15 : o.construction_method = 0, o.data_reference_index = t.readUint16(), this.base_offset_size) {\n        case 0:\n          o.base_offset = 0;\n          break;\n        case 4:\n          o.base_offset = t.readUint32();\n          break;\n        case 8:\n          o.base_offset = t.readUint64();\n          break;\n        default:\n          throw \"Error reading base offset size\";\n      }\n      var c = t.readUint16();\n      o.extents = [];\n      for (var u = 0; u < c; u++) {\n        var _ = {};\n        if (o.extents.push(_), this.version === 1 || this.version === 2)\n          switch (this.index_size) {\n            case 0:\n              _.extent_index = 0;\n              break;\n            case 4:\n              _.extent_index = t.readUint32();\n              break;\n            case 8:\n              _.extent_index = t.readUint64();\n              break;\n            default:\n              throw \"Error reading extent index\";\n          }\n        switch (this.offset_size) {\n          case 0:\n            _.extent_offset = 0;\n            break;\n          case 4:\n            _.extent_offset = t.readUint32();\n            break;\n          case 8:\n            _.extent_offset = t.readUint64();\n            break;\n          default:\n            throw \"Error reading extent index\";\n        }\n        switch (this.length_size) {\n          case 0:\n            _.extent_length = 0;\n            break;\n          case 4:\n            _.extent_length = t.readUint32();\n            break;\n          case 8:\n            _.extent_length = t.readUint64();\n            break;\n          default:\n            throw \"Error reading extent index\";\n        }\n      }\n    }\n  }), n.createBoxCtor(\"imir\", function(t) {\n    var e = t.readUint8();\n    this.reserved = e >> 7, this.axis = e & 1;\n  }), n.createFullBoxCtor(\"infe\", function(t) {\n    if ((this.version === 0 || this.version === 1) && (this.item_ID = t.readUint16(), this.item_protection_index = t.readUint16(), this.item_name = t.readCString(), this.content_type = t.readCString(), this.content_encoding = t.readCString()), this.version === 1) {\n      this.extension_type = t.readString(4), r.warn(\"BoxParser\", \"Cannot parse extension type\"), t.seek(this.start + this.size);\n      return;\n    }\n    this.version >= 2 && (this.version === 2 ? this.item_ID = t.readUint16() : this.version === 3 && (this.item_ID = t.readUint32()), this.item_protection_index = t.readUint16(), this.item_type = t.readString(4), this.item_name = t.readCString(), this.item_type === \"mime\" ? (this.content_type = t.readCString(), this.content_encoding = t.readCString()) : this.item_type === \"uri \" && (this.item_uri_type = t.readCString()));\n  }), n.createFullBoxCtor(\"ipma\", function(t) {\n    var e, i;\n    for (entry_count = t.readUint32(), this.associations = [], e = 0; e < entry_count; e++) {\n      var s = {};\n      this.associations.push(s), this.version < 1 ? s.id = t.readUint16() : s.id = t.readUint32();\n      var o = t.readUint8();\n      for (s.props = [], i = 0; i < o; i++) {\n        var c = t.readUint8(), u = {};\n        s.props.push(u), u.essential = (c & 128) >> 7 === 1, this.flags & 1 ? u.property_index = (c & 127) << 8 | t.readUint8() : u.property_index = c & 127;\n      }\n    }\n  }), n.createFullBoxCtor(\"iref\", function(t) {\n    var e, i;\n    for (this.references = []; t.getPosition() < this.start + this.size; )\n      if (e = n.parseOneBox(t, !0, this.size - (t.getPosition() - this.start)), e.code === n.OK)\n        this.version === 0 ? i = new n.SingleItemTypeReferenceBox(e.type, e.size, e.hdr_size, e.start) : i = new n.SingleItemTypeReferenceBoxLarge(e.type, e.size, e.hdr_size, e.start), i.write === n.Box.prototype.write && i.type !== \"mdat\" && (r.warn(\"BoxParser\", i.type + \" box writing not yet implemented, keeping unparsed data in memory for later write\"), i.parseDataAndRewind(t)), i.parse(t), this.references.push(i);\n      else\n        return;\n  }), n.createBoxCtor(\"irot\", function(t) {\n    this.angle = t.readUint8() & 3;\n  }), n.createFullBoxCtor(\"ispe\", function(t) {\n    this.image_width = t.readUint32(), this.image_height = t.readUint32();\n  }), n.createFullBoxCtor(\"kind\", function(t) {\n    this.schemeURI = t.readCString(), this.value = t.readCString();\n  }), n.createFullBoxCtor(\"leva\", function(t) {\n    var e = t.readUint8();\n    this.levels = [];\n    for (var i = 0; i < e; i++) {\n      var s = {};\n      this.levels[i] = s, s.track_ID = t.readUint32();\n      var o = t.readUint8();\n      switch (s.padding_flag = o >> 7, s.assignment_type = o & 127, s.assignment_type) {\n        case 0:\n          s.grouping_type = t.readString(4);\n          break;\n        case 1:\n          s.grouping_type = t.readString(4), s.grouping_type_parameter = t.readUint32();\n          break;\n        case 2:\n          break;\n        case 3:\n          break;\n        case 4:\n          s.sub_track_id = t.readUint32();\n          break;\n        default:\n          r.warn(\"BoxParser\", \"Unknown leva assignement type\");\n      }\n    }\n  }), n.createBoxCtor(\"lsel\", function(t) {\n    this.layer_id = t.readUint16();\n  }), n.createBoxCtor(\"maxr\", function(t) {\n    this.period = t.readUint32(), this.bytes = t.readUint32();\n  }), n.createBoxCtor(\"mdcv\", function(t) {\n    this.display_primaries = [], this.display_primaries[0] = {}, this.display_primaries[0].x = t.readUint16(), this.display_primaries[0].y = t.readUint16(), this.display_primaries[1] = {}, this.display_primaries[1].x = t.readUint16(), this.display_primaries[1].y = t.readUint16(), this.display_primaries[2] = {}, this.display_primaries[2].x = t.readUint16(), this.display_primaries[2].y = t.readUint16(), this.white_point = {}, this.white_point.x = t.readUint16(), this.white_point.y = t.readUint16(), this.max_display_mastering_luminance = t.readUint32(), this.min_display_mastering_luminance = t.readUint32();\n  }), n.createFullBoxCtor(\"mdhd\", function(t) {\n    this.version == 1 ? (this.creation_time = t.readUint64(), this.modification_time = t.readUint64(), this.timescale = t.readUint32(), this.duration = t.readUint64()) : (this.creation_time = t.readUint32(), this.modification_time = t.readUint32(), this.timescale = t.readUint32(), this.duration = t.readUint32()), this.parseLanguage(t), t.readUint16();\n  }), n.createFullBoxCtor(\"mehd\", function(t) {\n    this.flags & 1 && (r.warn(\"BoxParser\", \"mehd box incorrectly uses flags set to 1, converting version to 1\"), this.version = 1), this.version == 1 ? this.fragment_duration = t.readUint64() : this.fragment_duration = t.readUint32();\n  }), n.createFullBoxCtor(\"meta\", function(t) {\n    this.boxes = [], n.ContainerBox.prototype.parse.call(this, t);\n  }), n.createFullBoxCtor(\"mfhd\", function(t) {\n    this.sequence_number = t.readUint32();\n  }), n.createFullBoxCtor(\"mfro\", function(t) {\n    this._size = t.readUint32();\n  }), n.createFullBoxCtor(\"mvhd\", function(t) {\n    this.version == 1 ? (this.creation_time = t.readUint64(), this.modification_time = t.readUint64(), this.timescale = t.readUint32(), this.duration = t.readUint64()) : (this.creation_time = t.readUint32(), this.modification_time = t.readUint32(), this.timescale = t.readUint32(), this.duration = t.readUint32()), this.rate = t.readUint32(), this.volume = t.readUint16() >> 8, t.readUint16(), t.readUint32Array(2), this.matrix = t.readUint32Array(9), t.readUint32Array(6), this.next_track_id = t.readUint32();\n  }), n.createBoxCtor(\"npck\", function(t) {\n    this.packetssent = t.readUint32();\n  }), n.createBoxCtor(\"nump\", function(t) {\n    this.packetssent = t.readUint64();\n  }), n.createFullBoxCtor(\"padb\", function(t) {\n    var e = t.readUint32();\n    this.padbits = [];\n    for (var i = 0; i < Math.floor((e + 1) / 2); i++)\n      this.padbits = t.readUint8();\n  }), n.createBoxCtor(\"pasp\", function(t) {\n    this.hSpacing = t.readUint32(), this.vSpacing = t.readUint32();\n  }), n.createBoxCtor(\"payl\", function(t) {\n    this.text = t.readString(this.size - this.hdr_size);\n  }), n.createBoxCtor(\"payt\", function(t) {\n    this.payloadID = t.readUint32();\n    var e = t.readUint8();\n    this.rtpmap_string = t.readString(e);\n  }), n.createFullBoxCtor(\"pdin\", function(t) {\n    var e = (this.size - this.hdr_size) / 8;\n    this.rate = [], this.initial_delay = [];\n    for (var i = 0; i < e; i++)\n      this.rate[i] = t.readUint32(), this.initial_delay[i] = t.readUint32();\n  }), n.createFullBoxCtor(\"pitm\", function(t) {\n    this.version === 0 ? this.item_id = t.readUint16() : this.item_id = t.readUint32();\n  }), n.createFullBoxCtor(\"pixi\", function(t) {\n    var e;\n    for (this.num_channels = t.readUint8(), this.bits_per_channels = [], e = 0; e < this.num_channels; e++)\n      this.bits_per_channels[e] = t.readUint8();\n  }), n.createBoxCtor(\"pmax\", function(t) {\n    this.bytes = t.readUint32();\n  }), n.createFullBoxCtor(\"prft\", function(t) {\n    this.ref_track_id = t.readUint32(), this.ntp_timestamp = t.readUint64(), this.version === 0 ? this.media_time = t.readUint32() : this.media_time = t.readUint64();\n  }), n.createFullBoxCtor(\"pssh\", function(t) {\n    if (this.system_id = n.parseHex16(t), this.version > 0) {\n      var e = t.readUint32();\n      this.kid = [];\n      for (var i = 0; i < e; i++)\n        this.kid[i] = n.parseHex16(t);\n    }\n    var s = t.readUint32();\n    s > 0 && (this.data = t.readUint8Array(s));\n  }), n.createFullBoxCtor(\"clef\", function(t) {\n    this.width = t.readUint32(), this.height = t.readUint32();\n  }), n.createFullBoxCtor(\"enof\", function(t) {\n    this.width = t.readUint32(), this.height = t.readUint32();\n  }), n.createFullBoxCtor(\"prof\", function(t) {\n    this.width = t.readUint32(), this.height = t.readUint32();\n  }), n.createContainerBoxCtor(\"tapt\", null, [\"clef\", \"prof\", \"enof\"]), n.createBoxCtor(\"rtp \", function(t) {\n    this.descriptionformat = t.readString(4), this.sdptext = t.readString(this.size - this.hdr_size - 4);\n  }), n.createFullBoxCtor(\"saio\", function(t) {\n    this.flags & 1 && (this.aux_info_type = t.readUint32(), this.aux_info_type_parameter = t.readUint32());\n    var e = t.readUint32();\n    this.offset = [];\n    for (var i = 0; i < e; i++)\n      this.version === 0 ? this.offset[i] = t.readUint32() : this.offset[i] = t.readUint64();\n  }), n.createFullBoxCtor(\"saiz\", function(t) {\n    this.flags & 1 && (this.aux_info_type = t.readUint32(), this.aux_info_type_parameter = t.readUint32()), this.default_sample_info_size = t.readUint8();\n    var e = t.readUint32();\n    if (this.sample_info_size = [], this.default_sample_info_size === 0)\n      for (var i = 0; i < e; i++)\n        this.sample_info_size[i] = t.readUint8();\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_METADATA, \"mett\", function(t) {\n    this.parseHeader(t), this.content_encoding = t.readCString(), this.mime_format = t.readCString(), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_METADATA, \"metx\", function(t) {\n    this.parseHeader(t), this.content_encoding = t.readCString(), this.namespace = t.readCString(), this.schema_location = t.readCString(), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE, \"sbtt\", function(t) {\n    this.parseHeader(t), this.content_encoding = t.readCString(), this.mime_format = t.readCString(), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE, \"stpp\", function(t) {\n    this.parseHeader(t), this.namespace = t.readCString(), this.schema_location = t.readCString(), this.auxiliary_mime_types = t.readCString(), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE, \"stxt\", function(t) {\n    this.parseHeader(t), this.content_encoding = t.readCString(), this.mime_format = t.readCString(), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE, \"tx3g\", function(t) {\n    this.parseHeader(t), this.displayFlags = t.readUint32(), this.horizontal_justification = t.readInt8(), this.vertical_justification = t.readInt8(), this.bg_color_rgba = t.readUint8Array(4), this.box_record = t.readInt16Array(4), this.style_record = t.readUint8Array(12), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_METADATA, \"wvtt\", function(t) {\n    this.parseHeader(t), this.parseFooter(t);\n  }), n.createSampleGroupCtor(\"alst\", function(t) {\n    var e, i = t.readUint16();\n    for (this.first_output_sample = t.readUint16(), this.sample_offset = [], e = 0; e < i; e++)\n      this.sample_offset[e] = t.readUint32();\n    var s = this.description_length - 4 - 4 * i;\n    for (this.num_output_samples = [], this.num_total_samples = [], e = 0; e < s / 4; e++)\n      this.num_output_samples[e] = t.readUint16(), this.num_total_samples[e] = t.readUint16();\n  }), n.createSampleGroupCtor(\"avll\", function(t) {\n    this.layerNumber = t.readUint8(), this.accurateStatisticsFlag = t.readUint8(), this.avgBitRate = t.readUint16(), this.avgFrameRate = t.readUint16();\n  }), n.createSampleGroupCtor(\"avss\", function(t) {\n    this.subSequenceIdentifier = t.readUint16(), this.layerNumber = t.readUint8();\n    var e = t.readUint8();\n    this.durationFlag = e >> 7, this.avgRateFlag = e >> 6 & 1, this.durationFlag && (this.duration = t.readUint32()), this.avgRateFlag && (this.accurateStatisticsFlag = t.readUint8(), this.avgBitRate = t.readUint16(), this.avgFrameRate = t.readUint16()), this.dependency = [];\n    for (var i = t.readUint8(), s = 0; s < i; s++) {\n      var o = {};\n      this.dependency.push(o), o.subSeqDirectionFlag = t.readUint8(), o.layerNumber = t.readUint8(), o.subSequenceIdentifier = t.readUint16();\n    }\n  }), n.createSampleGroupCtor(\"dtrt\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"mvif\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"prol\", function(t) {\n    this.roll_distance = t.readInt16();\n  }), n.createSampleGroupCtor(\"rap \", function(t) {\n    var e = t.readUint8();\n    this.num_leading_samples_known = e >> 7, this.num_leading_samples = e & 127;\n  }), n.createSampleGroupCtor(\"rash\", function(t) {\n    if (this.operation_point_count = t.readUint16(), this.description_length !== 2 + (this.operation_point_count === 1 ? 2 : this.operation_point_count * 6) + 9)\n      r.warn(\"BoxParser\", \"Mismatch in \" + this.grouping_type + \" sample group length\"), this.data = t.readUint8Array(this.description_length - 2);\n    else {\n      if (this.operation_point_count === 1)\n        this.target_rate_share = t.readUint16();\n      else {\n        this.target_rate_share = [], this.available_bitrate = [];\n        for (var e = 0; e < this.operation_point_count; e++)\n          this.available_bitrate[e] = t.readUint32(), this.target_rate_share[e] = t.readUint16();\n      }\n      this.maximum_bitrate = t.readUint32(), this.minimum_bitrate = t.readUint32(), this.discard_priority = t.readUint8();\n    }\n  }), n.createSampleGroupCtor(\"roll\", function(t) {\n    this.roll_distance = t.readInt16();\n  }), n.SampleGroupEntry.prototype.parse = function(t) {\n    r.warn(\"BoxParser\", \"Unknown Sample Group type: \" + this.grouping_type), this.data = t.readUint8Array(this.description_length);\n  }, n.createSampleGroupCtor(\"scif\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"scnm\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"seig\", function(t) {\n    this.reserved = t.readUint8();\n    var e = t.readUint8();\n    this.crypt_byte_block = e >> 4, this.skip_byte_block = e & 15, this.isProtected = t.readUint8(), this.Per_Sample_IV_Size = t.readUint8(), this.KID = n.parseHex16(t), this.constant_IV_size = 0, this.constant_IV = 0, this.isProtected === 1 && this.Per_Sample_IV_Size === 0 && (this.constant_IV_size = t.readUint8(), this.constant_IV = t.readUint8Array(this.constant_IV_size));\n  }), n.createSampleGroupCtor(\"stsa\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"sync\", function(t) {\n    var e = t.readUint8();\n    this.NAL_unit_type = e & 63;\n  }), n.createSampleGroupCtor(\"tele\", function(t) {\n    var e = t.readUint8();\n    this.level_independently_decodable = e >> 7;\n  }), n.createSampleGroupCtor(\"tsas\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"tscl\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"vipr\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createFullBoxCtor(\"sbgp\", function(t) {\n    this.grouping_type = t.readString(4), this.version === 1 ? this.grouping_type_parameter = t.readUint32() : this.grouping_type_parameter = 0, this.entries = [];\n    for (var e = t.readUint32(), i = 0; i < e; i++) {\n      var s = {};\n      this.entries.push(s), s.sample_count = t.readInt32(), s.group_description_index = t.readInt32();\n    }\n  }), n.createFullBoxCtor(\"schm\", function(t) {\n    this.scheme_type = t.readString(4), this.scheme_version = t.readUint32(), this.flags & 1 && (this.scheme_uri = t.readString(this.size - this.hdr_size - 8));\n  }), n.createBoxCtor(\"sdp \", function(t) {\n    this.sdptext = t.readString(this.size - this.hdr_size);\n  }), n.createFullBoxCtor(\"sdtp\", function(t) {\n    var e, i = this.size - this.hdr_size;\n    this.is_leading = [], this.sample_depends_on = [], this.sample_is_depended_on = [], this.sample_has_redundancy = [];\n    for (var s = 0; s < i; s++)\n      e = t.readUint8(), this.is_leading[s] = e >> 6, this.sample_depends_on[s] = e >> 4 & 3, this.sample_is_depended_on[s] = e >> 2 & 3, this.sample_has_redundancy[s] = e & 3;\n  }), n.createFullBoxCtor(\n    \"senc\"\n    /*, function(stream) {\n    \tthis.parseFullHeader(stream);\n    \tvar sample_count = stream.readUint32();\n    \tthis.samples = [];\n    \tfor (var i = 0; i < sample_count; i++) {\n    \t\tvar sample = {};\n    \t\t// tenc.default_Per_Sample_IV_Size or seig.Per_Sample_IV_Size\n    \t\tsample.InitializationVector = this.readUint8Array(Per_Sample_IV_Size*8);\n    \t\tif (this.flags & 0x2) {\n    \t\t\tsample.subsamples = [];\n    \t\t\tsubsample_count = stream.readUint16();\n    \t\t\tfor (var j = 0; j < subsample_count; j++) {\n    \t\t\t\tvar subsample = {};\n    \t\t\t\tsubsample.BytesOfClearData = stream.readUint16();\n    \t\t\t\tsubsample.BytesOfProtectedData = stream.readUint32();\n    \t\t\t\tsample.subsamples.push(subsample);\n    \t\t\t}\n    \t\t}\n    \t\t// TODO\n    \t\tthis.samples.push(sample);\n    \t}\n    }*/\n  ), n.createFullBoxCtor(\"sgpd\", function(t) {\n    this.grouping_type = t.readString(4), r.debug(\"BoxParser\", \"Found Sample Groups of type \" + this.grouping_type), this.version === 1 ? this.default_length = t.readUint32() : this.default_length = 0, this.version >= 2 && (this.default_group_description_index = t.readUint32()), this.entries = [];\n    for (var e = t.readUint32(), i = 0; i < e; i++) {\n      var s;\n      n[this.grouping_type + \"SampleGroupEntry\"] ? s = new n[this.grouping_type + \"SampleGroupEntry\"](this.grouping_type) : s = new n.SampleGroupEntry(this.grouping_type), this.entries.push(s), this.version === 1 ? this.default_length === 0 ? s.description_length = t.readUint32() : s.description_length = this.default_length : s.description_length = this.default_length, s.write === n.SampleGroupEntry.prototype.write && (r.info(\"BoxParser\", \"SampleGroup for type \" + this.grouping_type + \" writing not yet implemented, keeping unparsed data in memory for later write\"), s.data = t.readUint8Array(s.description_length), t.position -= s.description_length), s.parse(t);\n    }\n  }), n.createFullBoxCtor(\"sidx\", function(t) {\n    this.reference_ID = t.readUint32(), this.timescale = t.readUint32(), this.version === 0 ? (this.earliest_presentation_time = t.readUint32(), this.first_offset = t.readUint32()) : (this.earliest_presentation_time = t.readUint64(), this.first_offset = t.readUint64()), t.readUint16(), this.references = [];\n    for (var e = t.readUint16(), i = 0; i < e; i++) {\n      var s = {};\n      this.references.push(s);\n      var o = t.readUint32();\n      s.reference_type = o >> 31 & 1, s.referenced_size = o & 2147483647, s.subsegment_duration = t.readUint32(), o = t.readUint32(), s.starts_with_SAP = o >> 31 & 1, s.SAP_type = o >> 28 & 7, s.SAP_delta_time = o & 268435455;\n    }\n  }), n.SingleItemTypeReferenceBox = function(t, e, i, s) {\n    n.Box.call(this, t, e), this.hdr_size = i, this.start = s;\n  }, n.SingleItemTypeReferenceBox.prototype = new n.Box(), n.SingleItemTypeReferenceBox.prototype.parse = function(t) {\n    this.from_item_ID = t.readUint16();\n    var e = t.readUint16();\n    this.references = [];\n    for (var i = 0; i < e; i++)\n      this.references[i] = t.readUint16();\n  }, n.SingleItemTypeReferenceBoxLarge = function(t, e, i, s) {\n    n.Box.call(this, t, e), this.hdr_size = i, this.start = s;\n  }, n.SingleItemTypeReferenceBoxLarge.prototype = new n.Box(), n.SingleItemTypeReferenceBoxLarge.prototype.parse = function(t) {\n    this.from_item_ID = t.readUint32();\n    var e = t.readUint16();\n    this.references = [];\n    for (var i = 0; i < e; i++)\n      this.references[i] = t.readUint32();\n  }, n.createFullBoxCtor(\"SmDm\", function(t) {\n    this.primaryRChromaticity_x = t.readUint16(), this.primaryRChromaticity_y = t.readUint16(), this.primaryGChromaticity_x = t.readUint16(), this.primaryGChromaticity_y = t.readUint16(), this.primaryBChromaticity_x = t.readUint16(), this.primaryBChromaticity_y = t.readUint16(), this.whitePointChromaticity_x = t.readUint16(), this.whitePointChromaticity_y = t.readUint16(), this.luminanceMax = t.readUint32(), this.luminanceMin = t.readUint32();\n  }), n.createFullBoxCtor(\"smhd\", function(t) {\n    this.balance = t.readUint16(), t.readUint16();\n  }), n.createFullBoxCtor(\"ssix\", function(t) {\n    this.subsegments = [];\n    for (var e = t.readUint32(), i = 0; i < e; i++) {\n      var s = {};\n      this.subsegments.push(s), s.ranges = [];\n      for (var o = t.readUint32(), c = 0; c < o; c++) {\n        var u = {};\n        s.ranges.push(u), u.level = t.readUint8(), u.range_size = t.readUint24();\n      }\n    }\n  }), n.createFullBoxCtor(\"stco\", function(t) {\n    var e;\n    if (e = t.readUint32(), this.chunk_offsets = [], this.version === 0)\n      for (var i = 0; i < e; i++)\n        this.chunk_offsets.push(t.readUint32());\n  }), n.createFullBoxCtor(\"stdp\", function(t) {\n    var e = (this.size - this.hdr_size) / 2;\n    this.priority = [];\n    for (var i = 0; i < e; i++)\n      this.priority[i] = t.readUint16();\n  }), n.createFullBoxCtor(\"sthd\"), n.createFullBoxCtor(\"stri\", function(t) {\n    this.switch_group = t.readUint16(), this.alternate_group = t.readUint16(), this.sub_track_id = t.readUint32();\n    var e = (this.size - this.hdr_size - 8) / 4;\n    this.attribute_list = [];\n    for (var i = 0; i < e; i++)\n      this.attribute_list[i] = t.readUint32();\n  }), n.createFullBoxCtor(\"stsc\", function(t) {\n    var e, i;\n    if (e = t.readUint32(), this.first_chunk = [], this.samples_per_chunk = [], this.sample_description_index = [], this.version === 0)\n      for (i = 0; i < e; i++)\n        this.first_chunk.push(t.readUint32()), this.samples_per_chunk.push(t.readUint32()), this.sample_description_index.push(t.readUint32());\n  }), n.createFullBoxCtor(\"stsd\", function(t) {\n    var e, i, s, o;\n    for (this.entries = [], s = t.readUint32(), e = 1; e <= s; e++)\n      if (i = n.parseOneBox(t, !0, this.size - (t.getPosition() - this.start)), i.code === n.OK)\n        n[i.type + \"SampleEntry\"] ? (o = new n[i.type + \"SampleEntry\"](i.size), o.hdr_size = i.hdr_size, o.start = i.start) : (r.warn(\"BoxParser\", \"Unknown sample entry type: \" + i.type), o = new n.SampleEntry(i.type, i.size, i.hdr_size, i.start)), o.write === n.SampleEntry.prototype.write && (r.info(\"BoxParser\", \"SampleEntry \" + o.type + \" box writing not yet implemented, keeping unparsed data in memory for later write\"), o.parseDataAndRewind(t)), o.parse(t), this.entries.push(o);\n      else\n        return;\n  }), n.createFullBoxCtor(\"stsg\", function(t) {\n    this.grouping_type = t.readUint32();\n    var e = t.readUint16();\n    this.group_description_index = [];\n    for (var i = 0; i < e; i++)\n      this.group_description_index[i] = t.readUint32();\n  }), n.createFullBoxCtor(\"stsh\", function(t) {\n    var e, i;\n    if (e = t.readUint32(), this.shadowed_sample_numbers = [], this.sync_sample_numbers = [], this.version === 0)\n      for (i = 0; i < e; i++)\n        this.shadowed_sample_numbers.push(t.readUint32()), this.sync_sample_numbers.push(t.readUint32());\n  }), n.createFullBoxCtor(\"stss\", function(t) {\n    var e, i;\n    if (i = t.readUint32(), this.version === 0)\n      for (this.sample_numbers = [], e = 0; e < i; e++)\n        this.sample_numbers.push(t.readUint32());\n  }), n.createFullBoxCtor(\"stsz\", function(t) {\n    var e;\n    if (this.sample_sizes = [], this.version === 0)\n      for (this.sample_size = t.readUint32(), this.sample_count = t.readUint32(), e = 0; e < this.sample_count; e++)\n        this.sample_size === 0 ? this.sample_sizes.push(t.readUint32()) : this.sample_sizes[e] = this.sample_size;\n  }), n.createFullBoxCtor(\"stts\", function(t) {\n    var e, i, s;\n    if (e = t.readUint32(), this.sample_counts = [], this.sample_deltas = [], this.version === 0)\n      for (i = 0; i < e; i++)\n        this.sample_counts.push(t.readUint32()), s = t.readInt32(), s < 0 && (r.warn(\"BoxParser\", \"File uses negative stts sample delta, using value 1 instead, sync may be lost!\"), s = 1), this.sample_deltas.push(s);\n  }), n.createFullBoxCtor(\"stvi\", function(t) {\n    var e = t.readUint32();\n    this.single_view_allowed = e & 3, this.stereo_scheme = t.readUint32();\n    var i = t.readUint32();\n    this.stereo_indication_type = t.readString(i);\n    var s, o;\n    for (this.boxes = []; t.getPosition() < this.start + this.size; )\n      if (s = n.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), s.code === n.OK)\n        o = s.box, this.boxes.push(o), this[o.type] = o;\n      else\n        return;\n  }), n.createBoxCtor(\"styp\", function(t) {\n    n.ftypBox.prototype.parse.call(this, t);\n  }), n.createFullBoxCtor(\"stz2\", function(t) {\n    var e, i;\n    if (this.sample_sizes = [], this.version === 0)\n      if (this.reserved = t.readUint24(), this.field_size = t.readUint8(), i = t.readUint32(), this.field_size === 4)\n        for (e = 0; e < i; e += 2) {\n          var s = t.readUint8();\n          this.sample_sizes[e] = s >> 4 & 15, this.sample_sizes[e + 1] = s & 15;\n        }\n      else if (this.field_size === 8)\n        for (e = 0; e < i; e++)\n          this.sample_sizes[e] = t.readUint8();\n      else if (this.field_size === 16)\n        for (e = 0; e < i; e++)\n          this.sample_sizes[e] = t.readUint16();\n      else\n        r.error(\"BoxParser\", \"Error in length field in stz2 box\");\n  }), n.createFullBoxCtor(\"subs\", function(t) {\n    var e, i, s, o;\n    for (s = t.readUint32(), this.entries = [], e = 0; e < s; e++) {\n      var c = {};\n      if (this.entries[e] = c, c.sample_delta = t.readUint32(), c.subsamples = [], o = t.readUint16(), o > 0)\n        for (i = 0; i < o; i++) {\n          var u = {};\n          c.subsamples.push(u), this.version == 1 ? u.size = t.readUint32() : u.size = t.readUint16(), u.priority = t.readUint8(), u.discardable = t.readUint8(), u.codec_specific_parameters = t.readUint32();\n        }\n    }\n  }), n.createFullBoxCtor(\"tenc\", function(t) {\n    if (t.readUint8(), this.version === 0)\n      t.readUint8();\n    else {\n      var e = t.readUint8();\n      this.default_crypt_byte_block = e >> 4 & 15, this.default_skip_byte_block = e & 15;\n    }\n    this.default_isProtected = t.readUint8(), this.default_Per_Sample_IV_Size = t.readUint8(), this.default_KID = n.parseHex16(t), this.default_isProtected === 1 && this.default_Per_Sample_IV_Size === 0 && (this.default_constant_IV_size = t.readUint8(), this.default_constant_IV = t.readUint8Array(this.default_constant_IV_size));\n  }), n.createFullBoxCtor(\"tfdt\", function(t) {\n    this.version == 1 ? this.baseMediaDecodeTime = t.readUint64() : this.baseMediaDecodeTime = t.readUint32();\n  }), n.createFullBoxCtor(\"tfhd\", function(t) {\n    var e = 0;\n    this.track_id = t.readUint32(), this.size - this.hdr_size > e && this.flags & n.TFHD_FLAG_BASE_DATA_OFFSET ? (this.base_data_offset = t.readUint64(), e += 8) : this.base_data_offset = 0, this.size - this.hdr_size > e && this.flags & n.TFHD_FLAG_SAMPLE_DESC ? (this.default_sample_description_index = t.readUint32(), e += 4) : this.default_sample_description_index = 0, this.size - this.hdr_size > e && this.flags & n.TFHD_FLAG_SAMPLE_DUR ? (this.default_sample_duration = t.readUint32(), e += 4) : this.default_sample_duration = 0, this.size - this.hdr_size > e && this.flags & n.TFHD_FLAG_SAMPLE_SIZE ? (this.default_sample_size = t.readUint32(), e += 4) : this.default_sample_size = 0, this.size - this.hdr_size > e && this.flags & n.TFHD_FLAG_SAMPLE_FLAGS ? (this.default_sample_flags = t.readUint32(), e += 4) : this.default_sample_flags = 0;\n  }), n.createFullBoxCtor(\"tfra\", function(t) {\n    this.track_ID = t.readUint32(), t.readUint24();\n    var e = t.readUint8();\n    this.length_size_of_traf_num = e >> 4 & 3, this.length_size_of_trun_num = e >> 2 & 3, this.length_size_of_sample_num = e & 3, this.entries = [];\n    for (var i = t.readUint32(), s = 0; s < i; s++)\n      this.version === 1 ? (this.time = t.readUint64(), this.moof_offset = t.readUint64()) : (this.time = t.readUint32(), this.moof_offset = t.readUint32()), this.traf_number = t[\"readUint\" + 8 * (this.length_size_of_traf_num + 1)](), this.trun_number = t[\"readUint\" + 8 * (this.length_size_of_trun_num + 1)](), this.sample_number = t[\"readUint\" + 8 * (this.length_size_of_sample_num + 1)]();\n  }), n.createFullBoxCtor(\"tkhd\", function(t) {\n    this.version == 1 ? (this.creation_time = t.readUint64(), this.modification_time = t.readUint64(), this.track_id = t.readUint32(), t.readUint32(), this.duration = t.readUint64()) : (this.creation_time = t.readUint32(), this.modification_time = t.readUint32(), this.track_id = t.readUint32(), t.readUint32(), this.duration = t.readUint32()), t.readUint32Array(2), this.layer = t.readInt16(), this.alternate_group = t.readInt16(), this.volume = t.readInt16() >> 8, t.readUint16(), this.matrix = t.readInt32Array(9), this.width = t.readUint32(), this.height = t.readUint32();\n  }), n.createBoxCtor(\"tmax\", function(t) {\n    this.time = t.readUint32();\n  }), n.createBoxCtor(\"tmin\", function(t) {\n    this.time = t.readUint32();\n  }), n.createBoxCtor(\"totl\", function(t) {\n    this.bytessent = t.readUint32();\n  }), n.createBoxCtor(\"tpay\", function(t) {\n    this.bytessent = t.readUint32();\n  }), n.createBoxCtor(\"tpyl\", function(t) {\n    this.bytessent = t.readUint64();\n  }), n.TrackGroupTypeBox.prototype.parse = function(t) {\n    this.parseFullHeader(t), this.track_group_id = t.readUint32();\n  }, n.createTrackGroupCtor(\"msrc\"), n.TrackReferenceTypeBox = function(t, e, i, s) {\n    n.Box.call(this, t, e), this.hdr_size = i, this.start = s;\n  }, n.TrackReferenceTypeBox.prototype = new n.Box(), n.TrackReferenceTypeBox.prototype.parse = function(t) {\n    this.track_ids = t.readUint32Array((this.size - this.hdr_size) / 4);\n  }, n.trefBox.prototype.parse = function(t) {\n    for (var e, i; t.getPosition() < this.start + this.size; )\n      if (e = n.parseOneBox(t, !0, this.size - (t.getPosition() - this.start)), e.code === n.OK)\n        i = new n.TrackReferenceTypeBox(e.type, e.size, e.hdr_size, e.start), i.write === n.Box.prototype.write && i.type !== \"mdat\" && (r.info(\"BoxParser\", \"TrackReference \" + i.type + \" box writing not yet implemented, keeping unparsed data in memory for later write\"), i.parseDataAndRewind(t)), i.parse(t), this.boxes.push(i);\n      else\n        return;\n  }, n.createFullBoxCtor(\"trep\", function(t) {\n    for (this.track_ID = t.readUint32(), this.boxes = []; t.getPosition() < this.start + this.size; )\n      if (ret = n.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), ret.code === n.OK)\n        box = ret.box, this.boxes.push(box);\n      else\n        return;\n  }), n.createFullBoxCtor(\"trex\", function(t) {\n    this.track_id = t.readUint32(), this.default_sample_description_index = t.readUint32(), this.default_sample_duration = t.readUint32(), this.default_sample_size = t.readUint32(), this.default_sample_flags = t.readUint32();\n  }), n.createBoxCtor(\"trpy\", function(t) {\n    this.bytessent = t.readUint64();\n  }), n.createFullBoxCtor(\"trun\", function(t) {\n    var e = 0;\n    if (this.sample_count = t.readUint32(), e += 4, this.size - this.hdr_size > e && this.flags & n.TRUN_FLAGS_DATA_OFFSET ? (this.data_offset = t.readInt32(), e += 4) : this.data_offset = 0, this.size - this.hdr_size > e && this.flags & n.TRUN_FLAGS_FIRST_FLAG ? (this.first_sample_flags = t.readUint32(), e += 4) : this.first_sample_flags = 0, this.sample_duration = [], this.sample_size = [], this.sample_flags = [], this.sample_composition_time_offset = [], this.size - this.hdr_size > e)\n      for (var i = 0; i < this.sample_count; i++)\n        this.flags & n.TRUN_FLAGS_DURATION && (this.sample_duration[i] = t.readUint32()), this.flags & n.TRUN_FLAGS_SIZE && (this.sample_size[i] = t.readUint32()), this.flags & n.TRUN_FLAGS_FLAGS && (this.sample_flags[i] = t.readUint32()), this.flags & n.TRUN_FLAGS_CTS_OFFSET && (this.version === 0 ? this.sample_composition_time_offset[i] = t.readUint32() : this.sample_composition_time_offset[i] = t.readInt32());\n  }), n.createFullBoxCtor(\"tsel\", function(t) {\n    this.switch_group = t.readUint32();\n    var e = (this.size - this.hdr_size - 4) / 4;\n    this.attribute_list = [];\n    for (var i = 0; i < e; i++)\n      this.attribute_list[i] = t.readUint32();\n  }), n.createFullBoxCtor(\"txtC\", function(t) {\n    this.config = t.readCString();\n  }), n.createFullBoxCtor(\"url \", function(t) {\n    this.flags !== 1 && (this.location = t.readCString());\n  }), n.createFullBoxCtor(\"urn \", function(t) {\n    this.name = t.readCString(), this.size - this.hdr_size - this.name.length - 1 > 0 && (this.location = t.readCString());\n  }), n.createUUIDBox(\"a5d40b30e81411ddba2f0800200c9a66\", !0, !1, function(t) {\n    this.LiveServerManifest = t.readString(this.size - this.hdr_size).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n  }), n.createUUIDBox(\"d08a4f1810f34a82b6c832d8aba183d3\", !0, !1, function(t) {\n    this.system_id = n.parseHex16(t);\n    var e = t.readUint32();\n    e > 0 && (this.data = t.readUint8Array(e));\n  }), n.createUUIDBox(\n    \"a2394f525a9b4f14a2446c427c648df4\",\n    !0,\n    !1\n    /*, function(stream) {\n    \tif (this.flags & 0x1) {\n    \t\tthis.AlgorithmID = stream.readUint24();\n    \t\tthis.IV_size = stream.readUint8();\n    \t\tthis.KID = BoxParser.parseHex16(stream);\n    \t}\n    \tvar sample_count = stream.readUint32();\n    \tthis.samples = [];\n    \tfor (var i = 0; i < sample_count; i++) {\n    \t\tvar sample = {};\n    \t\tsample.InitializationVector = this.readUint8Array(this.IV_size*8);\n    \t\tif (this.flags & 0x2) {\n    \t\t\tsample.subsamples = [];\n    \t\t\tsample.NumberOfEntries = stream.readUint16();\n    \t\t\tfor (var j = 0; j < sample.NumberOfEntries; j++) {\n    \t\t\t\tvar subsample = {};\n    \t\t\t\tsubsample.BytesOfClearData = stream.readUint16();\n    \t\t\t\tsubsample.BytesOfProtectedData = stream.readUint32();\n    \t\t\t\tsample.subsamples.push(subsample);\n    \t\t\t}\n    \t\t}\n    \t\tthis.samples.push(sample);\n    \t}\n    }*/\n  ), n.createUUIDBox(\"8974dbce7be74c5184f97148f9882554\", !0, !1, function(t) {\n    this.default_AlgorithmID = t.readUint24(), this.default_IV_size = t.readUint8(), this.default_KID = n.parseHex16(t);\n  }), n.createUUIDBox(\"d4807ef2ca3946958e5426cb9e46a79f\", !0, !1, function(t) {\n    this.fragment_count = t.readUint8(), this.entries = [];\n    for (var e = 0; e < this.fragment_count; e++) {\n      var i = {}, s = 0, o = 0;\n      this.version === 1 ? (s = t.readUint64(), o = t.readUint64()) : (s = t.readUint32(), o = t.readUint32()), i.absolute_time = s, i.absolute_duration = o, this.entries.push(i);\n    }\n  }), n.createUUIDBox(\"6d1d9b0542d544e680e2141daff757b2\", !0, !1, function(t) {\n    this.version === 1 ? (this.absolute_time = t.readUint64(), this.duration = t.readUint64()) : (this.absolute_time = t.readUint32(), this.duration = t.readUint32());\n  }), n.createFullBoxCtor(\"vmhd\", function(t) {\n    this.graphicsmode = t.readUint16(), this.opcolor = t.readUint16Array(3);\n  }), n.createFullBoxCtor(\"vpcC\", function(t) {\n    var e;\n    this.version === 1 ? (this.profile = t.readUint8(), this.level = t.readUint8(), e = t.readUint8(), this.bitDepth = e >> 4, this.chromaSubsampling = e >> 1 & 7, this.videoFullRangeFlag = e & 1, this.colourPrimaries = t.readUint8(), this.transferCharacteristics = t.readUint8(), this.matrixCoefficients = t.readUint8(), this.codecIntializationDataSize = t.readUint16(), this.codecIntializationData = t.readUint8Array(this.codecIntializationDataSize)) : (this.profile = t.readUint8(), this.level = t.readUint8(), e = t.readUint8(), this.bitDepth = e >> 4 & 15, this.colorSpace = e & 15, e = t.readUint8(), this.chromaSubsampling = e >> 4 & 15, this.transferFunction = e >> 1 & 7, this.videoFullRangeFlag = e & 1, this.codecIntializationDataSize = t.readUint16(), this.codecIntializationData = t.readUint8Array(this.codecIntializationDataSize));\n  }), n.createBoxCtor(\"vttC\", function(t) {\n    this.text = t.readString(this.size - this.hdr_size);\n  }), n.createFullBoxCtor(\"vvcC\", function(t) {\n    var e, i, s = {\n      held_bits: void 0,\n      num_held_bits: 0,\n      stream_read_1_bytes: function(x) {\n        this.held_bits = x.readUint8(), this.num_held_bits = 8;\n      },\n      stream_read_2_bytes: function(x) {\n        this.held_bits = x.readUint16(), this.num_held_bits = 16;\n      },\n      extract_bits: function(x) {\n        var P = this.held_bits >> this.num_held_bits - x & (1 << x) - 1;\n        return this.num_held_bits -= x, P;\n      }\n    };\n    if (s.stream_read_1_bytes(t), s.extract_bits(5), this.lengthSizeMinusOne = s.extract_bits(2), this.ptl_present_flag = s.extract_bits(1), this.ptl_present_flag) {\n      s.stream_read_2_bytes(t), this.ols_idx = s.extract_bits(9), this.num_sublayers = s.extract_bits(3), this.constant_frame_rate = s.extract_bits(2), this.chroma_format_idc = s.extract_bits(2), s.stream_read_1_bytes(t), this.bit_depth_minus8 = s.extract_bits(3), s.extract_bits(5);\n      {\n        if (s.stream_read_2_bytes(t), s.extract_bits(2), this.num_bytes_constraint_info = s.extract_bits(6), this.general_profile_idc = s.extract_bits(7), this.general_tier_flag = s.extract_bits(1), this.general_level_idc = t.readUint8(), s.stream_read_1_bytes(t), this.ptl_frame_only_constraint_flag = s.extract_bits(1), this.ptl_multilayer_enabled_flag = s.extract_bits(1), this.general_constraint_info = new Uint8Array(this.num_bytes_constraint_info), this.num_bytes_constraint_info) {\n          for (e = 0; e < this.num_bytes_constraint_info - 1; e++) {\n            var o = s.extract_bits(6);\n            s.stream_read_1_bytes(t);\n            var c = s.extract_bits(2);\n            this.general_constraint_info[e] = o << 2 | c;\n          }\n          this.general_constraint_info[this.num_bytes_constraint_info - 1] = s.extract_bits(6);\n        } else\n          s.extract_bits(6);\n        for (s.stream_read_1_bytes(t), this.ptl_sublayer_present_mask = 0, i = this.num_sublayers - 2; i >= 0; --i) {\n          var u = s.extract_bits(1);\n          this.ptl_sublayer_present_mask |= u << i;\n        }\n        for (i = this.num_sublayers; i <= 8 && this.num_sublayers > 1; ++i)\n          s.extract_bits(1);\n        for (i = this.num_sublayers - 2; i >= 0; --i)\n          this.ptl_sublayer_present_mask & 1 << i && (this.sublayer_level_idc[i] = t.readUint8());\n        if (this.ptl_num_sub_profiles = t.readUint8(), this.general_sub_profile_idc = [], this.ptl_num_sub_profiles)\n          for (e = 0; e < this.ptl_num_sub_profiles; e++)\n            this.general_sub_profile_idc.push(t.readUint32());\n      }\n      this.max_picture_width = t.readUint16(), this.max_picture_height = t.readUint16(), this.avg_frame_rate = t.readUint16();\n    }\n    var _ = 12, g = 13;\n    this.nalu_arrays = [];\n    var w = t.readUint8();\n    for (e = 0; e < w; e++) {\n      var S = [];\n      this.nalu_arrays.push(S), s.stream_read_1_bytes(t), S.completeness = s.extract_bits(1), s.extract_bits(2), S.nalu_type = s.extract_bits(5);\n      var U = 1;\n      for (S.nalu_type != g && S.nalu_type != _ && (U = t.readUint16()), i = 0; i < U; i++) {\n        var C = t.readUint16();\n        S.push({\n          data: t.readUint8Array(C),\n          length: C\n        });\n      }\n    }\n  }), n.createFullBoxCtor(\"vvnC\", function(t) {\n    var e = strm.readUint8();\n    this.lengthSizeMinusOne = e & 3;\n  }), n.SampleEntry.prototype.isVideo = function() {\n    return !1;\n  }, n.SampleEntry.prototype.isAudio = function() {\n    return !1;\n  }, n.SampleEntry.prototype.isSubtitle = function() {\n    return !1;\n  }, n.SampleEntry.prototype.isMetadata = function() {\n    return !1;\n  }, n.SampleEntry.prototype.isHint = function() {\n    return !1;\n  }, n.SampleEntry.prototype.getCodec = function() {\n    return this.type.replace(\".\", \"\");\n  }, n.SampleEntry.prototype.getWidth = function() {\n    return \"\";\n  }, n.SampleEntry.prototype.getHeight = function() {\n    return \"\";\n  }, n.SampleEntry.prototype.getChannelCount = function() {\n    return \"\";\n  }, n.SampleEntry.prototype.getSampleRate = function() {\n    return \"\";\n  }, n.SampleEntry.prototype.getSampleSize = function() {\n    return \"\";\n  }, n.VisualSampleEntry.prototype.isVideo = function() {\n    return !0;\n  }, n.VisualSampleEntry.prototype.getWidth = function() {\n    return this.width;\n  }, n.VisualSampleEntry.prototype.getHeight = function() {\n    return this.height;\n  }, n.AudioSampleEntry.prototype.isAudio = function() {\n    return !0;\n  }, n.AudioSampleEntry.prototype.getChannelCount = function() {\n    return this.channel_count;\n  }, n.AudioSampleEntry.prototype.getSampleRate = function() {\n    return this.samplerate;\n  }, n.AudioSampleEntry.prototype.getSampleSize = function() {\n    return this.samplesize;\n  }, n.SubtitleSampleEntry.prototype.isSubtitle = function() {\n    return !0;\n  }, n.MetadataSampleEntry.prototype.isMetadata = function() {\n    return !0;\n  }, n.decimalToHex = function(t, e) {\n    var i = Number(t).toString(16);\n    for (e = typeof e > \"u\" || e === null ? e = 2 : e; i.length < e; )\n      i = \"0\" + i;\n    return i;\n  }, n.avc1SampleEntry.prototype.getCodec = n.avc2SampleEntry.prototype.getCodec = n.avc3SampleEntry.prototype.getCodec = n.avc4SampleEntry.prototype.getCodec = function() {\n    var t = n.SampleEntry.prototype.getCodec.call(this);\n    return this.avcC ? t + \".\" + n.decimalToHex(this.avcC.AVCProfileIndication) + n.decimalToHex(this.avcC.profile_compatibility) + n.decimalToHex(this.avcC.AVCLevelIndication) : t;\n  }, n.hev1SampleEntry.prototype.getCodec = n.hvc1SampleEntry.prototype.getCodec = function() {\n    var t, e = n.SampleEntry.prototype.getCodec.call(this);\n    if (this.hvcC) {\n      switch (e += \".\", this.hvcC.general_profile_space) {\n        case 0:\n          e += \"\";\n          break;\n        case 1:\n          e += \"A\";\n          break;\n        case 2:\n          e += \"B\";\n          break;\n        case 3:\n          e += \"C\";\n          break;\n      }\n      e += this.hvcC.general_profile_idc, e += \".\";\n      var i = this.hvcC.general_profile_compatibility, s = 0;\n      for (t = 0; t < 32 && (s |= i & 1, t != 31); t++)\n        s <<= 1, i >>= 1;\n      e += n.decimalToHex(s, 0), e += \".\", this.hvcC.general_tier_flag === 0 ? e += \"L\" : e += \"H\", e += this.hvcC.general_level_idc;\n      var o = !1, c = \"\";\n      for (t = 5; t >= 0; t--)\n        (this.hvcC.general_constraint_indicator[t] || o) && (c = \".\" + n.decimalToHex(this.hvcC.general_constraint_indicator[t], 0) + c, o = !0);\n      e += c;\n    }\n    return e;\n  }, n.vvc1SampleEntry.prototype.getCodec = n.vvi1SampleEntry.prototype.getCodec = function() {\n    var t, e = n.SampleEntry.prototype.getCodec.call(this);\n    if (this.vvcC) {\n      e += \".\" + this.vvcC.general_profile_idc, this.vvcC.general_tier_flag ? e += \".H\" : e += \".L\", e += this.vvcC.general_level_idc;\n      var i = \"\";\n      if (this.vvcC.general_constraint_info) {\n        var s = [], o = 0;\n        o |= this.vvcC.ptl_frame_only_constraint << 7, o |= this.vvcC.ptl_multilayer_enabled << 6;\n        var c;\n        for (t = 0; t < this.vvcC.general_constraint_info.length; ++t)\n          o |= this.vvcC.general_constraint_info[t] >> 2 & 63, s.push(o), o && (c = t), o = this.vvcC.general_constraint_info[t] >> 2 & 3;\n        if (c === void 0)\n          i = \".CA\";\n        else {\n          i = \".C\";\n          var u = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\", _ = 0, g = 0;\n          for (t = 0; t <= c; ++t)\n            for (_ = _ << 8 | s[t], g += 8; g >= 5; ) {\n              var w = _ >> g - 5 & 31;\n              i += u[w], g -= 5, _ &= (1 << g) - 1;\n            }\n          g && (_ <<= 5 - g, i += u[_ & 31]);\n        }\n      }\n      e += i;\n    }\n    return e;\n  }, n.mp4aSampleEntry.prototype.getCodec = function() {\n    var t = n.SampleEntry.prototype.getCodec.call(this);\n    if (this.esds && this.esds.esd) {\n      var e = this.esds.esd.getOTI(), i = this.esds.esd.getAudioConfig();\n      return t + \".\" + n.decimalToHex(e) + (i ? \".\" + i : \"\");\n    } else\n      return t;\n  }, n.stxtSampleEntry.prototype.getCodec = function() {\n    var t = n.SampleEntry.prototype.getCodec.call(this);\n    return this.mime_format ? t + \".\" + this.mime_format : t;\n  }, n.vp08SampleEntry.prototype.getCodec = n.vp09SampleEntry.prototype.getCodec = function() {\n    var t = n.SampleEntry.prototype.getCodec.call(this), e = this.vpcC.level;\n    e == 0 && (e = \"00\");\n    var i = this.vpcC.bitDepth;\n    return i == 8 && (i = \"08\"), t + \".0\" + this.vpcC.profile + \".\" + e + \".\" + i;\n  }, n.av01SampleEntry.prototype.getCodec = function() {\n    var t = n.SampleEntry.prototype.getCodec.call(this), e = this.av1C.seq_level_idx_0;\n    e < 10 && (e = \"0\" + e);\n    var i;\n    return this.av1C.seq_profile === 2 && this.av1C.high_bitdepth === 1 ? i = this.av1C.twelve_bit === 1 ? \"12\" : \"10\" : this.av1C.seq_profile <= 2 && (i = this.av1C.high_bitdepth === 1 ? \"10\" : \"08\"), t + \".\" + this.av1C.seq_profile + \".\" + e + (this.av1C.seq_tier_0 ? \"H\" : \"M\") + \".\" + i;\n  }, n.Box.prototype.writeHeader = function(t, e) {\n    this.size += 8, this.size > f && (this.size += 8), this.type === \"uuid\" && (this.size += 16), r.debug(\"BoxWriter\", \"Writing box \" + this.type + \" of size: \" + this.size + \" at position \" + t.getPosition() + (e || \"\")), this.size > f ? t.writeUint32(1) : (this.sizePosition = t.getPosition(), t.writeUint32(this.size)), t.writeString(this.type, null, 4), this.type === \"uuid\" && t.writeUint8Array(this.uuid), this.size > f && t.writeUint64(this.size);\n  }, n.FullBox.prototype.writeHeader = function(t) {\n    this.size += 4, n.Box.prototype.writeHeader.call(this, t, \" v=\" + this.version + \" f=\" + this.flags), t.writeUint8(this.version), t.writeUint24(this.flags);\n  }, n.Box.prototype.write = function(t) {\n    this.type === \"mdat\" ? this.data && (this.size = this.data.length, this.writeHeader(t), t.writeUint8Array(this.data)) : (this.size = this.data ? this.data.length : 0, this.writeHeader(t), this.data && t.writeUint8Array(this.data));\n  }, n.ContainerBox.prototype.write = function(t) {\n    this.size = 0, this.writeHeader(t);\n    for (var e = 0; e < this.boxes.length; e++)\n      this.boxes[e] && (this.boxes[e].write(t), this.size += this.boxes[e].size);\n    r.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size), t.adjustUint32(this.sizePosition, this.size);\n  }, n.TrackReferenceTypeBox.prototype.write = function(t) {\n    this.size = this.track_ids.length * 4, this.writeHeader(t), t.writeUint32Array(this.track_ids);\n  }, n.avcCBox.prototype.write = function(t) {\n    var e;\n    for (this.size = 7, e = 0; e < this.SPS.length; e++)\n      this.size += 2 + this.SPS[e].length;\n    for (e = 0; e < this.PPS.length; e++)\n      this.size += 2 + this.PPS[e].length;\n    for (this.ext && (this.size += this.ext.length), this.writeHeader(t), t.writeUint8(this.configurationVersion), t.writeUint8(this.AVCProfileIndication), t.writeUint8(this.profile_compatibility), t.writeUint8(this.AVCLevelIndication), t.writeUint8(this.lengthSizeMinusOne + 252), t.writeUint8(this.SPS.length + 224), e = 0; e < this.SPS.length; e++)\n      t.writeUint16(this.SPS[e].length), t.writeUint8Array(this.SPS[e].nalu);\n    for (t.writeUint8(this.PPS.length), e = 0; e < this.PPS.length; e++)\n      t.writeUint16(this.PPS[e].length), t.writeUint8Array(this.PPS[e].nalu);\n    this.ext && t.writeUint8Array(this.ext);\n  }, n.co64Box.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.chunk_offsets.length, this.writeHeader(t), t.writeUint32(this.chunk_offsets.length), e = 0; e < this.chunk_offsets.length; e++)\n      t.writeUint64(this.chunk_offsets[e]);\n  }, n.cslgBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 * 5, this.writeHeader(t), t.writeInt32(this.compositionToDTSShift), t.writeInt32(this.leastDecodeToDisplayDelta), t.writeInt32(this.greatestDecodeToDisplayDelta), t.writeInt32(this.compositionStartTime), t.writeInt32(this.compositionEndTime);\n  }, n.cttsBox.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(t), t.writeUint32(this.sample_counts.length), e = 0; e < this.sample_counts.length; e++)\n      t.writeUint32(this.sample_counts[e]), this.version === 1 ? t.writeInt32(this.sample_offsets[e]) : t.writeUint32(this.sample_offsets[e]);\n  }, n.drefBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(t), t.writeUint32(this.entries.length);\n    for (var e = 0; e < this.entries.length; e++)\n      this.entries[e].write(t), this.size += this.entries[e].size;\n    r.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size), t.adjustUint32(this.sizePosition, this.size);\n  }, n.elngBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = this.extended_language.length, this.writeHeader(t), t.writeString(this.extended_language);\n  }, n.elstBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 + 12 * this.entries.length, this.writeHeader(t), t.writeUint32(this.entries.length);\n    for (var e = 0; e < this.entries.length; e++) {\n      var i = this.entries[e];\n      t.writeUint32(i.segment_duration), t.writeInt32(i.media_time), t.writeInt16(i.media_rate_integer), t.writeInt16(i.media_rate_fraction);\n    }\n  }, n.emsgBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 * 4 + this.message_data.length + (this.scheme_id_uri.length + 1) + (this.value.length + 1), this.writeHeader(t), t.writeCString(this.scheme_id_uri), t.writeCString(this.value), t.writeUint32(this.timescale), t.writeUint32(this.presentation_time_delta), t.writeUint32(this.event_duration), t.writeUint32(this.id), t.writeUint8Array(this.message_data);\n  }, n.ftypBox.prototype.write = function(t) {\n    this.size = 8 + 4 * this.compatible_brands.length, this.writeHeader(t), t.writeString(this.major_brand, null, 4), t.writeUint32(this.minor_version);\n    for (var e = 0; e < this.compatible_brands.length; e++)\n      t.writeString(this.compatible_brands[e], null, 4);\n  }, n.hdlrBox.prototype.write = function(t) {\n    this.size = 5 * 4 + this.name.length + 1, this.version = 0, this.flags = 0, this.writeHeader(t), t.writeUint32(0), t.writeString(this.handler, null, 4), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeCString(this.name);\n  }, n.kindBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = this.schemeURI.length + 1 + (this.value.length + 1), this.writeHeader(t), t.writeCString(this.schemeURI), t.writeCString(this.value);\n  }, n.mdhdBox.prototype.write = function(t) {\n    this.size = 4 * 4 + 2 * 2, this.flags = 0, this.version = 0, this.writeHeader(t), t.writeUint32(this.creation_time), t.writeUint32(this.modification_time), t.writeUint32(this.timescale), t.writeUint32(this.duration), t.writeUint16(this.language), t.writeUint16(0);\n  }, n.mehdBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(t), t.writeUint32(this.fragment_duration);\n  }, n.mfhdBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(t), t.writeUint32(this.sequence_number);\n  }, n.mvhdBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 23 * 4 + 2 * 2, this.writeHeader(t), t.writeUint32(this.creation_time), t.writeUint32(this.modification_time), t.writeUint32(this.timescale), t.writeUint32(this.duration), t.writeUint32(this.rate), t.writeUint16(this.volume << 8), t.writeUint16(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32Array(this.matrix), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(this.next_track_id);\n  }, n.SampleEntry.prototype.writeHeader = function(t) {\n    this.size = 8, n.Box.prototype.writeHeader.call(this, t), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint16(this.data_reference_index);\n  }, n.SampleEntry.prototype.writeFooter = function(t) {\n    for (var e = 0; e < this.boxes.length; e++)\n      this.boxes[e].write(t), this.size += this.boxes[e].size;\n    r.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size), t.adjustUint32(this.sizePosition, this.size);\n  }, n.SampleEntry.prototype.write = function(t) {\n    this.writeHeader(t), t.writeUint8Array(this.data), this.size += this.data.length, r.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size), t.adjustUint32(this.sizePosition, this.size);\n  }, n.VisualSampleEntry.prototype.write = function(t) {\n    this.writeHeader(t), this.size += 2 * 7 + 6 * 4 + 32, t.writeUint16(0), t.writeUint16(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint16(this.width), t.writeUint16(this.height), t.writeUint32(this.horizresolution), t.writeUint32(this.vertresolution), t.writeUint32(0), t.writeUint16(this.frame_count), t.writeUint8(Math.min(31, this.compressorname.length)), t.writeString(this.compressorname, null, 31), t.writeUint16(this.depth), t.writeInt16(-1), this.writeFooter(t);\n  }, n.AudioSampleEntry.prototype.write = function(t) {\n    this.writeHeader(t), this.size += 2 * 4 + 3 * 4, t.writeUint32(0), t.writeUint32(0), t.writeUint16(this.channel_count), t.writeUint16(this.samplesize), t.writeUint16(0), t.writeUint16(0), t.writeUint32(this.samplerate << 16), this.writeFooter(t);\n  }, n.stppSampleEntry.prototype.write = function(t) {\n    this.writeHeader(t), this.size += this.namespace.length + 1 + this.schema_location.length + 1 + this.auxiliary_mime_types.length + 1, t.writeCString(this.namespace), t.writeCString(this.schema_location), t.writeCString(this.auxiliary_mime_types), this.writeFooter(t);\n  }, n.SampleGroupEntry.prototype.write = function(t) {\n    t.writeUint8Array(this.data);\n  }, n.sbgpBox.prototype.write = function(t) {\n    this.version = 1, this.flags = 0, this.size = 12 + 8 * this.entries.length, this.writeHeader(t), t.writeString(this.grouping_type, null, 4), t.writeUint32(this.grouping_type_parameter), t.writeUint32(this.entries.length);\n    for (var e = 0; e < this.entries.length; e++) {\n      var i = this.entries[e];\n      t.writeInt32(i.sample_count), t.writeInt32(i.group_description_index);\n    }\n  }, n.sgpdBox.prototype.write = function(t) {\n    var e, i;\n    for (this.flags = 0, this.size = 12, e = 0; e < this.entries.length; e++)\n      i = this.entries[e], this.version === 1 && (this.default_length === 0 && (this.size += 4), this.size += i.data.length);\n    for (this.writeHeader(t), t.writeString(this.grouping_type, null, 4), this.version === 1 && t.writeUint32(this.default_length), this.version >= 2 && t.writeUint32(this.default_sample_description_index), t.writeUint32(this.entries.length), e = 0; e < this.entries.length; e++)\n      i = this.entries[e], this.version === 1 && this.default_length === 0 && t.writeUint32(i.description_length), i.write(t);\n  }, n.sidxBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 * 4 + 2 + 2 + 12 * this.references.length, this.writeHeader(t), t.writeUint32(this.reference_ID), t.writeUint32(this.timescale), t.writeUint32(this.earliest_presentation_time), t.writeUint32(this.first_offset), t.writeUint16(0), t.writeUint16(this.references.length);\n    for (var e = 0; e < this.references.length; e++) {\n      var i = this.references[e];\n      t.writeUint32(i.reference_type << 31 | i.referenced_size), t.writeUint32(i.subsegment_duration), t.writeUint32(i.starts_with_SAP << 31 | i.SAP_type << 28 | i.SAP_delta_time);\n    }\n  }, n.smhdBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 1, this.size = 4, this.writeHeader(t), t.writeUint16(this.balance), t.writeUint16(0);\n  }, n.stcoBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 + 4 * this.chunk_offsets.length, this.writeHeader(t), t.writeUint32(this.chunk_offsets.length), t.writeUint32Array(this.chunk_offsets);\n  }, n.stscBox.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 4 + 12 * this.first_chunk.length, this.writeHeader(t), t.writeUint32(this.first_chunk.length), e = 0; e < this.first_chunk.length; e++)\n      t.writeUint32(this.first_chunk[e]), t.writeUint32(this.samples_per_chunk[e]), t.writeUint32(this.sample_description_index[e]);\n  }, n.stsdBox.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 0, this.writeHeader(t), t.writeUint32(this.entries.length), this.size += 4, e = 0; e < this.entries.length; e++)\n      this.entries[e].write(t), this.size += this.entries[e].size;\n    r.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size), t.adjustUint32(this.sizePosition, this.size);\n  }, n.stshBox.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.shadowed_sample_numbers.length, this.writeHeader(t), t.writeUint32(this.shadowed_sample_numbers.length), e = 0; e < this.shadowed_sample_numbers.length; e++)\n      t.writeUint32(this.shadowed_sample_numbers[e]), t.writeUint32(this.sync_sample_numbers[e]);\n  }, n.stssBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 + 4 * this.sample_numbers.length, this.writeHeader(t), t.writeUint32(this.sample_numbers.length), t.writeUint32Array(this.sample_numbers);\n  }, n.stszBox.prototype.write = function(t) {\n    var e, i = !0;\n    if (this.version = 0, this.flags = 0, this.sample_sizes.length > 0)\n      for (e = 0; e + 1 < this.sample_sizes.length; )\n        if (this.sample_sizes[e + 1] !== this.sample_sizes[0]) {\n          i = !1;\n          break;\n        } else\n          e++;\n    else\n      i = !1;\n    this.size = 8, i || (this.size += 4 * this.sample_sizes.length), this.writeHeader(t), i ? t.writeUint32(this.sample_sizes[0]) : t.writeUint32(0), t.writeUint32(this.sample_sizes.length), i || t.writeUint32Array(this.sample_sizes);\n  }, n.sttsBox.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(t), t.writeUint32(this.sample_counts.length), e = 0; e < this.sample_counts.length; e++)\n      t.writeUint32(this.sample_counts[e]), t.writeUint32(this.sample_deltas[e]);\n  }, n.tfdtBox.prototype.write = function(t) {\n    var e = Math.pow(2, 32) - 1;\n    this.version = this.baseMediaDecodeTime > e ? 1 : 0, this.flags = 0, this.size = 4, this.version === 1 && (this.size += 4), this.writeHeader(t), this.version === 1 ? t.writeUint64(this.baseMediaDecodeTime) : t.writeUint32(this.baseMediaDecodeTime);\n  }, n.tfhdBox.prototype.write = function(t) {\n    this.version = 0, this.size = 4, this.flags & n.TFHD_FLAG_BASE_DATA_OFFSET && (this.size += 8), this.flags & n.TFHD_FLAG_SAMPLE_DESC && (this.size += 4), this.flags & n.TFHD_FLAG_SAMPLE_DUR && (this.size += 4), this.flags & n.TFHD_FLAG_SAMPLE_SIZE && (this.size += 4), this.flags & n.TFHD_FLAG_SAMPLE_FLAGS && (this.size += 4), this.writeHeader(t), t.writeUint32(this.track_id), this.flags & n.TFHD_FLAG_BASE_DATA_OFFSET && t.writeUint64(this.base_data_offset), this.flags & n.TFHD_FLAG_SAMPLE_DESC && t.writeUint32(this.default_sample_description_index), this.flags & n.TFHD_FLAG_SAMPLE_DUR && t.writeUint32(this.default_sample_duration), this.flags & n.TFHD_FLAG_SAMPLE_SIZE && t.writeUint32(this.default_sample_size), this.flags & n.TFHD_FLAG_SAMPLE_FLAGS && t.writeUint32(this.default_sample_flags);\n  }, n.tkhdBox.prototype.write = function(t) {\n    this.version = 0, this.size = 4 * 18 + 2 * 4, this.writeHeader(t), t.writeUint32(this.creation_time), t.writeUint32(this.modification_time), t.writeUint32(this.track_id), t.writeUint32(0), t.writeUint32(this.duration), t.writeUint32(0), t.writeUint32(0), t.writeInt16(this.layer), t.writeInt16(this.alternate_group), t.writeInt16(this.volume << 8), t.writeUint16(0), t.writeInt32Array(this.matrix), t.writeUint32(this.width), t.writeUint32(this.height);\n  }, n.trexBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 * 5, this.writeHeader(t), t.writeUint32(this.track_id), t.writeUint32(this.default_sample_description_index), t.writeUint32(this.default_sample_duration), t.writeUint32(this.default_sample_size), t.writeUint32(this.default_sample_flags);\n  }, n.trunBox.prototype.write = function(t) {\n    this.version = 0, this.size = 4, this.flags & n.TRUN_FLAGS_DATA_OFFSET && (this.size += 4), this.flags & n.TRUN_FLAGS_FIRST_FLAG && (this.size += 4), this.flags & n.TRUN_FLAGS_DURATION && (this.size += 4 * this.sample_duration.length), this.flags & n.TRUN_FLAGS_SIZE && (this.size += 4 * this.sample_size.length), this.flags & n.TRUN_FLAGS_FLAGS && (this.size += 4 * this.sample_flags.length), this.flags & n.TRUN_FLAGS_CTS_OFFSET && (this.size += 4 * this.sample_composition_time_offset.length), this.writeHeader(t), t.writeUint32(this.sample_count), this.flags & n.TRUN_FLAGS_DATA_OFFSET && (this.data_offset_position = t.getPosition(), t.writeInt32(this.data_offset)), this.flags & n.TRUN_FLAGS_FIRST_FLAG && t.writeUint32(this.first_sample_flags);\n    for (var e = 0; e < this.sample_count; e++)\n      this.flags & n.TRUN_FLAGS_DURATION && t.writeUint32(this.sample_duration[e]), this.flags & n.TRUN_FLAGS_SIZE && t.writeUint32(this.sample_size[e]), this.flags & n.TRUN_FLAGS_FLAGS && t.writeUint32(this.sample_flags[e]), this.flags & n.TRUN_FLAGS_CTS_OFFSET && (this.version === 0 ? t.writeUint32(this.sample_composition_time_offset[e]) : t.writeInt32(this.sample_composition_time_offset[e]));\n  }, n[\"url Box\"].prototype.write = function(t) {\n    this.version = 0, this.location ? (this.flags = 0, this.size = this.location.length + 1) : (this.flags = 1, this.size = 0), this.writeHeader(t), this.location && t.writeCString(this.location);\n  }, n[\"urn Box\"].prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = this.name.length + 1 + (this.location ? this.location.length + 1 : 0), this.writeHeader(t), t.writeCString(this.name), this.location && t.writeCString(this.location);\n  }, n.vmhdBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 1, this.size = 8, this.writeHeader(t), t.writeUint16(this.graphicsmode), t.writeUint16Array(this.opcolor);\n  }, n.cttsBox.prototype.unpack = function(t) {\n    var e, i, s;\n    for (s = 0, e = 0; e < this.sample_counts.length; e++)\n      for (i = 0; i < this.sample_counts[e]; i++)\n        t[s].pts = t[s].dts + this.sample_offsets[e], s++;\n  }, n.sttsBox.prototype.unpack = function(t) {\n    var e, i, s;\n    for (s = 0, e = 0; e < this.sample_counts.length; e++)\n      for (i = 0; i < this.sample_counts[e]; i++)\n        s === 0 ? t[s].dts = 0 : t[s].dts = t[s - 1].dts + this.sample_deltas[e], s++;\n  }, n.stcoBox.prototype.unpack = function(t) {\n    var e;\n    for (e = 0; e < this.chunk_offsets.length; e++)\n      t[e].offset = this.chunk_offsets[e];\n  }, n.stscBox.prototype.unpack = function(t) {\n    var e, i, s, o, c;\n    for (o = 0, c = 0, e = 0; e < this.first_chunk.length; e++)\n      for (i = 0; i < (e + 1 < this.first_chunk.length ? this.first_chunk[e + 1] : 1 / 0); i++)\n        for (c++, s = 0; s < this.samples_per_chunk[e]; s++) {\n          if (t[o])\n            t[o].description_index = this.sample_description_index[e], t[o].chunk_index = c;\n          else\n            return;\n          o++;\n        }\n  }, n.stszBox.prototype.unpack = function(t) {\n    var e;\n    for (e = 0; e < this.sample_sizes.length; e++)\n      t[e].size = this.sample_sizes[e];\n  }, n.DIFF_BOXES_PROP_NAMES = [\n    \"boxes\",\n    \"entries\",\n    \"references\",\n    \"subsamples\",\n    \"items\",\n    \"item_infos\",\n    \"extents\",\n    \"associations\",\n    \"subsegments\",\n    \"ranges\",\n    \"seekLists\",\n    \"seekPoints\",\n    \"esd\",\n    \"levels\"\n  ], n.DIFF_PRIMITIVE_ARRAY_PROP_NAMES = [\n    \"compatible_brands\",\n    \"matrix\",\n    \"opcolor\",\n    \"sample_counts\",\n    \"sample_counts\",\n    \"sample_deltas\",\n    \"first_chunk\",\n    \"samples_per_chunk\",\n    \"sample_sizes\",\n    \"chunk_offsets\",\n    \"sample_offsets\",\n    \"sample_description_index\",\n    \"sample_duration\"\n  ], n.boxEqualFields = function(t, e) {\n    if (t && !e) return !1;\n    var i;\n    for (i in t)\n      if (!(n.DIFF_BOXES_PROP_NAMES.indexOf(i) > -1)) {\n        if (t[i] instanceof n.Box || e[i] instanceof n.Box)\n          continue;\n        if (typeof t[i] > \"u\" || typeof e[i] > \"u\")\n          continue;\n        if (typeof t[i] == \"function\" || typeof e[i] == \"function\")\n          continue;\n        if (t.subBoxNames && t.subBoxNames.indexOf(i.slice(0, 4)) > -1 || e.subBoxNames && e.subBoxNames.indexOf(i.slice(0, 4)) > -1)\n          continue;\n        if (i === \"data\" || i === \"start\" || i === \"size\" || i === \"creation_time\" || i === \"modification_time\")\n          continue;\n        if (n.DIFF_PRIMITIVE_ARRAY_PROP_NAMES.indexOf(i) > -1)\n          continue;\n        if (t[i] !== e[i])\n          return !1;\n      }\n    return !0;\n  }, n.boxEqual = function(t, e) {\n    if (!n.boxEqualFields(t, e))\n      return !1;\n    for (var i = 0; i < n.DIFF_BOXES_PROP_NAMES.length; i++) {\n      var s = n.DIFF_BOXES_PROP_NAMES[i];\n      if (t[s] && e[s] && !n.boxEqual(t[s], e[s]))\n        return !1;\n    }\n    return !0;\n  };\n  var v = function() {\n  };\n  v.prototype.parseSample = function(t) {\n    var e = {}, i;\n    e.resources = [];\n    var s = new h(t.data.buffer);\n    if (!t.subsamples || t.subsamples.length === 0)\n      e.documentString = s.readString(t.data.length);\n    else if (e.documentString = s.readString(t.subsamples[0].size), t.subsamples.length > 1)\n      for (i = 1; i < t.subsamples.length; i++)\n        e.resources[i] = s.readUint8Array(t.subsamples[i].size);\n    return typeof DOMParser < \"u\" && (e.document = new DOMParser().parseFromString(e.documentString, \"application/xml\")), e;\n  };\n  var b = function() {\n  };\n  b.prototype.parseSample = function(t) {\n    var e, i = new h(t.data.buffer);\n    return e = i.readString(t.data.length), e;\n  }, b.prototype.parseConfig = function(t) {\n    var e, i = new h(t.buffer);\n    return i.readUint32(), e = i.readCString(), e;\n  }, l.XMLSubtitlein4Parser = v, l.Textin4Parser = b;\n  var y = function(t) {\n    this.stream = t || new d(), this.boxes = [], this.mdats = [], this.moofs = [], this.isProgressive = !1, this.moovStartFound = !1, this.onMoovStart = null, this.moovStartSent = !1, this.onReady = null, this.readySent = !1, this.onSegment = null, this.onSamples = null, this.onError = null, this.sampleListBuilt = !1, this.fragmentedTracks = [], this.extractedTracks = [], this.isFragmentationInitialized = !1, this.sampleProcessingStarted = !1, this.nextMoofNumber = 0, this.itemListBuilt = !1, this.onSidx = null, this.sidxSent = !1;\n  };\n  y.prototype.setSegmentOptions = function(t, e, i) {\n    var s = this.getTrackById(t);\n    if (s) {\n      var o = {};\n      this.fragmentedTracks.push(o), o.id = t, o.user = e, o.trak = s, s.nextSample = 0, o.segmentStream = null, o.nb_samples = 1e3, o.rapAlignement = !0, i && (i.nbSamples && (o.nb_samples = i.nbSamples), i.rapAlignement && (o.rapAlignement = i.rapAlignement));\n    }\n  }, y.prototype.unsetSegmentOptions = function(t) {\n    for (var e = -1, i = 0; i < this.fragmentedTracks.length; i++) {\n      var s = this.fragmentedTracks[i];\n      s.id == t && (e = i);\n    }\n    e > -1 && this.fragmentedTracks.splice(e, 1);\n  }, y.prototype.setExtractionOptions = function(t, e, i) {\n    var s = this.getTrackById(t);\n    if (s) {\n      var o = {};\n      this.extractedTracks.push(o), o.id = t, o.user = e, o.trak = s, s.nextSample = 0, o.nb_samples = 1e3, o.samples = [], i && i.nbSamples && (o.nb_samples = i.nbSamples);\n    }\n  }, y.prototype.unsetExtractionOptions = function(t) {\n    for (var e = -1, i = 0; i < this.extractedTracks.length; i++) {\n      var s = this.extractedTracks[i];\n      s.id == t && (e = i);\n    }\n    e > -1 && this.extractedTracks.splice(e, 1);\n  }, y.prototype.parse = function() {\n    var t, e, i = !1;\n    if (!(this.restoreParsePosition && !this.restoreParsePosition()))\n      for (; ; )\n        if (this.hasIncompleteMdat && this.hasIncompleteMdat()) {\n          if (this.processIncompleteMdat())\n            continue;\n          return;\n        } else if (this.saveParsePosition && this.saveParsePosition(), t = n.parseOneBox(this.stream, i), t.code === n.ERR_NOT_ENOUGH_DATA)\n          if (this.processIncompleteBox) {\n            if (this.processIncompleteBox(t))\n              continue;\n            return;\n          } else\n            return;\n        else {\n          var s;\n          switch (e = t.box, s = e.type !== \"uuid\" ? e.type : e.uuid, this.boxes.push(e), s) {\n            case \"mdat\":\n              this.mdats.push(e);\n              break;\n            case \"moof\":\n              this.moofs.push(e);\n              break;\n            case \"moov\":\n              this.moovStartFound = !0, this.mdats.length === 0 && (this.isProgressive = !0);\n            default:\n              this[s] !== void 0 && r.warn(\"ISOFile\", \"Duplicate Box of type: \" + s + \", overriding previous occurrence\"), this[s] = e;\n              break;\n          }\n          this.updateUsedBytes && this.updateUsedBytes(e, t);\n        }\n  }, y.prototype.checkBuffer = function(t) {\n    if (t == null)\n      throw \"Buffer must be defined and non empty\";\n    if (t.fileStart === void 0)\n      throw \"Buffer must have a fileStart property\";\n    return t.byteLength === 0 ? (r.warn(\"ISOFile\", \"Ignoring empty buffer (fileStart: \" + t.fileStart + \")\"), this.stream.logBufferLevel(), !1) : (r.info(\"ISOFile\", \"Processing buffer (fileStart: \" + t.fileStart + \")\"), t.usedBytes = 0, this.stream.insertBuffer(t), this.stream.logBufferLevel(), this.stream.initialized() ? !0 : (r.warn(\"ISOFile\", \"Not ready to start parsing\"), !1));\n  }, y.prototype.appendBuffer = function(t, e) {\n    var i;\n    if (this.checkBuffer(t))\n      return this.parse(), this.moovStartFound && !this.moovStartSent && (this.moovStartSent = !0, this.onMoovStart && this.onMoovStart()), this.moov ? (this.sampleListBuilt || (this.buildSampleLists(), this.sampleListBuilt = !0), this.updateSampleLists(), this.onReady && !this.readySent && (this.readySent = !0, this.onReady(this.getInfo())), this.processSamples(e), this.nextSeekPosition ? (i = this.nextSeekPosition, this.nextSeekPosition = void 0) : i = this.nextParsePosition, this.stream.getEndFilePositionAfter && (i = this.stream.getEndFilePositionAfter(i))) : this.nextParsePosition ? i = this.nextParsePosition : i = 0, this.sidx && this.onSidx && !this.sidxSent && (this.onSidx(this.sidx), this.sidxSent = !0), this.meta && (this.flattenItemInfo && !this.itemListBuilt && (this.flattenItemInfo(), this.itemListBuilt = !0), this.processItems && this.processItems(this.onItem)), this.stream.cleanBuffers && (r.info(\"ISOFile\", \"Done processing buffer (fileStart: \" + t.fileStart + \") - next buffer to fetch should have a fileStart position of \" + i), this.stream.logBufferLevel(), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0), r.info(\"ISOFile\", \"Sample data size in memory: \" + this.getAllocatedSampleDataSize())), i;\n  }, y.prototype.getInfo = function() {\n    var t, e, i = {}, s, o, c, u, _ = (/* @__PURE__ */ new Date(\"1904-01-01T00:00:00Z\")).getTime();\n    if (this.moov)\n      for (i.hasMoov = !0, i.duration = this.moov.mvhd.duration, i.timescale = this.moov.mvhd.timescale, i.isFragmented = this.moov.mvex != null, i.isFragmented && this.moov.mvex.mehd && (i.fragment_duration = this.moov.mvex.mehd.fragment_duration), i.isProgressive = this.isProgressive, i.hasIOD = this.moov.iods != null, i.brands = [], i.brands.push(this.ftyp.major_brand), i.brands = i.brands.concat(this.ftyp.compatible_brands), i.created = new Date(_ + this.moov.mvhd.creation_time * 1e3), i.modified = new Date(_ + this.moov.mvhd.modification_time * 1e3), i.tracks = [], i.audioTracks = [], i.videoTracks = [], i.subtitleTracks = [], i.metadataTracks = [], i.hintTracks = [], i.otherTracks = [], t = 0; t < this.moov.traks.length; t++) {\n        if (s = this.moov.traks[t], u = s.mdia.minf.stbl.stsd.entries[0], o = {}, i.tracks.push(o), o.id = s.tkhd.track_id, o.name = s.mdia.hdlr.name, o.references = [], s.tref)\n          for (e = 0; e < s.tref.boxes.length; e++)\n            c = {}, o.references.push(c), c.type = s.tref.boxes[e].type, c.track_ids = s.tref.boxes[e].track_ids;\n        s.edts && (o.edits = s.edts.elst.entries), o.created = new Date(_ + s.tkhd.creation_time * 1e3), o.modified = new Date(_ + s.tkhd.modification_time * 1e3), o.movie_duration = s.tkhd.duration, o.movie_timescale = i.timescale, o.layer = s.tkhd.layer, o.alternate_group = s.tkhd.alternate_group, o.volume = s.tkhd.volume, o.matrix = s.tkhd.matrix, o.track_width = s.tkhd.width / 65536, o.track_height = s.tkhd.height / 65536, o.timescale = s.mdia.mdhd.timescale, o.cts_shift = s.mdia.minf.stbl.cslg, o.duration = s.mdia.mdhd.duration, o.samples_duration = s.samples_duration, o.codec = u.getCodec(), o.kind = s.udta && s.udta.kinds.length ? s.udta.kinds[0] : { schemeURI: \"\", value: \"\" }, o.language = s.mdia.elng ? s.mdia.elng.extended_language : s.mdia.mdhd.languageString, o.nb_samples = s.samples.length, o.size = s.samples_size, o.bitrate = o.size * 8 * o.timescale / o.samples_duration, u.isAudio() ? (o.type = \"audio\", i.audioTracks.push(o), o.audio = {}, o.audio.sample_rate = u.getSampleRate(), o.audio.channel_count = u.getChannelCount(), o.audio.sample_size = u.getSampleSize()) : u.isVideo() ? (o.type = \"video\", i.videoTracks.push(o), o.video = {}, o.video.width = u.getWidth(), o.video.height = u.getHeight()) : u.isSubtitle() ? (o.type = \"subtitles\", i.subtitleTracks.push(o)) : u.isHint() ? (o.type = \"metadata\", i.hintTracks.push(o)) : u.isMetadata() ? (o.type = \"metadata\", i.metadataTracks.push(o)) : (o.type = \"metadata\", i.otherTracks.push(o));\n      }\n    else\n      i.hasMoov = !1;\n    if (i.mime = \"\", i.hasMoov && i.tracks) {\n      for (i.videoTracks && i.videoTracks.length > 0 ? i.mime += 'video/mp4; codecs=\"' : i.audioTracks && i.audioTracks.length > 0 ? i.mime += 'audio/mp4; codecs=\"' : i.mime += 'application/mp4; codecs=\"', t = 0; t < i.tracks.length; t++)\n        t !== 0 && (i.mime += \",\"), i.mime += i.tracks[t].codec;\n      i.mime += '\"; profiles=\"', i.mime += this.ftyp.compatible_brands.join(), i.mime += '\"';\n    }\n    return i;\n  }, y.prototype.processSamples = function(t) {\n    var e, i;\n    if (this.sampleProcessingStarted) {\n      if (this.isFragmentationInitialized && this.onSegment !== null)\n        for (e = 0; e < this.fragmentedTracks.length; e++) {\n          var s = this.fragmentedTracks[e];\n          for (i = s.trak; i.nextSample < i.samples.length && this.sampleProcessingStarted; ) {\n            r.debug(\"ISOFile\", \"Creating media fragment on track #\" + s.id + \" for sample \" + i.nextSample);\n            var o = this.createFragment(s.id, i.nextSample, s.segmentStream);\n            if (o)\n              s.segmentStream = o, i.nextSample++;\n            else\n              break;\n            if ((i.nextSample % s.nb_samples === 0 || t || i.nextSample >= i.samples.length) && (r.info(\"ISOFile\", \"Sending fragmented data on track #\" + s.id + \" for samples [\" + Math.max(0, i.nextSample - s.nb_samples) + \",\" + (i.nextSample - 1) + \"]\"), r.info(\"ISOFile\", \"Sample data size in memory: \" + this.getAllocatedSampleDataSize()), this.onSegment && this.onSegment(s.id, s.user, s.segmentStream.buffer, i.nextSample, t || i.nextSample >= i.samples.length), s.segmentStream = null, s !== this.fragmentedTracks[e]))\n              break;\n          }\n        }\n      if (this.onSamples !== null)\n        for (e = 0; e < this.extractedTracks.length; e++) {\n          var c = this.extractedTracks[e];\n          for (i = c.trak; i.nextSample < i.samples.length && this.sampleProcessingStarted; ) {\n            r.debug(\"ISOFile\", \"Exporting on track #\" + c.id + \" sample #\" + i.nextSample);\n            var u = this.getSample(i, i.nextSample);\n            if (u)\n              i.nextSample++, c.samples.push(u);\n            else\n              break;\n            if ((i.nextSample % c.nb_samples === 0 || i.nextSample >= i.samples.length) && (r.debug(\"ISOFile\", \"Sending samples on track #\" + c.id + \" for sample \" + i.nextSample), this.onSamples && this.onSamples(c.id, c.user, c.samples), c.samples = [], c !== this.extractedTracks[e]))\n              break;\n          }\n        }\n    }\n  }, y.prototype.getBox = function(t) {\n    var e = this.getBoxes(t, !0);\n    return e.length ? e[0] : null;\n  }, y.prototype.getBoxes = function(t, e) {\n    var i = [];\n    return y._sweep.call(this, t, i, e), i;\n  }, y._sweep = function(t, e, i) {\n    this.type && this.type == t && e.push(this);\n    for (var s in this.boxes) {\n      if (e.length && i) return;\n      y._sweep.call(this.boxes[s], t, e, i);\n    }\n  }, y.prototype.getTrackSamplesInfo = function(t) {\n    var e = this.getTrackById(t);\n    if (e)\n      return e.samples;\n  }, y.prototype.getTrackSample = function(t, e) {\n    var i = this.getTrackById(t), s = this.getSample(i, e);\n    return s;\n  }, y.prototype.releaseUsedSamples = function(t, e) {\n    var i = 0, s = this.getTrackById(t);\n    s.lastValidSample || (s.lastValidSample = 0);\n    for (var o = s.lastValidSample; o < e; o++)\n      i += this.releaseSample(s, o);\n    r.info(\"ISOFile\", \"Track #\" + t + \" released samples up to \" + e + \" (released size: \" + i + \", remaining: \" + this.samplesDataSize + \")\"), s.lastValidSample = e;\n  }, y.prototype.start = function() {\n    this.sampleProcessingStarted = !0, this.processSamples(!1);\n  }, y.prototype.stop = function() {\n    this.sampleProcessingStarted = !1;\n  }, y.prototype.flush = function() {\n    r.info(\"ISOFile\", \"Flushing remaining samples\"), this.updateSampleLists(), this.processSamples(!0), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0);\n  }, y.prototype.seekTrack = function(t, e, i) {\n    var s, o, c = 1 / 0, u = 0, _ = 0, g;\n    if (i.samples.length === 0)\n      return r.info(\"ISOFile\", \"No sample in track, cannot seek! Using time \" + r.getDurationString(0, 1) + \" and offset: 0\"), { offset: 0, time: 0 };\n    for (s = 0; s < i.samples.length; s++) {\n      if (o = i.samples[s], s === 0)\n        _ = 0, g = o.timescale;\n      else if (o.cts > t * o.timescale) {\n        _ = s - 1;\n        break;\n      }\n      e && o.is_sync && (u = s);\n    }\n    for (e && (_ = u), t = i.samples[_].cts, i.nextSample = _; i.samples[_].alreadyRead === i.samples[_].size && i.samples[_ + 1]; )\n      _++;\n    return c = i.samples[_].offset + i.samples[_].alreadyRead, r.info(\"ISOFile\", \"Seeking to \" + (e ? \"RAP\" : \"\") + \" sample #\" + i.nextSample + \" on track \" + i.tkhd.track_id + \", time \" + r.getDurationString(t, g) + \" and offset: \" + c), { offset: c, time: t / g };\n  }, y.prototype.seek = function(t, e) {\n    var i = this.moov, s, o, c, u = { offset: 1 / 0, time: 1 / 0 };\n    if (this.moov) {\n      for (c = 0; c < i.traks.length; c++)\n        s = i.traks[c], o = this.seekTrack(t, e, s), o.offset < u.offset && (u.offset = o.offset), o.time < u.time && (u.time = o.time);\n      return r.info(\"ISOFile\", \"Seeking at time \" + r.getDurationString(u.time, 1) + \" needs a buffer with a fileStart position of \" + u.offset), u.offset === 1 / 0 ? u = { offset: this.nextParsePosition, time: 0 } : u.offset = this.stream.getEndFilePositionAfter(u.offset), r.info(\"ISOFile\", \"Adjusted seek position (after checking data already in buffer): \" + u.offset), u;\n    } else\n      throw \"Cannot seek: moov not received!\";\n  }, y.prototype.equal = function(t) {\n    for (var e = 0; e < this.boxes.length && e < t.boxes.length; ) {\n      var i = this.boxes[e], s = t.boxes[e];\n      if (!n.boxEqual(i, s))\n        return !1;\n      e++;\n    }\n    return !0;\n  }, l.ISOFile = y, y.prototype.lastBoxStartPosition = 0, y.prototype.parsingMdat = null, y.prototype.nextParsePosition = 0, y.prototype.discardMdatData = !1, y.prototype.processIncompleteBox = function(t) {\n    var e, i, s;\n    return t.type === \"mdat\" ? (e = new n[t.type + \"Box\"](t.size), this.parsingMdat = e, this.boxes.push(e), this.mdats.push(e), e.start = t.start, e.hdr_size = t.hdr_size, this.stream.addUsedBytes(e.hdr_size), this.lastBoxStartPosition = e.start + e.size, s = this.stream.seek(e.start + e.size, !1, this.discardMdatData), s ? (this.parsingMdat = null, !0) : (this.moovStartFound ? this.nextParsePosition = this.stream.findEndContiguousBuf() : this.nextParsePosition = e.start + e.size, !1)) : (t.type === \"moov\" && (this.moovStartFound = !0, this.mdats.length === 0 && (this.isProgressive = !0)), i = this.stream.mergeNextBuffer ? this.stream.mergeNextBuffer() : !1, i ? (this.nextParsePosition = this.stream.getEndPosition(), !0) : (t.type ? this.moovStartFound ? this.nextParsePosition = this.stream.getEndPosition() : this.nextParsePosition = this.stream.getPosition() + t.size : this.nextParsePosition = this.stream.getEndPosition(), !1));\n  }, y.prototype.hasIncompleteMdat = function() {\n    return this.parsingMdat !== null;\n  }, y.prototype.processIncompleteMdat = function() {\n    var t, e;\n    return t = this.parsingMdat, e = this.stream.seek(t.start + t.size, !1, this.discardMdatData), e ? (r.debug(\"ISOFile\", \"Found 'mdat' end in buffered data\"), this.parsingMdat = null, !0) : (this.nextParsePosition = this.stream.findEndContiguousBuf(), !1);\n  }, y.prototype.restoreParsePosition = function() {\n    return this.stream.seek(this.lastBoxStartPosition, !0, this.discardMdatData);\n  }, y.prototype.saveParsePosition = function() {\n    this.lastBoxStartPosition = this.stream.getPosition();\n  }, y.prototype.updateUsedBytes = function(t, e) {\n    this.stream.addUsedBytes && (t.type === \"mdat\" ? (this.stream.addUsedBytes(t.hdr_size), this.discardMdatData && this.stream.addUsedBytes(t.size - t.hdr_size)) : this.stream.addUsedBytes(t.size));\n  }, y.prototype.add = n.Box.prototype.add, y.prototype.addBox = n.Box.prototype.addBox, y.prototype.init = function(t) {\n    var e = t || {};\n    this.add(\"ftyp\").set(\"major_brand\", e.brands && e.brands[0] || \"iso4\").set(\"minor_version\", 0).set(\"compatible_brands\", e.brands || [\"iso4\"]);\n    var i = this.add(\"moov\");\n    return i.add(\"mvhd\").set(\"timescale\", e.timescale || 600).set(\"rate\", e.rate || 65536).set(\"creation_time\", 0).set(\"modification_time\", 0).set(\"duration\", e.duration || 0).set(\"volume\", e.width ? 0 : 256).set(\"matrix\", [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]).set(\"next_track_id\", 1), i.add(\"mvex\"), this;\n  }, y.prototype.addTrack = function(t) {\n    this.moov || this.init(t);\n    var e = t || {};\n    e.width = e.width || 320, e.height = e.height || 320, e.id = e.id || this.moov.mvhd.next_track_id, e.type = e.type || \"avc1\";\n    var i = this.moov.add(\"trak\");\n    this.moov.mvhd.next_track_id = e.id + 1, i.add(\"tkhd\").set(\"flags\", n.TKHD_FLAG_ENABLED | n.TKHD_FLAG_IN_MOVIE | n.TKHD_FLAG_IN_PREVIEW).set(\"creation_time\", 0).set(\"modification_time\", 0).set(\"track_id\", e.id).set(\"duration\", e.duration || 0).set(\"layer\", e.layer || 0).set(\"alternate_group\", 0).set(\"volume\", 1).set(\"matrix\", [0, 0, 0, 0, 0, 0, 0, 0, 0]).set(\"width\", e.width << 16).set(\"height\", e.height << 16);\n    var s = i.add(\"mdia\");\n    s.add(\"mdhd\").set(\"creation_time\", 0).set(\"modification_time\", 0).set(\"timescale\", e.timescale || 1).set(\"duration\", e.media_duration || 0).set(\"language\", e.language || \"und\"), s.add(\"hdlr\").set(\"handler\", e.hdlr || \"vide\").set(\"name\", e.name || \"Track created with MP4Box.js\"), s.add(\"elng\").set(\"extended_language\", e.language || \"fr-FR\");\n    var o = s.add(\"minf\");\n    if (n[e.type + \"SampleEntry\"] !== void 0) {\n      var c = new n[e.type + \"SampleEntry\"]();\n      c.data_reference_index = 1;\n      var u = \"\";\n      for (var _ in n.sampleEntryCodes)\n        for (var g = n.sampleEntryCodes[_], w = 0; w < g.length; w++)\n          if (g.indexOf(e.type) > -1) {\n            u = _;\n            break;\n          }\n      switch (u) {\n        case \"Visual\":\n          if (o.add(\"vmhd\").set(\"graphicsmode\", 0).set(\"opcolor\", [0, 0, 0]), c.set(\"width\", e.width).set(\"height\", e.height).set(\"horizresolution\", 72 << 16).set(\"vertresolution\", 72 << 16).set(\"frame_count\", 1).set(\"compressorname\", e.type + \" Compressor\").set(\"depth\", 24), e.avcDecoderConfigRecord) {\n            var S = new n.avcCBox(), U = new h(e.avcDecoderConfigRecord);\n            S.parse(U), c.addBox(S);\n          }\n          break;\n        case \"Audio\":\n          o.add(\"smhd\").set(\"balance\", e.balance || 0), c.set(\"channel_count\", e.channel_count || 2).set(\"samplesize\", e.samplesize || 16).set(\"samplerate\", e.samplerate || 65536);\n          break;\n        case \"Hint\":\n          o.add(\"hmhd\");\n          break;\n        case \"Subtitle\":\n          switch (o.add(\"sthd\"), e.type) {\n            case \"stpp\":\n              c.set(\"namespace\", e.namespace || \"nonamespace\").set(\"schema_location\", e.schema_location || \"\").set(\"auxiliary_mime_types\", e.auxiliary_mime_types || \"\");\n              break;\n          }\n          break;\n        case \"Metadata\":\n          o.add(\"nmhd\");\n          break;\n        case \"System\":\n          o.add(\"nmhd\");\n          break;\n        default:\n          o.add(\"nmhd\");\n          break;\n      }\n      e.description && c.addBox(e.description), e.description_boxes && e.description_boxes.forEach(function(x) {\n        c.addBox(x);\n      }), o.add(\"dinf\").add(\"dref\").addEntry(new n[\"url Box\"]().set(\"flags\", 1));\n      var C = o.add(\"stbl\");\n      return C.add(\"stsd\").addEntry(c), C.add(\"stts\").set(\"sample_counts\", []).set(\"sample_deltas\", []), C.add(\"stsc\").set(\"first_chunk\", []).set(\"samples_per_chunk\", []).set(\"sample_description_index\", []), C.add(\"stco\").set(\"chunk_offsets\", []), C.add(\"stsz\").set(\"sample_sizes\", []), this.moov.mvex.add(\"trex\").set(\"track_id\", e.id).set(\"default_sample_description_index\", e.default_sample_description_index || 1).set(\"default_sample_duration\", e.default_sample_duration || 0).set(\"default_sample_size\", e.default_sample_size || 0).set(\"default_sample_flags\", e.default_sample_flags || 0), this.buildTrakSampleLists(i), e.id;\n    }\n  }, n.Box.prototype.computeSize = function(t) {\n    var e = t || new a();\n    e.endianness = a.BIG_ENDIAN, this.write(e);\n  }, y.prototype.addSample = function(t, e, i) {\n    var s = i || {}, o = {}, c = this.getTrackById(t);\n    if (c !== null) {\n      o.number = c.samples.length, o.track_id = c.tkhd.track_id, o.timescale = c.mdia.mdhd.timescale, o.description_index = s.sample_description_index ? s.sample_description_index - 1 : 0, o.description = c.mdia.minf.stbl.stsd.entries[o.description_index], o.data = e, o.size = e.byteLength, o.alreadyRead = o.size, o.duration = s.duration || 1, o.cts = s.cts || 0, o.dts = s.dts || 0, o.is_sync = s.is_sync || !1, o.is_leading = s.is_leading || 0, o.depends_on = s.depends_on || 0, o.is_depended_on = s.is_depended_on || 0, o.has_redundancy = s.has_redundancy || 0, o.degradation_priority = s.degradation_priority || 0, o.offset = 0, o.subsamples = s.subsamples, c.samples.push(o), c.samples_size += o.size, c.samples_duration += o.duration, c.first_dts || (c.first_dts = s.dts), this.processSamples();\n      var u = this.createSingleSampleMoof(o);\n      return this.addBox(u), u.computeSize(), u.trafs[0].truns[0].data_offset = u.size + 8, this.add(\"mdat\").data = new Uint8Array(e), o;\n    }\n  }, y.prototype.createSingleSampleMoof = function(t) {\n    var e = 0;\n    t.is_sync ? e = 1 << 25 : e = 65536;\n    var i = new n.moofBox();\n    i.add(\"mfhd\").set(\"sequence_number\", this.nextMoofNumber), this.nextMoofNumber++;\n    var s = i.add(\"traf\"), o = this.getTrackById(t.track_id);\n    return s.add(\"tfhd\").set(\"track_id\", t.track_id).set(\"flags\", n.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), s.add(\"tfdt\").set(\"baseMediaDecodeTime\", t.dts - (o.first_dts || 0)), s.add(\"trun\").set(\"flags\", n.TRUN_FLAGS_DATA_OFFSET | n.TRUN_FLAGS_DURATION | n.TRUN_FLAGS_SIZE | n.TRUN_FLAGS_FLAGS | n.TRUN_FLAGS_CTS_OFFSET).set(\"data_offset\", 0).set(\"first_sample_flags\", 0).set(\"sample_count\", 1).set(\"sample_duration\", [t.duration]).set(\"sample_size\", [t.size]).set(\"sample_flags\", [e]).set(\"sample_composition_time_offset\", [t.cts - t.dts]), i;\n  }, y.prototype.lastMoofIndex = 0, y.prototype.samplesDataSize = 0, y.prototype.resetTables = function() {\n    var t, e, i, s, o, c, u, _;\n    for (this.initial_duration = this.moov.mvhd.duration, this.moov.mvhd.duration = 0, t = 0; t < this.moov.traks.length; t++) {\n      e = this.moov.traks[t], e.tkhd.duration = 0, e.mdia.mdhd.duration = 0, i = e.mdia.minf.stbl.stco || e.mdia.minf.stbl.co64, i.chunk_offsets = [], s = e.mdia.minf.stbl.stsc, s.first_chunk = [], s.samples_per_chunk = [], s.sample_description_index = [], o = e.mdia.minf.stbl.stsz || e.mdia.minf.stbl.stz2, o.sample_sizes = [], c = e.mdia.minf.stbl.stts, c.sample_counts = [], c.sample_deltas = [], u = e.mdia.minf.stbl.ctts, u && (u.sample_counts = [], u.sample_offsets = []), _ = e.mdia.minf.stbl.stss;\n      var g = e.mdia.minf.stbl.boxes.indexOf(_);\n      g != -1 && (e.mdia.minf.stbl.boxes[g] = null);\n    }\n  }, y.initSampleGroups = function(t, e, i, s, o) {\n    var c, u, _, g;\n    function w(S, U, C) {\n      this.grouping_type = S, this.grouping_type_parameter = U, this.sbgp = C, this.last_sample_in_run = -1, this.entry_index = -1;\n    }\n    for (e && (e.sample_groups_info = []), t.sample_groups_info || (t.sample_groups_info = []), u = 0; u < i.length; u++) {\n      for (g = i[u].grouping_type + \"/\" + i[u].grouping_type_parameter, _ = new w(i[u].grouping_type, i[u].grouping_type_parameter, i[u]), e && (e.sample_groups_info[g] = _), t.sample_groups_info[g] || (t.sample_groups_info[g] = _), c = 0; c < s.length; c++)\n        s[c].grouping_type === i[u].grouping_type && (_.description = s[c], _.description.used = !0);\n      if (o)\n        for (c = 0; c < o.length; c++)\n          o[c].grouping_type === i[u].grouping_type && (_.fragment_description = o[c], _.fragment_description.used = !0, _.is_fragment = !0);\n    }\n    if (e) {\n      if (o)\n        for (u = 0; u < o.length; u++)\n          !o[u].used && o[u].version >= 2 && (g = o[u].grouping_type + \"/0\", _ = new w(o[u].grouping_type, 0), _.is_fragment = !0, e.sample_groups_info[g] || (e.sample_groups_info[g] = _));\n    } else\n      for (u = 0; u < s.length; u++)\n        !s[u].used && s[u].version >= 2 && (g = s[u].grouping_type + \"/0\", _ = new w(s[u].grouping_type, 0), t.sample_groups_info[g] || (t.sample_groups_info[g] = _));\n  }, y.setSampleGroupProperties = function(t, e, i, s) {\n    var o, c;\n    e.sample_groups = [];\n    for (o in s)\n      if (e.sample_groups[o] = {}, e.sample_groups[o].grouping_type = s[o].grouping_type, e.sample_groups[o].grouping_type_parameter = s[o].grouping_type_parameter, i >= s[o].last_sample_in_run && (s[o].last_sample_in_run < 0 && (s[o].last_sample_in_run = 0), s[o].entry_index++, s[o].entry_index <= s[o].sbgp.entries.length - 1 && (s[o].last_sample_in_run += s[o].sbgp.entries[s[o].entry_index].sample_count)), s[o].entry_index <= s[o].sbgp.entries.length - 1 ? e.sample_groups[o].group_description_index = s[o].sbgp.entries[s[o].entry_index].group_description_index : e.sample_groups[o].group_description_index = -1, e.sample_groups[o].group_description_index !== 0) {\n        var u;\n        s[o].fragment_description ? u = s[o].fragment_description : u = s[o].description, e.sample_groups[o].group_description_index > 0 ? (e.sample_groups[o].group_description_index > 65535 ? c = (e.sample_groups[o].group_description_index >> 16) - 1 : c = e.sample_groups[o].group_description_index - 1, u && c >= 0 && (e.sample_groups[o].description = u.entries[c])) : u && u.version >= 2 && u.default_group_description_index > 0 && (e.sample_groups[o].description = u.entries[u.default_group_description_index - 1]);\n      }\n  }, y.process_sdtp = function(t, e, i) {\n    e && (t ? (e.is_leading = t.is_leading[i], e.depends_on = t.sample_depends_on[i], e.is_depended_on = t.sample_is_depended_on[i], e.has_redundancy = t.sample_has_redundancy[i]) : (e.is_leading = 0, e.depends_on = 0, e.is_depended_on = 0, e.has_redundancy = 0));\n  }, y.prototype.buildSampleLists = function() {\n    var t, e;\n    for (t = 0; t < this.moov.traks.length; t++)\n      e = this.moov.traks[t], this.buildTrakSampleLists(e);\n  }, y.prototype.buildTrakSampleLists = function(t) {\n    var e, i, s, o, c, u, _, g, w, S, U, C, x, P, T, yt, Ut, ht, O, tt, Ht, ee, et, Et;\n    if (t.samples = [], t.samples_duration = 0, t.samples_size = 0, i = t.mdia.minf.stbl.stco || t.mdia.minf.stbl.co64, s = t.mdia.minf.stbl.stsc, o = t.mdia.minf.stbl.stsz || t.mdia.minf.stbl.stz2, c = t.mdia.minf.stbl.stts, u = t.mdia.minf.stbl.ctts, _ = t.mdia.minf.stbl.stss, g = t.mdia.minf.stbl.stsd, w = t.mdia.minf.stbl.subs, C = t.mdia.minf.stbl.stdp, S = t.mdia.minf.stbl.sbgps, U = t.mdia.minf.stbl.sgpds, ht = -1, O = -1, tt = -1, Ht = -1, ee = 0, et = 0, Et = 0, y.initSampleGroups(t, null, S, U), !(typeof o > \"u\")) {\n      for (e = 0; e < o.sample_sizes.length; e++) {\n        var F = {};\n        F.number = e, F.track_id = t.tkhd.track_id, F.timescale = t.mdia.mdhd.timescale, F.alreadyRead = 0, t.samples[e] = F, F.size = o.sample_sizes[e], t.samples_size += F.size, e === 0 ? (P = 1, x = 0, F.chunk_index = P, F.chunk_run_index = x, Ut = s.samples_per_chunk[x], yt = 0, x + 1 < s.first_chunk.length ? T = s.first_chunk[x + 1] - 1 : T = 1 / 0) : e < Ut ? (F.chunk_index = P, F.chunk_run_index = x) : (P++, F.chunk_index = P, yt = 0, P <= T || (x++, x + 1 < s.first_chunk.length ? T = s.first_chunk[x + 1] - 1 : T = 1 / 0), F.chunk_run_index = x, Ut += s.samples_per_chunk[x]), F.description_index = s.sample_description_index[F.chunk_run_index] - 1, F.description = g.entries[F.description_index], F.offset = i.chunk_offsets[F.chunk_index - 1] + yt, yt += F.size, e > ht && (O++, ht < 0 && (ht = 0), ht += c.sample_counts[O]), e > 0 ? (t.samples[e - 1].duration = c.sample_deltas[O], t.samples_duration += t.samples[e - 1].duration, F.dts = t.samples[e - 1].dts + t.samples[e - 1].duration) : F.dts = 0, u ? (e >= tt && (Ht++, tt < 0 && (tt = 0), tt += u.sample_counts[Ht]), F.cts = t.samples[e].dts + u.sample_offsets[Ht]) : F.cts = F.dts, _ ? (e == _.sample_numbers[ee] - 1 ? (F.is_sync = !0, ee++) : (F.is_sync = !1, F.degradation_priority = 0), w && w.entries[et].sample_delta + Et == e + 1 && (F.subsamples = w.entries[et].subsamples, Et += w.entries[et].sample_delta, et++)) : F.is_sync = !0, y.process_sdtp(t.mdia.minf.stbl.sdtp, F, F.number), C ? F.degradation_priority = C.priority[e] : F.degradation_priority = 0, w && w.entries[et].sample_delta + Et == e && (F.subsamples = w.entries[et].subsamples, Et += w.entries[et].sample_delta), (S.length > 0 || U.length > 0) && y.setSampleGroupProperties(t, F, e, t.sample_groups_info);\n      }\n      e > 0 && (t.samples[e - 1].duration = Math.max(t.mdia.mdhd.duration - t.samples[e - 1].dts, 0), t.samples_duration += t.samples[e - 1].duration);\n    }\n  }, y.prototype.updateSampleLists = function() {\n    var t, e, i, s, o, c, u, _, g, w, S, U, C, x, P;\n    if (this.moov !== void 0) {\n      for (; this.lastMoofIndex < this.moofs.length; )\n        if (g = this.moofs[this.lastMoofIndex], this.lastMoofIndex++, g.type == \"moof\")\n          for (w = g, t = 0; t < w.trafs.length; t++) {\n            for (S = w.trafs[t], U = this.getTrackById(S.tfhd.track_id), C = this.getTrexById(S.tfhd.track_id), S.tfhd.flags & n.TFHD_FLAG_SAMPLE_DESC ? s = S.tfhd.default_sample_description_index : s = C ? C.default_sample_description_index : 1, S.tfhd.flags & n.TFHD_FLAG_SAMPLE_DUR ? o = S.tfhd.default_sample_duration : o = C ? C.default_sample_duration : 0, S.tfhd.flags & n.TFHD_FLAG_SAMPLE_SIZE ? c = S.tfhd.default_sample_size : c = C ? C.default_sample_size : 0, S.tfhd.flags & n.TFHD_FLAG_SAMPLE_FLAGS ? u = S.tfhd.default_sample_flags : u = C ? C.default_sample_flags : 0, S.sample_number = 0, S.sbgps.length > 0 && y.initSampleGroups(U, S, S.sbgps, U.mdia.minf.stbl.sgpds, S.sgpds), e = 0; e < S.truns.length; e++) {\n              var T = S.truns[e];\n              for (i = 0; i < T.sample_count; i++) {\n                x = {}, x.moof_number = this.lastMoofIndex, x.number_in_traf = S.sample_number, S.sample_number++, x.number = U.samples.length, S.first_sample_index = U.samples.length, U.samples.push(x), x.track_id = U.tkhd.track_id, x.timescale = U.mdia.mdhd.timescale, x.description_index = s - 1, x.description = U.mdia.minf.stbl.stsd.entries[x.description_index], x.size = c, T.flags & n.TRUN_FLAGS_SIZE && (x.size = T.sample_size[i]), U.samples_size += x.size, x.duration = o, T.flags & n.TRUN_FLAGS_DURATION && (x.duration = T.sample_duration[i]), U.samples_duration += x.duration, U.first_traf_merged || i > 0 ? x.dts = U.samples[U.samples.length - 2].dts + U.samples[U.samples.length - 2].duration : (S.tfdt ? x.dts = S.tfdt.baseMediaDecodeTime : x.dts = 0, U.first_traf_merged = !0), x.cts = x.dts, T.flags & n.TRUN_FLAGS_CTS_OFFSET && (x.cts = x.dts + T.sample_composition_time_offset[i]), P = u, T.flags & n.TRUN_FLAGS_FLAGS ? P = T.sample_flags[i] : i === 0 && T.flags & n.TRUN_FLAGS_FIRST_FLAG && (P = T.first_sample_flags), x.is_sync = !(P >> 16 & 1), x.is_leading = P >> 26 & 3, x.depends_on = P >> 24 & 3, x.is_depended_on = P >> 22 & 3, x.has_redundancy = P >> 20 & 3, x.degradation_priority = P & 65535;\n                var yt = !!(S.tfhd.flags & n.TFHD_FLAG_BASE_DATA_OFFSET), Ut = !!(S.tfhd.flags & n.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), ht = !!(T.flags & n.TRUN_FLAGS_DATA_OFFSET), O = 0;\n                yt ? O = S.tfhd.base_data_offset : Ut || e === 0 ? O = w.start : O = _, e === 0 && i === 0 ? ht ? x.offset = O + T.data_offset : x.offset = O : x.offset = _, _ = x.offset + x.size, (S.sbgps.length > 0 || S.sgpds.length > 0 || U.mdia.minf.stbl.sbgps.length > 0 || U.mdia.minf.stbl.sgpds.length > 0) && y.setSampleGroupProperties(U, x, x.number_in_traf, S.sample_groups_info);\n              }\n            }\n            if (S.subs) {\n              U.has_fragment_subsamples = !0;\n              var tt = S.first_sample_index;\n              for (e = 0; e < S.subs.entries.length; e++)\n                tt += S.subs.entries[e].sample_delta, x = U.samples[tt - 1], x.subsamples = S.subs.entries[e].subsamples;\n            }\n          }\n    }\n  }, y.prototype.getSample = function(t, e) {\n    var i, s = t.samples[e];\n    if (!this.moov)\n      return null;\n    if (!s.data)\n      s.data = new Uint8Array(s.size), s.alreadyRead = 0, this.samplesDataSize += s.size, r.debug(\"ISOFile\", \"Allocating sample #\" + e + \" on track #\" + t.tkhd.track_id + \" of size \" + s.size + \" (total: \" + this.samplesDataSize + \")\");\n    else if (s.alreadyRead == s.size)\n      return s;\n    for (; ; ) {\n      var o = this.stream.findPosition(!0, s.offset + s.alreadyRead, !1);\n      if (o > -1) {\n        i = this.stream.buffers[o];\n        var c = i.byteLength - (s.offset + s.alreadyRead - i.fileStart);\n        if (s.size - s.alreadyRead <= c)\n          return r.debug(\"ISOFile\", \"Getting sample #\" + e + \" data (alreadyRead: \" + s.alreadyRead + \" offset: \" + (s.offset + s.alreadyRead - i.fileStart) + \" read size: \" + (s.size - s.alreadyRead) + \" full size: \" + s.size + \")\"), a.memcpy(\n            s.data.buffer,\n            s.alreadyRead,\n            i,\n            s.offset + s.alreadyRead - i.fileStart,\n            s.size - s.alreadyRead\n          ), i.usedBytes += s.size - s.alreadyRead, this.stream.logBufferLevel(), s.alreadyRead = s.size, s;\n        if (c === 0) return null;\n        r.debug(\"ISOFile\", \"Getting sample #\" + e + \" partial data (alreadyRead: \" + s.alreadyRead + \" offset: \" + (s.offset + s.alreadyRead - i.fileStart) + \" read size: \" + c + \" full size: \" + s.size + \")\"), a.memcpy(\n          s.data.buffer,\n          s.alreadyRead,\n          i,\n          s.offset + s.alreadyRead - i.fileStart,\n          c\n        ), s.alreadyRead += c, i.usedBytes += c, this.stream.logBufferLevel();\n      } else\n        return null;\n    }\n  }, y.prototype.releaseSample = function(t, e) {\n    var i = t.samples[e];\n    return i.data ? (this.samplesDataSize -= i.size, i.data = null, i.alreadyRead = 0, i.size) : 0;\n  }, y.prototype.getAllocatedSampleDataSize = function() {\n    return this.samplesDataSize;\n  }, y.prototype.getCodecs = function() {\n    var t, e = \"\";\n    for (t = 0; t < this.moov.traks.length; t++) {\n      var i = this.moov.traks[t];\n      t > 0 && (e += \",\"), e += i.mdia.minf.stbl.stsd.entries[0].getCodec();\n    }\n    return e;\n  }, y.prototype.getTrexById = function(t) {\n    var e;\n    if (!this.moov || !this.moov.mvex) return null;\n    for (e = 0; e < this.moov.mvex.trexs.length; e++) {\n      var i = this.moov.mvex.trexs[e];\n      if (i.track_id == t) return i;\n    }\n    return null;\n  }, y.prototype.getTrackById = function(t) {\n    if (this.moov === void 0)\n      return null;\n    for (var e = 0; e < this.moov.traks.length; e++) {\n      var i = this.moov.traks[e];\n      if (i.tkhd.track_id == t) return i;\n    }\n    return null;\n  }, y.prototype.items = [], y.prototype.itemsDataSize = 0, y.prototype.flattenItemInfo = function() {\n    var t = this.items, e, i, s, o = this.meta;\n    if (o != null && o.hdlr !== void 0 && o.iinf !== void 0) {\n      for (e = 0; e < o.iinf.item_infos.length; e++)\n        s = {}, s.id = o.iinf.item_infos[e].item_ID, t[s.id] = s, s.ref_to = [], s.name = o.iinf.item_infos[e].item_name, o.iinf.item_infos[e].protection_index > 0 && (s.protection = o.ipro.protections[o.iinf.item_infos[e].protection_index - 1]), o.iinf.item_infos[e].item_type ? s.type = o.iinf.item_infos[e].item_type : s.type = \"mime\", s.content_type = o.iinf.item_infos[e].content_type, s.content_encoding = o.iinf.item_infos[e].content_encoding;\n      if (o.iloc)\n        for (e = 0; e < o.iloc.items.length; e++) {\n          var c = o.iloc.items[e];\n          switch (s = t[c.item_ID], c.data_reference_index !== 0 && (r.warn(\"Item storage with reference to other files: not supported\"), s.source = o.dinf.boxes[c.data_reference_index - 1]), c.construction_method) {\n            case 0:\n              break;\n            case 1:\n              r.warn(\"Item storage with construction_method : not supported\");\n              break;\n            case 2:\n              r.warn(\"Item storage with construction_method : not supported\");\n              break;\n          }\n          for (s.extents = [], s.size = 0, i = 0; i < c.extents.length; i++)\n            s.extents[i] = {}, s.extents[i].offset = c.extents[i].extent_offset + c.base_offset, s.extents[i].length = c.extents[i].extent_length, s.extents[i].alreadyRead = 0, s.size += s.extents[i].length;\n        }\n      if (o.pitm && (t[o.pitm.item_id].primary = !0), o.iref)\n        for (e = 0; e < o.iref.references.length; e++) {\n          var u = o.iref.references[e];\n          for (i = 0; i < u.references.length; i++)\n            t[u.from_item_ID].ref_to.push({ type: u.type, id: u.references[i] });\n        }\n      if (o.iprp)\n        for (var _ = 0; _ < o.iprp.ipmas.length; _++) {\n          var g = o.iprp.ipmas[_];\n          for (e = 0; e < g.associations.length; e++) {\n            var w = g.associations[e];\n            for (s = t[w.id], s.properties === void 0 && (s.properties = {}, s.properties.boxes = []), i = 0; i < w.props.length; i++) {\n              var S = w.props[i];\n              if (S.property_index > 0 && S.property_index - 1 < o.iprp.ipco.boxes.length) {\n                var U = o.iprp.ipco.boxes[S.property_index - 1];\n                s.properties[U.type] = U, s.properties.boxes.push(U);\n              }\n            }\n          }\n        }\n    }\n  }, y.prototype.getItem = function(t) {\n    var e, i;\n    if (!this.meta)\n      return null;\n    if (i = this.items[t], !i.data && i.size)\n      i.data = new Uint8Array(i.size), i.alreadyRead = 0, this.itemsDataSize += i.size, r.debug(\"ISOFile\", \"Allocating item #\" + t + \" of size \" + i.size + \" (total: \" + this.itemsDataSize + \")\");\n    else if (i.alreadyRead === i.size)\n      return i;\n    for (var s = 0; s < i.extents.length; s++) {\n      var o = i.extents[s];\n      if (o.alreadyRead !== o.length) {\n        var c = this.stream.findPosition(!0, o.offset + o.alreadyRead, !1);\n        if (c > -1) {\n          e = this.stream.buffers[c];\n          var u = e.byteLength - (o.offset + o.alreadyRead - e.fileStart);\n          if (o.length - o.alreadyRead <= u)\n            r.debug(\"ISOFile\", \"Getting item #\" + t + \" extent #\" + s + \" data (alreadyRead: \" + o.alreadyRead + \" offset: \" + (o.offset + o.alreadyRead - e.fileStart) + \" read size: \" + (o.length - o.alreadyRead) + \" full extent size: \" + o.length + \" full item size: \" + i.size + \")\"), a.memcpy(\n              i.data.buffer,\n              i.alreadyRead,\n              e,\n              o.offset + o.alreadyRead - e.fileStart,\n              o.length - o.alreadyRead\n            ), e.usedBytes += o.length - o.alreadyRead, this.stream.logBufferLevel(), i.alreadyRead += o.length - o.alreadyRead, o.alreadyRead = o.length;\n          else\n            return r.debug(\"ISOFile\", \"Getting item #\" + t + \" extent #\" + s + \" partial data (alreadyRead: \" + o.alreadyRead + \" offset: \" + (o.offset + o.alreadyRead - e.fileStart) + \" read size: \" + u + \" full extent size: \" + o.length + \" full item size: \" + i.size + \")\"), a.memcpy(\n              i.data.buffer,\n              i.alreadyRead,\n              e,\n              o.offset + o.alreadyRead - e.fileStart,\n              u\n            ), o.alreadyRead += u, i.alreadyRead += u, e.usedBytes += u, this.stream.logBufferLevel(), null;\n        } else\n          return null;\n      }\n    }\n    return i.alreadyRead === i.size ? i : null;\n  }, y.prototype.releaseItem = function(t) {\n    var e = this.items[t];\n    if (e.data) {\n      this.itemsDataSize -= e.size, e.data = null, e.alreadyRead = 0;\n      for (var i = 0; i < e.extents.length; i++) {\n        var s = e.extents[i];\n        s.alreadyRead = 0;\n      }\n      return e.size;\n    } else\n      return 0;\n  }, y.prototype.processItems = function(t) {\n    for (var e in this.items) {\n      var i = this.items[e];\n      this.getItem(i.id), t && !i.sent && (t(i), i.sent = !0, i.data = null);\n    }\n  }, y.prototype.hasItem = function(t) {\n    for (var e in this.items) {\n      var i = this.items[e];\n      if (i.name === t)\n        return i.id;\n    }\n    return -1;\n  }, y.prototype.getMetaHandler = function() {\n    return this.meta ? this.meta.hdlr.handler : null;\n  }, y.prototype.getPrimaryItem = function() {\n    return !this.meta || !this.meta.pitm ? null : this.getItem(this.meta.pitm.item_id);\n  }, y.prototype.itemToFragmentedTrackFile = function(t) {\n    var e = t || {}, i = null;\n    if (e.itemId ? i = this.getItem(e.itemId) : i = this.getPrimaryItem(), i == null) return null;\n    var s = new y();\n    s.discardMdatData = !1;\n    var o = { type: i.type, description_boxes: i.properties.boxes };\n    i.properties.ispe && (o.width = i.properties.ispe.image_width, o.height = i.properties.ispe.image_height);\n    var c = s.addTrack(o);\n    return c ? (s.addSample(c, i.data), s) : null;\n  }, y.prototype.write = function(t) {\n    for (var e = 0; e < this.boxes.length; e++)\n      this.boxes[e].write(t);\n  }, y.prototype.createFragment = function(t, e, i) {\n    var s = this.getTrackById(t), o = this.getSample(s, e);\n    if (o == null)\n      return o = s.samples[e], this.nextSeekPosition ? this.nextSeekPosition = Math.min(o.offset + o.alreadyRead, this.nextSeekPosition) : this.nextSeekPosition = s.samples[e].offset + o.alreadyRead, null;\n    var c = i || new a();\n    c.endianness = a.BIG_ENDIAN;\n    var u = this.createSingleSampleMoof(o);\n    u.write(c), u.trafs[0].truns[0].data_offset = u.size + 8, r.debug(\"MP4Box\", \"Adjusting data_offset with new value \" + u.trafs[0].truns[0].data_offset), c.adjustUint32(u.trafs[0].truns[0].data_offset_position, u.trafs[0].truns[0].data_offset);\n    var _ = new n.mdatBox();\n    return _.data = o.data, _.write(c), c;\n  }, y.writeInitializationSegment = function(t, e, i, s) {\n    var o;\n    r.debug(\"ISOFile\", \"Generating initialization segment\");\n    var c = new a();\n    c.endianness = a.BIG_ENDIAN, t.write(c);\n    var u = e.add(\"mvex\");\n    for (i && u.add(\"mehd\").set(\"fragment_duration\", i), o = 0; o < e.traks.length; o++)\n      u.add(\"trex\").set(\"track_id\", e.traks[o].tkhd.track_id).set(\"default_sample_description_index\", 1).set(\"default_sample_duration\", s).set(\"default_sample_size\", 0).set(\"default_sample_flags\", 65536);\n    return e.write(c), c.buffer;\n  }, y.prototype.save = function(t) {\n    var e = new a();\n    e.endianness = a.BIG_ENDIAN, this.write(e), e.save(t);\n  }, y.prototype.getBuffer = function() {\n    var t = new a();\n    return t.endianness = a.BIG_ENDIAN, this.write(t), t.buffer;\n  }, y.prototype.initializeSegmentation = function() {\n    var t, e, i, s;\n    for (this.onSegment === null && r.warn(\"MP4Box\", \"No segmentation callback set!\"), this.isFragmentationInitialized || (this.isFragmentationInitialized = !0, this.nextMoofNumber = 0, this.resetTables()), e = [], t = 0; t < this.fragmentedTracks.length; t++) {\n      var o = new n.moovBox();\n      o.mvhd = this.moov.mvhd, o.boxes.push(o.mvhd), i = this.getTrackById(this.fragmentedTracks[t].id), o.boxes.push(i), o.traks.push(i), s = {}, s.id = i.tkhd.track_id, s.user = this.fragmentedTracks[t].user, s.buffer = y.writeInitializationSegment(this.ftyp, o, this.moov.mvex && this.moov.mvex.mehd ? this.moov.mvex.mehd.fragment_duration : void 0, this.moov.traks[t].samples.length > 0 ? this.moov.traks[t].samples[0].duration : 0), e.push(s);\n    }\n    return e;\n  }, n.Box.prototype.printHeader = function(t) {\n    this.size += 8, this.size > f && (this.size += 8), this.type === \"uuid\" && (this.size += 16), t.log(t.indent + \"size:\" + this.size), t.log(t.indent + \"type:\" + this.type);\n  }, n.FullBox.prototype.printHeader = function(t) {\n    this.size += 4, n.Box.prototype.printHeader.call(this, t), t.log(t.indent + \"version:\" + this.version), t.log(t.indent + \"flags:\" + this.flags);\n  }, n.Box.prototype.print = function(t) {\n    this.printHeader(t);\n  }, n.ContainerBox.prototype.print = function(t) {\n    this.printHeader(t);\n    for (var e = 0; e < this.boxes.length; e++)\n      if (this.boxes[e]) {\n        var i = t.indent;\n        t.indent += \" \", this.boxes[e].print(t), t.indent = i;\n      }\n  }, y.prototype.print = function(t) {\n    t.indent = \"\";\n    for (var e = 0; e < this.boxes.length; e++)\n      this.boxes[e] && this.boxes[e].print(t);\n  }, n.mvhdBox.prototype.print = function(t) {\n    n.FullBox.prototype.printHeader.call(this, t), t.log(t.indent + \"creation_time: \" + this.creation_time), t.log(t.indent + \"modification_time: \" + this.modification_time), t.log(t.indent + \"timescale: \" + this.timescale), t.log(t.indent + \"duration: \" + this.duration), t.log(t.indent + \"rate: \" + this.rate), t.log(t.indent + \"volume: \" + (this.volume >> 8)), t.log(t.indent + \"matrix: \" + this.matrix.join(\", \")), t.log(t.indent + \"next_track_id: \" + this.next_track_id);\n  }, n.tkhdBox.prototype.print = function(t) {\n    n.FullBox.prototype.printHeader.call(this, t), t.log(t.indent + \"creation_time: \" + this.creation_time), t.log(t.indent + \"modification_time: \" + this.modification_time), t.log(t.indent + \"track_id: \" + this.track_id), t.log(t.indent + \"duration: \" + this.duration), t.log(t.indent + \"volume: \" + (this.volume >> 8)), t.log(t.indent + \"matrix: \" + this.matrix.join(\", \")), t.log(t.indent + \"layer: \" + this.layer), t.log(t.indent + \"alternate_group: \" + this.alternate_group), t.log(t.indent + \"width: \" + this.width), t.log(t.indent + \"height: \" + this.height);\n  };\n  var B = {};\n  B.createFile = function(t, e) {\n    var i = t !== void 0 ? t : !0, s = new y(e);\n    return s.discardMdatData = !i, s;\n  }, l.createFile = B.createFile;\n})(Ge);\nconst D = /* @__PURE__ */ xi(Ge), q = {\n  sampleRate: 48e3,\n  channelCount: 2,\n  codec: \"mp4a.40.2\"\n};\nfunction de(l, r) {\n  const h = r.videoTracks[0], a = {};\n  if (h != null) {\n    const d = Ui(l.getTrackById(h.id)).buffer, { descKey: p, type: n } = h.codec.startsWith(\"avc1\") ? { descKey: \"avcDecoderConfigRecord\", type: \"avc1\" } : h.codec.startsWith(\"hvc1\") ? { descKey: \"hevcDecoderConfigRecord\", type: \"hvc1\" } : { descKey: \"\", type: \"\" };\n    p !== \"\" && (a.videoTrackConf = {\n      timescale: h.timescale,\n      duration: h.duration,\n      width: h.video.width,\n      height: h.video.height,\n      brands: r.brands,\n      type: n,\n      [p]: d\n    }), a.videoDecoderConf = {\n      codec: h.codec,\n      codedHeight: h.video.height,\n      codedWidth: h.video.width,\n      description: d\n    };\n  }\n  const f = r.audioTracks[0];\n  if (f != null) {\n    const d = Se(l);\n    a.audioTrackConf = {\n      timescale: f.timescale,\n      samplerate: f.audio.sample_rate,\n      channel_count: f.audio.channel_count,\n      hdlr: \"soun\",\n      type: f.codec.startsWith(\"mp4a\") ? \"mp4a\" : f.codec,\n      description: Se(l)\n    }, a.audioDecoderConf = {\n      codec: f.codec.startsWith(\"mp4a\") ? q.codec : f.codec,\n      numberOfChannels: f.audio.channel_count,\n      sampleRate: f.audio.sample_rate,\n      ...d == null ? {} : Ei(d)\n    };\n  }\n  return a;\n}\nfunction Ui(l) {\n  for (const r of l.mdia.minf.stbl.stsd.entries) {\n    const h = r.avcC ?? r.hvcC ?? r.vpcC;\n    if (h != null) {\n      const a = new D.DataStream(\n        void 0,\n        0,\n        D.DataStream.BIG_ENDIAN\n      );\n      return h.write(a), new Uint8Array(a.buffer.slice(8));\n    }\n  }\n  throw Error(\"avcC, hvcC or VPX not found\");\n}\nfunction Se(l, r = \"mp4a\") {\n  var a;\n  const h = (a = l.moov) == null ? void 0 : a.traks.map((f) => f.mdia.minf.stbl.stsd.entries).flat().find(({ type: f }) => f === r);\n  return h == null ? void 0 : h.esds;\n}\nfunction Ei(l) {\n  var n;\n  const r = (n = l.esd.descs[0]) == null ? void 0 : n.descs[0];\n  if (r == null) return {};\n  const [h, a] = r.data, f = ((h & 7) << 1) + (a >> 7), d = (a & 127) >> 3;\n  return {\n    sampleRate: [\n      96e3,\n      88200,\n      64e3,\n      48e3,\n      44100,\n      32e3,\n      24e3,\n      22050,\n      16e3,\n      12e3,\n      11025,\n      8e3,\n      7350\n    ][f],\n    numberOfChannels: d\n  };\n}\nfunction Ai(l) {\n  if (l.moov != null) {\n    for (var r = 0; r < l.moov.traks.length; r++)\n      l.moov.traks[r].samples = [];\n    l.mdats = [], l.moofs = [];\n  }\n}\nvar zt;\nclass ce {\n  constructor() {\n    R(this, \"readable\");\n    R(this, \"writable\");\n    A(this, zt, 0);\n    const r = D.createFile();\n    let h = !1;\n    this.readable = new ReadableStream(\n      {\n        start: (a) => {\n          r.onReady = (d) => {\n            var v, b;\n            const p = (v = d.videoTracks[0]) == null ? void 0 : v.id;\n            p != null && r.setExtractionOptions(p, \"video\", { nbSamples: 100 });\n            const n = (b = d.audioTracks[0]) == null ? void 0 : b.id;\n            n != null && r.setExtractionOptions(n, \"audio\", { nbSamples: 100 }), a.enqueue({ chunkType: \"ready\", data: { info: d, file: r } }), r.start();\n          };\n          const f = {};\n          r.onSamples = (d, p, n) => {\n            a.enqueue({\n              chunkType: \"samples\",\n              data: { id: d, type: p, samples: n.map((v) => ({ ...v })) }\n            }), f[d] = (f[d] ?? 0) + n.length, r.releaseUsedSamples(d, f[d]);\n          }, r.onFlush = () => {\n            a.close();\n          };\n        },\n        cancel: () => {\n          r.stop(), h = !0;\n        }\n      },\n      {\n        highWaterMark: 50\n      }\n    ), this.writable = new WritableStream({\n      write: async (a) => {\n        if (h) {\n          this.writable.abort();\n          return;\n        }\n        const f = a.buffer;\n        f.fileStart = m(this, zt), E(this, zt, m(this, zt) + f.byteLength), r.appendBuffer(f);\n      },\n      close: () => {\n        var a;\n        r.flush(), r.stop(), (a = r.onFlush) == null || a.call(r);\n      }\n    });\n  }\n}\nzt = new WeakMap();\nlet Bi = 0;\nfunction ne(l) {\n  return l.kind === \"file\" && l.createReader instanceof Function;\n}\nvar Tt, Pt, G, K, Lt, st, wt, bt, St, V, Q;\nclass sn {\n  constructor(r, h = {}) {\n    A(this, Tt, z.create(`MP4Clip id:${Bi++},`));\n    R(this, \"ready\");\n    A(this, Pt, !1);\n    A(this, G, {\n      duration: 0,\n      width: 0,\n      height: 0,\n      audioSampleRate: 0,\n      audioChanCount: 0\n    });\n    A(this, K);\n    A(this, Lt, 1);\n    A(this, st, []);\n    A(this, wt, null);\n    A(this, bt, null);\n    A(this, St, {\n      video: null,\n      audio: null\n    });\n    A(this, V, { audio: !0 });\n    R(this, \"tickInterceptor\", async (r, h) => h);\n    A(this, Q, new AbortController());\n    if (!(r instanceof ReadableStream) && !ne(r) && !Array.isArray(r.videoSamples))\n      throw Error(\"Illegal argument\");\n    E(this, V, { audio: !0, ...h }), E(this, Lt, typeof h.audio == \"object\" && \"volume\" in h.audio ? h.audio.volume : 1);\n    const a = async (f) => (await Ct(m(this, K), f), await m(this, K).stream());\n    E(this, K, ne(r) ? r : \"localFile\" in r ? r.localFile : Kt()), this.ready = (r instanceof ReadableStream ? a(r).then((f) => xe(f, m(this, V))) : ne(r) ? r.stream().then((f) => xe(f, m(this, V))) : Promise.resolve(r)).then(async ({ videoSamples: f, audioSamples: d, decoderConf: p }) => {\n      E(this, st, f), E(this, St, p);\n      const { videoFrameFinder: n, audioFrameFinder: v } = Ii(\n        {\n          video: p.video == null ? null : {\n            ...p.video,\n            hardwareAcceleration: m(this, V).__unsafe_hardwareAcceleration__\n          },\n          audio: p.audio\n        },\n        await m(this, K).createReader(),\n        f,\n        d,\n        m(this, V).audio !== !1 ? m(this, Lt) : 0\n      );\n      return E(this, wt, n), E(this, bt, v), E(this, G, Fi(p, f, d)), m(this, Tt).info(\"MP4Clip meta:\", m(this, G)), { ...m(this, G) };\n    });\n  }\n  get meta() {\n    return { ...m(this, G) };\n  }\n  async tick(r) {\n    var f, d;\n    if (r >= m(this, G).duration)\n      return await this.tickInterceptor(r, {\n        audio: [],\n        state: \"done\"\n      });\n    const [h, a] = await Promise.all([\n      ((f = m(this, bt)) == null ? void 0 : f.find(r)) ?? [],\n      (d = m(this, wt)) == null ? void 0 : d.find(r)\n    ]);\n    return a == null ? await this.tickInterceptor(r, {\n      audio: h,\n      state: \"success\"\n    }) : await this.tickInterceptor(r, {\n      video: a,\n      audio: h,\n      state: \"success\"\n    });\n  }\n  async thumbnails(r = 100, h) {\n    m(this, Q).abort(), E(this, Q, new AbortController());\n    const a = m(this, Q).signal;\n    await this.ready;\n    const f = \"generate thumbnails aborted\";\n    if (a.aborted) throw Error(f);\n    const { width: d, height: p } = m(this, G), n = Ue(\n      r,\n      Math.round(p * (r / d)),\n      { quality: 0.1, type: \"image/png\" }\n    );\n    return new Promise(\n      async (v, b) => {\n        let y = [];\n        const B = m(this, St).video;\n        if (B == null || m(this, st).length === 0) {\n          t();\n          return;\n        }\n        a.addEventListener(\"abort\", () => {\n          b(Error(f));\n        });\n        async function t() {\n          a.aborted || v(\n            await Promise.all(\n              y.map(async (_) => ({\n                ts: _.ts,\n                img: await _.img\n              }))\n            )\n          );\n        }\n        function e(_) {\n          y.push({\n            ts: _.timestamp,\n            img: n(_)\n          });\n        }\n        const { start: i = 0, end: s = m(this, G).duration, step: o = 1e6 } = h ?? {};\n        let c = i;\n        const u = new oe(\n          await m(this, K).createReader(),\n          m(this, st),\n          {\n            ...B,\n            hardwareAcceleration: m(this, V).__unsafe_hardwareAcceleration__\n          }\n        );\n        for (; c <= s && !a.aborted; ) {\n          const _ = await u.find(c);\n          _ && e(_), c += o;\n        }\n        u.destroy(), t();\n      }\n    );\n  }\n  async thumbnailsList(r = 100, h) {\n    var v;\n    if (((v = h == null ? void 0 : h.timestamps) == null ? void 0 : v.length) === 0) return [];\n    m(this, Q).abort(), E(this, Q, new AbortController());\n    const a = m(this, Q).signal;\n    await this.ready;\n    const f = \"generate thumbnails aborted\";\n    if (a.aborted) throw Error(f);\n    const { width: d, height: p } = m(this, G), n = Ue(\n      r,\n      Math.round(p * (r / d)),\n      { quality: 0.1, type: \"image/png\" }\n    );\n    return new Promise(\n      async (b, y) => {\n        let B = [];\n        const t = m(this, St).video;\n        if (t == null || m(this, st).length === 0) {\n          e();\n          return;\n        }\n        a.addEventListener(\"abort\", () => {\n          y(Error(f));\n        });\n        async function e() {\n          a.aborted || b(\n            await Promise.all(\n              B.map(async (c) => ({\n                ts: c.ts,\n                img: await c.img\n              }))\n            )\n          );\n        }\n        function i(c) {\n          B.push({\n            ts: c.timestamp,\n            img: n(c)\n          });\n        }\n        const s = (h == null ? void 0 : h.timestamps) ?? [];\n        if (s.length === 0) {\n          e();\n          return;\n        }\n        const o = new oe(\n          await m(this, K).createReader(),\n          m(this, st),\n          {\n            ...t,\n            hardwareAcceleration: m(this, V).__unsafe_hardwareAcceleration__\n          }\n        );\n        for (const c of s) {\n          if (a.aborted) break;\n          const u = await o.find(c);\n          u && i(u);\n        }\n        o.destroy(), e();\n      }\n    );\n  }\n  destroy() {\n    var r, h;\n    m(this, Pt) || (m(this, Tt).info(\"MP4Clip destroy\"), E(this, Pt, !0), (r = m(this, wt)) == null || r.destroy(), (h = m(this, bt)) == null || h.destroy());\n  }\n}\nTt = new WeakMap(), Pt = new WeakMap(), G = new WeakMap(), K = new WeakMap(), Lt = new WeakMap(), st = new WeakMap(), wt = new WeakMap(), bt = new WeakMap(), St = new WeakMap(), V = new WeakMap(), Q = new WeakMap();\nfunction Fi(l, r, h) {\n  const a = {\n    duration: 0,\n    width: 0,\n    height: 0,\n    audioSampleRate: 0,\n    audioChanCount: 0\n  };\n  l.video != null && r.length > 0 && (a.width = l.video.codedWidth ?? 0, a.height = l.video.codedHeight ?? 0), l.audio != null && h.length > 0 && (a.audioSampleRate = q.sampleRate, a.audioChanCount = q.channelCount);\n  let f = 0, d = 0;\n  if (r.length > 0)\n    for (let p = r.length - 1; p >= 0; p--) {\n      const n = r[p];\n      if (!n.deleted) {\n        f = n.cts + n.duration;\n        break;\n      }\n    }\n  if (h.length > 0) {\n    const p = h.at(-1);\n    d = p.cts + p.duration;\n  }\n  return a.duration = Math.max(f, d), a;\n}\nfunction Ii(l, r, h, a, f) {\n  return {\n    audioFrameFinder: f === 0 || l.audio == null || a.length === 0 ? null : new Ci(\n      r,\n      a,\n      l.audio,\n      {\n        volume: f,\n        targetSampleRate: q.sampleRate\n      }\n    ),\n    videoFrameFinder: l.video == null || h.length === 0 ? null : new oe(\n      r,\n      h,\n      l.video\n    )\n  };\n}\nasync function xe(l, r = {}) {\n  let h;\n  const a = { video: null, audio: null };\n  let f = [], d = [];\n  return new Promise(async (n, v) => {\n    let b = -1, y = -1;\n    const B = fe(l.pipeThrough(new ce()), {\n      onChunk: async ({ chunkType: t, data: e }) => {\n        if (t === \"ready\") {\n          h = e.info;\n          let { videoDecoderConf: i, audioDecoderConf: s } = de(e.file, e.info);\n          a.video = i ?? null, a.audio = s ?? null, i == null && s == null && (B(), v(\n            Error(\"MP4Clip must contain at least one video or audio track\")\n          )), z.info(\n            \"mp4BoxFile moov ready\",\n            {\n              ...e.info,\n              tracks: null,\n              videoTracks: null,\n              audioTracks: null\n            },\n            a\n          );\n        } else if (t === \"samples\") {\n          if (e.type === \"video\") {\n            b === -1 && (b = e.samples[0].dts);\n            for (const i of e.samples)\n              f.push(p(i, b, \"video\"));\n          } else if (e.type === \"audio\" && r.audio) {\n            y === -1 && (y = e.samples[0].dts);\n            for (const i of e.samples)\n              d.push(p(i, y, \"audio\"));\n          }\n        }\n      },\n      onDone: () => {\n        const t = f.at(-1) ?? d.at(-1);\n        if (h == null) {\n          v(Error(\"MP4Clip stream is done, but not emit ready\"));\n          return;\n        } else if (t == null) {\n          v(Error(\"MP4Clip stream not contain any sample\"));\n          return;\n        }\n        const e = f[0];\n        e != null && e.cts < 2e5 && (e.duration += e.cts, e.cts = 0), z.info(\"mp4 stream parsed\"), n({\n          videoSamples: f,\n          audioSamples: d,\n          decoderConf: a\n        });\n      }\n    });\n  });\n  function p(n, v = 0, b) {\n    return {\n      ...n,\n      is_idr: b === \"video\" && n.is_sync && Di(n.data, n.description.type),\n      cts: (n.cts - v) / n.timescale * 1e6,\n      dts: (n.dts - v) / n.timescale * 1e6,\n      duration: n.duration / n.timescale * 1e6,\n      timescale: 1e6,\n      data: b === \"video\" ? null : n.data\n    };\n  }\n}\nvar L, lt, ft, kt, dt, W, k, rt, ct, xt, at, Dt, ut, Jt;\nclass oe {\n  constructor(r, h, a) {\n    A(this, L, null);\n    A(this, lt, 0);\n    A(this, ft, { abort: !1, st: performance.now() });\n    R(this, \"find\", async (r) => ((m(this, L) == null || r <= m(this, lt) || r - m(this, lt) > 3e6) && m(this, ut).call(this, r), m(this, ft).abort = !0, E(this, lt, r), E(this, ft, { abort: !1, st: performance.now() }), await m(this, xt).call(this, r, m(this, L), m(this, ft))));\n    // fix VideoFrame duration is null\n    A(this, kt, 0);\n    A(this, dt, !1);\n    A(this, W, 0);\n    A(this, k, []);\n    A(this, rt, 0);\n    A(this, ct, 0);\n    A(this, xt, async (r, h, a) => {\n      if (h == null || h.state === \"closed\" || a.abort) return null;\n      if (m(this, k).length > 0) {\n        const f = m(this, k)[0];\n        return r < f.timestamp ? null : (m(this, k).shift(), r > f.timestamp + (f.duration ?? 0) ? (f.close(), await m(this, xt).call(this, r, h, a)) : (m(this, k).length < 10 && m(this, Dt).call(this, h).catch((d) => {\n          throw m(this, ut).call(this, r), d;\n        }), f));\n      }\n      if (m(this, at) || m(this, rt) < m(this, ct) && h.decodeQueueSize > 0) {\n        if (performance.now() - a.st > 6e3)\n          throw Error(\n            `MP4Clip.tick video timeout, ${JSON.stringify(m(this, Jt).call(this))}`\n          );\n        await Ne(15);\n      } else {\n        if (m(this, W) >= this.samples.length)\n          return null;\n        try {\n          await m(this, Dt).call(this, h);\n        } catch (f) {\n          throw m(this, ut).call(this, r), f;\n        }\n      }\n      return await m(this, xt).call(this, r, h, a);\n    });\n    A(this, at, !1);\n    A(this, Dt, async (r) => {\n      var f, d;\n      if (m(this, at)) return;\n      E(this, at, !0);\n      let h = m(this, W) + 1, a = !1;\n      for (; h < this.samples.length; h++) {\n        const p = this.samples[h];\n        if (!a && !p.deleted && (a = !0), p.is_idr) break;\n      }\n      if (a) {\n        const p = this.samples.slice(m(this, W), h);\n        if (((f = p[0]) == null ? void 0 : f.is_idr) !== !0)\n          z.warn(\"First sample not idr frame\");\n        else {\n          const n = await Li(p, this.localFileReader);\n          if (r.state === \"closed\") return;\n          E(this, kt, ((d = n[0]) == null ? void 0 : d.duration) ?? 0), ki(r, n, {\n            onDecodingError: (v) => {\n              if (m(this, dt))\n                throw v;\n              m(this, rt) === 0 && (E(this, dt, !0), z.warn(\"Downgrade to software decode\"), m(this, ut).call(this));\n            }\n          }), E(this, ct, m(this, ct) + n.length);\n        }\n      }\n      E(this, W, h), E(this, at, !1);\n    });\n    A(this, ut, (r) => {\n      var h, a;\n      if (E(this, at, !1), m(this, k).forEach((f) => f.close()), E(this, k, []), r == null || r === 0)\n        E(this, W, 0);\n      else {\n        let f = 0;\n        for (let d = 0; d < this.samples.length; d++) {\n          const p = this.samples[d];\n          if (p.is_idr && (f = d), !(p.cts < r)) {\n            E(this, W, f);\n            break;\n          }\n        }\n      }\n      E(this, ct, 0), E(this, rt, 0), ((h = m(this, L)) == null ? void 0 : h.state) !== \"closed\" && ((a = m(this, L)) == null || a.close()), E(this, L, new VideoDecoder({\n        output: (f) => {\n          if (E(this, rt, m(this, rt) + 1), f.timestamp === -1) {\n            f.close();\n            return;\n          }\n          let d = f;\n          f.duration == null && (d = new VideoFrame(f, {\n            duration: m(this, kt)\n          }), f.close()), m(this, k).push(d);\n        },\n        error: (f) => {\n          z.error(`MP4Clip VideoDecoder err: ${f.message}`);\n        }\n      })), m(this, L).configure({\n        ...this.conf,\n        ...m(this, dt) ? { hardwareAcceleration: \"prefer-software\" } : {}\n      });\n    });\n    A(this, Jt, () => {\n      var r, h;\n      return {\n        time: m(this, lt),\n        decState: (r = m(this, L)) == null ? void 0 : r.state,\n        decQSize: (h = m(this, L)) == null ? void 0 : h.decodeQueueSize,\n        decCusorIdx: m(this, W),\n        sampleLen: this.samples.length,\n        inputCnt: m(this, ct),\n        outputCnt: m(this, rt),\n        cacheFrameLen: m(this, k).length,\n        softDeocde: m(this, dt)\n      };\n    });\n    R(this, \"destroy\", () => {\n      var r, h;\n      ((r = m(this, L)) == null ? void 0 : r.state) !== \"closed\" && ((h = m(this, L)) == null || h.close()), E(this, L, null), m(this, ft).abort = !0, m(this, k).forEach((a) => a.close()), E(this, k, []), this.localFileReader.close();\n    });\n    this.localFileReader = r, this.samples = h, this.conf = a;\n  }\n}\nL = new WeakMap(), lt = new WeakMap(), ft = new WeakMap(), kt = new WeakMap(), dt = new WeakMap(), W = new WeakMap(), k = new WeakMap(), rt = new WeakMap(), ct = new WeakMap(), xt = new WeakMap(), at = new WeakMap(), Dt = new WeakMap(), ut = new WeakMap(), Jt = new WeakMap();\nvar Rt, Mt, Z, pt, X, J, j, Ot, Nt, $t, qt;\nclass Ci {\n  constructor(r, h, a, f) {\n    A(this, Rt, 1);\n    A(this, Mt);\n    A(this, Z, null);\n    A(this, pt, { abort: !1, st: performance.now() });\n    R(this, \"find\", async (r) => {\n      if (m(this, Z) == null || r <= m(this, X) || r - m(this, X) > 1e5) {\n        m(this, $t).call(this), E(this, X, r);\n        for (let a = 0; a < this.samples.length; a++)\n          if (!(this.samples[a].cts < r)) {\n            E(this, J, a);\n            break;\n          }\n        return [];\n      }\n      m(this, pt).abort = !0;\n      const h = r - m(this, X);\n      return E(this, X, r), E(this, pt, { abort: !1, st: performance.now() }), await m(this, Ot).call(this, h, m(this, Z), m(this, pt));\n    });\n    A(this, X, 0);\n    A(this, J, 0);\n    A(this, j, {\n      frameCnt: 0,\n      data: []\n    });\n    A(this, Ot, async (r, h = null, a) => {\n      if (h == null || a.abort || h.state === \"closed\") return [];\n      const f = Math.ceil(r * (m(this, Mt) / 1e6));\n      if (f === 0) return [];\n      const d = m(this, j).frameCnt - f;\n      if (d > 0)\n        return d < q.sampleRate / 10 && m(this, Nt).call(this, h), Pi(m(this, j), f);\n      if (h.decodeQueueSize > 10) {\n        if (performance.now() - a.st > 3e3)\n          throw a.abort = !0, Error(\n            `MP4Clip.tick audio timeout, ${JSON.stringify(m(this, qt).call(this))}`\n          );\n        await Ne(15);\n      } else {\n        if (m(this, J) >= this.samples.length - 1)\n          return [];\n        m(this, Nt).call(this, h);\n      }\n      return m(this, Ot).call(this, r, h, a);\n    });\n    A(this, Nt, (r) => {\n      if (r.decodeQueueSize > 100) return;\n      const h = [];\n      let a = m(this, J);\n      for (; a < this.samples.length; ) {\n        const f = this.samples[a];\n        if (a += 1, !f.deleted && (h.push(f), h.length >= 10))\n          break;\n      }\n      E(this, J, a), r.decode(\n        h.map(\n          (f) => new EncodedAudioChunk({\n            type: \"key\",\n            timestamp: f.cts,\n            duration: f.duration,\n            data: f.data\n          })\n        )\n      );\n    });\n    A(this, $t, () => {\n      var r;\n      E(this, X, 0), E(this, J, 0), E(this, j, {\n        frameCnt: 0,\n        data: []\n      }), (r = m(this, Z)) == null || r.close(), E(this, Z, zi(\n        this.conf,\n        {\n          resampleRate: q.sampleRate,\n          volume: m(this, Rt)\n        },\n        (h) => {\n          m(this, j).data.push(h), m(this, j).frameCnt += h[0].length;\n        }\n      ));\n    });\n    A(this, qt, () => {\n      var r, h;\n      return {\n        time: m(this, X),\n        decState: (r = m(this, Z)) == null ? void 0 : r.state,\n        decQSize: (h = m(this, Z)) == null ? void 0 : h.decodeQueueSize,\n        decCusorIdx: m(this, J),\n        sampleLen: this.samples.length,\n        pcmLen: m(this, j).frameCnt\n      };\n    });\n    R(this, \"destroy\", () => {\n      E(this, Z, null), m(this, pt).abort = !0, E(this, j, {\n        frameCnt: 0,\n        data: []\n      }), this.localFileReader.close();\n    });\n    this.localFileReader = r, this.samples = h, this.conf = a, E(this, Rt, f.volume), E(this, Mt, f.targetSampleRate);\n  }\n}\nRt = new WeakMap(), Mt = new WeakMap(), Z = new WeakMap(), pt = new WeakMap(), X = new WeakMap(), J = new WeakMap(), j = new WeakMap(), Ot = new WeakMap(), Nt = new WeakMap(), $t = new WeakMap(), qt = new WeakMap();\nfunction zi(l, r, h) {\n  const a = (n) => {\n    if (n.length !== 0) {\n      if (r.volume !== 1)\n        for (const v of n)\n          for (let b = 0; b < v.length; b++) v[b] *= r.volume;\n      n.length === 1 && (n = [n[0], n[0]]), h(n);\n    }\n  }, f = Ti(a), d = r.resampleRate !== l.sampleRate, p = new AudioDecoder({\n    output: (n) => {\n      const v = le(n);\n      d ? f(\n        () => bi(v, n.sampleRate, {\n          rate: r.resampleRate,\n          chanCount: n.numberOfChannels\n        })\n      ) : a(v), n.close();\n    },\n    error: (n) => {\n      z.error(`MP4Clip AudioDecoder err: ${n.message}`);\n    }\n  });\n  return p.configure(l), {\n    decode(n) {\n      for (const v of n) p.decode(v);\n    },\n    close() {\n      p.state !== \"closed\" && p.close();\n    },\n    get state() {\n      return p.state;\n    },\n    get decodeQueueSize() {\n      return p.decodeQueueSize;\n    }\n  };\n}\nfunction Ti(l) {\n  const r = [];\n  let h = 0;\n  function a(p, n) {\n    r[n] = p, f();\n  }\n  function f() {\n    const p = r[h];\n    p != null && (l(p), h += 1, f());\n  }\n  let d = 0;\n  return (p) => {\n    const n = d;\n    d += 1, p().then((v) => a(v, n)).catch((v) => a(v, n));\n  };\n}\nfunction Pi(l, r) {\n  const h = [new Float32Array(r), new Float32Array(r)];\n  let a = 0, f = 0;\n  for (; f < l.data.length; ) {\n    const [d, p] = l.data[f];\n    if (a + d.length > r) {\n      const n = r - a;\n      h[0].set(d.subarray(0, n), a), h[1].set(p.subarray(0, n), a), l.data[f][0] = d.subarray(n, d.length), l.data[f][1] = p.subarray(n, p.length);\n      break;\n    } else\n      h[0].set(d, a), h[1].set(p, a), a += d.length, f++;\n  }\n  return l.data = l.data.slice(f), l.frameCnt -= r, h;\n}\nasync function Li(l, r) {\n  const h = l[0], a = l.at(-1);\n  if (a == null) return [];\n  const f = a.offset + a.size - h.offset;\n  if (f < 3e7) {\n    const d = new Uint8Array(\n      await r.read(f, { at: h.offset })\n    );\n    return l.map((p) => {\n      const n = p.offset - h.offset;\n      let v = d.subarray(n, n + p.size);\n      return p.is_idr && (v = Ee(v)), new EncodedVideoChunk({\n        type: p.is_sync ? \"key\" : \"delta\",\n        timestamp: p.cts,\n        duration: p.duration,\n        data: v\n      });\n    });\n  }\n  return await Promise.all(\n    l.map(async (d) => {\n      let p = await r.read(d.size, {\n        at: d.offset\n      });\n      return d.is_idr && (p = Ee(new Uint8Array(p))), new EncodedVideoChunk({\n        type: d.is_sync ? \"key\" : \"delta\",\n        timestamp: d.cts,\n        duration: d.duration,\n        data: p\n      });\n    })\n  );\n}\nfunction Ue(l, r, h) {\n  const a = new OffscreenCanvas(l, r), f = a.getContext(\"2d\");\n  return async (d) => (f.drawImage(d, 0, 0, l, r), d.close(), await a.convertToBlob(h));\n}\nfunction ki(l, r, h) {\n  let a = 0;\n  if (l.state === \"configured\") {\n    for (; a < r.length; a++) l.decode(r[a]);\n    l.flush().catch((f) => {\n      if (!(f instanceof Error)) throw f;\n      if (f.message.includes(\"Decoding error\") && h.onDecodingError != null) {\n        h.onDecodingError(f);\n        return;\n      }\n      if (!f.message.includes(\"Aborted due to close\"))\n        throw f;\n    });\n  }\n}\nfunction Ee(l) {\n  const r = new DataView(l.buffer, l.byteOffset, l.byteLength);\n  return (r.getUint8(4) & 31) === 6 ? l.subarray(r.getUint32(0) + 4) : l;\n}\nfunction Di(l, r) {\n  if (r !== \"avc1\" && r !== \"hvc1\") return !1;\n  const h = new DataView(l.buffer);\n  let a = 0;\n  for (; a < l.byteLength - 4; ) {\n    if (r === \"avc1\") {\n      if ((h.getUint8(a + 4) & 31) === 5) return !0;\n    } else if (r === \"hvc1\" && (h.getUint8(a + 4) >> 1 & 63) === 20)\n      return !0;\n    a += h.getUint32(a) + 4;\n  }\n  return !1;\n}\nvar $;\nclass Ri {\n  constructor() {\n    A(this, $, /* @__PURE__ */ new Map());\n    R(this, \"on\", (r, h) => {\n      const a = m(this, $).get(r) ?? /* @__PURE__ */ new Set();\n      return a.add(h), m(this, $).has(r) || m(this, $).set(r, a), () => {\n        a.delete(h), a.size === 0 && m(this, $).delete(r);\n      };\n    });\n    R(this, \"once\", (r, h) => {\n      const a = this.on(r, (...f) => {\n        a(), h(...f);\n      });\n      return a;\n    });\n    R(this, \"emit\", (r, ...h) => {\n      const a = m(this, $).get(r);\n      a != null && a.forEach((f) => f(...h));\n    });\n  }\n  static forwardEvent(r, h, a) {\n    const f = a.map((d) => {\n      const [p, n] = Array.isArray(d) ? d : [d, d];\n      return r.on(p, (...v) => {\n        h.emit(n, ...v);\n      });\n    });\n    return () => {\n      f.forEach((d) => d());\n    };\n  }\n  destroy() {\n    m(this, $).clear();\n  }\n}\n$ = new WeakMap();\nconst ue = (l, r) => {\n  const h = new Uint8Array(8);\n  new DataView(h.buffer).setUint32(0, r);\n  for (let f = 0; f < 4; f++)\n    h[4 + f] = l.charCodeAt(f);\n  return h;\n}, Mi = () => {\n  const l = new TextEncoder(), r = l.encode(\"mdta\"), h = l.encode(\"mp4 handler\"), a = 32 + h.byteLength + 1, f = new Uint8Array(a), d = new DataView(f.buffer);\n  return f.set(ue(\"hdlr\", a), 0), d.setUint32(8, 0), f.set(r, 16), f.set(h, 32), f;\n}, Oi = (l) => {\n  const r = new TextEncoder(), h = r.encode(\"mdta\"), a = l.map((b) => {\n    const y = r.encode(b), B = 8 + y.byteLength, t = new Uint8Array(B);\n    return new DataView(t.buffer).setUint32(0, B), t.set(h, 4), t.set(y, 4 + h.byteLength), t;\n  }), d = 16 + a.reduce((b, y) => b + y.byteLength, 0), p = new Uint8Array(d), n = new DataView(p.buffer);\n  p.set(ue(\"keys\", d), 0), n.setUint32(8, 0), n.setUint32(12, l.length);\n  let v = 16;\n  for (const b of a)\n    p.set(b, v), v += b.byteLength;\n  return p;\n}, Ni = (l) => {\n  const r = new TextEncoder(), h = r.encode(\"data\"), a = Object.entries(l).map(([v, b], y) => {\n    const B = y + 1, t = r.encode(b), e = 24 + t.byteLength, i = new Uint8Array(e), s = new DataView(i.buffer);\n    return s.setUint32(0, e), s.setUint32(4, B), s.setUint32(8, 16 + t.byteLength), i.set(h, 12), s.setUint32(16, 1), i.set(t, 24), i;\n  }), d = 8 + a.reduce((v, b) => v + b.byteLength, 0), p = new Uint8Array(d);\n  p.set(ue(\"ilst\", d), 0);\n  let n = 8;\n  for (const v of a)\n    p.set(v, n), n += v.byteLength;\n  return p;\n}, Gi = (l) => {\n  const r = Mi(), h = Oi(Object.keys(l)), a = Ni(l), f = r.length + h.length + a.length, d = new Uint8Array(f);\n  return d.set(r, 0), d.set(h, r.length), d.set(a, r.length + h.length), d;\n};\nfunction rn(l) {\n  z.info(\"recodemux opts:\", l);\n  const r = D.createFile(), h = new Ri(), a = (v, b) => {\n    const B = v.add(\"udta\").add(\"meta\");\n    B.data = Gi(b), B.size = B.data.byteLength;\n  };\n  let f = !1;\n  const d = () => {\n    r.moov == null || f || (f = !0, l.metaDataTags != null && a(r.moov, l.metaDataTags), l.duration != null && (r.moov.mvhd.duration = l.duration));\n  };\n  h.once(\"VideoReady\", d), h.once(\"AudioReady\", d);\n  let p = l.video != null ? Hi(l.video, r, h) : null, n = l.audio != null ? Vi(l.audio, r, h) : null;\n  return l.video == null && h.emit(\"VideoReady\"), l.audio == null && h.emit(\"AudioReady\"), {\n    encodeVideo: (v, b) => {\n      p == null || p.encode(v, b), v.close();\n    },\n    encodeAudio: (v) => {\n      n != null && (n.encode(v), v.close());\n    },\n    getEncodeQueueSize: () => (p == null ? void 0 : p.encodeQueueSize) ?? (n == null ? void 0 : n.encodeQueueSize) ?? 0,\n    flush: async () => {\n      await Promise.all([\n        p == null ? void 0 : p.flush(),\n        (n == null ? void 0 : n.state) === \"configured\" ? n.flush() : null\n      ]);\n    },\n    close: () => {\n      h.destroy(), p == null || p.close(), (n == null ? void 0 : n.state) === \"configured\" && n.close();\n    },\n    mp4file: r\n  };\n}\nfunction Hi(l, r, h) {\n  const a = {\n    timescale: 1e6,\n    width: l.width,\n    height: l.height,\n    brands: [\"isom\", \"iso2\", \"avc1\", \"mp42\", \"mp41\"],\n    avcDecoderConfigRecord: null,\n    name: \"Track created with WebAV\"\n  };\n  let f = -1, d = !1;\n  h.once(\"AudioReady\", () => {\n    d = !0;\n  });\n  const p = {\n    encoder0: [],\n    encoder1: []\n  }, n = (c, u, _) => {\n    var g;\n    if (f === -1 && _ != null) {\n      const w = (g = _.decoderConfig) == null ? void 0 : g.description;\n      Yi(w), a.avcDecoderConfigRecord = w, f = r.addTrack(a), h.emit(\"VideoReady\"), z.info(\"VideoEncoder, video track ready, trackId:\", f);\n    }\n    p[c].push(Qt(u));\n  };\n  let v = \"encoder1\", b = 0;\n  const y = Math.floor(1e3 / l.expectFPS * 1e3);\n  function B() {\n    if (!d) return;\n    const c = v === \"encoder1\" ? \"encoder0\" : \"encoder1\", u = p[v], _ = p[c];\n    if (u.length === 0 && _.length === 0) return;\n    let g = u[0];\n    if (g != null && (!g.is_sync || g.cts - b < y)) {\n      const S = t(u);\n      S > b && (b = S);\n    }\n    const w = _[0];\n    if (w != null && w.is_sync && w.cts - b < y) {\n      v = c, B();\n      return;\n    }\n    if (g != null && g.is_sync && (w != null && w.is_sync))\n      if (g.cts <= w.cts) {\n        const S = t(u);\n        S > b && (b = S);\n      } else {\n        v = c, B();\n        return;\n      }\n  }\n  function t(c) {\n    let u = -1, _ = 0;\n    for (; _ < c.length; _++) {\n      const g = c[_];\n      if (_ > 0 && g.is_sync) break;\n      r.addSample(f, g.data, g), u = g.cts + g.duration;\n    }\n    return c.splice(0, _), u;\n  }\n  const e = De(B, 15), i = Ae(\n    l,\n    (c, u) => n(\"encoder0\", c, u)\n  ), s = Ae(\n    l,\n    (c, u) => n(\"encoder1\", c, u)\n  );\n  let o = 0;\n  return {\n    get encodeQueueSize() {\n      return i.encodeQueueSize + s.encodeQueueSize;\n    },\n    encode: (c, u) => {\n      u.keyFrame && (o += 1), (o % 2 === 0 ? i : s).encode(c, u);\n    },\n    flush: async () => {\n      await Promise.all([\n        i.state === \"configured\" ? await i.flush() : null,\n        s.state === \"configured\" ? await s.flush() : null\n      ]), e(), B();\n    },\n    close: () => {\n      i.state === \"configured\" && i.close(), s.state === \"configured\" && s.close();\n    }\n  };\n}\nfunction Yi(l) {\n  const r = new Uint8Array(l);\n  r[2].toString(2).slice(-2).includes(\"1\") && (r[2] = 0);\n}\nfunction Ae(l, r) {\n  const h = new VideoEncoder({\n    error: z.error,\n    output: r\n  });\n  return h.configure({\n    codec: l.codec,\n    framerate: l.expectFPS,\n    hardwareAcceleration: l.__unsafe_hardwareAcceleration__,\n    bitrate: l.bitrate,\n    width: l.width,\n    height: l.height,\n    alpha: \"discard\",\n    avc: { format: \"avc\" }\n  }), h;\n}\nfunction Vi(l, r, h) {\n  const a = {\n    timescale: 1e6,\n    samplerate: l.sampleRate,\n    channel_count: l.channelCount,\n    hdlr: \"soun\",\n    type: l.codec === \"aac\" ? \"mp4a\" : \"Opus\",\n    name: \"Track created with WebAV\"\n  };\n  let f = -1, d = [], p = !1;\n  h.once(\"VideoReady\", () => {\n    p = !0, d.forEach((v) => {\n      const b = Qt(v);\n      r.addSample(f, b.data, b);\n    }), d = [];\n  });\n  const n = new AudioEncoder({\n    error: z.error,\n    output: (v, b) => {\n      var y;\n      if (f === -1) {\n        const B = (y = b.decoderConfig) == null ? void 0 : y.description;\n        f = r.addTrack({\n          ...a,\n          description: B == null ? void 0 : $i(B)\n        }), h.emit(\"AudioReady\"), z.info(\"AudioEncoder, audio track ready, trackId:\", f);\n      }\n      if (p) {\n        const B = Qt(v);\n        r.addSample(f, B.data, B);\n      } else\n        d.push(v);\n    }\n  });\n  return n.configure({\n    codec: l.codec === \"aac\" ? q.codec : \"opus\",\n    sampleRate: l.sampleRate,\n    numberOfChannels: l.channelCount,\n    bitrate: 128e3\n  }), n;\n}\nfunction Wi(l, r, h) {\n  let a = 0, f = 0;\n  const d = l.boxes;\n  let p = !1;\n  const n = () => {\n    var i;\n    if (!p)\n      if (d.find((s) => s.type === \"moof\") != null)\n        p = !0;\n      else\n        return null;\n    if (f >= d.length) return null;\n    const t = new D.DataStream();\n    t.endianness = D.DataStream.BIG_ENDIAN;\n    let e = f;\n    try {\n      for (; e < d.length; )\n        d[e].write(t), delete d[e], e += 1;\n    } catch (s) {\n      const o = d[e];\n      throw s instanceof Error && o != null ? Error(\n        `${s.message} | deltaBuf( boxType: ${o.type}, boxSize: ${o.size}, boxDataLen: ${((i = o.data) == null ? void 0 : i.length) ?? -1})`\n      ) : s;\n    }\n    return Ai(l), f = d.length, new Uint8Array(t.buffer);\n  };\n  let v = !1, b = !1, y = null;\n  return {\n    stream: new ReadableStream({\n      start(t) {\n        a = self.setInterval(() => {\n          const e = n();\n          e != null && !b && t.enqueue(e);\n        }, r), y = (e) => {\n          if (clearInterval(a), l.flush(), e != null) {\n            t.error(e);\n            return;\n          }\n          const i = n();\n          i != null && !b && t.enqueue(i), b || t.close();\n        }, v && y();\n      },\n      cancel() {\n        b = !0, clearInterval(a), h == null || h();\n      }\n    }),\n    stop: (t) => {\n      v || (v = !0, y == null || y(t));\n    }\n  };\n}\nfunction Zi(l) {\n  let r = 0;\n  const h = l.boxes, a = [];\n  let f = 0;\n  async function d() {\n    const i = e(h, r);\n    r = h.length, a.forEach(({ track: s, id: o }) => {\n      const c = s.samples.at(-1);\n      c != null && (f = Math.max(f, c.cts + c.duration)), l.releaseUsedSamples(o, s.samples.length), s.samples = [];\n    }), l.mdats = [], l.moofs = [], i != null && await (y == null ? void 0 : y.write(i));\n  }\n  let p = [];\n  function n() {\n    if (p.length > 0) return !0;\n    const i = h.findIndex((s) => s.type === \"moov\");\n    if (i === -1) return !1;\n    if (p = h.slice(0, i + 1), r = i + 1, a.length === 0)\n      for (let s = 1; ; s += 1) {\n        const o = l.getTrackById(s);\n        if (o == null) break;\n        a.push({ track: o, id: s });\n      }\n    return !0;\n  }\n  let v = 0;\n  const b = Kt();\n  let y = null;\n  const B = (async () => {\n    y = await b.createWriter(), v = self.setInterval(() => {\n      n() && d();\n    }, 100);\n  })();\n  let t = !1;\n  return async () => {\n    if (t) throw Error(\"File exported\");\n    if (t = !0, await B, clearInterval(v), !n() || y == null) return null;\n    l.flush(), await d(), await (y == null ? void 0 : y.close());\n    const i = p.find((c) => c.type === \"moov\");\n    if (i == null) return null;\n    i.mvhd.duration = f;\n    const s = Kt(), o = e(p, 0);\n    return await Ct(s, o), await Ct(s, b, { overwrite: !1 }), await s.stream();\n  };\n  function e(i, s) {\n    if (s >= i.length) return null;\n    const o = new D.DataStream();\n    o.endianness = D.DataStream.BIG_ENDIAN;\n    for (let c = s; c < i.length; c++)\n      i[c] !== null && (i[c].write(o), delete i[c]);\n    return new Uint8Array(o.buffer);\n  }\n}\nfunction Qt(l) {\n  const r = new ArrayBuffer(l.byteLength);\n  l.copyTo(r);\n  const h = l.timestamp;\n  return {\n    duration: l.duration ?? 0,\n    dts: h,\n    cts: h,\n    is_sync: l.type === \"key\",\n    data: r\n  };\n}\nasync function Xi(l) {\n  const r = D.createFile(), h = Zi(r);\n  await ji(l, r);\n  const a = await h();\n  if (a == null) throw Error(\"Can not generate file from streams\");\n  return a;\n}\nasync function ji(l, r) {\n  let h = 0, a = 0, f = 0, d = 0, p = 0, n = 0, v = null, b = null;\n  for (const y of l)\n    await new Promise(async (B) => {\n      fe(y.pipeThrough(new ce()), {\n        onDone: B,\n        onChunk: async ({ chunkType: t, data: e }) => {\n          if (t === \"ready\") {\n            const { videoTrackConf: i, audioTrackConf: s } = de(\n              e.file,\n              e.info\n            );\n            h === 0 && i != null && (h = r.addTrack(i)), d === 0 && s != null && (d = r.addTrack(s));\n          } else if (t === \"samples\") {\n            const { type: i, samples: s } = e, o = i === \"video\" ? h : d, c = i === \"video\" ? a : p, u = i === \"video\" ? f : n;\n            s.forEach((g) => {\n              r.addSample(o, g.data, {\n                duration: g.duration,\n                dts: g.dts + c,\n                cts: g.cts + u,\n                is_sync: g.is_sync\n              });\n            });\n            const _ = s.at(-1);\n            if (_ == null) return;\n            i === \"video\" ? v = _ : i === \"audio\" && (b = _);\n          }\n        }\n      });\n    }), v != null && (a += v.dts, f += v.cts), b != null && (p += b.dts, n += b.cts);\n}\nasync function an(l) {\n  return await Xi([l]);\n}\nfunction Ki(l) {\n  let r = [];\n  const h = new AudioDecoder({\n    output: (a) => {\n      r.push(a);\n    },\n    error: z.error\n  });\n  return h.configure(l), {\n    decode: async (a) => {\n      a.forEach((d) => {\n        h.decode(\n          new EncodedAudioChunk({\n            type: d.is_sync ? \"key\" : \"delta\",\n            timestamp: 1e6 * d.cts / d.timescale,\n            duration: 1e6 * d.duration / d.timescale,\n            data: d.data\n          })\n        );\n      }), await h.flush();\n      const f = r;\n      return r = [], f;\n    },\n    close: () => {\n      h.close();\n    }\n  };\n}\nfunction Qi(l, r) {\n  const h = new AudioEncoder({\n    output: (d) => {\n      r(Qt(d));\n    },\n    error: z.error\n  });\n  h.configure({\n    codec: l.codec,\n    sampleRate: l.sampleRate,\n    numberOfChannels: l.numberOfChannels\n  });\n  let a = null;\n  function f(d, p) {\n    return new AudioData({\n      timestamp: p,\n      numberOfChannels: l.numberOfChannels,\n      numberOfFrames: d.length / l.numberOfChannels,\n      sampleRate: l.sampleRate,\n      format: \"f32-planar\",\n      data: d\n    });\n  }\n  return {\n    encode: async (d, p) => {\n      a != null && h.encode(f(a.data, a.ts)), a = { data: d, ts: p };\n    },\n    stop: async () => {\n      a != null && (Ji(a.data, l.numberOfChannels, l.sampleRate), h.encode(f(a.data, a.ts)), a = null), await h.flush(), h.close();\n    }\n  };\n}\nfunction Ji(l, r, h) {\n  const a = l.length - 1, f = Math.min(h / 2, a);\n  for (let d = 0; d < f; d++)\n    for (let p = 1; p <= r; p++)\n      l[Math.floor(a / p) - d] *= d / f;\n}\nfunction on(l, r) {\n  z.info(\"mixinMP4AndAudio, opts:\", {\n    volume: r.volume,\n    loop: r.loop\n  });\n  const h = D.createFile(), { stream: a, stop: f } = Wi(h, 500);\n  let d = null, p = null, n = [], v = 0, b = 0, y = 0, B = !0, t = 48e3;\n  fe(l.pipeThrough(new ce()), {\n    onDone: async () => {\n      await (p == null ? void 0 : p.stop()), d == null || d.close(), f();\n    },\n    onChunk: async ({ chunkType: o, data: c }) => {\n      if (o === \"ready\") {\n        const { videoTrackConf: u, audioTrackConf: _, audioDecoderConf: g } = de(c.file, c.info);\n        v === 0 && u != null && (v = h.addTrack(u));\n        const w = _ ?? {\n          timescale: 1e6,\n          samplerate: t,\n          channel_count: q.channelCount,\n          hdlr: \"soun\",\n          name: \"SoundHandler\",\n          type: \"mp4a\"\n        };\n        b === 0 && (b = h.addTrack(w), t = (_ == null ? void 0 : _.samplerate) ?? t, B = _ != null);\n        const S = new AudioContext({ sampleRate: t });\n        n = Oe(\n          await S.decodeAudioData(\n            await new Response(r.stream).arrayBuffer()\n          )\n        ), g != null && (d = Ki(g)), p = Qi(\n          g ?? {\n            codec: w.type === \"mp4a\" ? q.codec : w.type,\n            numberOfChannels: w.channel_count,\n            sampleRate: w.samplerate\n          },\n          (U) => h.addSample(b, U.data, U)\n        );\n      } else if (o === \"samples\") {\n        const { id: u, type: _, samples: g } = c;\n        if (_ === \"video\") {\n          g.forEach((w) => h.addSample(u, w.data, w)), B || await i(g);\n          return;\n        }\n        _ === \"audio\" && await s(g);\n      }\n    }\n  });\n  function e(o) {\n    const c = n.map(\n      (u) => r.loop ? Si(u, y, y + o) : u.slice(y, y + o)\n    );\n    if (y += o, r.volume !== 1)\n      for (const u of c)\n        for (let _ = 0; _ < u.length; _++) u[_] *= r.volume;\n    return c;\n  }\n  async function i(o) {\n    const c = o[0], u = o[o.length - 1], _ = Math.floor(\n      (u.cts + u.duration - c.cts) / u.timescale * t\n    ), g = be([e(_)]);\n    g.length !== 0 && (p == null || p.encode(\n      g,\n      c.cts / c.timescale * 1e6\n    ));\n  }\n  async function s(o) {\n    if (d == null) return;\n    const c = (await d.decode(o)).map(\n      le\n    ), u = mi(c), _ = e(u[0].length), g = o[0];\n    p == null || p.encode(\n      be([u, _]),\n      g.cts / g.timescale * 1e6\n    );\n  }\n  return a;\n}\nfunction $i(l) {\n  const r = l.byteLength, h = new Uint8Array([\n    0,\n    // version 0\n    0,\n    0,\n    0,\n    // flags\n    3,\n    // descriptor_type\n    23 + r,\n    // length\n    0,\n    // 0x01, // es_id\n    2,\n    // es_id\n    0,\n    // stream_priority\n    4,\n    // descriptor_type\n    18 + r,\n    // length\n    64,\n    // codec : mpeg4_audio\n    21,\n    // stream_type\n    0,\n    0,\n    0,\n    // buffer_size\n    0,\n    0,\n    0,\n    0,\n    // maxBitrate\n    0,\n    0,\n    0,\n    0,\n    // avgBitrate\n    5,\n    // descriptor_type\n    r,\n    ...new Uint8Array(l instanceof ArrayBuffer ? l : l.buffer),\n    6,\n    1,\n    2\n  ]), a = new D.BoxParser.esdsBox(h.byteLength);\n  return a.hdr_size = 0, a.parse(new D.DataStream(h, 0, D.DataStream.BIG_ENDIAN)), a;\n}\n\n//# sourceMappingURL=frames.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRlc2lnbmNvbWJvL2ZyYW1lcy9kaXN0L2ZyYW1lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxFQUFFLElBQUksb0JBQW9CLGdCQUFnQjtBQUMxRSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxFQUFFLFlBQVksRUFBRTtBQUNyRTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0IsRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseXZFQUF5dkUsdUJBQXVCLGdCQUFnQjtBQUNoeUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsOEVBQThFLGtCQUFrQjtBQUNoRyx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FB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QUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7QUFDdkgsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGdCQUFnQiw0REFBNEQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeUJFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZW1vdGlvbi1jYXB0aW9ucy8uL25vZGVfbW9kdWxlcy9AZGVzaWduY29tYm8vZnJhbWVzL2Rpc3QvZnJhbWVzLmpzPzg2ZTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEhlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIHBlID0gKGwpID0+IHtcbiAgdGhyb3cgVHlwZUVycm9yKGwpO1xufTtcbnZhciBZZSA9IChsLCByLCBoKSA9PiByIGluIGwgPyBIZShsLCByLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBoIH0pIDogbFtyXSA9IGg7XG52YXIgUiA9IChsLCByLCBoKSA9PiBZZShsLCB0eXBlb2YgciAhPSBcInN5bWJvbFwiID8gciArIFwiXCIgOiByLCBoKSwgX2UgPSAobCwgciwgaCkgPT4gci5oYXMobCkgfHwgcGUoXCJDYW5ub3QgXCIgKyBoKTtcbnZhciBtID0gKGwsIHIsIGgpID0+IChfZShsLCByLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBoID8gaC5jYWxsKGwpIDogci5nZXQobCkpLCBBID0gKGwsIHIsIGgpID0+IHIuaGFzKGwpID8gcGUoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogciBpbnN0YW5jZW9mIFdlYWtTZXQgPyByLmFkZChsKSA6IHIuc2V0KGwsIGgpLCBFID0gKGwsIHIsIGgsIGEpID0+IChfZShsLCByLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIGEgPyBhLmNhbGwobCwgaCkgOiByLnNldChsLCBoKSwgaCk7XG5mdW5jdGlvbiBWZShsKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGwpO1xufVxuZnVuY3Rpb24gV2UobCwgcikge1xuICBjb25zdCBoID0gVmUoXCJwcmVcIik7XG4gIGguc3R5bGUuY3NzVGV4dCA9IGBtYXJnaW46IDA7ICR7cn07IHZpc2liaWxpdHk6IGhpZGRlbjsgcG9zaXRpb246IGZpeGVkO2AsIGgudGV4dENvbnRlbnQgPSBsLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGgpO1xuICBjb25zdCB7IHdpZHRoOiBhLCBoZWlnaHQ6IGYgfSA9IGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGgucmVtb3ZlKCksIGguc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICBjb25zdCBkID0gbmV3IEltYWdlKCk7XG4gIGQud2lkdGggPSBhLCBkLmhlaWdodCA9IGY7XG4gIGNvbnN0IHAgPSBgXG4gICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIke2F9XCIgaGVpZ2h0PVwiJHtmfVwiPlxuICAgIDxmb3JlaWduT2JqZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIj5cbiAgICAgICAgPGRpdiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj4ke2gub3V0ZXJIVE1MfTwvZGl2PlxuICAgIDwvZm9yZWlnbk9iamVjdD5cbiAgICA8L3N2Zz5cbiAgYC5yZXBsYWNlKC9cXHQvZywgXCJcIikucmVwbGFjZSgvIy9nLCBcIiUyM1wiKTtcbiAgcmV0dXJuIGQuc3JjID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCR7cH1gLCBkO1xufVxuYXN5bmMgZnVuY3Rpb24gdG4obCwgcikge1xuICBjb25zdCBoID0gV2UobCwgcik7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChkKSA9PiB7XG4gICAgaC5vbmxvYWQgPSBkO1xuICB9KTtcbiAgY29uc3QgYSA9IG5ldyBPZmZzY3JlZW5DYW52YXMoaC53aWR0aCwgaC5oZWlnaHQpLCBmID0gYS5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHJldHVybiBmID09IG51bGwgfHwgZi5kcmF3SW1hZ2UoaCwgMCwgMCwgaC53aWR0aCwgaC5oZWlnaHQpLCBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChhKTtcbn1cbnZhciBCZSA9IChsKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihsKTtcbn0sIEZlID0gKGwsIHIsIGgpID0+IHIuaGFzKGwpIHx8IEJlKFwiQ2Fubm90IFwiICsgaCksIEkgPSAobCwgciwgaCkgPT4gKEZlKGwsIHIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGggPyBoLmNhbGwobCkgOiByLmdldChsKSksIE4gPSAobCwgciwgaCkgPT4gci5oYXMobCkgPyBCZShcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiByIGluc3RhbmNlb2YgV2Vha1NldCA/IHIuYWRkKGwpIDogci5zZXQobCwgaCksIE0gPSAobCwgciwgaCwgYSkgPT4gKEZlKGwsIHIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgci5zZXQobCwgaCksIGgpO1xuY29uc3QgSWUgPSBcIktHWjFibU4wYVc5dUtDbDdJblZ6WlNCemRISnBZM1FpTzJaMWJtTjBhVzl1SUhVb2JpbDdhV1lvYmowOVBTSXZJaWx5WlhSMWNtNTdjR0Z5Wlc1ME9tNTFiR3dzYm1GdFpUb2lJbjA3WTI5dWMzUWdaVDF1TG5Od2JHbDBLQ0l2SWlrdVptbHNkR1Z5S0drOVBta3ViR1Z1WjNSb1BqQXBPMmxtS0dVdWJHVnVaM1JvUFQwOU1DbDBhSEp2ZHlCRmNuSnZjaWdpU1c1MllXeHBaQ0J3WVhSb0lpazdZMjl1YzNRZ1lUMWxXMlV1YkdWdVozUm9MVEZkTEhJOUlpOGlLMlV1YzJ4cFkyVW9NQ3d0TVNrdWFtOXBiaWdpTHlJcE8zSmxkSFZ5Ym50dVlXMWxPbUVzY0dGeVpXNTBPbko5ZldGemVXNWpJR1oxYm1OMGFXOXVJSGNvYml4bEtYdGpiMjV6ZEh0d1lYSmxiblE2WVN4dVlXMWxPbko5UFhVb2JpazdhV1lvWVQwOWJuVnNiQ2x5WlhSMWNtNGdZWGRoYVhRZ2JtRjJhV2RoZEc5eUxuTjBiM0poWjJVdVoyVjBSR2x5WldOMGIzSjVLQ2s3WTI5dWMzUWdhVDFoTG5Od2JHbDBLQ0l2SWlrdVptbHNkR1Z5S0hROVBuUXViR1Z1WjNSb1BqQXBPM1J5ZVh0c1pYUWdkRDFoZDJGcGRDQnVZWFpwWjJGMGIzSXVjM1J2Y21GblpTNW5aWFJFYVhKbFkzUnZjbmtvS1R0bWIzSW9ZMjl1YzNRZ2N5QnZaaUJwS1hROVlYZGhhWFFnZEM1blpYUkVhWEpsWTNSdmNubElZVzVrYkdVb2N5eDdZM0psWVhSbE9tVXVZM0psWVhSbGZTazdhV1lvWlM1cGMwWnBiR1VwY21WMGRYSnVJR0YzWVdsMElIUXVaMlYwUm1sc1pVaGhibVJzWlNoeUxIdGpjbVZoZEdVNlpTNWpjbVZoZEdWOUtYMWpZWFJqYUNoMEtYdHBaaWgwTG01aGJXVTlQVDBpVG05MFJtOTFibVJGY25KdmNpSXBjbVYwZFhKdUlHNTFiR3c3ZEdoeWIzY2dkSDE5WTI5dWMzUWdaajE3ZlR0elpXeG1MbTl1YldWemMyRm5aVDFoYzNsdVl5QnVQVDU3ZG1GeUlHazdZMjl1YzNSN1pYWjBWSGx3WlRwbExHRnlaM002WVgwOWJpNWtZWFJoTzJ4bGRDQnlQV1piWVM1bWFXeGxTV1JkTzNSeWVYdHNaWFFnZER0amIyNXpkQ0J6UFZ0ZE8ybG1LR1U5UFQwaWNtVm5hWE4wWlhJaUtYdGpiMjV6ZENCc1BXRjNZV2wwSUhjb1lTNW1hV3hsVUdGMGFDeDdZM0psWVhSbE9pRXdMR2x6Um1sc1pUb2hNSDBwTzJsbUtHdzlQVzUxYkd3cGRHaHliM2NnUlhKeWIzSW9ZRzV2ZENCbWIzVnVaQ0JtYVd4bE9pQWtlMkV1Wm1sc1pVbGtmV0FwTzNJOVlYZGhhWFFnYkM1amNtVmhkR1ZUZVc1alFXTmpaWE56U0dGdVpHeGxLSHR0YjJSbE9tRXViVzlrWlgwcExHWmJZUzVtYVd4bFNXUmRQWEo5Wld4elpTQnBaaWhsUFQwOUltTnNiM05sSWlsaGQyRnBkQ0J5TG1Oc2IzTmxLQ2tzWkdWc1pYUmxJR1piWVM1bWFXeGxTV1JkTzJWc2MyVWdhV1lvWlQwOVBTSjBjblZ1WTJGMFpTSXBZWGRoYVhRZ2NpNTBjblZ1WTJGMFpTaGhMbTVsZDFOcGVtVXBPMlZzYzJVZ2FXWW9aVDA5UFNKM2NtbDBaU0lwZTJOdmJuTjBlMlJoZEdFNmJDeHZjSFJ6T205OVBXNHVaR0YwWVM1aGNtZHpPM1E5WVhkaGFYUWdjaTUzY21sMFpTaHNMRzhwZldWc2MyVWdhV1lvWlQwOVBTSnlaV0ZrSWlsN1kyOXVjM1I3YjJabWMyVjBPbXdzYzJsNlpUcHZmVDF1TG1SaGRHRXVZWEpuY3l4blBXNWxkeUJWYVc1ME9FRnljbUY1S0c4cExHUTlZWGRoYVhRZ2NpNXlaV0ZrS0djc2UyRjBPbXg5S1N4alBXY3VZblZtWm1WeU8zUTlaRDA5UFc4L1l6b29LR2s5WXk1MGNtRnVjMlpsY2lrOVBXNTFiR3cvZG05cFpDQXdPbWt1WTJGc2JDaGpMR1FwS1Q4L1l5NXpiR2xqWlNnd0xHUXBMSE11Y0hWemFDaDBLWDFsYkhObElHVTlQVDBpWjJWMFUybDZaU0kvZEQxaGQyRnBkQ0J5TG1kbGRGTnBlbVVvS1RwbFBUMDlJbVpzZFhOb0lpWW1ZWGRoYVhRZ2NpNW1iSFZ6YUNncE8zTmxiR1l1Y0c5emRFMWxjM05oWjJVb2UyVjJkRlI1Y0dVNkltTmhiR3hpWVdOcklpeGpZa2xrT200dVpHRjBZUzVqWWtsa0xISmxkSFZ5YmxaaGJEcDBmU3h6S1gxallYUmphQ2gwS1h0amIyNXpkQ0J6UFhRN2MyVnNaaTV3YjNOMFRXVnpjMkZuWlNoN1pYWjBWSGx3WlRvaWRHaHliM2RGY25KdmNpSXNZMkpKWkRwdUxtUmhkR0V1WTJKSlpDeGxjbkpOYzJjNmN5NXVZVzFsS3lJNklDSXJjeTV0WlhOellXZGxLMkFLWUN0S1UwOU9Mbk4wY21sdVoybG1lU2h1TG1SaGRHRXBmU2w5ZlgwcEtDazdDaTh2SXlCemIzVnlZMlZOWVhCd2FXNW5WVkpNUFc5d1puTXRkMjl5YTJWeUxVWTBVbGRzY1dOZkxtcHpMbTFoY0FvPVwiLCBaZSA9IChsKSA9PiBVaW50OEFycmF5LmZyb20oYXRvYihsKSwgKHIpID0+IHIuY2hhckNvZGVBdCgwKSksIGdlID0gdHlwZW9mIHNlbGYgPCBcInVcIiAmJiBzZWxmLkJsb2IgJiYgbmV3IEJsb2IoW1plKEllKV0sIHsgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHQ7Y2hhcnNldD11dGYtOFwiIH0pO1xuZnVuY3Rpb24gWGUobCkge1xuICBsZXQgcjtcbiAgdHJ5IHtcbiAgICBpZiAociA9IGdlICYmIChzZWxmLlVSTCB8fCBzZWxmLndlYmtpdFVSTCkuY3JlYXRlT2JqZWN0VVJMKGdlKSwgIXIpIHRocm93IFwiXCI7XG4gICAgY29uc3QgaCA9IG5ldyBXb3JrZXIociwge1xuICAgICAgbmFtZTogbCA9PSBudWxsID8gdm9pZCAwIDogbC5uYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIGguYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICAgIChzZWxmLlVSTCB8fCBzZWxmLndlYmtpdFVSTCkucmV2b2tlT2JqZWN0VVJMKHIpO1xuICAgIH0pLCBoO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbmV3IFdvcmtlcihcbiAgICAgIFwiZGF0YTp0ZXh0L2phdmFzY3JpcHQ7YmFzZTY0LFwiICsgSWUsXG4gICAgICB7XG4gICAgICAgIG5hbWU6IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwubmFtZVxuICAgICAgfVxuICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgciAmJiAoc2VsZi5VUkwgfHwgc2VsZi53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChyKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gamUobCwgciwgaCkge1xuICBjb25zdCBhID0gS2UoKTtcbiAgcmV0dXJuIGF3YWl0IGEoXCJyZWdpc3RlclwiLCB7IGZpbGVJZDogbCwgZmlsZVBhdGg6IHIsIG1vZGU6IGggfSksIHtcbiAgICByZWFkOiBhc3luYyAoZiwgZCkgPT4gYXdhaXQgYShcInJlYWRcIiwge1xuICAgICAgZmlsZUlkOiBsLFxuICAgICAgb2Zmc2V0OiBmLFxuICAgICAgc2l6ZTogZFxuICAgIH0pLFxuICAgIHdyaXRlOiBhc3luYyAoZiwgZCkgPT4gYXdhaXQgYShcbiAgICAgIFwid3JpdGVcIixcbiAgICAgIHtcbiAgICAgICAgZmlsZUlkOiBsLFxuICAgICAgICBkYXRhOiBmLFxuICAgICAgICBvcHRzOiBkXG4gICAgICB9LFxuICAgICAgW0FycmF5QnVmZmVyLmlzVmlldyhmKSA/IGYuYnVmZmVyIDogZl1cbiAgICApLFxuICAgIGNsb3NlOiBhc3luYyAoKSA9PiBhd2FpdCBhKFwiY2xvc2VcIiwge1xuICAgICAgZmlsZUlkOiBsXG4gICAgfSksXG4gICAgdHJ1bmNhdGU6IGFzeW5jIChmKSA9PiBhd2FpdCBhKFwidHJ1bmNhdGVcIiwge1xuICAgICAgZmlsZUlkOiBsLFxuICAgICAgbmV3U2l6ZTogZlxuICAgIH0pLFxuICAgIGdldFNpemU6IGFzeW5jICgpID0+IGF3YWl0IGEoXCJnZXRTaXplXCIsIHtcbiAgICAgIGZpbGVJZDogbFxuICAgIH0pLFxuICAgIGZsdXNoOiBhc3luYyAoKSA9PiBhd2FpdCBhKFwiZmx1c2hcIiwge1xuICAgICAgZmlsZUlkOiBsXG4gICAgfSlcbiAgfTtcbn1cbmNvbnN0IFl0ID0gW107XG5sZXQgaWUgPSAwO1xuZnVuY3Rpb24gS2UoKSB7XG4gIGlmIChZdC5sZW5ndGggPCAzKSB7XG4gICAgY29uc3QgciA9IGwoKTtcbiAgICByZXR1cm4gWXQucHVzaChyKSwgcjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByID0gWXRbaWVdO1xuICAgIHJldHVybiBpZSA9IChpZSArIDEpICUgWXQubGVuZ3RoLCByO1xuICB9XG4gIGZ1bmN0aW9uIGwoKSB7XG4gICAgY29uc3QgciA9IG5ldyBYZSgpO1xuICAgIGxldCBoID0gMCwgYSA9IHt9O1xuICAgIHJldHVybiByLm9ubWVzc2FnZSA9ICh7XG4gICAgICBkYXRhOiBmXG4gICAgfSkgPT4ge1xuICAgICAgdmFyIGQsIHA7XG4gICAgICBmLmV2dFR5cGUgPT09IFwiY2FsbGJhY2tcIiA/IChkID0gYVtmLmNiSWRdKSA9PSBudWxsIHx8IGQucmVzb2x2ZShmLnJldHVyblZhbCkgOiBmLmV2dFR5cGUgPT09IFwidGhyb3dFcnJvclwiICYmICgocCA9IGFbZi5jYklkXSkgPT0gbnVsbCB8fCBwLnJlamVjdChFcnJvcihmLmVyck1zZykpKSwgZGVsZXRlIGFbZi5jYklkXTtcbiAgICB9LCBhc3luYyBmdW5jdGlvbihmLCBkLCBwID0gW10pIHtcbiAgICAgIGggKz0gMTtcbiAgICAgIGNvbnN0IG4gPSBuZXcgUHJvbWlzZSgodiwgYikgPT4ge1xuICAgICAgICBhW2hdID0geyByZXNvbHZlOiB2LCByZWplY3Q6IGIgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHIucG9zdE1lc3NhZ2UoXG4gICAgICAgIHtcbiAgICAgICAgICBjYklkOiBoLFxuICAgICAgICAgIGV2dFR5cGU6IGYsXG4gICAgICAgICAgYXJnczogZFxuICAgICAgICB9LFxuICAgICAgICBwXG4gICAgICApLCBuO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHRlKGwpIHtcbiAgaWYgKGwgPT09IFwiL1wiKSByZXR1cm4geyBwYXJlbnQ6IG51bGwsIG5hbWU6IFwiXCIgfTtcbiAgY29uc3QgciA9IGwuc3BsaXQoXCIvXCIpLmZpbHRlcigoZikgPT4gZi5sZW5ndGggPiAwKTtcbiAgaWYgKHIubGVuZ3RoID09PSAwKSB0aHJvdyBFcnJvcihcIkludmFsaWQgcGF0aFwiKTtcbiAgY29uc3QgaCA9IHJbci5sZW5ndGggLSAxXSwgYSA9IFwiL1wiICsgci5zbGljZSgwLCAtMSkuam9pbihcIi9cIik7XG4gIHJldHVybiB7IG5hbWU6IGgsIHBhcmVudDogYSB9O1xufVxuYXN5bmMgZnVuY3Rpb24gb3QobCwgcikge1xuICBjb25zdCB7IHBhcmVudDogaCwgbmFtZTogYSB9ID0gdGUobCk7XG4gIGlmIChoID09IG51bGwpIHJldHVybiBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgY29uc3QgZiA9IGguc3BsaXQoXCIvXCIpLmZpbHRlcigoZCkgPT4gZC5sZW5ndGggPiAwKTtcbiAgdHJ5IHtcbiAgICBsZXQgZCA9IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgIGZvciAoY29uc3QgcCBvZiBmKVxuICAgICAgZCA9IGF3YWl0IGQuZ2V0RGlyZWN0b3J5SGFuZGxlKHAsIHtcbiAgICAgICAgY3JlYXRlOiByLmNyZWF0ZVxuICAgICAgfSk7XG4gICAgcmV0dXJuIHIuaXNGaWxlID8gYXdhaXQgZC5nZXRGaWxlSGFuZGxlKGEsIHtcbiAgICAgIGNyZWF0ZTogci5jcmVhdGVcbiAgICB9KSA6IGF3YWl0IGQuZ2V0RGlyZWN0b3J5SGFuZGxlKGEsIHtcbiAgICAgIGNyZWF0ZTogci5jcmVhdGVcbiAgICB9KTtcbiAgfSBjYXRjaCAoZCkge1xuICAgIGlmIChkLm5hbWUgPT09IFwiTm90Rm91bmRFcnJvclwiKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdGhyb3cgZDtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gQ2UobCkge1xuICBjb25zdCB7IHBhcmVudDogciwgbmFtZTogaCB9ID0gdGUobCk7XG4gIGlmIChyID09IG51bGwpIHtcbiAgICBjb25zdCBmID0gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBkIG9mIGYua2V5cygpKVxuICAgICAgYXdhaXQgZi5yZW1vdmVFbnRyeShkLCB7IHJlY3Vyc2l2ZTogITAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSBhd2FpdCBvdChyLCB7XG4gICAgY3JlYXRlOiAhMSxcbiAgICBpc0ZpbGU6ICExXG4gIH0pO1xuICBhICE9IG51bGwgJiYgYXdhaXQgYS5yZW1vdmVFbnRyeShoLCB7IHJlY3Vyc2l2ZTogITAgfSk7XG59XG5mdW5jdGlvbiBzZShsLCByKSB7XG4gIHJldHVybiBgJHtsfS8ke3J9YC5yZXBsYWNlKFwiLy9cIiwgXCIvXCIpO1xufVxuZnVuY3Rpb24gdnQobCkge1xuICByZXR1cm4gbmV3IHplKGwpO1xufVxudmFyIEgsIFZ0LCBBdDtcbmNsYXNzIHplIHtcbiAgY29uc3RydWN0b3Iocikge1xuICAgIE4odGhpcywgSCksIE4odGhpcywgVnQpLCBOKHRoaXMsIEF0KSwgTSh0aGlzLCBILCByKTtcbiAgICBjb25zdCB7IHBhcmVudDogaCwgbmFtZTogYSB9ID0gdGUocik7XG4gICAgTSh0aGlzLCBWdCwgYSksIE0odGhpcywgQXQsIGgpO1xuICB9XG4gIGdldCBraW5kKCkge1xuICAgIHJldHVybiBcImRpclwiO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBJKHRoaXMsIFZ0KTtcbiAgfVxuICBnZXQgcGF0aCgpIHtcbiAgICByZXR1cm4gSSh0aGlzLCBIKTtcbiAgfVxuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiBJKHRoaXMsIEF0KSA9PSBudWxsID8gbnVsbCA6IHZ0KEkodGhpcywgQXQpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZGlyZWN0b3J5LlxuICAgKiByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZGlyZWN0b3J5IGlzIGNyZWF0ZWQuXG4gICAqL1xuICBhc3luYyBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIGF3YWl0IG90KEkodGhpcywgSCksIHtcbiAgICAgIGNyZWF0ZTogITAsXG4gICAgICBpc0ZpbGU6ICExXG4gICAgfSksIHZ0KEkodGhpcywgSCkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGRpcmVjdG9yeSBleGlzdHMuXG4gICAqIHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHRoZSBkaXJlY3RvcnkgZXhpc3RzLCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBhc3luYyBleGlzdHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IG90KEkodGhpcywgSCksIHtcbiAgICAgIGNyZWF0ZTogITEsXG4gICAgICBpc0ZpbGU6ICExXG4gICAgfSkgaW5zdGFuY2VvZiBGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBkaXJlY3RvcnkuXG4gICAqIHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBkaXJlY3RvcnkgaXMgcmVtb3ZlZC5cbiAgICovXG4gIGFzeW5jIHJlbW92ZSgpIHtcbiAgICBmb3IgKGNvbnN0IHIgb2YgYXdhaXQgdGhpcy5jaGlsZHJlbigpKVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgci5yZW1vdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGgpO1xuICAgICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBDZShJKHRoaXMsIEgpKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBjb25zb2xlLndhcm4ocik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNoaWxkcmVuIG9mIHRoZSBkaXJlY3RvcnkuXG4gICAqIHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgY2hpbGRyZW4uXG4gICAqL1xuICBhc3luYyBjaGlsZHJlbigpIHtcbiAgICBjb25zdCByID0gYXdhaXQgb3QoSSh0aGlzLCBIKSwge1xuICAgICAgY3JlYXRlOiAhMSxcbiAgICAgIGlzRmlsZTogITFcbiAgICB9KTtcbiAgICBpZiAociA9PSBudWxsKSByZXR1cm4gW107XG4gICAgY29uc3QgaCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgYSBvZiByLnZhbHVlcygpKVxuICAgICAgaC5wdXNoKChhLmtpbmQgPT09IFwiZmlsZVwiID8gX3QgOiB2dCkoc2UoSSh0aGlzLCBIKSwgYS5uYW1lKSkpO1xuICAgIHJldHVybiBoO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0aGUgZGVzdCBmb2xkZXIgZXhpc3RzLCBjb3B5IHRoZSBjdXJyZW50IGRpcmVjdG9yeSBpbnRvIHRoZSBkZXN0IGZvbGRlcjtcbiAgICogaWYgdGhlIGRlc3QgZm9sZGVyIGRvZXMgbm90IGV4aXN0LCByZW5hbWUgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHRvIGRlc3QgbmFtZS5cbiAgICovXG4gIGFzeW5jIGNvcHlUbyhyKSB7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmV4aXN0cygpKVxuICAgICAgdGhyb3cgRXJyb3IoYGRpciAke3RoaXMucGF0aH0gbm90IGV4aXN0c2ApO1xuICAgIGNvbnN0IGggPSBhd2FpdCByLmV4aXN0cygpID8gdnQoc2Uoci5wYXRoLCB0aGlzLm5hbWUpKSA6IHI7XG4gICAgcmV0dXJuIGF3YWl0IGguY3JlYXRlKCksIGF3YWl0IFByb21pc2UuYWxsKChhd2FpdCB0aGlzLmNoaWxkcmVuKCkpLm1hcCgoYSkgPT4gYS5jb3B5VG8oaCkpKSwgaDtcbiAgfVxuICAvKipcbiAgICogbW92ZSBkaXJlY3RvcnksIGNvcHkgdGhlbiByZW1vdmUgY3VycmVudFxuICAgKi9cbiAgYXN5bmMgbW92ZVRvKHIpIHtcbiAgICBjb25zdCBoID0gYXdhaXQgdGhpcy5jb3B5VG8ocik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVtb3ZlKCksIGg7XG4gIH1cbn1cbkggPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgVnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHllID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIF90KGwsIHIgPSBcInJ3XCIpIHtcbiAgaWYgKHIgPT09IFwicndcIikge1xuICAgIGNvbnN0IGggPSB5ZS5nZXQobCkgPz8gbmV3IGp0KGwsIHIpO1xuICAgIHJldHVybiB5ZS5zZXQobCwgaCksIGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBqdChsLCByKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEN0KGwsIHIsIGggPSB7IG92ZXJ3cml0ZTogITAgfSkge1xuICBpZiAociBpbnN0YW5jZW9mIGp0KSB7XG4gICAgYXdhaXQgQ3QobCwgYXdhaXQgci5zdHJlYW0oKSwgaCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSBhd2FpdCAobCBpbnN0YW5jZW9mIGp0ID8gbCA6IF90KGwsIFwicndcIikpLmNyZWF0ZVdyaXRlcigpO1xuICB0cnkge1xuICAgIGlmIChoLm92ZXJ3cml0ZSAmJiBhd2FpdCBhLnRydW5jYXRlKDApLCByIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIGNvbnN0IGYgPSByLmdldFJlYWRlcigpO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZTogZCwgdmFsdWU6IHAgfSA9IGF3YWl0IGYucmVhZCgpO1xuICAgICAgICBpZiAoZCkgYnJlYWs7XG4gICAgICAgIGF3YWl0IGEud3JpdGUocCk7XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICBhd2FpdCBhLndyaXRlKHIpO1xuICB9IGNhdGNoIChmKSB7XG4gICAgdGhyb3cgZjtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBhLmNsb3NlKCk7XG4gIH1cbn1cbmxldCBRZSA9IDA7XG5jb25zdCBKZSA9ICgpID0+ICsrUWU7XG52YXIgWSwgQnQsIFd0LCBGdCwgWnQsIGl0LCBYdCwgSXQ7XG5jb25zdCAkZSA9IGNsYXNzIFRlIHtcbiAgY29uc3RydWN0b3IociwgaCkge1xuICAgIE4odGhpcywgWSksIE4odGhpcywgQnQpLCBOKHRoaXMsIFd0KSwgTih0aGlzLCBGdCksIE4odGhpcywgWnQpLCBOKHRoaXMsIGl0LCAwKSwgTih0aGlzLCBYdCwgLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgICBsZXQgZCA9IG51bGw7XG4gICAgICByZXR1cm4gKCkgPT4gKE0odGhpcywgaXQsIEkodGhpcywgaXQpICsgMSksIGQgPz8gKGQgPSBuZXcgUHJvbWlzZShhc3luYyAocCwgbikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHYgPSBhd2FpdCBqZShcbiAgICAgICAgICAgIEkodGhpcywgWnQpLFxuICAgICAgICAgICAgSSh0aGlzLCBZKSxcbiAgICAgICAgICAgIEkodGhpcywgRnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwKFtcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIE0odGhpcywgaXQsIEkodGhpcywgaXQpIC0gMSksICEoSSh0aGlzLCBpdCkgPiAwKSAmJiAoZCA9IG51bGwsIGF3YWl0IHYuY2xvc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSk7XG4gICAgICAgIH0gY2F0Y2ggKHYpIHtcbiAgICAgICAgICBuKHYpO1xuICAgICAgICB9XG4gICAgICB9KSkpO1xuICAgIH0pKCkpLCBOKHRoaXMsIEl0LCAhMSksIE0odGhpcywgWnQsIEplKCkpLCBNKHRoaXMsIFksIHIpLCBNKHRoaXMsIEZ0LCB7XG4gICAgICByOiBcInJlYWQtb25seVwiLFxuICAgICAgcnc6IFwicmVhZHdyaXRlXCIsXG4gICAgICBcInJ3LXVuc2FmZVwiOiBcInJlYWR3cml0ZS11bnNhZmVcIlxuICAgIH1baF0pO1xuICAgIGNvbnN0IHsgcGFyZW50OiBhLCBuYW1lOiBmIH0gPSB0ZShyKTtcbiAgICBNKHRoaXMsIFd0LCBmKSwgTSh0aGlzLCBCdCwgYSk7XG4gIH1cbiAgZ2V0IGtpbmQoKSB7XG4gICAgcmV0dXJuIFwiZmlsZVwiO1xuICB9XG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiBJKHRoaXMsIFkpO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBJKHRoaXMsIFd0KTtcbiAgfVxuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiBJKHRoaXMsIEJ0KSA9PSBudWxsID8gbnVsbCA6IHZ0KEkodGhpcywgQnQpKTtcbiAgfVxuICAvKipcbiAgICogUmFuZG9tIHdyaXRlIHRvIGZpbGVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVdyaXRlcigpIHtcbiAgICBpZiAoSSh0aGlzLCBGdCkgPT09IFwicmVhZC1vbmx5XCIpIHRocm93IEVycm9yKFwiZmlsZSBpcyByZWFkLW9ubHlcIik7XG4gICAgaWYgKEkodGhpcywgSXQpKSB0aHJvdyBFcnJvcihcIk90aGVyIHdyaXRlciBoYXZlIG5vdCBiZWVuIGNsb3NlZFwiKTtcbiAgICBNKHRoaXMsIEl0LCAhMCk7XG4gICAgY29uc3QgciA9IG5ldyBUZXh0RW5jb2RlcigpLCBbaCwgYV0gPSBhd2FpdCBJKHRoaXMsIFh0KS5jYWxsKHRoaXMpO1xuICAgIGxldCBmID0gYXdhaXQgaC5nZXRTaXplKCksIGQgPSAhMTtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGFzeW5jIChwLCBuID0ge30pID0+IHtcbiAgICAgICAgaWYgKGQpIHRocm93IEVycm9yKFwiV3JpdGVyIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgY29uc3QgdiA9IHR5cGVvZiBwID09IFwic3RyaW5nXCIgPyByLmVuY29kZShwKSA6IHAsIGIgPSBuLmF0ID8/IGYsIHkgPSB2LmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybiBmID0gYiArIHksIGF3YWl0IGgud3JpdGUodiwgeyBhdDogYiB9KTtcbiAgICAgIH0sXG4gICAgICB0cnVuY2F0ZTogYXN5bmMgKHApID0+IHtcbiAgICAgICAgaWYgKGQpIHRocm93IEVycm9yKFwiV3JpdGVyIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgYXdhaXQgaC50cnVuY2F0ZShwKSwgZiA+IHAgJiYgKGYgPSBwKTtcbiAgICAgIH0sXG4gICAgICBmbHVzaDogYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoZCkgdGhyb3cgRXJyb3IoXCJXcml0ZXIgaXMgY2xvc2VkXCIpO1xuICAgICAgICBhd2FpdCBoLmZsdXNoKCk7XG4gICAgICB9LFxuICAgICAgY2xvc2U6IGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGQpIHRocm93IEVycm9yKFwiV3JpdGVyIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgZCA9ICEwLCBNKHRoaXMsIEl0LCAhMSksIGF3YWl0IGEoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSYW5kb20gYWNjZXNzIHRvIGZpbGVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVJlYWRlcigpIHtcbiAgICBjb25zdCBbciwgaF0gPSBhd2FpdCBJKHRoaXMsIFh0KS5jYWxsKHRoaXMpO1xuICAgIGxldCBhID0gITEsIGYgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICByZWFkOiBhc3luYyAoZCwgcCA9IHt9KSA9PiB7XG4gICAgICAgIGlmIChhKSB0aHJvdyBFcnJvcihcIlJlYWRlciBpcyBjbG9zZWRcIik7XG4gICAgICAgIGNvbnN0IG4gPSBwLmF0ID8/IGYsIHYgPSBhd2FpdCByLnJlYWQobiwgZCk7XG4gICAgICAgIHJldHVybiBmID0gbiArIHYuYnl0ZUxlbmd0aCwgdjtcbiAgICAgIH0sXG4gICAgICBnZXRTaXplOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChhKSB0aHJvdyBFcnJvcihcIlJlYWRlciBpcyBjbG9zZWRcIik7XG4gICAgICAgIHJldHVybiBhd2FpdCByLmdldFNpemUoKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICBhIHx8IChhID0gITAsIGF3YWl0IGgoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyB0ZXh0KCkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXdhaXQgdGhpcy5hcnJheUJ1ZmZlcigpKTtcbiAgfVxuICBhc3luYyBhcnJheUJ1ZmZlcigpIHtcbiAgICBjb25zdCByID0gYXdhaXQgb3QoSSh0aGlzLCBZKSwgeyBjcmVhdGU6ICExLCBpc0ZpbGU6ICEwIH0pO1xuICAgIHJldHVybiByID09IG51bGwgPyBuZXcgQXJyYXlCdWZmZXIoMCkgOiAoYXdhaXQgci5nZXRGaWxlKCkpLmFycmF5QnVmZmVyKCk7XG4gIH1cbiAgYXN5bmMgc3RyZWFtKCkge1xuICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmdldE9yaWdpbkZpbGUoKTtcbiAgICByZXR1cm4gciA9PSBudWxsID8gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHB1bGw6IChoKSA9PiB7XG4gICAgICAgIGguY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KSA6IHIuc3RyZWFtKCk7XG4gIH1cbiAgYXN5bmMgZ2V0T3JpZ2luRmlsZSgpIHtcbiAgICB2YXIgcjtcbiAgICByZXR1cm4gKHIgPSBhd2FpdCBvdChJKHRoaXMsIFkpLCB7IGNyZWF0ZTogITEsIGlzRmlsZTogITAgfSkpID09IG51bGwgPyB2b2lkIDAgOiByLmdldEZpbGUoKTtcbiAgfVxuICBhc3luYyBnZXRTaXplKCkge1xuICAgIGNvbnN0IHIgPSBhd2FpdCBvdChJKHRoaXMsIFkpLCB7IGNyZWF0ZTogITEsIGlzRmlsZTogITAgfSk7XG4gICAgcmV0dXJuIHIgPT0gbnVsbCA/IDAgOiAoYXdhaXQgci5nZXRGaWxlKCkpLnNpemU7XG4gIH1cbiAgYXN5bmMgZXhpc3RzKCkge1xuICAgIHJldHVybiBhd2FpdCBvdChJKHRoaXMsIFkpLCB7XG4gICAgICBjcmVhdGU6ICExLFxuICAgICAgaXNGaWxlOiAhMFxuICAgIH0pIGluc3RhbmNlb2YgRmlsZVN5c3RlbUZpbGVIYW5kbGU7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlKCkge1xuICAgIGlmIChJKHRoaXMsIGl0KSkgdGhyb3cgRXJyb3IoXCJleGlzdHMgdW5jbG9zZWQgcmVhZGVyL3dyaXRlclwiKTtcbiAgICBhd2FpdCBDZShJKHRoaXMsIFkpKTtcbiAgfVxuICAvKipcbiAgICogSWYgdGhlIHRhcmdldCBpcyBhIGZpbGUsIHVzZSBjdXJyZW50IG92ZXJ3cml0ZSB0aGUgdGFyZ2V0O1xuICAgKiBpZiB0aGUgdGFyZ2V0IGlzIGEgZm9sZGVyLCBjb3B5IHRoZSBjdXJyZW50IGZpbGUgaW50byB0aGF0IGZvbGRlci5cbiAgICovXG4gIGFzeW5jIGNvcHlUbyhyKSB7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmV4aXN0cygpKVxuICAgICAgdGhyb3cgRXJyb3IoYGZpbGUgJHt0aGlzLnBhdGh9IG5vdCBleGlzdHNgKTtcbiAgICBpZiAociBpbnN0YW5jZW9mIFRlKVxuICAgICAgcmV0dXJuIF90KHIucGF0aCkgPT09IHRoaXMgPyB0aGlzIDogKGF3YWl0IEN0KHIucGF0aCwgdGhpcyksIF90KHIucGF0aCkpO1xuICAgIGlmIChyIGluc3RhbmNlb2YgemUpXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb3B5VG8oX3Qoc2Uoci5wYXRoLCB0aGlzLm5hbWUpKSk7XG4gICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHRhcmdldCB0eXBlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBtb3ZlIGZpbGUsIGNvcHkgdGhlbiByZW1vdmUgY3VycmVudFxuICAgKi9cbiAgYXN5bmMgbW92ZVRvKHIpIHtcbiAgICBjb25zdCBoID0gYXdhaXQgdGhpcy5jb3B5VG8ocik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVtb3ZlKCksIGg7XG4gIH1cbn07XG5ZID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEJ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFd0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEZ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFp0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGl0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFh0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEl0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5sZXQganQgPSAkZTtcbmNvbnN0IGhlID0gXCIvLm9wZnMtdG9vbHMtdGVtcC1kaXJcIjtcbmFzeW5jIGZ1bmN0aW9uIFBlKGwpIHtcbiAgdHJ5IHtcbiAgICBpZiAobC5raW5kID09PSBcImZpbGVcIikge1xuICAgICAgaWYgKCFhd2FpdCBsLmV4aXN0cygpKSByZXR1cm4gITA7XG4gICAgICBjb25zdCByID0gYXdhaXQgbC5jcmVhdGVXcml0ZXIoKTtcbiAgICAgIGF3YWl0IHIudHJ1bmNhdGUoMCksIGF3YWl0IHIuY2xvc2UoKSwgYXdhaXQgbC5yZW1vdmUoKTtcbiAgICB9IGVsc2VcbiAgICAgIGF3YWl0IGwucmVtb3ZlKCk7XG4gICAgcmV0dXJuICEwO1xuICB9IGNhdGNoIChyKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihyKSwgITE7XG4gIH1cbn1cbmZ1bmN0aW9uIHFlKCkge1xuICBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBsIG9mIGF3YWl0IHZ0KGhlKS5jaGlsZHJlbigpKSB7XG4gICAgICBjb25zdCByID0gL15cXGQrLShcXGQrKSQvLmV4ZWMobC5uYW1lKTtcbiAgICAgIChyID09IG51bGwgfHwgRGF0ZS5ub3coKSAtIE51bWJlcihyWzFdKSA+IDI1OTJlNSkgJiYgYXdhaXQgUGUobCk7XG4gICAgfVxuICB9LCA2MCAqIDFlMyk7XG59XG5jb25zdCByZSA9IFtdO1xubGV0IG1lID0gITE7XG5hc3luYyBmdW5jdGlvbiB0aSgpIHtcbiAgaWYgKGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlID09IG51bGwpIHJldHVybjtcbiAgY29uc3QgbCA9IFwiT1BGU19UT09MU19FWFBJUkVTX1RNUF9GSUxFU1wiO1xuICBtZSB8fCAobWUgPSAhMCwgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsICgpID0+IHtcbiAgICByZS5sZW5ndGggIT09IDAgJiYgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXG4gICAgICBsLFxuICAgICAgYCR7bG9jYWxTdG9yYWdlLmdldEl0ZW0obCkgPz8gXCJcIn0sJHtyZS5qb2luKFwiLFwiKX1gXG4gICAgKTtcbiAgfSkpO1xuICBsZXQgciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGwpID8/IFwiXCI7XG4gIGZvciAoY29uc3QgaCBvZiByLnNwbGl0KFwiLFwiKSlcbiAgICBoLmxlbmd0aCAhPT0gMCAmJiBhd2FpdCBQZShfdChgJHtoZX0vJHtofWApKSAmJiAociA9IHIucmVwbGFjZShoLCBcIlwiKSk7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGwsIHIucmVwbGFjZSgvLHsyLH0vZywgXCIsXCIpKTtcbn1cbihhc3luYyBmdW5jdGlvbigpIHtcbiAgdmFyIGw7XG4gIGdsb2JhbFRoaXMuX19vcGZzX3Rvb2xzX3RtcGZpbGVfaW5pdF9fICE9PSAhMCAmJiAoZ2xvYmFsVGhpcy5fX29wZnNfdG9vbHNfdG1wZmlsZV9pbml0X18gPSAhMCwgIShnbG9iYWxUaGlzLkZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgPT0gbnVsbCB8fCBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlID09IG51bGwgfHwgKChsID0gZ2xvYmFsVGhpcy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBsLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KSA9PSBudWxsKSAmJiAocWUoKSwgYXdhaXQgdGkoKSkpO1xufSkoKTtcbmZ1bmN0aW9uIEt0KCkge1xuICBjb25zdCBsID0gYCR7TWF0aC5yYW5kb20oKS50b1N0cmluZygpLnNsaWNlKDIpfS0ke0RhdGUubm93KCl9YDtcbiAgcmV0dXJuIHJlLnB1c2gobCksIF90KGAke2hlfS8ke2x9YCk7XG59XG5mdW5jdGlvbiBlaShsKSB7XG4gIHJldHVybiBsIGluc3RhbmNlb2YgRXJyb3IgPyBTdHJpbmcobCkgOiB0eXBlb2YgbCA9PSBcIm9iamVjdFwiID8gSlNPTi5zdHJpbmdpZnkobCwgKHIsIGgpID0+IGggaW5zdGFuY2VvZiBFcnJvciA/IFN0cmluZyhoKSA6IGgpIDogU3RyaW5nKGwpO1xufVxuZnVuY3Rpb24gaWkoKSB7XG4gIGNvbnN0IGwgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgcmV0dXJuIGAke2wuZ2V0SG91cnMoKX06JHtsLmdldE1pbnV0ZXMoKX06JHtsLmdldFNlY29uZHMoKX0uJHtsLmdldE1pbGxpc2Vjb25kcygpfWA7XG59XG5sZXQgTGUgPSAxO1xuY29uc3Qga2UgPSBLdCgpO1xubGV0IGd0ID0gbnVsbDtcbmNvbnN0IHZlID0gW1wiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCJdLnJlZHVjZShcbiAgKGwsIHIsIGgpID0+IE9iamVjdC5hc3NpZ24obCwge1xuICAgIFtyXTogKC4uLmEpID0+IHtcbiAgICAgIExlIDw9IGggJiYgKGNvbnNvbGVbcl0oLi4uYSksIGd0ID09IG51bGwgfHwgZ3Qud3JpdGUoXG4gICAgICAgIGBbJHtyfV1bJHtpaSgpfV0gICR7YS5tYXAoKGYpID0+IGVpKGYpKS5qb2luKFwiIFwiKX1cbmBcbiAgICAgICkpO1xuICAgIH1cbiAgfSksXG4gIHt9XG4pLCBHdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHogPSB7XG4gIHNldExvZ0xldmVsOiAobCkgPT4ge1xuICAgIExlID0gR3QuZ2V0KGwpID8/IDE7XG4gIH0sXG4gIC4uLnZlLFxuICBjcmVhdGU6IChsKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXModmUpLm1hcCgoW3IsIGhdKSA9PiBbXG4gICAgICByLFxuICAgICAgKC4uLmEpID0+IGgobCwgLi4uYSlcbiAgICBdKVxuICApLFxuICBhc3luYyBkdW1wKCkge1xuICAgIHJldHVybiBhd2FpdCBzaSwgYXdhaXQgKGd0ID09IG51bGwgPyB2b2lkIDAgOiBndC5mbHVzaCgpKSwgYXdhaXQga2UudGV4dCgpO1xuICB9XG59O1xuR3Quc2V0KHouZGVidWcsIDApO1xuR3Quc2V0KHouaW5mbywgMSk7XG5HdC5zZXQoei53YXJuLCAyKTtcbkd0LnNldCh6LmVycm9yLCAzKTtcbmFzeW5jIGZ1bmN0aW9uIG5pKCkge1xuICB0cnkge1xuICAgIGd0ID0gYXdhaXQga2UuY3JlYXRlV3JpdGVyKCksIHouaW5mbyhuYXZpZ2F0b3IudXNlckFnZW50KSwgei5pbmZvKFwiZGF0ZTogXCIgKyAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvTG9jYWxlRGF0ZVN0cmluZygpKTtcbiAgfSBjYXRjaCAobCkge1xuICAgIGlmICghKGwgaW5zdGFuY2VvZiBFcnJvcikpIHRocm93IGw7XG4gICAgaWYgKGwubWVzc2FnZS5pbmNsdWRlcyhcImNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUgaXMgbm90IGEgZnVuY3Rpb25cIikpXG4gICAgICBjb25zb2xlLndhcm4obCk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbDtcbiAgfVxufVxuY29uc3Qgc2kgPSBnbG9iYWxUaGlzLm5hdmlnYXRvciA9PSBudWxsID8gbnVsbCA6IG5pKCksIHJpID0gKCkgPT4ge1xuICBsZXQgbCwgciA9IDE2LjY7XG4gIHNlbGYub25tZXNzYWdlID0gKGgpID0+IHtcbiAgICBoLmRhdGEuZXZlbnQgPT09IFwic3RhcnRcIiAmJiAoc2VsZi5jbGVhckludGVydmFsKGwpLCBsID0gc2VsZi5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHt9KTtcbiAgICB9LCByKSksIGguZGF0YS5ldmVudCA9PT0gXCJzdG9wXCIgJiYgc2VsZi5jbGVhckludGVydmFsKGwpO1xuICB9O1xufSwgYWkgPSAoKSA9PiB7XG4gIGNvbnN0IGwgPSBuZXcgQmxvYihbYCgke3JpLnRvU3RyaW5nKCl9KSgpYF0pLCByID0gVVJMLmNyZWF0ZU9iamVjdFVSTChsKTtcbiAgcmV0dXJuIG5ldyBXb3JrZXIocik7XG59LCBtdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5sZXQgYWUgPSAxLCBudCA9IG51bGw7XG5nbG9iYWxUaGlzLldvcmtlciAhPSBudWxsICYmIChudCA9IGFpKCksIG50Lm9ubWVzc2FnZSA9ICgpID0+IHtcbiAgYWUgKz0gMTtcbiAgZm9yIChjb25zdCBbbCwgcl0gb2YgbXQpXG4gICAgaWYgKGFlICUgbCA9PT0gMCkgZm9yIChjb25zdCBoIG9mIHIpIGgoKTtcbn0pO1xuY29uc3QgRGUgPSAobCwgcikgPT4ge1xuICBjb25zdCBoID0gTWF0aC5yb3VuZChyIC8gMTYuNiksIGEgPSBtdC5nZXQoaCkgPz8gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmV0dXJuIGEuYWRkKGwpLCBtdC5zZXQoaCwgYSksIG10LnNpemUgPT09IDEgJiYgYS5zaXplID09PSAxICYmIChudCA9PSBudWxsIHx8IG50LnBvc3RNZXNzYWdlKHsgZXZlbnQ6IFwic3RhcnRcIiB9KSksICgpID0+IHtcbiAgICBhLmRlbGV0ZShsKSwgYS5zaXplID09PSAwICYmIG10LmRlbGV0ZShoKSwgbXQuc2l6ZSA9PT0gMCAmJiAoYWUgPSAwLCBudCA9PSBudWxsIHx8IG50LnBvc3RNZXNzYWdlKHsgZXZlbnQ6IFwic3RvcFwiIH0pKTtcbiAgfTtcbn07XG5jbGFzcyBvaSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVGcm9tIHRoZSBsZW5ndGggb2YgdGhlIG9yaWdpbmFsIGFycmF5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVUbyBUaGUgbGVuZ3RoIG9mIHRoZSBuZXcgYXJyYXkuXG4gICAqIEBwYXJhbSB7P09iamVjdH0gZGV0YWlscyBUaGUgZXh0cmEgY29uZmlndXJhdGlvbiwgaWYgbmVlZGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IociwgaCwgYSkge1xuICAgIHRoaXMubGVuZ3RoXyA9IHIsIHRoaXMuc2NhbGVGYWN0b3JfID0gKHIgLSAxKSAvIGgsIHRoaXMuaW50ZXJwb2xhdGUgPSB0aGlzLmN1YmljLCBhLm1ldGhvZCA9PT0gXCJwb2ludFwiID8gdGhpcy5pbnRlcnBvbGF0ZSA9IHRoaXMucG9pbnQgOiBhLm1ldGhvZCA9PT0gXCJsaW5lYXJcIiA/IHRoaXMuaW50ZXJwb2xhdGUgPSB0aGlzLmxpbmVhciA6IGEubWV0aG9kID09PSBcInNpbmNcIiAmJiAodGhpcy5pbnRlcnBvbGF0ZSA9IHRoaXMuc2luYyksIHRoaXMudGFuZ2VudEZhY3Rvcl8gPSAxIC0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYS50ZW5zaW9uIHx8IDApKSwgdGhpcy5zaW5jRmlsdGVyU2l6ZV8gPSBhLnNpbmNGaWx0ZXJTaXplIHx8IDEsIHRoaXMua2VybmVsXyA9IGxpKGEuc2luY1dpbmRvdyB8fCBoaSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IFRoZSBpbmRleCB0byBpbnRlcnBvbGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBzYW1wbGVzIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlLlxuICAgKi9cbiAgcG9pbnQociwgaCkge1xuICAgIHJldHVybiB0aGlzLmdldENsaXBwZWRJbnB1dF8oTWF0aC5yb3VuZCh0aGlzLnNjYWxlRmFjdG9yXyAqIHIpLCBoKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIGluZGV4IHRvIGludGVycG9sYXRlLlxuICAgKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IHNhbXBsZXMgdGhlIG9yaWdpbmFsIGFycmF5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gICAqL1xuICBsaW5lYXIociwgaCkge1xuICAgIHIgPSB0aGlzLnNjYWxlRmFjdG9yXyAqIHI7XG4gICAgbGV0IGEgPSBNYXRoLmZsb29yKHIpO1xuICAgIHJldHVybiByIC09IGEsICgxIC0gcikgKiB0aGlzLmdldENsaXBwZWRJbnB1dF8oYSwgaCkgKyByICogdGhpcy5nZXRDbGlwcGVkSW5wdXRfKGEgKyAxLCBoKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIGluZGV4IHRvIGludGVycG9sYXRlLlxuICAgKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IHNhbXBsZXMgdGhlIG9yaWdpbmFsIGFycmF5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gICAqL1xuICBjdWJpYyhyLCBoKSB7XG4gICAgciA9IHRoaXMuc2NhbGVGYWN0b3JfICogcjtcbiAgICBsZXQgYSA9IE1hdGguZmxvb3IociksIGYgPSBbdGhpcy5nZXRUYW5nZW50XyhhLCBoKSwgdGhpcy5nZXRUYW5nZW50XyhhICsgMSwgaCldLCBkID0gW1xuICAgICAgdGhpcy5nZXRDbGlwcGVkSW5wdXRfKGEsIGgpLFxuICAgICAgdGhpcy5nZXRDbGlwcGVkSW5wdXRfKGEgKyAxLCBoKVxuICAgIF07XG4gICAgciAtPSBhO1xuICAgIGxldCBwID0gciAqIHIsIG4gPSByICogcDtcbiAgICByZXR1cm4gKDIgKiBuIC0gMyAqIHAgKyAxKSAqIGRbMF0gKyAobiAtIDIgKiBwICsgcikgKiBmWzBdICsgKC0yICogbiArIDMgKiBwKSAqIGRbMV0gKyAobiAtIHApICogZlsxXTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIGluZGV4IHRvIGludGVycG9sYXRlLlxuICAgKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IHNhbXBsZXMgdGhlIG9yaWdpbmFsIGFycmF5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gICAqL1xuICBzaW5jKHIsIGgpIHtcbiAgICByID0gdGhpcy5zY2FsZUZhY3Rvcl8gKiByO1xuICAgIGxldCBhID0gTWF0aC5mbG9vcihyKSwgZiA9IGEgLSB0aGlzLnNpbmNGaWx0ZXJTaXplXyArIDEsIGQgPSBhICsgdGhpcy5zaW5jRmlsdGVyU2l6ZV8sIHAgPSAwO1xuICAgIGZvciAobGV0IG4gPSBmOyBuIDw9IGQ7IG4rKylcbiAgICAgIHAgKz0gdGhpcy5rZXJuZWxfKHIgLSBuKSAqIHRoaXMuZ2V0Q2xpcHBlZElucHV0XyhuLCBoKTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVGhlIHNjYWxlZCBpbmRleCB0byBpbnRlcnBvbGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBzYW1wbGVzIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdGFuZ2VudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFRhbmdlbnRfKHIsIGgpIHtcbiAgICByZXR1cm4gdGhpcy50YW5nZW50RmFjdG9yXyAqICh0aGlzLmdldENsaXBwZWRJbnB1dF8ociArIDEsIGgpIC0gdGhpcy5nZXRDbGlwcGVkSW5wdXRfKHIgLSAxLCBoKSkgLyAyO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdCBUaGUgc2NhbGVkIGluZGV4IHRvIGludGVycG9sYXRlLlxuICAgKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IHNhbXBsZXMgdGhlIG9yaWdpbmFsIGFycmF5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRDbGlwcGVkSW5wdXRfKHIsIGgpIHtcbiAgICByZXR1cm4gMCA8PSByICYmIHIgPCB0aGlzLmxlbmd0aF8gPyBoW3JdIDogMDtcbiAgfVxufVxuZnVuY3Rpb24gaGkobCkge1xuICByZXR1cm4gTWF0aC5leHAoLWwgLyAyICogbCAvIDIpO1xufVxuZnVuY3Rpb24gbGkobCkge1xuICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBmaShyKSAqIGwocik7XG4gIH07XG59XG5mdW5jdGlvbiBmaShsKSB7XG4gIHJldHVybiBsID09PSAwID8gMSA6IE1hdGguc2luKE1hdGguUEkgKiBsKSAvIChNYXRoLlBJICogbCk7XG59XG5jbGFzcyBkaSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JkZXIgVGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVSYXRlIFRoZSBzYW1wbGUgcmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1dE9mZiBUaGUgY3V0IG9mZiBmcmVxdWVuY3kuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyLCBoLCBhKSB7XG4gICAgbGV0IGYgPSAyICogTWF0aC5QSSAqIGEgLyBoLCBkID0gMDtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8PSByOyBwKyspXG4gICAgICBwIC0gciAvIDIgPT09IDAgPyB0aGlzLmZpbHRlcnNbcF0gPSBmIDogKHRoaXMuZmlsdGVyc1twXSA9IE1hdGguc2luKGYgKiAocCAtIHIgLyAyKSkgLyAocCAtIHIgLyAyKSwgdGhpcy5maWx0ZXJzW3BdICo9IDAuNTQgLSAwLjQ2ICogTWF0aC5jb3MoMiAqIE1hdGguUEkgKiBwIC8gcikpLCBkID0gZCArIHRoaXMuZmlsdGVyc1twXTtcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8PSByOyBwKyspXG4gICAgICB0aGlzLmZpbHRlcnNbcF0gLz0gZDtcbiAgICB0aGlzLnogPSB0aGlzLmluaXRaXygpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlIEEgc2FtcGxlIG9mIGEgc2VxdWVuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGZpbHRlcihyKSB7XG4gICAgdGhpcy56LmJ1Zlt0aGlzLnoucG9pbnRlcl0gPSByO1xuICAgIGxldCBoID0gMDtcbiAgICBmb3IgKGxldCBhID0gMCwgZiA9IHRoaXMuei5idWYubGVuZ3RoOyBhIDwgZjsgYSsrKVxuICAgICAgaCArPSB0aGlzLmZpbHRlcnNbYV0gKiB0aGlzLnouYnVmWyh0aGlzLnoucG9pbnRlciArIGEpICUgdGhpcy56LmJ1Zi5sZW5ndGhdO1xuICAgIHJldHVybiB0aGlzLnoucG9pbnRlciA9ICh0aGlzLnoucG9pbnRlciArIDEpICUgdGhpcy56LmJ1Zi5sZW5ndGgsIGg7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBmaWx0ZXIuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnogPSB0aGlzLmluaXRaXygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHouXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0Wl8oKSB7XG4gICAgbGV0IHIgPSBbXTtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBoKyspXG4gICAgICByLnB1c2goMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJ1ZjogcixcbiAgICAgIHBvaW50ZXI6IDBcbiAgICB9O1xuICB9XG59XG5jbGFzcyBjaSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JkZXIgVGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVSYXRlIFRoZSBzYW1wbGUgcmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1dE9mZiBUaGUgY3V0IG9mZiBmcmVxdWVuY3kuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyLCBoLCBhKSB7XG4gICAgbGV0IGYgPSBbXTtcbiAgICBmb3IgKGxldCBkID0gMDsgZCA8IHI7IGQrKylcbiAgICAgIGYucHVzaCh0aGlzLmdldENvZWZmc18oe1xuICAgICAgICBGczogaCxcbiAgICAgICAgRmM6IGEsXG4gICAgICAgIFE6IDAuNSAvIE1hdGguc2luKE1hdGguUEkgLyAociAqIDIpICogKGQgKyAwLjUpKVxuICAgICAgfSkpO1xuICAgIHRoaXMuc3RhZ2VzID0gW107XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCBmLmxlbmd0aDsgZCsrKVxuICAgICAgdGhpcy5zdGFnZXNbZF0gPSB7XG4gICAgICAgIGIwOiBmW2RdLmJbMF0sXG4gICAgICAgIGIxOiBmW2RdLmJbMV0sXG4gICAgICAgIGIyOiBmW2RdLmJbMl0sXG4gICAgICAgIGExOiBmW2RdLmFbMF0sXG4gICAgICAgIGEyOiBmW2RdLmFbMV0sXG4gICAgICAgIGs6IGZbZF0uayxcbiAgICAgICAgejogWzAsIDBdXG4gICAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlIEEgc2FtcGxlIG9mIGEgc2VxdWVuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGZpbHRlcihyKSB7XG4gICAgbGV0IGggPSByO1xuICAgIGZvciAobGV0IGEgPSAwLCBmID0gdGhpcy5zdGFnZXMubGVuZ3RoOyBhIDwgZjsgYSsrKVxuICAgICAgaCA9IHRoaXMucnVuU3RhZ2VfKGEsIGgpO1xuICAgIHJldHVybiBoO1xuICB9XG4gIGdldENvZWZmc18ocikge1xuICAgIGxldCBoID0ge307XG4gICAgaC56ID0gWzAsIDBdLCBoLmEgPSBbXSwgaC5iID0gW107XG4gICAgbGV0IGEgPSB0aGlzLnByZUNhbGNfKHIsIGgpO1xuICAgIHJldHVybiBoLmsgPSAxLCBoLmIucHVzaCgoMSAtIGEuY3cpIC8gKDIgKiBhLmEwKSksIGguYi5wdXNoKDIgKiBoLmJbMF0pLCBoLmIucHVzaChoLmJbMF0pLCBoO1xuICB9XG4gIHByZUNhbGNfKHIsIGgpIHtcbiAgICBsZXQgYSA9IHt9LCBmID0gMiAqIE1hdGguUEkgKiByLkZjIC8gci5GcztcbiAgICByZXR1cm4gYS5hbHBoYSA9IE1hdGguc2luKGYpIC8gKDIgKiByLlEpLCBhLmN3ID0gTWF0aC5jb3MoZiksIGEuYTAgPSAxICsgYS5hbHBoYSwgaC5hMCA9IGEuYTAsIGguYS5wdXNoKC0yICogYS5jdyAvIGEuYTApLCBoLmsgPSAxLCBoLmEucHVzaCgoMSAtIGEuYWxwaGEpIC8gYS5hMCksIGE7XG4gIH1cbiAgcnVuU3RhZ2VfKHIsIGgpIHtcbiAgICBsZXQgYSA9IGggKiB0aGlzLnN0YWdlc1tyXS5rIC0gdGhpcy5zdGFnZXNbcl0uYTEgKiB0aGlzLnN0YWdlc1tyXS56WzBdIC0gdGhpcy5zdGFnZXNbcl0uYTIgKiB0aGlzLnN0YWdlc1tyXS56WzFdLCBmID0gdGhpcy5zdGFnZXNbcl0uYjAgKiBhICsgdGhpcy5zdGFnZXNbcl0uYjEgKiB0aGlzLnN0YWdlc1tyXS56WzBdICsgdGhpcy5zdGFnZXNbcl0uYjIgKiB0aGlzLnN0YWdlc1tyXS56WzFdO1xuICAgIHJldHVybiB0aGlzLnN0YWdlc1tyXS56WzFdID0gdGhpcy5zdGFnZXNbcl0uelswXSwgdGhpcy5zdGFnZXNbcl0uelswXSA9IGEsIGY7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBmaWx0ZXIuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHRoaXMuc3RhZ2VzLmxlbmd0aDsgcisrKVxuICAgICAgdGhpcy5zdGFnZXNbcl0ueiA9IFswLCAwXTtcbiAgfVxufVxuY29uc3QgdWkgPSB7XG4gIHBvaW50OiAhMSxcbiAgbGluZWFyOiAhMSxcbiAgY3ViaWM6ICEwLFxuICBzaW5jOiAhMFxufSwgd2UgPSB7XG4gIElJUjogMTYsXG4gIEZJUjogNzFcbn0sIHBpID0ge1xuICBJSVI6IGNpLFxuICBGSVI6IGRpXG59O1xuZnVuY3Rpb24gX2kobCwgciwgaCwgYSA9IHt9KSB7XG4gIGxldCBmID0gKGggLSByKSAvIHIgKyAxLCBkID0gbmV3IEZsb2F0NjRBcnJheShsLmxlbmd0aCAqIGYpO1xuICBhLm1ldGhvZCA9IGEubWV0aG9kIHx8IFwiY3ViaWNcIjtcbiAgbGV0IHAgPSBuZXcgb2koXG4gICAgbC5sZW5ndGgsXG4gICAgZC5sZW5ndGgsXG4gICAge1xuICAgICAgbWV0aG9kOiBhLm1ldGhvZCxcbiAgICAgIHRlbnNpb246IGEudGVuc2lvbiB8fCAwLFxuICAgICAgc2luY0ZpbHRlclNpemU6IGEuc2luY0ZpbHRlclNpemUgfHwgNixcbiAgICAgIHNpbmNXaW5kb3c6IGEuc2luY1dpbmRvdyB8fCB2b2lkIDBcbiAgICB9XG4gICk7XG4gIGlmIChhLkxQRiA9PT0gdm9pZCAwICYmIChhLkxQRiA9IHVpW2EubWV0aG9kXSksIGEuTFBGKSB7XG4gICAgYS5MUEZUeXBlID0gYS5MUEZUeXBlIHx8IFwiSUlSXCI7XG4gICAgY29uc3QgbiA9IHBpW2EuTFBGVHlwZV07XG4gICAgaWYgKGggPiByKSB7XG4gICAgICBsZXQgdiA9IG5ldyBuKFxuICAgICAgICBhLkxQRk9yZGVyIHx8IHdlW2EuTFBGVHlwZV0sXG4gICAgICAgIGgsXG4gICAgICAgIHIgLyAyXG4gICAgICApO1xuICAgICAgZ2koXG4gICAgICAgIGwsXG4gICAgICAgIGQsXG4gICAgICAgIHAsXG4gICAgICAgIHZcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB2ID0gbmV3IG4oXG4gICAgICAgIGEuTFBGT3JkZXIgfHwgd2VbYS5MUEZUeXBlXSxcbiAgICAgICAgcixcbiAgICAgICAgaCAvIDJcbiAgICAgICk7XG4gICAgICB5aShcbiAgICAgICAgbCxcbiAgICAgICAgZCxcbiAgICAgICAgcCxcbiAgICAgICAgdlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZVxuICAgIFJlKGwsIGQsIHApO1xuICByZXR1cm4gZDtcbn1cbmZ1bmN0aW9uIFJlKGwsIHIsIGgpIHtcbiAgZm9yIChsZXQgYSA9IDAsIGYgPSByLmxlbmd0aDsgYSA8IGY7IGErKylcbiAgICByW2FdID0gaC5pbnRlcnBvbGF0ZShhLCBsKTtcbn1cbmZ1bmN0aW9uIGdpKGwsIHIsIGgsIGEpIHtcbiAgZm9yIChsZXQgZiA9IDAsIGQgPSByLmxlbmd0aDsgZiA8IGQ7IGYrKylcbiAgICByW2ZdID0gYS5maWx0ZXIoaC5pbnRlcnBvbGF0ZShmLCBsKSk7XG4gIGEucmVzZXQoKTtcbiAgZm9yIChsZXQgZiA9IHIubGVuZ3RoIC0gMTsgZiA+PSAwOyBmLS0pXG4gICAgcltmXSA9IGEuZmlsdGVyKHJbZl0pO1xufVxuZnVuY3Rpb24geWkobCwgciwgaCwgYSkge1xuICBmb3IgKGxldCBmID0gMCwgZCA9IGwubGVuZ3RoOyBmIDwgZDsgZisrKVxuICAgIGxbZl0gPSBhLmZpbHRlcihsW2ZdKTtcbiAgYS5yZXNldCgpO1xuICBmb3IgKGxldCBmID0gbC5sZW5ndGggLSAxOyBmID49IDA7IGYtLSlcbiAgICBsW2ZdID0gYS5maWx0ZXIobFtmXSk7XG4gIFJlKGwsIHIsIGgpO1xufVxuZnVuY3Rpb24gTWUobCkge1xuICBjb25zdCByID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICBsLm1hcCgoYSkgPT4gYS5sZW5ndGgpLnJlZHVjZSgoYSwgZikgPT4gYSArIGYpXG4gICk7XG4gIGxldCBoID0gMDtcbiAgZm9yIChjb25zdCBhIG9mIGwpXG4gICAgci5zZXQoYSwgaCksIGggKz0gYS5sZW5ndGg7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gbWkobCkge1xuICBjb25zdCByID0gW107XG4gIGZvciAobGV0IGggPSAwOyBoIDwgbC5sZW5ndGg7IGggKz0gMSlcbiAgICBmb3IgKGxldCBhID0gMDsgYSA8IGxbaF0ubGVuZ3RoOyBhICs9IDEpXG4gICAgICByW2FdID09IG51bGwgJiYgKHJbYV0gPSBbXSksIHJbYV0ucHVzaChsW2hdW2FdKTtcbiAgcmV0dXJuIHIubWFwKE1lKTtcbn1cbmZ1bmN0aW9uIGxlKGwpIHtcbiAgaWYgKGwuZm9ybWF0ID09PSBcImYzMi1wbGFuYXJcIikge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IGwubnVtYmVyT2ZDaGFubmVsczsgaCArPSAxKSB7XG4gICAgICBjb25zdCBhID0gbC5hbGxvY2F0aW9uU2l6ZSh7IHBsYW5lSW5kZXg6IGggfSksIGYgPSBuZXcgQXJyYXlCdWZmZXIoYSk7XG4gICAgICBsLmNvcHlUbyhmLCB7IHBsYW5lSW5kZXg6IGggfSksIHIucHVzaChuZXcgRmxvYXQzMkFycmF5KGYpKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH0gZWxzZSBpZiAobC5mb3JtYXQgPT09IFwiZjMyXCIpIHtcbiAgICBjb25zdCByID0gbmV3IEFycmF5QnVmZmVyKGwuYWxsb2NhdGlvblNpemUoeyBwbGFuZUluZGV4OiAwIH0pKTtcbiAgICByZXR1cm4gbC5jb3B5VG8ociwgeyBwbGFuZUluZGV4OiAwIH0pLCB3aShuZXcgRmxvYXQzMkFycmF5KHIpLCBsLm51bWJlck9mQ2hhbm5lbHMpO1xuICB9IGVsc2UgaWYgKGwuZm9ybWF0ID09PSBcInMxNlwiKSB7XG4gICAgY29uc3QgciA9IG5ldyBBcnJheUJ1ZmZlcihsLmFsbG9jYXRpb25TaXplKHsgcGxhbmVJbmRleDogMCB9KSk7XG4gICAgcmV0dXJuIGwuY29weVRvKHIsIHsgcGxhbmVJbmRleDogMCB9KSwgdmkobmV3IEludDE2QXJyYXkociksIGwubnVtYmVyT2ZDaGFubmVscyk7XG4gIH1cbiAgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBhdWRpbyBkYXRhIGZvcm1hdFwiKTtcbn1cbmZ1bmN0aW9uIHZpKGwsIHIpIHtcbiAgY29uc3QgaCA9IGwubGVuZ3RoIC8gciwgYSA9IEFycmF5LmZyb20oXG4gICAgeyBsZW5ndGg6IHIgfSxcbiAgICAoKSA9PiBuZXcgRmxvYXQzMkFycmF5KGgpXG4gICk7XG4gIGZvciAobGV0IGYgPSAwOyBmIDwgaDsgZisrKVxuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgcjsgZCsrKSB7XG4gICAgICBjb25zdCBwID0gbFtmICogciArIGRdO1xuICAgICAgYVtkXVtmXSA9IHAgLyAzMjc2ODtcbiAgICB9XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gd2kobCwgcikge1xuICBjb25zdCBoID0gbC5sZW5ndGggLyByLCBhID0gQXJyYXkuZnJvbShcbiAgICB7IGxlbmd0aDogciB9LFxuICAgICgpID0+IG5ldyBGbG9hdDMyQXJyYXkoaClcbiAgKTtcbiAgZm9yIChsZXQgZiA9IDA7IGYgPCBoOyBmKyspXG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCByOyBkKyspXG4gICAgICBhW2RdW2ZdID0gbFtmICogciArIGRdO1xuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIE9lKGwpIHtcbiAgcmV0dXJuIEFycmF5KGwubnVtYmVyT2ZDaGFubmVscykuZmlsbCgwKS5tYXAoKHIsIGgpID0+IGwuZ2V0Q2hhbm5lbERhdGEoaCkpO1xufVxuZnVuY3Rpb24gZW4obCwgcikge1xuICBjb25zdCBoID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICBNZShsZShsKSlcbiAgKS5tYXAoKGYpID0+IGYgKiByKSwgYSA9IG5ldyBBdWRpb0RhdGEoe1xuICAgIHNhbXBsZVJhdGU6IGwuc2FtcGxlUmF0ZSxcbiAgICBudW1iZXJPZkNoYW5uZWxzOiBsLm51bWJlck9mQ2hhbm5lbHMsXG4gICAgdGltZXN0YW1wOiBsLnRpbWVzdGFtcCxcbiAgICBmb3JtYXQ6IGwuZm9ybWF0LFxuICAgIG51bWJlck9mRnJhbWVzOiBsLm51bWJlck9mRnJhbWVzLFxuICAgIGRhdGE6IGhcbiAgfSk7XG4gIHJldHVybiBsLmNsb3NlKCksIGE7XG59XG5hc3luYyBmdW5jdGlvbiBubihsLCByKSB7XG4gIHZhciBwO1xuICBjb25zdCBoID0ge1xuICAgIHR5cGU6IHIsXG4gICAgZGF0YTogbFxuICB9LCBhID0gbmV3IEltYWdlRGVjb2RlcihoKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoW2EuY29tcGxldGVkLCBhLnRyYWNrcy5yZWFkeV0pO1xuICBsZXQgZiA9ICgocCA9IGEudHJhY2tzLnNlbGVjdGVkVHJhY2spID09IG51bGwgPyB2b2lkIDAgOiBwLmZyYW1lQ291bnQpID8/IDE7XG4gIGNvbnN0IGQgPSBbXTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBmOyBuICs9IDEpXG4gICAgZC5wdXNoKChhd2FpdCBhLmRlY29kZSh7IGZyYW1lSW5kZXg6IG4gfSkpLmltYWdlKTtcbiAgcmV0dXJuIGQ7XG59XG5mdW5jdGlvbiBiZShsKSB7XG4gIHZhciBhLCBmO1xuICBjb25zdCByID0gTWF0aC5tYXgoLi4ubC5tYXAoKGQpID0+IHtcbiAgICB2YXIgcDtcbiAgICByZXR1cm4gKChwID0gZFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHAubGVuZ3RoKSA/PyAwO1xuICB9KSksIGggPSBuZXcgRmxvYXQzMkFycmF5KHIgKiAyKTtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCByOyBkKyspIHtcbiAgICBsZXQgcCA9IDAsIG4gPSAwO1xuICAgIGZvciAobGV0IHYgPSAwOyB2IDwgbC5sZW5ndGg7IHYrKykge1xuICAgICAgY29uc3QgYiA9ICgoYSA9IGxbdl1bMF0pID09IG51bGwgPyB2b2lkIDAgOiBhW2RdKSA/PyAwLCB5ID0gKChmID0gbFt2XVsxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGZbZF0pID8/IGI7XG4gICAgICBwICs9IGIsIG4gKz0geTtcbiAgICB9XG4gICAgaFtkXSA9IHAsIGhbZCArIHJdID0gbjtcbiAgfVxuICByZXR1cm4gaDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJpKGwsIHIsIGgpIHtcbiAgY29uc3QgYSA9IGwubGVuZ3RoLCBmID0gQXJyYXkoaC5jaGFuQ291bnQpLmZpbGwoMCkubWFwKCgpID0+IG5ldyBGbG9hdDMyQXJyYXkoMCkpO1xuICBpZiAoYSA9PT0gMCkgcmV0dXJuIGY7XG4gIGNvbnN0IGQgPSBNYXRoLm1heCguLi5sLm1hcCgoYikgPT4gYi5sZW5ndGgpKTtcbiAgaWYgKGQgPT09IDApIHJldHVybiBmO1xuICBpZiAoZ2xvYmFsVGhpcy5PZmZsaW5lQXVkaW9Db250ZXh0ID09IG51bGwpXG4gICAgcmV0dXJuIGwubWFwKFxuICAgICAgKGIpID0+IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgIF9pKGIsIHIsIGgucmF0ZSwgeyBtZXRob2Q6IFwic2luY1wiLCBMUEY6ICExIH0pXG4gICAgICApXG4gICAgKTtcbiAgY29uc3QgcCA9IG5ldyBnbG9iYWxUaGlzLk9mZmxpbmVBdWRpb0NvbnRleHQoXG4gICAgaC5jaGFuQ291bnQsXG4gICAgZCAqIGgucmF0ZSAvIHIsXG4gICAgaC5yYXRlXG4gICksIG4gPSBwLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpLCB2ID0gcC5jcmVhdGVCdWZmZXIoYSwgZCwgcik7XG4gIHJldHVybiBsLmZvckVhY2goKGIsIHkpID0+IHYuY29weVRvQ2hhbm5lbChiLCB5KSksIG4uYnVmZmVyID0gdiwgbi5jb25uZWN0KHAuZGVzdGluYXRpb24pLCBuLnN0YXJ0KCksIE9lKGF3YWl0IHAuc3RhcnRSZW5kZXJpbmcoKSk7XG59XG5mdW5jdGlvbiBOZShsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocikgPT4ge1xuICAgIGNvbnN0IGggPSBEZSgoKSA9PiB7XG4gICAgICBoKCksIHIoKTtcbiAgICB9LCBsKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBTaShsLCByLCBoKSB7XG4gIGNvbnN0IGEgPSBoIC0gciwgZiA9IG5ldyBGbG9hdDMyQXJyYXkoYSk7XG4gIGxldCBkID0gMDtcbiAgZm9yICg7IGQgPCBhOyApXG4gICAgZltkXSA9IGxbKHIgKyBkKSAlIGwubGVuZ3RoXSwgZCArPSAxO1xuICByZXR1cm4gZjtcbn1cbmZ1bmN0aW9uIGZlKGwsIHIpIHtcbiAgbGV0IGggPSAhMTtcbiAgYXN5bmMgZnVuY3Rpb24gYSgpIHtcbiAgICBjb25zdCBmID0gbC5nZXRSZWFkZXIoKTtcbiAgICBmb3IgKDsgIWg7ICkge1xuICAgICAgY29uc3QgeyB2YWx1ZTogZCwgZG9uZTogcCB9ID0gYXdhaXQgZi5yZWFkKCk7XG4gICAgICBpZiAocCkge1xuICAgICAgICByLm9uRG9uZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCByLm9uQ2h1bmsoZCk7XG4gICAgfVxuICAgIGYucmVsZWFzZUxvY2soKSwgYXdhaXQgbC5jYW5jZWwoKTtcbiAgfVxuICByZXR1cm4gYSgpLmNhdGNoKHouZXJyb3IpLCAoKSA9PiB7XG4gICAgaCA9ICEwO1xuICB9O1xufVxuZnVuY3Rpb24geGkobCkge1xuICByZXR1cm4gbCAmJiBsLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGwsIFwiZGVmYXVsdFwiKSA/IGwuZGVmYXVsdCA6IGw7XG59XG52YXIgR2UgPSB7fTtcbihmdW5jdGlvbihsKSB7XG4gIHZhciByID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGUgPSA0LCBpID0gMywgcyA9IDIsIG8gPSAxLCBjID0gZSwgdSA9IHtcbiAgICAgIHNldExvZ0xldmVsOiBmdW5jdGlvbihfKSB7XG4gICAgICAgIF8gPT0gdGhpcy5kZWJ1ZyA/IGMgPSBvIDogXyA9PSB0aGlzLmluZm8gPyBjID0gcyA6IF8gPT0gdGhpcy53YXJuID8gYyA9IGkgOiAoXyA9PSB0aGlzLmVycm9yLCBjID0gZSk7XG4gICAgICB9LFxuICAgICAgZGVidWc6IGZ1bmN0aW9uKF8sIGcpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyA9PT0gdm9pZCAwICYmIChjb25zb2xlLmRlYnVnID0gY29uc29sZS5sb2cpLCBvID49IGMgJiYgY29uc29sZS5kZWJ1ZyhcIltcIiArIHIuZ2V0RHVyYXRpb25TdHJpbmcoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgLSB0LCAxZTMpICsgXCJdXCIsIFwiW1wiICsgXyArIFwiXVwiLCBnKTtcbiAgICAgIH0sXG4gICAgICBsb2c6IGZ1bmN0aW9uKF8sIGcpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhfLm1zZyk7XG4gICAgICB9LFxuICAgICAgaW5mbzogZnVuY3Rpb24oXywgZykge1xuICAgICAgICBzID49IGMgJiYgY29uc29sZS5pbmZvKFwiW1wiICsgci5nZXREdXJhdGlvblN0cmluZygvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSAtIHQsIDFlMykgKyBcIl1cIiwgXCJbXCIgKyBfICsgXCJdXCIsIGcpO1xuICAgICAgfSxcbiAgICAgIHdhcm46IGZ1bmN0aW9uKF8sIGcpIHtcbiAgICAgICAgaSA+PSBjICYmIGNvbnNvbGUud2FybihcIltcIiArIHIuZ2V0RHVyYXRpb25TdHJpbmcoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgLSB0LCAxZTMpICsgXCJdXCIsIFwiW1wiICsgXyArIFwiXVwiLCBnKTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZnVuY3Rpb24oXywgZykge1xuICAgICAgICBlID49IGMgJiYgY29uc29sZS5lcnJvcihcIltcIiArIHIuZ2V0RHVyYXRpb25TdHJpbmcoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgLSB0LCAxZTMpICsgXCJdXCIsIFwiW1wiICsgXyArIFwiXVwiLCBnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB1O1xuICB9KCk7XG4gIHIuZ2V0RHVyYXRpb25TdHJpbmcgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGk7XG4gICAgZnVuY3Rpb24gcyh3LCBTKSB7XG4gICAgICBmb3IgKHZhciBVID0gXCJcIiArIHcsIEMgPSBVLnNwbGl0KFwiLlwiKTsgQ1swXS5sZW5ndGggPCBTOyApXG4gICAgICAgIENbMF0gPSBcIjBcIiArIENbMF07XG4gICAgICByZXR1cm4gQy5qb2luKFwiLlwiKTtcbiAgICB9XG4gICAgdCA8IDAgPyAoaSA9ICEwLCB0ID0gLXQpIDogaSA9ICExO1xuICAgIHZhciBvID0gZSB8fCAxLCBjID0gdCAvIG8sIHUgPSBNYXRoLmZsb29yKGMgLyAzNjAwKTtcbiAgICBjIC09IHUgKiAzNjAwO1xuICAgIHZhciBfID0gTWF0aC5mbG9vcihjIC8gNjApO1xuICAgIGMgLT0gXyAqIDYwO1xuICAgIHZhciBnID0gYyAqIDFlMztcbiAgICByZXR1cm4gYyA9IE1hdGguZmxvb3IoYyksIGcgLT0gYyAqIDFlMywgZyA9IE1hdGguZmxvb3IoZyksIChpID8gXCItXCIgOiBcIlwiKSArIHUgKyBcIjpcIiArIHMoXywgMikgKyBcIjpcIiArIHMoYywgMikgKyBcIi5cIiArIHMoZywgMyk7XG4gIH0sIHIucHJpbnRSYW5nZXMgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0Lmxlbmd0aDtcbiAgICBpZiAoZSA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSBcIlwiLCBzID0gMDsgcyA8IGU7IHMrKylcbiAgICAgICAgcyA+IDAgJiYgKGkgKz0gXCIsXCIpLCBpICs9IFwiW1wiICsgci5nZXREdXJhdGlvblN0cmluZyh0LnN0YXJ0KHMpKSArIFwiLFwiICsgci5nZXREdXJhdGlvblN0cmluZyh0LmVuZChzKSkgKyBcIl1cIjtcbiAgICAgIHJldHVybiBpO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIFwiKGVtcHR5KVwiO1xuICB9LCBsLkxvZyA9IHI7XG4gIHZhciBoID0gZnVuY3Rpb24odCkge1xuICAgIGlmICh0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICB0aGlzLmJ1ZmZlciA9IHQsIHRoaXMuZGF0YXZpZXcgPSBuZXcgRGF0YVZpZXcodCk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgXCJOZWVkcyBhbiBhcnJheSBidWZmZXJcIjtcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgfTtcbiAgaC5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbiAgfSwgaC5wcm90b3R5cGUuZ2V0RW5kUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgfSwgaC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH0sIGgucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoLCB0KSk7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPSBpc05hTihlKSB8fCAhaXNGaW5pdGUoZSkgPyAwIDogZSwgITA7XG4gIH0sIGgucHJvdG90eXBlLmlzRW9zID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9zaXRpb24oKSA+PSB0aGlzLmdldEVuZFBvc2l0aW9uKCk7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRBbnlJbnQgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh0aGlzLnBvc2l0aW9uICsgdCA8PSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGUgPyBpID0gdGhpcy5kYXRhdmlldy5nZXRJbnQ4KHRoaXMucG9zaXRpb24pIDogaSA9IHRoaXMuZGF0YXZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBlID8gaSA9IHRoaXMuZGF0YXZpZXcuZ2V0SW50MTYodGhpcy5wb3NpdGlvbikgOiBpID0gdGhpcy5kYXRhdmlldy5nZXRVaW50MTYodGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHRocm93IFwiTm8gbWV0aG9kIGZvciByZWFkaW5nIHNpZ25lZCAyNCBiaXRzIHZhbHVlc1wiO1xuICAgICAgICAgIGkgPSB0aGlzLmRhdGF2aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24pIDw8IDE2LCBpIHw9IHRoaXMuZGF0YXZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiArIDEpIDw8IDgsIGkgfD0gdGhpcy5kYXRhdmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBlID8gaSA9IHRoaXMuZGF0YXZpZXcuZ2V0SW50MzIodGhpcy5wb3NpdGlvbikgOiBpID0gdGhpcy5kYXRhdmlldy5nZXRVaW50MzIodGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHRocm93IFwiTm8gbWV0aG9kIGZvciByZWFkaW5nIHNpZ25lZCA2NCBiaXRzIHZhbHVlc1wiO1xuICAgICAgICAgIGkgPSB0aGlzLmRhdGF2aWV3LmdldFVpbnQzMih0aGlzLnBvc2l0aW9uKSA8PCAzMiwgaSB8PSB0aGlzLmRhdGF2aWV3LmdldFVpbnQzMih0aGlzLnBvc2l0aW9uICsgNCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgXCJyZWFkSW50IG1ldGhvZCBub3QgaW1wbGVtZW50ZWQgZm9yIHNpemU6IFwiICsgdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICs9IHQsIGk7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBcIk5vdCBlbm91Z2ggYnl0ZXMgaW4gYnVmZmVyXCI7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRVaW50OCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoMSwgITEpO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEFueUludCgyLCAhMSk7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRVaW50MjQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQW55SW50KDMsICExKTtcbiAgfSwgaC5wcm90b3R5cGUucmVhZFVpbnQzMiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoNCwgITEpO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkVWludDY0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEFueUludCg4LCAhMSk7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRTdHJpbmcgPSBmdW5jdGlvbih0KSB7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gKyB0IDw9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGUgPSBcIlwiLCBpID0gMDsgaSA8IHQ7IGkrKylcbiAgICAgICAgZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZFVpbnQ4KCkpO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBcIk5vdCBlbm91Z2ggYnl0ZXMgaW4gYnVmZmVyXCI7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRDU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgdCA9IFtdOyA7ICkge1xuICAgICAgdmFyIGUgPSB0aGlzLnJlYWRVaW50OCgpO1xuICAgICAgaWYgKGUgIT09IDApXG4gICAgICAgIHQucHVzaChlKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHQpO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoMSwgITApO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkSW50MTYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQW55SW50KDIsICEwKTtcbiAgfSwgaC5wcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEFueUludCg0LCAhMCk7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRJbnQ2NCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoOCwgITEpO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkVWludDhBcnJheSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gbmV3IFVpbnQ4QXJyYXkodCksIGkgPSAwOyBpIDwgdDsgaSsrKVxuICAgICAgZVtpXSA9IHRoaXMucmVhZFVpbnQ4KCk7XG4gICAgcmV0dXJuIGU7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRJbnQxNkFycmF5ID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgPSBuZXcgSW50MTZBcnJheSh0KSwgaSA9IDA7IGkgPCB0OyBpKyspXG4gICAgICBlW2ldID0gdGhpcy5yZWFkSW50MTYoKTtcbiAgICByZXR1cm4gZTtcbiAgfSwgaC5wcm90b3R5cGUucmVhZFVpbnQxNkFycmF5ID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgPSBuZXcgSW50MTZBcnJheSh0KSwgaSA9IDA7IGkgPCB0OyBpKyspXG4gICAgICBlW2ldID0gdGhpcy5yZWFkVWludDE2KCk7XG4gICAgcmV0dXJuIGU7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRVaW50MzJBcnJheSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gbmV3IFVpbnQzMkFycmF5KHQpLCBpID0gMDsgaSA8IHQ7IGkrKylcbiAgICAgIGVbaV0gPSB0aGlzLnJlYWRVaW50MzIoKTtcbiAgICByZXR1cm4gZTtcbiAgfSwgaC5wcm90b3R5cGUucmVhZEludDMyQXJyYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IG5ldyBJbnQzMkFycmF5KHQpLCBpID0gMDsgaSA8IHQ7IGkrKylcbiAgICAgIGVbaV0gPSB0aGlzLnJlYWRJbnQzMigpO1xuICAgIHJldHVybiBlO1xuICB9LCBsLk1QNEJveFN0cmVhbSA9IGg7XG4gIHZhciBhID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICAgIHRoaXMuX2J5dGVPZmZzZXQgPSBlIHx8IDAsIHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IHRoaXMuYnVmZmVyID0gdCA6IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyAodGhpcy5kYXRhVmlldyA9IHQsIGUgJiYgKHRoaXMuX2J5dGVPZmZzZXQgKz0gZSkpIDogdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodCB8fCAwKSwgdGhpcy5wb3NpdGlvbiA9IDAsIHRoaXMuZW5kaWFubmVzcyA9IGkgPz8gYS5MSVRUTEVfRU5ESUFOO1xuICB9O1xuICBhLnByb3RvdHlwZSA9IHt9LCBhLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICB9LCBhLnByb3RvdHlwZS5fcmVhbGxvYyA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodGhpcy5fZHluYW1pY1NpemUpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24gKyB0LCBpID0gdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAoZSA8PSBpKSB7XG4gICAgICAgIGUgPiB0aGlzLl9ieXRlTGVuZ3RoICYmICh0aGlzLl9ieXRlTGVuZ3RoID0gZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA8IDEgJiYgKGkgPSAxKTsgZSA+IGk7IClcbiAgICAgICAgaSAqPSAyO1xuICAgICAgdmFyIHMgPSBuZXcgQXJyYXlCdWZmZXIoaSksIG8gPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIpLCBjID0gbmV3IFVpbnQ4QXJyYXkocywgMCwgby5sZW5ndGgpO1xuICAgICAgYy5zZXQobyksIHRoaXMuYnVmZmVyID0gcywgdGhpcy5fYnl0ZUxlbmd0aCA9IGU7XG4gICAgfVxuICB9LCBhLnByb3RvdHlwZS5fdHJpbUFsbG9jID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2J5dGVMZW5ndGggIT0gdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHZhciB0ID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuX2J5dGVMZW5ndGgpLCBlID0gbmV3IFVpbnQ4QXJyYXkodCksIGkgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIsIDAsIGUubGVuZ3RoKTtcbiAgICAgIGUuc2V0KGkpLCB0aGlzLmJ1ZmZlciA9IHQ7XG4gICAgfVxuICB9LCBhLkJJR19FTkRJQU4gPSAhMSwgYS5MSVRUTEVfRU5ESUFOID0gITAsIGEucHJvdG90eXBlLl9ieXRlTGVuZ3RoID0gMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIGEucHJvdG90eXBlLFxuICAgIFwiYnl0ZUxlbmd0aFwiLFxuICAgIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ieXRlTGVuZ3RoIC0gdGhpcy5fYnl0ZU9mZnNldDtcbiAgICB9IH1cbiAgKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIGEucHJvdG90eXBlLFxuICAgIFwiYnVmZmVyXCIsXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaW1BbGxvYygpLCB0aGlzLl9idWZmZXI7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IHQsIHRoaXMuX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuX2J1ZmZlciwgdGhpcy5fYnl0ZU9mZnNldCksIHRoaXMuX2J5dGVMZW5ndGggPSB0aGlzLl9idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICBhLnByb3RvdHlwZSxcbiAgICBcImJ5dGVPZmZzZXRcIixcbiAgICB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZU9mZnNldDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy5fYnl0ZU9mZnNldCA9IHQsIHRoaXMuX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuX2J1ZmZlciwgdGhpcy5fYnl0ZU9mZnNldCksIHRoaXMuX2J5dGVMZW5ndGggPSB0aGlzLl9idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICBhLnByb3RvdHlwZSxcbiAgICBcImRhdGFWaWV3XCIsXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLl9ieXRlT2Zmc2V0ID0gdC5ieXRlT2Zmc2V0LCB0aGlzLl9idWZmZXIgPSB0LmJ1ZmZlciwgdGhpcy5fZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0KSwgdGhpcy5fYnl0ZUxlbmd0aCA9IHRoaXMuX2J5dGVPZmZzZXQgKyB0LmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICApLCBhLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5ieXRlTGVuZ3RoLCB0KSk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IGlzTmFOKGUpIHx8ICFpc0Zpbml0ZShlKSA/IDAgOiBlO1xuICB9LCBhLnByb3RvdHlwZS5pc0VvZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID49IHRoaXMuX2J5dGVMZW5ndGg7XG4gIH0sIGEucHJvdG90eXBlLm1hcFVpbnQ4QXJyYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5fcmVhbGxvYyh0ICogMSk7XG4gICAgdmFyIGUgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sIHQpO1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICs9IHQgKiAxLCBlO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkSW50MzJBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0ID0gdCA/PyB0aGlzLmJ5dGVMZW5ndGggLSB0aGlzLnBvc2l0aW9uIC8gNDtcbiAgICB2YXIgaSA9IG5ldyBJbnQzMkFycmF5KHQpO1xuICAgIHJldHVybiBhLm1lbWNweShcbiAgICAgIGkuYnVmZmVyLFxuICAgICAgMCxcbiAgICAgIHRoaXMuYnVmZmVyLFxuICAgICAgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbixcbiAgICAgIHQgKiBpLkJZVEVTX1BFUl9FTEVNRU5UXG4gICAgKSwgYS5hcnJheVRvTmF0aXZlKGksIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSBpLmJ5dGVMZW5ndGgsIGk7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRJbnQxNkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHQgPSB0ID8/IHRoaXMuYnl0ZUxlbmd0aCAtIHRoaXMucG9zaXRpb24gLyAyO1xuICAgIHZhciBpID0gbmV3IEludDE2QXJyYXkodCk7XG4gICAgcmV0dXJuIGEubWVtY3B5KFxuICAgICAgaS5idWZmZXIsXG4gICAgICAwLFxuICAgICAgdGhpcy5idWZmZXIsXG4gICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgdCAqIGkuQllURVNfUEVSX0VMRU1FTlRcbiAgICApLCBhLmFycmF5VG9OYXRpdmUoaSwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IGkuYnl0ZUxlbmd0aCwgaTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZEludDhBcnJheSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0ID0gdCA/PyB0aGlzLmJ5dGVMZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xuICAgIHZhciBlID0gbmV3IEludDhBcnJheSh0KTtcbiAgICByZXR1cm4gYS5tZW1jcHkoXG4gICAgICBlLmJ1ZmZlcixcbiAgICAgIDAsXG4gICAgICB0aGlzLmJ1ZmZlcixcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICB0ICogZS5CWVRFU19QRVJfRUxFTUVOVFxuICAgICksIHRoaXMucG9zaXRpb24gKz0gZS5ieXRlTGVuZ3RoLCBlO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkVWludDMyQXJyYXkgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdCA9IHQgPz8gdGhpcy5ieXRlTGVuZ3RoIC0gdGhpcy5wb3NpdGlvbiAvIDQ7XG4gICAgdmFyIGkgPSBuZXcgVWludDMyQXJyYXkodCk7XG4gICAgcmV0dXJuIGEubWVtY3B5KFxuICAgICAgaS5idWZmZXIsXG4gICAgICAwLFxuICAgICAgdGhpcy5idWZmZXIsXG4gICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgdCAqIGkuQllURVNfUEVSX0VMRU1FTlRcbiAgICApLCBhLmFycmF5VG9OYXRpdmUoaSwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IGkuYnl0ZUxlbmd0aCwgaTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZFVpbnQxNkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHQgPSB0ID8/IHRoaXMuYnl0ZUxlbmd0aCAtIHRoaXMucG9zaXRpb24gLyAyO1xuICAgIHZhciBpID0gbmV3IFVpbnQxNkFycmF5KHQpO1xuICAgIHJldHVybiBhLm1lbWNweShcbiAgICAgIGkuYnVmZmVyLFxuICAgICAgMCxcbiAgICAgIHRoaXMuYnVmZmVyLFxuICAgICAgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbixcbiAgICAgIHQgKiBpLkJZVEVTX1BFUl9FTEVNRU5UXG4gICAgKSwgYS5hcnJheVRvTmF0aXZlKGksIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSBpLmJ5dGVMZW5ndGgsIGk7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRVaW50OEFycmF5ID0gZnVuY3Rpb24odCkge1xuICAgIHQgPSB0ID8/IHRoaXMuYnl0ZUxlbmd0aCAtIHRoaXMucG9zaXRpb247XG4gICAgdmFyIGUgPSBuZXcgVWludDhBcnJheSh0KTtcbiAgICByZXR1cm4gYS5tZW1jcHkoXG4gICAgICBlLmJ1ZmZlcixcbiAgICAgIDAsXG4gICAgICB0aGlzLmJ1ZmZlcixcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICB0ICogZS5CWVRFU19QRVJfRUxFTUVOVFxuICAgICksIHRoaXMucG9zaXRpb24gKz0gZS5ieXRlTGVuZ3RoLCBlO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkRmxvYXQ2NEFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHQgPSB0ID8/IHRoaXMuYnl0ZUxlbmd0aCAtIHRoaXMucG9zaXRpb24gLyA4O1xuICAgIHZhciBpID0gbmV3IEZsb2F0NjRBcnJheSh0KTtcbiAgICByZXR1cm4gYS5tZW1jcHkoXG4gICAgICBpLmJ1ZmZlcixcbiAgICAgIDAsXG4gICAgICB0aGlzLmJ1ZmZlcixcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICB0ICogaS5CWVRFU19QRVJfRUxFTUVOVFxuICAgICksIGEuYXJyYXlUb05hdGl2ZShpLCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gaS5ieXRlTGVuZ3RoLCBpO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkRmxvYXQzMkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHQgPSB0ID8/IHRoaXMuYnl0ZUxlbmd0aCAtIHRoaXMucG9zaXRpb24gLyA0O1xuICAgIHZhciBpID0gbmV3IEZsb2F0MzJBcnJheSh0KTtcbiAgICByZXR1cm4gYS5tZW1jcHkoXG4gICAgICBpLmJ1ZmZlcixcbiAgICAgIDAsXG4gICAgICB0aGlzLmJ1ZmZlcixcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICB0ICogaS5CWVRFU19QRVJfRUxFTUVOVFxuICAgICksIGEuYXJyYXlUb05hdGl2ZShpLCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gaS5ieXRlTGVuZ3RoLCBpO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkSW50MzIgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0aGlzLl9kYXRhVmlldy5nZXRJbnQzMih0aGlzLnBvc2l0aW9uLCB0ID8/IHRoaXMuZW5kaWFubmVzcyk7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb24gKz0gNCwgZTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZEludDE2ID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MTYodGhpcy5wb3NpdGlvbiwgdCA/PyB0aGlzLmVuZGlhbm5lc3MpO1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICs9IDIsIGU7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSB0aGlzLl9kYXRhVmlldy5nZXRJbnQ4KHRoaXMucG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICs9IDEsIHQ7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0aGlzLl9kYXRhVmlldy5nZXRVaW50MzIodGhpcy5wb3NpdGlvbiwgdCA/PyB0aGlzLmVuZGlhbm5lc3MpO1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICs9IDQsIGU7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRVaW50MTYgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0aGlzLl9kYXRhVmlldy5nZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdCA/PyB0aGlzLmVuZGlhbm5lc3MpO1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICs9IDIsIGU7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRVaW50OCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbik7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb24gKz0gMSwgdDtcbiAgfSwgYS5wcm90b3R5cGUucmVhZEZsb2F0MzIgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0aGlzLl9kYXRhVmlldy5nZXRGbG9hdDMyKHRoaXMucG9zaXRpb24sIHQgPz8gdGhpcy5lbmRpYW5uZXNzKTtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiArPSA0LCBlO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkRmxvYXQ2NCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0NjQodGhpcy5wb3NpdGlvbiwgdCA/PyB0aGlzLmVuZGlhbm5lc3MpO1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICs9IDgsIGU7XG4gIH0sIGEuZW5kaWFubmVzcyA9IG5ldyBJbnQ4QXJyYXkobmV3IEludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID4gMCwgYS5tZW1jcHkgPSBmdW5jdGlvbih0LCBlLCBpLCBzLCBvKSB7XG4gICAgdmFyIGMgPSBuZXcgVWludDhBcnJheSh0LCBlLCBvKSwgdSA9IG5ldyBVaW50OEFycmF5KGksIHMsIG8pO1xuICAgIGMuc2V0KHUpO1xuICB9LCBhLmFycmF5VG9OYXRpdmUgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgcmV0dXJuIGUgPT0gdGhpcy5lbmRpYW5uZXNzID8gdCA6IHRoaXMuZmxpcEFycmF5RW5kaWFubmVzcyh0KTtcbiAgfSwgYS5uYXRpdmVUb0VuZGlhbiA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRpYW5uZXNzID09IGUgPyB0IDogdGhpcy5mbGlwQXJyYXlFbmRpYW5uZXNzKHQpO1xuICB9LCBhLmZsaXBBcnJheUVuZGlhbm5lc3MgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IG5ldyBVaW50OEFycmF5KHQuYnVmZmVyLCB0LmJ5dGVPZmZzZXQsIHQuYnl0ZUxlbmd0aCksIGkgPSAwOyBpIDwgdC5ieXRlTGVuZ3RoOyBpICs9IHQuQllURVNfUEVSX0VMRU1FTlQpXG4gICAgICBmb3IgKHZhciBzID0gaSArIHQuQllURVNfUEVSX0VMRU1FTlQgLSAxLCBvID0gaTsgcyA+IG87IHMtLSwgbysrKSB7XG4gICAgICAgIHZhciBjID0gZVtvXTtcbiAgICAgICAgZVtvXSA9IGVbc10sIGVbc10gPSBjO1xuICAgICAgfVxuICAgIHJldHVybiB0O1xuICB9LCBhLnByb3RvdHlwZS5mYWlsdXJlUG9zaXRpb24gPSAwLCBTdHJpbmcuZnJvbUNoYXJDb2RlVWludDggPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IFtdLCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgICBlW2ldID0gdFtpXTtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBlKTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICByZXR1cm4gZSA9PSBudWxsIHx8IGUgPT0gXCJBU0NJSVwiID8gU3RyaW5nLmZyb21DaGFyQ29kZVVpbnQ4LmFwcGx5KG51bGwsIFt0aGlzLm1hcFVpbnQ4QXJyYXkodCA/PyB0aGlzLmJ5dGVMZW5ndGggLSB0aGlzLnBvc2l0aW9uKV0pIDogbmV3IFRleHREZWNvZGVyKGUpLmRlY29kZSh0aGlzLm1hcFVpbnQ4QXJyYXkodCkpO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkQ1N0cmluZyA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHRoaXMuYnl0ZUxlbmd0aCAtIHRoaXMucG9zaXRpb24sIGkgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuX2J5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uKSwgcyA9IGU7XG4gICAgdCAhPSBudWxsICYmIChzID0gTWF0aC5taW4odCwgZSkpO1xuICAgIGZvciAodmFyIG8gPSAwOyBvIDwgcyAmJiBpW29dICE9PSAwOyBvKyspIDtcbiAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGVVaW50OC5hcHBseShudWxsLCBbdGhpcy5tYXBVaW50OEFycmF5KG8pXSk7XG4gICAgcmV0dXJuIHQgIT0gbnVsbCA/IHRoaXMucG9zaXRpb24gKz0gcyAtIG8gOiBvICE9IGUgJiYgKHRoaXMucG9zaXRpb24gKz0gMSksIGM7XG4gIH07XG4gIHZhciBmID0gTWF0aC5wb3coMiwgMzIpO1xuICBhLnByb3RvdHlwZS5yZWFkSW50NjQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkSW50MzIoKSAqIGYgKyB0aGlzLnJlYWRVaW50MzIoKTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZFVpbnQ2NCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRVaW50MzIoKSAqIGYgKyB0aGlzLnJlYWRVaW50MzIoKTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZFVpbnQzMigpICogZiArIHRoaXMucmVhZFVpbnQzMigpO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkVWludDI0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlYWRVaW50OCgpIDw8IDE2KSArICh0aGlzLnJlYWRVaW50OCgpIDw8IDgpICsgdGhpcy5yZWFkVWludDgoKTtcbiAgfSwgbC5EYXRhU3RyZWFtID0gYSwgYS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IG5ldyBCbG9iKFt0aGlzLmJ1ZmZlcl0pO1xuICAgIGlmICh3aW5kb3cuVVJMICYmIFVSTC5jcmVhdGVPYmplY3RVUkwpIHtcbiAgICAgIHZhciBpID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoZSksIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocyksIHMuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBpKSwgcy5zZXRBdHRyaWJ1dGUoXCJkb3dubG9hZFwiLCB0KSwgcy5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgXCJfc2VsZlwiKSwgcy5jbGljaygpLCB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTChpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IFwiRGF0YVN0cmVhbS5zYXZlOiBDYW4ndCBjcmVhdGUgb2JqZWN0IFVSTC5cIjtcbiAgfSwgYS5wcm90b3R5cGUuX2R5bmFtaWNTaXplID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICBhLnByb3RvdHlwZSxcbiAgICBcImR5bmFtaWNTaXplXCIsXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R5bmFtaWNTaXplO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odCkge1xuICAgICAgICB0IHx8IHRoaXMuX3RyaW1BbGxvYygpLCB0aGlzLl9keW5hbWljU2l6ZSA9IHQ7XG4gICAgICB9XG4gICAgfVxuICApLCBhLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLl9ieXRlTGVuZ3RoIC0gdCksIGkgPSBuZXcgVWludDhBcnJheShlKSwgcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1ZmZlciwgdCwgaS5sZW5ndGgpO1xuICAgIGkuc2V0KHMpLCB0aGlzLmJ1ZmZlciA9IGUsIHRoaXMucG9zaXRpb24gLT0gdDtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVJbnQzMkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIGlmICh0aGlzLl9yZWFsbG9jKHQubGVuZ3RoICogNCksIHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5ICYmIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24gJSB0LkJZVEVTX1BFUl9FTEVNRU5UID09PSAwKVxuICAgICAgYS5tZW1jcHkoXG4gICAgICAgIHRoaXMuX2J1ZmZlcixcbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbixcbiAgICAgICAgdC5idWZmZXIsXG4gICAgICAgIDAsXG4gICAgICAgIHQuYnl0ZUxlbmd0aFxuICAgICAgKSwgdGhpcy5tYXBJbnQzMkFycmF5KHQubGVuZ3RoLCBlKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMud3JpdGVJbnQzMih0W2ldLCBlKTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVJbnQxNkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIGlmICh0aGlzLl9yZWFsbG9jKHQubGVuZ3RoICogMiksIHQgaW5zdGFuY2VvZiBJbnQxNkFycmF5ICYmIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24gJSB0LkJZVEVTX1BFUl9FTEVNRU5UID09PSAwKVxuICAgICAgYS5tZW1jcHkoXG4gICAgICAgIHRoaXMuX2J1ZmZlcixcbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbixcbiAgICAgICAgdC5idWZmZXIsXG4gICAgICAgIDAsXG4gICAgICAgIHQuYnl0ZUxlbmd0aFxuICAgICAgKSwgdGhpcy5tYXBJbnQxNkFycmF5KHQubGVuZ3RoLCBlKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMud3JpdGVJbnQxNih0W2ldLCBlKTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVJbnQ4QXJyYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgaWYgKHRoaXMuX3JlYWxsb2ModC5sZW5ndGggKiAxKSwgdCBpbnN0YW5jZW9mIEludDhBcnJheSAmJiB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uICUgdC5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMClcbiAgICAgIGEubWVtY3B5KFxuICAgICAgICB0aGlzLl9idWZmZXIsXG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICAgIHQuYnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICB0LmJ5dGVMZW5ndGhcbiAgICAgICksIHRoaXMubWFwSW50OEFycmF5KHQubGVuZ3RoKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQubGVuZ3RoOyBlKyspXG4gICAgICAgIHRoaXMud3JpdGVJbnQ4KHRbZV0pO1xuICB9LCBhLnByb3RvdHlwZS53cml0ZVVpbnQzMkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIGlmICh0aGlzLl9yZWFsbG9jKHQubGVuZ3RoICogNCksIHQgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uICUgdC5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMClcbiAgICAgIGEubWVtY3B5KFxuICAgICAgICB0aGlzLl9idWZmZXIsXG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICAgIHQuYnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICB0LmJ5dGVMZW5ndGhcbiAgICAgICksIHRoaXMubWFwVWludDMyQXJyYXkodC5sZW5ndGgsIGUpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy53cml0ZVVpbnQzMih0W2ldLCBlKTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVVaW50MTZBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICBpZiAodGhpcy5fcmVhbGxvYyh0Lmxlbmd0aCAqIDIpLCB0IGluc3RhbmNlb2YgVWludDE2QXJyYXkgJiYgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiAlIHQuQllURVNfUEVSX0VMRU1FTlQgPT09IDApXG4gICAgICBhLm1lbWNweShcbiAgICAgICAgdGhpcy5fYnVmZmVyLFxuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgICB0LmJ1ZmZlcixcbiAgICAgICAgMCxcbiAgICAgICAgdC5ieXRlTGVuZ3RoXG4gICAgICApLCB0aGlzLm1hcFVpbnQxNkFycmF5KHQubGVuZ3RoLCBlKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMud3JpdGVVaW50MTYodFtpXSwgZSk7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlVWludDhBcnJheSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodGhpcy5fcmVhbGxvYyh0Lmxlbmd0aCAqIDEpLCB0IGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uICUgdC5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMClcbiAgICAgIGEubWVtY3B5KFxuICAgICAgICB0aGlzLl9idWZmZXIsXG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICAgIHQuYnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICB0LmJ5dGVMZW5ndGhcbiAgICAgICksIHRoaXMubWFwVWludDhBcnJheSh0Lmxlbmd0aCk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSsrKVxuICAgICAgICB0aGlzLndyaXRlVWludDgodFtlXSk7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlRmxvYXQ2NEFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIGlmICh0aGlzLl9yZWFsbG9jKHQubGVuZ3RoICogOCksIHQgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgJiYgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiAlIHQuQllURVNfUEVSX0VMRU1FTlQgPT09IDApXG4gICAgICBhLm1lbWNweShcbiAgICAgICAgdGhpcy5fYnVmZmVyLFxuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgICB0LmJ1ZmZlcixcbiAgICAgICAgMCxcbiAgICAgICAgdC5ieXRlTGVuZ3RoXG4gICAgICApLCB0aGlzLm1hcEZsb2F0NjRBcnJheSh0Lmxlbmd0aCwgZSk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLndyaXRlRmxvYXQ2NCh0W2ldLCBlKTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVGbG9hdDMyQXJyYXkgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWxsb2ModC5sZW5ndGggKiA0KSwgdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSAmJiB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uICUgdC5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMClcbiAgICAgIGEubWVtY3B5KFxuICAgICAgICB0aGlzLl9idWZmZXIsXG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICAgIHQuYnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICB0LmJ5dGVMZW5ndGhcbiAgICAgICksIHRoaXMubWFwRmxvYXQzMkFycmF5KHQubGVuZ3RoLCBlKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMud3JpdGVGbG9hdDMyKHRbaV0sIGUpO1xuICB9LCBhLnByb3RvdHlwZS53cml0ZUludDMyID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHRoaXMuX3JlYWxsb2MoNCksIHRoaXMuX2RhdGFWaWV3LnNldEludDMyKHRoaXMucG9zaXRpb24sIHQsIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSA0O1xuICB9LCBhLnByb3RvdHlwZS53cml0ZUludDE2ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHRoaXMuX3JlYWxsb2MoMiksIHRoaXMuX2RhdGFWaWV3LnNldEludDE2KHRoaXMucG9zaXRpb24sIHQsIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSAyO1xuICB9LCBhLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5fcmVhbGxvYygxKSwgdGhpcy5fZGF0YVZpZXcuc2V0SW50OCh0aGlzLnBvc2l0aW9uLCB0KSwgdGhpcy5wb3NpdGlvbiArPSAxO1xuICB9LCBhLnByb3RvdHlwZS53cml0ZVVpbnQzMiA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl9yZWFsbG9jKDQpLCB0aGlzLl9kYXRhVmlldy5zZXRVaW50MzIodGhpcy5wb3NpdGlvbiwgdCwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IDQ7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlVWludDE2ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHRoaXMuX3JlYWxsb2MoMiksIHRoaXMuX2RhdGFWaWV3LnNldFVpbnQxNih0aGlzLnBvc2l0aW9uLCB0LCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVVaW50OCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLl9yZWFsbG9jKDEpLCB0aGlzLl9kYXRhVmlldy5zZXRVaW50OCh0aGlzLnBvc2l0aW9uLCB0KSwgdGhpcy5wb3NpdGlvbiArPSAxO1xuICB9LCBhLnByb3RvdHlwZS53cml0ZUZsb2F0MzIgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdGhpcy5fcmVhbGxvYyg0KSwgdGhpcy5fZGF0YVZpZXcuc2V0RmxvYXQzMih0aGlzLnBvc2l0aW9uLCB0LCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVGbG9hdDY0ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHRoaXMuX3JlYWxsb2MoOCksIHRoaXMuX2RhdGFWaWV3LnNldEZsb2F0NjQodGhpcy5wb3NpdGlvbiwgdCwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IDg7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlVUNTMlN0cmluZyA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICBpID09IG51bGwgJiYgKGkgPSB0Lmxlbmd0aCk7XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCB0Lmxlbmd0aCAmJiBzIDwgaTsgcysrKVxuICAgICAgdGhpcy53cml0ZVVpbnQxNih0LmNoYXJDb2RlQXQocyksIGUpO1xuICAgIGZvciAoOyBzIDwgaTsgcysrKVxuICAgICAgdGhpcy53cml0ZVVpbnQxNigwKTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVTdHJpbmcgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgdmFyIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA9PSBcIkFTQ0lJXCIpXG4gICAgICBpZiAoaSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvID0gTWF0aC5taW4odC5sZW5ndGgsIGkpO1xuICAgICAgICBmb3IgKHMgPSAwOyBzIDwgbzsgcysrKVxuICAgICAgICAgIHRoaXMud3JpdGVVaW50OCh0LmNoYXJDb2RlQXQocykpO1xuICAgICAgICBmb3IgKDsgcyA8IGk7IHMrKylcbiAgICAgICAgICB0aGlzLndyaXRlVWludDgoMCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9yIChzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspXG4gICAgICAgICAgdGhpcy53cml0ZVVpbnQ4KHQuY2hhckNvZGVBdChzKSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy53cml0ZVVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKGUpLmVuY29kZSh0LnN1YnN0cmluZygwLCBpKSkpO1xuICB9LCBhLnByb3RvdHlwZS53cml0ZUNTdHJpbmcgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmIChlICE9IG51bGwpIHtcbiAgICAgIHZhciBzID0gTWF0aC5taW4odC5sZW5ndGgsIGUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKylcbiAgICAgICAgdGhpcy53cml0ZVVpbnQ4KHQuY2hhckNvZGVBdChpKSk7XG4gICAgICBmb3IgKDsgaSA8IGU7IGkrKylcbiAgICAgICAgdGhpcy53cml0ZVVpbnQ4KDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy53cml0ZVVpbnQ4KHQuY2hhckNvZGVBdChpKSk7XG4gICAgICB0aGlzLndyaXRlVWludDgoMCk7XG4gICAgfVxuICB9LCBhLnByb3RvdHlwZS53cml0ZVN0cnVjdCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciBzID0gdFtpICsgMV07XG4gICAgICB0aGlzLndyaXRlVHlwZShzLCBlW3RbaV1dLCBlKTtcbiAgICB9XG4gIH0sIGEucHJvdG90eXBlLndyaXRlVHlwZSA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICB2YXIgcztcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIHQodGhpcywgZSk7XG4gICAgaWYgKHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgISh0IGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgcmV0dXJuIHQuc2V0KHRoaXMsIGUsIGkpO1xuICAgIHZhciBvID0gbnVsbCwgYyA9IFwiQVNDSUlcIiwgdSA9IHRoaXMucG9zaXRpb247XG4gICAgc3dpdGNoICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmIC86Ly50ZXN0KHQpICYmIChzID0gdC5zcGxpdChcIjpcIiksIHQgPSBzWzBdLCBvID0gcGFyc2VJbnQoc1sxXSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmIC8sLy50ZXN0KHQpICYmIChzID0gdC5zcGxpdChcIixcIiksIHQgPSBzWzBdLCBjID0gcGFyc2VJbnQoc1sxXSkpLCB0KSB7XG4gICAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgdGhpcy53cml0ZVVpbnQ4KGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICAgIHRoaXMud3JpdGVJbnQ4KGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgdGhpcy53cml0ZVVpbnQxNihlLCB0aGlzLmVuZGlhbm5lc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICB0aGlzLndyaXRlSW50MTYoZSwgdGhpcy5lbmRpYW5uZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgIHRoaXMud3JpdGVVaW50MzIoZSwgdGhpcy5lbmRpYW5uZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgdGhpcy53cml0ZUludDMyKGUsIHRoaXMuZW5kaWFubmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZsb2F0MzJcIjpcbiAgICAgICAgdGhpcy53cml0ZUZsb2F0MzIoZSwgdGhpcy5lbmRpYW5uZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmxvYXQ2NFwiOlxuICAgICAgICB0aGlzLndyaXRlRmxvYXQ2NChlLCB0aGlzLmVuZGlhbm5lc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ1aW50MTZiZVwiOlxuICAgICAgICB0aGlzLndyaXRlVWludDE2KGUsIGEuQklHX0VORElBTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludDE2YmVcIjpcbiAgICAgICAgdGhpcy53cml0ZUludDE2KGUsIGEuQklHX0VORElBTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInVpbnQzMmJlXCI6XG4gICAgICAgIHRoaXMud3JpdGVVaW50MzIoZSwgYS5CSUdfRU5ESUFOKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW50MzJiZVwiOlxuICAgICAgICB0aGlzLndyaXRlSW50MzIoZSwgYS5CSUdfRU5ESUFOKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmxvYXQzMmJlXCI6XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdDMyKGUsIGEuQklHX0VORElBTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZsb2F0NjRiZVwiOlxuICAgICAgICB0aGlzLndyaXRlRmxvYXQ2NChlLCBhLkJJR19FTkRJQU4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ1aW50MTZsZVwiOlxuICAgICAgICB0aGlzLndyaXRlVWludDE2KGUsIGEuTElUVExFX0VORElBTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludDE2bGVcIjpcbiAgICAgICAgdGhpcy53cml0ZUludDE2KGUsIGEuTElUVExFX0VORElBTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInVpbnQzMmxlXCI6XG4gICAgICAgIHRoaXMud3JpdGVVaW50MzIoZSwgYS5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW50MzJsZVwiOlxuICAgICAgICB0aGlzLndyaXRlSW50MzIoZSwgYS5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmxvYXQzMmxlXCI6XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdDMyKGUsIGEuTElUVExFX0VORElBTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZsb2F0NjRsZVwiOlxuICAgICAgICB0aGlzLndyaXRlRmxvYXQ2NChlLCBhLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjc3RyaW5nXCI6XG4gICAgICAgIHRoaXMud3JpdGVDU3RyaW5nKGUsIG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgdGhpcy53cml0ZVN0cmluZyhlLCBjLCBvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidTE2c3RyaW5nXCI6XG4gICAgICAgIHRoaXMud3JpdGVVQ1MyU3RyaW5nKGUsIHRoaXMuZW5kaWFubmVzcywgbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInUxNnN0cmluZ2xlXCI6XG4gICAgICAgIHRoaXMud3JpdGVVQ1MyU3RyaW5nKGUsIGEuTElUVExFX0VORElBTiwgbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInUxNnN0cmluZ2JlXCI6XG4gICAgICAgIHRoaXMud3JpdGVVQ1MyU3RyaW5nKGUsIGEuQklHX0VORElBTiwgbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHQubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICBmb3IgKHZhciBfID0gdFsxXSwgZyA9IDA7IGcgPCBlLmxlbmd0aDsgZysrKVxuICAgICAgICAgICAgdGhpcy53cml0ZVR5cGUoXywgZVtnXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy53cml0ZVN0cnVjdCh0LCBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBvICE9IG51bGwgJiYgKHRoaXMucG9zaXRpb24gPSB1LCB0aGlzLl9yZWFsbG9jKG8pLCB0aGlzLnBvc2l0aW9uID0gdSArIG8pO1xuICB9LCBhLnByb3RvdHlwZS53cml0ZVVpbnQ2NCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IE1hdGguZmxvb3IodCAvIGYpO1xuICAgIHRoaXMud3JpdGVVaW50MzIoZSksIHRoaXMud3JpdGVVaW50MzIodCAmIDQyOTQ5NjcyOTUpO1xuICB9LCBhLnByb3RvdHlwZS53cml0ZVVpbnQyNCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLndyaXRlVWludDgoKHQgJiAxNjcxMTY4MCkgPj4gMTYpLCB0aGlzLndyaXRlVWludDgoKHQgJiA2NTI4MCkgPj4gOCksIHRoaXMud3JpdGVVaW50OCh0ICYgMjU1KTtcbiAgfSwgYS5wcm90b3R5cGUuYWRqdXN0VWludDMyID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbjtcbiAgICB0aGlzLnNlZWsodCksIHRoaXMud3JpdGVVaW50MzIoZSksIHRoaXMuc2VlayhpKTtcbiAgfSwgYS5wcm90b3R5cGUubWFwSW50MzJBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl9yZWFsbG9jKHQgKiA0KTtcbiAgICB2YXIgaSA9IG5ldyBJbnQzMkFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiwgdCk7XG4gICAgcmV0dXJuIGEuYXJyYXlUb05hdGl2ZShpLCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gdCAqIDQsIGk7XG4gIH0sIGEucHJvdG90eXBlLm1hcEludDE2QXJyYXkgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdGhpcy5fcmVhbGxvYyh0ICogMik7XG4gICAgdmFyIGkgPSBuZXcgSW50MTZBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sIHQpO1xuICAgIHJldHVybiBhLmFycmF5VG9OYXRpdmUoaSwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IHQgKiAyLCBpO1xuICB9LCBhLnByb3RvdHlwZS5tYXBJbnQ4QXJyYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5fcmVhbGxvYyh0ICogMSk7XG4gICAgdmFyIGUgPSBuZXcgSW50OEFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiwgdCk7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb24gKz0gdCAqIDEsIGU7XG4gIH0sIGEucHJvdG90eXBlLm1hcFVpbnQzMkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHRoaXMuX3JlYWxsb2ModCAqIDQpO1xuICAgIHZhciBpID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiwgdCk7XG4gICAgcmV0dXJuIGEuYXJyYXlUb05hdGl2ZShpLCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gdCAqIDQsIGk7XG4gIH0sIGEucHJvdG90eXBlLm1hcFVpbnQxNkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHRoaXMuX3JlYWxsb2ModCAqIDIpO1xuICAgIHZhciBpID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiwgdCk7XG4gICAgcmV0dXJuIGEuYXJyYXlUb05hdGl2ZShpLCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gdCAqIDIsIGk7XG4gIH0sIGEucHJvdG90eXBlLm1hcEZsb2F0NjRBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl9yZWFsbG9jKHQgKiA4KTtcbiAgICB2YXIgaSA9IG5ldyBGbG9hdDY0QXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLCB0KTtcbiAgICByZXR1cm4gYS5hcnJheVRvTmF0aXZlKGksIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSB0ICogOCwgaTtcbiAgfSwgYS5wcm90b3R5cGUubWFwRmxvYXQzMkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHRoaXMuX3JlYWxsb2ModCAqIDQpO1xuICAgIHZhciBpID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sIHQpO1xuICAgIHJldHVybiBhLmFycmF5VG9OYXRpdmUoaSwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IHQgKiA0LCBpO1xuICB9O1xuICB2YXIgZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBbXSwgdGhpcy5idWZmZXJJbmRleCA9IC0xLCB0ICYmICh0aGlzLmluc2VydEJ1ZmZlcih0KSwgdGhpcy5idWZmZXJJbmRleCA9IDApO1xuICB9O1xuICBkLnByb3RvdHlwZSA9IG5ldyBhKG5ldyBBcnJheUJ1ZmZlcigpLCAwLCBhLkJJR19FTkRJQU4pLCBkLnByb3RvdHlwZS5pbml0aWFsaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0O1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlckluZGV4ID4gLTEgPyAhMCA6IHRoaXMuYnVmZmVycy5sZW5ndGggPiAwID8gKHQgPSB0aGlzLmJ1ZmZlcnNbMF0sIHQuZmlsZVN0YXJ0ID09PSAwID8gKHRoaXMuYnVmZmVyID0gdCwgdGhpcy5idWZmZXJJbmRleCA9IDAsIHIuZGVidWcoXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIlN0cmVhbSByZWFkeSBmb3IgcGFyc2luZ1wiKSwgITApIDogKHIud2FybihcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiVGhlIGZpcnN0IGJ1ZmZlciBzaG91bGQgaGF2ZSBhIGZpbGVTdGFydCBvZiAwXCIpLCB0aGlzLmxvZ0J1ZmZlckxldmVsKCksICExKSkgOiAoci53YXJuKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJObyBidWZmZXIgdG8gc3RhcnQgcGFyc2luZyBmcm9tXCIpLCB0aGlzLmxvZ0J1ZmZlckxldmVsKCksICExKTtcbiAgfSwgQXJyYXlCdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHIuZGVidWcoXCJBcnJheUJ1ZmZlclwiLCBcIlRyeWluZyB0byBjcmVhdGUgYSBuZXcgYnVmZmVyIG9mIHNpemU6IFwiICsgKHQuYnl0ZUxlbmd0aCArIGUuYnl0ZUxlbmd0aCkpO1xuICAgIHZhciBpID0gbmV3IFVpbnQ4QXJyYXkodC5ieXRlTGVuZ3RoICsgZS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gaS5zZXQobmV3IFVpbnQ4QXJyYXkodCksIDApLCBpLnNldChuZXcgVWludDhBcnJheShlKSwgdC5ieXRlTGVuZ3RoKSwgaS5idWZmZXI7XG4gIH0sIGQucHJvdG90eXBlLnJlZHVjZUJ1ZmZlciA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICB2YXIgcztcbiAgICByZXR1cm4gcyA9IG5ldyBVaW50OEFycmF5KGkpLCBzLnNldChuZXcgVWludDhBcnJheSh0LCBlLCBpKSksIHMuYnVmZmVyLmZpbGVTdGFydCA9IHQuZmlsZVN0YXJ0ICsgZSwgcy5idWZmZXIudXNlZEJ5dGVzID0gMCwgcy5idWZmZXI7XG4gIH0sIGQucHJvdG90eXBlLmluc2VydEJ1ZmZlciA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gITAsIGkgPSAwOyBpIDwgdGhpcy5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuYnVmZmVyc1tpXTtcbiAgICAgIGlmICh0LmZpbGVTdGFydCA8PSBzLmZpbGVTdGFydCkge1xuICAgICAgICBpZiAodC5maWxlU3RhcnQgPT09IHMuZmlsZVN0YXJ0KVxuICAgICAgICAgIGlmICh0LmJ5dGVMZW5ndGggPiBzLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5zcGxpY2UoaSwgMSksIGktLTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgci53YXJuKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJCdWZmZXIgKGZpbGVTdGFydDogXCIgKyB0LmZpbGVTdGFydCArIFwiIC0gTGVuZ3RoOiBcIiArIHQuYnl0ZUxlbmd0aCArIFwiKSBhbHJlYWR5IGFwcGVuZGVkLCBpZ25vcmluZ1wiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHQuZmlsZVN0YXJ0ICsgdC5ieXRlTGVuZ3RoIDw9IHMuZmlsZVN0YXJ0IHx8ICh0ID0gdGhpcy5yZWR1Y2VCdWZmZXIodCwgMCwgcy5maWxlU3RhcnQgLSB0LmZpbGVTdGFydCkpLCByLmRlYnVnKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJBcHBlbmRpbmcgbmV3IGJ1ZmZlciAoZmlsZVN0YXJ0OiBcIiArIHQuZmlsZVN0YXJ0ICsgXCIgLSBMZW5ndGg6IFwiICsgdC5ieXRlTGVuZ3RoICsgXCIpXCIpLCB0aGlzLmJ1ZmZlcnMuc3BsaWNlKGksIDAsIHQpLCBpID09PSAwICYmICh0aGlzLmJ1ZmZlciA9IHQpO1xuICAgICAgICBlID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh0LmZpbGVTdGFydCA8IHMuZmlsZVN0YXJ0ICsgcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBvID0gcy5maWxlU3RhcnQgKyBzLmJ5dGVMZW5ndGggLSB0LmZpbGVTdGFydCwgYyA9IHQuYnl0ZUxlbmd0aCAtIG87XG4gICAgICAgIGlmIChjID4gMClcbiAgICAgICAgICB0ID0gdGhpcy5yZWR1Y2VCdWZmZXIodCwgbywgYyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGUgPSAhMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlICYmIChyLmRlYnVnKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJBcHBlbmRpbmcgbmV3IGJ1ZmZlciAoZmlsZVN0YXJ0OiBcIiArIHQuZmlsZVN0YXJ0ICsgXCIgLSBMZW5ndGg6IFwiICsgdC5ieXRlTGVuZ3RoICsgXCIpXCIpLCB0aGlzLmJ1ZmZlcnMucHVzaCh0KSwgaSA9PT0gMCAmJiAodGhpcy5idWZmZXIgPSB0KSk7XG4gIH0sIGQucHJvdG90eXBlLmxvZ0J1ZmZlckxldmVsID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpLCBzLCBvLCBjID0gW10sIHUsIF8gPSBcIlwiO1xuICAgIGZvciAocyA9IDAsIG8gPSAwLCBlID0gMDsgZSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGUrKylcbiAgICAgIGkgPSB0aGlzLmJ1ZmZlcnNbZV0sIGUgPT09IDAgPyAodSA9IHt9LCBjLnB1c2godSksIHUuc3RhcnQgPSBpLmZpbGVTdGFydCwgdS5lbmQgPSBpLmZpbGVTdGFydCArIGkuYnl0ZUxlbmd0aCwgXyArPSBcIltcIiArIHUuc3RhcnQgKyBcIi1cIikgOiB1LmVuZCA9PT0gaS5maWxlU3RhcnQgPyB1LmVuZCA9IGkuZmlsZVN0YXJ0ICsgaS5ieXRlTGVuZ3RoIDogKHUgPSB7fSwgdS5zdGFydCA9IGkuZmlsZVN0YXJ0LCBfICs9IGNbYy5sZW5ndGggLSAxXS5lbmQgLSAxICsgXCJdLCBbXCIgKyB1LnN0YXJ0ICsgXCItXCIsIHUuZW5kID0gaS5maWxlU3RhcnQgKyBpLmJ5dGVMZW5ndGgsIGMucHVzaCh1KSksIHMgKz0gaS51c2VkQnl0ZXMsIG8gKz0gaS5ieXRlTGVuZ3RoO1xuICAgIGMubGVuZ3RoID4gMCAmJiAoXyArPSB1LmVuZCAtIDEgKyBcIl1cIik7XG4gICAgdmFyIGcgPSB0ID8gci5pbmZvIDogci5kZWJ1ZztcbiAgICB0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSAwID8gZyhcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiTm8gbW9yZSBidWZmZXIgaW4gbWVtb3J5XCIpIDogZyhcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiXCIgKyB0aGlzLmJ1ZmZlcnMubGVuZ3RoICsgXCIgc3RvcmVkIGJ1ZmZlcihzKSAoXCIgKyBzICsgXCIvXCIgKyBvICsgXCIgYnl0ZXMpLCBjb250aW51b3VzIHJhbmdlczogXCIgKyBfKTtcbiAgfSwgZC5wcm90b3R5cGUuY2xlYW5CdWZmZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQsIGU7XG4gICAgZm9yICh0ID0gMDsgdCA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IHQrKylcbiAgICAgIGUgPSB0aGlzLmJ1ZmZlcnNbdF0sIGUudXNlZEJ5dGVzID09PSBlLmJ5dGVMZW5ndGggJiYgKHIuZGVidWcoXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIlJlbW92aW5nIGJ1ZmZlciAjXCIgKyB0KSwgdGhpcy5idWZmZXJzLnNwbGljZSh0LCAxKSwgdC0tKTtcbiAgfSwgZC5wcm90b3R5cGUubWVyZ2VOZXh0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQ7XG4gICAgaWYgKHRoaXMuYnVmZmVySW5kZXggKyAxIDwgdGhpcy5idWZmZXJzLmxlbmd0aClcbiAgICAgIGlmICh0ID0gdGhpcy5idWZmZXJzW3RoaXMuYnVmZmVySW5kZXggKyAxXSwgdC5maWxlU3RhcnQgPT09IHRoaXMuYnVmZmVyLmZpbGVTdGFydCArIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoLCBpID0gdGhpcy5idWZmZXIudXNlZEJ5dGVzLCBzID0gdGhpcy5idWZmZXIuZmlsZVN0YXJ0O1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzW3RoaXMuYnVmZmVySW5kZXhdID0gQXJyYXlCdWZmZXIuY29uY2F0KHRoaXMuYnVmZmVyLCB0KSwgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlcnNbdGhpcy5idWZmZXJJbmRleF0sIHRoaXMuYnVmZmVycy5zcGxpY2UodGhpcy5idWZmZXJJbmRleCArIDEsIDEpLCB0aGlzLmJ1ZmZlci51c2VkQnl0ZXMgPSBpLCB0aGlzLmJ1ZmZlci5maWxlU3RhcnQgPSBzLCByLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkNvbmNhdGVuYXRpbmcgYnVmZmVyIGZvciBib3ggcGFyc2luZyAobGVuZ3RoOiBcIiArIGUgKyBcIi0+XCIgKyB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoICsgXCIpXCIpLCAhMDtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gITE7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuICExO1xuICB9LCBkLnByb3RvdHlwZS5maW5kUG9zaXRpb24gPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgdmFyIHMsIG8gPSBudWxsLCBjID0gLTE7XG4gICAgZm9yICh0ID09PSAhMCA/IHMgPSAwIDogcyA9IHRoaXMuYnVmZmVySW5kZXg7IHMgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoICYmIChvID0gdGhpcy5idWZmZXJzW3NdLCBvLmZpbGVTdGFydCA8PSBlKTsgKSB7XG4gICAgICBjID0gcywgaSAmJiAoby5maWxlU3RhcnQgKyBvLmJ5dGVMZW5ndGggPD0gZSA/IG8udXNlZEJ5dGVzID0gby5ieXRlTGVuZ3RoIDogby51c2VkQnl0ZXMgPSBlIC0gby5maWxlU3RhcnQsIHRoaXMubG9nQnVmZmVyTGV2ZWwoKSk7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHJldHVybiBjICE9PSAtMSA/IChvID0gdGhpcy5idWZmZXJzW2NdLCBvLmZpbGVTdGFydCArIG8uYnl0ZUxlbmd0aCA+PSBlID8gKHIuZGVidWcoXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIkZvdW5kIHBvc2l0aW9uIGluIGV4aXN0aW5nIGJ1ZmZlciAjXCIgKyBjKSwgYykgOiAtMSkgOiAtMTtcbiAgfSwgZC5wcm90b3R5cGUuZmluZEVuZENvbnRpZ3VvdXNCdWYgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGksIHMsIG8gPSB0ICE9PSB2b2lkIDAgPyB0IDogdGhpcy5idWZmZXJJbmRleDtcbiAgICBpZiAoaSA9IHRoaXMuYnVmZmVyc1tvXSwgdGhpcy5idWZmZXJzLmxlbmd0aCA+IG8gKyAxKVxuICAgICAgZm9yIChlID0gbyArIDE7IGUgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoICYmIChzID0gdGhpcy5idWZmZXJzW2VdLCBzLmZpbGVTdGFydCA9PT0gaS5maWxlU3RhcnQgKyBpLmJ5dGVMZW5ndGgpOyBlKyspXG4gICAgICAgIGkgPSBzO1xuICAgIHJldHVybiBpLmZpbGVTdGFydCArIGkuYnl0ZUxlbmd0aDtcbiAgfSwgZC5wcm90b3R5cGUuZ2V0RW5kRmlsZVBvc2l0aW9uQWZ0ZXIgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0aGlzLmZpbmRQb3NpdGlvbighMCwgdCwgITEpO1xuICAgIHJldHVybiBlICE9PSAtMSA/IHRoaXMuZmluZEVuZENvbnRpZ3VvdXNCdWYoZSkgOiB0O1xuICB9LCBkLnByb3RvdHlwZS5hZGRVc2VkQnl0ZXMgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5idWZmZXIudXNlZEJ5dGVzICs9IHQsIHRoaXMubG9nQnVmZmVyTGV2ZWwoKTtcbiAgfSwgZC5wcm90b3R5cGUuc2V0QWxsVXNlZEJ5dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5idWZmZXIudXNlZEJ5dGVzID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCwgdGhpcy5sb2dCdWZmZXJMZXZlbCgpO1xuICB9LCBkLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICAgIHZhciBzO1xuICAgIHJldHVybiBzID0gdGhpcy5maW5kUG9zaXRpb24oZSwgdCwgaSksIHMgIT09IC0xID8gKHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXJzW3NdLCB0aGlzLmJ1ZmZlckluZGV4ID0gcywgdGhpcy5wb3NpdGlvbiA9IHQgLSB0aGlzLmJ1ZmZlci5maWxlU3RhcnQsIHIuZGVidWcoXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIlJlcG9zaXRpb25pbmcgcGFyc2VyIGF0IGJ1ZmZlciBwb3NpdGlvbjogXCIgKyB0aGlzLnBvc2l0aW9uKSwgITApIDogKHIuZGVidWcoXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIlBvc2l0aW9uIFwiICsgdCArIFwiIG5vdCBmb3VuZCBpbiBidWZmZXJlZCBkYXRhXCIpLCAhMSk7XG4gIH0sIGQucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVySW5kZXggPT09IC0xIHx8IHRoaXMuYnVmZmVyc1t0aGlzLmJ1ZmZlckluZGV4XSA9PT0gbnVsbClcbiAgICAgIHRocm93IFwiRXJyb3IgYWNjZXNzaW5nIHBvc2l0aW9uIGluIHRoZSBNdWx0aUJ1ZmZlclN0cmVhbVwiO1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbdGhpcy5idWZmZXJJbmRleF0uZmlsZVN0YXJ0ICsgdGhpcy5wb3NpdGlvbjtcbiAgfSwgZC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZUxlbmd0aDtcbiAgfSwgZC5wcm90b3R5cGUuZ2V0RW5kUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5idWZmZXJJbmRleCA9PT0gLTEgfHwgdGhpcy5idWZmZXJzW3RoaXMuYnVmZmVySW5kZXhdID09PSBudWxsKVxuICAgICAgdGhyb3cgXCJFcnJvciBhY2Nlc3NpbmcgcG9zaXRpb24gaW4gdGhlIE11bHRpQnVmZmVyU3RyZWFtXCI7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyc1t0aGlzLmJ1ZmZlckluZGV4XS5maWxlU3RhcnQgKyB0aGlzLmJ5dGVMZW5ndGg7XG4gIH0sIGwuTXVsdGlCdWZmZXJTdHJlYW0gPSBkO1xuICB2YXIgcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gMywgZSA9IDQsIGkgPSA1LCBzID0gNiwgbyA9IFtdO1xuICAgIG9bdF0gPSBcIkVTX0Rlc2NyaXB0b3JcIiwgb1tlXSA9IFwiRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3JcIiwgb1tpXSA9IFwiRGVjb2RlclNwZWNpZmljSW5mb1wiLCBvW3NdID0gXCJTTENvbmZpZ0Rlc2NyaXB0b3JcIiwgdGhpcy5nZXREZXNjcmlwdG9yTmFtZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBvW19dO1xuICAgIH07XG4gICAgdmFyIGMgPSB0aGlzLCB1ID0ge307XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPbmVEZXNjcmlwdG9yID0gZnVuY3Rpb24oXykge1xuICAgICAgdmFyIGcgPSAwLCB3LCBTLCBVO1xuICAgICAgZm9yICh3ID0gXy5yZWFkVWludDgoKSwgVSA9IF8ucmVhZFVpbnQ4KCk7IFUgJiAxMjg7IClcbiAgICAgICAgZyA9IChVICYgMTI3KSA8PCA3LCBVID0gXy5yZWFkVWludDgoKTtcbiAgICAgIHJldHVybiBnICs9IFUgJiAxMjcsIHIuZGVidWcoXCJNUEVHNERlc2NyaXB0b3JQYXJzZXJcIiwgXCJGb3VuZCBcIiArIChvW3ddIHx8IFwiRGVzY3JpcHRvciBcIiArIHcpICsgXCIsIHNpemUgXCIgKyBnICsgXCIgYXQgcG9zaXRpb24gXCIgKyBfLmdldFBvc2l0aW9uKCkpLCBvW3ddID8gUyA9IG5ldyB1W29bd11dKGcpIDogUyA9IG5ldyB1LkRlc2NyaXB0b3IoZyksIFMucGFyc2UoXyksIFM7XG4gICAgfSwgdS5EZXNjcmlwdG9yID0gZnVuY3Rpb24oXywgZykge1xuICAgICAgdGhpcy50YWcgPSBfLCB0aGlzLnNpemUgPSBnLCB0aGlzLmRlc2NzID0gW107XG4gICAgfSwgdS5EZXNjcmlwdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHRoaXMuZGF0YSA9IF8ucmVhZFVpbnQ4QXJyYXkodGhpcy5zaXplKTtcbiAgICB9LCB1LkRlc2NyaXB0b3IucHJvdG90eXBlLmZpbmREZXNjcmlwdG9yID0gZnVuY3Rpb24oXykge1xuICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCB0aGlzLmRlc2NzLmxlbmd0aDsgZysrKVxuICAgICAgICBpZiAodGhpcy5kZXNjc1tnXS50YWcgPT0gXylcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZXNjc1tnXTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIHUuRGVzY3JpcHRvci5wcm90b3R5cGUucGFyc2VSZW1haW5pbmdEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGZvciAodmFyIGcgPSBfLnBvc2l0aW9uOyBfLnBvc2l0aW9uIDwgZyArIHRoaXMuc2l6ZTsgKSB7XG4gICAgICAgIHZhciB3ID0gYy5wYXJzZU9uZURlc2NyaXB0b3IoXyk7XG4gICAgICAgIHRoaXMuZGVzY3MucHVzaCh3KTtcbiAgICAgIH1cbiAgICB9LCB1LkVTX0Rlc2NyaXB0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgICB1LkRlc2NyaXB0b3IuY2FsbCh0aGlzLCB0LCBfKTtcbiAgICB9LCB1LkVTX0Rlc2NyaXB0b3IucHJvdG90eXBlID0gbmV3IHUuRGVzY3JpcHRvcigpLCB1LkVTX0Rlc2NyaXB0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKHRoaXMuRVNfSUQgPSBfLnJlYWRVaW50MTYoKSwgdGhpcy5mbGFncyA9IF8ucmVhZFVpbnQ4KCksIHRoaXMuc2l6ZSAtPSAzLCB0aGlzLmZsYWdzICYgMTI4ID8gKHRoaXMuZGVwZW5kc09uX0VTX0lEID0gXy5yZWFkVWludDE2KCksIHRoaXMuc2l6ZSAtPSAyKSA6IHRoaXMuZGVwZW5kc09uX0VTX0lEID0gMCwgdGhpcy5mbGFncyAmIDY0KSB7XG4gICAgICAgIHZhciBnID0gXy5yZWFkVWludDgoKTtcbiAgICAgICAgdGhpcy5VUkwgPSBfLnJlYWRTdHJpbmcoZyksIHRoaXMuc2l6ZSAtPSBnICsgMTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLlVSTCA9IFwiXCI7XG4gICAgICB0aGlzLmZsYWdzICYgMzIgPyAodGhpcy5PQ1JfRVNfSUQgPSBfLnJlYWRVaW50MTYoKSwgdGhpcy5zaXplIC09IDIpIDogdGhpcy5PQ1JfRVNfSUQgPSAwLCB0aGlzLnBhcnNlUmVtYWluaW5nRGVzY3JpcHRvcnMoXyk7XG4gICAgfSwgdS5FU19EZXNjcmlwdG9yLnByb3RvdHlwZS5nZXRPVEkgPSBmdW5jdGlvbihfKSB7XG4gICAgICB2YXIgZyA9IHRoaXMuZmluZERlc2NyaXB0b3IoZSk7XG4gICAgICByZXR1cm4gZyA/IGcub3RpIDogMDtcbiAgICB9LCB1LkVTX0Rlc2NyaXB0b3IucHJvdG90eXBlLmdldEF1ZGlvQ29uZmlnID0gZnVuY3Rpb24oXykge1xuICAgICAgdmFyIGcgPSB0aGlzLmZpbmREZXNjcmlwdG9yKGUpO1xuICAgICAgaWYgKCFnKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB3ID0gZy5maW5kRGVzY3JpcHRvcihpKTtcbiAgICAgIGlmICh3ICYmIHcuZGF0YSkge1xuICAgICAgICB2YXIgUyA9ICh3LmRhdGFbMF0gJiAyNDgpID4+IDM7XG4gICAgICAgIHJldHVybiBTID09PSAzMSAmJiB3LmRhdGEubGVuZ3RoID49IDIgJiYgKFMgPSAzMiArICgody5kYXRhWzBdICYgNykgPDwgMykgKyAoKHcuZGF0YVsxXSAmIDIyNCkgPj4gNSkpLCBTO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIHUuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgICB1LkRlc2NyaXB0b3IuY2FsbCh0aGlzLCBlLCBfKTtcbiAgICB9LCB1LkRlY29kZXJDb25maWdEZXNjcmlwdG9yLnByb3RvdHlwZSA9IG5ldyB1LkRlc2NyaXB0b3IoKSwgdS5EZWNvZGVyQ29uZmlnRGVzY3JpcHRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICB0aGlzLm90aSA9IF8ucmVhZFVpbnQ4KCksIHRoaXMuc3RyZWFtVHlwZSA9IF8ucmVhZFVpbnQ4KCksIHRoaXMuYnVmZmVyU2l6ZSA9IF8ucmVhZFVpbnQyNCgpLCB0aGlzLm1heEJpdHJhdGUgPSBfLnJlYWRVaW50MzIoKSwgdGhpcy5hdmdCaXRyYXRlID0gXy5yZWFkVWludDMyKCksIHRoaXMuc2l6ZSAtPSAxMywgdGhpcy5wYXJzZVJlbWFpbmluZ0Rlc2NyaXB0b3JzKF8pO1xuICAgIH0sIHUuRGVjb2RlclNwZWNpZmljSW5mbyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHUuRGVzY3JpcHRvci5jYWxsKHRoaXMsIGksIF8pO1xuICAgIH0sIHUuRGVjb2RlclNwZWNpZmljSW5mby5wcm90b3R5cGUgPSBuZXcgdS5EZXNjcmlwdG9yKCksIHUuU0xDb25maWdEZXNjcmlwdG9yID0gZnVuY3Rpb24oXykge1xuICAgICAgdS5EZXNjcmlwdG9yLmNhbGwodGhpcywgcywgXyk7XG4gICAgfSwgdS5TTENvbmZpZ0Rlc2NyaXB0b3IucHJvdG90eXBlID0gbmV3IHUuRGVzY3JpcHRvcigpLCB0aGlzO1xuICB9O1xuICBsLk1QRUc0RGVzY3JpcHRvclBhcnNlciA9IHA7XG4gIHZhciBuID0ge1xuICAgIEVSUl9JTlZBTElEX0RBVEE6IC0xLFxuICAgIEVSUl9OT1RfRU5PVUdIX0RBVEE6IDAsXG4gICAgT0s6IDEsXG4gICAgLy8gQm94ZXMgdG8gYmUgY3JlYXRlZCB3aXRoIGRlZmF1bHQgcGFyc2luZ1xuICAgIEJBU0lDX0JPWEVTOiBbXCJtZGF0XCIsIFwiaWRhdFwiLCBcImZyZWVcIiwgXCJza2lwXCIsIFwibWVjb1wiLCBcInN0cmtcIl0sXG4gICAgRlVMTF9CT1hFUzogW1wiaG1oZFwiLCBcIm5taGRcIiwgXCJpb2RzXCIsIFwieG1sIFwiLCBcImJ4bWxcIiwgXCJpcHJvXCIsIFwibWVyZVwiXSxcbiAgICBDT05UQUlORVJfQk9YRVM6IFtcbiAgICAgIFtcIm1vb3ZcIiwgW1widHJha1wiLCBcInBzc2hcIl1dLFxuICAgICAgW1widHJha1wiXSxcbiAgICAgIFtcImVkdHNcIl0sXG4gICAgICBbXCJtZGlhXCJdLFxuICAgICAgW1wibWluZlwiXSxcbiAgICAgIFtcImRpbmZcIl0sXG4gICAgICBbXCJzdGJsXCIsIFtcInNncGRcIiwgXCJzYmdwXCJdXSxcbiAgICAgIFtcIm12ZXhcIiwgW1widHJleFwiXV0sXG4gICAgICBbXCJtb29mXCIsIFtcInRyYWZcIl1dLFxuICAgICAgW1widHJhZlwiLCBbXCJ0cnVuXCIsIFwic2dwZFwiLCBcInNiZ3BcIl1dLFxuICAgICAgW1widnR0Y1wiXSxcbiAgICAgIFtcInRyZWZcIl0sXG4gICAgICBbXCJpcmVmXCJdLFxuICAgICAgW1wibWZyYVwiLCBbXCJ0ZnJhXCJdXSxcbiAgICAgIFtcIm1lY29cIl0sXG4gICAgICBbXCJobnRpXCJdLFxuICAgICAgW1wiaGluZlwiXSxcbiAgICAgIFtcInN0cmtcIl0sXG4gICAgICBbXCJzdHJkXCJdLFxuICAgICAgW1wic2luZlwiXSxcbiAgICAgIFtcInJpbmZcIl0sXG4gICAgICBbXCJzY2hpXCJdLFxuICAgICAgW1widHJnclwiXSxcbiAgICAgIFtcInVkdGFcIiwgW1wia2luZFwiXV0sXG4gICAgICBbXCJpcHJwXCIsIFtcImlwbWFcIl1dLFxuICAgICAgW1wiaXBjb1wiXVxuICAgIF0sXG4gICAgLy8gQm94ZXMgZWZmZWN0aXZlbHkgY3JlYXRlZFxuICAgIGJveENvZGVzOiBbXSxcbiAgICBmdWxsQm94Q29kZXM6IFtdLFxuICAgIGNvbnRhaW5lckJveENvZGVzOiBbXSxcbiAgICBzYW1wbGVFbnRyeUNvZGVzOiB7fSxcbiAgICBzYW1wbGVHcm91cEVudHJ5Q29kZXM6IFtdLFxuICAgIHRyYWNrR3JvdXBUeXBlczogW10sXG4gICAgVVVJREJveGVzOiB7fSxcbiAgICBVVUlEczogW10sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICBuLkZ1bGxCb3gucHJvdG90eXBlID0gbmV3IG4uQm94KCksIG4uQ29udGFpbmVyQm94LnByb3RvdHlwZSA9IG5ldyBuLkJveCgpLCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZSA9IG5ldyBuLkJveCgpLCBuLlRyYWNrR3JvdXBUeXBlQm94LnByb3RvdHlwZSA9IG5ldyBuLkZ1bGxCb3goKSwgbi5CQVNJQ19CT1hFUy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgbi5jcmVhdGVCb3hDdG9yKHQpO1xuICAgICAgfSksIG4uRlVMTF9CT1hFUy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgbi5jcmVhdGVGdWxsQm94Q3Rvcih0KTtcbiAgICAgIH0pLCBuLkNPTlRBSU5FUl9CT1hFUy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgbi5jcmVhdGVDb250YWluZXJCb3hDdG9yKHRbMF0sIG51bGwsIHRbMV0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBCb3g6IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuc2l6ZSA9IGUsIHRoaXMudXVpZCA9IGk7XG4gICAgfSxcbiAgICBGdWxsQm94OiBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgICBuLkJveC5jYWxsKHRoaXMsIHQsIGUsIGkpLCB0aGlzLmZsYWdzID0gMCwgdGhpcy52ZXJzaW9uID0gMDtcbiAgICB9LFxuICAgIENvbnRhaW5lckJveDogZnVuY3Rpb24odCwgZSwgaSkge1xuICAgICAgbi5Cb3guY2FsbCh0aGlzLCB0LCBlLCBpKSwgdGhpcy5ib3hlcyA9IFtdO1xuICAgIH0sXG4gICAgU2FtcGxlRW50cnk6IGZ1bmN0aW9uKHQsIGUsIGksIHMpIHtcbiAgICAgIG4uQ29udGFpbmVyQm94LmNhbGwodGhpcywgdCwgZSksIHRoaXMuaGRyX3NpemUgPSBpLCB0aGlzLnN0YXJ0ID0gcztcbiAgICB9LFxuICAgIFNhbXBsZUdyb3VwRW50cnk6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHRoaXMuZ3JvdXBpbmdfdHlwZSA9IHQ7XG4gICAgfSxcbiAgICBUcmFja0dyb3VwVHlwZUJveDogZnVuY3Rpb24odCwgZSkge1xuICAgICAgbi5GdWxsQm94LmNhbGwodGhpcywgdCwgZSk7XG4gICAgfSxcbiAgICBjcmVhdGVCb3hDdG9yOiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICBuLmJveENvZGVzLnB1c2godCksIG5bdCArIFwiQm94XCJdID0gZnVuY3Rpb24oaSkge1xuICAgICAgICBuLkJveC5jYWxsKHRoaXMsIHQsIGkpO1xuICAgICAgfSwgblt0ICsgXCJCb3hcIl0ucHJvdG90eXBlID0gbmV3IG4uQm94KCksIGUgJiYgKG5bdCArIFwiQm94XCJdLnByb3RvdHlwZS5wYXJzZSA9IGUpO1xuICAgIH0sXG4gICAgY3JlYXRlRnVsbEJveEN0b3I6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgIG5bdCArIFwiQm94XCJdID0gZnVuY3Rpb24oaSkge1xuICAgICAgICBuLkZ1bGxCb3guY2FsbCh0aGlzLCB0LCBpKTtcbiAgICAgIH0sIG5bdCArIFwiQm94XCJdLnByb3RvdHlwZSA9IG5ldyBuLkZ1bGxCb3goKSwgblt0ICsgXCJCb3hcIl0ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB0aGlzLnBhcnNlRnVsbEhlYWRlcihpKSwgZSAmJiBlLmNhbGwodGhpcywgaSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgYWRkU3ViQm94QXJyYXlzOiBmdW5jdGlvbih0KSB7XG4gICAgICBpZiAodCkge1xuICAgICAgICB0aGlzLnN1YkJveE5hbWVzID0gdDtcbiAgICAgICAgZm9yICh2YXIgZSA9IHQubGVuZ3RoLCBpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgICAgICB0aGlzW3RbaV0gKyBcInNcIl0gPSBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZUNvbnRhaW5lckJveEN0b3I6IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICAgIG5bdCArIFwiQm94XCJdID0gZnVuY3Rpb24ocykge1xuICAgICAgICBuLkNvbnRhaW5lckJveC5jYWxsKHRoaXMsIHQsIHMpLCBuLmFkZFN1YkJveEFycmF5cy5jYWxsKHRoaXMsIGkpO1xuICAgICAgfSwgblt0ICsgXCJCb3hcIl0ucHJvdG90eXBlID0gbmV3IG4uQ29udGFpbmVyQm94KCksIGUgJiYgKG5bdCArIFwiQm94XCJdLnByb3RvdHlwZS5wYXJzZSA9IGUpO1xuICAgIH0sXG4gICAgY3JlYXRlTWVkaWFTYW1wbGVFbnRyeUN0b3I6IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICAgIG4uc2FtcGxlRW50cnlDb2Rlc1t0XSA9IFtdLCBuW3QgKyBcIlNhbXBsZUVudHJ5XCJdID0gZnVuY3Rpb24ocywgbykge1xuICAgICAgICBuLlNhbXBsZUVudHJ5LmNhbGwodGhpcywgcywgbyksIG4uYWRkU3ViQm94QXJyYXlzLmNhbGwodGhpcywgaSk7XG4gICAgICB9LCBuW3QgKyBcIlNhbXBsZUVudHJ5XCJdLnByb3RvdHlwZSA9IG5ldyBuLlNhbXBsZUVudHJ5KCksIGUgJiYgKG5bdCArIFwiU2FtcGxlRW50cnlcIl0ucHJvdG90eXBlLnBhcnNlID0gZSk7XG4gICAgfSxcbiAgICBjcmVhdGVTYW1wbGVFbnRyeUN0b3I6IGZ1bmN0aW9uKHQsIGUsIGksIHMpIHtcbiAgICAgIG4uc2FtcGxlRW50cnlDb2Rlc1t0XS5wdXNoKGUpLCBuW2UgKyBcIlNhbXBsZUVudHJ5XCJdID0gZnVuY3Rpb24obykge1xuICAgICAgICBuW3QgKyBcIlNhbXBsZUVudHJ5XCJdLmNhbGwodGhpcywgZSwgbyksIG4uYWRkU3ViQm94QXJyYXlzLmNhbGwodGhpcywgcyk7XG4gICAgICB9LCBuW2UgKyBcIlNhbXBsZUVudHJ5XCJdLnByb3RvdHlwZSA9IG5ldyBuW3QgKyBcIlNhbXBsZUVudHJ5XCJdKCksIGkgJiYgKG5bZSArIFwiU2FtcGxlRW50cnlcIl0ucHJvdG90eXBlLnBhcnNlID0gaSk7XG4gICAgfSxcbiAgICBjcmVhdGVFbmNyeXB0ZWRTYW1wbGVFbnRyeUN0b3I6IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICAgIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yLmNhbGwodGhpcywgdCwgZSwgaSwgW1wic2luZlwiXSk7XG4gICAgfSxcbiAgICBjcmVhdGVTYW1wbGVHcm91cEN0b3I6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgIG5bdCArIFwiU2FtcGxlR3JvdXBFbnRyeVwiXSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgbi5TYW1wbGVHcm91cEVudHJ5LmNhbGwodGhpcywgdCwgaSk7XG4gICAgICB9LCBuW3QgKyBcIlNhbXBsZUdyb3VwRW50cnlcIl0ucHJvdG90eXBlID0gbmV3IG4uU2FtcGxlR3JvdXBFbnRyeSgpLCBlICYmIChuW3QgKyBcIlNhbXBsZUdyb3VwRW50cnlcIl0ucHJvdG90eXBlLnBhcnNlID0gZSk7XG4gICAgfSxcbiAgICBjcmVhdGVUcmFja0dyb3VwQ3RvcjogZnVuY3Rpb24odCwgZSkge1xuICAgICAgblt0ICsgXCJUcmFja0dyb3VwVHlwZUJveFwiXSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgbi5UcmFja0dyb3VwVHlwZUJveC5jYWxsKHRoaXMsIHQsIGkpO1xuICAgICAgfSwgblt0ICsgXCJUcmFja0dyb3VwVHlwZUJveFwiXS5wcm90b3R5cGUgPSBuZXcgbi5UcmFja0dyb3VwVHlwZUJveCgpLCBlICYmIChuW3QgKyBcIlRyYWNrR3JvdXBUeXBlQm94XCJdLnByb3RvdHlwZS5wYXJzZSA9IGUpO1xuICAgIH0sXG4gICAgY3JlYXRlVVVJREJveDogZnVuY3Rpb24odCwgZSwgaSwgcykge1xuICAgICAgbi5VVUlEcy5wdXNoKHQpLCBuLlVVSURCb3hlc1t0XSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgZSA/IG4uRnVsbEJveC5jYWxsKHRoaXMsIFwidXVpZFwiLCBvLCB0KSA6IGkgPyBuLkNvbnRhaW5lckJveC5jYWxsKHRoaXMsIFwidXVpZFwiLCBvLCB0KSA6IG4uQm94LmNhbGwodGhpcywgXCJ1dWlkXCIsIG8sIHQpO1xuICAgICAgfSwgbi5VVUlEQm94ZXNbdF0ucHJvdG90eXBlID0gZSA/IG5ldyBuLkZ1bGxCb3goKSA6IGkgPyBuZXcgbi5Db250YWluZXJCb3goKSA6IG5ldyBuLkJveCgpLCBzICYmIChlID8gbi5VVUlEQm94ZXNbdF0ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24obykge1xuICAgICAgICB0aGlzLnBhcnNlRnVsbEhlYWRlcihvKSwgcyAmJiBzLmNhbGwodGhpcywgbyk7XG4gICAgICB9IDogbi5VVUlEQm94ZXNbdF0ucHJvdG90eXBlLnBhcnNlID0gcyk7XG4gICAgfVxuICB9O1xuICBuLmluaXRpYWxpemUoKSwgbi5US0hEX0ZMQUdfRU5BQkxFRCA9IDEsIG4uVEtIRF9GTEFHX0lOX01PVklFID0gMiwgbi5US0hEX0ZMQUdfSU5fUFJFVklFVyA9IDQsIG4uVEZIRF9GTEFHX0JBU0VfREFUQV9PRkZTRVQgPSAxLCBuLlRGSERfRkxBR19TQU1QTEVfREVTQyA9IDIsIG4uVEZIRF9GTEFHX1NBTVBMRV9EVVIgPSA4LCBuLlRGSERfRkxBR19TQU1QTEVfU0laRSA9IDE2LCBuLlRGSERfRkxBR19TQU1QTEVfRkxBR1MgPSAzMiwgbi5URkhEX0ZMQUdfRFVSX0VNUFRZID0gNjU1MzYsIG4uVEZIRF9GTEFHX0RFRkFVTFRfQkFTRV9JU19NT09GID0gMTMxMDcyLCBuLlRSVU5fRkxBR1NfREFUQV9PRkZTRVQgPSAxLCBuLlRSVU5fRkxBR1NfRklSU1RfRkxBRyA9IDQsIG4uVFJVTl9GTEFHU19EVVJBVElPTiA9IDI1Niwgbi5UUlVOX0ZMQUdTX1NJWkUgPSA1MTIsIG4uVFJVTl9GTEFHU19GTEFHUyA9IDEwMjQsIG4uVFJVTl9GTEFHU19DVFNfT0ZGU0VUID0gMjA0OCwgbi5Cb3gucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRCb3gobmV3IG5bdCArIFwiQm94XCJdKCkpO1xuICB9LCBuLkJveC5wcm90b3R5cGUuYWRkQm94ID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0aGlzLmJveGVzLnB1c2godCksIHRoaXNbdC50eXBlICsgXCJzXCJdID8gdGhpc1t0LnR5cGUgKyBcInNcIl0ucHVzaCh0KSA6IHRoaXNbdC50eXBlXSA9IHQsIHQ7XG4gIH0sIG4uQm94LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXNbdF0gPSBlLCB0aGlzO1xuICB9LCBuLkJveC5wcm90b3R5cGUuYWRkRW50cnkgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGkgPSBlIHx8IFwiZW50cmllc1wiO1xuICAgIHJldHVybiB0aGlzW2ldIHx8ICh0aGlzW2ldID0gW10pLCB0aGlzW2ldLnB1c2godCksIHRoaXM7XG4gIH0sIGwuQm94UGFyc2VyID0gbiwgbi5wYXJzZVVVSUQgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIG4ucGFyc2VIZXgxNih0KTtcbiAgfSwgbi5wYXJzZUhleDE2ID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgPSBcIlwiLCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHZhciBzID0gdC5yZWFkVWludDgoKS50b1N0cmluZygxNik7XG4gICAgICBlICs9IHMubGVuZ3RoID09PSAxID8gXCIwXCIgKyBzIDogcztcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIG4ucGFyc2VPbmVCb3ggPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgdmFyIHMsIG8gPSB0LmdldFBvc2l0aW9uKCksIGMgPSAwLCB1LCBfO1xuICAgIGlmICh0LmdldEVuZFBvc2l0aW9uKCkgLSBvIDwgOClcbiAgICAgIHJldHVybiByLmRlYnVnKFwiQm94UGFyc2VyXCIsIFwiTm90IGVub3VnaCBkYXRhIGluIHN0cmVhbSB0byBwYXJzZSB0aGUgdHlwZSBhbmQgc2l6ZSBvZiB0aGUgYm94XCIpLCB7IGNvZGU6IG4uRVJSX05PVF9FTk9VR0hfREFUQSB9O1xuICAgIGlmIChpICYmIGkgPCA4KVxuICAgICAgcmV0dXJuIHIuZGVidWcoXCJCb3hQYXJzZXJcIiwgXCJOb3QgZW5vdWdoIGJ5dGVzIGxlZnQgaW4gdGhlIHBhcmVudCBib3ggdG8gcGFyc2UgYSBuZXcgYm94XCIpLCB7IGNvZGU6IG4uRVJSX05PVF9FTk9VR0hfREFUQSB9O1xuICAgIHZhciBnID0gdC5yZWFkVWludDMyKCksIHcgPSB0LnJlYWRTdHJpbmcoNCksIFMgPSB3O1xuICAgIGlmIChyLmRlYnVnKFwiQm94UGFyc2VyXCIsIFwiRm91bmQgYm94IG9mIHR5cGUgJ1wiICsgdyArIFwiJyBhbmQgc2l6ZSBcIiArIGcgKyBcIiBhdCBwb3NpdGlvbiBcIiArIG8pLCBjID0gOCwgdyA9PSBcInV1aWRcIikge1xuICAgICAgaWYgKHQuZ2V0RW5kUG9zaXRpb24oKSAtIHQuZ2V0UG9zaXRpb24oKSA8IDE2IHx8IGkgLSBjIDwgMTYpXG4gICAgICAgIHJldHVybiB0LnNlZWsobyksIHIuZGVidWcoXCJCb3hQYXJzZXJcIiwgXCJOb3QgZW5vdWdoIGJ5dGVzIGxlZnQgaW4gdGhlIHBhcmVudCBib3ggdG8gcGFyc2UgYSBVVUlEIGJveFwiKSwgeyBjb2RlOiBuLkVSUl9OT1RfRU5PVUdIX0RBVEEgfTtcbiAgICAgIF8gPSBuLnBhcnNlVVVJRCh0KSwgYyArPSAxNiwgUyA9IF87XG4gICAgfVxuICAgIGlmIChnID09IDEpIHtcbiAgICAgIGlmICh0LmdldEVuZFBvc2l0aW9uKCkgLSB0LmdldFBvc2l0aW9uKCkgPCA4IHx8IGkgJiYgaSAtIGMgPCA4KVxuICAgICAgICByZXR1cm4gdC5zZWVrKG8pLCByLndhcm4oXCJCb3hQYXJzZXJcIiwgJ05vdCBlbm91Z2ggZGF0YSBpbiBzdHJlYW0gdG8gcGFyc2UgdGhlIGV4dGVuZGVkIHNpemUgb2YgdGhlIFwiJyArIHcgKyAnXCIgYm94JyksIHsgY29kZTogbi5FUlJfTk9UX0VOT1VHSF9EQVRBIH07XG4gICAgICBnID0gdC5yZWFkVWludDY0KCksIGMgKz0gODtcbiAgICB9IGVsc2UgaWYgKGcgPT09IDApIHtcbiAgICAgIGlmIChpKVxuICAgICAgICBnID0gaTtcbiAgICAgIGVsc2UgaWYgKHcgIT09IFwibWRhdFwiKVxuICAgICAgICByZXR1cm4gci5lcnJvcihcIkJveFBhcnNlclwiLCBcIlVubGltaXRlZCBib3ggc2l6ZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlOiAnXCIgKyB3ICsgXCInXCIpLCBzID0gbmV3IG4uQm94KHcsIGcpLCB7IGNvZGU6IG4uT0ssIGJveDogcywgc2l6ZTogcy5zaXplIH07XG4gICAgfVxuICAgIHJldHVybiBnICE9PSAwICYmIGcgPCBjID8gKHIuZXJyb3IoXCJCb3hQYXJzZXJcIiwgXCJCb3ggb2YgdHlwZSBcIiArIHcgKyBcIiBoYXMgYW4gaW52YWxpZCBzaXplIFwiICsgZyArIFwiICh0b28gc21hbGwgdG8gYmUgYSBib3gpXCIpLCB7IGNvZGU6IG4uRVJSX05PVF9FTk9VR0hfREFUQSwgdHlwZTogdywgc2l6ZTogZywgaGRyX3NpemU6IGMsIHN0YXJ0OiBvIH0pIDogZyAhPT0gMCAmJiBpICYmIGcgPiBpID8gKHIuZXJyb3IoXCJCb3hQYXJzZXJcIiwgXCJCb3ggb2YgdHlwZSAnXCIgKyB3ICsgXCInIGhhcyBhIHNpemUgXCIgKyBnICsgXCIgZ3JlYXRlciB0aGFuIGl0cyBjb250YWluZXIgc2l6ZSBcIiArIGkpLCB7IGNvZGU6IG4uRVJSX05PVF9FTk9VR0hfREFUQSwgdHlwZTogdywgc2l6ZTogZywgaGRyX3NpemU6IGMsIHN0YXJ0OiBvIH0pIDogZyAhPT0gMCAmJiBvICsgZyA+IHQuZ2V0RW5kUG9zaXRpb24oKSA/ICh0LnNlZWsobyksIHIuaW5mbyhcIkJveFBhcnNlclwiLCBcIk5vdCBlbm91Z2ggZGF0YSBpbiBzdHJlYW0gdG8gcGFyc2UgdGhlIGVudGlyZSAnXCIgKyB3ICsgXCInIGJveFwiKSwgeyBjb2RlOiBuLkVSUl9OT1RfRU5PVUdIX0RBVEEsIHR5cGU6IHcsIHNpemU6IGcsIGhkcl9zaXplOiBjLCBzdGFydDogbyB9KSA6IGUgPyB7IGNvZGU6IG4uT0ssIHR5cGU6IHcsIHNpemU6IGcsIGhkcl9zaXplOiBjLCBzdGFydDogbyB9IDogKG5bdyArIFwiQm94XCJdID8gcyA9IG5ldyBuW3cgKyBcIkJveFwiXShnKSA6IHcgIT09IFwidXVpZFwiID8gKHIud2FybihcIkJveFBhcnNlclwiLCBcIlVua25vd24gYm94IHR5cGU6ICdcIiArIHcgKyBcIidcIiksIHMgPSBuZXcgbi5Cb3godywgZyksIHMuaGFzX3VucGFyc2VkX2RhdGEgPSAhMCkgOiBuLlVVSURCb3hlc1tfXSA/IHMgPSBuZXcgbi5VVUlEQm94ZXNbX10oZykgOiAoci53YXJuKFwiQm94UGFyc2VyXCIsIFwiVW5rbm93biB1dWlkIHR5cGU6ICdcIiArIF8gKyBcIidcIiksIHMgPSBuZXcgbi5Cb3godywgZyksIHMudXVpZCA9IF8sIHMuaGFzX3VucGFyc2VkX2RhdGEgPSAhMCksIHMuaGRyX3NpemUgPSBjLCBzLnN0YXJ0ID0gbywgcy53cml0ZSA9PT0gbi5Cb3gucHJvdG90eXBlLndyaXRlICYmIHMudHlwZSAhPT0gXCJtZGF0XCIgJiYgKHIuaW5mbyhcIkJveFBhcnNlclwiLCBcIidcIiArIFMgKyBcIicgYm94IHdyaXRpbmcgbm90IHlldCBpbXBsZW1lbnRlZCwga2VlcGluZyB1bnBhcnNlZCBkYXRhIGluIG1lbW9yeSBmb3IgbGF0ZXIgd3JpdGVcIiksIHMucGFyc2VEYXRhQW5kUmV3aW5kKHQpKSwgcy5wYXJzZSh0KSwgdSA9IHQuZ2V0UG9zaXRpb24oKSAtIChzLnN0YXJ0ICsgcy5zaXplKSwgdSA8IDAgPyAoci53YXJuKFwiQm94UGFyc2VyXCIsIFwiUGFyc2luZyBvZiBib3ggJ1wiICsgUyArIFwiJyBkaWQgbm90IHJlYWQgdGhlIGVudGlyZSBpbmRpY2F0ZWQgYm94IGRhdGEgc2l6ZSAobWlzc2luZyBcIiArIC11ICsgXCIgYnl0ZXMpLCBzZWVraW5nIGZvcndhcmRcIiksIHQuc2VlayhzLnN0YXJ0ICsgcy5zaXplKSkgOiB1ID4gMCAmJiAoci5lcnJvcihcIkJveFBhcnNlclwiLCBcIlBhcnNpbmcgb2YgYm94ICdcIiArIFMgKyBcIicgcmVhZCBcIiArIHUgKyBcIiBtb3JlIGJ5dGVzIHRoYW4gdGhlIGluZGljYXRlZCBib3ggZGF0YSBzaXplLCBzZWVraW5nIGJhY2t3YXJkc1wiKSwgcy5zaXplICE9PSAwICYmIHQuc2VlayhzLnN0YXJ0ICsgcy5zaXplKSksIHsgY29kZTogbi5PSywgYm94OiBzLCBzaXplOiBzLnNpemUgfSk7XG4gIH0sIG4uQm94LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnR5cGUgIT0gXCJtZGF0XCIgPyB0aGlzLmRhdGEgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpIDogdGhpcy5zaXplID09PSAwID8gdC5zZWVrKHQuZ2V0RW5kUG9zaXRpb24oKSkgOiB0LnNlZWsodGhpcy5zdGFydCArIHRoaXMuc2l6ZSk7XG4gIH0sIG4uQm94LnByb3RvdHlwZS5wYXJzZURhdGFBbmRSZXdpbmQgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5kYXRhID0gdC5yZWFkVWludDhBcnJheSh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKSwgdC5wb3NpdGlvbiAtPSB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplO1xuICB9LCBuLkZ1bGxCb3gucHJvdG90eXBlLnBhcnNlRGF0YUFuZFJld2luZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlRnVsbEhlYWRlcih0KSwgdGhpcy5kYXRhID0gdC5yZWFkVWludDhBcnJheSh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKSwgdGhpcy5oZHJfc2l6ZSAtPSA0LCB0LnBvc2l0aW9uIC09IHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemU7XG4gIH0sIG4uRnVsbEJveC5wcm90b3R5cGUucGFyc2VGdWxsSGVhZGVyID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IHQucmVhZFVpbnQ4KCksIHRoaXMuZmxhZ3MgPSB0LnJlYWRVaW50MjQoKSwgdGhpcy5oZHJfc2l6ZSArPSA0O1xuICB9LCBuLkZ1bGxCb3gucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VGdWxsSGVhZGVyKHQpLCB0aGlzLmRhdGEgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpO1xuICB9LCBuLkNvbnRhaW5lckJveC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSwgaTsgdC5nZXRQb3NpdGlvbigpIDwgdGhpcy5zdGFydCArIHRoaXMuc2l6ZTsgKVxuICAgICAgaWYgKGUgPSBuLnBhcnNlT25lQm94KHQsICExLCB0aGlzLnNpemUgLSAodC5nZXRQb3NpdGlvbigpIC0gdGhpcy5zdGFydCkpLCBlLmNvZGUgPT09IG4uT0spXG4gICAgICAgIGlmIChpID0gZS5ib3gsIHRoaXMuYm94ZXMucHVzaChpKSwgdGhpcy5zdWJCb3hOYW1lcyAmJiB0aGlzLnN1YkJveE5hbWVzLmluZGV4T2YoaS50eXBlKSAhPSAtMSlcbiAgICAgICAgICB0aGlzW3RoaXMuc3ViQm94TmFtZXNbdGhpcy5zdWJCb3hOYW1lcy5pbmRleE9mKGkudHlwZSldICsgXCJzXCJdLnB1c2goaSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBzID0gaS50eXBlICE9PSBcInV1aWRcIiA/IGkudHlwZSA6IGkudXVpZDtcbiAgICAgICAgICB0aGlzW3NdID8gci53YXJuKFwiQm94IG9mIHR5cGUgXCIgKyBzICsgXCIgYWxyZWFkeSBzdG9yZWQgaW4gZmllbGQgb2YgdGhpcyB0eXBlXCIpIDogdGhpc1tzXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuO1xuICB9LCBuLkJveC5wcm90b3R5cGUucGFyc2VMYW5ndWFnZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmxhbmd1YWdlID0gdC5yZWFkVWludDE2KCk7XG4gICAgdmFyIGUgPSBbXTtcbiAgICBlWzBdID0gdGhpcy5sYW5ndWFnZSA+PiAxMCAmIDMxLCBlWzFdID0gdGhpcy5sYW5ndWFnZSA+PiA1ICYgMzEsIGVbMl0gPSB0aGlzLmxhbmd1YWdlICYgMzEsIHRoaXMubGFuZ3VhZ2VTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVbMF0gKyA5NiwgZVsxXSArIDk2LCBlWzJdICsgOTYpO1xuICB9LCBuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCA9IFwiVmlzdWFsXCIsIG4uU0FNUExFX0VOVFJZX1RZUEVfQVVESU8gPSBcIkF1ZGlvXCIsIG4uU0FNUExFX0VOVFJZX1RZUEVfSElOVCA9IFwiSGludFwiLCBuLlNBTVBMRV9FTlRSWV9UWVBFX01FVEFEQVRBID0gXCJNZXRhZGF0YVwiLCBuLlNBTVBMRV9FTlRSWV9UWVBFX1NVQlRJVExFID0gXCJTdWJ0aXRsZVwiLCBuLlNBTVBMRV9FTlRSWV9UWVBFX1NZU1RFTSA9IFwiU3lzdGVtXCIsIG4uU0FNUExFX0VOVFJZX1RZUEVfVEVYVCA9IFwiVGV4dFwiLCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5wYXJzZUhlYWRlciA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0LnJlYWRVaW50OEFycmF5KDYpLCB0aGlzLmRhdGFfcmVmZXJlbmNlX2luZGV4ID0gdC5yZWFkVWludDE2KCksIHRoaXMuaGRyX3NpemUgKz0gODtcbiAgfSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wYXJzZUhlYWRlcih0KSwgdGhpcy5kYXRhID0gdC5yZWFkVWludDhBcnJheSh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKTtcbiAgfSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUucGFyc2VEYXRhQW5kUmV3aW5kID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIodCksIHRoaXMuZGF0YSA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSksIHRoaXMuaGRyX3NpemUgLT0gOCwgdC5wb3NpdGlvbiAtPSB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5wYXJzZUZvb3RlciA9IGZ1bmN0aW9uKHQpIHtcbiAgICBuLkNvbnRhaW5lckJveC5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCB0KTtcbiAgfSwgbi5jcmVhdGVNZWRpYVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX0hJTlQpLCBuLmNyZWF0ZU1lZGlhU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfTUVUQURBVEEpLCBuLmNyZWF0ZU1lZGlhU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfU1VCVElUTEUpLCBuLmNyZWF0ZU1lZGlhU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfU1lTVEVNKSwgbi5jcmVhdGVNZWRpYVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1RFWFQpLCBuLmNyZWF0ZU1lZGlhU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5wYXJzZUhlYWRlcih0KSwgdC5yZWFkVWludDE2KCksIHQucmVhZFVpbnQxNigpLCB0LnJlYWRVaW50MzJBcnJheSgzKSwgdGhpcy53aWR0aCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmhlaWdodCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmhvcml6cmVzb2x1dGlvbiA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnZlcnRyZXNvbHV0aW9uID0gdC5yZWFkVWludDMyKCksIHQucmVhZFVpbnQzMigpLCB0aGlzLmZyYW1lX2NvdW50ID0gdC5yZWFkVWludDE2KCksIGUgPSBNYXRoLm1pbigzMSwgdC5yZWFkVWludDgoKSksIHRoaXMuY29tcHJlc3Nvcm5hbWUgPSB0LnJlYWRTdHJpbmcoZSksIGUgPCAzMSAmJiB0LnJlYWRTdHJpbmcoMzEgLSBlKSwgdGhpcy5kZXB0aCA9IHQucmVhZFVpbnQxNigpLCB0LnJlYWRVaW50MTYoKSwgdGhpcy5wYXJzZUZvb3Rlcih0KTtcbiAgfSksIG4uY3JlYXRlTWVkaWFTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9BVURJTywgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIodCksIHQucmVhZFVpbnQzMkFycmF5KDIpLCB0aGlzLmNoYW5uZWxfY291bnQgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5zYW1wbGVzaXplID0gdC5yZWFkVWludDE2KCksIHQucmVhZFVpbnQxNigpLCB0LnJlYWRVaW50MTYoKSwgdGhpcy5zYW1wbGVyYXRlID0gdC5yZWFkVWludDMyKCkgLyA2NTUzNiwgdGhpcy5wYXJzZUZvb3Rlcih0KTtcbiAgfSksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImF2YzFcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImF2YzJcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImF2YzNcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImF2YzRcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImF2MDFcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImh2YzFcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImhldjFcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcInZ2YzFcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcInZ2aTFcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcInZ2czFcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcInZ2Y05cIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcInZwMDhcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcInZwMDlcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfQVVESU8sIFwibXA0YVwiKSwgbi5jcmVhdGVTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9BVURJTywgXCJhYy0zXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX0FVRElPLCBcImVjLTNcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfQVVESU8sIFwiT3B1c1wiKSwgbi5jcmVhdGVFbmNyeXB0ZWRTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9WSVNVQUwsIFwiZW5jdlwiKSwgbi5jcmVhdGVFbmNyeXB0ZWRTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9BVURJTywgXCJlbmNhXCIpLCBuLmNyZWF0ZUVuY3J5cHRlZFNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1NVQlRJVExFLCBcImVuY3VcIiksIG4uY3JlYXRlRW5jcnlwdGVkU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfU1lTVEVNLCBcImVuY3NcIiksIG4uY3JlYXRlRW5jcnlwdGVkU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVEVYVCwgXCJlbmN0XCIpLCBuLmNyZWF0ZUVuY3J5cHRlZFNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX01FVEFEQVRBLCBcImVuY21cIiksIG4uY3JlYXRlQm94Q3RvcihcImExbHhcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5yZWFkVWludDgoKSAmIDEsIGkgPSAoKGUgJiAxKSArIDEpICogMTY7XG4gICAgdGhpcy5sYXllcl9zaXplID0gW107XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCAzOyBzKyspXG4gICAgICBpID09IDE2ID8gdGhpcy5sYXllcl9zaXplW3NdID0gdC5yZWFkVWludDE2KCkgOiB0aGlzLmxheWVyX3NpemVbc10gPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImExb3BcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMub3BfaW5kZXggPSB0LnJlYWRVaW50OCgpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImF1eENcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuYXV4X3R5cGUgPSB0LnJlYWRDU3RyaW5nKCk7XG4gICAgdmFyIGUgPSB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gKHRoaXMuYXV4X3R5cGUubGVuZ3RoICsgMSk7XG4gICAgdGhpcy5hdXhfc3VidHlwZSA9IHQucmVhZFVpbnQ4QXJyYXkoZSk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJhdjFDXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgaWYgKGUgPj4gNyAmICExKSB7XG4gICAgICByLmVycm9yKFwiYXYxQyBtYXJrZXIgcHJvYmxlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9IGUgJiAxMjcsIHRoaXMudmVyc2lvbiAhPT0gMSkge1xuICAgICAgci5lcnJvcihcImF2MUMgdmVyc2lvbiBcIiArIHRoaXMudmVyc2lvbiArIFwiIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlID0gdC5yZWFkVWludDgoKSwgdGhpcy5zZXFfcHJvZmlsZSA9IGUgPj4gNSAmIDcsIHRoaXMuc2VxX2xldmVsX2lkeF8wID0gZSAmIDMxLCBlID0gdC5yZWFkVWludDgoKSwgdGhpcy5zZXFfdGllcl8wID0gZSA+PiA3ICYgMSwgdGhpcy5oaWdoX2JpdGRlcHRoID0gZSA+PiA2ICYgMSwgdGhpcy50d2VsdmVfYml0ID0gZSA+PiA1ICYgMSwgdGhpcy5tb25vY2hyb21lID0gZSA+PiA0ICYgMSwgdGhpcy5jaHJvbWFfc3Vic2FtcGxpbmdfeCA9IGUgPj4gMyAmIDEsIHRoaXMuY2hyb21hX3N1YnNhbXBsaW5nX3kgPSBlID4+IDIgJiAxLCB0aGlzLmNocm9tYV9zYW1wbGVfcG9zaXRpb24gPSBlICYgMywgZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMucmVzZXJ2ZWRfMSA9IGUgPj4gNSAmIDcsIHRoaXMucmVzZXJ2ZWRfMSAhPT0gMCkge1xuICAgICAgci5lcnJvcihcImF2MUMgcmVzZXJ2ZWRfMSBwYXJzaW5nIHByb2JsZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmluaXRpYWxfcHJlc2VudGF0aW9uX2RlbGF5X3ByZXNlbnQgPSBlID4+IDQgJiAxLCB0aGlzLmluaXRpYWxfcHJlc2VudGF0aW9uX2RlbGF5X3ByZXNlbnQgPT09IDEpXG4gICAgICB0aGlzLmluaXRpYWxfcHJlc2VudGF0aW9uX2RlbGF5X21pbnVzX29uZSA9IGUgJiAxNTtcbiAgICBlbHNlIGlmICh0aGlzLnJlc2VydmVkXzIgPSBlICYgMTUsIHRoaXMucmVzZXJ2ZWRfMiAhPT0gMCkge1xuICAgICAgci5lcnJvcihcImF2MUMgcmVzZXJ2ZWRfMiBwYXJzaW5nIHByb2JsZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSAtIDQ7XG4gICAgdGhpcy5jb25maWdPQlVzID0gdC5yZWFkVWludDhBcnJheShpKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImF2Y0NcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpO1xuICAgIGZvciAodGhpcy5jb25maWd1cmF0aW9uVmVyc2lvbiA9IHQucmVhZFVpbnQ4KCksIHRoaXMuQVZDUHJvZmlsZUluZGljYXRpb24gPSB0LnJlYWRVaW50OCgpLCB0aGlzLnByb2ZpbGVfY29tcGF0aWJpbGl0eSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuQVZDTGV2ZWxJbmRpY2F0aW9uID0gdC5yZWFkVWludDgoKSwgdGhpcy5sZW5ndGhTaXplTWludXNPbmUgPSB0LnJlYWRVaW50OCgpICYgMywgdGhpcy5uYl9TUFNfbmFsdXMgPSB0LnJlYWRVaW50OCgpICYgMzEsIGkgPSB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gNiwgdGhpcy5TUFMgPSBbXSwgZSA9IDA7IGUgPCB0aGlzLm5iX1NQU19uYWx1czsgZSsrKVxuICAgICAgdGhpcy5TUFNbZV0gPSB7fSwgdGhpcy5TUFNbZV0ubGVuZ3RoID0gdC5yZWFkVWludDE2KCksIHRoaXMuU1BTW2VdLm5hbHUgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuU1BTW2VdLmxlbmd0aCksIGkgLT0gMiArIHRoaXMuU1BTW2VdLmxlbmd0aDtcbiAgICBmb3IgKHRoaXMubmJfUFBTX25hbHVzID0gdC5yZWFkVWludDgoKSwgaS0tLCB0aGlzLlBQUyA9IFtdLCBlID0gMDsgZSA8IHRoaXMubmJfUFBTX25hbHVzOyBlKyspXG4gICAgICB0aGlzLlBQU1tlXSA9IHt9LCB0aGlzLlBQU1tlXS5sZW5ndGggPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5QUFNbZV0ubmFsdSA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5QUFNbZV0ubGVuZ3RoKSwgaSAtPSAyICsgdGhpcy5QUFNbZV0ubGVuZ3RoO1xuICAgIGkgPiAwICYmICh0aGlzLmV4dCA9IHQucmVhZFVpbnQ4QXJyYXkoaSkpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiYnRydFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5idWZmZXJTaXplREIgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5tYXhCaXRyYXRlID0gdC5yZWFkVWludDMyKCksIHRoaXMuYXZnQml0cmF0ZSA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiY2xhcFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5jbGVhbkFwZXJ0dXJlV2lkdGhOID0gdC5yZWFkVWludDMyKCksIHRoaXMuY2xlYW5BcGVydHVyZVdpZHRoRCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmNsZWFuQXBlcnR1cmVIZWlnaHROID0gdC5yZWFkVWludDMyKCksIHRoaXMuY2xlYW5BcGVydHVyZUhlaWdodEQgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5ob3Jpek9mZk4gPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5ob3Jpek9mZkQgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy52ZXJ0T2ZmTiA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnZlcnRPZmZEID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJjbGxpXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLm1heF9jb250ZW50X2xpZ2h0X2xldmVsID0gdC5yZWFkVWludDE2KCksIHRoaXMubWF4X3BpY19hdmVyYWdlX2xpZ2h0X2xldmVsID0gdC5yZWFkVWludDE2KCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiY282NFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGk7XG4gICAgaWYgKGUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5jaHVua19vZmZzZXRzID0gW10sIHRoaXMudmVyc2lvbiA9PT0gMClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICAgIHRoaXMuY2h1bmtfb2Zmc2V0cy5wdXNoKHQucmVhZFVpbnQ2NCgpKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJDb0xMXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLm1heENMTCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLm1heEZBTEwgPSB0LnJlYWRVaW50MTYoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImNvbHJcIiwgZnVuY3Rpb24odCkge1xuICAgIGlmICh0aGlzLmNvbG91cl90eXBlID0gdC5yZWFkU3RyaW5nKDQpLCB0aGlzLmNvbG91cl90eXBlID09PSBcIm5jbHhcIikge1xuICAgICAgdGhpcy5jb2xvdXJfcHJpbWFyaWVzID0gdC5yZWFkVWludDE2KCksIHRoaXMudHJhbnNmZXJfY2hhcmFjdGVyaXN0aWNzID0gdC5yZWFkVWludDE2KCksIHRoaXMubWF0cml4X2NvZWZmaWNpZW50cyA9IHQucmVhZFVpbnQxNigpO1xuICAgICAgdmFyIGUgPSB0LnJlYWRVaW50OCgpO1xuICAgICAgdGhpcy5mdWxsX3JhbmdlX2ZsYWcgPSBlID4+IDc7XG4gICAgfSBlbHNlIHRoaXMuY29sb3VyX3R5cGUgPT09IFwicklDQ1wiID8gdGhpcy5JQ0NfcHJvZmlsZSA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5zaXplIC0gNCkgOiB0aGlzLmNvbG91cl90eXBlID09PSBcInByb2ZcIiAmJiAodGhpcy5JQ0NfcHJvZmlsZSA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5zaXplIC0gNCkpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImNwcnRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VMYW5ndWFnZSh0KSwgdGhpcy5ub3RpY2UgPSB0LnJlYWRDU3RyaW5nKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiY3NsZ1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID09PSAwICYmICh0aGlzLmNvbXBvc2l0aW9uVG9EVFNTaGlmdCA9IHQucmVhZEludDMyKCksIHRoaXMubGVhc3REZWNvZGVUb0Rpc3BsYXlEZWx0YSA9IHQucmVhZEludDMyKCksIHRoaXMuZ3JlYXRlc3REZWNvZGVUb0Rpc3BsYXlEZWx0YSA9IHQucmVhZEludDMyKCksIHRoaXMuY29tcG9zaXRpb25TdGFydFRpbWUgPSB0LnJlYWRJbnQzMigpLCB0aGlzLmNvbXBvc2l0aW9uRW5kVGltZSA9IHQucmVhZEludDMyKCkpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImN0dHNcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpO1xuICAgIGlmIChlID0gdC5yZWFkVWludDMyKCksIHRoaXMuc2FtcGxlX2NvdW50cyA9IFtdLCB0aGlzLnNhbXBsZV9vZmZzZXRzID0gW10sIHRoaXMudmVyc2lvbiA9PT0gMClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlOyBpKyspIHtcbiAgICAgICAgdGhpcy5zYW1wbGVfY291bnRzLnB1c2godC5yZWFkVWludDMyKCkpO1xuICAgICAgICB2YXIgcyA9IHQucmVhZEludDMyKCk7XG4gICAgICAgIHMgPCAwICYmIHIud2FybihcIkJveFBhcnNlclwiLCBcImN0dHMgYm94IHVzZXMgbmVnYXRpdmUgdmFsdWVzIHdpdGhvdXQgdXNpbmcgdmVyc2lvbiAxXCIpLCB0aGlzLnNhbXBsZV9vZmZzZXRzLnB1c2gocyk7XG4gICAgICB9XG4gICAgZWxzZSBpZiAodGhpcy52ZXJzaW9uID09IDEpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgICAgICB0aGlzLnNhbXBsZV9jb3VudHMucHVzaCh0LnJlYWRVaW50MzIoKSksIHRoaXMuc2FtcGxlX29mZnNldHMucHVzaCh0LnJlYWRJbnQzMigpKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImRhYzNcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5yZWFkVWludDgoKSwgaSA9IHQucmVhZFVpbnQ4KCksIHMgPSB0LnJlYWRVaW50OCgpO1xuICAgIHRoaXMuZnNjb2QgPSBlID4+IDYsIHRoaXMuYnNpZCA9IGUgPj4gMSAmIDMxLCB0aGlzLmJzbW9kID0gKGUgJiAxKSA8PCAyIHwgaSA+PiA2ICYgMywgdGhpcy5hY21vZCA9IGkgPj4gMyAmIDcsIHRoaXMubGZlb24gPSBpID4+IDIgJiAxLCB0aGlzLmJpdF9yYXRlX2NvZGUgPSBpICYgMyB8IHMgPj4gNSAmIDc7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJkZWMzXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQxNigpO1xuICAgIHRoaXMuZGF0YV9yYXRlID0gZSA+PiAzLCB0aGlzLm51bV9pbmRfc3ViID0gZSAmIDcsIHRoaXMuaW5kX3N1YnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtX2luZF9zdWIgKyAxOyBpKyspIHtcbiAgICAgIHZhciBzID0ge307XG4gICAgICB0aGlzLmluZF9zdWJzLnB1c2gocyk7XG4gICAgICB2YXIgbyA9IHQucmVhZFVpbnQ4KCksIGMgPSB0LnJlYWRVaW50OCgpLCB1ID0gdC5yZWFkVWludDgoKTtcbiAgICAgIHMuZnNjb2QgPSBvID4+IDYsIHMuYnNpZCA9IG8gPj4gMSAmIDMxLCBzLmJzbW9kID0gKG8gJiAxKSA8PCA0IHwgYyA+PiA0ICYgMTUsIHMuYWNtb2QgPSBjID4+IDEgJiA3LCBzLmxmZW9uID0gYyAmIDEsIHMubnVtX2RlcF9zdWIgPSB1ID4+IDEgJiAxNSwgcy5udW1fZGVwX3N1YiA+IDAgJiYgKHMuY2hhbl9sb2MgPSAodSAmIDEpIDw8IDggfCB0LnJlYWRVaW50OCgpKTtcbiAgICB9XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiZGZMYVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSAxMjcsIGkgPSAxMjgsIHMgPSBbXSwgbyA9IFtcbiAgICAgIFwiU1RSRUFNSU5GT1wiLFxuICAgICAgXCJQQURESU5HXCIsXG4gICAgICBcIkFQUExJQ0FUSU9OXCIsXG4gICAgICBcIlNFRUtUQUJMRVwiLFxuICAgICAgXCJWT1JCSVNfQ09NTUVOVFwiLFxuICAgICAgXCJDVUVTSEVFVFwiLFxuICAgICAgXCJQSUNUVVJFXCIsXG4gICAgICBcIlJFU0VSVkVEXCJcbiAgICBdO1xuICAgIHRoaXMucGFyc2VGdWxsSGVhZGVyKHQpO1xuICAgIGRvIHtcbiAgICAgIHZhciBjID0gdC5yZWFkVWludDgoKSwgdSA9IE1hdGgubWluKFxuICAgICAgICBjICYgZSxcbiAgICAgICAgby5sZW5ndGggLSAxXG4gICAgICApO1xuICAgICAgaWYgKHUgPyB0LnJlYWRVaW50OEFycmF5KHQucmVhZFVpbnQyNCgpKSA6ICh0LnJlYWRVaW50OEFycmF5KDEzKSwgdGhpcy5zYW1wbGVyYXRlID0gdC5yZWFkVWludDMyKCkgPj4gMTIsIHQucmVhZFVpbnQ4QXJyYXkoMjApKSwgcy5wdXNoKG9bdV0pLCBjICYgaSlcbiAgICAgICAgYnJlYWs7XG4gICAgfSB3aGlsZSAoITApO1xuICAgIHRoaXMubnVtTWV0YWRhdGFCbG9ja3MgPSBzLmxlbmd0aCArIFwiIChcIiArIHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJkaW1tXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmJ5dGVzc2VudCA9IHQucmVhZFVpbnQ2NCgpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiZG1heFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50aW1lID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJkbWVkXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmJ5dGVzc2VudCA9IHQucmVhZFVpbnQ2NCgpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiZE9wc1wiLCBmdW5jdGlvbih0KSB7XG4gICAgaWYgKHRoaXMuVmVyc2lvbiA9IHQucmVhZFVpbnQ4KCksIHRoaXMuT3V0cHV0Q2hhbm5lbENvdW50ID0gdC5yZWFkVWludDgoKSwgdGhpcy5QcmVTa2lwID0gdC5yZWFkVWludDE2KCksIHRoaXMuSW5wdXRTYW1wbGVSYXRlID0gdC5yZWFkVWludDMyKCksIHRoaXMuT3V0cHV0R2FpbiA9IHQucmVhZEludDE2KCksIHRoaXMuQ2hhbm5lbE1hcHBpbmdGYW1pbHkgPSB0LnJlYWRVaW50OCgpLCB0aGlzLkNoYW5uZWxNYXBwaW5nRmFtaWx5ICE9PSAwKSB7XG4gICAgICB0aGlzLlN0cmVhbUNvdW50ID0gdC5yZWFkVWludDgoKSwgdGhpcy5Db3VwbGVkQ291bnQgPSB0LnJlYWRVaW50OCgpLCB0aGlzLkNoYW5uZWxNYXBwaW5nID0gW107XG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuT3V0cHV0Q2hhbm5lbENvdW50OyBlKyspXG4gICAgICAgIHRoaXMuQ2hhbm5lbE1hcHBpbmdbZV0gPSB0LnJlYWRVaW50OCgpO1xuICAgIH1cbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJkcmVmXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaTtcbiAgICB0aGlzLmVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBzID0gdC5yZWFkVWludDMyKCksIG8gPSAwOyBvIDwgczsgbysrKVxuICAgICAgaWYgKGUgPSBuLnBhcnNlT25lQm94KHQsICExLCB0aGlzLnNpemUgLSAodC5nZXRQb3NpdGlvbigpIC0gdGhpcy5zdGFydCkpLCBlLmNvZGUgPT09IG4uT0spXG4gICAgICAgIGkgPSBlLmJveCwgdGhpcy5lbnRyaWVzLnB1c2goaSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImRyZXBcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuYnl0ZXNzZW50ID0gdC5yZWFkVWludDY0KCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiZWxuZ1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5leHRlbmRlZF9sYW5ndWFnZSA9IHQucmVhZFN0cmluZyh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJlbHN0XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBlID0gdC5yZWFkVWludDMyKCksIGkgPSAwOyBpIDwgZTsgaSsrKSB7XG4gICAgICB2YXIgcyA9IHt9O1xuICAgICAgdGhpcy5lbnRyaWVzLnB1c2gocyksIHRoaXMudmVyc2lvbiA9PT0gMSA/IChzLnNlZ21lbnRfZHVyYXRpb24gPSB0LnJlYWRVaW50NjQoKSwgcy5tZWRpYV90aW1lID0gdC5yZWFkSW50NjQoKSkgOiAocy5zZWdtZW50X2R1cmF0aW9uID0gdC5yZWFkVWludDMyKCksIHMubWVkaWFfdGltZSA9IHQucmVhZEludDMyKCkpLCBzLm1lZGlhX3JhdGVfaW50ZWdlciA9IHQucmVhZEludDE2KCksIHMubWVkaWFfcmF0ZV9mcmFjdGlvbiA9IHQucmVhZEludDE2KCk7XG4gICAgfVxuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImVtc2dcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9PSAxID8gKHRoaXMudGltZXNjYWxlID0gdC5yZWFkVWludDMyKCksIHRoaXMucHJlc2VudGF0aW9uX3RpbWUgPSB0LnJlYWRVaW50NjQoKSwgdGhpcy5ldmVudF9kdXJhdGlvbiA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmlkID0gdC5yZWFkVWludDMyKCksIHRoaXMuc2NoZW1lX2lkX3VyaSA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy52YWx1ZSA9IHQucmVhZENTdHJpbmcoKSkgOiAodGhpcy5zY2hlbWVfaWRfdXJpID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLnZhbHVlID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLnRpbWVzY2FsZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnByZXNlbnRhdGlvbl90aW1lX2RlbHRhID0gdC5yZWFkVWludDMyKCksIHRoaXMuZXZlbnRfZHVyYXRpb24gPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5pZCA9IHQucmVhZFVpbnQzMigpKTtcbiAgICB2YXIgZSA9IHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgLSAoNCAqIDQgKyAodGhpcy5zY2hlbWVfaWRfdXJpLmxlbmd0aCArIDEpICsgKHRoaXMudmFsdWUubGVuZ3RoICsgMSkpO1xuICAgIHRoaXMudmVyc2lvbiA9PSAxICYmIChlIC09IDQpLCB0aGlzLm1lc3NhZ2VfZGF0YSA9IHQucmVhZFVpbnQ4QXJyYXkoZSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiZXNkc1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpO1xuICAgIGlmICh0eXBlb2YgcCA8IFwidVwiKSB7XG4gICAgICB2YXIgaSA9IG5ldyBwKCk7XG4gICAgICB0aGlzLmVzZCA9IGkucGFyc2VPbmVEZXNjcmlwdG9yKG5ldyBhKGUuYnVmZmVyLCAwLCBhLkJJR19FTkRJQU4pKTtcbiAgICB9XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJmaWVsXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmZpZWxkQ291bnQgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmZpZWxkT3JkZXJpbmcgPSB0LnJlYWRVaW50OCgpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiZnJtYVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5kYXRhX2Zvcm1hdCA9IHQucmVhZFN0cmluZyg0KTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImZ0eXBcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZTtcbiAgICB0aGlzLm1ham9yX2JyYW5kID0gdC5yZWFkU3RyaW5nKDQpLCB0aGlzLm1pbm9yX3ZlcnNpb24gPSB0LnJlYWRVaW50MzIoKSwgZSAtPSA4LCB0aGlzLmNvbXBhdGlibGVfYnJhbmRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGUgPj0gNDsgKVxuICAgICAgdGhpcy5jb21wYXRpYmxlX2JyYW5kc1tpXSA9IHQucmVhZFN0cmluZyg0KSwgZSAtPSA0LCBpKys7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiaGRsclwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID09PSAwICYmICh0LnJlYWRVaW50MzIoKSwgdGhpcy5oYW5kbGVyID0gdC5yZWFkU3RyaW5nKDQpLCB0LnJlYWRVaW50MzJBcnJheSgzKSwgdGhpcy5uYW1lID0gdC5yZWFkU3RyaW5nKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgLSAyMCksIHRoaXMubmFtZVt0aGlzLm5hbWUubGVuZ3RoIC0gMV0gPT09IFwiXFwwXCIgJiYgKHRoaXMubmFtZSA9IHRoaXMubmFtZS5zbGljZSgwLCAtMSkpKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImh2Y0NcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpLCBzLCBvO1xuICAgIHRoaXMuY29uZmlndXJhdGlvblZlcnNpb24gPSB0LnJlYWRVaW50OCgpLCBvID0gdC5yZWFkVWludDgoKSwgdGhpcy5nZW5lcmFsX3Byb2ZpbGVfc3BhY2UgPSBvID4+IDYsIHRoaXMuZ2VuZXJhbF90aWVyX2ZsYWcgPSAobyAmIDMyKSA+PiA1LCB0aGlzLmdlbmVyYWxfcHJvZmlsZV9pZGMgPSBvICYgMzEsIHRoaXMuZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHkgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5nZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yID0gdC5yZWFkVWludDhBcnJheSg2KSwgdGhpcy5nZW5lcmFsX2xldmVsX2lkYyA9IHQucmVhZFVpbnQ4KCksIHRoaXMubWluX3NwYXRpYWxfc2VnbWVudGF0aW9uX2lkYyA9IHQucmVhZFVpbnQxNigpICYgNDA5NSwgdGhpcy5wYXJhbGxlbGlzbVR5cGUgPSB0LnJlYWRVaW50OCgpICYgMywgdGhpcy5jaHJvbWFfZm9ybWF0X2lkYyA9IHQucmVhZFVpbnQ4KCkgJiAzLCB0aGlzLmJpdF9kZXB0aF9sdW1hX21pbnVzOCA9IHQucmVhZFVpbnQ4KCkgJiA3LCB0aGlzLmJpdF9kZXB0aF9jaHJvbWFfbWludXM4ID0gdC5yZWFkVWludDgoKSAmIDcsIHRoaXMuYXZnRnJhbWVSYXRlID0gdC5yZWFkVWludDE2KCksIG8gPSB0LnJlYWRVaW50OCgpLCB0aGlzLmNvbnN0YW50RnJhbWVSYXRlID0gbyA+PiA2LCB0aGlzLm51bVRlbXBvcmFsTGF5ZXJzID0gKG8gJiAxMykgPj4gMywgdGhpcy50ZW1wb3JhbElkTmVzdGVkID0gKG8gJiA0KSA+PiAyLCB0aGlzLmxlbmd0aFNpemVNaW51c09uZSA9IG8gJiAzLCB0aGlzLm5hbHVfYXJyYXlzID0gW107XG4gICAgdmFyIGMgPSB0LnJlYWRVaW50OCgpO1xuICAgIGZvciAoZSA9IDA7IGUgPCBjOyBlKyspIHtcbiAgICAgIHZhciB1ID0gW107XG4gICAgICB0aGlzLm5hbHVfYXJyYXlzLnB1c2godSksIG8gPSB0LnJlYWRVaW50OCgpLCB1LmNvbXBsZXRlbmVzcyA9IChvICYgMTI4KSA+PiA3LCB1Lm5hbHVfdHlwZSA9IG8gJiA2MztcbiAgICAgIHZhciBfID0gdC5yZWFkVWludDE2KCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgXzsgaSsrKSB7XG4gICAgICAgIHZhciBnID0ge307XG4gICAgICAgIHUucHVzaChnKSwgcyA9IHQucmVhZFVpbnQxNigpLCBnLmRhdGEgPSB0LnJlYWRVaW50OEFycmF5KHMpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJpaW5mXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLnZlcnNpb24gPT09IDAgPyB0aGlzLmVudHJ5X2NvdW50ID0gdC5yZWFkVWludDE2KCkgOiB0aGlzLmVudHJ5X2NvdW50ID0gdC5yZWFkVWludDMyKCksIHRoaXMuaXRlbV9pbmZvcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRyeV9jb3VudDsgaSsrKVxuICAgICAgaWYgKGUgPSBuLnBhcnNlT25lQm94KHQsICExLCB0aGlzLnNpemUgLSAodC5nZXRQb3NpdGlvbigpIC0gdGhpcy5zdGFydCkpLCBlLmNvZGUgPT09IG4uT0spXG4gICAgICAgIGUuYm94LnR5cGUgIT09IFwiaW5mZVwiICYmIHIuZXJyb3IoXCJCb3hQYXJzZXJcIiwgXCJFeHBlY3RlZCAnaW5mZScgYm94LCBnb3QgXCIgKyBlLmJveC50eXBlKSwgdGhpcy5pdGVtX2luZm9zW2ldID0gZS5ib3g7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJpbG9jXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZTtcbiAgICBlID0gdC5yZWFkVWludDgoKSwgdGhpcy5vZmZzZXRfc2l6ZSA9IGUgPj4gNCAmIDE1LCB0aGlzLmxlbmd0aF9zaXplID0gZSAmIDE1LCBlID0gdC5yZWFkVWludDgoKSwgdGhpcy5iYXNlX29mZnNldF9zaXplID0gZSA+PiA0ICYgMTUsIHRoaXMudmVyc2lvbiA9PT0gMSB8fCB0aGlzLnZlcnNpb24gPT09IDIgPyB0aGlzLmluZGV4X3NpemUgPSBlICYgMTUgOiB0aGlzLmluZGV4X3NpemUgPSAwLCB0aGlzLml0ZW1zID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh0aGlzLnZlcnNpb24gPCAyKVxuICAgICAgaSA9IHQucmVhZFVpbnQxNigpO1xuICAgIGVsc2UgaWYgKHRoaXMudmVyc2lvbiA9PT0gMilcbiAgICAgIGkgPSB0LnJlYWRVaW50MzIoKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBcInZlcnNpb24gb2YgaWxvYyBib3ggbm90IHN1cHBvcnRlZFwiO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgaTsgcysrKSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgaWYgKHRoaXMuaXRlbXMucHVzaChvKSwgdGhpcy52ZXJzaW9uIDwgMilcbiAgICAgICAgby5pdGVtX0lEID0gdC5yZWFkVWludDE2KCk7XG4gICAgICBlbHNlIGlmICh0aGlzLnZlcnNpb24gPT09IDIpXG4gICAgICAgIG8uaXRlbV9JRCA9IHQucmVhZFVpbnQxNigpO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBcInZlcnNpb24gb2YgaWxvYyBib3ggbm90IHN1cHBvcnRlZFwiO1xuICAgICAgc3dpdGNoICh0aGlzLnZlcnNpb24gPT09IDEgfHwgdGhpcy52ZXJzaW9uID09PSAyID8gby5jb25zdHJ1Y3Rpb25fbWV0aG9kID0gdC5yZWFkVWludDE2KCkgJiAxNSA6IG8uY29uc3RydWN0aW9uX21ldGhvZCA9IDAsIG8uZGF0YV9yZWZlcmVuY2VfaW5kZXggPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5iYXNlX29mZnNldF9zaXplKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBvLmJhc2Vfb2Zmc2V0ID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIG8uYmFzZV9vZmZzZXQgPSB0LnJlYWRVaW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIG8uYmFzZV9vZmZzZXQgPSB0LnJlYWRVaW50NjQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBcIkVycm9yIHJlYWRpbmcgYmFzZSBvZmZzZXQgc2l6ZVwiO1xuICAgICAgfVxuICAgICAgdmFyIGMgPSB0LnJlYWRVaW50MTYoKTtcbiAgICAgIG8uZXh0ZW50cyA9IFtdO1xuICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBjOyB1KyspIHtcbiAgICAgICAgdmFyIF8gPSB7fTtcbiAgICAgICAgaWYgKG8uZXh0ZW50cy5wdXNoKF8pLCB0aGlzLnZlcnNpb24gPT09IDEgfHwgdGhpcy52ZXJzaW9uID09PSAyKVxuICAgICAgICAgIHN3aXRjaCAodGhpcy5pbmRleF9zaXplKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF8uZXh0ZW50X2luZGV4ID0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF8uZXh0ZW50X2luZGV4ID0gdC5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBfLmV4dGVudF9pbmRleCA9IHQucmVhZFVpbnQ2NCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IFwiRXJyb3IgcmVhZGluZyBleHRlbnQgaW5kZXhcIjtcbiAgICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5vZmZzZXRfc2l6ZSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF8uZXh0ZW50X29mZnNldCA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfLmV4dGVudF9vZmZzZXQgPSB0LnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF8uZXh0ZW50X29mZnNldCA9IHQucmVhZFVpbnQ2NCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFwiRXJyb3IgcmVhZGluZyBleHRlbnQgaW5kZXhcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMubGVuZ3RoX3NpemUpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfLmV4dGVudF9sZW5ndGggPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgXy5leHRlbnRfbGVuZ3RoID0gdC5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfLmV4dGVudF9sZW5ndGggPSB0LnJlYWRVaW50NjQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBcIkVycm9yIHJlYWRpbmcgZXh0ZW50IGluZGV4XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJpbWlyXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5yZXNlcnZlZCA9IGUgPj4gNywgdGhpcy5heGlzID0gZSAmIDE7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiaW5mZVwiLCBmdW5jdGlvbih0KSB7XG4gICAgaWYgKCh0aGlzLnZlcnNpb24gPT09IDAgfHwgdGhpcy52ZXJzaW9uID09PSAxKSAmJiAodGhpcy5pdGVtX0lEID0gdC5yZWFkVWludDE2KCksIHRoaXMuaXRlbV9wcm90ZWN0aW9uX2luZGV4ID0gdC5yZWFkVWludDE2KCksIHRoaXMuaXRlbV9uYW1lID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLmNvbnRlbnRfdHlwZSA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5jb250ZW50X2VuY29kaW5nID0gdC5yZWFkQ1N0cmluZygpKSwgdGhpcy52ZXJzaW9uID09PSAxKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbl90eXBlID0gdC5yZWFkU3RyaW5nKDQpLCByLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJDYW5ub3QgcGFyc2UgZXh0ZW5zaW9uIHR5cGVcIiksIHQuc2Vlayh0aGlzLnN0YXJ0ICsgdGhpcy5zaXplKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy52ZXJzaW9uID49IDIgJiYgKHRoaXMudmVyc2lvbiA9PT0gMiA/IHRoaXMuaXRlbV9JRCA9IHQucmVhZFVpbnQxNigpIDogdGhpcy52ZXJzaW9uID09PSAzICYmICh0aGlzLml0ZW1fSUQgPSB0LnJlYWRVaW50MzIoKSksIHRoaXMuaXRlbV9wcm90ZWN0aW9uX2luZGV4ID0gdC5yZWFkVWludDE2KCksIHRoaXMuaXRlbV90eXBlID0gdC5yZWFkU3RyaW5nKDQpLCB0aGlzLml0ZW1fbmFtZSA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5pdGVtX3R5cGUgPT09IFwibWltZVwiID8gKHRoaXMuY29udGVudF90eXBlID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLmNvbnRlbnRfZW5jb2RpbmcgPSB0LnJlYWRDU3RyaW5nKCkpIDogdGhpcy5pdGVtX3R5cGUgPT09IFwidXJpIFwiICYmICh0aGlzLml0ZW1fdXJpX3R5cGUgPSB0LnJlYWRDU3RyaW5nKCkpKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJpcG1hXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaTtcbiAgICBmb3IgKGVudHJ5X2NvdW50ID0gdC5yZWFkVWludDMyKCksIHRoaXMuYXNzb2NpYXRpb25zID0gW10sIGUgPSAwOyBlIDwgZW50cnlfY291bnQ7IGUrKykge1xuICAgICAgdmFyIHMgPSB7fTtcbiAgICAgIHRoaXMuYXNzb2NpYXRpb25zLnB1c2gocyksIHRoaXMudmVyc2lvbiA8IDEgPyBzLmlkID0gdC5yZWFkVWludDE2KCkgOiBzLmlkID0gdC5yZWFkVWludDMyKCk7XG4gICAgICB2YXIgbyA9IHQucmVhZFVpbnQ4KCk7XG4gICAgICBmb3IgKHMucHJvcHMgPSBbXSwgaSA9IDA7IGkgPCBvOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSB0LnJlYWRVaW50OCgpLCB1ID0ge307XG4gICAgICAgIHMucHJvcHMucHVzaCh1KSwgdS5lc3NlbnRpYWwgPSAoYyAmIDEyOCkgPj4gNyA9PT0gMSwgdGhpcy5mbGFncyAmIDEgPyB1LnByb3BlcnR5X2luZGV4ID0gKGMgJiAxMjcpIDw8IDggfCB0LnJlYWRVaW50OCgpIDogdS5wcm9wZXJ0eV9pbmRleCA9IGMgJiAxMjc7XG4gICAgICB9XG4gICAgfVxuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImlyZWZcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpO1xuICAgIGZvciAodGhpcy5yZWZlcmVuY2VzID0gW107IHQuZ2V0UG9zaXRpb24oKSA8IHRoaXMuc3RhcnQgKyB0aGlzLnNpemU7IClcbiAgICAgIGlmIChlID0gbi5wYXJzZU9uZUJveCh0LCAhMCwgdGhpcy5zaXplIC0gKHQuZ2V0UG9zaXRpb24oKSAtIHRoaXMuc3RhcnQpKSwgZS5jb2RlID09PSBuLk9LKVxuICAgICAgICB0aGlzLnZlcnNpb24gPT09IDAgPyBpID0gbmV3IG4uU2luZ2xlSXRlbVR5cGVSZWZlcmVuY2VCb3goZS50eXBlLCBlLnNpemUsIGUuaGRyX3NpemUsIGUuc3RhcnQpIDogaSA9IG5ldyBuLlNpbmdsZUl0ZW1UeXBlUmVmZXJlbmNlQm94TGFyZ2UoZS50eXBlLCBlLnNpemUsIGUuaGRyX3NpemUsIGUuc3RhcnQpLCBpLndyaXRlID09PSBuLkJveC5wcm90b3R5cGUud3JpdGUgJiYgaS50eXBlICE9PSBcIm1kYXRcIiAmJiAoci53YXJuKFwiQm94UGFyc2VyXCIsIGkudHlwZSArIFwiIGJveCB3cml0aW5nIG5vdCB5ZXQgaW1wbGVtZW50ZWQsIGtlZXBpbmcgdW5wYXJzZWQgZGF0YSBpbiBtZW1vcnkgZm9yIGxhdGVyIHdyaXRlXCIpLCBpLnBhcnNlRGF0YUFuZFJld2luZCh0KSksIGkucGFyc2UodCksIHRoaXMucmVmZXJlbmNlcy5wdXNoKGkpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm47XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJpcm90XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmFuZ2xlID0gdC5yZWFkVWludDgoKSAmIDM7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiaXNwZVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5pbWFnZV93aWR0aCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmltYWdlX2hlaWdodCA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImtpbmRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2NoZW1lVVJJID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLnZhbHVlID0gdC5yZWFkQ1N0cmluZygpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImxldmFcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5yZWFkVWludDgoKTtcbiAgICB0aGlzLmxldmVscyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZTsgaSsrKSB7XG4gICAgICB2YXIgcyA9IHt9O1xuICAgICAgdGhpcy5sZXZlbHNbaV0gPSBzLCBzLnRyYWNrX0lEID0gdC5yZWFkVWludDMyKCk7XG4gICAgICB2YXIgbyA9IHQucmVhZFVpbnQ4KCk7XG4gICAgICBzd2l0Y2ggKHMucGFkZGluZ19mbGFnID0gbyA+PiA3LCBzLmFzc2lnbm1lbnRfdHlwZSA9IG8gJiAxMjcsIHMuYXNzaWdubWVudF90eXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBzLmdyb3VwaW5nX3R5cGUgPSB0LnJlYWRTdHJpbmcoNCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBzLmdyb3VwaW5nX3R5cGUgPSB0LnJlYWRTdHJpbmcoNCksIHMuZ3JvdXBpbmdfdHlwZV9wYXJhbWV0ZXIgPSB0LnJlYWRVaW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzLnN1Yl90cmFja19pZCA9IHQucmVhZFVpbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHIud2FybihcIkJveFBhcnNlclwiLCBcIlVua25vd24gbGV2YSBhc3NpZ25lbWVudCB0eXBlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImxzZWxcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMubGF5ZXJfaWQgPSB0LnJlYWRVaW50MTYoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcIm1heHJcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGVyaW9kID0gdC5yZWFkVWludDMyKCksIHRoaXMuYnl0ZXMgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcIm1kY3ZcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuZGlzcGxheV9wcmltYXJpZXMgPSBbXSwgdGhpcy5kaXNwbGF5X3ByaW1hcmllc1swXSA9IHt9LCB0aGlzLmRpc3BsYXlfcHJpbWFyaWVzWzBdLnggPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5kaXNwbGF5X3ByaW1hcmllc1swXS55ID0gdC5yZWFkVWludDE2KCksIHRoaXMuZGlzcGxheV9wcmltYXJpZXNbMV0gPSB7fSwgdGhpcy5kaXNwbGF5X3ByaW1hcmllc1sxXS54ID0gdC5yZWFkVWludDE2KCksIHRoaXMuZGlzcGxheV9wcmltYXJpZXNbMV0ueSA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmRpc3BsYXlfcHJpbWFyaWVzWzJdID0ge30sIHRoaXMuZGlzcGxheV9wcmltYXJpZXNbMl0ueCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmRpc3BsYXlfcHJpbWFyaWVzWzJdLnkgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy53aGl0ZV9wb2ludCA9IHt9LCB0aGlzLndoaXRlX3BvaW50LnggPSB0LnJlYWRVaW50MTYoKSwgdGhpcy53aGl0ZV9wb2ludC55ID0gdC5yZWFkVWludDE2KCksIHRoaXMubWF4X2Rpc3BsYXlfbWFzdGVyaW5nX2x1bWluYW5jZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLm1pbl9kaXNwbGF5X21hc3RlcmluZ19sdW1pbmFuY2UgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJtZGhkXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPT0gMSA/ICh0aGlzLmNyZWF0aW9uX3RpbWUgPSB0LnJlYWRVaW50NjQoKSwgdGhpcy5tb2RpZmljYXRpb25fdGltZSA9IHQucmVhZFVpbnQ2NCgpLCB0aGlzLnRpbWVzY2FsZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmR1cmF0aW9uID0gdC5yZWFkVWludDY0KCkpIDogKHRoaXMuY3JlYXRpb25fdGltZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLm1vZGlmaWNhdGlvbl90aW1lID0gdC5yZWFkVWludDMyKCksIHRoaXMudGltZXNjYWxlID0gdC5yZWFkVWludDMyKCksIHRoaXMuZHVyYXRpb24gPSB0LnJlYWRVaW50MzIoKSksIHRoaXMucGFyc2VMYW5ndWFnZSh0KSwgdC5yZWFkVWludDE2KCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwibWVoZFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5mbGFncyAmIDEgJiYgKHIud2FybihcIkJveFBhcnNlclwiLCBcIm1laGQgYm94IGluY29ycmVjdGx5IHVzZXMgZmxhZ3Mgc2V0IHRvIDEsIGNvbnZlcnRpbmcgdmVyc2lvbiB0byAxXCIpLCB0aGlzLnZlcnNpb24gPSAxKSwgdGhpcy52ZXJzaW9uID09IDEgPyB0aGlzLmZyYWdtZW50X2R1cmF0aW9uID0gdC5yZWFkVWludDY0KCkgOiB0aGlzLmZyYWdtZW50X2R1cmF0aW9uID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwibWV0YVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5ib3hlcyA9IFtdLCBuLkNvbnRhaW5lckJveC5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCB0KTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJtZmhkXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNlcXVlbmNlX251bWJlciA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcIm1mcm9cIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuX3NpemUgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJtdmhkXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPT0gMSA/ICh0aGlzLmNyZWF0aW9uX3RpbWUgPSB0LnJlYWRVaW50NjQoKSwgdGhpcy5tb2RpZmljYXRpb25fdGltZSA9IHQucmVhZFVpbnQ2NCgpLCB0aGlzLnRpbWVzY2FsZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmR1cmF0aW9uID0gdC5yZWFkVWludDY0KCkpIDogKHRoaXMuY3JlYXRpb25fdGltZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLm1vZGlmaWNhdGlvbl90aW1lID0gdC5yZWFkVWludDMyKCksIHRoaXMudGltZXNjYWxlID0gdC5yZWFkVWludDMyKCksIHRoaXMuZHVyYXRpb24gPSB0LnJlYWRVaW50MzIoKSksIHRoaXMucmF0ZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnZvbHVtZSA9IHQucmVhZFVpbnQxNigpID4+IDgsIHQucmVhZFVpbnQxNigpLCB0LnJlYWRVaW50MzJBcnJheSgyKSwgdGhpcy5tYXRyaXggPSB0LnJlYWRVaW50MzJBcnJheSg5KSwgdC5yZWFkVWludDMyQXJyYXkoNiksIHRoaXMubmV4dF90cmFja19pZCA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwibnBja1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wYWNrZXRzc2VudCA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwibnVtcFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wYWNrZXRzc2VudCA9IHQucmVhZFVpbnQ2NCgpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInBhZGJcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5yZWFkVWludDMyKCk7XG4gICAgdGhpcy5wYWRiaXRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLmZsb29yKChlICsgMSkgLyAyKTsgaSsrKVxuICAgICAgdGhpcy5wYWRiaXRzID0gdC5yZWFkVWludDgoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInBhc3BcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuaFNwYWNpbmcgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy52U3BhY2luZyA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwicGF5bFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50ZXh0ID0gdC5yZWFkU3RyaW5nKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwicGF5dFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wYXlsb2FkSUQgPSB0LnJlYWRVaW50MzIoKTtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5ydHBtYXBfc3RyaW5nID0gdC5yZWFkU3RyaW5nKGUpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInBkaW5cIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpIC8gODtcbiAgICB0aGlzLnJhdGUgPSBbXSwgdGhpcy5pbml0aWFsX2RlbGF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICB0aGlzLnJhdGVbaV0gPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5pbml0aWFsX2RlbGF5W2ldID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwicGl0bVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID09PSAwID8gdGhpcy5pdGVtX2lkID0gdC5yZWFkVWludDE2KCkgOiB0aGlzLml0ZW1faWQgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJwaXhpXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZTtcbiAgICBmb3IgKHRoaXMubnVtX2NoYW5uZWxzID0gdC5yZWFkVWludDgoKSwgdGhpcy5iaXRzX3Blcl9jaGFubmVscyA9IFtdLCBlID0gMDsgZSA8IHRoaXMubnVtX2NoYW5uZWxzOyBlKyspXG4gICAgICB0aGlzLmJpdHNfcGVyX2NoYW5uZWxzW2VdID0gdC5yZWFkVWludDgoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInBtYXhcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuYnl0ZXMgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJwcmZ0XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnJlZl90cmFja19pZCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLm50cF90aW1lc3RhbXAgPSB0LnJlYWRVaW50NjQoKSwgdGhpcy52ZXJzaW9uID09PSAwID8gdGhpcy5tZWRpYV90aW1lID0gdC5yZWFkVWludDMyKCkgOiB0aGlzLm1lZGlhX3RpbWUgPSB0LnJlYWRVaW50NjQoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJwc3NoXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW1faWQgPSBuLnBhcnNlSGV4MTYodCksIHRoaXMudmVyc2lvbiA+IDApIHtcbiAgICAgIHZhciBlID0gdC5yZWFkVWludDMyKCk7XG4gICAgICB0aGlzLmtpZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICAgIHRoaXMua2lkW2ldID0gbi5wYXJzZUhleDE2KHQpO1xuICAgIH1cbiAgICB2YXIgcyA9IHQucmVhZFVpbnQzMigpO1xuICAgIHMgPiAwICYmICh0aGlzLmRhdGEgPSB0LnJlYWRVaW50OEFycmF5KHMpKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJjbGVmXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLndpZHRoID0gdC5yZWFkVWludDMyKCksIHRoaXMuaGVpZ2h0ID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiZW5vZlwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy53aWR0aCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmhlaWdodCA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInByb2ZcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMud2lkdGggPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5oZWlnaHQgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQ29udGFpbmVyQm94Q3RvcihcInRhcHRcIiwgbnVsbCwgW1wiY2xlZlwiLCBcInByb2ZcIiwgXCJlbm9mXCJdKSwgbi5jcmVhdGVCb3hDdG9yKFwicnRwIFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5kZXNjcmlwdGlvbmZvcm1hdCA9IHQucmVhZFN0cmluZyg0KSwgdGhpcy5zZHB0ZXh0ID0gdC5yZWFkU3RyaW5nKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgLSA0KTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzYWlvXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmZsYWdzICYgMSAmJiAodGhpcy5hdXhfaW5mb190eXBlID0gdC5yZWFkVWludDMyKCksIHRoaXMuYXV4X2luZm9fdHlwZV9wYXJhbWV0ZXIgPSB0LnJlYWRVaW50MzIoKSk7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50MzIoKTtcbiAgICB0aGlzLm9mZnNldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgICAgdGhpcy52ZXJzaW9uID09PSAwID8gdGhpcy5vZmZzZXRbaV0gPSB0LnJlYWRVaW50MzIoKSA6IHRoaXMub2Zmc2V0W2ldID0gdC5yZWFkVWludDY0KCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic2FpelwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5mbGFncyAmIDEgJiYgKHRoaXMuYXV4X2luZm9fdHlwZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmF1eF9pbmZvX3R5cGVfcGFyYW1ldGVyID0gdC5yZWFkVWludDMyKCkpLCB0aGlzLmRlZmF1bHRfc2FtcGxlX2luZm9fc2l6ZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50MzIoKTtcbiAgICBpZiAodGhpcy5zYW1wbGVfaW5mb19zaXplID0gW10sIHRoaXMuZGVmYXVsdF9zYW1wbGVfaW5mb19zaXplID09PSAwKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICAgIHRoaXMuc2FtcGxlX2luZm9fc2l6ZVtpXSA9IHQucmVhZFVpbnQ4KCk7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX01FVEFEQVRBLCBcIm1ldHRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIodCksIHRoaXMuY29udGVudF9lbmNvZGluZyA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5taW1lX2Zvcm1hdCA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5wYXJzZUZvb3Rlcih0KTtcbiAgfSksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfTUVUQURBVEEsIFwibWV0eFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wYXJzZUhlYWRlcih0KSwgdGhpcy5jb250ZW50X2VuY29kaW5nID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLm5hbWVzcGFjZSA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5zY2hlbWFfbG9jYXRpb24gPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMucGFyc2VGb290ZXIodCk7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1NVQlRJVExFLCBcInNidHRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIodCksIHRoaXMuY29udGVudF9lbmNvZGluZyA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5taW1lX2Zvcm1hdCA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5wYXJzZUZvb3Rlcih0KTtcbiAgfSksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfU1VCVElUTEUsIFwic3RwcFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wYXJzZUhlYWRlcih0KSwgdGhpcy5uYW1lc3BhY2UgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMuc2NoZW1hX2xvY2F0aW9uID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLmF1eGlsaWFyeV9taW1lX3R5cGVzID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLnBhcnNlRm9vdGVyKHQpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9TVUJUSVRMRSwgXCJzdHh0XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlSGVhZGVyKHQpLCB0aGlzLmNvbnRlbnRfZW5jb2RpbmcgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMubWltZV9mb3JtYXQgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMucGFyc2VGb290ZXIodCk7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1NVQlRJVExFLCBcInR4M2dcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIodCksIHRoaXMuZGlzcGxheUZsYWdzID0gdC5yZWFkVWludDMyKCksIHRoaXMuaG9yaXpvbnRhbF9qdXN0aWZpY2F0aW9uID0gdC5yZWFkSW50OCgpLCB0aGlzLnZlcnRpY2FsX2p1c3RpZmljYXRpb24gPSB0LnJlYWRJbnQ4KCksIHRoaXMuYmdfY29sb3JfcmdiYSA9IHQucmVhZFVpbnQ4QXJyYXkoNCksIHRoaXMuYm94X3JlY29yZCA9IHQucmVhZEludDE2QXJyYXkoNCksIHRoaXMuc3R5bGVfcmVjb3JkID0gdC5yZWFkVWludDhBcnJheSgxMiksIHRoaXMucGFyc2VGb290ZXIodCk7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX01FVEFEQVRBLCBcInd2dHRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIodCksIHRoaXMucGFyc2VGb290ZXIodCk7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcImFsc3RcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpID0gdC5yZWFkVWludDE2KCk7XG4gICAgZm9yICh0aGlzLmZpcnN0X291dHB1dF9zYW1wbGUgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5zYW1wbGVfb2Zmc2V0ID0gW10sIGUgPSAwOyBlIDwgaTsgZSsrKVxuICAgICAgdGhpcy5zYW1wbGVfb2Zmc2V0W2VdID0gdC5yZWFkVWludDMyKCk7XG4gICAgdmFyIHMgPSB0aGlzLmRlc2NyaXB0aW9uX2xlbmd0aCAtIDQgLSA0ICogaTtcbiAgICBmb3IgKHRoaXMubnVtX291dHB1dF9zYW1wbGVzID0gW10sIHRoaXMubnVtX3RvdGFsX3NhbXBsZXMgPSBbXSwgZSA9IDA7IGUgPCBzIC8gNDsgZSsrKVxuICAgICAgdGhpcy5udW1fb3V0cHV0X3NhbXBsZXNbZV0gPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5udW1fdG90YWxfc2FtcGxlc1tlXSA9IHQucmVhZFVpbnQxNigpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJhdmxsXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmxheWVyTnVtYmVyID0gdC5yZWFkVWludDgoKSwgdGhpcy5hY2N1cmF0ZVN0YXRpc3RpY3NGbGFnID0gdC5yZWFkVWludDgoKSwgdGhpcy5hdmdCaXRSYXRlID0gdC5yZWFkVWludDE2KCksIHRoaXMuYXZnRnJhbWVSYXRlID0gdC5yZWFkVWludDE2KCk7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcImF2c3NcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3ViU2VxdWVuY2VJZGVudGlmaWVyID0gdC5yZWFkVWludDE2KCksIHRoaXMubGF5ZXJOdW1iZXIgPSB0LnJlYWRVaW50OCgpO1xuICAgIHZhciBlID0gdC5yZWFkVWludDgoKTtcbiAgICB0aGlzLmR1cmF0aW9uRmxhZyA9IGUgPj4gNywgdGhpcy5hdmdSYXRlRmxhZyA9IGUgPj4gNiAmIDEsIHRoaXMuZHVyYXRpb25GbGFnICYmICh0aGlzLmR1cmF0aW9uID0gdC5yZWFkVWludDMyKCkpLCB0aGlzLmF2Z1JhdGVGbGFnICYmICh0aGlzLmFjY3VyYXRlU3RhdGlzdGljc0ZsYWcgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmF2Z0JpdFJhdGUgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5hdmdGcmFtZVJhdGUgPSB0LnJlYWRVaW50MTYoKSksIHRoaXMuZGVwZW5kZW5jeSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSB0LnJlYWRVaW50OCgpLCBzID0gMDsgcyA8IGk7IHMrKykge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeS5wdXNoKG8pLCBvLnN1YlNlcURpcmVjdGlvbkZsYWcgPSB0LnJlYWRVaW50OCgpLCBvLmxheWVyTnVtYmVyID0gdC5yZWFkVWludDgoKSwgby5zdWJTZXF1ZW5jZUlkZW50aWZpZXIgPSB0LnJlYWRVaW50MTYoKTtcbiAgICB9XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcImR0cnRcIiwgZnVuY3Rpb24odCkge1xuICAgIHIud2FybihcIkJveFBhcnNlclwiLCBcIlNhbXBsZSBHcm91cCB0eXBlOiBcIiArIHRoaXMuZ3JvdXBpbmdfdHlwZSArIFwiIG5vdCBmdWxseSBwYXJzZWRcIik7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcIm12aWZcIiwgZnVuY3Rpb24odCkge1xuICAgIHIud2FybihcIkJveFBhcnNlclwiLCBcIlNhbXBsZSBHcm91cCB0eXBlOiBcIiArIHRoaXMuZ3JvdXBpbmdfdHlwZSArIFwiIG5vdCBmdWxseSBwYXJzZWRcIik7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInByb2xcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucm9sbF9kaXN0YW5jZSA9IHQucmVhZEludDE2KCk7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInJhcCBcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5yZWFkVWludDgoKTtcbiAgICB0aGlzLm51bV9sZWFkaW5nX3NhbXBsZXNfa25vd24gPSBlID4+IDcsIHRoaXMubnVtX2xlYWRpbmdfc2FtcGxlcyA9IGUgJiAxMjc7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInJhc2hcIiwgZnVuY3Rpb24odCkge1xuICAgIGlmICh0aGlzLm9wZXJhdGlvbl9wb2ludF9jb3VudCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmRlc2NyaXB0aW9uX2xlbmd0aCAhPT0gMiArICh0aGlzLm9wZXJhdGlvbl9wb2ludF9jb3VudCA9PT0gMSA/IDIgOiB0aGlzLm9wZXJhdGlvbl9wb2ludF9jb3VudCAqIDYpICsgOSlcbiAgICAgIHIud2FybihcIkJveFBhcnNlclwiLCBcIk1pc21hdGNoIGluIFwiICsgdGhpcy5ncm91cGluZ190eXBlICsgXCIgc2FtcGxlIGdyb3VwIGxlbmd0aFwiKSwgdGhpcy5kYXRhID0gdC5yZWFkVWludDhBcnJheSh0aGlzLmRlc2NyaXB0aW9uX2xlbmd0aCAtIDIpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMub3BlcmF0aW9uX3BvaW50X2NvdW50ID09PSAxKVxuICAgICAgICB0aGlzLnRhcmdldF9yYXRlX3NoYXJlID0gdC5yZWFkVWludDE2KCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy50YXJnZXRfcmF0ZV9zaGFyZSA9IFtdLCB0aGlzLmF2YWlsYWJsZV9iaXRyYXRlID0gW107XG4gICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5vcGVyYXRpb25fcG9pbnRfY291bnQ7IGUrKylcbiAgICAgICAgICB0aGlzLmF2YWlsYWJsZV9iaXRyYXRlW2VdID0gdC5yZWFkVWludDMyKCksIHRoaXMudGFyZ2V0X3JhdGVfc2hhcmVbZV0gPSB0LnJlYWRVaW50MTYoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWF4aW11bV9iaXRyYXRlID0gdC5yZWFkVWludDMyKCksIHRoaXMubWluaW11bV9iaXRyYXRlID0gdC5yZWFkVWludDMyKCksIHRoaXMuZGlzY2FyZF9wcmlvcml0eSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgfVxuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJyb2xsXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnJvbGxfZGlzdGFuY2UgPSB0LnJlYWRJbnQxNigpO1xuICB9KSwgbi5TYW1wbGVHcm91cEVudHJ5LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICByLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJVbmtub3duIFNhbXBsZSBHcm91cCB0eXBlOiBcIiArIHRoaXMuZ3JvdXBpbmdfdHlwZSksIHRoaXMuZGF0YSA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5kZXNjcmlwdGlvbl9sZW5ndGgpO1xuICB9LCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInNjaWZcIiwgZnVuY3Rpb24odCkge1xuICAgIHIud2FybihcIkJveFBhcnNlclwiLCBcIlNhbXBsZSBHcm91cCB0eXBlOiBcIiArIHRoaXMuZ3JvdXBpbmdfdHlwZSArIFwiIG5vdCBmdWxseSBwYXJzZWRcIik7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInNjbm1cIiwgZnVuY3Rpb24odCkge1xuICAgIHIud2FybihcIkJveFBhcnNlclwiLCBcIlNhbXBsZSBHcm91cCB0eXBlOiBcIiArIHRoaXMuZ3JvdXBpbmdfdHlwZSArIFwiIG5vdCBmdWxseSBwYXJzZWRcIik7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInNlaWdcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucmVzZXJ2ZWQgPSB0LnJlYWRVaW50OCgpO1xuICAgIHZhciBlID0gdC5yZWFkVWludDgoKTtcbiAgICB0aGlzLmNyeXB0X2J5dGVfYmxvY2sgPSBlID4+IDQsIHRoaXMuc2tpcF9ieXRlX2Jsb2NrID0gZSAmIDE1LCB0aGlzLmlzUHJvdGVjdGVkID0gdC5yZWFkVWludDgoKSwgdGhpcy5QZXJfU2FtcGxlX0lWX1NpemUgPSB0LnJlYWRVaW50OCgpLCB0aGlzLktJRCA9IG4ucGFyc2VIZXgxNih0KSwgdGhpcy5jb25zdGFudF9JVl9zaXplID0gMCwgdGhpcy5jb25zdGFudF9JViA9IDAsIHRoaXMuaXNQcm90ZWN0ZWQgPT09IDEgJiYgdGhpcy5QZXJfU2FtcGxlX0lWX1NpemUgPT09IDAgJiYgKHRoaXMuY29uc3RhbnRfSVZfc2l6ZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuY29uc3RhbnRfSVYgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuY29uc3RhbnRfSVZfc2l6ZSkpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJzdHNhXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGUgR3JvdXAgdHlwZTogXCIgKyB0aGlzLmdyb3VwaW5nX3R5cGUgKyBcIiBub3QgZnVsbHkgcGFyc2VkXCIpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJzeW5jXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5OQUxfdW5pdF90eXBlID0gZSAmIDYzO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJ0ZWxlXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5sZXZlbF9pbmRlcGVuZGVudGx5X2RlY29kYWJsZSA9IGUgPj4gNztcbiAgfSksIG4uY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwidHNhc1wiLCBmdW5jdGlvbih0KSB7XG4gICAgci53YXJuKFwiQm94UGFyc2VyXCIsIFwiU2FtcGxlIEdyb3VwIHR5cGU6IFwiICsgdGhpcy5ncm91cGluZ190eXBlICsgXCIgbm90IGZ1bGx5IHBhcnNlZFwiKTtcbiAgfSksIG4uY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwidHNjbFwiLCBmdW5jdGlvbih0KSB7XG4gICAgci53YXJuKFwiQm94UGFyc2VyXCIsIFwiU2FtcGxlIEdyb3VwIHR5cGU6IFwiICsgdGhpcy5ncm91cGluZ190eXBlICsgXCIgbm90IGZ1bGx5IHBhcnNlZFwiKTtcbiAgfSksIG4uY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwidmlwclwiLCBmdW5jdGlvbih0KSB7XG4gICAgci53YXJuKFwiQm94UGFyc2VyXCIsIFwiU2FtcGxlIEdyb3VwIHR5cGU6IFwiICsgdGhpcy5ncm91cGluZ190eXBlICsgXCIgbm90IGZ1bGx5IHBhcnNlZFwiKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzYmdwXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmdyb3VwaW5nX3R5cGUgPSB0LnJlYWRTdHJpbmcoNCksIHRoaXMudmVyc2lvbiA9PT0gMSA/IHRoaXMuZ3JvdXBpbmdfdHlwZV9wYXJhbWV0ZXIgPSB0LnJlYWRVaW50MzIoKSA6IHRoaXMuZ3JvdXBpbmdfdHlwZV9wYXJhbWV0ZXIgPSAwLCB0aGlzLmVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBlID0gdC5yZWFkVWludDMyKCksIGkgPSAwOyBpIDwgZTsgaSsrKSB7XG4gICAgICB2YXIgcyA9IHt9O1xuICAgICAgdGhpcy5lbnRyaWVzLnB1c2gocyksIHMuc2FtcGxlX2NvdW50ID0gdC5yZWFkSW50MzIoKSwgcy5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCA9IHQucmVhZEludDMyKCk7XG4gICAgfVxuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInNjaG1cIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2NoZW1lX3R5cGUgPSB0LnJlYWRTdHJpbmcoNCksIHRoaXMuc2NoZW1lX3ZlcnNpb24gPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5mbGFncyAmIDEgJiYgKHRoaXMuc2NoZW1lX3VyaSA9IHQucmVhZFN0cmluZyh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gOCkpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwic2RwIFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZHB0ZXh0ID0gdC5yZWFkU3RyaW5nKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInNkdHBcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpID0gdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZTtcbiAgICB0aGlzLmlzX2xlYWRpbmcgPSBbXSwgdGhpcy5zYW1wbGVfZGVwZW5kc19vbiA9IFtdLCB0aGlzLnNhbXBsZV9pc19kZXBlbmRlZF9vbiA9IFtdLCB0aGlzLnNhbXBsZV9oYXNfcmVkdW5kYW5jeSA9IFtdO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgaTsgcysrKVxuICAgICAgZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuaXNfbGVhZGluZ1tzXSA9IGUgPj4gNiwgdGhpcy5zYW1wbGVfZGVwZW5kc19vbltzXSA9IGUgPj4gNCAmIDMsIHRoaXMuc2FtcGxlX2lzX2RlcGVuZGVkX29uW3NdID0gZSA+PiAyICYgMywgdGhpcy5zYW1wbGVfaGFzX3JlZHVuZGFuY3lbc10gPSBlICYgMztcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXG4gICAgXCJzZW5jXCJcbiAgICAvKiwgZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgXHR0aGlzLnBhcnNlRnVsbEhlYWRlcihzdHJlYW0pO1xuICAgIFx0dmFyIHNhbXBsZV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG4gICAgXHR0aGlzLnNhbXBsZXMgPSBbXTtcbiAgICBcdGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlX2NvdW50OyBpKyspIHtcbiAgICBcdFx0dmFyIHNhbXBsZSA9IHt9O1xuICAgIFx0XHQvLyB0ZW5jLmRlZmF1bHRfUGVyX1NhbXBsZV9JVl9TaXplIG9yIHNlaWcuUGVyX1NhbXBsZV9JVl9TaXplXG4gICAgXHRcdHNhbXBsZS5Jbml0aWFsaXphdGlvblZlY3RvciA9IHRoaXMucmVhZFVpbnQ4QXJyYXkoUGVyX1NhbXBsZV9JVl9TaXplKjgpO1xuICAgIFx0XHRpZiAodGhpcy5mbGFncyAmIDB4Mikge1xuICAgIFx0XHRcdHNhbXBsZS5zdWJzYW1wbGVzID0gW107XG4gICAgXHRcdFx0c3Vic2FtcGxlX2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICBcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHN1YnNhbXBsZV9jb3VudDsgaisrKSB7XG4gICAgXHRcdFx0XHR2YXIgc3Vic2FtcGxlID0ge307XG4gICAgXHRcdFx0XHRzdWJzYW1wbGUuQnl0ZXNPZkNsZWFyRGF0YSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgXHRcdFx0XHRzdWJzYW1wbGUuQnl0ZXNPZlByb3RlY3RlZERhdGEgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuICAgIFx0XHRcdFx0c2FtcGxlLnN1YnNhbXBsZXMucHVzaChzdWJzYW1wbGUpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0XHQvLyBUT0RPXG4gICAgXHRcdHRoaXMuc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG4gICAgXHR9XG4gICAgfSovXG4gICksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzZ3BkXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmdyb3VwaW5nX3R5cGUgPSB0LnJlYWRTdHJpbmcoNCksIHIuZGVidWcoXCJCb3hQYXJzZXJcIiwgXCJGb3VuZCBTYW1wbGUgR3JvdXBzIG9mIHR5cGUgXCIgKyB0aGlzLmdyb3VwaW5nX3R5cGUpLCB0aGlzLnZlcnNpb24gPT09IDEgPyB0aGlzLmRlZmF1bHRfbGVuZ3RoID0gdC5yZWFkVWludDMyKCkgOiB0aGlzLmRlZmF1bHRfbGVuZ3RoID0gMCwgdGhpcy52ZXJzaW9uID49IDIgJiYgKHRoaXMuZGVmYXVsdF9ncm91cF9kZXNjcmlwdGlvbl9pbmRleCA9IHQucmVhZFVpbnQzMigpKSwgdGhpcy5lbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgZSA9IHQucmVhZFVpbnQzMigpLCBpID0gMDsgaSA8IGU7IGkrKykge1xuICAgICAgdmFyIHM7XG4gICAgICBuW3RoaXMuZ3JvdXBpbmdfdHlwZSArIFwiU2FtcGxlR3JvdXBFbnRyeVwiXSA/IHMgPSBuZXcgblt0aGlzLmdyb3VwaW5nX3R5cGUgKyBcIlNhbXBsZUdyb3VwRW50cnlcIl0odGhpcy5ncm91cGluZ190eXBlKSA6IHMgPSBuZXcgbi5TYW1wbGVHcm91cEVudHJ5KHRoaXMuZ3JvdXBpbmdfdHlwZSksIHRoaXMuZW50cmllcy5wdXNoKHMpLCB0aGlzLnZlcnNpb24gPT09IDEgPyB0aGlzLmRlZmF1bHRfbGVuZ3RoID09PSAwID8gcy5kZXNjcmlwdGlvbl9sZW5ndGggPSB0LnJlYWRVaW50MzIoKSA6IHMuZGVzY3JpcHRpb25fbGVuZ3RoID0gdGhpcy5kZWZhdWx0X2xlbmd0aCA6IHMuZGVzY3JpcHRpb25fbGVuZ3RoID0gdGhpcy5kZWZhdWx0X2xlbmd0aCwgcy53cml0ZSA9PT0gbi5TYW1wbGVHcm91cEVudHJ5LnByb3RvdHlwZS53cml0ZSAmJiAoci5pbmZvKFwiQm94UGFyc2VyXCIsIFwiU2FtcGxlR3JvdXAgZm9yIHR5cGUgXCIgKyB0aGlzLmdyb3VwaW5nX3R5cGUgKyBcIiB3cml0aW5nIG5vdCB5ZXQgaW1wbGVtZW50ZWQsIGtlZXBpbmcgdW5wYXJzZWQgZGF0YSBpbiBtZW1vcnkgZm9yIGxhdGVyIHdyaXRlXCIpLCBzLmRhdGEgPSB0LnJlYWRVaW50OEFycmF5KHMuZGVzY3JpcHRpb25fbGVuZ3RoKSwgdC5wb3NpdGlvbiAtPSBzLmRlc2NyaXB0aW9uX2xlbmd0aCksIHMucGFyc2UodCk7XG4gICAgfVxuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInNpZHhcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucmVmZXJlbmNlX0lEID0gdC5yZWFkVWludDMyKCksIHRoaXMudGltZXNjYWxlID0gdC5yZWFkVWludDMyKCksIHRoaXMudmVyc2lvbiA9PT0gMCA/ICh0aGlzLmVhcmxpZXN0X3ByZXNlbnRhdGlvbl90aW1lID0gdC5yZWFkVWludDMyKCksIHRoaXMuZmlyc3Rfb2Zmc2V0ID0gdC5yZWFkVWludDMyKCkpIDogKHRoaXMuZWFybGllc3RfcHJlc2VudGF0aW9uX3RpbWUgPSB0LnJlYWRVaW50NjQoKSwgdGhpcy5maXJzdF9vZmZzZXQgPSB0LnJlYWRVaW50NjQoKSksIHQucmVhZFVpbnQxNigpLCB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcbiAgICBmb3IgKHZhciBlID0gdC5yZWFkVWludDE2KCksIGkgPSAwOyBpIDwgZTsgaSsrKSB7XG4gICAgICB2YXIgcyA9IHt9O1xuICAgICAgdGhpcy5yZWZlcmVuY2VzLnB1c2gocyk7XG4gICAgICB2YXIgbyA9IHQucmVhZFVpbnQzMigpO1xuICAgICAgcy5yZWZlcmVuY2VfdHlwZSA9IG8gPj4gMzEgJiAxLCBzLnJlZmVyZW5jZWRfc2l6ZSA9IG8gJiAyMTQ3NDgzNjQ3LCBzLnN1YnNlZ21lbnRfZHVyYXRpb24gPSB0LnJlYWRVaW50MzIoKSwgbyA9IHQucmVhZFVpbnQzMigpLCBzLnN0YXJ0c193aXRoX1NBUCA9IG8gPj4gMzEgJiAxLCBzLlNBUF90eXBlID0gbyA+PiAyOCAmIDcsIHMuU0FQX2RlbHRhX3RpbWUgPSBvICYgMjY4NDM1NDU1O1xuICAgIH1cbiAgfSksIG4uU2luZ2xlSXRlbVR5cGVSZWZlcmVuY2VCb3ggPSBmdW5jdGlvbih0LCBlLCBpLCBzKSB7XG4gICAgbi5Cb3guY2FsbCh0aGlzLCB0LCBlKSwgdGhpcy5oZHJfc2l6ZSA9IGksIHRoaXMuc3RhcnQgPSBzO1xuICB9LCBuLlNpbmdsZUl0ZW1UeXBlUmVmZXJlbmNlQm94LnByb3RvdHlwZSA9IG5ldyBuLkJveCgpLCBuLlNpbmdsZUl0ZW1UeXBlUmVmZXJlbmNlQm94LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmZyb21faXRlbV9JRCA9IHQucmVhZFVpbnQxNigpO1xuICAgIHZhciBlID0gdC5yZWFkVWludDE2KCk7XG4gICAgdGhpcy5yZWZlcmVuY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICB0aGlzLnJlZmVyZW5jZXNbaV0gPSB0LnJlYWRVaW50MTYoKTtcbiAgfSwgbi5TaW5nbGVJdGVtVHlwZVJlZmVyZW5jZUJveExhcmdlID0gZnVuY3Rpb24odCwgZSwgaSwgcykge1xuICAgIG4uQm94LmNhbGwodGhpcywgdCwgZSksIHRoaXMuaGRyX3NpemUgPSBpLCB0aGlzLnN0YXJ0ID0gcztcbiAgfSwgbi5TaW5nbGVJdGVtVHlwZVJlZmVyZW5jZUJveExhcmdlLnByb3RvdHlwZSA9IG5ldyBuLkJveCgpLCBuLlNpbmdsZUl0ZW1UeXBlUmVmZXJlbmNlQm94TGFyZ2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuZnJvbV9pdGVtX0lEID0gdC5yZWFkVWludDMyKCk7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50MTYoKTtcbiAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgIHRoaXMucmVmZXJlbmNlc1tpXSA9IHQucmVhZFVpbnQzMigpO1xuICB9LCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiU21EbVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wcmltYXJ5UkNocm9tYXRpY2l0eV94ID0gdC5yZWFkVWludDE2KCksIHRoaXMucHJpbWFyeVJDaHJvbWF0aWNpdHlfeSA9IHQucmVhZFVpbnQxNigpLCB0aGlzLnByaW1hcnlHQ2hyb21hdGljaXR5X3ggPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5wcmltYXJ5R0Nocm9tYXRpY2l0eV95ID0gdC5yZWFkVWludDE2KCksIHRoaXMucHJpbWFyeUJDaHJvbWF0aWNpdHlfeCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLnByaW1hcnlCQ2hyb21hdGljaXR5X3kgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy53aGl0ZVBvaW50Q2hyb21hdGljaXR5X3ggPSB0LnJlYWRVaW50MTYoKSwgdGhpcy53aGl0ZVBvaW50Q2hyb21hdGljaXR5X3kgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5sdW1pbmFuY2VNYXggPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5sdW1pbmFuY2VNaW4gPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzbWhkXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmJhbGFuY2UgPSB0LnJlYWRVaW50MTYoKSwgdC5yZWFkVWludDE2KCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3NpeFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zdWJzZWdtZW50cyA9IFtdO1xuICAgIGZvciAodmFyIGUgPSB0LnJlYWRVaW50MzIoKSwgaSA9IDA7IGkgPCBlOyBpKyspIHtcbiAgICAgIHZhciBzID0ge307XG4gICAgICB0aGlzLnN1YnNlZ21lbnRzLnB1c2gocyksIHMucmFuZ2VzID0gW107XG4gICAgICBmb3IgKHZhciBvID0gdC5yZWFkVWludDMyKCksIGMgPSAwOyBjIDwgbzsgYysrKSB7XG4gICAgICAgIHZhciB1ID0ge307XG4gICAgICAgIHMucmFuZ2VzLnB1c2godSksIHUubGV2ZWwgPSB0LnJlYWRVaW50OCgpLCB1LnJhbmdlX3NpemUgPSB0LnJlYWRVaW50MjQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3Rjb1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKGUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5jaHVua19vZmZzZXRzID0gW10sIHRoaXMudmVyc2lvbiA9PT0gMClcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgICAgICB0aGlzLmNodW5rX29mZnNldHMucHVzaCh0LnJlYWRVaW50MzIoKSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RkcFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSAodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSkgLyAyO1xuICAgIHRoaXMucHJpb3JpdHkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgIHRoaXMucHJpb3JpdHlbaV0gPSB0LnJlYWRVaW50MTYoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzdGhkXCIpLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RyaVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zd2l0Y2hfZ3JvdXAgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5hbHRlcm5hdGVfZ3JvdXAgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5zdWJfdHJhY2tfaWQgPSB0LnJlYWRVaW50MzIoKTtcbiAgICB2YXIgZSA9ICh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gOCkgLyA0O1xuICAgIHRoaXMuYXR0cmlidXRlX2xpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgIHRoaXMuYXR0cmlidXRlX2xpc3RbaV0gPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzdHNjXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaTtcbiAgICBpZiAoZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmZpcnN0X2NodW5rID0gW10sIHRoaXMuc2FtcGxlc19wZXJfY2h1bmsgPSBbXSwgdGhpcy5zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggPSBbXSwgdGhpcy52ZXJzaW9uID09PSAwKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgICAgdGhpcy5maXJzdF9jaHVuay5wdXNoKHQucmVhZFVpbnQzMigpKSwgdGhpcy5zYW1wbGVzX3Blcl9jaHVuay5wdXNoKHQucmVhZFVpbnQzMigpKSwgdGhpcy5zYW1wbGVfZGVzY3JpcHRpb25faW5kZXgucHVzaCh0LnJlYWRVaW50MzIoKSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RzZFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGksIHMsIG87XG4gICAgZm9yICh0aGlzLmVudHJpZXMgPSBbXSwgcyA9IHQucmVhZFVpbnQzMigpLCBlID0gMTsgZSA8PSBzOyBlKyspXG4gICAgICBpZiAoaSA9IG4ucGFyc2VPbmVCb3godCwgITAsIHRoaXMuc2l6ZSAtICh0LmdldFBvc2l0aW9uKCkgLSB0aGlzLnN0YXJ0KSksIGkuY29kZSA9PT0gbi5PSylcbiAgICAgICAgbltpLnR5cGUgKyBcIlNhbXBsZUVudHJ5XCJdID8gKG8gPSBuZXcgbltpLnR5cGUgKyBcIlNhbXBsZUVudHJ5XCJdKGkuc2l6ZSksIG8uaGRyX3NpemUgPSBpLmhkcl9zaXplLCBvLnN0YXJ0ID0gaS5zdGFydCkgOiAoci53YXJuKFwiQm94UGFyc2VyXCIsIFwiVW5rbm93biBzYW1wbGUgZW50cnkgdHlwZTogXCIgKyBpLnR5cGUpLCBvID0gbmV3IG4uU2FtcGxlRW50cnkoaS50eXBlLCBpLnNpemUsIGkuaGRyX3NpemUsIGkuc3RhcnQpKSwgby53cml0ZSA9PT0gbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUud3JpdGUgJiYgKHIuaW5mbyhcIkJveFBhcnNlclwiLCBcIlNhbXBsZUVudHJ5IFwiICsgby50eXBlICsgXCIgYm94IHdyaXRpbmcgbm90IHlldCBpbXBsZW1lbnRlZCwga2VlcGluZyB1bnBhcnNlZCBkYXRhIGluIG1lbW9yeSBmb3IgbGF0ZXIgd3JpdGVcIiksIG8ucGFyc2VEYXRhQW5kUmV3aW5kKHQpKSwgby5wYXJzZSh0KSwgdGhpcy5lbnRyaWVzLnB1c2gobyk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzdHNnXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmdyb3VwaW5nX3R5cGUgPSB0LnJlYWRVaW50MzIoKTtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQxNigpO1xuICAgIHRoaXMuZ3JvdXBfZGVzY3JpcHRpb25faW5kZXggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgIHRoaXMuZ3JvdXBfZGVzY3JpcHRpb25faW5kZXhbaV0gPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzdHNoXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaTtcbiAgICBpZiAoZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnNoYWRvd2VkX3NhbXBsZV9udW1iZXJzID0gW10sIHRoaXMuc3luY19zYW1wbGVfbnVtYmVycyA9IFtdLCB0aGlzLnZlcnNpb24gPT09IDApXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgICAgICB0aGlzLnNoYWRvd2VkX3NhbXBsZV9udW1iZXJzLnB1c2godC5yZWFkVWludDMyKCkpLCB0aGlzLnN5bmNfc2FtcGxlX251bWJlcnMucHVzaCh0LnJlYWRVaW50MzIoKSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3Rzc1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGk7XG4gICAgaWYgKGkgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy52ZXJzaW9uID09PSAwKVxuICAgICAgZm9yICh0aGlzLnNhbXBsZV9udW1iZXJzID0gW10sIGUgPSAwOyBlIDwgaTsgZSsrKVxuICAgICAgICB0aGlzLnNhbXBsZV9udW1iZXJzLnB1c2godC5yZWFkVWludDMyKCkpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInN0c3pcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIGlmICh0aGlzLnNhbXBsZV9zaXplcyA9IFtdLCB0aGlzLnZlcnNpb24gPT09IDApXG4gICAgICBmb3IgKHRoaXMuc2FtcGxlX3NpemUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5zYW1wbGVfY291bnQgPSB0LnJlYWRVaW50MzIoKSwgZSA9IDA7IGUgPCB0aGlzLnNhbXBsZV9jb3VudDsgZSsrKVxuICAgICAgICB0aGlzLnNhbXBsZV9zaXplID09PSAwID8gdGhpcy5zYW1wbGVfc2l6ZXMucHVzaCh0LnJlYWRVaW50MzIoKSkgOiB0aGlzLnNhbXBsZV9zaXplc1tlXSA9IHRoaXMuc2FtcGxlX3NpemU7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3R0c1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGksIHM7XG4gICAgaWYgKGUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5zYW1wbGVfY291bnRzID0gW10sIHRoaXMuc2FtcGxlX2RlbHRhcyA9IFtdLCB0aGlzLnZlcnNpb24gPT09IDApXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgICAgICB0aGlzLnNhbXBsZV9jb3VudHMucHVzaCh0LnJlYWRVaW50MzIoKSksIHMgPSB0LnJlYWRJbnQzMigpLCBzIDwgMCAmJiAoci53YXJuKFwiQm94UGFyc2VyXCIsIFwiRmlsZSB1c2VzIG5lZ2F0aXZlIHN0dHMgc2FtcGxlIGRlbHRhLCB1c2luZyB2YWx1ZSAxIGluc3RlYWQsIHN5bmMgbWF5IGJlIGxvc3QhXCIpLCBzID0gMSksIHRoaXMuc2FtcGxlX2RlbHRhcy5wdXNoKHMpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInN0dmlcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5yZWFkVWludDMyKCk7XG4gICAgdGhpcy5zaW5nbGVfdmlld19hbGxvd2VkID0gZSAmIDMsIHRoaXMuc3RlcmVvX3NjaGVtZSA9IHQucmVhZFVpbnQzMigpO1xuICAgIHZhciBpID0gdC5yZWFkVWludDMyKCk7XG4gICAgdGhpcy5zdGVyZW9faW5kaWNhdGlvbl90eXBlID0gdC5yZWFkU3RyaW5nKGkpO1xuICAgIHZhciBzLCBvO1xuICAgIGZvciAodGhpcy5ib3hlcyA9IFtdOyB0LmdldFBvc2l0aW9uKCkgPCB0aGlzLnN0YXJ0ICsgdGhpcy5zaXplOyApXG4gICAgICBpZiAocyA9IG4ucGFyc2VPbmVCb3godCwgITEsIHRoaXMuc2l6ZSAtICh0LmdldFBvc2l0aW9uKCkgLSB0aGlzLnN0YXJ0KSksIHMuY29kZSA9PT0gbi5PSylcbiAgICAgICAgbyA9IHMuYm94LCB0aGlzLmJveGVzLnB1c2gobyksIHRoaXNbby50eXBlXSA9IG87XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInN0eXBcIiwgZnVuY3Rpb24odCkge1xuICAgIG4uZnR5cEJveC5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCB0KTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzdHoyXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaTtcbiAgICBpZiAodGhpcy5zYW1wbGVfc2l6ZXMgPSBbXSwgdGhpcy52ZXJzaW9uID09PSAwKVxuICAgICAgaWYgKHRoaXMucmVzZXJ2ZWQgPSB0LnJlYWRVaW50MjQoKSwgdGhpcy5maWVsZF9zaXplID0gdC5yZWFkVWludDgoKSwgaSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmZpZWxkX3NpemUgPT09IDQpXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCBpOyBlICs9IDIpIHtcbiAgICAgICAgICB2YXIgcyA9IHQucmVhZFVpbnQ4KCk7XG4gICAgICAgICAgdGhpcy5zYW1wbGVfc2l6ZXNbZV0gPSBzID4+IDQgJiAxNSwgdGhpcy5zYW1wbGVfc2l6ZXNbZSArIDFdID0gcyAmIDE1O1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLmZpZWxkX3NpemUgPT09IDgpXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCBpOyBlKyspXG4gICAgICAgICAgdGhpcy5zYW1wbGVfc2l6ZXNbZV0gPSB0LnJlYWRVaW50OCgpO1xuICAgICAgZWxzZSBpZiAodGhpcy5maWVsZF9zaXplID09PSAxNilcbiAgICAgICAgZm9yIChlID0gMDsgZSA8IGk7IGUrKylcbiAgICAgICAgICB0aGlzLnNhbXBsZV9zaXplc1tlXSA9IHQucmVhZFVpbnQxNigpO1xuICAgICAgZWxzZVxuICAgICAgICByLmVycm9yKFwiQm94UGFyc2VyXCIsIFwiRXJyb3IgaW4gbGVuZ3RoIGZpZWxkIGluIHN0ejIgYm94XCIpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInN1YnNcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpLCBzLCBvO1xuICAgIGZvciAocyA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmVudHJpZXMgPSBbXSwgZSA9IDA7IGUgPCBzOyBlKyspIHtcbiAgICAgIHZhciBjID0ge307XG4gICAgICBpZiAodGhpcy5lbnRyaWVzW2VdID0gYywgYy5zYW1wbGVfZGVsdGEgPSB0LnJlYWRVaW50MzIoKSwgYy5zdWJzYW1wbGVzID0gW10sIG8gPSB0LnJlYWRVaW50MTYoKSwgbyA+IDApXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvOyBpKyspIHtcbiAgICAgICAgICB2YXIgdSA9IHt9O1xuICAgICAgICAgIGMuc3Vic2FtcGxlcy5wdXNoKHUpLCB0aGlzLnZlcnNpb24gPT0gMSA/IHUuc2l6ZSA9IHQucmVhZFVpbnQzMigpIDogdS5zaXplID0gdC5yZWFkVWludDE2KCksIHUucHJpb3JpdHkgPSB0LnJlYWRVaW50OCgpLCB1LmRpc2NhcmRhYmxlID0gdC5yZWFkVWludDgoKSwgdS5jb2RlY19zcGVjaWZpY19wYXJhbWV0ZXJzID0gdC5yZWFkVWludDMyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidGVuY1wiLCBmdW5jdGlvbih0KSB7XG4gICAgaWYgKHQucmVhZFVpbnQ4KCksIHRoaXMudmVyc2lvbiA9PT0gMClcbiAgICAgIHQucmVhZFVpbnQ4KCk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgICB0aGlzLmRlZmF1bHRfY3J5cHRfYnl0ZV9ibG9jayA9IGUgPj4gNCAmIDE1LCB0aGlzLmRlZmF1bHRfc2tpcF9ieXRlX2Jsb2NrID0gZSAmIDE1O1xuICAgIH1cbiAgICB0aGlzLmRlZmF1bHRfaXNQcm90ZWN0ZWQgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmRlZmF1bHRfUGVyX1NhbXBsZV9JVl9TaXplID0gdC5yZWFkVWludDgoKSwgdGhpcy5kZWZhdWx0X0tJRCA9IG4ucGFyc2VIZXgxNih0KSwgdGhpcy5kZWZhdWx0X2lzUHJvdGVjdGVkID09PSAxICYmIHRoaXMuZGVmYXVsdF9QZXJfU2FtcGxlX0lWX1NpemUgPT09IDAgJiYgKHRoaXMuZGVmYXVsdF9jb25zdGFudF9JVl9zaXplID0gdC5yZWFkVWludDgoKSwgdGhpcy5kZWZhdWx0X2NvbnN0YW50X0lWID0gdC5yZWFkVWludDhBcnJheSh0aGlzLmRlZmF1bHRfY29uc3RhbnRfSVZfc2l6ZSkpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInRmZHRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9PSAxID8gdGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lID0gdC5yZWFkVWludDY0KCkgOiB0aGlzLmJhc2VNZWRpYURlY29kZVRpbWUgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ0ZmhkXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IDA7XG4gICAgdGhpcy50cmFja19pZCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplID4gZSAmJiB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfQkFTRV9EQVRBX09GRlNFVCA/ICh0aGlzLmJhc2VfZGF0YV9vZmZzZXQgPSB0LnJlYWRVaW50NjQoKSwgZSArPSA4KSA6IHRoaXMuYmFzZV9kYXRhX29mZnNldCA9IDAsIHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgPiBlICYmIHRoaXMuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfREVTQyA/ICh0aGlzLmRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4ID0gdC5yZWFkVWludDMyKCksIGUgKz0gNCkgOiB0aGlzLmRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4ID0gMCwgdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSA+IGUgJiYgdGhpcy5mbGFncyAmIG4uVEZIRF9GTEFHX1NBTVBMRV9EVVIgPyAodGhpcy5kZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiA9IHQucmVhZFVpbnQzMigpLCBlICs9IDQpIDogdGhpcy5kZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiA9IDAsIHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgPiBlICYmIHRoaXMuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfU0laRSA/ICh0aGlzLmRlZmF1bHRfc2FtcGxlX3NpemUgPSB0LnJlYWRVaW50MzIoKSwgZSArPSA0KSA6IHRoaXMuZGVmYXVsdF9zYW1wbGVfc2l6ZSA9IDAsIHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgPiBlICYmIHRoaXMuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfRkxBR1MgPyAodGhpcy5kZWZhdWx0X3NhbXBsZV9mbGFncyA9IHQucmVhZFVpbnQzMigpLCBlICs9IDQpIDogdGhpcy5kZWZhdWx0X3NhbXBsZV9mbGFncyA9IDA7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidGZyYVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50cmFja19JRCA9IHQucmVhZFVpbnQzMigpLCB0LnJlYWRVaW50MjQoKTtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5sZW5ndGhfc2l6ZV9vZl90cmFmX251bSA9IGUgPj4gNCAmIDMsIHRoaXMubGVuZ3RoX3NpemVfb2ZfdHJ1bl9udW0gPSBlID4+IDIgJiAzLCB0aGlzLmxlbmd0aF9zaXplX29mX3NhbXBsZV9udW0gPSBlICYgMywgdGhpcy5lbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IHQucmVhZFVpbnQzMigpLCBzID0gMDsgcyA8IGk7IHMrKylcbiAgICAgIHRoaXMudmVyc2lvbiA9PT0gMSA/ICh0aGlzLnRpbWUgPSB0LnJlYWRVaW50NjQoKSwgdGhpcy5tb29mX29mZnNldCA9IHQucmVhZFVpbnQ2NCgpKSA6ICh0aGlzLnRpbWUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5tb29mX29mZnNldCA9IHQucmVhZFVpbnQzMigpKSwgdGhpcy50cmFmX251bWJlciA9IHRbXCJyZWFkVWludFwiICsgOCAqICh0aGlzLmxlbmd0aF9zaXplX29mX3RyYWZfbnVtICsgMSldKCksIHRoaXMudHJ1bl9udW1iZXIgPSB0W1wicmVhZFVpbnRcIiArIDggKiAodGhpcy5sZW5ndGhfc2l6ZV9vZl90cnVuX251bSArIDEpXSgpLCB0aGlzLnNhbXBsZV9udW1iZXIgPSB0W1wicmVhZFVpbnRcIiArIDggKiAodGhpcy5sZW5ndGhfc2l6ZV9vZl9zYW1wbGVfbnVtICsgMSldKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidGtoZFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID09IDEgPyAodGhpcy5jcmVhdGlvbl90aW1lID0gdC5yZWFkVWludDY0KCksIHRoaXMubW9kaWZpY2F0aW9uX3RpbWUgPSB0LnJlYWRVaW50NjQoKSwgdGhpcy50cmFja19pZCA9IHQucmVhZFVpbnQzMigpLCB0LnJlYWRVaW50MzIoKSwgdGhpcy5kdXJhdGlvbiA9IHQucmVhZFVpbnQ2NCgpKSA6ICh0aGlzLmNyZWF0aW9uX3RpbWUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5tb2RpZmljYXRpb25fdGltZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnRyYWNrX2lkID0gdC5yZWFkVWludDMyKCksIHQucmVhZFVpbnQzMigpLCB0aGlzLmR1cmF0aW9uID0gdC5yZWFkVWludDMyKCkpLCB0LnJlYWRVaW50MzJBcnJheSgyKSwgdGhpcy5sYXllciA9IHQucmVhZEludDE2KCksIHRoaXMuYWx0ZXJuYXRlX2dyb3VwID0gdC5yZWFkSW50MTYoKSwgdGhpcy52b2x1bWUgPSB0LnJlYWRJbnQxNigpID4+IDgsIHQucmVhZFVpbnQxNigpLCB0aGlzLm1hdHJpeCA9IHQucmVhZEludDMyQXJyYXkoOSksIHRoaXMud2lkdGggPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5oZWlnaHQgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInRtYXhcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGltZSA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwidG1pblwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50aW1lID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJ0b3RsXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmJ5dGVzc2VudCA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwidHBheVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5ieXRlc3NlbnQgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInRweWxcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuYnl0ZXNzZW50ID0gdC5yZWFkVWludDY0KCk7XG4gIH0pLCBuLlRyYWNrR3JvdXBUeXBlQm94LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlRnVsbEhlYWRlcih0KSwgdGhpcy50cmFja19ncm91cF9pZCA9IHQucmVhZFVpbnQzMigpO1xuICB9LCBuLmNyZWF0ZVRyYWNrR3JvdXBDdG9yKFwibXNyY1wiKSwgbi5UcmFja1JlZmVyZW5jZVR5cGVCb3ggPSBmdW5jdGlvbih0LCBlLCBpLCBzKSB7XG4gICAgbi5Cb3guY2FsbCh0aGlzLCB0LCBlKSwgdGhpcy5oZHJfc2l6ZSA9IGksIHRoaXMuc3RhcnQgPSBzO1xuICB9LCBuLlRyYWNrUmVmZXJlbmNlVHlwZUJveC5wcm90b3R5cGUgPSBuZXcgbi5Cb3goKSwgbi5UcmFja1JlZmVyZW5jZVR5cGVCb3gucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudHJhY2tfaWRzID0gdC5yZWFkVWludDMyQXJyYXkoKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpIC8gNCk7XG4gIH0sIG4udHJlZkJveC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSwgaTsgdC5nZXRQb3NpdGlvbigpIDwgdGhpcy5zdGFydCArIHRoaXMuc2l6ZTsgKVxuICAgICAgaWYgKGUgPSBuLnBhcnNlT25lQm94KHQsICEwLCB0aGlzLnNpemUgLSAodC5nZXRQb3NpdGlvbigpIC0gdGhpcy5zdGFydCkpLCBlLmNvZGUgPT09IG4uT0spXG4gICAgICAgIGkgPSBuZXcgbi5UcmFja1JlZmVyZW5jZVR5cGVCb3goZS50eXBlLCBlLnNpemUsIGUuaGRyX3NpemUsIGUuc3RhcnQpLCBpLndyaXRlID09PSBuLkJveC5wcm90b3R5cGUud3JpdGUgJiYgaS50eXBlICE9PSBcIm1kYXRcIiAmJiAoci5pbmZvKFwiQm94UGFyc2VyXCIsIFwiVHJhY2tSZWZlcmVuY2UgXCIgKyBpLnR5cGUgKyBcIiBib3ggd3JpdGluZyBub3QgeWV0IGltcGxlbWVudGVkLCBrZWVwaW5nIHVucGFyc2VkIGRhdGEgaW4gbWVtb3J5IGZvciBsYXRlciB3cml0ZVwiKSwgaS5wYXJzZURhdGFBbmRSZXdpbmQodCkpLCBpLnBhcnNlKHQpLCB0aGlzLmJveGVzLnB1c2goaSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgfSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInRyZXBcIiwgZnVuY3Rpb24odCkge1xuICAgIGZvciAodGhpcy50cmFja19JRCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmJveGVzID0gW107IHQuZ2V0UG9zaXRpb24oKSA8IHRoaXMuc3RhcnQgKyB0aGlzLnNpemU7IClcbiAgICAgIGlmIChyZXQgPSBuLnBhcnNlT25lQm94KHQsICExLCB0aGlzLnNpemUgLSAodC5nZXRQb3NpdGlvbigpIC0gdGhpcy5zdGFydCkpLCByZXQuY29kZSA9PT0gbi5PSylcbiAgICAgICAgYm94ID0gcmV0LmJveCwgdGhpcy5ib3hlcy5wdXNoKGJveCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ0cmV4XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRyYWNrX2lkID0gdC5yZWFkVWludDMyKCksIHRoaXMuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5kZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmRlZmF1bHRfc2FtcGxlX3NpemUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5kZWZhdWx0X3NhbXBsZV9mbGFncyA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwidHJweVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5ieXRlc3NlbnQgPSB0LnJlYWRVaW50NjQoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ0cnVuXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IDA7XG4gICAgaWYgKHRoaXMuc2FtcGxlX2NvdW50ID0gdC5yZWFkVWludDMyKCksIGUgKz0gNCwgdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSA+IGUgJiYgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19EQVRBX09GRlNFVCA/ICh0aGlzLmRhdGFfb2Zmc2V0ID0gdC5yZWFkSW50MzIoKSwgZSArPSA0KSA6IHRoaXMuZGF0YV9vZmZzZXQgPSAwLCB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplID4gZSAmJiB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX0ZJUlNUX0ZMQUcgPyAodGhpcy5maXJzdF9zYW1wbGVfZmxhZ3MgPSB0LnJlYWRVaW50MzIoKSwgZSArPSA0KSA6IHRoaXMuZmlyc3Rfc2FtcGxlX2ZsYWdzID0gMCwgdGhpcy5zYW1wbGVfZHVyYXRpb24gPSBbXSwgdGhpcy5zYW1wbGVfc2l6ZSA9IFtdLCB0aGlzLnNhbXBsZV9mbGFncyA9IFtdLCB0aGlzLnNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldCA9IFtdLCB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplID4gZSlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zYW1wbGVfY291bnQ7IGkrKylcbiAgICAgICAgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19EVVJBVElPTiAmJiAodGhpcy5zYW1wbGVfZHVyYXRpb25baV0gPSB0LnJlYWRVaW50MzIoKSksIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfU0laRSAmJiAodGhpcy5zYW1wbGVfc2l6ZVtpXSA9IHQucmVhZFVpbnQzMigpKSwgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19GTEFHUyAmJiAodGhpcy5zYW1wbGVfZmxhZ3NbaV0gPSB0LnJlYWRVaW50MzIoKSksIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfQ1RTX09GRlNFVCAmJiAodGhpcy52ZXJzaW9uID09PSAwID8gdGhpcy5zYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRbaV0gPSB0LnJlYWRVaW50MzIoKSA6IHRoaXMuc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0W2ldID0gdC5yZWFkSW50MzIoKSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidHNlbFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zd2l0Y2hfZ3JvdXAgPSB0LnJlYWRVaW50MzIoKTtcbiAgICB2YXIgZSA9ICh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gNCkgLyA0O1xuICAgIHRoaXMuYXR0cmlidXRlX2xpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgIHRoaXMuYXR0cmlidXRlX2xpc3RbaV0gPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ0eHRDXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHQucmVhZENTdHJpbmcoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ1cmwgXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmZsYWdzICE9PSAxICYmICh0aGlzLmxvY2F0aW9uID0gdC5yZWFkQ1N0cmluZygpKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ1cm4gXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLm5hbWUgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgLSB0aGlzLm5hbWUubGVuZ3RoIC0gMSA+IDAgJiYgKHRoaXMubG9jYXRpb24gPSB0LnJlYWRDU3RyaW5nKCkpO1xuICB9KSwgbi5jcmVhdGVVVUlEQm94KFwiYTVkNDBiMzBlODE0MTFkZGJhMmYwODAwMjAwYzlhNjZcIiwgITAsICExLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5MaXZlU2VydmVyTWFuaWZlc3QgPSB0LnJlYWRTdHJpbmcodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSkucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpLnJlcGxhY2UoLycvZywgXCImIzAzOTtcIik7XG4gIH0pLCBuLmNyZWF0ZVVVSURCb3goXCJkMDhhNGYxODEwZjM0YTgyYjZjODMyZDhhYmExODNkM1wiLCAhMCwgITEsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnN5c3RlbV9pZCA9IG4ucGFyc2VIZXgxNih0KTtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQzMigpO1xuICAgIGUgPiAwICYmICh0aGlzLmRhdGEgPSB0LnJlYWRVaW50OEFycmF5KGUpKTtcbiAgfSksIG4uY3JlYXRlVVVJREJveChcbiAgICBcImEyMzk0ZjUyNWE5YjRmMTRhMjQ0NmM0MjdjNjQ4ZGY0XCIsXG4gICAgITAsXG4gICAgITFcbiAgICAvKiwgZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgXHRpZiAodGhpcy5mbGFncyAmIDB4MSkge1xuICAgIFx0XHR0aGlzLkFsZ29yaXRobUlEID0gc3RyZWFtLnJlYWRVaW50MjQoKTtcbiAgICBcdFx0dGhpcy5JVl9zaXplID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuICAgIFx0XHR0aGlzLktJRCA9IEJveFBhcnNlci5wYXJzZUhleDE2KHN0cmVhbSk7XG4gICAgXHR9XG4gICAgXHR2YXIgc2FtcGxlX2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICBcdHRoaXMuc2FtcGxlcyA9IFtdO1xuICAgIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVfY291bnQ7IGkrKykge1xuICAgIFx0XHR2YXIgc2FtcGxlID0ge307XG4gICAgXHRcdHNhbXBsZS5Jbml0aWFsaXphdGlvblZlY3RvciA9IHRoaXMucmVhZFVpbnQ4QXJyYXkodGhpcy5JVl9zaXplKjgpO1xuICAgIFx0XHRpZiAodGhpcy5mbGFncyAmIDB4Mikge1xuICAgIFx0XHRcdHNhbXBsZS5zdWJzYW1wbGVzID0gW107XG4gICAgXHRcdFx0c2FtcGxlLk51bWJlck9mRW50cmllcyA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzYW1wbGUuTnVtYmVyT2ZFbnRyaWVzOyBqKyspIHtcbiAgICBcdFx0XHRcdHZhciBzdWJzYW1wbGUgPSB7fTtcbiAgICBcdFx0XHRcdHN1YnNhbXBsZS5CeXRlc09mQ2xlYXJEYXRhID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICBcdFx0XHRcdHN1YnNhbXBsZS5CeXRlc09mUHJvdGVjdGVkRGF0YSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG4gICAgXHRcdFx0XHRzYW1wbGUuc3Vic2FtcGxlcy5wdXNoKHN1YnNhbXBsZSk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHRcdHRoaXMuc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG4gICAgXHR9XG4gICAgfSovXG4gICksIG4uY3JlYXRlVVVJREJveChcIjg5NzRkYmNlN2JlNzRjNTE4NGY5NzE0OGY5ODgyNTU0XCIsICEwLCAhMSwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuZGVmYXVsdF9BbGdvcml0aG1JRCA9IHQucmVhZFVpbnQyNCgpLCB0aGlzLmRlZmF1bHRfSVZfc2l6ZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuZGVmYXVsdF9LSUQgPSBuLnBhcnNlSGV4MTYodCk7XG4gIH0pLCBuLmNyZWF0ZVVVSURCb3goXCJkNDgwN2VmMmNhMzk0Njk1OGU1NDI2Y2I5ZTQ2YTc5ZlwiLCAhMCwgITEsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmZyYWdtZW50X2NvdW50ID0gdC5yZWFkVWludDgoKSwgdGhpcy5lbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmZyYWdtZW50X2NvdW50OyBlKyspIHtcbiAgICAgIHZhciBpID0ge30sIHMgPSAwLCBvID0gMDtcbiAgICAgIHRoaXMudmVyc2lvbiA9PT0gMSA/IChzID0gdC5yZWFkVWludDY0KCksIG8gPSB0LnJlYWRVaW50NjQoKSkgOiAocyA9IHQucmVhZFVpbnQzMigpLCBvID0gdC5yZWFkVWludDMyKCkpLCBpLmFic29sdXRlX3RpbWUgPSBzLCBpLmFic29sdXRlX2R1cmF0aW9uID0gbywgdGhpcy5lbnRyaWVzLnB1c2goaSk7XG4gICAgfVxuICB9KSwgbi5jcmVhdGVVVUlEQm94KFwiNmQxZDliMDU0MmQ1NDRlNjgwZTIxNDFkYWZmNzU3YjJcIiwgITAsICExLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID09PSAxID8gKHRoaXMuYWJzb2x1dGVfdGltZSA9IHQucmVhZFVpbnQ2NCgpLCB0aGlzLmR1cmF0aW9uID0gdC5yZWFkVWludDY0KCkpIDogKHRoaXMuYWJzb2x1dGVfdGltZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmR1cmF0aW9uID0gdC5yZWFkVWludDMyKCkpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInZtaGRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuZ3JhcGhpY3Ntb2RlID0gdC5yZWFkVWludDE2KCksIHRoaXMub3Bjb2xvciA9IHQucmVhZFVpbnQxNkFycmF5KDMpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInZwY0NcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMudmVyc2lvbiA9PT0gMSA/ICh0aGlzLnByb2ZpbGUgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmxldmVsID0gdC5yZWFkVWludDgoKSwgZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuYml0RGVwdGggPSBlID4+IDQsIHRoaXMuY2hyb21hU3Vic2FtcGxpbmcgPSBlID4+IDEgJiA3LCB0aGlzLnZpZGVvRnVsbFJhbmdlRmxhZyA9IGUgJiAxLCB0aGlzLmNvbG91clByaW1hcmllcyA9IHQucmVhZFVpbnQ4KCksIHRoaXMudHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MgPSB0LnJlYWRVaW50OCgpLCB0aGlzLm1hdHJpeENvZWZmaWNpZW50cyA9IHQucmVhZFVpbnQ4KCksIHRoaXMuY29kZWNJbnRpYWxpemF0aW9uRGF0YVNpemUgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5jb2RlY0ludGlhbGl6YXRpb25EYXRhID0gdC5yZWFkVWludDhBcnJheSh0aGlzLmNvZGVjSW50aWFsaXphdGlvbkRhdGFTaXplKSkgOiAodGhpcy5wcm9maWxlID0gdC5yZWFkVWludDgoKSwgdGhpcy5sZXZlbCA9IHQucmVhZFVpbnQ4KCksIGUgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmJpdERlcHRoID0gZSA+PiA0ICYgMTUsIHRoaXMuY29sb3JTcGFjZSA9IGUgJiAxNSwgZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuY2hyb21hU3Vic2FtcGxpbmcgPSBlID4+IDQgJiAxNSwgdGhpcy50cmFuc2ZlckZ1bmN0aW9uID0gZSA+PiAxICYgNywgdGhpcy52aWRlb0Z1bGxSYW5nZUZsYWcgPSBlICYgMSwgdGhpcy5jb2RlY0ludGlhbGl6YXRpb25EYXRhU2l6ZSA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmNvZGVjSW50aWFsaXphdGlvbkRhdGEgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuY29kZWNJbnRpYWxpemF0aW9uRGF0YVNpemUpKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInZ0dENcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGV4dCA9IHQucmVhZFN0cmluZyh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ2dmNDXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSwgcyA9IHtcbiAgICAgIGhlbGRfYml0czogdm9pZCAwLFxuICAgICAgbnVtX2hlbGRfYml0czogMCxcbiAgICAgIHN0cmVhbV9yZWFkXzFfYnl0ZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdGhpcy5oZWxkX2JpdHMgPSB4LnJlYWRVaW50OCgpLCB0aGlzLm51bV9oZWxkX2JpdHMgPSA4O1xuICAgICAgfSxcbiAgICAgIHN0cmVhbV9yZWFkXzJfYnl0ZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdGhpcy5oZWxkX2JpdHMgPSB4LnJlYWRVaW50MTYoKSwgdGhpcy5udW1faGVsZF9iaXRzID0gMTY7XG4gICAgICB9LFxuICAgICAgZXh0cmFjdF9iaXRzOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBQID0gdGhpcy5oZWxkX2JpdHMgPj4gdGhpcy5udW1faGVsZF9iaXRzIC0geCAmICgxIDw8IHgpIC0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtX2hlbGRfYml0cyAtPSB4LCBQO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHMuc3RyZWFtX3JlYWRfMV9ieXRlcyh0KSwgcy5leHRyYWN0X2JpdHMoNSksIHRoaXMubGVuZ3RoU2l6ZU1pbnVzT25lID0gcy5leHRyYWN0X2JpdHMoMiksIHRoaXMucHRsX3ByZXNlbnRfZmxhZyA9IHMuZXh0cmFjdF9iaXRzKDEpLCB0aGlzLnB0bF9wcmVzZW50X2ZsYWcpIHtcbiAgICAgIHMuc3RyZWFtX3JlYWRfMl9ieXRlcyh0KSwgdGhpcy5vbHNfaWR4ID0gcy5leHRyYWN0X2JpdHMoOSksIHRoaXMubnVtX3N1YmxheWVycyA9IHMuZXh0cmFjdF9iaXRzKDMpLCB0aGlzLmNvbnN0YW50X2ZyYW1lX3JhdGUgPSBzLmV4dHJhY3RfYml0cygyKSwgdGhpcy5jaHJvbWFfZm9ybWF0X2lkYyA9IHMuZXh0cmFjdF9iaXRzKDIpLCBzLnN0cmVhbV9yZWFkXzFfYnl0ZXModCksIHRoaXMuYml0X2RlcHRoX21pbnVzOCA9IHMuZXh0cmFjdF9iaXRzKDMpLCBzLmV4dHJhY3RfYml0cyg1KTtcbiAgICAgIHtcbiAgICAgICAgaWYgKHMuc3RyZWFtX3JlYWRfMl9ieXRlcyh0KSwgcy5leHRyYWN0X2JpdHMoMiksIHRoaXMubnVtX2J5dGVzX2NvbnN0cmFpbnRfaW5mbyA9IHMuZXh0cmFjdF9iaXRzKDYpLCB0aGlzLmdlbmVyYWxfcHJvZmlsZV9pZGMgPSBzLmV4dHJhY3RfYml0cyg3KSwgdGhpcy5nZW5lcmFsX3RpZXJfZmxhZyA9IHMuZXh0cmFjdF9iaXRzKDEpLCB0aGlzLmdlbmVyYWxfbGV2ZWxfaWRjID0gdC5yZWFkVWludDgoKSwgcy5zdHJlYW1fcmVhZF8xX2J5dGVzKHQpLCB0aGlzLnB0bF9mcmFtZV9vbmx5X2NvbnN0cmFpbnRfZmxhZyA9IHMuZXh0cmFjdF9iaXRzKDEpLCB0aGlzLnB0bF9tdWx0aWxheWVyX2VuYWJsZWRfZmxhZyA9IHMuZXh0cmFjdF9iaXRzKDEpLCB0aGlzLmdlbmVyYWxfY29uc3RyYWludF9pbmZvID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5udW1fYnl0ZXNfY29uc3RyYWludF9pbmZvKSwgdGhpcy5udW1fYnl0ZXNfY29uc3RyYWludF9pbmZvKSB7XG4gICAgICAgICAgZm9yIChlID0gMDsgZSA8IHRoaXMubnVtX2J5dGVzX2NvbnN0cmFpbnRfaW5mbyAtIDE7IGUrKykge1xuICAgICAgICAgICAgdmFyIG8gPSBzLmV4dHJhY3RfYml0cyg2KTtcbiAgICAgICAgICAgIHMuc3RyZWFtX3JlYWRfMV9ieXRlcyh0KTtcbiAgICAgICAgICAgIHZhciBjID0gcy5leHRyYWN0X2JpdHMoMik7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYWxfY29uc3RyYWludF9pbmZvW2VdID0gbyA8PCAyIHwgYztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5nZW5lcmFsX2NvbnN0cmFpbnRfaW5mb1t0aGlzLm51bV9ieXRlc19jb25zdHJhaW50X2luZm8gLSAxXSA9IHMuZXh0cmFjdF9iaXRzKDYpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBzLmV4dHJhY3RfYml0cyg2KTtcbiAgICAgICAgZm9yIChzLnN0cmVhbV9yZWFkXzFfYnl0ZXModCksIHRoaXMucHRsX3N1YmxheWVyX3ByZXNlbnRfbWFzayA9IDAsIGkgPSB0aGlzLm51bV9zdWJsYXllcnMgLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIHZhciB1ID0gcy5leHRyYWN0X2JpdHMoMSk7XG4gICAgICAgICAgdGhpcy5wdGxfc3VibGF5ZXJfcHJlc2VudF9tYXNrIHw9IHUgPDwgaTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSB0aGlzLm51bV9zdWJsYXllcnM7IGkgPD0gOCAmJiB0aGlzLm51bV9zdWJsYXllcnMgPiAxOyArK2kpXG4gICAgICAgICAgcy5leHRyYWN0X2JpdHMoMSk7XG4gICAgICAgIGZvciAoaSA9IHRoaXMubnVtX3N1YmxheWVycyAtIDI7IGkgPj0gMDsgLS1pKVxuICAgICAgICAgIHRoaXMucHRsX3N1YmxheWVyX3ByZXNlbnRfbWFzayAmIDEgPDwgaSAmJiAodGhpcy5zdWJsYXllcl9sZXZlbF9pZGNbaV0gPSB0LnJlYWRVaW50OCgpKTtcbiAgICAgICAgaWYgKHRoaXMucHRsX251bV9zdWJfcHJvZmlsZXMgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmdlbmVyYWxfc3ViX3Byb2ZpbGVfaWRjID0gW10sIHRoaXMucHRsX251bV9zdWJfcHJvZmlsZXMpXG4gICAgICAgICAgZm9yIChlID0gMDsgZSA8IHRoaXMucHRsX251bV9zdWJfcHJvZmlsZXM7IGUrKylcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhbF9zdWJfcHJvZmlsZV9pZGMucHVzaCh0LnJlYWRVaW50MzIoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1heF9waWN0dXJlX3dpZHRoID0gdC5yZWFkVWludDE2KCksIHRoaXMubWF4X3BpY3R1cmVfaGVpZ2h0ID0gdC5yZWFkVWludDE2KCksIHRoaXMuYXZnX2ZyYW1lX3JhdGUgPSB0LnJlYWRVaW50MTYoKTtcbiAgICB9XG4gICAgdmFyIF8gPSAxMiwgZyA9IDEzO1xuICAgIHRoaXMubmFsdV9hcnJheXMgPSBbXTtcbiAgICB2YXIgdyA9IHQucmVhZFVpbnQ4KCk7XG4gICAgZm9yIChlID0gMDsgZSA8IHc7IGUrKykge1xuICAgICAgdmFyIFMgPSBbXTtcbiAgICAgIHRoaXMubmFsdV9hcnJheXMucHVzaChTKSwgcy5zdHJlYW1fcmVhZF8xX2J5dGVzKHQpLCBTLmNvbXBsZXRlbmVzcyA9IHMuZXh0cmFjdF9iaXRzKDEpLCBzLmV4dHJhY3RfYml0cygyKSwgUy5uYWx1X3R5cGUgPSBzLmV4dHJhY3RfYml0cyg1KTtcbiAgICAgIHZhciBVID0gMTtcbiAgICAgIGZvciAoUy5uYWx1X3R5cGUgIT0gZyAmJiBTLm5hbHVfdHlwZSAhPSBfICYmIChVID0gdC5yZWFkVWludDE2KCkpLCBpID0gMDsgaSA8IFU7IGkrKykge1xuICAgICAgICB2YXIgQyA9IHQucmVhZFVpbnQxNigpO1xuICAgICAgICBTLnB1c2goe1xuICAgICAgICAgIGRhdGE6IHQucmVhZFVpbnQ4QXJyYXkoQyksXG4gICAgICAgICAgbGVuZ3RoOiBDXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ2dm5DXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHN0cm0ucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5sZW5ndGhTaXplTWludXNPbmUgPSBlICYgMztcbiAgfSksIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmlzVmlkZW8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gITE7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmlzQXVkaW8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gITE7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmlzU3VidGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gITE7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmlzTWV0YWRhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gITE7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmlzSGludCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhMTtcbiAgfSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q2hhbm5lbENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmdldFNhbXBsZVJhdGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0U2FtcGxlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9LCBuLlZpc3VhbFNhbXBsZUVudHJ5LnByb3RvdHlwZS5pc1ZpZGVvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEwO1xuICB9LCBuLlZpc3VhbFNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoO1xuICB9LCBuLlZpc3VhbFNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gIH0sIG4uQXVkaW9TYW1wbGVFbnRyeS5wcm90b3R5cGUuaXNBdWRpbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhMDtcbiAgfSwgbi5BdWRpb1NhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDaGFubmVsQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsX2NvdW50O1xuICB9LCBuLkF1ZGlvU2FtcGxlRW50cnkucHJvdG90eXBlLmdldFNhbXBsZVJhdGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVyYXRlO1xuICB9LCBuLkF1ZGlvU2FtcGxlRW50cnkucHJvdG90eXBlLmdldFNhbXBsZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVzaXplO1xuICB9LCBuLlN1YnRpdGxlU2FtcGxlRW50cnkucHJvdG90eXBlLmlzU3VidGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gITA7XG4gIH0sIG4uTWV0YWRhdGFTYW1wbGVFbnRyeS5wcm90b3R5cGUuaXNNZXRhZGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhMDtcbiAgfSwgbi5kZWNpbWFsVG9IZXggPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGkgPSBOdW1iZXIodCkudG9TdHJpbmcoMTYpO1xuICAgIGZvciAoZSA9IHR5cGVvZiBlID4gXCJ1XCIgfHwgZSA9PT0gbnVsbCA/IGUgPSAyIDogZTsgaS5sZW5ndGggPCBlOyApXG4gICAgICBpID0gXCIwXCIgKyBpO1xuICAgIHJldHVybiBpO1xuICB9LCBuLmF2YzFTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBuLmF2YzJTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBuLmF2YzNTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBuLmF2YzRTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuYXZjQyA/IHQgKyBcIi5cIiArIG4uZGVjaW1hbFRvSGV4KHRoaXMuYXZjQy5BVkNQcm9maWxlSW5kaWNhdGlvbikgKyBuLmRlY2ltYWxUb0hleCh0aGlzLmF2Y0MucHJvZmlsZV9jb21wYXRpYmlsaXR5KSArIG4uZGVjaW1hbFRvSGV4KHRoaXMuYXZjQy5BVkNMZXZlbEluZGljYXRpb24pIDogdDtcbiAgfSwgbi5oZXYxU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gbi5odmMxU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQsIGUgPSBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYy5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLmh2Y0MpIHtcbiAgICAgIHN3aXRjaCAoZSArPSBcIi5cIiwgdGhpcy5odmNDLmdlbmVyYWxfcHJvZmlsZV9zcGFjZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgZSArPSBcIlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZSArPSBcIkFcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGUgKz0gXCJCXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBlICs9IFwiQ1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZSArPSB0aGlzLmh2Y0MuZ2VuZXJhbF9wcm9maWxlX2lkYywgZSArPSBcIi5cIjtcbiAgICAgIHZhciBpID0gdGhpcy5odmNDLmdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5LCBzID0gMDtcbiAgICAgIGZvciAodCA9IDA7IHQgPCAzMiAmJiAocyB8PSBpICYgMSwgdCAhPSAzMSk7IHQrKylcbiAgICAgICAgcyA8PD0gMSwgaSA+Pj0gMTtcbiAgICAgIGUgKz0gbi5kZWNpbWFsVG9IZXgocywgMCksIGUgKz0gXCIuXCIsIHRoaXMuaHZjQy5nZW5lcmFsX3RpZXJfZmxhZyA9PT0gMCA/IGUgKz0gXCJMXCIgOiBlICs9IFwiSFwiLCBlICs9IHRoaXMuaHZjQy5nZW5lcmFsX2xldmVsX2lkYztcbiAgICAgIHZhciBvID0gITEsIGMgPSBcIlwiO1xuICAgICAgZm9yICh0ID0gNTsgdCA+PSAwOyB0LS0pXG4gICAgICAgICh0aGlzLmh2Y0MuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvclt0XSB8fCBvKSAmJiAoYyA9IFwiLlwiICsgbi5kZWNpbWFsVG9IZXgodGhpcy5odmNDLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JbdF0sIDApICsgYywgbyA9ICEwKTtcbiAgICAgIGUgKz0gYztcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIG4udnZjMVNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYyA9IG4udnZpMVNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0LCBlID0gbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy52dmNDKSB7XG4gICAgICBlICs9IFwiLlwiICsgdGhpcy52dmNDLmdlbmVyYWxfcHJvZmlsZV9pZGMsIHRoaXMudnZjQy5nZW5lcmFsX3RpZXJfZmxhZyA/IGUgKz0gXCIuSFwiIDogZSArPSBcIi5MXCIsIGUgKz0gdGhpcy52dmNDLmdlbmVyYWxfbGV2ZWxfaWRjO1xuICAgICAgdmFyIGkgPSBcIlwiO1xuICAgICAgaWYgKHRoaXMudnZjQy5nZW5lcmFsX2NvbnN0cmFpbnRfaW5mbykge1xuICAgICAgICB2YXIgcyA9IFtdLCBvID0gMDtcbiAgICAgICAgbyB8PSB0aGlzLnZ2Y0MucHRsX2ZyYW1lX29ubHlfY29uc3RyYWludCA8PCA3LCBvIHw9IHRoaXMudnZjQy5wdGxfbXVsdGlsYXllcl9lbmFibGVkIDw8IDY7XG4gICAgICAgIHZhciBjO1xuICAgICAgICBmb3IgKHQgPSAwOyB0IDwgdGhpcy52dmNDLmdlbmVyYWxfY29uc3RyYWludF9pbmZvLmxlbmd0aDsgKyt0KVxuICAgICAgICAgIG8gfD0gdGhpcy52dmNDLmdlbmVyYWxfY29uc3RyYWludF9pbmZvW3RdID4+IDIgJiA2Mywgcy5wdXNoKG8pLCBvICYmIChjID0gdCksIG8gPSB0aGlzLnZ2Y0MuZ2VuZXJhbF9jb25zdHJhaW50X2luZm9bdF0gPj4gMiAmIDM7XG4gICAgICAgIGlmIChjID09PSB2b2lkIDApXG4gICAgICAgICAgaSA9IFwiLkNBXCI7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGkgPSBcIi5DXCI7XG4gICAgICAgICAgdmFyIHUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCIsIF8gPSAwLCBnID0gMDtcbiAgICAgICAgICBmb3IgKHQgPSAwOyB0IDw9IGM7ICsrdClcbiAgICAgICAgICAgIGZvciAoXyA9IF8gPDwgOCB8IHNbdF0sIGcgKz0gODsgZyA+PSA1OyApIHtcbiAgICAgICAgICAgICAgdmFyIHcgPSBfID4+IGcgLSA1ICYgMzE7XG4gICAgICAgICAgICAgIGkgKz0gdVt3XSwgZyAtPSA1LCBfICY9ICgxIDw8IGcpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBnICYmIChfIDw8PSA1IC0gZywgaSArPSB1W18gJiAzMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlICs9IGk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBuLm1wNGFTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuZXNkcyAmJiB0aGlzLmVzZHMuZXNkKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuZXNkcy5lc2QuZ2V0T1RJKCksIGkgPSB0aGlzLmVzZHMuZXNkLmdldEF1ZGlvQ29uZmlnKCk7XG4gICAgICByZXR1cm4gdCArIFwiLlwiICsgbi5kZWNpbWFsVG9IZXgoZSkgKyAoaSA/IFwiLlwiICsgaSA6IFwiXCIpO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHQ7XG4gIH0sIG4uc3R4dFNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5taW1lX2Zvcm1hdCA/IHQgKyBcIi5cIiArIHRoaXMubWltZV9mb3JtYXQgOiB0O1xuICB9LCBuLnZwMDhTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBuLnZwMDlTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjLmNhbGwodGhpcyksIGUgPSB0aGlzLnZwY0MubGV2ZWw7XG4gICAgZSA9PSAwICYmIChlID0gXCIwMFwiKTtcbiAgICB2YXIgaSA9IHRoaXMudnBjQy5iaXREZXB0aDtcbiAgICByZXR1cm4gaSA9PSA4ICYmIChpID0gXCIwOFwiKSwgdCArIFwiLjBcIiArIHRoaXMudnBjQy5wcm9maWxlICsgXCIuXCIgKyBlICsgXCIuXCIgKyBpO1xuICB9LCBuLmF2MDFTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjLmNhbGwodGhpcyksIGUgPSB0aGlzLmF2MUMuc2VxX2xldmVsX2lkeF8wO1xuICAgIGUgPCAxMCAmJiAoZSA9IFwiMFwiICsgZSk7XG4gICAgdmFyIGk7XG4gICAgcmV0dXJuIHRoaXMuYXYxQy5zZXFfcHJvZmlsZSA9PT0gMiAmJiB0aGlzLmF2MUMuaGlnaF9iaXRkZXB0aCA9PT0gMSA/IGkgPSB0aGlzLmF2MUMudHdlbHZlX2JpdCA9PT0gMSA/IFwiMTJcIiA6IFwiMTBcIiA6IHRoaXMuYXYxQy5zZXFfcHJvZmlsZSA8PSAyICYmIChpID0gdGhpcy5hdjFDLmhpZ2hfYml0ZGVwdGggPT09IDEgPyBcIjEwXCIgOiBcIjA4XCIpLCB0ICsgXCIuXCIgKyB0aGlzLmF2MUMuc2VxX3Byb2ZpbGUgKyBcIi5cIiArIGUgKyAodGhpcy5hdjFDLnNlcV90aWVyXzAgPyBcIkhcIiA6IFwiTVwiKSArIFwiLlwiICsgaTtcbiAgfSwgbi5Cb3gucHJvdG90eXBlLndyaXRlSGVhZGVyID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHRoaXMuc2l6ZSArPSA4LCB0aGlzLnNpemUgPiBmICYmICh0aGlzLnNpemUgKz0gOCksIHRoaXMudHlwZSA9PT0gXCJ1dWlkXCIgJiYgKHRoaXMuc2l6ZSArPSAxNiksIHIuZGVidWcoXCJCb3hXcml0ZXJcIiwgXCJXcml0aW5nIGJveCBcIiArIHRoaXMudHlwZSArIFwiIG9mIHNpemU6IFwiICsgdGhpcy5zaXplICsgXCIgYXQgcG9zaXRpb24gXCIgKyB0LmdldFBvc2l0aW9uKCkgKyAoZSB8fCBcIlwiKSksIHRoaXMuc2l6ZSA+IGYgPyB0LndyaXRlVWludDMyKDEpIDogKHRoaXMuc2l6ZVBvc2l0aW9uID0gdC5nZXRQb3NpdGlvbigpLCB0LndyaXRlVWludDMyKHRoaXMuc2l6ZSkpLCB0LndyaXRlU3RyaW5nKHRoaXMudHlwZSwgbnVsbCwgNCksIHRoaXMudHlwZSA9PT0gXCJ1dWlkXCIgJiYgdC53cml0ZVVpbnQ4QXJyYXkodGhpcy51dWlkKSwgdGhpcy5zaXplID4gZiAmJiB0LndyaXRlVWludDY0KHRoaXMuc2l6ZSk7XG4gIH0sIG4uRnVsbEJveC5wcm90b3R5cGUud3JpdGVIZWFkZXIgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zaXplICs9IDQsIG4uQm94LnByb3RvdHlwZS53cml0ZUhlYWRlci5jYWxsKHRoaXMsIHQsIFwiIHY9XCIgKyB0aGlzLnZlcnNpb24gKyBcIiBmPVwiICsgdGhpcy5mbGFncyksIHQud3JpdGVVaW50OCh0aGlzLnZlcnNpb24pLCB0LndyaXRlVWludDI0KHRoaXMuZmxhZ3MpO1xuICB9LCBuLkJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50eXBlID09PSBcIm1kYXRcIiA/IHRoaXMuZGF0YSAmJiAodGhpcy5zaXplID0gdGhpcy5kYXRhLmxlbmd0aCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQ4QXJyYXkodGhpcy5kYXRhKSkgOiAodGhpcy5zaXplID0gdGhpcy5kYXRhID8gdGhpcy5kYXRhLmxlbmd0aCA6IDAsIHRoaXMud3JpdGVIZWFkZXIodCksIHRoaXMuZGF0YSAmJiB0LndyaXRlVWludDhBcnJheSh0aGlzLmRhdGEpKTtcbiAgfSwgbi5Db250YWluZXJCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2l6ZSA9IDAsIHRoaXMud3JpdGVIZWFkZXIodCk7XG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmJveGVzLmxlbmd0aDsgZSsrKVxuICAgICAgdGhpcy5ib3hlc1tlXSAmJiAodGhpcy5ib3hlc1tlXS53cml0ZSh0KSwgdGhpcy5zaXplICs9IHRoaXMuYm94ZXNbZV0uc2l6ZSk7XG4gICAgci5kZWJ1ZyhcIkJveFdyaXRlclwiLCBcIkFkanVzdGluZyBib3ggXCIgKyB0aGlzLnR5cGUgKyBcIiB3aXRoIG5ldyBzaXplIFwiICsgdGhpcy5zaXplKSwgdC5hZGp1c3RVaW50MzIodGhpcy5zaXplUG9zaXRpb24sIHRoaXMuc2l6ZSk7XG4gIH0sIG4uVHJhY2tSZWZlcmVuY2VUeXBlQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNpemUgPSB0aGlzLnRyYWNrX2lkcy5sZW5ndGggKiA0LCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyQXJyYXkodGhpcy50cmFja19pZHMpO1xuICB9LCBuLmF2Y0NCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIGZvciAodGhpcy5zaXplID0gNywgZSA9IDA7IGUgPCB0aGlzLlNQUy5sZW5ndGg7IGUrKylcbiAgICAgIHRoaXMuc2l6ZSArPSAyICsgdGhpcy5TUFNbZV0ubGVuZ3RoO1xuICAgIGZvciAoZSA9IDA7IGUgPCB0aGlzLlBQUy5sZW5ndGg7IGUrKylcbiAgICAgIHRoaXMuc2l6ZSArPSAyICsgdGhpcy5QUFNbZV0ubGVuZ3RoO1xuICAgIGZvciAodGhpcy5leHQgJiYgKHRoaXMuc2l6ZSArPSB0aGlzLmV4dC5sZW5ndGgpLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDgodGhpcy5jb25maWd1cmF0aW9uVmVyc2lvbiksIHQud3JpdGVVaW50OCh0aGlzLkFWQ1Byb2ZpbGVJbmRpY2F0aW9uKSwgdC53cml0ZVVpbnQ4KHRoaXMucHJvZmlsZV9jb21wYXRpYmlsaXR5KSwgdC53cml0ZVVpbnQ4KHRoaXMuQVZDTGV2ZWxJbmRpY2F0aW9uKSwgdC53cml0ZVVpbnQ4KHRoaXMubGVuZ3RoU2l6ZU1pbnVzT25lICsgMjUyKSwgdC53cml0ZVVpbnQ4KHRoaXMuU1BTLmxlbmd0aCArIDIyNCksIGUgPSAwOyBlIDwgdGhpcy5TUFMubGVuZ3RoOyBlKyspXG4gICAgICB0LndyaXRlVWludDE2KHRoaXMuU1BTW2VdLmxlbmd0aCksIHQud3JpdGVVaW50OEFycmF5KHRoaXMuU1BTW2VdLm5hbHUpO1xuICAgIGZvciAodC53cml0ZVVpbnQ4KHRoaXMuUFBTLmxlbmd0aCksIGUgPSAwOyBlIDwgdGhpcy5QUFMubGVuZ3RoOyBlKyspXG4gICAgICB0LndyaXRlVWludDE2KHRoaXMuUFBTW2VdLmxlbmd0aCksIHQud3JpdGVVaW50OEFycmF5KHRoaXMuUFBTW2VdLm5hbHUpO1xuICAgIHRoaXMuZXh0ICYmIHQud3JpdGVVaW50OEFycmF5KHRoaXMuZXh0KTtcbiAgfSwgbi5jbzY0Qm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZTtcbiAgICBmb3IgKHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSA0ICsgOCAqIHRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGgsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5jaHVua19vZmZzZXRzLmxlbmd0aCksIGUgPSAwOyBlIDwgdGhpcy5jaHVua19vZmZzZXRzLmxlbmd0aDsgZSsrKVxuICAgICAgdC53cml0ZVVpbnQ2NCh0aGlzLmNodW5rX29mZnNldHNbZV0pO1xuICB9LCBuLmNzbGdCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSA0ICogNSwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZUludDMyKHRoaXMuY29tcG9zaXRpb25Ub0RUU1NoaWZ0KSwgdC53cml0ZUludDMyKHRoaXMubGVhc3REZWNvZGVUb0Rpc3BsYXlEZWx0YSksIHQud3JpdGVJbnQzMih0aGlzLmdyZWF0ZXN0RGVjb2RlVG9EaXNwbGF5RGVsdGEpLCB0LndyaXRlSW50MzIodGhpcy5jb21wb3NpdGlvblN0YXJ0VGltZSksIHQud3JpdGVJbnQzMih0aGlzLmNvbXBvc2l0aW9uRW5kVGltZSk7XG4gIH0sIG4uY3R0c0JveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgZm9yICh0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCArIDggKiB0aGlzLnNhbXBsZV9jb3VudHMubGVuZ3RoLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGgpLCBlID0gMDsgZSA8IHRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGg7IGUrKylcbiAgICAgIHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfY291bnRzW2VdKSwgdGhpcy52ZXJzaW9uID09PSAxID8gdC53cml0ZUludDMyKHRoaXMuc2FtcGxlX29mZnNldHNbZV0pIDogdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9vZmZzZXRzW2VdKTtcbiAgfSwgbi5kcmVmQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLmVudHJpZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGUrKylcbiAgICAgIHRoaXMuZW50cmllc1tlXS53cml0ZSh0KSwgdGhpcy5zaXplICs9IHRoaXMuZW50cmllc1tlXS5zaXplO1xuICAgIHIuZGVidWcoXCJCb3hXcml0ZXJcIiwgXCJBZGp1c3RpbmcgYm94IFwiICsgdGhpcy50eXBlICsgXCIgd2l0aCBuZXcgc2l6ZSBcIiArIHRoaXMuc2l6ZSksIHQuYWRqdXN0VWludDMyKHRoaXMuc2l6ZVBvc2l0aW9uLCB0aGlzLnNpemUpO1xuICB9LCBuLmVsbmdCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSB0aGlzLmV4dGVuZGVkX2xhbmd1YWdlLmxlbmd0aCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVN0cmluZyh0aGlzLmV4dGVuZGVkX2xhbmd1YWdlKTtcbiAgfSwgbi5lbHN0Qm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCArIDEyICogdGhpcy5lbnRyaWVzLmxlbmd0aCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLmVudHJpZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIGkgPSB0aGlzLmVudHJpZXNbZV07XG4gICAgICB0LndyaXRlVWludDMyKGkuc2VnbWVudF9kdXJhdGlvbiksIHQud3JpdGVJbnQzMihpLm1lZGlhX3RpbWUpLCB0LndyaXRlSW50MTYoaS5tZWRpYV9yYXRlX2ludGVnZXIpLCB0LndyaXRlSW50MTYoaS5tZWRpYV9yYXRlX2ZyYWN0aW9uKTtcbiAgICB9XG4gIH0sIG4uZW1zZ0JveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQgKiA0ICsgdGhpcy5tZXNzYWdlX2RhdGEubGVuZ3RoICsgKHRoaXMuc2NoZW1lX2lkX3VyaS5sZW5ndGggKyAxKSArICh0aGlzLnZhbHVlLmxlbmd0aCArIDEpLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlQ1N0cmluZyh0aGlzLnNjaGVtZV9pZF91cmkpLCB0LndyaXRlQ1N0cmluZyh0aGlzLnZhbHVlKSwgdC53cml0ZVVpbnQzMih0aGlzLnRpbWVzY2FsZSksIHQud3JpdGVVaW50MzIodGhpcy5wcmVzZW50YXRpb25fdGltZV9kZWx0YSksIHQud3JpdGVVaW50MzIodGhpcy5ldmVudF9kdXJhdGlvbiksIHQud3JpdGVVaW50MzIodGhpcy5pZCksIHQud3JpdGVVaW50OEFycmF5KHRoaXMubWVzc2FnZV9kYXRhKTtcbiAgfSwgbi5mdHlwQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNpemUgPSA4ICsgNCAqIHRoaXMuY29tcGF0aWJsZV9icmFuZHMubGVuZ3RoLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlU3RyaW5nKHRoaXMubWFqb3JfYnJhbmQsIG51bGwsIDQpLCB0LndyaXRlVWludDMyKHRoaXMubWlub3JfdmVyc2lvbik7XG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmNvbXBhdGlibGVfYnJhbmRzLmxlbmd0aDsgZSsrKVxuICAgICAgdC53cml0ZVN0cmluZyh0aGlzLmNvbXBhdGlibGVfYnJhbmRzW2VdLCBudWxsLCA0KTtcbiAgfSwgbi5oZGxyQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNpemUgPSA1ICogNCArIHRoaXMubmFtZS5sZW5ndGggKyAxLCB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVN0cmluZyh0aGlzLmhhbmRsZXIsIG51bGwsIDQpLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlQ1N0cmluZyh0aGlzLm5hbWUpO1xuICB9LCBuLmtpbmRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSB0aGlzLnNjaGVtZVVSSS5sZW5ndGggKyAxICsgKHRoaXMudmFsdWUubGVuZ3RoICsgMSksIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVDU3RyaW5nKHRoaXMuc2NoZW1lVVJJKSwgdC53cml0ZUNTdHJpbmcodGhpcy52YWx1ZSk7XG4gIH0sIG4ubWRoZEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zaXplID0gNCAqIDQgKyAyICogMiwgdGhpcy5mbGFncyA9IDAsIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5jcmVhdGlvbl90aW1lKSwgdC53cml0ZVVpbnQzMih0aGlzLm1vZGlmaWNhdGlvbl90aW1lKSwgdC53cml0ZVVpbnQzMih0aGlzLnRpbWVzY2FsZSksIHQud3JpdGVVaW50MzIodGhpcy5kdXJhdGlvbiksIHQud3JpdGVVaW50MTYodGhpcy5sYW5ndWFnZSksIHQud3JpdGVVaW50MTYoMCk7XG4gIH0sIG4ubWVoZEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5mcmFnbWVudF9kdXJhdGlvbik7XG4gIH0sIG4ubWZoZEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5zZXF1ZW5jZV9udW1iZXIpO1xuICB9LCBuLm12aGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSAyMyAqIDQgKyAyICogMiwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLmNyZWF0aW9uX3RpbWUpLCB0LndyaXRlVWludDMyKHRoaXMubW9kaWZpY2F0aW9uX3RpbWUpLCB0LndyaXRlVWludDMyKHRoaXMudGltZXNjYWxlKSwgdC53cml0ZVVpbnQzMih0aGlzLmR1cmF0aW9uKSwgdC53cml0ZVVpbnQzMih0aGlzLnJhdGUpLCB0LndyaXRlVWludDE2KHRoaXMudm9sdW1lIDw8IDgpLCB0LndyaXRlVWludDE2KDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyQXJyYXkodGhpcy5tYXRyaXgpLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKHRoaXMubmV4dF90cmFja19pZCk7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLndyaXRlSGVhZGVyID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2l6ZSA9IDgsIG4uQm94LnByb3RvdHlwZS53cml0ZUhlYWRlci5jYWxsKHRoaXMsIHQpLCB0LndyaXRlVWludDgoMCksIHQud3JpdGVVaW50OCgwKSwgdC53cml0ZVVpbnQ4KDApLCB0LndyaXRlVWludDgoMCksIHQud3JpdGVVaW50OCgwKSwgdC53cml0ZVVpbnQ4KDApLCB0LndyaXRlVWludDE2KHRoaXMuZGF0YV9yZWZlcmVuY2VfaW5kZXgpO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS53cml0ZUZvb3RlciA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuYm94ZXMubGVuZ3RoOyBlKyspXG4gICAgICB0aGlzLmJveGVzW2VdLndyaXRlKHQpLCB0aGlzLnNpemUgKz0gdGhpcy5ib3hlc1tlXS5zaXplO1xuICAgIHIuZGVidWcoXCJCb3hXcml0ZXJcIiwgXCJBZGp1c3RpbmcgYm94IFwiICsgdGhpcy50eXBlICsgXCIgd2l0aCBuZXcgc2l6ZSBcIiArIHRoaXMuc2l6ZSksIHQuYWRqdXN0VWludDMyKHRoaXMuc2l6ZVBvc2l0aW9uLCB0aGlzLnNpemUpO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDhBcnJheSh0aGlzLmRhdGEpLCB0aGlzLnNpemUgKz0gdGhpcy5kYXRhLmxlbmd0aCwgci5kZWJ1ZyhcIkJveFdyaXRlclwiLCBcIkFkanVzdGluZyBib3ggXCIgKyB0aGlzLnR5cGUgKyBcIiB3aXRoIG5ldyBzaXplIFwiICsgdGhpcy5zaXplKSwgdC5hZGp1c3RVaW50MzIodGhpcy5zaXplUG9zaXRpb24sIHRoaXMuc2l6ZSk7XG4gIH0sIG4uVmlzdWFsU2FtcGxlRW50cnkucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMud3JpdGVIZWFkZXIodCksIHRoaXMuc2l6ZSArPSAyICogNyArIDYgKiA0ICsgMzIsIHQud3JpdGVVaW50MTYoMCksIHQud3JpdGVVaW50MTYoMCksIHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVVaW50MTYodGhpcy53aWR0aCksIHQud3JpdGVVaW50MTYodGhpcy5oZWlnaHQpLCB0LndyaXRlVWludDMyKHRoaXMuaG9yaXpyZXNvbHV0aW9uKSwgdC53cml0ZVVpbnQzMih0aGlzLnZlcnRyZXNvbHV0aW9uKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQxNih0aGlzLmZyYW1lX2NvdW50KSwgdC53cml0ZVVpbnQ4KE1hdGgubWluKDMxLCB0aGlzLmNvbXByZXNzb3JuYW1lLmxlbmd0aCkpLCB0LndyaXRlU3RyaW5nKHRoaXMuY29tcHJlc3Nvcm5hbWUsIG51bGwsIDMxKSwgdC53cml0ZVVpbnQxNih0aGlzLmRlcHRoKSwgdC53cml0ZUludDE2KC0xKSwgdGhpcy53cml0ZUZvb3Rlcih0KTtcbiAgfSwgbi5BdWRpb1NhbXBsZUVudHJ5LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLndyaXRlSGVhZGVyKHQpLCB0aGlzLnNpemUgKz0gMiAqIDQgKyAzICogNCwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQxNih0aGlzLmNoYW5uZWxfY291bnQpLCB0LndyaXRlVWludDE2KHRoaXMuc2FtcGxlc2l6ZSksIHQud3JpdGVVaW50MTYoMCksIHQud3JpdGVVaW50MTYoMCksIHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVyYXRlIDw8IDE2KSwgdGhpcy53cml0ZUZvb3Rlcih0KTtcbiAgfSwgbi5zdHBwU2FtcGxlRW50cnkucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMud3JpdGVIZWFkZXIodCksIHRoaXMuc2l6ZSArPSB0aGlzLm5hbWVzcGFjZS5sZW5ndGggKyAxICsgdGhpcy5zY2hlbWFfbG9jYXRpb24ubGVuZ3RoICsgMSArIHRoaXMuYXV4aWxpYXJ5X21pbWVfdHlwZXMubGVuZ3RoICsgMSwgdC53cml0ZUNTdHJpbmcodGhpcy5uYW1lc3BhY2UpLCB0LndyaXRlQ1N0cmluZyh0aGlzLnNjaGVtYV9sb2NhdGlvbiksIHQud3JpdGVDU3RyaW5nKHRoaXMuYXV4aWxpYXJ5X21pbWVfdHlwZXMpLCB0aGlzLndyaXRlRm9vdGVyKHQpO1xuICB9LCBuLlNhbXBsZUdyb3VwRW50cnkucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHQud3JpdGVVaW50OEFycmF5KHRoaXMuZGF0YSk7XG4gIH0sIG4uc2JncEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMSwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDEyICsgOCAqIHRoaXMuZW50cmllcy5sZW5ndGgsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVTdHJpbmcodGhpcy5ncm91cGluZ190eXBlLCBudWxsLCA0KSwgdC53cml0ZVVpbnQzMih0aGlzLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyKSwgdC53cml0ZVVpbnQzMih0aGlzLmVudHJpZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIGkgPSB0aGlzLmVudHJpZXNbZV07XG4gICAgICB0LndyaXRlSW50MzIoaS5zYW1wbGVfY291bnQpLCB0LndyaXRlSW50MzIoaS5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCk7XG4gICAgfVxuICB9LCBuLnNncGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpO1xuICAgIGZvciAodGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDEyLCBlID0gMDsgZSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGUrKylcbiAgICAgIGkgPSB0aGlzLmVudHJpZXNbZV0sIHRoaXMudmVyc2lvbiA9PT0gMSAmJiAodGhpcy5kZWZhdWx0X2xlbmd0aCA9PT0gMCAmJiAodGhpcy5zaXplICs9IDQpLCB0aGlzLnNpemUgKz0gaS5kYXRhLmxlbmd0aCk7XG4gICAgZm9yICh0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlU3RyaW5nKHRoaXMuZ3JvdXBpbmdfdHlwZSwgbnVsbCwgNCksIHRoaXMudmVyc2lvbiA9PT0gMSAmJiB0LndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9sZW5ndGgpLCB0aGlzLnZlcnNpb24gPj0gMiAmJiB0LndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXgpLCB0LndyaXRlVWludDMyKHRoaXMuZW50cmllcy5sZW5ndGgpLCBlID0gMDsgZSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGUrKylcbiAgICAgIGkgPSB0aGlzLmVudHJpZXNbZV0sIHRoaXMudmVyc2lvbiA9PT0gMSAmJiB0aGlzLmRlZmF1bHRfbGVuZ3RoID09PSAwICYmIHQud3JpdGVVaW50MzIoaS5kZXNjcmlwdGlvbl9sZW5ndGgpLCBpLndyaXRlKHQpO1xuICB9LCBuLnNpZHhCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSA0ICogNCArIDIgKyAyICsgMTIgKiB0aGlzLnJlZmVyZW5jZXMubGVuZ3RoLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMucmVmZXJlbmNlX0lEKSwgdC53cml0ZVVpbnQzMih0aGlzLnRpbWVzY2FsZSksIHQud3JpdGVVaW50MzIodGhpcy5lYXJsaWVzdF9wcmVzZW50YXRpb25fdGltZSksIHQud3JpdGVVaW50MzIodGhpcy5maXJzdF9vZmZzZXQpLCB0LndyaXRlVWludDE2KDApLCB0LndyaXRlVWludDE2KHRoaXMucmVmZXJlbmNlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5yZWZlcmVuY2VzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgaSA9IHRoaXMucmVmZXJlbmNlc1tlXTtcbiAgICAgIHQud3JpdGVVaW50MzIoaS5yZWZlcmVuY2VfdHlwZSA8PCAzMSB8IGkucmVmZXJlbmNlZF9zaXplKSwgdC53cml0ZVVpbnQzMihpLnN1YnNlZ21lbnRfZHVyYXRpb24pLCB0LndyaXRlVWludDMyKGkuc3RhcnRzX3dpdGhfU0FQIDw8IDMxIHwgaS5TQVBfdHlwZSA8PCAyOCB8IGkuU0FQX2RlbHRhX3RpbWUpO1xuICAgIH1cbiAgfSwgbi5zbWhkQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMSwgdGhpcy5zaXplID0gNCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQxNih0aGlzLmJhbGFuY2UpLCB0LndyaXRlVWludDE2KDApO1xuICB9LCBuLnN0Y29Cb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSA0ICsgNCAqIHRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGgsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5jaHVua19vZmZzZXRzLmxlbmd0aCksIHQud3JpdGVVaW50MzJBcnJheSh0aGlzLmNodW5rX29mZnNldHMpO1xuICB9LCBuLnN0c2NCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIGZvciAodGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQgKyAxMiAqIHRoaXMuZmlyc3RfY2h1bmsubGVuZ3RoLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMuZmlyc3RfY2h1bmsubGVuZ3RoKSwgZSA9IDA7IGUgPCB0aGlzLmZpcnN0X2NodW5rLmxlbmd0aDsgZSsrKVxuICAgICAgdC53cml0ZVVpbnQzMih0aGlzLmZpcnN0X2NodW5rW2VdKSwgdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZXNfcGVyX2NodW5rW2VdKSwgdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFtlXSk7XG4gIH0sIG4uc3RzZEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgZm9yICh0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gMCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLmVudHJpZXMubGVuZ3RoKSwgdGhpcy5zaXplICs9IDQsIGUgPSAwOyBlIDwgdGhpcy5lbnRyaWVzLmxlbmd0aDsgZSsrKVxuICAgICAgdGhpcy5lbnRyaWVzW2VdLndyaXRlKHQpLCB0aGlzLnNpemUgKz0gdGhpcy5lbnRyaWVzW2VdLnNpemU7XG4gICAgci5kZWJ1ZyhcIkJveFdyaXRlclwiLCBcIkFkanVzdGluZyBib3ggXCIgKyB0aGlzLnR5cGUgKyBcIiB3aXRoIG5ldyBzaXplIFwiICsgdGhpcy5zaXplKSwgdC5hZGp1c3RVaW50MzIodGhpcy5zaXplUG9zaXRpb24sIHRoaXMuc2l6ZSk7XG4gIH0sIG4uc3RzaEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgZm9yICh0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCArIDggKiB0aGlzLnNoYWRvd2VkX3NhbXBsZV9udW1iZXJzLmxlbmd0aCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLnNoYWRvd2VkX3NhbXBsZV9udW1iZXJzLmxlbmd0aCksIGUgPSAwOyBlIDwgdGhpcy5zaGFkb3dlZF9zYW1wbGVfbnVtYmVycy5sZW5ndGg7IGUrKylcbiAgICAgIHQud3JpdGVVaW50MzIodGhpcy5zaGFkb3dlZF9zYW1wbGVfbnVtYmVyc1tlXSksIHQud3JpdGVVaW50MzIodGhpcy5zeW5jX3NhbXBsZV9udW1iZXJzW2VdKTtcbiAgfSwgbi5zdHNzQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCArIDQgKiB0aGlzLnNhbXBsZV9udW1iZXJzLmxlbmd0aCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9udW1iZXJzLmxlbmd0aCksIHQud3JpdGVVaW50MzJBcnJheSh0aGlzLnNhbXBsZV9udW1iZXJzKTtcbiAgfSwgbi5zdHN6Qm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSA9ICEwO1xuICAgIGlmICh0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zYW1wbGVfc2l6ZXMubGVuZ3RoID4gMClcbiAgICAgIGZvciAoZSA9IDA7IGUgKyAxIDwgdGhpcy5zYW1wbGVfc2l6ZXMubGVuZ3RoOyApXG4gICAgICAgIGlmICh0aGlzLnNhbXBsZV9zaXplc1tlICsgMV0gIT09IHRoaXMuc2FtcGxlX3NpemVzWzBdKSB7XG4gICAgICAgICAgaSA9ICExO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBlKys7XG4gICAgZWxzZVxuICAgICAgaSA9ICExO1xuICAgIHRoaXMuc2l6ZSA9IDgsIGkgfHwgKHRoaXMuc2l6ZSArPSA0ICogdGhpcy5zYW1wbGVfc2l6ZXMubGVuZ3RoKSwgdGhpcy53cml0ZUhlYWRlcih0KSwgaSA/IHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfc2l6ZXNbMF0pIDogdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9zaXplcy5sZW5ndGgpLCBpIHx8IHQud3JpdGVVaW50MzJBcnJheSh0aGlzLnNhbXBsZV9zaXplcyk7XG4gIH0sIG4uc3R0c0JveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgZm9yICh0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCArIDggKiB0aGlzLnNhbXBsZV9jb3VudHMubGVuZ3RoLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGgpLCBlID0gMDsgZSA8IHRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGg7IGUrKylcbiAgICAgIHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfY291bnRzW2VdKSwgdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9kZWx0YXNbZV0pO1xuICB9LCBuLnRmZHRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbiAgICB0aGlzLnZlcnNpb24gPSB0aGlzLmJhc2VNZWRpYURlY29kZVRpbWUgPiBlID8gMSA6IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSA0LCB0aGlzLnZlcnNpb24gPT09IDEgJiYgKHRoaXMuc2l6ZSArPSA0KSwgdGhpcy53cml0ZUhlYWRlcih0KSwgdGhpcy52ZXJzaW9uID09PSAxID8gdC53cml0ZVVpbnQ2NCh0aGlzLmJhc2VNZWRpYURlY29kZVRpbWUpIDogdC53cml0ZVVpbnQzMih0aGlzLmJhc2VNZWRpYURlY29kZVRpbWUpO1xuICB9LCBuLnRmaGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuc2l6ZSA9IDQsIHRoaXMuZmxhZ3MgJiBuLlRGSERfRkxBR19CQVNFX0RBVEFfT0ZGU0VUICYmICh0aGlzLnNpemUgKz0gOCksIHRoaXMuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfREVTQyAmJiAodGhpcy5zaXplICs9IDQpLCB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX0RVUiAmJiAodGhpcy5zaXplICs9IDQpLCB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX1NJWkUgJiYgKHRoaXMuc2l6ZSArPSA0KSwgdGhpcy5mbGFncyAmIG4uVEZIRF9GTEFHX1NBTVBMRV9GTEFHUyAmJiAodGhpcy5zaXplICs9IDQpLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMudHJhY2tfaWQpLCB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfQkFTRV9EQVRBX09GRlNFVCAmJiB0LndyaXRlVWludDY0KHRoaXMuYmFzZV9kYXRhX29mZnNldCksIHRoaXMuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfREVTQyAmJiB0LndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXgpLCB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX0RVUiAmJiB0LndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24pLCB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX1NJWkUgJiYgdC53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfc2FtcGxlX3NpemUpLCB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX0ZMQUdTICYmIHQud3JpdGVVaW50MzIodGhpcy5kZWZhdWx0X3NhbXBsZV9mbGFncyk7XG4gIH0sIG4udGtoZEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5zaXplID0gNCAqIDE4ICsgMiAqIDQsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5jcmVhdGlvbl90aW1lKSwgdC53cml0ZVVpbnQzMih0aGlzLm1vZGlmaWNhdGlvbl90aW1lKSwgdC53cml0ZVVpbnQzMih0aGlzLnRyYWNrX2lkKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMih0aGlzLmR1cmF0aW9uKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZUludDE2KHRoaXMubGF5ZXIpLCB0LndyaXRlSW50MTYodGhpcy5hbHRlcm5hdGVfZ3JvdXApLCB0LndyaXRlSW50MTYodGhpcy52b2x1bWUgPDwgOCksIHQud3JpdGVVaW50MTYoMCksIHQud3JpdGVJbnQzMkFycmF5KHRoaXMubWF0cml4KSwgdC53cml0ZVVpbnQzMih0aGlzLndpZHRoKSwgdC53cml0ZVVpbnQzMih0aGlzLmhlaWdodCk7XG4gIH0sIG4udHJleEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQgKiA1LCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMudHJhY2tfaWQpLCB0LndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXgpLCB0LndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24pLCB0LndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfc2l6ZSksIHQud3JpdGVVaW50MzIodGhpcy5kZWZhdWx0X3NhbXBsZV9mbGFncyk7XG4gIH0sIG4udHJ1bkJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5zaXplID0gNCwgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19EQVRBX09GRlNFVCAmJiAodGhpcy5zaXplICs9IDQpLCB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX0ZJUlNUX0ZMQUcgJiYgKHRoaXMuc2l6ZSArPSA0KSwgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19EVVJBVElPTiAmJiAodGhpcy5zaXplICs9IDQgKiB0aGlzLnNhbXBsZV9kdXJhdGlvbi5sZW5ndGgpLCB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX1NJWkUgJiYgKHRoaXMuc2l6ZSArPSA0ICogdGhpcy5zYW1wbGVfc2l6ZS5sZW5ndGgpLCB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX0ZMQUdTICYmICh0aGlzLnNpemUgKz0gNCAqIHRoaXMuc2FtcGxlX2ZsYWdzLmxlbmd0aCksIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfQ1RTX09GRlNFVCAmJiAodGhpcy5zaXplICs9IDQgKiB0aGlzLnNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldC5sZW5ndGgpLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2NvdW50KSwgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19EQVRBX09GRlNFVCAmJiAodGhpcy5kYXRhX29mZnNldF9wb3NpdGlvbiA9IHQuZ2V0UG9zaXRpb24oKSwgdC53cml0ZUludDMyKHRoaXMuZGF0YV9vZmZzZXQpKSwgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19GSVJTVF9GTEFHICYmIHQud3JpdGVVaW50MzIodGhpcy5maXJzdF9zYW1wbGVfZmxhZ3MpO1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5zYW1wbGVfY291bnQ7IGUrKylcbiAgICAgIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfRFVSQVRJT04gJiYgdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9kdXJhdGlvbltlXSksIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfU0laRSAmJiB0LndyaXRlVWludDMyKHRoaXMuc2FtcGxlX3NpemVbZV0pLCB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX0ZMQUdTICYmIHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfZmxhZ3NbZV0pLCB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX0NUU19PRkZTRVQgJiYgKHRoaXMudmVyc2lvbiA9PT0gMCA/IHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRbZV0pIDogdC53cml0ZUludDMyKHRoaXMuc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0W2VdKSk7XG4gIH0sIG5bXCJ1cmwgQm94XCJdLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmxvY2F0aW9uID8gKHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSB0aGlzLmxvY2F0aW9uLmxlbmd0aCArIDEpIDogKHRoaXMuZmxhZ3MgPSAxLCB0aGlzLnNpemUgPSAwKSwgdGhpcy53cml0ZUhlYWRlcih0KSwgdGhpcy5sb2NhdGlvbiAmJiB0LndyaXRlQ1N0cmluZyh0aGlzLmxvY2F0aW9uKTtcbiAgfSwgbltcInVybiBCb3hcIl0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSB0aGlzLm5hbWUubGVuZ3RoICsgMSArICh0aGlzLmxvY2F0aW9uID8gdGhpcy5sb2NhdGlvbi5sZW5ndGggKyAxIDogMCksIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVDU3RyaW5nKHRoaXMubmFtZSksIHRoaXMubG9jYXRpb24gJiYgdC53cml0ZUNTdHJpbmcodGhpcy5sb2NhdGlvbik7XG4gIH0sIG4udm1oZEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDEsIHRoaXMuc2l6ZSA9IDgsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MTYodGhpcy5ncmFwaGljc21vZGUpLCB0LndyaXRlVWludDE2QXJyYXkodGhpcy5vcGNvbG9yKTtcbiAgfSwgbi5jdHRzQm94LnByb3RvdHlwZS51bnBhY2sgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGksIHM7XG4gICAgZm9yIChzID0gMCwgZSA9IDA7IGUgPCB0aGlzLnNhbXBsZV9jb3VudHMubGVuZ3RoOyBlKyspXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zYW1wbGVfY291bnRzW2VdOyBpKyspXG4gICAgICAgIHRbc10ucHRzID0gdFtzXS5kdHMgKyB0aGlzLnNhbXBsZV9vZmZzZXRzW2VdLCBzKys7XG4gIH0sIG4uc3R0c0JveC5wcm90b3R5cGUudW5wYWNrID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpLCBzO1xuICAgIGZvciAocyA9IDAsIGUgPSAwOyBlIDwgdGhpcy5zYW1wbGVfY291bnRzLmxlbmd0aDsgZSsrKVxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2FtcGxlX2NvdW50c1tlXTsgaSsrKVxuICAgICAgICBzID09PSAwID8gdFtzXS5kdHMgPSAwIDogdFtzXS5kdHMgPSB0W3MgLSAxXS5kdHMgKyB0aGlzLnNhbXBsZV9kZWx0YXNbZV0sIHMrKztcbiAgfSwgbi5zdGNvQm94LnByb3RvdHlwZS51bnBhY2sgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgZm9yIChlID0gMDsgZSA8IHRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGg7IGUrKylcbiAgICAgIHRbZV0ub2Zmc2V0ID0gdGhpcy5jaHVua19vZmZzZXRzW2VdO1xuICB9LCBuLnN0c2NCb3gucHJvdG90eXBlLnVucGFjayA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSwgcywgbywgYztcbiAgICBmb3IgKG8gPSAwLCBjID0gMCwgZSA9IDA7IGUgPCB0aGlzLmZpcnN0X2NodW5rLmxlbmd0aDsgZSsrKVxuICAgICAgZm9yIChpID0gMDsgaSA8IChlICsgMSA8IHRoaXMuZmlyc3RfY2h1bmsubGVuZ3RoID8gdGhpcy5maXJzdF9jaHVua1tlICsgMV0gOiAxIC8gMCk7IGkrKylcbiAgICAgICAgZm9yIChjKyssIHMgPSAwOyBzIDwgdGhpcy5zYW1wbGVzX3Blcl9jaHVua1tlXTsgcysrKSB7XG4gICAgICAgICAgaWYgKHRbb10pXG4gICAgICAgICAgICB0W29dLmRlc2NyaXB0aW9uX2luZGV4ID0gdGhpcy5zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhbZV0sIHRbb10uY2h1bmtfaW5kZXggPSBjO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBvKys7XG4gICAgICAgIH1cbiAgfSwgbi5zdHN6Qm94LnByb3RvdHlwZS51bnBhY2sgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgZm9yIChlID0gMDsgZSA8IHRoaXMuc2FtcGxlX3NpemVzLmxlbmd0aDsgZSsrKVxuICAgICAgdFtlXS5zaXplID0gdGhpcy5zYW1wbGVfc2l6ZXNbZV07XG4gIH0sIG4uRElGRl9CT1hFU19QUk9QX05BTUVTID0gW1xuICAgIFwiYm94ZXNcIixcbiAgICBcImVudHJpZXNcIixcbiAgICBcInJlZmVyZW5jZXNcIixcbiAgICBcInN1YnNhbXBsZXNcIixcbiAgICBcIml0ZW1zXCIsXG4gICAgXCJpdGVtX2luZm9zXCIsXG4gICAgXCJleHRlbnRzXCIsXG4gICAgXCJhc3NvY2lhdGlvbnNcIixcbiAgICBcInN1YnNlZ21lbnRzXCIsXG4gICAgXCJyYW5nZXNcIixcbiAgICBcInNlZWtMaXN0c1wiLFxuICAgIFwic2Vla1BvaW50c1wiLFxuICAgIFwiZXNkXCIsXG4gICAgXCJsZXZlbHNcIlxuICBdLCBuLkRJRkZfUFJJTUlUSVZFX0FSUkFZX1BST1BfTkFNRVMgPSBbXG4gICAgXCJjb21wYXRpYmxlX2JyYW5kc1wiLFxuICAgIFwibWF0cml4XCIsXG4gICAgXCJvcGNvbG9yXCIsXG4gICAgXCJzYW1wbGVfY291bnRzXCIsXG4gICAgXCJzYW1wbGVfY291bnRzXCIsXG4gICAgXCJzYW1wbGVfZGVsdGFzXCIsXG4gICAgXCJmaXJzdF9jaHVua1wiLFxuICAgIFwic2FtcGxlc19wZXJfY2h1bmtcIixcbiAgICBcInNhbXBsZV9zaXplc1wiLFxuICAgIFwiY2h1bmtfb2Zmc2V0c1wiLFxuICAgIFwic2FtcGxlX29mZnNldHNcIixcbiAgICBcInNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFwiLFxuICAgIFwic2FtcGxlX2R1cmF0aW9uXCJcbiAgXSwgbi5ib3hFcXVhbEZpZWxkcyA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICBpZiAodCAmJiAhZSkgcmV0dXJuICExO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSBpbiB0KVxuICAgICAgaWYgKCEobi5ESUZGX0JPWEVTX1BST1BfTkFNRVMuaW5kZXhPZihpKSA+IC0xKSkge1xuICAgICAgICBpZiAodFtpXSBpbnN0YW5jZW9mIG4uQm94IHx8IGVbaV0gaW5zdGFuY2VvZiBuLkJveClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0W2ldID4gXCJ1XCIgfHwgdHlwZW9mIGVbaV0gPiBcInVcIilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0W2ldID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgZVtpXSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0LnN1YkJveE5hbWVzICYmIHQuc3ViQm94TmFtZXMuaW5kZXhPZihpLnNsaWNlKDAsIDQpKSA+IC0xIHx8IGUuc3ViQm94TmFtZXMgJiYgZS5zdWJCb3hOYW1lcy5pbmRleE9mKGkuc2xpY2UoMCwgNCkpID4gLTEpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChpID09PSBcImRhdGFcIiB8fCBpID09PSBcInN0YXJ0XCIgfHwgaSA9PT0gXCJzaXplXCIgfHwgaSA9PT0gXCJjcmVhdGlvbl90aW1lXCIgfHwgaSA9PT0gXCJtb2RpZmljYXRpb25fdGltZVwiKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobi5ESUZGX1BSSU1JVElWRV9BUlJBWV9QUk9QX05BTUVTLmluZGV4T2YoaSkgPiAtMSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHRbaV0gIT09IGVbaV0pXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIHJldHVybiAhMDtcbiAgfSwgbi5ib3hFcXVhbCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICBpZiAoIW4uYm94RXF1YWxGaWVsZHModCwgZSkpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLkRJRkZfQk9YRVNfUFJPUF9OQU1FUy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHMgPSBuLkRJRkZfQk9YRVNfUFJPUF9OQU1FU1tpXTtcbiAgICAgIGlmICh0W3NdICYmIGVbc10gJiYgIW4uYm94RXF1YWwodFtzXSwgZVtzXSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9O1xuICB2YXIgdiA9IGZ1bmN0aW9uKCkge1xuICB9O1xuICB2LnByb3RvdHlwZS5wYXJzZVNhbXBsZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHt9LCBpO1xuICAgIGUucmVzb3VyY2VzID0gW107XG4gICAgdmFyIHMgPSBuZXcgaCh0LmRhdGEuYnVmZmVyKTtcbiAgICBpZiAoIXQuc3Vic2FtcGxlcyB8fCB0LnN1YnNhbXBsZXMubGVuZ3RoID09PSAwKVxuICAgICAgZS5kb2N1bWVudFN0cmluZyA9IHMucmVhZFN0cmluZyh0LmRhdGEubGVuZ3RoKTtcbiAgICBlbHNlIGlmIChlLmRvY3VtZW50U3RyaW5nID0gcy5yZWFkU3RyaW5nKHQuc3Vic2FtcGxlc1swXS5zaXplKSwgdC5zdWJzYW1wbGVzLmxlbmd0aCA+IDEpXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgdC5zdWJzYW1wbGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBlLnJlc291cmNlc1tpXSA9IHMucmVhZFVpbnQ4QXJyYXkodC5zdWJzYW1wbGVzW2ldLnNpemUpO1xuICAgIHJldHVybiB0eXBlb2YgRE9NUGFyc2VyIDwgXCJ1XCIgJiYgKGUuZG9jdW1lbnQgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGUuZG9jdW1lbnRTdHJpbmcsIFwiYXBwbGljYXRpb24veG1sXCIpKSwgZTtcbiAgfTtcbiAgdmFyIGIgPSBmdW5jdGlvbigpIHtcbiAgfTtcbiAgYi5wcm90b3R5cGUucGFyc2VTYW1wbGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGkgPSBuZXcgaCh0LmRhdGEuYnVmZmVyKTtcbiAgICByZXR1cm4gZSA9IGkucmVhZFN0cmluZyh0LmRhdGEubGVuZ3RoKSwgZTtcbiAgfSwgYi5wcm90b3R5cGUucGFyc2VDb25maWcgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGkgPSBuZXcgaCh0LmJ1ZmZlcik7XG4gICAgcmV0dXJuIGkucmVhZFVpbnQzMigpLCBlID0gaS5yZWFkQ1N0cmluZygpLCBlO1xuICB9LCBsLlhNTFN1YnRpdGxlaW40UGFyc2VyID0gdiwgbC5UZXh0aW40UGFyc2VyID0gYjtcbiAgdmFyIHkgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zdHJlYW0gPSB0IHx8IG5ldyBkKCksIHRoaXMuYm94ZXMgPSBbXSwgdGhpcy5tZGF0cyA9IFtdLCB0aGlzLm1vb2ZzID0gW10sIHRoaXMuaXNQcm9ncmVzc2l2ZSA9ICExLCB0aGlzLm1vb3ZTdGFydEZvdW5kID0gITEsIHRoaXMub25Nb292U3RhcnQgPSBudWxsLCB0aGlzLm1vb3ZTdGFydFNlbnQgPSAhMSwgdGhpcy5vblJlYWR5ID0gbnVsbCwgdGhpcy5yZWFkeVNlbnQgPSAhMSwgdGhpcy5vblNlZ21lbnQgPSBudWxsLCB0aGlzLm9uU2FtcGxlcyA9IG51bGwsIHRoaXMub25FcnJvciA9IG51bGwsIHRoaXMuc2FtcGxlTGlzdEJ1aWx0ID0gITEsIHRoaXMuZnJhZ21lbnRlZFRyYWNrcyA9IFtdLCB0aGlzLmV4dHJhY3RlZFRyYWNrcyA9IFtdLCB0aGlzLmlzRnJhZ21lbnRhdGlvbkluaXRpYWxpemVkID0gITEsIHRoaXMuc2FtcGxlUHJvY2Vzc2luZ1N0YXJ0ZWQgPSAhMSwgdGhpcy5uZXh0TW9vZk51bWJlciA9IDAsIHRoaXMuaXRlbUxpc3RCdWlsdCA9ICExLCB0aGlzLm9uU2lkeCA9IG51bGwsIHRoaXMuc2lkeFNlbnQgPSAhMTtcbiAgfTtcbiAgeS5wcm90b3R5cGUuc2V0U2VnbWVudE9wdGlvbnMgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgdmFyIHMgPSB0aGlzLmdldFRyYWNrQnlJZCh0KTtcbiAgICBpZiAocykge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIHRoaXMuZnJhZ21lbnRlZFRyYWNrcy5wdXNoKG8pLCBvLmlkID0gdCwgby51c2VyID0gZSwgby50cmFrID0gcywgcy5uZXh0U2FtcGxlID0gMCwgby5zZWdtZW50U3RyZWFtID0gbnVsbCwgby5uYl9zYW1wbGVzID0gMWUzLCBvLnJhcEFsaWduZW1lbnQgPSAhMCwgaSAmJiAoaS5uYlNhbXBsZXMgJiYgKG8ubmJfc2FtcGxlcyA9IGkubmJTYW1wbGVzKSwgaS5yYXBBbGlnbmVtZW50ICYmIChvLnJhcEFsaWduZW1lbnQgPSBpLnJhcEFsaWduZW1lbnQpKTtcbiAgICB9XG4gIH0sIHkucHJvdG90eXBlLnVuc2V0U2VnbWVudE9wdGlvbnMgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IC0xLCBpID0gMDsgaSA8IHRoaXMuZnJhZ21lbnRlZFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHMgPSB0aGlzLmZyYWdtZW50ZWRUcmFja3NbaV07XG4gICAgICBzLmlkID09IHQgJiYgKGUgPSBpKTtcbiAgICB9XG4gICAgZSA+IC0xICYmIHRoaXMuZnJhZ21lbnRlZFRyYWNrcy5zcGxpY2UoZSwgMSk7XG4gIH0sIHkucHJvdG90eXBlLnNldEV4dHJhY3Rpb25PcHRpb25zID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICAgIHZhciBzID0gdGhpcy5nZXRUcmFja0J5SWQodCk7XG4gICAgaWYgKHMpIHtcbiAgICAgIHZhciBvID0ge307XG4gICAgICB0aGlzLmV4dHJhY3RlZFRyYWNrcy5wdXNoKG8pLCBvLmlkID0gdCwgby51c2VyID0gZSwgby50cmFrID0gcywgcy5uZXh0U2FtcGxlID0gMCwgby5uYl9zYW1wbGVzID0gMWUzLCBvLnNhbXBsZXMgPSBbXSwgaSAmJiBpLm5iU2FtcGxlcyAmJiAoby5uYl9zYW1wbGVzID0gaS5uYlNhbXBsZXMpO1xuICAgIH1cbiAgfSwgeS5wcm90b3R5cGUudW5zZXRFeHRyYWN0aW9uT3B0aW9ucyA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gLTEsIGkgPSAwOyBpIDwgdGhpcy5leHRyYWN0ZWRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzID0gdGhpcy5leHRyYWN0ZWRUcmFja3NbaV07XG4gICAgICBzLmlkID09IHQgJiYgKGUgPSBpKTtcbiAgICB9XG4gICAgZSA+IC0xICYmIHRoaXMuZXh0cmFjdGVkVHJhY2tzLnNwbGljZShlLCAxKTtcbiAgfSwgeS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCwgZSwgaSA9ICExO1xuICAgIGlmICghKHRoaXMucmVzdG9yZVBhcnNlUG9zaXRpb24gJiYgIXRoaXMucmVzdG9yZVBhcnNlUG9zaXRpb24oKSkpXG4gICAgICBmb3IgKDsgOyApXG4gICAgICAgIGlmICh0aGlzLmhhc0luY29tcGxldGVNZGF0ICYmIHRoaXMuaGFzSW5jb21wbGV0ZU1kYXQoKSkge1xuICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NJbmNvbXBsZXRlTWRhdCgpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2F2ZVBhcnNlUG9zaXRpb24gJiYgdGhpcy5zYXZlUGFyc2VQb3NpdGlvbigpLCB0ID0gbi5wYXJzZU9uZUJveCh0aGlzLnN0cmVhbSwgaSksIHQuY29kZSA9PT0gbi5FUlJfTk9UX0VOT1VHSF9EQVRBKVxuICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NJbmNvbXBsZXRlQm94KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzSW5jb21wbGV0ZUJveCh0KSlcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBzO1xuICAgICAgICAgIHN3aXRjaCAoZSA9IHQuYm94LCBzID0gZS50eXBlICE9PSBcInV1aWRcIiA/IGUudHlwZSA6IGUudXVpZCwgdGhpcy5ib3hlcy5wdXNoKGUpLCBzKSB7XG4gICAgICAgICAgICBjYXNlIFwibWRhdFwiOlxuICAgICAgICAgICAgICB0aGlzLm1kYXRzLnB1c2goZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1vb2ZcIjpcbiAgICAgICAgICAgICAgdGhpcy5tb29mcy5wdXNoKGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtb292XCI6XG4gICAgICAgICAgICAgIHRoaXMubW9vdlN0YXJ0Rm91bmQgPSAhMCwgdGhpcy5tZGF0cy5sZW5ndGggPT09IDAgJiYgKHRoaXMuaXNQcm9ncmVzc2l2ZSA9ICEwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXNbc10gIT09IHZvaWQgMCAmJiByLndhcm4oXCJJU09GaWxlXCIsIFwiRHVwbGljYXRlIEJveCBvZiB0eXBlOiBcIiArIHMgKyBcIiwgb3ZlcnJpZGluZyBwcmV2aW91cyBvY2N1cnJlbmNlXCIpLCB0aGlzW3NdID0gZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudXBkYXRlVXNlZEJ5dGVzICYmIHRoaXMudXBkYXRlVXNlZEJ5dGVzKGUsIHQpO1xuICAgICAgICB9XG4gIH0sIHkucHJvdG90eXBlLmNoZWNrQnVmZmVyID0gZnVuY3Rpb24odCkge1xuICAgIGlmICh0ID09IG51bGwpXG4gICAgICB0aHJvdyBcIkJ1ZmZlciBtdXN0IGJlIGRlZmluZWQgYW5kIG5vbiBlbXB0eVwiO1xuICAgIGlmICh0LmZpbGVTdGFydCA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgXCJCdWZmZXIgbXVzdCBoYXZlIGEgZmlsZVN0YXJ0IHByb3BlcnR5XCI7XG4gICAgcmV0dXJuIHQuYnl0ZUxlbmd0aCA9PT0gMCA/IChyLndhcm4oXCJJU09GaWxlXCIsIFwiSWdub3JpbmcgZW1wdHkgYnVmZmVyIChmaWxlU3RhcnQ6IFwiICsgdC5maWxlU3RhcnQgKyBcIilcIiksIHRoaXMuc3RyZWFtLmxvZ0J1ZmZlckxldmVsKCksICExKSA6IChyLmluZm8oXCJJU09GaWxlXCIsIFwiUHJvY2Vzc2luZyBidWZmZXIgKGZpbGVTdGFydDogXCIgKyB0LmZpbGVTdGFydCArIFwiKVwiKSwgdC51c2VkQnl0ZXMgPSAwLCB0aGlzLnN0cmVhbS5pbnNlcnRCdWZmZXIodCksIHRoaXMuc3RyZWFtLmxvZ0J1ZmZlckxldmVsKCksIHRoaXMuc3RyZWFtLmluaXRpYWxpemVkKCkgPyAhMCA6IChyLndhcm4oXCJJU09GaWxlXCIsIFwiTm90IHJlYWR5IHRvIHN0YXJ0IHBhcnNpbmdcIiksICExKSk7XG4gIH0sIHkucHJvdG90eXBlLmFwcGVuZEJ1ZmZlciA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAodGhpcy5jaGVja0J1ZmZlcih0KSlcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlKCksIHRoaXMubW9vdlN0YXJ0Rm91bmQgJiYgIXRoaXMubW9vdlN0YXJ0U2VudCAmJiAodGhpcy5tb292U3RhcnRTZW50ID0gITAsIHRoaXMub25Nb292U3RhcnQgJiYgdGhpcy5vbk1vb3ZTdGFydCgpKSwgdGhpcy5tb292ID8gKHRoaXMuc2FtcGxlTGlzdEJ1aWx0IHx8ICh0aGlzLmJ1aWxkU2FtcGxlTGlzdHMoKSwgdGhpcy5zYW1wbGVMaXN0QnVpbHQgPSAhMCksIHRoaXMudXBkYXRlU2FtcGxlTGlzdHMoKSwgdGhpcy5vblJlYWR5ICYmICF0aGlzLnJlYWR5U2VudCAmJiAodGhpcy5yZWFkeVNlbnQgPSAhMCwgdGhpcy5vblJlYWR5KHRoaXMuZ2V0SW5mbygpKSksIHRoaXMucHJvY2Vzc1NhbXBsZXMoZSksIHRoaXMubmV4dFNlZWtQb3NpdGlvbiA/IChpID0gdGhpcy5uZXh0U2Vla1Bvc2l0aW9uLCB0aGlzLm5leHRTZWVrUG9zaXRpb24gPSB2b2lkIDApIDogaSA9IHRoaXMubmV4dFBhcnNlUG9zaXRpb24sIHRoaXMuc3RyZWFtLmdldEVuZEZpbGVQb3NpdGlvbkFmdGVyICYmIChpID0gdGhpcy5zdHJlYW0uZ2V0RW5kRmlsZVBvc2l0aW9uQWZ0ZXIoaSkpKSA6IHRoaXMubmV4dFBhcnNlUG9zaXRpb24gPyBpID0gdGhpcy5uZXh0UGFyc2VQb3NpdGlvbiA6IGkgPSAwLCB0aGlzLnNpZHggJiYgdGhpcy5vblNpZHggJiYgIXRoaXMuc2lkeFNlbnQgJiYgKHRoaXMub25TaWR4KHRoaXMuc2lkeCksIHRoaXMuc2lkeFNlbnQgPSAhMCksIHRoaXMubWV0YSAmJiAodGhpcy5mbGF0dGVuSXRlbUluZm8gJiYgIXRoaXMuaXRlbUxpc3RCdWlsdCAmJiAodGhpcy5mbGF0dGVuSXRlbUluZm8oKSwgdGhpcy5pdGVtTGlzdEJ1aWx0ID0gITApLCB0aGlzLnByb2Nlc3NJdGVtcyAmJiB0aGlzLnByb2Nlc3NJdGVtcyh0aGlzLm9uSXRlbSkpLCB0aGlzLnN0cmVhbS5jbGVhbkJ1ZmZlcnMgJiYgKHIuaW5mbyhcIklTT0ZpbGVcIiwgXCJEb25lIHByb2Nlc3NpbmcgYnVmZmVyIChmaWxlU3RhcnQ6IFwiICsgdC5maWxlU3RhcnQgKyBcIikgLSBuZXh0IGJ1ZmZlciB0byBmZXRjaCBzaG91bGQgaGF2ZSBhIGZpbGVTdGFydCBwb3NpdGlvbiBvZiBcIiArIGkpLCB0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCgpLCB0aGlzLnN0cmVhbS5jbGVhbkJ1ZmZlcnMoKSwgdGhpcy5zdHJlYW0ubG9nQnVmZmVyTGV2ZWwoITApLCByLmluZm8oXCJJU09GaWxlXCIsIFwiU2FtcGxlIGRhdGEgc2l6ZSBpbiBtZW1vcnk6IFwiICsgdGhpcy5nZXRBbGxvY2F0ZWRTYW1wbGVEYXRhU2l6ZSgpKSksIGk7XG4gIH0sIHkucHJvdG90eXBlLmdldEluZm8gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCwgZSwgaSA9IHt9LCBzLCBvLCBjLCB1LCBfID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZShcIjE5MDQtMDEtMDFUMDA6MDA6MDBaXCIpKS5nZXRUaW1lKCk7XG4gICAgaWYgKHRoaXMubW9vdilcbiAgICAgIGZvciAoaS5oYXNNb292ID0gITAsIGkuZHVyYXRpb24gPSB0aGlzLm1vb3YubXZoZC5kdXJhdGlvbiwgaS50aW1lc2NhbGUgPSB0aGlzLm1vb3YubXZoZC50aW1lc2NhbGUsIGkuaXNGcmFnbWVudGVkID0gdGhpcy5tb292Lm12ZXggIT0gbnVsbCwgaS5pc0ZyYWdtZW50ZWQgJiYgdGhpcy5tb292Lm12ZXgubWVoZCAmJiAoaS5mcmFnbWVudF9kdXJhdGlvbiA9IHRoaXMubW9vdi5tdmV4Lm1laGQuZnJhZ21lbnRfZHVyYXRpb24pLCBpLmlzUHJvZ3Jlc3NpdmUgPSB0aGlzLmlzUHJvZ3Jlc3NpdmUsIGkuaGFzSU9EID0gdGhpcy5tb292LmlvZHMgIT0gbnVsbCwgaS5icmFuZHMgPSBbXSwgaS5icmFuZHMucHVzaCh0aGlzLmZ0eXAubWFqb3JfYnJhbmQpLCBpLmJyYW5kcyA9IGkuYnJhbmRzLmNvbmNhdCh0aGlzLmZ0eXAuY29tcGF0aWJsZV9icmFuZHMpLCBpLmNyZWF0ZWQgPSBuZXcgRGF0ZShfICsgdGhpcy5tb292Lm12aGQuY3JlYXRpb25fdGltZSAqIDFlMyksIGkubW9kaWZpZWQgPSBuZXcgRGF0ZShfICsgdGhpcy5tb292Lm12aGQubW9kaWZpY2F0aW9uX3RpbWUgKiAxZTMpLCBpLnRyYWNrcyA9IFtdLCBpLmF1ZGlvVHJhY2tzID0gW10sIGkudmlkZW9UcmFja3MgPSBbXSwgaS5zdWJ0aXRsZVRyYWNrcyA9IFtdLCBpLm1ldGFkYXRhVHJhY2tzID0gW10sIGkuaGludFRyYWNrcyA9IFtdLCBpLm90aGVyVHJhY2tzID0gW10sIHQgPSAwOyB0IDwgdGhpcy5tb292LnRyYWtzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIGlmIChzID0gdGhpcy5tb292LnRyYWtzW3RdLCB1ID0gcy5tZGlhLm1pbmYuc3RibC5zdHNkLmVudHJpZXNbMF0sIG8gPSB7fSwgaS50cmFja3MucHVzaChvKSwgby5pZCA9IHMudGtoZC50cmFja19pZCwgby5uYW1lID0gcy5tZGlhLmhkbHIubmFtZSwgby5yZWZlcmVuY2VzID0gW10sIHMudHJlZilcbiAgICAgICAgICBmb3IgKGUgPSAwOyBlIDwgcy50cmVmLmJveGVzLmxlbmd0aDsgZSsrKVxuICAgICAgICAgICAgYyA9IHt9LCBvLnJlZmVyZW5jZXMucHVzaChjKSwgYy50eXBlID0gcy50cmVmLmJveGVzW2VdLnR5cGUsIGMudHJhY2tfaWRzID0gcy50cmVmLmJveGVzW2VdLnRyYWNrX2lkcztcbiAgICAgICAgcy5lZHRzICYmIChvLmVkaXRzID0gcy5lZHRzLmVsc3QuZW50cmllcyksIG8uY3JlYXRlZCA9IG5ldyBEYXRlKF8gKyBzLnRraGQuY3JlYXRpb25fdGltZSAqIDFlMyksIG8ubW9kaWZpZWQgPSBuZXcgRGF0ZShfICsgcy50a2hkLm1vZGlmaWNhdGlvbl90aW1lICogMWUzKSwgby5tb3ZpZV9kdXJhdGlvbiA9IHMudGtoZC5kdXJhdGlvbiwgby5tb3ZpZV90aW1lc2NhbGUgPSBpLnRpbWVzY2FsZSwgby5sYXllciA9IHMudGtoZC5sYXllciwgby5hbHRlcm5hdGVfZ3JvdXAgPSBzLnRraGQuYWx0ZXJuYXRlX2dyb3VwLCBvLnZvbHVtZSA9IHMudGtoZC52b2x1bWUsIG8ubWF0cml4ID0gcy50a2hkLm1hdHJpeCwgby50cmFja193aWR0aCA9IHMudGtoZC53aWR0aCAvIDY1NTM2LCBvLnRyYWNrX2hlaWdodCA9IHMudGtoZC5oZWlnaHQgLyA2NTUzNiwgby50aW1lc2NhbGUgPSBzLm1kaWEubWRoZC50aW1lc2NhbGUsIG8uY3RzX3NoaWZ0ID0gcy5tZGlhLm1pbmYuc3RibC5jc2xnLCBvLmR1cmF0aW9uID0gcy5tZGlhLm1kaGQuZHVyYXRpb24sIG8uc2FtcGxlc19kdXJhdGlvbiA9IHMuc2FtcGxlc19kdXJhdGlvbiwgby5jb2RlYyA9IHUuZ2V0Q29kZWMoKSwgby5raW5kID0gcy51ZHRhICYmIHMudWR0YS5raW5kcy5sZW5ndGggPyBzLnVkdGEua2luZHNbMF0gOiB7IHNjaGVtZVVSSTogXCJcIiwgdmFsdWU6IFwiXCIgfSwgby5sYW5ndWFnZSA9IHMubWRpYS5lbG5nID8gcy5tZGlhLmVsbmcuZXh0ZW5kZWRfbGFuZ3VhZ2UgOiBzLm1kaWEubWRoZC5sYW5ndWFnZVN0cmluZywgby5uYl9zYW1wbGVzID0gcy5zYW1wbGVzLmxlbmd0aCwgby5zaXplID0gcy5zYW1wbGVzX3NpemUsIG8uYml0cmF0ZSA9IG8uc2l6ZSAqIDggKiBvLnRpbWVzY2FsZSAvIG8uc2FtcGxlc19kdXJhdGlvbiwgdS5pc0F1ZGlvKCkgPyAoby50eXBlID0gXCJhdWRpb1wiLCBpLmF1ZGlvVHJhY2tzLnB1c2gobyksIG8uYXVkaW8gPSB7fSwgby5hdWRpby5zYW1wbGVfcmF0ZSA9IHUuZ2V0U2FtcGxlUmF0ZSgpLCBvLmF1ZGlvLmNoYW5uZWxfY291bnQgPSB1LmdldENoYW5uZWxDb3VudCgpLCBvLmF1ZGlvLnNhbXBsZV9zaXplID0gdS5nZXRTYW1wbGVTaXplKCkpIDogdS5pc1ZpZGVvKCkgPyAoby50eXBlID0gXCJ2aWRlb1wiLCBpLnZpZGVvVHJhY2tzLnB1c2gobyksIG8udmlkZW8gPSB7fSwgby52aWRlby53aWR0aCA9IHUuZ2V0V2lkdGgoKSwgby52aWRlby5oZWlnaHQgPSB1LmdldEhlaWdodCgpKSA6IHUuaXNTdWJ0aXRsZSgpID8gKG8udHlwZSA9IFwic3VidGl0bGVzXCIsIGkuc3VidGl0bGVUcmFja3MucHVzaChvKSkgOiB1LmlzSGludCgpID8gKG8udHlwZSA9IFwibWV0YWRhdGFcIiwgaS5oaW50VHJhY2tzLnB1c2gobykpIDogdS5pc01ldGFkYXRhKCkgPyAoby50eXBlID0gXCJtZXRhZGF0YVwiLCBpLm1ldGFkYXRhVHJhY2tzLnB1c2gobykpIDogKG8udHlwZSA9IFwibWV0YWRhdGFcIiwgaS5vdGhlclRyYWNrcy5wdXNoKG8pKTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBpLmhhc01vb3YgPSAhMTtcbiAgICBpZiAoaS5taW1lID0gXCJcIiwgaS5oYXNNb292ICYmIGkudHJhY2tzKSB7XG4gICAgICBmb3IgKGkudmlkZW9UcmFja3MgJiYgaS52aWRlb1RyYWNrcy5sZW5ndGggPiAwID8gaS5taW1lICs9ICd2aWRlby9tcDQ7IGNvZGVjcz1cIicgOiBpLmF1ZGlvVHJhY2tzICYmIGkuYXVkaW9UcmFja3MubGVuZ3RoID4gMCA/IGkubWltZSArPSAnYXVkaW8vbXA0OyBjb2RlY3M9XCInIDogaS5taW1lICs9ICdhcHBsaWNhdGlvbi9tcDQ7IGNvZGVjcz1cIicsIHQgPSAwOyB0IDwgaS50cmFja3MubGVuZ3RoOyB0KyspXG4gICAgICAgIHQgIT09IDAgJiYgKGkubWltZSArPSBcIixcIiksIGkubWltZSArPSBpLnRyYWNrc1t0XS5jb2RlYztcbiAgICAgIGkubWltZSArPSAnXCI7IHByb2ZpbGVzPVwiJywgaS5taW1lICs9IHRoaXMuZnR5cC5jb21wYXRpYmxlX2JyYW5kcy5qb2luKCksIGkubWltZSArPSAnXCInO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfSwgeS5wcm90b3R5cGUucHJvY2Vzc1NhbXBsZXMgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGk7XG4gICAgaWYgKHRoaXMuc2FtcGxlUHJvY2Vzc2luZ1N0YXJ0ZWQpIHtcbiAgICAgIGlmICh0aGlzLmlzRnJhZ21lbnRhdGlvbkluaXRpYWxpemVkICYmIHRoaXMub25TZWdtZW50ICE9PSBudWxsKVxuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgdGhpcy5mcmFnbWVudGVkVHJhY2tzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgdmFyIHMgPSB0aGlzLmZyYWdtZW50ZWRUcmFja3NbZV07XG4gICAgICAgICAgZm9yIChpID0gcy50cmFrOyBpLm5leHRTYW1wbGUgPCBpLnNhbXBsZXMubGVuZ3RoICYmIHRoaXMuc2FtcGxlUHJvY2Vzc2luZ1N0YXJ0ZWQ7ICkge1xuICAgICAgICAgICAgci5kZWJ1ZyhcIklTT0ZpbGVcIiwgXCJDcmVhdGluZyBtZWRpYSBmcmFnbWVudCBvbiB0cmFjayAjXCIgKyBzLmlkICsgXCIgZm9yIHNhbXBsZSBcIiArIGkubmV4dFNhbXBsZSk7XG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMuY3JlYXRlRnJhZ21lbnQocy5pZCwgaS5uZXh0U2FtcGxlLCBzLnNlZ21lbnRTdHJlYW0pO1xuICAgICAgICAgICAgaWYgKG8pXG4gICAgICAgICAgICAgIHMuc2VnbWVudFN0cmVhbSA9IG8sIGkubmV4dFNhbXBsZSsrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICgoaS5uZXh0U2FtcGxlICUgcy5uYl9zYW1wbGVzID09PSAwIHx8IHQgfHwgaS5uZXh0U2FtcGxlID49IGkuc2FtcGxlcy5sZW5ndGgpICYmIChyLmluZm8oXCJJU09GaWxlXCIsIFwiU2VuZGluZyBmcmFnbWVudGVkIGRhdGEgb24gdHJhY2sgI1wiICsgcy5pZCArIFwiIGZvciBzYW1wbGVzIFtcIiArIE1hdGgubWF4KDAsIGkubmV4dFNhbXBsZSAtIHMubmJfc2FtcGxlcykgKyBcIixcIiArIChpLm5leHRTYW1wbGUgLSAxKSArIFwiXVwiKSwgci5pbmZvKFwiSVNPRmlsZVwiLCBcIlNhbXBsZSBkYXRhIHNpemUgaW4gbWVtb3J5OiBcIiArIHRoaXMuZ2V0QWxsb2NhdGVkU2FtcGxlRGF0YVNpemUoKSksIHRoaXMub25TZWdtZW50ICYmIHRoaXMub25TZWdtZW50KHMuaWQsIHMudXNlciwgcy5zZWdtZW50U3RyZWFtLmJ1ZmZlciwgaS5uZXh0U2FtcGxlLCB0IHx8IGkubmV4dFNhbXBsZSA+PSBpLnNhbXBsZXMubGVuZ3RoKSwgcy5zZWdtZW50U3RyZWFtID0gbnVsbCwgcyAhPT0gdGhpcy5mcmFnbWVudGVkVHJhY2tzW2VdKSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBpZiAodGhpcy5vblNhbXBsZXMgIT09IG51bGwpXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCB0aGlzLmV4dHJhY3RlZFRyYWNrcy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgIHZhciBjID0gdGhpcy5leHRyYWN0ZWRUcmFja3NbZV07XG4gICAgICAgICAgZm9yIChpID0gYy50cmFrOyBpLm5leHRTYW1wbGUgPCBpLnNhbXBsZXMubGVuZ3RoICYmIHRoaXMuc2FtcGxlUHJvY2Vzc2luZ1N0YXJ0ZWQ7ICkge1xuICAgICAgICAgICAgci5kZWJ1ZyhcIklTT0ZpbGVcIiwgXCJFeHBvcnRpbmcgb24gdHJhY2sgI1wiICsgYy5pZCArIFwiIHNhbXBsZSAjXCIgKyBpLm5leHRTYW1wbGUpO1xuICAgICAgICAgICAgdmFyIHUgPSB0aGlzLmdldFNhbXBsZShpLCBpLm5leHRTYW1wbGUpO1xuICAgICAgICAgICAgaWYgKHUpXG4gICAgICAgICAgICAgIGkubmV4dFNhbXBsZSsrLCBjLnNhbXBsZXMucHVzaCh1KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoKGkubmV4dFNhbXBsZSAlIGMubmJfc2FtcGxlcyA9PT0gMCB8fCBpLm5leHRTYW1wbGUgPj0gaS5zYW1wbGVzLmxlbmd0aCkgJiYgKHIuZGVidWcoXCJJU09GaWxlXCIsIFwiU2VuZGluZyBzYW1wbGVzIG9uIHRyYWNrICNcIiArIGMuaWQgKyBcIiBmb3Igc2FtcGxlIFwiICsgaS5uZXh0U2FtcGxlKSwgdGhpcy5vblNhbXBsZXMgJiYgdGhpcy5vblNhbXBsZXMoYy5pZCwgYy51c2VyLCBjLnNhbXBsZXMpLCBjLnNhbXBsZXMgPSBbXSwgYyAhPT0gdGhpcy5leHRyYWN0ZWRUcmFja3NbZV0pKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH0sIHkucHJvdG90eXBlLmdldEJveCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHRoaXMuZ2V0Qm94ZXModCwgITApO1xuICAgIHJldHVybiBlLmxlbmd0aCA/IGVbMF0gOiBudWxsO1xuICB9LCB5LnByb3RvdHlwZS5nZXRCb3hlcyA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB2YXIgaSA9IFtdO1xuICAgIHJldHVybiB5Ll9zd2VlcC5jYWxsKHRoaXMsIHQsIGksIGUpLCBpO1xuICB9LCB5Ll9zd2VlcCA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICB0aGlzLnR5cGUgJiYgdGhpcy50eXBlID09IHQgJiYgZS5wdXNoKHRoaXMpO1xuICAgIGZvciAodmFyIHMgaW4gdGhpcy5ib3hlcykge1xuICAgICAgaWYgKGUubGVuZ3RoICYmIGkpIHJldHVybjtcbiAgICAgIHkuX3N3ZWVwLmNhbGwodGhpcy5ib3hlc1tzXSwgdCwgZSwgaSk7XG4gICAgfVxuICB9LCB5LnByb3RvdHlwZS5nZXRUcmFja1NhbXBsZXNJbmZvID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdGhpcy5nZXRUcmFja0J5SWQodCk7XG4gICAgaWYgKGUpXG4gICAgICByZXR1cm4gZS5zYW1wbGVzO1xuICB9LCB5LnByb3RvdHlwZS5nZXRUcmFja1NhbXBsZSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB2YXIgaSA9IHRoaXMuZ2V0VHJhY2tCeUlkKHQpLCBzID0gdGhpcy5nZXRTYW1wbGUoaSwgZSk7XG4gICAgcmV0dXJuIHM7XG4gIH0sIHkucHJvdG90eXBlLnJlbGVhc2VVc2VkU2FtcGxlcyA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB2YXIgaSA9IDAsIHMgPSB0aGlzLmdldFRyYWNrQnlJZCh0KTtcbiAgICBzLmxhc3RWYWxpZFNhbXBsZSB8fCAocy5sYXN0VmFsaWRTYW1wbGUgPSAwKTtcbiAgICBmb3IgKHZhciBvID0gcy5sYXN0VmFsaWRTYW1wbGU7IG8gPCBlOyBvKyspXG4gICAgICBpICs9IHRoaXMucmVsZWFzZVNhbXBsZShzLCBvKTtcbiAgICByLmluZm8oXCJJU09GaWxlXCIsIFwiVHJhY2sgI1wiICsgdCArIFwiIHJlbGVhc2VkIHNhbXBsZXMgdXAgdG8gXCIgKyBlICsgXCIgKHJlbGVhc2VkIHNpemU6IFwiICsgaSArIFwiLCByZW1haW5pbmc6IFwiICsgdGhpcy5zYW1wbGVzRGF0YVNpemUgKyBcIilcIiksIHMubGFzdFZhbGlkU2FtcGxlID0gZTtcbiAgfSwgeS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNhbXBsZVByb2Nlc3NpbmdTdGFydGVkID0gITAsIHRoaXMucHJvY2Vzc1NhbXBsZXMoITEpO1xuICB9LCB5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zYW1wbGVQcm9jZXNzaW5nU3RhcnRlZCA9ICExO1xuICB9LCB5LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHIuaW5mbyhcIklTT0ZpbGVcIiwgXCJGbHVzaGluZyByZW1haW5pbmcgc2FtcGxlc1wiKSwgdGhpcy51cGRhdGVTYW1wbGVMaXN0cygpLCB0aGlzLnByb2Nlc3NTYW1wbGVzKCEwKSwgdGhpcy5zdHJlYW0uY2xlYW5CdWZmZXJzKCksIHRoaXMuc3RyZWFtLmxvZ0J1ZmZlckxldmVsKCEwKTtcbiAgfSwgeS5wcm90b3R5cGUuc2Vla1RyYWNrID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICAgIHZhciBzLCBvLCBjID0gMSAvIDAsIHUgPSAwLCBfID0gMCwgZztcbiAgICBpZiAoaS5zYW1wbGVzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiByLmluZm8oXCJJU09GaWxlXCIsIFwiTm8gc2FtcGxlIGluIHRyYWNrLCBjYW5ub3Qgc2VlayEgVXNpbmcgdGltZSBcIiArIHIuZ2V0RHVyYXRpb25TdHJpbmcoMCwgMSkgKyBcIiBhbmQgb2Zmc2V0OiAwXCIpLCB7IG9mZnNldDogMCwgdGltZTogMCB9O1xuICAgIGZvciAocyA9IDA7IHMgPCBpLnNhbXBsZXMubGVuZ3RoOyBzKyspIHtcbiAgICAgIGlmIChvID0gaS5zYW1wbGVzW3NdLCBzID09PSAwKVxuICAgICAgICBfID0gMCwgZyA9IG8udGltZXNjYWxlO1xuICAgICAgZWxzZSBpZiAoby5jdHMgPiB0ICogby50aW1lc2NhbGUpIHtcbiAgICAgICAgXyA9IHMgLSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGUgJiYgby5pc19zeW5jICYmICh1ID0gcyk7XG4gICAgfVxuICAgIGZvciAoZSAmJiAoXyA9IHUpLCB0ID0gaS5zYW1wbGVzW19dLmN0cywgaS5uZXh0U2FtcGxlID0gXzsgaS5zYW1wbGVzW19dLmFscmVhZHlSZWFkID09PSBpLnNhbXBsZXNbX10uc2l6ZSAmJiBpLnNhbXBsZXNbXyArIDFdOyApXG4gICAgICBfKys7XG4gICAgcmV0dXJuIGMgPSBpLnNhbXBsZXNbX10ub2Zmc2V0ICsgaS5zYW1wbGVzW19dLmFscmVhZHlSZWFkLCByLmluZm8oXCJJU09GaWxlXCIsIFwiU2Vla2luZyB0byBcIiArIChlID8gXCJSQVBcIiA6IFwiXCIpICsgXCIgc2FtcGxlICNcIiArIGkubmV4dFNhbXBsZSArIFwiIG9uIHRyYWNrIFwiICsgaS50a2hkLnRyYWNrX2lkICsgXCIsIHRpbWUgXCIgKyByLmdldER1cmF0aW9uU3RyaW5nKHQsIGcpICsgXCIgYW5kIG9mZnNldDogXCIgKyBjKSwgeyBvZmZzZXQ6IGMsIHRpbWU6IHQgLyBnIH07XG4gIH0sIHkucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGkgPSB0aGlzLm1vb3YsIHMsIG8sIGMsIHUgPSB7IG9mZnNldDogMSAvIDAsIHRpbWU6IDEgLyAwIH07XG4gICAgaWYgKHRoaXMubW9vdikge1xuICAgICAgZm9yIChjID0gMDsgYyA8IGkudHJha3MubGVuZ3RoOyBjKyspXG4gICAgICAgIHMgPSBpLnRyYWtzW2NdLCBvID0gdGhpcy5zZWVrVHJhY2sodCwgZSwgcyksIG8ub2Zmc2V0IDwgdS5vZmZzZXQgJiYgKHUub2Zmc2V0ID0gby5vZmZzZXQpLCBvLnRpbWUgPCB1LnRpbWUgJiYgKHUudGltZSA9IG8udGltZSk7XG4gICAgICByZXR1cm4gci5pbmZvKFwiSVNPRmlsZVwiLCBcIlNlZWtpbmcgYXQgdGltZSBcIiArIHIuZ2V0RHVyYXRpb25TdHJpbmcodS50aW1lLCAxKSArIFwiIG5lZWRzIGEgYnVmZmVyIHdpdGggYSBmaWxlU3RhcnQgcG9zaXRpb24gb2YgXCIgKyB1Lm9mZnNldCksIHUub2Zmc2V0ID09PSAxIC8gMCA/IHUgPSB7IG9mZnNldDogdGhpcy5uZXh0UGFyc2VQb3NpdGlvbiwgdGltZTogMCB9IDogdS5vZmZzZXQgPSB0aGlzLnN0cmVhbS5nZXRFbmRGaWxlUG9zaXRpb25BZnRlcih1Lm9mZnNldCksIHIuaW5mbyhcIklTT0ZpbGVcIiwgXCJBZGp1c3RlZCBzZWVrIHBvc2l0aW9uIChhZnRlciBjaGVja2luZyBkYXRhIGFscmVhZHkgaW4gYnVmZmVyKTogXCIgKyB1Lm9mZnNldCksIHU7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBcIkNhbm5vdCBzZWVrOiBtb292IG5vdCByZWNlaXZlZCFcIjtcbiAgfSwgeS5wcm90b3R5cGUuZXF1YWwgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmJveGVzLmxlbmd0aCAmJiBlIDwgdC5ib3hlcy5sZW5ndGg7ICkge1xuICAgICAgdmFyIGkgPSB0aGlzLmJveGVzW2VdLCBzID0gdC5ib3hlc1tlXTtcbiAgICAgIGlmICghbi5ib3hFcXVhbChpLCBzKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgZSsrO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH0sIGwuSVNPRmlsZSA9IHksIHkucHJvdG90eXBlLmxhc3RCb3hTdGFydFBvc2l0aW9uID0gMCwgeS5wcm90b3R5cGUucGFyc2luZ01kYXQgPSBudWxsLCB5LnByb3RvdHlwZS5uZXh0UGFyc2VQb3NpdGlvbiA9IDAsIHkucHJvdG90eXBlLmRpc2NhcmRNZGF0RGF0YSA9ICExLCB5LnByb3RvdHlwZS5wcm9jZXNzSW5jb21wbGV0ZUJveCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSwgcztcbiAgICByZXR1cm4gdC50eXBlID09PSBcIm1kYXRcIiA/IChlID0gbmV3IG5bdC50eXBlICsgXCJCb3hcIl0odC5zaXplKSwgdGhpcy5wYXJzaW5nTWRhdCA9IGUsIHRoaXMuYm94ZXMucHVzaChlKSwgdGhpcy5tZGF0cy5wdXNoKGUpLCBlLnN0YXJ0ID0gdC5zdGFydCwgZS5oZHJfc2l6ZSA9IHQuaGRyX3NpemUsIHRoaXMuc3RyZWFtLmFkZFVzZWRCeXRlcyhlLmhkcl9zaXplKSwgdGhpcy5sYXN0Qm94U3RhcnRQb3NpdGlvbiA9IGUuc3RhcnQgKyBlLnNpemUsIHMgPSB0aGlzLnN0cmVhbS5zZWVrKGUuc3RhcnQgKyBlLnNpemUsICExLCB0aGlzLmRpc2NhcmRNZGF0RGF0YSksIHMgPyAodGhpcy5wYXJzaW5nTWRhdCA9IG51bGwsICEwKSA6ICh0aGlzLm1vb3ZTdGFydEZvdW5kID8gdGhpcy5uZXh0UGFyc2VQb3NpdGlvbiA9IHRoaXMuc3RyZWFtLmZpbmRFbmRDb250aWd1b3VzQnVmKCkgOiB0aGlzLm5leHRQYXJzZVBvc2l0aW9uID0gZS5zdGFydCArIGUuc2l6ZSwgITEpKSA6ICh0LnR5cGUgPT09IFwibW9vdlwiICYmICh0aGlzLm1vb3ZTdGFydEZvdW5kID0gITAsIHRoaXMubWRhdHMubGVuZ3RoID09PSAwICYmICh0aGlzLmlzUHJvZ3Jlc3NpdmUgPSAhMCkpLCBpID0gdGhpcy5zdHJlYW0ubWVyZ2VOZXh0QnVmZmVyID8gdGhpcy5zdHJlYW0ubWVyZ2VOZXh0QnVmZmVyKCkgOiAhMSwgaSA/ICh0aGlzLm5leHRQYXJzZVBvc2l0aW9uID0gdGhpcy5zdHJlYW0uZ2V0RW5kUG9zaXRpb24oKSwgITApIDogKHQudHlwZSA/IHRoaXMubW9vdlN0YXJ0Rm91bmQgPyB0aGlzLm5leHRQYXJzZVBvc2l0aW9uID0gdGhpcy5zdHJlYW0uZ2V0RW5kUG9zaXRpb24oKSA6IHRoaXMubmV4dFBhcnNlUG9zaXRpb24gPSB0aGlzLnN0cmVhbS5nZXRQb3NpdGlvbigpICsgdC5zaXplIDogdGhpcy5uZXh0UGFyc2VQb3NpdGlvbiA9IHRoaXMuc3RyZWFtLmdldEVuZFBvc2l0aW9uKCksICExKSk7XG4gIH0sIHkucHJvdG90eXBlLmhhc0luY29tcGxldGVNZGF0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2luZ01kYXQgIT09IG51bGw7XG4gIH0sIHkucHJvdG90eXBlLnByb2Nlc3NJbmNvbXBsZXRlTWRhdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0LCBlO1xuICAgIHJldHVybiB0ID0gdGhpcy5wYXJzaW5nTWRhdCwgZSA9IHRoaXMuc3RyZWFtLnNlZWsodC5zdGFydCArIHQuc2l6ZSwgITEsIHRoaXMuZGlzY2FyZE1kYXREYXRhKSwgZSA/IChyLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkZvdW5kICdtZGF0JyBlbmQgaW4gYnVmZmVyZWQgZGF0YVwiKSwgdGhpcy5wYXJzaW5nTWRhdCA9IG51bGwsICEwKSA6ICh0aGlzLm5leHRQYXJzZVBvc2l0aW9uID0gdGhpcy5zdHJlYW0uZmluZEVuZENvbnRpZ3VvdXNCdWYoKSwgITEpO1xuICB9LCB5LnByb3RvdHlwZS5yZXN0b3JlUGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbS5zZWVrKHRoaXMubGFzdEJveFN0YXJ0UG9zaXRpb24sICEwLCB0aGlzLmRpc2NhcmRNZGF0RGF0YSk7XG4gIH0sIHkucHJvdG90eXBlLnNhdmVQYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sYXN0Qm94U3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RyZWFtLmdldFBvc2l0aW9uKCk7XG4gIH0sIHkucHJvdG90eXBlLnVwZGF0ZVVzZWRCeXRlcyA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLnN0cmVhbS5hZGRVc2VkQnl0ZXMgJiYgKHQudHlwZSA9PT0gXCJtZGF0XCIgPyAodGhpcy5zdHJlYW0uYWRkVXNlZEJ5dGVzKHQuaGRyX3NpemUpLCB0aGlzLmRpc2NhcmRNZGF0RGF0YSAmJiB0aGlzLnN0cmVhbS5hZGRVc2VkQnl0ZXModC5zaXplIC0gdC5oZHJfc2l6ZSkpIDogdGhpcy5zdHJlYW0uYWRkVXNlZEJ5dGVzKHQuc2l6ZSkpO1xuICB9LCB5LnByb3RvdHlwZS5hZGQgPSBuLkJveC5wcm90b3R5cGUuYWRkLCB5LnByb3RvdHlwZS5hZGRCb3ggPSBuLkJveC5wcm90b3R5cGUuYWRkQm94LCB5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdCB8fCB7fTtcbiAgICB0aGlzLmFkZChcImZ0eXBcIikuc2V0KFwibWFqb3JfYnJhbmRcIiwgZS5icmFuZHMgJiYgZS5icmFuZHNbMF0gfHwgXCJpc280XCIpLnNldChcIm1pbm9yX3ZlcnNpb25cIiwgMCkuc2V0KFwiY29tcGF0aWJsZV9icmFuZHNcIiwgZS5icmFuZHMgfHwgW1wiaXNvNFwiXSk7XG4gICAgdmFyIGkgPSB0aGlzLmFkZChcIm1vb3ZcIik7XG4gICAgcmV0dXJuIGkuYWRkKFwibXZoZFwiKS5zZXQoXCJ0aW1lc2NhbGVcIiwgZS50aW1lc2NhbGUgfHwgNjAwKS5zZXQoXCJyYXRlXCIsIGUucmF0ZSB8fCA2NTUzNikuc2V0KFwiY3JlYXRpb25fdGltZVwiLCAwKS5zZXQoXCJtb2RpZmljYXRpb25fdGltZVwiLCAwKS5zZXQoXCJkdXJhdGlvblwiLCBlLmR1cmF0aW9uIHx8IDApLnNldChcInZvbHVtZVwiLCBlLndpZHRoID8gMCA6IDI1Nikuc2V0KFwibWF0cml4XCIsIFs2NTUzNiwgMCwgMCwgMCwgNjU1MzYsIDAsIDAsIDAsIDEwNzM3NDE4MjRdKS5zZXQoXCJuZXh0X3RyYWNrX2lkXCIsIDEpLCBpLmFkZChcIm12ZXhcIiksIHRoaXM7XG4gIH0sIHkucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMubW9vdiB8fCB0aGlzLmluaXQodCk7XG4gICAgdmFyIGUgPSB0IHx8IHt9O1xuICAgIGUud2lkdGggPSBlLndpZHRoIHx8IDMyMCwgZS5oZWlnaHQgPSBlLmhlaWdodCB8fCAzMjAsIGUuaWQgPSBlLmlkIHx8IHRoaXMubW9vdi5tdmhkLm5leHRfdHJhY2tfaWQsIGUudHlwZSA9IGUudHlwZSB8fCBcImF2YzFcIjtcbiAgICB2YXIgaSA9IHRoaXMubW9vdi5hZGQoXCJ0cmFrXCIpO1xuICAgIHRoaXMubW9vdi5tdmhkLm5leHRfdHJhY2tfaWQgPSBlLmlkICsgMSwgaS5hZGQoXCJ0a2hkXCIpLnNldChcImZsYWdzXCIsIG4uVEtIRF9GTEFHX0VOQUJMRUQgfCBuLlRLSERfRkxBR19JTl9NT1ZJRSB8IG4uVEtIRF9GTEFHX0lOX1BSRVZJRVcpLnNldChcImNyZWF0aW9uX3RpbWVcIiwgMCkuc2V0KFwibW9kaWZpY2F0aW9uX3RpbWVcIiwgMCkuc2V0KFwidHJhY2tfaWRcIiwgZS5pZCkuc2V0KFwiZHVyYXRpb25cIiwgZS5kdXJhdGlvbiB8fCAwKS5zZXQoXCJsYXllclwiLCBlLmxheWVyIHx8IDApLnNldChcImFsdGVybmF0ZV9ncm91cFwiLCAwKS5zZXQoXCJ2b2x1bWVcIiwgMSkuc2V0KFwibWF0cml4XCIsIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSkuc2V0KFwid2lkdGhcIiwgZS53aWR0aCA8PCAxNikuc2V0KFwiaGVpZ2h0XCIsIGUuaGVpZ2h0IDw8IDE2KTtcbiAgICB2YXIgcyA9IGkuYWRkKFwibWRpYVwiKTtcbiAgICBzLmFkZChcIm1kaGRcIikuc2V0KFwiY3JlYXRpb25fdGltZVwiLCAwKS5zZXQoXCJtb2RpZmljYXRpb25fdGltZVwiLCAwKS5zZXQoXCJ0aW1lc2NhbGVcIiwgZS50aW1lc2NhbGUgfHwgMSkuc2V0KFwiZHVyYXRpb25cIiwgZS5tZWRpYV9kdXJhdGlvbiB8fCAwKS5zZXQoXCJsYW5ndWFnZVwiLCBlLmxhbmd1YWdlIHx8IFwidW5kXCIpLCBzLmFkZChcImhkbHJcIikuc2V0KFwiaGFuZGxlclwiLCBlLmhkbHIgfHwgXCJ2aWRlXCIpLnNldChcIm5hbWVcIiwgZS5uYW1lIHx8IFwiVHJhY2sgY3JlYXRlZCB3aXRoIE1QNEJveC5qc1wiKSwgcy5hZGQoXCJlbG5nXCIpLnNldChcImV4dGVuZGVkX2xhbmd1YWdlXCIsIGUubGFuZ3VhZ2UgfHwgXCJmci1GUlwiKTtcbiAgICB2YXIgbyA9IHMuYWRkKFwibWluZlwiKTtcbiAgICBpZiAobltlLnR5cGUgKyBcIlNhbXBsZUVudHJ5XCJdICE9PSB2b2lkIDApIHtcbiAgICAgIHZhciBjID0gbmV3IG5bZS50eXBlICsgXCJTYW1wbGVFbnRyeVwiXSgpO1xuICAgICAgYy5kYXRhX3JlZmVyZW5jZV9pbmRleCA9IDE7XG4gICAgICB2YXIgdSA9IFwiXCI7XG4gICAgICBmb3IgKHZhciBfIGluIG4uc2FtcGxlRW50cnlDb2RlcylcbiAgICAgICAgZm9yICh2YXIgZyA9IG4uc2FtcGxlRW50cnlDb2Rlc1tfXSwgdyA9IDA7IHcgPCBnLmxlbmd0aDsgdysrKVxuICAgICAgICAgIGlmIChnLmluZGV4T2YoZS50eXBlKSA+IC0xKSB7XG4gICAgICAgICAgICB1ID0gXztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIHN3aXRjaCAodSkge1xuICAgICAgICBjYXNlIFwiVmlzdWFsXCI6XG4gICAgICAgICAgaWYgKG8uYWRkKFwidm1oZFwiKS5zZXQoXCJncmFwaGljc21vZGVcIiwgMCkuc2V0KFwib3Bjb2xvclwiLCBbMCwgMCwgMF0pLCBjLnNldChcIndpZHRoXCIsIGUud2lkdGgpLnNldChcImhlaWdodFwiLCBlLmhlaWdodCkuc2V0KFwiaG9yaXpyZXNvbHV0aW9uXCIsIDcyIDw8IDE2KS5zZXQoXCJ2ZXJ0cmVzb2x1dGlvblwiLCA3MiA8PCAxNikuc2V0KFwiZnJhbWVfY291bnRcIiwgMSkuc2V0KFwiY29tcHJlc3Nvcm5hbWVcIiwgZS50eXBlICsgXCIgQ29tcHJlc3NvclwiKS5zZXQoXCJkZXB0aFwiLCAyNCksIGUuYXZjRGVjb2RlckNvbmZpZ1JlY29yZCkge1xuICAgICAgICAgICAgdmFyIFMgPSBuZXcgbi5hdmNDQm94KCksIFUgPSBuZXcgaChlLmF2Y0RlY29kZXJDb25maWdSZWNvcmQpO1xuICAgICAgICAgICAgUy5wYXJzZShVKSwgYy5hZGRCb3goUyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXVkaW9cIjpcbiAgICAgICAgICBvLmFkZChcInNtaGRcIikuc2V0KFwiYmFsYW5jZVwiLCBlLmJhbGFuY2UgfHwgMCksIGMuc2V0KFwiY2hhbm5lbF9jb3VudFwiLCBlLmNoYW5uZWxfY291bnQgfHwgMikuc2V0KFwic2FtcGxlc2l6ZVwiLCBlLnNhbXBsZXNpemUgfHwgMTYpLnNldChcInNhbXBsZXJhdGVcIiwgZS5zYW1wbGVyYXRlIHx8IDY1NTM2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkhpbnRcIjpcbiAgICAgICAgICBvLmFkZChcImhtaGRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJTdWJ0aXRsZVwiOlxuICAgICAgICAgIHN3aXRjaCAoby5hZGQoXCJzdGhkXCIpLCBlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHBwXCI6XG4gICAgICAgICAgICAgIGMuc2V0KFwibmFtZXNwYWNlXCIsIGUubmFtZXNwYWNlIHx8IFwibm9uYW1lc3BhY2VcIikuc2V0KFwic2NoZW1hX2xvY2F0aW9uXCIsIGUuc2NoZW1hX2xvY2F0aW9uIHx8IFwiXCIpLnNldChcImF1eGlsaWFyeV9taW1lX3R5cGVzXCIsIGUuYXV4aWxpYXJ5X21pbWVfdHlwZXMgfHwgXCJcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1ldGFkYXRhXCI6XG4gICAgICAgICAgby5hZGQoXCJubWhkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU3lzdGVtXCI6XG4gICAgICAgICAgby5hZGQoXCJubWhkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG8uYWRkKFwibm1oZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGUuZGVzY3JpcHRpb24gJiYgYy5hZGRCb3goZS5kZXNjcmlwdGlvbiksIGUuZGVzY3JpcHRpb25fYm94ZXMgJiYgZS5kZXNjcmlwdGlvbl9ib3hlcy5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgYy5hZGRCb3goeCk7XG4gICAgICB9KSwgby5hZGQoXCJkaW5mXCIpLmFkZChcImRyZWZcIikuYWRkRW50cnkobmV3IG5bXCJ1cmwgQm94XCJdKCkuc2V0KFwiZmxhZ3NcIiwgMSkpO1xuICAgICAgdmFyIEMgPSBvLmFkZChcInN0YmxcIik7XG4gICAgICByZXR1cm4gQy5hZGQoXCJzdHNkXCIpLmFkZEVudHJ5KGMpLCBDLmFkZChcInN0dHNcIikuc2V0KFwic2FtcGxlX2NvdW50c1wiLCBbXSkuc2V0KFwic2FtcGxlX2RlbHRhc1wiLCBbXSksIEMuYWRkKFwic3RzY1wiKS5zZXQoXCJmaXJzdF9jaHVua1wiLCBbXSkuc2V0KFwic2FtcGxlc19wZXJfY2h1bmtcIiwgW10pLnNldChcInNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFwiLCBbXSksIEMuYWRkKFwic3Rjb1wiKS5zZXQoXCJjaHVua19vZmZzZXRzXCIsIFtdKSwgQy5hZGQoXCJzdHN6XCIpLnNldChcInNhbXBsZV9zaXplc1wiLCBbXSksIHRoaXMubW9vdi5tdmV4LmFkZChcInRyZXhcIikuc2V0KFwidHJhY2tfaWRcIiwgZS5pZCkuc2V0KFwiZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcIiwgZS5kZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCB8fCAxKS5zZXQoXCJkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblwiLCBlLmRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIHx8IDApLnNldChcImRlZmF1bHRfc2FtcGxlX3NpemVcIiwgZS5kZWZhdWx0X3NhbXBsZV9zaXplIHx8IDApLnNldChcImRlZmF1bHRfc2FtcGxlX2ZsYWdzXCIsIGUuZGVmYXVsdF9zYW1wbGVfZmxhZ3MgfHwgMCksIHRoaXMuYnVpbGRUcmFrU2FtcGxlTGlzdHMoaSksIGUuaWQ7XG4gICAgfVxuICB9LCBuLkJveC5wcm90b3R5cGUuY29tcHV0ZVNpemUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0IHx8IG5ldyBhKCk7XG4gICAgZS5lbmRpYW5uZXNzID0gYS5CSUdfRU5ESUFOLCB0aGlzLndyaXRlKGUpO1xuICB9LCB5LnByb3RvdHlwZS5hZGRTYW1wbGUgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgdmFyIHMgPSBpIHx8IHt9LCBvID0ge30sIGMgPSB0aGlzLmdldFRyYWNrQnlJZCh0KTtcbiAgICBpZiAoYyAhPT0gbnVsbCkge1xuICAgICAgby5udW1iZXIgPSBjLnNhbXBsZXMubGVuZ3RoLCBvLnRyYWNrX2lkID0gYy50a2hkLnRyYWNrX2lkLCBvLnRpbWVzY2FsZSA9IGMubWRpYS5tZGhkLnRpbWVzY2FsZSwgby5kZXNjcmlwdGlvbl9pbmRleCA9IHMuc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4ID8gcy5zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggLSAxIDogMCwgby5kZXNjcmlwdGlvbiA9IGMubWRpYS5taW5mLnN0Ymwuc3RzZC5lbnRyaWVzW28uZGVzY3JpcHRpb25faW5kZXhdLCBvLmRhdGEgPSBlLCBvLnNpemUgPSBlLmJ5dGVMZW5ndGgsIG8uYWxyZWFkeVJlYWQgPSBvLnNpemUsIG8uZHVyYXRpb24gPSBzLmR1cmF0aW9uIHx8IDEsIG8uY3RzID0gcy5jdHMgfHwgMCwgby5kdHMgPSBzLmR0cyB8fCAwLCBvLmlzX3N5bmMgPSBzLmlzX3N5bmMgfHwgITEsIG8uaXNfbGVhZGluZyA9IHMuaXNfbGVhZGluZyB8fCAwLCBvLmRlcGVuZHNfb24gPSBzLmRlcGVuZHNfb24gfHwgMCwgby5pc19kZXBlbmRlZF9vbiA9IHMuaXNfZGVwZW5kZWRfb24gfHwgMCwgby5oYXNfcmVkdW5kYW5jeSA9IHMuaGFzX3JlZHVuZGFuY3kgfHwgMCwgby5kZWdyYWRhdGlvbl9wcmlvcml0eSA9IHMuZGVncmFkYXRpb25fcHJpb3JpdHkgfHwgMCwgby5vZmZzZXQgPSAwLCBvLnN1YnNhbXBsZXMgPSBzLnN1YnNhbXBsZXMsIGMuc2FtcGxlcy5wdXNoKG8pLCBjLnNhbXBsZXNfc2l6ZSArPSBvLnNpemUsIGMuc2FtcGxlc19kdXJhdGlvbiArPSBvLmR1cmF0aW9uLCBjLmZpcnN0X2R0cyB8fCAoYy5maXJzdF9kdHMgPSBzLmR0cyksIHRoaXMucHJvY2Vzc1NhbXBsZXMoKTtcbiAgICAgIHZhciB1ID0gdGhpcy5jcmVhdGVTaW5nbGVTYW1wbGVNb29mKG8pO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkQm94KHUpLCB1LmNvbXB1dGVTaXplKCksIHUudHJhZnNbMF0udHJ1bnNbMF0uZGF0YV9vZmZzZXQgPSB1LnNpemUgKyA4LCB0aGlzLmFkZChcIm1kYXRcIikuZGF0YSA9IG5ldyBVaW50OEFycmF5KGUpLCBvO1xuICAgIH1cbiAgfSwgeS5wcm90b3R5cGUuY3JlYXRlU2luZ2xlU2FtcGxlTW9vZiA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IDA7XG4gICAgdC5pc19zeW5jID8gZSA9IDEgPDwgMjUgOiBlID0gNjU1MzY7XG4gICAgdmFyIGkgPSBuZXcgbi5tb29mQm94KCk7XG4gICAgaS5hZGQoXCJtZmhkXCIpLnNldChcInNlcXVlbmNlX251bWJlclwiLCB0aGlzLm5leHRNb29mTnVtYmVyKSwgdGhpcy5uZXh0TW9vZk51bWJlcisrO1xuICAgIHZhciBzID0gaS5hZGQoXCJ0cmFmXCIpLCBvID0gdGhpcy5nZXRUcmFja0J5SWQodC50cmFja19pZCk7XG4gICAgcmV0dXJuIHMuYWRkKFwidGZoZFwiKS5zZXQoXCJ0cmFja19pZFwiLCB0LnRyYWNrX2lkKS5zZXQoXCJmbGFnc1wiLCBuLlRGSERfRkxBR19ERUZBVUxUX0JBU0VfSVNfTU9PRiksIHMuYWRkKFwidGZkdFwiKS5zZXQoXCJiYXNlTWVkaWFEZWNvZGVUaW1lXCIsIHQuZHRzIC0gKG8uZmlyc3RfZHRzIHx8IDApKSwgcy5hZGQoXCJ0cnVuXCIpLnNldChcImZsYWdzXCIsIG4uVFJVTl9GTEFHU19EQVRBX09GRlNFVCB8IG4uVFJVTl9GTEFHU19EVVJBVElPTiB8IG4uVFJVTl9GTEFHU19TSVpFIHwgbi5UUlVOX0ZMQUdTX0ZMQUdTIHwgbi5UUlVOX0ZMQUdTX0NUU19PRkZTRVQpLnNldChcImRhdGFfb2Zmc2V0XCIsIDApLnNldChcImZpcnN0X3NhbXBsZV9mbGFnc1wiLCAwKS5zZXQoXCJzYW1wbGVfY291bnRcIiwgMSkuc2V0KFwic2FtcGxlX2R1cmF0aW9uXCIsIFt0LmR1cmF0aW9uXSkuc2V0KFwic2FtcGxlX3NpemVcIiwgW3Quc2l6ZV0pLnNldChcInNhbXBsZV9mbGFnc1wiLCBbZV0pLnNldChcInNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFwiLCBbdC5jdHMgLSB0LmR0c10pLCBpO1xuICB9LCB5LnByb3RvdHlwZS5sYXN0TW9vZkluZGV4ID0gMCwgeS5wcm90b3R5cGUuc2FtcGxlc0RhdGFTaXplID0gMCwgeS5wcm90b3R5cGUucmVzZXRUYWJsZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCwgZSwgaSwgcywgbywgYywgdSwgXztcbiAgICBmb3IgKHRoaXMuaW5pdGlhbF9kdXJhdGlvbiA9IHRoaXMubW9vdi5tdmhkLmR1cmF0aW9uLCB0aGlzLm1vb3YubXZoZC5kdXJhdGlvbiA9IDAsIHQgPSAwOyB0IDwgdGhpcy5tb292LnRyYWtzLmxlbmd0aDsgdCsrKSB7XG4gICAgICBlID0gdGhpcy5tb292LnRyYWtzW3RdLCBlLnRraGQuZHVyYXRpb24gPSAwLCBlLm1kaWEubWRoZC5kdXJhdGlvbiA9IDAsIGkgPSBlLm1kaWEubWluZi5zdGJsLnN0Y28gfHwgZS5tZGlhLm1pbmYuc3RibC5jbzY0LCBpLmNodW5rX29mZnNldHMgPSBbXSwgcyA9IGUubWRpYS5taW5mLnN0Ymwuc3RzYywgcy5maXJzdF9jaHVuayA9IFtdLCBzLnNhbXBsZXNfcGVyX2NodW5rID0gW10sIHMuc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4ID0gW10sIG8gPSBlLm1kaWEubWluZi5zdGJsLnN0c3ogfHwgZS5tZGlhLm1pbmYuc3RibC5zdHoyLCBvLnNhbXBsZV9zaXplcyA9IFtdLCBjID0gZS5tZGlhLm1pbmYuc3RibC5zdHRzLCBjLnNhbXBsZV9jb3VudHMgPSBbXSwgYy5zYW1wbGVfZGVsdGFzID0gW10sIHUgPSBlLm1kaWEubWluZi5zdGJsLmN0dHMsIHUgJiYgKHUuc2FtcGxlX2NvdW50cyA9IFtdLCB1LnNhbXBsZV9vZmZzZXRzID0gW10pLCBfID0gZS5tZGlhLm1pbmYuc3RibC5zdHNzO1xuICAgICAgdmFyIGcgPSBlLm1kaWEubWluZi5zdGJsLmJveGVzLmluZGV4T2YoXyk7XG4gICAgICBnICE9IC0xICYmIChlLm1kaWEubWluZi5zdGJsLmJveGVzW2ddID0gbnVsbCk7XG4gICAgfVxuICB9LCB5LmluaXRTYW1wbGVHcm91cHMgPSBmdW5jdGlvbih0LCBlLCBpLCBzLCBvKSB7XG4gICAgdmFyIGMsIHUsIF8sIGc7XG4gICAgZnVuY3Rpb24gdyhTLCBVLCBDKSB7XG4gICAgICB0aGlzLmdyb3VwaW5nX3R5cGUgPSBTLCB0aGlzLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyID0gVSwgdGhpcy5zYmdwID0gQywgdGhpcy5sYXN0X3NhbXBsZV9pbl9ydW4gPSAtMSwgdGhpcy5lbnRyeV9pbmRleCA9IC0xO1xuICAgIH1cbiAgICBmb3IgKGUgJiYgKGUuc2FtcGxlX2dyb3Vwc19pbmZvID0gW10pLCB0LnNhbXBsZV9ncm91cHNfaW5mbyB8fCAodC5zYW1wbGVfZ3JvdXBzX2luZm8gPSBbXSksIHUgPSAwOyB1IDwgaS5sZW5ndGg7IHUrKykge1xuICAgICAgZm9yIChnID0gaVt1XS5ncm91cGluZ190eXBlICsgXCIvXCIgKyBpW3VdLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyLCBfID0gbmV3IHcoaVt1XS5ncm91cGluZ190eXBlLCBpW3VdLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyLCBpW3VdKSwgZSAmJiAoZS5zYW1wbGVfZ3JvdXBzX2luZm9bZ10gPSBfKSwgdC5zYW1wbGVfZ3JvdXBzX2luZm9bZ10gfHwgKHQuc2FtcGxlX2dyb3Vwc19pbmZvW2ddID0gXyksIGMgPSAwOyBjIDwgcy5sZW5ndGg7IGMrKylcbiAgICAgICAgc1tjXS5ncm91cGluZ190eXBlID09PSBpW3VdLmdyb3VwaW5nX3R5cGUgJiYgKF8uZGVzY3JpcHRpb24gPSBzW2NdLCBfLmRlc2NyaXB0aW9uLnVzZWQgPSAhMCk7XG4gICAgICBpZiAobylcbiAgICAgICAgZm9yIChjID0gMDsgYyA8IG8ubGVuZ3RoOyBjKyspXG4gICAgICAgICAgb1tjXS5ncm91cGluZ190eXBlID09PSBpW3VdLmdyb3VwaW5nX3R5cGUgJiYgKF8uZnJhZ21lbnRfZGVzY3JpcHRpb24gPSBvW2NdLCBfLmZyYWdtZW50X2Rlc2NyaXB0aW9uLnVzZWQgPSAhMCwgXy5pc19mcmFnbWVudCA9ICEwKTtcbiAgICB9XG4gICAgaWYgKGUpIHtcbiAgICAgIGlmIChvKVxuICAgICAgICBmb3IgKHUgPSAwOyB1IDwgby5sZW5ndGg7IHUrKylcbiAgICAgICAgICAhb1t1XS51c2VkICYmIG9bdV0udmVyc2lvbiA+PSAyICYmIChnID0gb1t1XS5ncm91cGluZ190eXBlICsgXCIvMFwiLCBfID0gbmV3IHcob1t1XS5ncm91cGluZ190eXBlLCAwKSwgXy5pc19mcmFnbWVudCA9ICEwLCBlLnNhbXBsZV9ncm91cHNfaW5mb1tnXSB8fCAoZS5zYW1wbGVfZ3JvdXBzX2luZm9bZ10gPSBfKSk7XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKHUgPSAwOyB1IDwgcy5sZW5ndGg7IHUrKylcbiAgICAgICAgIXNbdV0udXNlZCAmJiBzW3VdLnZlcnNpb24gPj0gMiAmJiAoZyA9IHNbdV0uZ3JvdXBpbmdfdHlwZSArIFwiLzBcIiwgXyA9IG5ldyB3KHNbdV0uZ3JvdXBpbmdfdHlwZSwgMCksIHQuc2FtcGxlX2dyb3Vwc19pbmZvW2ddIHx8ICh0LnNhbXBsZV9ncm91cHNfaW5mb1tnXSA9IF8pKTtcbiAgfSwgeS5zZXRTYW1wbGVHcm91cFByb3BlcnRpZXMgPSBmdW5jdGlvbih0LCBlLCBpLCBzKSB7XG4gICAgdmFyIG8sIGM7XG4gICAgZS5zYW1wbGVfZ3JvdXBzID0gW107XG4gICAgZm9yIChvIGluIHMpXG4gICAgICBpZiAoZS5zYW1wbGVfZ3JvdXBzW29dID0ge30sIGUuc2FtcGxlX2dyb3Vwc1tvXS5ncm91cGluZ190eXBlID0gc1tvXS5ncm91cGluZ190eXBlLCBlLnNhbXBsZV9ncm91cHNbb10uZ3JvdXBpbmdfdHlwZV9wYXJhbWV0ZXIgPSBzW29dLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyLCBpID49IHNbb10ubGFzdF9zYW1wbGVfaW5fcnVuICYmIChzW29dLmxhc3Rfc2FtcGxlX2luX3J1biA8IDAgJiYgKHNbb10ubGFzdF9zYW1wbGVfaW5fcnVuID0gMCksIHNbb10uZW50cnlfaW5kZXgrKywgc1tvXS5lbnRyeV9pbmRleCA8PSBzW29dLnNiZ3AuZW50cmllcy5sZW5ndGggLSAxICYmIChzW29dLmxhc3Rfc2FtcGxlX2luX3J1biArPSBzW29dLnNiZ3AuZW50cmllc1tzW29dLmVudHJ5X2luZGV4XS5zYW1wbGVfY291bnQpKSwgc1tvXS5lbnRyeV9pbmRleCA8PSBzW29dLnNiZ3AuZW50cmllcy5sZW5ndGggLSAxID8gZS5zYW1wbGVfZ3JvdXBzW29dLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ID0gc1tvXS5zYmdwLmVudHJpZXNbc1tvXS5lbnRyeV9pbmRleF0uZ3JvdXBfZGVzY3JpcHRpb25faW5kZXggOiBlLnNhbXBsZV9ncm91cHNbb10uZ3JvdXBfZGVzY3JpcHRpb25faW5kZXggPSAtMSwgZS5zYW1wbGVfZ3JvdXBzW29dLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ICE9PSAwKSB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICBzW29dLmZyYWdtZW50X2Rlc2NyaXB0aW9uID8gdSA9IHNbb10uZnJhZ21lbnRfZGVzY3JpcHRpb24gOiB1ID0gc1tvXS5kZXNjcmlwdGlvbiwgZS5zYW1wbGVfZ3JvdXBzW29dLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ID4gMCA/IChlLnNhbXBsZV9ncm91cHNbb10uZ3JvdXBfZGVzY3JpcHRpb25faW5kZXggPiA2NTUzNSA/IGMgPSAoZS5zYW1wbGVfZ3JvdXBzW29dLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ID4+IDE2KSAtIDEgOiBjID0gZS5zYW1wbGVfZ3JvdXBzW29dLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4IC0gMSwgdSAmJiBjID49IDAgJiYgKGUuc2FtcGxlX2dyb3Vwc1tvXS5kZXNjcmlwdGlvbiA9IHUuZW50cmllc1tjXSkpIDogdSAmJiB1LnZlcnNpb24gPj0gMiAmJiB1LmRlZmF1bHRfZ3JvdXBfZGVzY3JpcHRpb25faW5kZXggPiAwICYmIChlLnNhbXBsZV9ncm91cHNbb10uZGVzY3JpcHRpb24gPSB1LmVudHJpZXNbdS5kZWZhdWx0X2dyb3VwX2Rlc2NyaXB0aW9uX2luZGV4IC0gMV0pO1xuICAgICAgfVxuICB9LCB5LnByb2Nlc3Nfc2R0cCA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICBlICYmICh0ID8gKGUuaXNfbGVhZGluZyA9IHQuaXNfbGVhZGluZ1tpXSwgZS5kZXBlbmRzX29uID0gdC5zYW1wbGVfZGVwZW5kc19vbltpXSwgZS5pc19kZXBlbmRlZF9vbiA9IHQuc2FtcGxlX2lzX2RlcGVuZGVkX29uW2ldLCBlLmhhc19yZWR1bmRhbmN5ID0gdC5zYW1wbGVfaGFzX3JlZHVuZGFuY3lbaV0pIDogKGUuaXNfbGVhZGluZyA9IDAsIGUuZGVwZW5kc19vbiA9IDAsIGUuaXNfZGVwZW5kZWRfb24gPSAwLCBlLmhhc19yZWR1bmRhbmN5ID0gMCkpO1xuICB9LCB5LnByb3RvdHlwZS5idWlsZFNhbXBsZUxpc3RzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQsIGU7XG4gICAgZm9yICh0ID0gMDsgdCA8IHRoaXMubW9vdi50cmFrcy5sZW5ndGg7IHQrKylcbiAgICAgIGUgPSB0aGlzLm1vb3YudHJha3NbdF0sIHRoaXMuYnVpbGRUcmFrU2FtcGxlTGlzdHMoZSk7XG4gIH0sIHkucHJvdG90eXBlLmJ1aWxkVHJha1NhbXBsZUxpc3RzID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpLCBzLCBvLCBjLCB1LCBfLCBnLCB3LCBTLCBVLCBDLCB4LCBQLCBULCB5dCwgVXQsIGh0LCBPLCB0dCwgSHQsIGVlLCBldCwgRXQ7XG4gICAgaWYgKHQuc2FtcGxlcyA9IFtdLCB0LnNhbXBsZXNfZHVyYXRpb24gPSAwLCB0LnNhbXBsZXNfc2l6ZSA9IDAsIGkgPSB0Lm1kaWEubWluZi5zdGJsLnN0Y28gfHwgdC5tZGlhLm1pbmYuc3RibC5jbzY0LCBzID0gdC5tZGlhLm1pbmYuc3RibC5zdHNjLCBvID0gdC5tZGlhLm1pbmYuc3RibC5zdHN6IHx8IHQubWRpYS5taW5mLnN0Ymwuc3R6MiwgYyA9IHQubWRpYS5taW5mLnN0Ymwuc3R0cywgdSA9IHQubWRpYS5taW5mLnN0YmwuY3R0cywgXyA9IHQubWRpYS5taW5mLnN0Ymwuc3RzcywgZyA9IHQubWRpYS5taW5mLnN0Ymwuc3RzZCwgdyA9IHQubWRpYS5taW5mLnN0Ymwuc3VicywgQyA9IHQubWRpYS5taW5mLnN0Ymwuc3RkcCwgUyA9IHQubWRpYS5taW5mLnN0Ymwuc2JncHMsIFUgPSB0Lm1kaWEubWluZi5zdGJsLnNncGRzLCBodCA9IC0xLCBPID0gLTEsIHR0ID0gLTEsIEh0ID0gLTEsIGVlID0gMCwgZXQgPSAwLCBFdCA9IDAsIHkuaW5pdFNhbXBsZUdyb3Vwcyh0LCBudWxsLCBTLCBVKSwgISh0eXBlb2YgbyA+IFwidVwiKSkge1xuICAgICAgZm9yIChlID0gMDsgZSA8IG8uc2FtcGxlX3NpemVzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgIHZhciBGID0ge307XG4gICAgICAgIEYubnVtYmVyID0gZSwgRi50cmFja19pZCA9IHQudGtoZC50cmFja19pZCwgRi50aW1lc2NhbGUgPSB0Lm1kaWEubWRoZC50aW1lc2NhbGUsIEYuYWxyZWFkeVJlYWQgPSAwLCB0LnNhbXBsZXNbZV0gPSBGLCBGLnNpemUgPSBvLnNhbXBsZV9zaXplc1tlXSwgdC5zYW1wbGVzX3NpemUgKz0gRi5zaXplLCBlID09PSAwID8gKFAgPSAxLCB4ID0gMCwgRi5jaHVua19pbmRleCA9IFAsIEYuY2h1bmtfcnVuX2luZGV4ID0geCwgVXQgPSBzLnNhbXBsZXNfcGVyX2NodW5rW3hdLCB5dCA9IDAsIHggKyAxIDwgcy5maXJzdF9jaHVuay5sZW5ndGggPyBUID0gcy5maXJzdF9jaHVua1t4ICsgMV0gLSAxIDogVCA9IDEgLyAwKSA6IGUgPCBVdCA/IChGLmNodW5rX2luZGV4ID0gUCwgRi5jaHVua19ydW5faW5kZXggPSB4KSA6IChQKyssIEYuY2h1bmtfaW5kZXggPSBQLCB5dCA9IDAsIFAgPD0gVCB8fCAoeCsrLCB4ICsgMSA8IHMuZmlyc3RfY2h1bmsubGVuZ3RoID8gVCA9IHMuZmlyc3RfY2h1bmtbeCArIDFdIC0gMSA6IFQgPSAxIC8gMCksIEYuY2h1bmtfcnVuX2luZGV4ID0geCwgVXQgKz0gcy5zYW1wbGVzX3Blcl9jaHVua1t4XSksIEYuZGVzY3JpcHRpb25faW5kZXggPSBzLnNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFtGLmNodW5rX3J1bl9pbmRleF0gLSAxLCBGLmRlc2NyaXB0aW9uID0gZy5lbnRyaWVzW0YuZGVzY3JpcHRpb25faW5kZXhdLCBGLm9mZnNldCA9IGkuY2h1bmtfb2Zmc2V0c1tGLmNodW5rX2luZGV4IC0gMV0gKyB5dCwgeXQgKz0gRi5zaXplLCBlID4gaHQgJiYgKE8rKywgaHQgPCAwICYmIChodCA9IDApLCBodCArPSBjLnNhbXBsZV9jb3VudHNbT10pLCBlID4gMCA/ICh0LnNhbXBsZXNbZSAtIDFdLmR1cmF0aW9uID0gYy5zYW1wbGVfZGVsdGFzW09dLCB0LnNhbXBsZXNfZHVyYXRpb24gKz0gdC5zYW1wbGVzW2UgLSAxXS5kdXJhdGlvbiwgRi5kdHMgPSB0LnNhbXBsZXNbZSAtIDFdLmR0cyArIHQuc2FtcGxlc1tlIC0gMV0uZHVyYXRpb24pIDogRi5kdHMgPSAwLCB1ID8gKGUgPj0gdHQgJiYgKEh0KyssIHR0IDwgMCAmJiAodHQgPSAwKSwgdHQgKz0gdS5zYW1wbGVfY291bnRzW0h0XSksIEYuY3RzID0gdC5zYW1wbGVzW2VdLmR0cyArIHUuc2FtcGxlX29mZnNldHNbSHRdKSA6IEYuY3RzID0gRi5kdHMsIF8gPyAoZSA9PSBfLnNhbXBsZV9udW1iZXJzW2VlXSAtIDEgPyAoRi5pc19zeW5jID0gITAsIGVlKyspIDogKEYuaXNfc3luYyA9ICExLCBGLmRlZ3JhZGF0aW9uX3ByaW9yaXR5ID0gMCksIHcgJiYgdy5lbnRyaWVzW2V0XS5zYW1wbGVfZGVsdGEgKyBFdCA9PSBlICsgMSAmJiAoRi5zdWJzYW1wbGVzID0gdy5lbnRyaWVzW2V0XS5zdWJzYW1wbGVzLCBFdCArPSB3LmVudHJpZXNbZXRdLnNhbXBsZV9kZWx0YSwgZXQrKykpIDogRi5pc19zeW5jID0gITAsIHkucHJvY2Vzc19zZHRwKHQubWRpYS5taW5mLnN0Ymwuc2R0cCwgRiwgRi5udW1iZXIpLCBDID8gRi5kZWdyYWRhdGlvbl9wcmlvcml0eSA9IEMucHJpb3JpdHlbZV0gOiBGLmRlZ3JhZGF0aW9uX3ByaW9yaXR5ID0gMCwgdyAmJiB3LmVudHJpZXNbZXRdLnNhbXBsZV9kZWx0YSArIEV0ID09IGUgJiYgKEYuc3Vic2FtcGxlcyA9IHcuZW50cmllc1tldF0uc3Vic2FtcGxlcywgRXQgKz0gdy5lbnRyaWVzW2V0XS5zYW1wbGVfZGVsdGEpLCAoUy5sZW5ndGggPiAwIHx8IFUubGVuZ3RoID4gMCkgJiYgeS5zZXRTYW1wbGVHcm91cFByb3BlcnRpZXModCwgRiwgZSwgdC5zYW1wbGVfZ3JvdXBzX2luZm8pO1xuICAgICAgfVxuICAgICAgZSA+IDAgJiYgKHQuc2FtcGxlc1tlIC0gMV0uZHVyYXRpb24gPSBNYXRoLm1heCh0Lm1kaWEubWRoZC5kdXJhdGlvbiAtIHQuc2FtcGxlc1tlIC0gMV0uZHRzLCAwKSwgdC5zYW1wbGVzX2R1cmF0aW9uICs9IHQuc2FtcGxlc1tlIC0gMV0uZHVyYXRpb24pO1xuICAgIH1cbiAgfSwgeS5wcm90b3R5cGUudXBkYXRlU2FtcGxlTGlzdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCwgZSwgaSwgcywgbywgYywgdSwgXywgZywgdywgUywgVSwgQywgeCwgUDtcbiAgICBpZiAodGhpcy5tb292ICE9PSB2b2lkIDApIHtcbiAgICAgIGZvciAoOyB0aGlzLmxhc3RNb29mSW5kZXggPCB0aGlzLm1vb2ZzLmxlbmd0aDsgKVxuICAgICAgICBpZiAoZyA9IHRoaXMubW9vZnNbdGhpcy5sYXN0TW9vZkluZGV4XSwgdGhpcy5sYXN0TW9vZkluZGV4KyssIGcudHlwZSA9PSBcIm1vb2ZcIilcbiAgICAgICAgICBmb3IgKHcgPSBnLCB0ID0gMDsgdCA8IHcudHJhZnMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGZvciAoUyA9IHcudHJhZnNbdF0sIFUgPSB0aGlzLmdldFRyYWNrQnlJZChTLnRmaGQudHJhY2tfaWQpLCBDID0gdGhpcy5nZXRUcmV4QnlJZChTLnRmaGQudHJhY2tfaWQpLCBTLnRmaGQuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfREVTQyA/IHMgPSBTLnRmaGQuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggOiBzID0gQyA/IEMuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggOiAxLCBTLnRmaGQuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfRFVSID8gbyA9IFMudGZoZC5kZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiA6IG8gPSBDID8gQy5kZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiA6IDAsIFMudGZoZC5mbGFncyAmIG4uVEZIRF9GTEFHX1NBTVBMRV9TSVpFID8gYyA9IFMudGZoZC5kZWZhdWx0X3NhbXBsZV9zaXplIDogYyA9IEMgPyBDLmRlZmF1bHRfc2FtcGxlX3NpemUgOiAwLCBTLnRmaGQuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfRkxBR1MgPyB1ID0gUy50ZmhkLmRlZmF1bHRfc2FtcGxlX2ZsYWdzIDogdSA9IEMgPyBDLmRlZmF1bHRfc2FtcGxlX2ZsYWdzIDogMCwgUy5zYW1wbGVfbnVtYmVyID0gMCwgUy5zYmdwcy5sZW5ndGggPiAwICYmIHkuaW5pdFNhbXBsZUdyb3VwcyhVLCBTLCBTLnNiZ3BzLCBVLm1kaWEubWluZi5zdGJsLnNncGRzLCBTLnNncGRzKSwgZSA9IDA7IGUgPCBTLnRydW5zLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgICAgIHZhciBUID0gUy50cnVuc1tlXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IFQuc2FtcGxlX2NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB4ID0ge30sIHgubW9vZl9udW1iZXIgPSB0aGlzLmxhc3RNb29mSW5kZXgsIHgubnVtYmVyX2luX3RyYWYgPSBTLnNhbXBsZV9udW1iZXIsIFMuc2FtcGxlX251bWJlcisrLCB4Lm51bWJlciA9IFUuc2FtcGxlcy5sZW5ndGgsIFMuZmlyc3Rfc2FtcGxlX2luZGV4ID0gVS5zYW1wbGVzLmxlbmd0aCwgVS5zYW1wbGVzLnB1c2goeCksIHgudHJhY2tfaWQgPSBVLnRraGQudHJhY2tfaWQsIHgudGltZXNjYWxlID0gVS5tZGlhLm1kaGQudGltZXNjYWxlLCB4LmRlc2NyaXB0aW9uX2luZGV4ID0gcyAtIDEsIHguZGVzY3JpcHRpb24gPSBVLm1kaWEubWluZi5zdGJsLnN0c2QuZW50cmllc1t4LmRlc2NyaXB0aW9uX2luZGV4XSwgeC5zaXplID0gYywgVC5mbGFncyAmIG4uVFJVTl9GTEFHU19TSVpFICYmICh4LnNpemUgPSBULnNhbXBsZV9zaXplW2ldKSwgVS5zYW1wbGVzX3NpemUgKz0geC5zaXplLCB4LmR1cmF0aW9uID0gbywgVC5mbGFncyAmIG4uVFJVTl9GTEFHU19EVVJBVElPTiAmJiAoeC5kdXJhdGlvbiA9IFQuc2FtcGxlX2R1cmF0aW9uW2ldKSwgVS5zYW1wbGVzX2R1cmF0aW9uICs9IHguZHVyYXRpb24sIFUuZmlyc3RfdHJhZl9tZXJnZWQgfHwgaSA+IDAgPyB4LmR0cyA9IFUuc2FtcGxlc1tVLnNhbXBsZXMubGVuZ3RoIC0gMl0uZHRzICsgVS5zYW1wbGVzW1Uuc2FtcGxlcy5sZW5ndGggLSAyXS5kdXJhdGlvbiA6IChTLnRmZHQgPyB4LmR0cyA9IFMudGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lIDogeC5kdHMgPSAwLCBVLmZpcnN0X3RyYWZfbWVyZ2VkID0gITApLCB4LmN0cyA9IHguZHRzLCBULmZsYWdzICYgbi5UUlVOX0ZMQUdTX0NUU19PRkZTRVQgJiYgKHguY3RzID0geC5kdHMgKyBULnNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFtpXSksIFAgPSB1LCBULmZsYWdzICYgbi5UUlVOX0ZMQUdTX0ZMQUdTID8gUCA9IFQuc2FtcGxlX2ZsYWdzW2ldIDogaSA9PT0gMCAmJiBULmZsYWdzICYgbi5UUlVOX0ZMQUdTX0ZJUlNUX0ZMQUcgJiYgKFAgPSBULmZpcnN0X3NhbXBsZV9mbGFncyksIHguaXNfc3luYyA9ICEoUCA+PiAxNiAmIDEpLCB4LmlzX2xlYWRpbmcgPSBQID4+IDI2ICYgMywgeC5kZXBlbmRzX29uID0gUCA+PiAyNCAmIDMsIHguaXNfZGVwZW5kZWRfb24gPSBQID4+IDIyICYgMywgeC5oYXNfcmVkdW5kYW5jeSA9IFAgPj4gMjAgJiAzLCB4LmRlZ3JhZGF0aW9uX3ByaW9yaXR5ID0gUCAmIDY1NTM1O1xuICAgICAgICAgICAgICAgIHZhciB5dCA9ICEhKFMudGZoZC5mbGFncyAmIG4uVEZIRF9GTEFHX0JBU0VfREFUQV9PRkZTRVQpLCBVdCA9ICEhKFMudGZoZC5mbGFncyAmIG4uVEZIRF9GTEFHX0RFRkFVTFRfQkFTRV9JU19NT09GKSwgaHQgPSAhIShULmZsYWdzICYgbi5UUlVOX0ZMQUdTX0RBVEFfT0ZGU0VUKSwgTyA9IDA7XG4gICAgICAgICAgICAgICAgeXQgPyBPID0gUy50ZmhkLmJhc2VfZGF0YV9vZmZzZXQgOiBVdCB8fCBlID09PSAwID8gTyA9IHcuc3RhcnQgOiBPID0gXywgZSA9PT0gMCAmJiBpID09PSAwID8gaHQgPyB4Lm9mZnNldCA9IE8gKyBULmRhdGFfb2Zmc2V0IDogeC5vZmZzZXQgPSBPIDogeC5vZmZzZXQgPSBfLCBfID0geC5vZmZzZXQgKyB4LnNpemUsIChTLnNiZ3BzLmxlbmd0aCA+IDAgfHwgUy5zZ3Bkcy5sZW5ndGggPiAwIHx8IFUubWRpYS5taW5mLnN0Ymwuc2JncHMubGVuZ3RoID4gMCB8fCBVLm1kaWEubWluZi5zdGJsLnNncGRzLmxlbmd0aCA+IDApICYmIHkuc2V0U2FtcGxlR3JvdXBQcm9wZXJ0aWVzKFUsIHgsIHgubnVtYmVyX2luX3RyYWYsIFMuc2FtcGxlX2dyb3Vwc19pbmZvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFMuc3Vicykge1xuICAgICAgICAgICAgICBVLmhhc19mcmFnbWVudF9zdWJzYW1wbGVzID0gITA7XG4gICAgICAgICAgICAgIHZhciB0dCA9IFMuZmlyc3Rfc2FtcGxlX2luZGV4O1xuICAgICAgICAgICAgICBmb3IgKGUgPSAwOyBlIDwgUy5zdWJzLmVudHJpZXMubGVuZ3RoOyBlKyspXG4gICAgICAgICAgICAgICAgdHQgKz0gUy5zdWJzLmVudHJpZXNbZV0uc2FtcGxlX2RlbHRhLCB4ID0gVS5zYW1wbGVzW3R0IC0gMV0sIHguc3Vic2FtcGxlcyA9IFMuc3Vicy5lbnRyaWVzW2VdLnN1YnNhbXBsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgIH1cbiAgfSwgeS5wcm90b3R5cGUuZ2V0U2FtcGxlID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHZhciBpLCBzID0gdC5zYW1wbGVzW2VdO1xuICAgIGlmICghdGhpcy5tb292KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKCFzLmRhdGEpXG4gICAgICBzLmRhdGEgPSBuZXcgVWludDhBcnJheShzLnNpemUpLCBzLmFscmVhZHlSZWFkID0gMCwgdGhpcy5zYW1wbGVzRGF0YVNpemUgKz0gcy5zaXplLCByLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkFsbG9jYXRpbmcgc2FtcGxlICNcIiArIGUgKyBcIiBvbiB0cmFjayAjXCIgKyB0LnRraGQudHJhY2tfaWQgKyBcIiBvZiBzaXplIFwiICsgcy5zaXplICsgXCIgKHRvdGFsOiBcIiArIHRoaXMuc2FtcGxlc0RhdGFTaXplICsgXCIpXCIpO1xuICAgIGVsc2UgaWYgKHMuYWxyZWFkeVJlYWQgPT0gcy5zaXplKVxuICAgICAgcmV0dXJuIHM7XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuc3RyZWFtLmZpbmRQb3NpdGlvbighMCwgcy5vZmZzZXQgKyBzLmFscmVhZHlSZWFkLCAhMSk7XG4gICAgICBpZiAobyA+IC0xKSB7XG4gICAgICAgIGkgPSB0aGlzLnN0cmVhbS5idWZmZXJzW29dO1xuICAgICAgICB2YXIgYyA9IGkuYnl0ZUxlbmd0aCAtIChzLm9mZnNldCArIHMuYWxyZWFkeVJlYWQgLSBpLmZpbGVTdGFydCk7XG4gICAgICAgIGlmIChzLnNpemUgLSBzLmFscmVhZHlSZWFkIDw9IGMpXG4gICAgICAgICAgcmV0dXJuIHIuZGVidWcoXCJJU09GaWxlXCIsIFwiR2V0dGluZyBzYW1wbGUgI1wiICsgZSArIFwiIGRhdGEgKGFscmVhZHlSZWFkOiBcIiArIHMuYWxyZWFkeVJlYWQgKyBcIiBvZmZzZXQ6IFwiICsgKHMub2Zmc2V0ICsgcy5hbHJlYWR5UmVhZCAtIGkuZmlsZVN0YXJ0KSArIFwiIHJlYWQgc2l6ZTogXCIgKyAocy5zaXplIC0gcy5hbHJlYWR5UmVhZCkgKyBcIiBmdWxsIHNpemU6IFwiICsgcy5zaXplICsgXCIpXCIpLCBhLm1lbWNweShcbiAgICAgICAgICAgIHMuZGF0YS5idWZmZXIsXG4gICAgICAgICAgICBzLmFscmVhZHlSZWFkLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHMub2Zmc2V0ICsgcy5hbHJlYWR5UmVhZCAtIGkuZmlsZVN0YXJ0LFxuICAgICAgICAgICAgcy5zaXplIC0gcy5hbHJlYWR5UmVhZFxuICAgICAgICAgICksIGkudXNlZEJ5dGVzICs9IHMuc2l6ZSAtIHMuYWxyZWFkeVJlYWQsIHRoaXMuc3RyZWFtLmxvZ0J1ZmZlckxldmVsKCksIHMuYWxyZWFkeVJlYWQgPSBzLnNpemUsIHM7XG4gICAgICAgIGlmIChjID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgci5kZWJ1ZyhcIklTT0ZpbGVcIiwgXCJHZXR0aW5nIHNhbXBsZSAjXCIgKyBlICsgXCIgcGFydGlhbCBkYXRhIChhbHJlYWR5UmVhZDogXCIgKyBzLmFscmVhZHlSZWFkICsgXCIgb2Zmc2V0OiBcIiArIChzLm9mZnNldCArIHMuYWxyZWFkeVJlYWQgLSBpLmZpbGVTdGFydCkgKyBcIiByZWFkIHNpemU6IFwiICsgYyArIFwiIGZ1bGwgc2l6ZTogXCIgKyBzLnNpemUgKyBcIilcIiksIGEubWVtY3B5KFxuICAgICAgICAgIHMuZGF0YS5idWZmZXIsXG4gICAgICAgICAgcy5hbHJlYWR5UmVhZCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHMub2Zmc2V0ICsgcy5hbHJlYWR5UmVhZCAtIGkuZmlsZVN0YXJ0LFxuICAgICAgICAgIGNcbiAgICAgICAgKSwgcy5hbHJlYWR5UmVhZCArPSBjLCBpLnVzZWRCeXRlcyArPSBjLCB0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCgpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwgeS5wcm90b3R5cGUucmVsZWFzZVNhbXBsZSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB2YXIgaSA9IHQuc2FtcGxlc1tlXTtcbiAgICByZXR1cm4gaS5kYXRhID8gKHRoaXMuc2FtcGxlc0RhdGFTaXplIC09IGkuc2l6ZSwgaS5kYXRhID0gbnVsbCwgaS5hbHJlYWR5UmVhZCA9IDAsIGkuc2l6ZSkgOiAwO1xuICB9LCB5LnByb3RvdHlwZS5nZXRBbGxvY2F0ZWRTYW1wbGVEYXRhU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNhbXBsZXNEYXRhU2l6ZTtcbiAgfSwgeS5wcm90b3R5cGUuZ2V0Q29kZWNzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQsIGUgPSBcIlwiO1xuICAgIGZvciAodCA9IDA7IHQgPCB0aGlzLm1vb3YudHJha3MubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBpID0gdGhpcy5tb292LnRyYWtzW3RdO1xuICAgICAgdCA+IDAgJiYgKGUgKz0gXCIsXCIpLCBlICs9IGkubWRpYS5taW5mLnN0Ymwuc3RzZC5lbnRyaWVzWzBdLmdldENvZGVjKCk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCB5LnByb3RvdHlwZS5nZXRUcmV4QnlJZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZTtcbiAgICBpZiAoIXRoaXMubW9vdiB8fCAhdGhpcy5tb292Lm12ZXgpIHJldHVybiBudWxsO1xuICAgIGZvciAoZSA9IDA7IGUgPCB0aGlzLm1vb3YubXZleC50cmV4cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIGkgPSB0aGlzLm1vb3YubXZleC50cmV4c1tlXTtcbiAgICAgIGlmIChpLnRyYWNrX2lkID09IHQpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSwgeS5wcm90b3R5cGUuZ2V0VHJhY2tCeUlkID0gZnVuY3Rpb24odCkge1xuICAgIGlmICh0aGlzLm1vb3YgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5tb292LnRyYWtzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgaSA9IHRoaXMubW9vdi50cmFrc1tlXTtcbiAgICAgIGlmIChpLnRraGQudHJhY2tfaWQgPT0gdCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LCB5LnByb3RvdHlwZS5pdGVtcyA9IFtdLCB5LnByb3RvdHlwZS5pdGVtc0RhdGFTaXplID0gMCwgeS5wcm90b3R5cGUuZmxhdHRlbkl0ZW1JbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSB0aGlzLml0ZW1zLCBlLCBpLCBzLCBvID0gdGhpcy5tZXRhO1xuICAgIGlmIChvICE9IG51bGwgJiYgby5oZGxyICE9PSB2b2lkIDAgJiYgby5paW5mICE9PSB2b2lkIDApIHtcbiAgICAgIGZvciAoZSA9IDA7IGUgPCBvLmlpbmYuaXRlbV9pbmZvcy5sZW5ndGg7IGUrKylcbiAgICAgICAgcyA9IHt9LCBzLmlkID0gby5paW5mLml0ZW1faW5mb3NbZV0uaXRlbV9JRCwgdFtzLmlkXSA9IHMsIHMucmVmX3RvID0gW10sIHMubmFtZSA9IG8uaWluZi5pdGVtX2luZm9zW2VdLml0ZW1fbmFtZSwgby5paW5mLml0ZW1faW5mb3NbZV0ucHJvdGVjdGlvbl9pbmRleCA+IDAgJiYgKHMucHJvdGVjdGlvbiA9IG8uaXByby5wcm90ZWN0aW9uc1tvLmlpbmYuaXRlbV9pbmZvc1tlXS5wcm90ZWN0aW9uX2luZGV4IC0gMV0pLCBvLmlpbmYuaXRlbV9pbmZvc1tlXS5pdGVtX3R5cGUgPyBzLnR5cGUgPSBvLmlpbmYuaXRlbV9pbmZvc1tlXS5pdGVtX3R5cGUgOiBzLnR5cGUgPSBcIm1pbWVcIiwgcy5jb250ZW50X3R5cGUgPSBvLmlpbmYuaXRlbV9pbmZvc1tlXS5jb250ZW50X3R5cGUsIHMuY29udGVudF9lbmNvZGluZyA9IG8uaWluZi5pdGVtX2luZm9zW2VdLmNvbnRlbnRfZW5jb2Rpbmc7XG4gICAgICBpZiAoby5pbG9jKVxuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgby5pbG9jLml0ZW1zLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgdmFyIGMgPSBvLmlsb2MuaXRlbXNbZV07XG4gICAgICAgICAgc3dpdGNoIChzID0gdFtjLml0ZW1fSURdLCBjLmRhdGFfcmVmZXJlbmNlX2luZGV4ICE9PSAwICYmIChyLndhcm4oXCJJdGVtIHN0b3JhZ2Ugd2l0aCByZWZlcmVuY2UgdG8gb3RoZXIgZmlsZXM6IG5vdCBzdXBwb3J0ZWRcIiksIHMuc291cmNlID0gby5kaW5mLmJveGVzW2MuZGF0YV9yZWZlcmVuY2VfaW5kZXggLSAxXSksIGMuY29uc3RydWN0aW9uX21ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgci53YXJuKFwiSXRlbSBzdG9yYWdlIHdpdGggY29uc3RydWN0aW9uX21ldGhvZCA6IG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByLndhcm4oXCJJdGVtIHN0b3JhZ2Ugd2l0aCBjb25zdHJ1Y3Rpb25fbWV0aG9kIDogbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAocy5leHRlbnRzID0gW10sIHMuc2l6ZSA9IDAsIGkgPSAwOyBpIDwgYy5leHRlbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcy5leHRlbnRzW2ldID0ge30sIHMuZXh0ZW50c1tpXS5vZmZzZXQgPSBjLmV4dGVudHNbaV0uZXh0ZW50X29mZnNldCArIGMuYmFzZV9vZmZzZXQsIHMuZXh0ZW50c1tpXS5sZW5ndGggPSBjLmV4dGVudHNbaV0uZXh0ZW50X2xlbmd0aCwgcy5leHRlbnRzW2ldLmFscmVhZHlSZWFkID0gMCwgcy5zaXplICs9IHMuZXh0ZW50c1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIGlmIChvLnBpdG0gJiYgKHRbby5waXRtLml0ZW1faWRdLnByaW1hcnkgPSAhMCksIG8uaXJlZilcbiAgICAgICAgZm9yIChlID0gMDsgZSA8IG8uaXJlZi5yZWZlcmVuY2VzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgdmFyIHUgPSBvLmlyZWYucmVmZXJlbmNlc1tlXTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdS5yZWZlcmVuY2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdFt1LmZyb21faXRlbV9JRF0ucmVmX3RvLnB1c2goeyB0eXBlOiB1LnR5cGUsIGlkOiB1LnJlZmVyZW5jZXNbaV0gfSk7XG4gICAgICAgIH1cbiAgICAgIGlmIChvLmlwcnApXG4gICAgICAgIGZvciAodmFyIF8gPSAwOyBfIDwgby5pcHJwLmlwbWFzLmxlbmd0aDsgXysrKSB7XG4gICAgICAgICAgdmFyIGcgPSBvLmlwcnAuaXBtYXNbX107XG4gICAgICAgICAgZm9yIChlID0gMDsgZSA8IGcuYXNzb2NpYXRpb25zLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgICB2YXIgdyA9IGcuYXNzb2NpYXRpb25zW2VdO1xuICAgICAgICAgICAgZm9yIChzID0gdFt3LmlkXSwgcy5wcm9wZXJ0aWVzID09PSB2b2lkIDAgJiYgKHMucHJvcGVydGllcyA9IHt9LCBzLnByb3BlcnRpZXMuYm94ZXMgPSBbXSksIGkgPSAwOyBpIDwgdy5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgUyA9IHcucHJvcHNbaV07XG4gICAgICAgICAgICAgIGlmIChTLnByb3BlcnR5X2luZGV4ID4gMCAmJiBTLnByb3BlcnR5X2luZGV4IC0gMSA8IG8uaXBycC5pcGNvLmJveGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBVID0gby5pcHJwLmlwY28uYm94ZXNbUy5wcm9wZXJ0eV9pbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIHMucHJvcGVydGllc1tVLnR5cGVdID0gVSwgcy5wcm9wZXJ0aWVzLmJveGVzLnB1c2goVSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH0sIHkucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGk7XG4gICAgaWYgKCF0aGlzLm1ldGEpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaSA9IHRoaXMuaXRlbXNbdF0sICFpLmRhdGEgJiYgaS5zaXplKVxuICAgICAgaS5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoaS5zaXplKSwgaS5hbHJlYWR5UmVhZCA9IDAsIHRoaXMuaXRlbXNEYXRhU2l6ZSArPSBpLnNpemUsIHIuZGVidWcoXCJJU09GaWxlXCIsIFwiQWxsb2NhdGluZyBpdGVtICNcIiArIHQgKyBcIiBvZiBzaXplIFwiICsgaS5zaXplICsgXCIgKHRvdGFsOiBcIiArIHRoaXMuaXRlbXNEYXRhU2l6ZSArIFwiKVwiKTtcbiAgICBlbHNlIGlmIChpLmFscmVhZHlSZWFkID09PSBpLnNpemUpXG4gICAgICByZXR1cm4gaTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IGkuZXh0ZW50cy5sZW5ndGg7IHMrKykge1xuICAgICAgdmFyIG8gPSBpLmV4dGVudHNbc107XG4gICAgICBpZiAoby5hbHJlYWR5UmVhZCAhPT0gby5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnN0cmVhbS5maW5kUG9zaXRpb24oITAsIG8ub2Zmc2V0ICsgby5hbHJlYWR5UmVhZCwgITEpO1xuICAgICAgICBpZiAoYyA+IC0xKSB7XG4gICAgICAgICAgZSA9IHRoaXMuc3RyZWFtLmJ1ZmZlcnNbY107XG4gICAgICAgICAgdmFyIHUgPSBlLmJ5dGVMZW5ndGggLSAoby5vZmZzZXQgKyBvLmFscmVhZHlSZWFkIC0gZS5maWxlU3RhcnQpO1xuICAgICAgICAgIGlmIChvLmxlbmd0aCAtIG8uYWxyZWFkeVJlYWQgPD0gdSlcbiAgICAgICAgICAgIHIuZGVidWcoXCJJU09GaWxlXCIsIFwiR2V0dGluZyBpdGVtICNcIiArIHQgKyBcIiBleHRlbnQgI1wiICsgcyArIFwiIGRhdGEgKGFscmVhZHlSZWFkOiBcIiArIG8uYWxyZWFkeVJlYWQgKyBcIiBvZmZzZXQ6IFwiICsgKG8ub2Zmc2V0ICsgby5hbHJlYWR5UmVhZCAtIGUuZmlsZVN0YXJ0KSArIFwiIHJlYWQgc2l6ZTogXCIgKyAoby5sZW5ndGggLSBvLmFscmVhZHlSZWFkKSArIFwiIGZ1bGwgZXh0ZW50IHNpemU6IFwiICsgby5sZW5ndGggKyBcIiBmdWxsIGl0ZW0gc2l6ZTogXCIgKyBpLnNpemUgKyBcIilcIiksIGEubWVtY3B5KFxuICAgICAgICAgICAgICBpLmRhdGEuYnVmZmVyLFxuICAgICAgICAgICAgICBpLmFscmVhZHlSZWFkLFxuICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICBvLm9mZnNldCArIG8uYWxyZWFkeVJlYWQgLSBlLmZpbGVTdGFydCxcbiAgICAgICAgICAgICAgby5sZW5ndGggLSBvLmFscmVhZHlSZWFkXG4gICAgICAgICAgICApLCBlLnVzZWRCeXRlcyArPSBvLmxlbmd0aCAtIG8uYWxyZWFkeVJlYWQsIHRoaXMuc3RyZWFtLmxvZ0J1ZmZlckxldmVsKCksIGkuYWxyZWFkeVJlYWQgKz0gby5sZW5ndGggLSBvLmFscmVhZHlSZWFkLCBvLmFscmVhZHlSZWFkID0gby5sZW5ndGg7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHIuZGVidWcoXCJJU09GaWxlXCIsIFwiR2V0dGluZyBpdGVtICNcIiArIHQgKyBcIiBleHRlbnQgI1wiICsgcyArIFwiIHBhcnRpYWwgZGF0YSAoYWxyZWFkeVJlYWQ6IFwiICsgby5hbHJlYWR5UmVhZCArIFwiIG9mZnNldDogXCIgKyAoby5vZmZzZXQgKyBvLmFscmVhZHlSZWFkIC0gZS5maWxlU3RhcnQpICsgXCIgcmVhZCBzaXplOiBcIiArIHUgKyBcIiBmdWxsIGV4dGVudCBzaXplOiBcIiArIG8ubGVuZ3RoICsgXCIgZnVsbCBpdGVtIHNpemU6IFwiICsgaS5zaXplICsgXCIpXCIpLCBhLm1lbWNweShcbiAgICAgICAgICAgICAgaS5kYXRhLmJ1ZmZlcixcbiAgICAgICAgICAgICAgaS5hbHJlYWR5UmVhZCxcbiAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgby5vZmZzZXQgKyBvLmFscmVhZHlSZWFkIC0gZS5maWxlU3RhcnQsXG4gICAgICAgICAgICAgIHVcbiAgICAgICAgICAgICksIG8uYWxyZWFkeVJlYWQgKz0gdSwgaS5hbHJlYWR5UmVhZCArPSB1LCBlLnVzZWRCeXRlcyArPSB1LCB0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCgpLCBudWxsO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGkuYWxyZWFkeVJlYWQgPT09IGkuc2l6ZSA/IGkgOiBudWxsO1xuICB9LCB5LnByb3RvdHlwZS5yZWxlYXNlSXRlbSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHRoaXMuaXRlbXNbdF07XG4gICAgaWYgKGUuZGF0YSkge1xuICAgICAgdGhpcy5pdGVtc0RhdGFTaXplIC09IGUuc2l6ZSwgZS5kYXRhID0gbnVsbCwgZS5hbHJlYWR5UmVhZCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGUuZXh0ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcyA9IGUuZXh0ZW50c1tpXTtcbiAgICAgICAgcy5hbHJlYWR5UmVhZCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5zaXplO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIDA7XG4gIH0sIHkucHJvdG90eXBlLnByb2Nlc3NJdGVtcyA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlIGluIHRoaXMuaXRlbXMpIHtcbiAgICAgIHZhciBpID0gdGhpcy5pdGVtc1tlXTtcbiAgICAgIHRoaXMuZ2V0SXRlbShpLmlkKSwgdCAmJiAhaS5zZW50ICYmICh0KGkpLCBpLnNlbnQgPSAhMCwgaS5kYXRhID0gbnVsbCk7XG4gICAgfVxuICB9LCB5LnByb3RvdHlwZS5oYXNJdGVtID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgaW4gdGhpcy5pdGVtcykge1xuICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zW2VdO1xuICAgICAgaWYgKGkubmFtZSA9PT0gdClcbiAgICAgICAgcmV0dXJuIGkuaWQ7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSwgeS5wcm90b3R5cGUuZ2V0TWV0YUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhID8gdGhpcy5tZXRhLmhkbHIuaGFuZGxlciA6IG51bGw7XG4gIH0sIHkucHJvdG90eXBlLmdldFByaW1hcnlJdGVtID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLm1ldGEgfHwgIXRoaXMubWV0YS5waXRtID8gbnVsbCA6IHRoaXMuZ2V0SXRlbSh0aGlzLm1ldGEucGl0bS5pdGVtX2lkKTtcbiAgfSwgeS5wcm90b3R5cGUuaXRlbVRvRnJhZ21lbnRlZFRyYWNrRmlsZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQgfHwge30sIGkgPSBudWxsO1xuICAgIGlmIChlLml0ZW1JZCA/IGkgPSB0aGlzLmdldEl0ZW0oZS5pdGVtSWQpIDogaSA9IHRoaXMuZ2V0UHJpbWFyeUl0ZW0oKSwgaSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgcyA9IG5ldyB5KCk7XG4gICAgcy5kaXNjYXJkTWRhdERhdGEgPSAhMTtcbiAgICB2YXIgbyA9IHsgdHlwZTogaS50eXBlLCBkZXNjcmlwdGlvbl9ib3hlczogaS5wcm9wZXJ0aWVzLmJveGVzIH07XG4gICAgaS5wcm9wZXJ0aWVzLmlzcGUgJiYgKG8ud2lkdGggPSBpLnByb3BlcnRpZXMuaXNwZS5pbWFnZV93aWR0aCwgby5oZWlnaHQgPSBpLnByb3BlcnRpZXMuaXNwZS5pbWFnZV9oZWlnaHQpO1xuICAgIHZhciBjID0gcy5hZGRUcmFjayhvKTtcbiAgICByZXR1cm4gYyA/IChzLmFkZFNhbXBsZShjLCBpLmRhdGEpLCBzKSA6IG51bGw7XG4gIH0sIHkucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5ib3hlcy5sZW5ndGg7IGUrKylcbiAgICAgIHRoaXMuYm94ZXNbZV0ud3JpdGUodCk7XG4gIH0sIHkucHJvdG90eXBlLmNyZWF0ZUZyYWdtZW50ID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICAgIHZhciBzID0gdGhpcy5nZXRUcmFja0J5SWQodCksIG8gPSB0aGlzLmdldFNhbXBsZShzLCBlKTtcbiAgICBpZiAobyA9PSBudWxsKVxuICAgICAgcmV0dXJuIG8gPSBzLnNhbXBsZXNbZV0sIHRoaXMubmV4dFNlZWtQb3NpdGlvbiA/IHRoaXMubmV4dFNlZWtQb3NpdGlvbiA9IE1hdGgubWluKG8ub2Zmc2V0ICsgby5hbHJlYWR5UmVhZCwgdGhpcy5uZXh0U2Vla1Bvc2l0aW9uKSA6IHRoaXMubmV4dFNlZWtQb3NpdGlvbiA9IHMuc2FtcGxlc1tlXS5vZmZzZXQgKyBvLmFscmVhZHlSZWFkLCBudWxsO1xuICAgIHZhciBjID0gaSB8fCBuZXcgYSgpO1xuICAgIGMuZW5kaWFubmVzcyA9IGEuQklHX0VORElBTjtcbiAgICB2YXIgdSA9IHRoaXMuY3JlYXRlU2luZ2xlU2FtcGxlTW9vZihvKTtcbiAgICB1LndyaXRlKGMpLCB1LnRyYWZzWzBdLnRydW5zWzBdLmRhdGFfb2Zmc2V0ID0gdS5zaXplICsgOCwgci5kZWJ1ZyhcIk1QNEJveFwiLCBcIkFkanVzdGluZyBkYXRhX29mZnNldCB3aXRoIG5ldyB2YWx1ZSBcIiArIHUudHJhZnNbMF0udHJ1bnNbMF0uZGF0YV9vZmZzZXQpLCBjLmFkanVzdFVpbnQzMih1LnRyYWZzWzBdLnRydW5zWzBdLmRhdGFfb2Zmc2V0X3Bvc2l0aW9uLCB1LnRyYWZzWzBdLnRydW5zWzBdLmRhdGFfb2Zmc2V0KTtcbiAgICB2YXIgXyA9IG5ldyBuLm1kYXRCb3goKTtcbiAgICByZXR1cm4gXy5kYXRhID0gby5kYXRhLCBfLndyaXRlKGMpLCBjO1xuICB9LCB5LndyaXRlSW5pdGlhbGl6YXRpb25TZWdtZW50ID0gZnVuY3Rpb24odCwgZSwgaSwgcykge1xuICAgIHZhciBvO1xuICAgIHIuZGVidWcoXCJJU09GaWxlXCIsIFwiR2VuZXJhdGluZyBpbml0aWFsaXphdGlvbiBzZWdtZW50XCIpO1xuICAgIHZhciBjID0gbmV3IGEoKTtcbiAgICBjLmVuZGlhbm5lc3MgPSBhLkJJR19FTkRJQU4sIHQud3JpdGUoYyk7XG4gICAgdmFyIHUgPSBlLmFkZChcIm12ZXhcIik7XG4gICAgZm9yIChpICYmIHUuYWRkKFwibWVoZFwiKS5zZXQoXCJmcmFnbWVudF9kdXJhdGlvblwiLCBpKSwgbyA9IDA7IG8gPCBlLnRyYWtzLmxlbmd0aDsgbysrKVxuICAgICAgdS5hZGQoXCJ0cmV4XCIpLnNldChcInRyYWNrX2lkXCIsIGUudHJha3Nbb10udGtoZC50cmFja19pZCkuc2V0KFwiZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcIiwgMSkuc2V0KFwiZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cIiwgcykuc2V0KFwiZGVmYXVsdF9zYW1wbGVfc2l6ZVwiLCAwKS5zZXQoXCJkZWZhdWx0X3NhbXBsZV9mbGFnc1wiLCA2NTUzNik7XG4gICAgcmV0dXJuIGUud3JpdGUoYyksIGMuYnVmZmVyO1xuICB9LCB5LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gbmV3IGEoKTtcbiAgICBlLmVuZGlhbm5lc3MgPSBhLkJJR19FTkRJQU4sIHRoaXMud3JpdGUoZSksIGUuc2F2ZSh0KTtcbiAgfSwgeS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBuZXcgYSgpO1xuICAgIHJldHVybiB0LmVuZGlhbm5lc3MgPSBhLkJJR19FTkRJQU4sIHRoaXMud3JpdGUodCksIHQuYnVmZmVyO1xuICB9LCB5LnByb3RvdHlwZS5pbml0aWFsaXplU2VnbWVudGF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQsIGUsIGksIHM7XG4gICAgZm9yICh0aGlzLm9uU2VnbWVudCA9PT0gbnVsbCAmJiByLndhcm4oXCJNUDRCb3hcIiwgXCJObyBzZWdtZW50YXRpb24gY2FsbGJhY2sgc2V0IVwiKSwgdGhpcy5pc0ZyYWdtZW50YXRpb25Jbml0aWFsaXplZCB8fCAodGhpcy5pc0ZyYWdtZW50YXRpb25Jbml0aWFsaXplZCA9ICEwLCB0aGlzLm5leHRNb29mTnVtYmVyID0gMCwgdGhpcy5yZXNldFRhYmxlcygpKSwgZSA9IFtdLCB0ID0gMDsgdCA8IHRoaXMuZnJhZ21lbnRlZFRyYWNrcy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG8gPSBuZXcgbi5tb292Qm94KCk7XG4gICAgICBvLm12aGQgPSB0aGlzLm1vb3YubXZoZCwgby5ib3hlcy5wdXNoKG8ubXZoZCksIGkgPSB0aGlzLmdldFRyYWNrQnlJZCh0aGlzLmZyYWdtZW50ZWRUcmFja3NbdF0uaWQpLCBvLmJveGVzLnB1c2goaSksIG8udHJha3MucHVzaChpKSwgcyA9IHt9LCBzLmlkID0gaS50a2hkLnRyYWNrX2lkLCBzLnVzZXIgPSB0aGlzLmZyYWdtZW50ZWRUcmFja3NbdF0udXNlciwgcy5idWZmZXIgPSB5LndyaXRlSW5pdGlhbGl6YXRpb25TZWdtZW50KHRoaXMuZnR5cCwgbywgdGhpcy5tb292Lm12ZXggJiYgdGhpcy5tb292Lm12ZXgubWVoZCA/IHRoaXMubW9vdi5tdmV4Lm1laGQuZnJhZ21lbnRfZHVyYXRpb24gOiB2b2lkIDAsIHRoaXMubW9vdi50cmFrc1t0XS5zYW1wbGVzLmxlbmd0aCA+IDAgPyB0aGlzLm1vb3YudHJha3NbdF0uc2FtcGxlc1swXS5kdXJhdGlvbiA6IDApLCBlLnB1c2gocyk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBuLkJveC5wcm90b3R5cGUucHJpbnRIZWFkZXIgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zaXplICs9IDgsIHRoaXMuc2l6ZSA+IGYgJiYgKHRoaXMuc2l6ZSArPSA4KSwgdGhpcy50eXBlID09PSBcInV1aWRcIiAmJiAodGhpcy5zaXplICs9IDE2KSwgdC5sb2codC5pbmRlbnQgKyBcInNpemU6XCIgKyB0aGlzLnNpemUpLCB0LmxvZyh0LmluZGVudCArIFwidHlwZTpcIiArIHRoaXMudHlwZSk7XG4gIH0sIG4uRnVsbEJveC5wcm90b3R5cGUucHJpbnRIZWFkZXIgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zaXplICs9IDQsIG4uQm94LnByb3RvdHlwZS5wcmludEhlYWRlci5jYWxsKHRoaXMsIHQpLCB0LmxvZyh0LmluZGVudCArIFwidmVyc2lvbjpcIiArIHRoaXMudmVyc2lvbiksIHQubG9nKHQuaW5kZW50ICsgXCJmbGFnczpcIiArIHRoaXMuZmxhZ3MpO1xuICB9LCBuLkJveC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wcmludEhlYWRlcih0KTtcbiAgfSwgbi5Db250YWluZXJCb3gucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMucHJpbnRIZWFkZXIodCk7XG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmJveGVzLmxlbmd0aDsgZSsrKVxuICAgICAgaWYgKHRoaXMuYm94ZXNbZV0pIHtcbiAgICAgICAgdmFyIGkgPSB0LmluZGVudDtcbiAgICAgICAgdC5pbmRlbnQgKz0gXCIgXCIsIHRoaXMuYm94ZXNbZV0ucHJpbnQodCksIHQuaW5kZW50ID0gaTtcbiAgICAgIH1cbiAgfSwgeS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbih0KSB7XG4gICAgdC5pbmRlbnQgPSBcIlwiO1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5ib3hlcy5sZW5ndGg7IGUrKylcbiAgICAgIHRoaXMuYm94ZXNbZV0gJiYgdGhpcy5ib3hlc1tlXS5wcmludCh0KTtcbiAgfSwgbi5tdmhkQm94LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uKHQpIHtcbiAgICBuLkZ1bGxCb3gucHJvdG90eXBlLnByaW50SGVhZGVyLmNhbGwodGhpcywgdCksIHQubG9nKHQuaW5kZW50ICsgXCJjcmVhdGlvbl90aW1lOiBcIiArIHRoaXMuY3JlYXRpb25fdGltZSksIHQubG9nKHQuaW5kZW50ICsgXCJtb2RpZmljYXRpb25fdGltZTogXCIgKyB0aGlzLm1vZGlmaWNhdGlvbl90aW1lKSwgdC5sb2codC5pbmRlbnQgKyBcInRpbWVzY2FsZTogXCIgKyB0aGlzLnRpbWVzY2FsZSksIHQubG9nKHQuaW5kZW50ICsgXCJkdXJhdGlvbjogXCIgKyB0aGlzLmR1cmF0aW9uKSwgdC5sb2codC5pbmRlbnQgKyBcInJhdGU6IFwiICsgdGhpcy5yYXRlKSwgdC5sb2codC5pbmRlbnQgKyBcInZvbHVtZTogXCIgKyAodGhpcy52b2x1bWUgPj4gOCkpLCB0LmxvZyh0LmluZGVudCArIFwibWF0cml4OiBcIiArIHRoaXMubWF0cml4LmpvaW4oXCIsIFwiKSksIHQubG9nKHQuaW5kZW50ICsgXCJuZXh0X3RyYWNrX2lkOiBcIiArIHRoaXMubmV4dF90cmFja19pZCk7XG4gIH0sIG4udGtoZEJveC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbih0KSB7XG4gICAgbi5GdWxsQm94LnByb3RvdHlwZS5wcmludEhlYWRlci5jYWxsKHRoaXMsIHQpLCB0LmxvZyh0LmluZGVudCArIFwiY3JlYXRpb25fdGltZTogXCIgKyB0aGlzLmNyZWF0aW9uX3RpbWUpLCB0LmxvZyh0LmluZGVudCArIFwibW9kaWZpY2F0aW9uX3RpbWU6IFwiICsgdGhpcy5tb2RpZmljYXRpb25fdGltZSksIHQubG9nKHQuaW5kZW50ICsgXCJ0cmFja19pZDogXCIgKyB0aGlzLnRyYWNrX2lkKSwgdC5sb2codC5pbmRlbnQgKyBcImR1cmF0aW9uOiBcIiArIHRoaXMuZHVyYXRpb24pLCB0LmxvZyh0LmluZGVudCArIFwidm9sdW1lOiBcIiArICh0aGlzLnZvbHVtZSA+PiA4KSksIHQubG9nKHQuaW5kZW50ICsgXCJtYXRyaXg6IFwiICsgdGhpcy5tYXRyaXguam9pbihcIiwgXCIpKSwgdC5sb2codC5pbmRlbnQgKyBcImxheWVyOiBcIiArIHRoaXMubGF5ZXIpLCB0LmxvZyh0LmluZGVudCArIFwiYWx0ZXJuYXRlX2dyb3VwOiBcIiArIHRoaXMuYWx0ZXJuYXRlX2dyb3VwKSwgdC5sb2codC5pbmRlbnQgKyBcIndpZHRoOiBcIiArIHRoaXMud2lkdGgpLCB0LmxvZyh0LmluZGVudCArIFwiaGVpZ2h0OiBcIiArIHRoaXMuaGVpZ2h0KTtcbiAgfTtcbiAgdmFyIEIgPSB7fTtcbiAgQi5jcmVhdGVGaWxlID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHZhciBpID0gdCAhPT0gdm9pZCAwID8gdCA6ICEwLCBzID0gbmV3IHkoZSk7XG4gICAgcmV0dXJuIHMuZGlzY2FyZE1kYXREYXRhID0gIWksIHM7XG4gIH0sIGwuY3JlYXRlRmlsZSA9IEIuY3JlYXRlRmlsZTtcbn0pKEdlKTtcbmNvbnN0IEQgPSAvKiBAX19QVVJFX18gKi8geGkoR2UpLCBxID0ge1xuICBzYW1wbGVSYXRlOiA0OGUzLFxuICBjaGFubmVsQ291bnQ6IDIsXG4gIGNvZGVjOiBcIm1wNGEuNDAuMlwiXG59O1xuZnVuY3Rpb24gZGUobCwgcikge1xuICBjb25zdCBoID0gci52aWRlb1RyYWNrc1swXSwgYSA9IHt9O1xuICBpZiAoaCAhPSBudWxsKSB7XG4gICAgY29uc3QgZCA9IFVpKGwuZ2V0VHJhY2tCeUlkKGguaWQpKS5idWZmZXIsIHsgZGVzY0tleTogcCwgdHlwZTogbiB9ID0gaC5jb2RlYy5zdGFydHNXaXRoKFwiYXZjMVwiKSA/IHsgZGVzY0tleTogXCJhdmNEZWNvZGVyQ29uZmlnUmVjb3JkXCIsIHR5cGU6IFwiYXZjMVwiIH0gOiBoLmNvZGVjLnN0YXJ0c1dpdGgoXCJodmMxXCIpID8geyBkZXNjS2V5OiBcImhldmNEZWNvZGVyQ29uZmlnUmVjb3JkXCIsIHR5cGU6IFwiaHZjMVwiIH0gOiB7IGRlc2NLZXk6IFwiXCIsIHR5cGU6IFwiXCIgfTtcbiAgICBwICE9PSBcIlwiICYmIChhLnZpZGVvVHJhY2tDb25mID0ge1xuICAgICAgdGltZXNjYWxlOiBoLnRpbWVzY2FsZSxcbiAgICAgIGR1cmF0aW9uOiBoLmR1cmF0aW9uLFxuICAgICAgd2lkdGg6IGgudmlkZW8ud2lkdGgsXG4gICAgICBoZWlnaHQ6IGgudmlkZW8uaGVpZ2h0LFxuICAgICAgYnJhbmRzOiByLmJyYW5kcyxcbiAgICAgIHR5cGU6IG4sXG4gICAgICBbcF06IGRcbiAgICB9KSwgYS52aWRlb0RlY29kZXJDb25mID0ge1xuICAgICAgY29kZWM6IGguY29kZWMsXG4gICAgICBjb2RlZEhlaWdodDogaC52aWRlby5oZWlnaHQsXG4gICAgICBjb2RlZFdpZHRoOiBoLnZpZGVvLndpZHRoLFxuICAgICAgZGVzY3JpcHRpb246IGRcbiAgICB9O1xuICB9XG4gIGNvbnN0IGYgPSByLmF1ZGlvVHJhY2tzWzBdO1xuICBpZiAoZiAhPSBudWxsKSB7XG4gICAgY29uc3QgZCA9IFNlKGwpO1xuICAgIGEuYXVkaW9UcmFja0NvbmYgPSB7XG4gICAgICB0aW1lc2NhbGU6IGYudGltZXNjYWxlLFxuICAgICAgc2FtcGxlcmF0ZTogZi5hdWRpby5zYW1wbGVfcmF0ZSxcbiAgICAgIGNoYW5uZWxfY291bnQ6IGYuYXVkaW8uY2hhbm5lbF9jb3VudCxcbiAgICAgIGhkbHI6IFwic291blwiLFxuICAgICAgdHlwZTogZi5jb2RlYy5zdGFydHNXaXRoKFwibXA0YVwiKSA/IFwibXA0YVwiIDogZi5jb2RlYyxcbiAgICAgIGRlc2NyaXB0aW9uOiBTZShsKVxuICAgIH0sIGEuYXVkaW9EZWNvZGVyQ29uZiA9IHtcbiAgICAgIGNvZGVjOiBmLmNvZGVjLnN0YXJ0c1dpdGgoXCJtcDRhXCIpID8gcS5jb2RlYyA6IGYuY29kZWMsXG4gICAgICBudW1iZXJPZkNoYW5uZWxzOiBmLmF1ZGlvLmNoYW5uZWxfY291bnQsXG4gICAgICBzYW1wbGVSYXRlOiBmLmF1ZGlvLnNhbXBsZV9yYXRlLFxuICAgICAgLi4uZCA9PSBudWxsID8ge30gOiBFaShkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBVaShsKSB7XG4gIGZvciAoY29uc3QgciBvZiBsLm1kaWEubWluZi5zdGJsLnN0c2QuZW50cmllcykge1xuICAgIGNvbnN0IGggPSByLmF2Y0MgPz8gci5odmNDID8/IHIudnBjQztcbiAgICBpZiAoaCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBhID0gbmV3IEQuRGF0YVN0cmVhbShcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICAwLFxuICAgICAgICBELkRhdGFTdHJlYW0uQklHX0VORElBTlxuICAgICAgKTtcbiAgICAgIHJldHVybiBoLndyaXRlKGEpLCBuZXcgVWludDhBcnJheShhLmJ1ZmZlci5zbGljZSg4KSk7XG4gICAgfVxuICB9XG4gIHRocm93IEVycm9yKFwiYXZjQywgaHZjQyBvciBWUFggbm90IGZvdW5kXCIpO1xufVxuZnVuY3Rpb24gU2UobCwgciA9IFwibXA0YVwiKSB7XG4gIHZhciBhO1xuICBjb25zdCBoID0gKGEgPSBsLm1vb3YpID09IG51bGwgPyB2b2lkIDAgOiBhLnRyYWtzLm1hcCgoZikgPT4gZi5tZGlhLm1pbmYuc3RibC5zdHNkLmVudHJpZXMpLmZsYXQoKS5maW5kKCh7IHR5cGU6IGYgfSkgPT4gZiA9PT0gcik7XG4gIHJldHVybiBoID09IG51bGwgPyB2b2lkIDAgOiBoLmVzZHM7XG59XG5mdW5jdGlvbiBFaShsKSB7XG4gIHZhciBuO1xuICBjb25zdCByID0gKG4gPSBsLmVzZC5kZXNjc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uZGVzY3NbMF07XG4gIGlmIChyID09IG51bGwpIHJldHVybiB7fTtcbiAgY29uc3QgW2gsIGFdID0gci5kYXRhLCBmID0gKChoICYgNykgPDwgMSkgKyAoYSA+PiA3KSwgZCA9IChhICYgMTI3KSA+PiAzO1xuICByZXR1cm4ge1xuICAgIHNhbXBsZVJhdGU6IFtcbiAgICAgIDk2ZTMsXG4gICAgICA4ODIwMCxcbiAgICAgIDY0ZTMsXG4gICAgICA0OGUzLFxuICAgICAgNDQxMDAsXG4gICAgICAzMmUzLFxuICAgICAgMjRlMyxcbiAgICAgIDIyMDUwLFxuICAgICAgMTZlMyxcbiAgICAgIDEyZTMsXG4gICAgICAxMTAyNSxcbiAgICAgIDhlMyxcbiAgICAgIDczNTBcbiAgICBdW2ZdLFxuICAgIG51bWJlck9mQ2hhbm5lbHM6IGRcbiAgfTtcbn1cbmZ1bmN0aW9uIEFpKGwpIHtcbiAgaWYgKGwubW9vdiAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBsLm1vb3YudHJha3MubGVuZ3RoOyByKyspXG4gICAgICBsLm1vb3YudHJha3Nbcl0uc2FtcGxlcyA9IFtdO1xuICAgIGwubWRhdHMgPSBbXSwgbC5tb29mcyA9IFtdO1xuICB9XG59XG52YXIgenQ7XG5jbGFzcyBjZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIFIodGhpcywgXCJyZWFkYWJsZVwiKTtcbiAgICBSKHRoaXMsIFwid3JpdGFibGVcIik7XG4gICAgQSh0aGlzLCB6dCwgMCk7XG4gICAgY29uc3QgciA9IEQuY3JlYXRlRmlsZSgpO1xuICAgIGxldCBoID0gITE7XG4gICAgdGhpcy5yZWFkYWJsZSA9IG5ldyBSZWFkYWJsZVN0cmVhbShcbiAgICAgIHtcbiAgICAgICAgc3RhcnQ6IChhKSA9PiB7XG4gICAgICAgICAgci5vblJlYWR5ID0gKGQpID0+IHtcbiAgICAgICAgICAgIHZhciB2LCBiO1xuICAgICAgICAgICAgY29uc3QgcCA9ICh2ID0gZC52aWRlb1RyYWNrc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHYuaWQ7XG4gICAgICAgICAgICBwICE9IG51bGwgJiYgci5zZXRFeHRyYWN0aW9uT3B0aW9ucyhwLCBcInZpZGVvXCIsIHsgbmJTYW1wbGVzOiAxMDAgfSk7XG4gICAgICAgICAgICBjb25zdCBuID0gKGIgPSBkLmF1ZGlvVHJhY2tzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogYi5pZDtcbiAgICAgICAgICAgIG4gIT0gbnVsbCAmJiByLnNldEV4dHJhY3Rpb25PcHRpb25zKG4sIFwiYXVkaW9cIiwgeyBuYlNhbXBsZXM6IDEwMCB9KSwgYS5lbnF1ZXVlKHsgY2h1bmtUeXBlOiBcInJlYWR5XCIsIGRhdGE6IHsgaW5mbzogZCwgZmlsZTogciB9IH0pLCByLnN0YXJ0KCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBmID0ge307XG4gICAgICAgICAgci5vblNhbXBsZXMgPSAoZCwgcCwgbikgPT4ge1xuICAgICAgICAgICAgYS5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgY2h1bmtUeXBlOiBcInNhbXBsZXNcIixcbiAgICAgICAgICAgICAgZGF0YTogeyBpZDogZCwgdHlwZTogcCwgc2FtcGxlczogbi5tYXAoKHYpID0+ICh7IC4uLnYgfSkpIH1cbiAgICAgICAgICAgIH0pLCBmW2RdID0gKGZbZF0gPz8gMCkgKyBuLmxlbmd0aCwgci5yZWxlYXNlVXNlZFNhbXBsZXMoZCwgZltkXSk7XG4gICAgICAgICAgfSwgci5vbkZsdXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgYS5jbG9zZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgIHIuc3RvcCgpLCBoID0gITA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGhpZ2hXYXRlck1hcms6IDUwXG4gICAgICB9XG4gICAgKSwgdGhpcy53cml0YWJsZSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICB3cml0ZTogYXN5bmMgKGEpID0+IHtcbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICB0aGlzLndyaXRhYmxlLmFib3J0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGYgPSBhLmJ1ZmZlcjtcbiAgICAgICAgZi5maWxlU3RhcnQgPSBtKHRoaXMsIHp0KSwgRSh0aGlzLCB6dCwgbSh0aGlzLCB6dCkgKyBmLmJ5dGVMZW5ndGgpLCByLmFwcGVuZEJ1ZmZlcihmKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgci5mbHVzaCgpLCByLnN0b3AoKSwgKGEgPSByLm9uRmx1c2gpID09IG51bGwgfHwgYS5jYWxsKHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG56dCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgQmkgPSAwO1xuZnVuY3Rpb24gbmUobCkge1xuICByZXR1cm4gbC5raW5kID09PSBcImZpbGVcIiAmJiBsLmNyZWF0ZVJlYWRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxudmFyIFR0LCBQdCwgRywgSywgTHQsIHN0LCB3dCwgYnQsIFN0LCBWLCBRO1xuY2xhc3Mgc24ge1xuICBjb25zdHJ1Y3RvcihyLCBoID0ge30pIHtcbiAgICBBKHRoaXMsIFR0LCB6LmNyZWF0ZShgTVA0Q2xpcCBpZDoke0JpKyt9LGApKTtcbiAgICBSKHRoaXMsIFwicmVhZHlcIik7XG4gICAgQSh0aGlzLCBQdCwgITEpO1xuICAgIEEodGhpcywgRywge1xuICAgICAgZHVyYXRpb246IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGF1ZGlvU2FtcGxlUmF0ZTogMCxcbiAgICAgIGF1ZGlvQ2hhbkNvdW50OiAwXG4gICAgfSk7XG4gICAgQSh0aGlzLCBLKTtcbiAgICBBKHRoaXMsIEx0LCAxKTtcbiAgICBBKHRoaXMsIHN0LCBbXSk7XG4gICAgQSh0aGlzLCB3dCwgbnVsbCk7XG4gICAgQSh0aGlzLCBidCwgbnVsbCk7XG4gICAgQSh0aGlzLCBTdCwge1xuICAgICAgdmlkZW86IG51bGwsXG4gICAgICBhdWRpbzogbnVsbFxuICAgIH0pO1xuICAgIEEodGhpcywgViwgeyBhdWRpbzogITAgfSk7XG4gICAgUih0aGlzLCBcInRpY2tJbnRlcmNlcHRvclwiLCBhc3luYyAociwgaCkgPT4gaCk7XG4gICAgQSh0aGlzLCBRLCBuZXcgQWJvcnRDb250cm9sbGVyKCkpO1xuICAgIGlmICghKHIgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkgJiYgIW5lKHIpICYmICFBcnJheS5pc0FycmF5KHIudmlkZW9TYW1wbGVzKSlcbiAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBhcmd1bWVudFwiKTtcbiAgICBFKHRoaXMsIFYsIHsgYXVkaW86ICEwLCAuLi5oIH0pLCBFKHRoaXMsIEx0LCB0eXBlb2YgaC5hdWRpbyA9PSBcIm9iamVjdFwiICYmIFwidm9sdW1lXCIgaW4gaC5hdWRpbyA/IGguYXVkaW8udm9sdW1lIDogMSk7XG4gICAgY29uc3QgYSA9IGFzeW5jIChmKSA9PiAoYXdhaXQgQ3QobSh0aGlzLCBLKSwgZiksIGF3YWl0IG0odGhpcywgSykuc3RyZWFtKCkpO1xuICAgIEUodGhpcywgSywgbmUocikgPyByIDogXCJsb2NhbEZpbGVcIiBpbiByID8gci5sb2NhbEZpbGUgOiBLdCgpKSwgdGhpcy5yZWFkeSA9IChyIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gPyBhKHIpLnRoZW4oKGYpID0+IHhlKGYsIG0odGhpcywgVikpKSA6IG5lKHIpID8gci5zdHJlYW0oKS50aGVuKChmKSA9PiB4ZShmLCBtKHRoaXMsIFYpKSkgOiBQcm9taXNlLnJlc29sdmUocikpLnRoZW4oYXN5bmMgKHsgdmlkZW9TYW1wbGVzOiBmLCBhdWRpb1NhbXBsZXM6IGQsIGRlY29kZXJDb25mOiBwIH0pID0+IHtcbiAgICAgIEUodGhpcywgc3QsIGYpLCBFKHRoaXMsIFN0LCBwKTtcbiAgICAgIGNvbnN0IHsgdmlkZW9GcmFtZUZpbmRlcjogbiwgYXVkaW9GcmFtZUZpbmRlcjogdiB9ID0gSWkoXG4gICAgICAgIHtcbiAgICAgICAgICB2aWRlbzogcC52aWRlbyA9PSBudWxsID8gbnVsbCA6IHtcbiAgICAgICAgICAgIC4uLnAudmlkZW8sXG4gICAgICAgICAgICBoYXJkd2FyZUFjY2VsZXJhdGlvbjogbSh0aGlzLCBWKS5fX3Vuc2FmZV9oYXJkd2FyZUFjY2VsZXJhdGlvbl9fXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdWRpbzogcC5hdWRpb1xuICAgICAgICB9LFxuICAgICAgICBhd2FpdCBtKHRoaXMsIEspLmNyZWF0ZVJlYWRlcigpLFxuICAgICAgICBmLFxuICAgICAgICBkLFxuICAgICAgICBtKHRoaXMsIFYpLmF1ZGlvICE9PSAhMSA/IG0odGhpcywgTHQpIDogMFxuICAgICAgKTtcbiAgICAgIHJldHVybiBFKHRoaXMsIHd0LCBuKSwgRSh0aGlzLCBidCwgdiksIEUodGhpcywgRywgRmkocCwgZiwgZCkpLCBtKHRoaXMsIFR0KS5pbmZvKFwiTVA0Q2xpcCBtZXRhOlwiLCBtKHRoaXMsIEcpKSwgeyAuLi5tKHRoaXMsIEcpIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1ldGEoKSB7XG4gICAgcmV0dXJuIHsgLi4ubSh0aGlzLCBHKSB9O1xuICB9XG4gIGFzeW5jIHRpY2socikge1xuICAgIHZhciBmLCBkO1xuICAgIGlmIChyID49IG0odGhpcywgRykuZHVyYXRpb24pXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy50aWNrSW50ZXJjZXB0b3Iociwge1xuICAgICAgICBhdWRpbzogW10sXG4gICAgICAgIHN0YXRlOiBcImRvbmVcIlxuICAgICAgfSk7XG4gICAgY29uc3QgW2gsIGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgKChmID0gbSh0aGlzLCBidCkpID09IG51bGwgPyB2b2lkIDAgOiBmLmZpbmQocikpID8/IFtdLFxuICAgICAgKGQgPSBtKHRoaXMsIHd0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZmluZChyKVxuICAgIF0pO1xuICAgIHJldHVybiBhID09IG51bGwgPyBhd2FpdCB0aGlzLnRpY2tJbnRlcmNlcHRvcihyLCB7XG4gICAgICBhdWRpbzogaCxcbiAgICAgIHN0YXRlOiBcInN1Y2Nlc3NcIlxuICAgIH0pIDogYXdhaXQgdGhpcy50aWNrSW50ZXJjZXB0b3Iociwge1xuICAgICAgdmlkZW86IGEsXG4gICAgICBhdWRpbzogaCxcbiAgICAgIHN0YXRlOiBcInN1Y2Nlc3NcIlxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHRodW1ibmFpbHMociA9IDEwMCwgaCkge1xuICAgIG0odGhpcywgUSkuYWJvcnQoKSwgRSh0aGlzLCBRLCBuZXcgQWJvcnRDb250cm9sbGVyKCkpO1xuICAgIGNvbnN0IGEgPSBtKHRoaXMsIFEpLnNpZ25hbDtcbiAgICBhd2FpdCB0aGlzLnJlYWR5O1xuICAgIGNvbnN0IGYgPSBcImdlbmVyYXRlIHRodW1ibmFpbHMgYWJvcnRlZFwiO1xuICAgIGlmIChhLmFib3J0ZWQpIHRocm93IEVycm9yKGYpO1xuICAgIGNvbnN0IHsgd2lkdGg6IGQsIGhlaWdodDogcCB9ID0gbSh0aGlzLCBHKSwgbiA9IFVlKFxuICAgICAgcixcbiAgICAgIE1hdGgucm91bmQocCAqIChyIC8gZCkpLFxuICAgICAgeyBxdWFsaXR5OiAwLjEsIHR5cGU6IFwiaW1hZ2UvcG5nXCIgfVxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKFxuICAgICAgYXN5bmMgKHYsIGIpID0+IHtcbiAgICAgICAgbGV0IHkgPSBbXTtcbiAgICAgICAgY29uc3QgQiA9IG0odGhpcywgU3QpLnZpZGVvO1xuICAgICAgICBpZiAoQiA9PSBudWxsIHx8IG0odGhpcywgc3QpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgIGIoRXJyb3IoZikpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gdCgpIHtcbiAgICAgICAgICBhLmFib3J0ZWQgfHwgdihcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICB5Lm1hcChhc3luYyAoXykgPT4gKHtcbiAgICAgICAgICAgICAgICB0czogXy50cyxcbiAgICAgICAgICAgICAgICBpbWc6IGF3YWl0IF8uaW1nXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZShfKSB7XG4gICAgICAgICAgeS5wdXNoKHtcbiAgICAgICAgICAgIHRzOiBfLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGltZzogbihfKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhcnQ6IGkgPSAwLCBlbmQ6IHMgPSBtKHRoaXMsIEcpLmR1cmF0aW9uLCBzdGVwOiBvID0gMWU2IH0gPSBoID8/IHt9O1xuICAgICAgICBsZXQgYyA9IGk7XG4gICAgICAgIGNvbnN0IHUgPSBuZXcgb2UoXG4gICAgICAgICAgYXdhaXQgbSh0aGlzLCBLKS5jcmVhdGVSZWFkZXIoKSxcbiAgICAgICAgICBtKHRoaXMsIHN0KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5CLFxuICAgICAgICAgICAgaGFyZHdhcmVBY2NlbGVyYXRpb246IG0odGhpcywgVikuX191bnNhZmVfaGFyZHdhcmVBY2NlbGVyYXRpb25fX1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgZm9yICg7IGMgPD0gcyAmJiAhYS5hYm9ydGVkOyApIHtcbiAgICAgICAgICBjb25zdCBfID0gYXdhaXQgdS5maW5kKGMpO1xuICAgICAgICAgIF8gJiYgZShfKSwgYyArPSBvO1xuICAgICAgICB9XG4gICAgICAgIHUuZGVzdHJveSgpLCB0KCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyB0aHVtYm5haWxzTGlzdChyID0gMTAwLCBoKSB7XG4gICAgdmFyIHY7XG4gICAgaWYgKCgodiA9IGggPT0gbnVsbCA/IHZvaWQgMCA6IGgudGltZXN0YW1wcykgPT0gbnVsbCA/IHZvaWQgMCA6IHYubGVuZ3RoKSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIG0odGhpcywgUSkuYWJvcnQoKSwgRSh0aGlzLCBRLCBuZXcgQWJvcnRDb250cm9sbGVyKCkpO1xuICAgIGNvbnN0IGEgPSBtKHRoaXMsIFEpLnNpZ25hbDtcbiAgICBhd2FpdCB0aGlzLnJlYWR5O1xuICAgIGNvbnN0IGYgPSBcImdlbmVyYXRlIHRodW1ibmFpbHMgYWJvcnRlZFwiO1xuICAgIGlmIChhLmFib3J0ZWQpIHRocm93IEVycm9yKGYpO1xuICAgIGNvbnN0IHsgd2lkdGg6IGQsIGhlaWdodDogcCB9ID0gbSh0aGlzLCBHKSwgbiA9IFVlKFxuICAgICAgcixcbiAgICAgIE1hdGgucm91bmQocCAqIChyIC8gZCkpLFxuICAgICAgeyBxdWFsaXR5OiAwLjEsIHR5cGU6IFwiaW1hZ2UvcG5nXCIgfVxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKFxuICAgICAgYXN5bmMgKGIsIHkpID0+IHtcbiAgICAgICAgbGV0IEIgPSBbXTtcbiAgICAgICAgY29uc3QgdCA9IG0odGhpcywgU3QpLnZpZGVvO1xuICAgICAgICBpZiAodCA9PSBudWxsIHx8IG0odGhpcywgc3QpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgIHkoRXJyb3IoZikpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICBhLmFib3J0ZWQgfHwgYihcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBCLm1hcChhc3luYyAoYykgPT4gKHtcbiAgICAgICAgICAgICAgICB0czogYy50cyxcbiAgICAgICAgICAgICAgICBpbWc6IGF3YWl0IGMuaW1nXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaShjKSB7XG4gICAgICAgICAgQi5wdXNoKHtcbiAgICAgICAgICAgIHRzOiBjLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGltZzogbihjKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHMgPSAoaCA9PSBudWxsID8gdm9pZCAwIDogaC50aW1lc3RhbXBzKSA/PyBbXTtcbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvID0gbmV3IG9lKFxuICAgICAgICAgIGF3YWl0IG0odGhpcywgSykuY3JlYXRlUmVhZGVyKCksXG4gICAgICAgICAgbSh0aGlzLCBzdCksXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4udCxcbiAgICAgICAgICAgIGhhcmR3YXJlQWNjZWxlcmF0aW9uOiBtKHRoaXMsIFYpLl9fdW5zYWZlX2hhcmR3YXJlQWNjZWxlcmF0aW9uX19cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBzKSB7XG4gICAgICAgICAgaWYgKGEuYWJvcnRlZCkgYnJlYWs7XG4gICAgICAgICAgY29uc3QgdSA9IGF3YWl0IG8uZmluZChjKTtcbiAgICAgICAgICB1ICYmIGkodSk7XG4gICAgICAgIH1cbiAgICAgICAgby5kZXN0cm95KCksIGUoKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIHIsIGg7XG4gICAgbSh0aGlzLCBQdCkgfHwgKG0odGhpcywgVHQpLmluZm8oXCJNUDRDbGlwIGRlc3Ryb3lcIiksIEUodGhpcywgUHQsICEwKSwgKHIgPSBtKHRoaXMsIHd0KSkgPT0gbnVsbCB8fCByLmRlc3Ryb3koKSwgKGggPSBtKHRoaXMsIGJ0KSkgPT0gbnVsbCB8fCBoLmRlc3Ryb3koKSk7XG4gIH1cbn1cblR0ID0gbmV3IFdlYWtNYXAoKSwgUHQgPSBuZXcgV2Vha01hcCgpLCBHID0gbmV3IFdlYWtNYXAoKSwgSyA9IG5ldyBXZWFrTWFwKCksIEx0ID0gbmV3IFdlYWtNYXAoKSwgc3QgPSBuZXcgV2Vha01hcCgpLCB3dCA9IG5ldyBXZWFrTWFwKCksIGJ0ID0gbmV3IFdlYWtNYXAoKSwgU3QgPSBuZXcgV2Vha01hcCgpLCBWID0gbmV3IFdlYWtNYXAoKSwgUSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBGaShsLCByLCBoKSB7XG4gIGNvbnN0IGEgPSB7XG4gICAgZHVyYXRpb246IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGF1ZGlvU2FtcGxlUmF0ZTogMCxcbiAgICBhdWRpb0NoYW5Db3VudDogMFxuICB9O1xuICBsLnZpZGVvICE9IG51bGwgJiYgci5sZW5ndGggPiAwICYmIChhLndpZHRoID0gbC52aWRlby5jb2RlZFdpZHRoID8/IDAsIGEuaGVpZ2h0ID0gbC52aWRlby5jb2RlZEhlaWdodCA/PyAwKSwgbC5hdWRpbyAhPSBudWxsICYmIGgubGVuZ3RoID4gMCAmJiAoYS5hdWRpb1NhbXBsZVJhdGUgPSBxLnNhbXBsZVJhdGUsIGEuYXVkaW9DaGFuQ291bnQgPSBxLmNoYW5uZWxDb3VudCk7XG4gIGxldCBmID0gMCwgZCA9IDA7XG4gIGlmIChyLmxlbmd0aCA+IDApXG4gICAgZm9yIChsZXQgcCA9IHIubGVuZ3RoIC0gMTsgcCA+PSAwOyBwLS0pIHtcbiAgICAgIGNvbnN0IG4gPSByW3BdO1xuICAgICAgaWYgKCFuLmRlbGV0ZWQpIHtcbiAgICAgICAgZiA9IG4uY3RzICsgbi5kdXJhdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICBpZiAoaC5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcCA9IGguYXQoLTEpO1xuICAgIGQgPSBwLmN0cyArIHAuZHVyYXRpb247XG4gIH1cbiAgcmV0dXJuIGEuZHVyYXRpb24gPSBNYXRoLm1heChmLCBkKSwgYTtcbn1cbmZ1bmN0aW9uIElpKGwsIHIsIGgsIGEsIGYpIHtcbiAgcmV0dXJuIHtcbiAgICBhdWRpb0ZyYW1lRmluZGVyOiBmID09PSAwIHx8IGwuYXVkaW8gPT0gbnVsbCB8fCBhLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBuZXcgQ2koXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGwuYXVkaW8sXG4gICAgICB7XG4gICAgICAgIHZvbHVtZTogZixcbiAgICAgICAgdGFyZ2V0U2FtcGxlUmF0ZTogcS5zYW1wbGVSYXRlXG4gICAgICB9XG4gICAgKSxcbiAgICB2aWRlb0ZyYW1lRmluZGVyOiBsLnZpZGVvID09IG51bGwgfHwgaC5sZW5ndGggPT09IDAgPyBudWxsIDogbmV3IG9lKFxuICAgICAgcixcbiAgICAgIGgsXG4gICAgICBsLnZpZGVvXG4gICAgKVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24geGUobCwgciA9IHt9KSB7XG4gIGxldCBoO1xuICBjb25zdCBhID0geyB2aWRlbzogbnVsbCwgYXVkaW86IG51bGwgfTtcbiAgbGV0IGYgPSBbXSwgZCA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKG4sIHYpID0+IHtcbiAgICBsZXQgYiA9IC0xLCB5ID0gLTE7XG4gICAgY29uc3QgQiA9IGZlKGwucGlwZVRocm91Z2gobmV3IGNlKCkpLCB7XG4gICAgICBvbkNodW5rOiBhc3luYyAoeyBjaHVua1R5cGU6IHQsIGRhdGE6IGUgfSkgPT4ge1xuICAgICAgICBpZiAodCA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgaCA9IGUuaW5mbztcbiAgICAgICAgICBsZXQgeyB2aWRlb0RlY29kZXJDb25mOiBpLCBhdWRpb0RlY29kZXJDb25mOiBzIH0gPSBkZShlLmZpbGUsIGUuaW5mbyk7XG4gICAgICAgICAgYS52aWRlbyA9IGkgPz8gbnVsbCwgYS5hdWRpbyA9IHMgPz8gbnVsbCwgaSA9PSBudWxsICYmIHMgPT0gbnVsbCAmJiAoQigpLCB2KFxuICAgICAgICAgICAgRXJyb3IoXCJNUDRDbGlwIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdmlkZW8gb3IgYXVkaW8gdHJhY2tcIilcbiAgICAgICAgICApKSwgei5pbmZvKFxuICAgICAgICAgICAgXCJtcDRCb3hGaWxlIG1vb3YgcmVhZHlcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uZS5pbmZvLFxuICAgICAgICAgICAgICB0cmFja3M6IG51bGwsXG4gICAgICAgICAgICAgIHZpZGVvVHJhY2tzOiBudWxsLFxuICAgICAgICAgICAgICBhdWRpb1RyYWNrczogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPT09IFwic2FtcGxlc1wiKSB7XG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgICAgICAgICBiID09PSAtMSAmJiAoYiA9IGUuc2FtcGxlc1swXS5kdHMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIG9mIGUuc2FtcGxlcylcbiAgICAgICAgICAgICAgZi5wdXNoKHAoaSwgYiwgXCJ2aWRlb1wiKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09IFwiYXVkaW9cIiAmJiByLmF1ZGlvKSB7XG4gICAgICAgICAgICB5ID09PSAtMSAmJiAoeSA9IGUuc2FtcGxlc1swXS5kdHMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIG9mIGUuc2FtcGxlcylcbiAgICAgICAgICAgICAgZC5wdXNoKHAoaSwgeSwgXCJhdWRpb1wiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Eb25lOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHQgPSBmLmF0KC0xKSA/PyBkLmF0KC0xKTtcbiAgICAgICAgaWYgKGggPT0gbnVsbCkge1xuICAgICAgICAgIHYoRXJyb3IoXCJNUDRDbGlwIHN0cmVhbSBpcyBkb25lLCBidXQgbm90IGVtaXQgcmVhZHlcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICB2KEVycm9yKFwiTVA0Q2xpcCBzdHJlYW0gbm90IGNvbnRhaW4gYW55IHNhbXBsZVwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBmWzBdO1xuICAgICAgICBlICE9IG51bGwgJiYgZS5jdHMgPCAyZTUgJiYgKGUuZHVyYXRpb24gKz0gZS5jdHMsIGUuY3RzID0gMCksIHouaW5mbyhcIm1wNCBzdHJlYW0gcGFyc2VkXCIpLCBuKHtcbiAgICAgICAgICB2aWRlb1NhbXBsZXM6IGYsXG4gICAgICAgICAgYXVkaW9TYW1wbGVzOiBkLFxuICAgICAgICAgIGRlY29kZXJDb25mOiBhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgZnVuY3Rpb24gcChuLCB2ID0gMCwgYikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5uLFxuICAgICAgaXNfaWRyOiBiID09PSBcInZpZGVvXCIgJiYgbi5pc19zeW5jICYmIERpKG4uZGF0YSwgbi5kZXNjcmlwdGlvbi50eXBlKSxcbiAgICAgIGN0czogKG4uY3RzIC0gdikgLyBuLnRpbWVzY2FsZSAqIDFlNixcbiAgICAgIGR0czogKG4uZHRzIC0gdikgLyBuLnRpbWVzY2FsZSAqIDFlNixcbiAgICAgIGR1cmF0aW9uOiBuLmR1cmF0aW9uIC8gbi50aW1lc2NhbGUgKiAxZTYsXG4gICAgICB0aW1lc2NhbGU6IDFlNixcbiAgICAgIGRhdGE6IGIgPT09IFwidmlkZW9cIiA/IG51bGwgOiBuLmRhdGFcbiAgICB9O1xuICB9XG59XG52YXIgTCwgbHQsIGZ0LCBrdCwgZHQsIFcsIGssIHJ0LCBjdCwgeHQsIGF0LCBEdCwgdXQsIEp0O1xuY2xhc3Mgb2Uge1xuICBjb25zdHJ1Y3RvcihyLCBoLCBhKSB7XG4gICAgQSh0aGlzLCBMLCBudWxsKTtcbiAgICBBKHRoaXMsIGx0LCAwKTtcbiAgICBBKHRoaXMsIGZ0LCB7IGFib3J0OiAhMSwgc3Q6IHBlcmZvcm1hbmNlLm5vdygpIH0pO1xuICAgIFIodGhpcywgXCJmaW5kXCIsIGFzeW5jIChyKSA9PiAoKG0odGhpcywgTCkgPT0gbnVsbCB8fCByIDw9IG0odGhpcywgbHQpIHx8IHIgLSBtKHRoaXMsIGx0KSA+IDNlNikgJiYgbSh0aGlzLCB1dCkuY2FsbCh0aGlzLCByKSwgbSh0aGlzLCBmdCkuYWJvcnQgPSAhMCwgRSh0aGlzLCBsdCwgciksIEUodGhpcywgZnQsIHsgYWJvcnQ6ICExLCBzdDogcGVyZm9ybWFuY2Uubm93KCkgfSksIGF3YWl0IG0odGhpcywgeHQpLmNhbGwodGhpcywgciwgbSh0aGlzLCBMKSwgbSh0aGlzLCBmdCkpKSk7XG4gICAgLy8gZml4IFZpZGVvRnJhbWUgZHVyYXRpb24gaXMgbnVsbFxuICAgIEEodGhpcywga3QsIDApO1xuICAgIEEodGhpcywgZHQsICExKTtcbiAgICBBKHRoaXMsIFcsIDApO1xuICAgIEEodGhpcywgaywgW10pO1xuICAgIEEodGhpcywgcnQsIDApO1xuICAgIEEodGhpcywgY3QsIDApO1xuICAgIEEodGhpcywgeHQsIGFzeW5jIChyLCBoLCBhKSA9PiB7XG4gICAgICBpZiAoaCA9PSBudWxsIHx8IGguc3RhdGUgPT09IFwiY2xvc2VkXCIgfHwgYS5hYm9ydCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAobSh0aGlzLCBrKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtKHRoaXMsIGspWzBdO1xuICAgICAgICByZXR1cm4gciA8IGYudGltZXN0YW1wID8gbnVsbCA6IChtKHRoaXMsIGspLnNoaWZ0KCksIHIgPiBmLnRpbWVzdGFtcCArIChmLmR1cmF0aW9uID8/IDApID8gKGYuY2xvc2UoKSwgYXdhaXQgbSh0aGlzLCB4dCkuY2FsbCh0aGlzLCByLCBoLCBhKSkgOiAobSh0aGlzLCBrKS5sZW5ndGggPCAxMCAmJiBtKHRoaXMsIER0KS5jYWxsKHRoaXMsIGgpLmNhdGNoKChkKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbSh0aGlzLCB1dCkuY2FsbCh0aGlzLCByKSwgZDtcbiAgICAgICAgfSksIGYpKTtcbiAgICAgIH1cbiAgICAgIGlmIChtKHRoaXMsIGF0KSB8fCBtKHRoaXMsIHJ0KSA8IG0odGhpcywgY3QpICYmIGguZGVjb2RlUXVldWVTaXplID4gMCkge1xuICAgICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSBhLnN0ID4gNmUzKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgYE1QNENsaXAudGljayB2aWRlbyB0aW1lb3V0LCAke0pTT04uc3RyaW5naWZ5KG0odGhpcywgSnQpLmNhbGwodGhpcykpfWBcbiAgICAgICAgICApO1xuICAgICAgICBhd2FpdCBOZSgxNSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobSh0aGlzLCBXKSA+PSB0aGlzLnNhbXBsZXMubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG0odGhpcywgRHQpLmNhbGwodGhpcywgaCk7XG4gICAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgICB0aHJvdyBtKHRoaXMsIHV0KS5jYWxsKHRoaXMsIHIpLCBmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgbSh0aGlzLCB4dCkuY2FsbCh0aGlzLCByLCBoLCBhKTtcbiAgICB9KTtcbiAgICBBKHRoaXMsIGF0LCAhMSk7XG4gICAgQSh0aGlzLCBEdCwgYXN5bmMgKHIpID0+IHtcbiAgICAgIHZhciBmLCBkO1xuICAgICAgaWYgKG0odGhpcywgYXQpKSByZXR1cm47XG4gICAgICBFKHRoaXMsIGF0LCAhMCk7XG4gICAgICBsZXQgaCA9IG0odGhpcywgVykgKyAxLCBhID0gITE7XG4gICAgICBmb3IgKDsgaCA8IHRoaXMuc2FtcGxlcy5sZW5ndGg7IGgrKykge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5zYW1wbGVzW2hdO1xuICAgICAgICBpZiAoIWEgJiYgIXAuZGVsZXRlZCAmJiAoYSA9ICEwKSwgcC5pc19pZHIpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGEpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuc2FtcGxlcy5zbGljZShtKHRoaXMsIFcpLCBoKTtcbiAgICAgICAgaWYgKCgoZiA9IHBbMF0pID09IG51bGwgPyB2b2lkIDAgOiBmLmlzX2lkcikgIT09ICEwKVxuICAgICAgICAgIHoud2FybihcIkZpcnN0IHNhbXBsZSBub3QgaWRyIGZyYW1lXCIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuID0gYXdhaXQgTGkocCwgdGhpcy5sb2NhbEZpbGVSZWFkZXIpO1xuICAgICAgICAgIGlmIChyLnN0YXRlID09PSBcImNsb3NlZFwiKSByZXR1cm47XG4gICAgICAgICAgRSh0aGlzLCBrdCwgKChkID0gblswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZHVyYXRpb24pID8/IDApLCBraShyLCBuLCB7XG4gICAgICAgICAgICBvbkRlY29kaW5nRXJyb3I6ICh2KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChtKHRoaXMsIGR0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyB2O1xuICAgICAgICAgICAgICBtKHRoaXMsIHJ0KSA9PT0gMCAmJiAoRSh0aGlzLCBkdCwgITApLCB6Lndhcm4oXCJEb3duZ3JhZGUgdG8gc29mdHdhcmUgZGVjb2RlXCIpLCBtKHRoaXMsIHV0KS5jYWxsKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgRSh0aGlzLCBjdCwgbSh0aGlzLCBjdCkgKyBuLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEUodGhpcywgVywgaCksIEUodGhpcywgYXQsICExKTtcbiAgICB9KTtcbiAgICBBKHRoaXMsIHV0LCAocikgPT4ge1xuICAgICAgdmFyIGgsIGE7XG4gICAgICBpZiAoRSh0aGlzLCBhdCwgITEpLCBtKHRoaXMsIGspLmZvckVhY2goKGYpID0+IGYuY2xvc2UoKSksIEUodGhpcywgaywgW10pLCByID09IG51bGwgfHwgciA9PT0gMClcbiAgICAgICAgRSh0aGlzLCBXLCAwKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgZiA9IDA7XG4gICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdGhpcy5zYW1wbGVzLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgICAgY29uc3QgcCA9IHRoaXMuc2FtcGxlc1tkXTtcbiAgICAgICAgICBpZiAocC5pc19pZHIgJiYgKGYgPSBkKSwgIShwLmN0cyA8IHIpKSB7XG4gICAgICAgICAgICBFKHRoaXMsIFcsIGYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBFKHRoaXMsIGN0LCAwKSwgRSh0aGlzLCBydCwgMCksICgoaCA9IG0odGhpcywgTCkpID09IG51bGwgPyB2b2lkIDAgOiBoLnN0YXRlKSAhPT0gXCJjbG9zZWRcIiAmJiAoKGEgPSBtKHRoaXMsIEwpKSA9PSBudWxsIHx8IGEuY2xvc2UoKSksIEUodGhpcywgTCwgbmV3IFZpZGVvRGVjb2Rlcih7XG4gICAgICAgIG91dHB1dDogKGYpID0+IHtcbiAgICAgICAgICBpZiAoRSh0aGlzLCBydCwgbSh0aGlzLCBydCkgKyAxKSwgZi50aW1lc3RhbXAgPT09IC0xKSB7XG4gICAgICAgICAgICBmLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBkID0gZjtcbiAgICAgICAgICBmLmR1cmF0aW9uID09IG51bGwgJiYgKGQgPSBuZXcgVmlkZW9GcmFtZShmLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogbSh0aGlzLCBrdClcbiAgICAgICAgICB9KSwgZi5jbG9zZSgpKSwgbSh0aGlzLCBrKS5wdXNoKGQpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKGYpID0+IHtcbiAgICAgICAgICB6LmVycm9yKGBNUDRDbGlwIFZpZGVvRGVjb2RlciBlcnI6ICR7Zi5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9KSksIG0odGhpcywgTCkuY29uZmlndXJlKHtcbiAgICAgICAgLi4udGhpcy5jb25mLFxuICAgICAgICAuLi5tKHRoaXMsIGR0KSA/IHsgaGFyZHdhcmVBY2NlbGVyYXRpb246IFwicHJlZmVyLXNvZnR3YXJlXCIgfSA6IHt9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBKHRoaXMsIEp0LCAoKSA9PiB7XG4gICAgICB2YXIgciwgaDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRpbWU6IG0odGhpcywgbHQpLFxuICAgICAgICBkZWNTdGF0ZTogKHIgPSBtKHRoaXMsIEwpKSA9PSBudWxsID8gdm9pZCAwIDogci5zdGF0ZSxcbiAgICAgICAgZGVjUVNpemU6IChoID0gbSh0aGlzLCBMKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGguZGVjb2RlUXVldWVTaXplLFxuICAgICAgICBkZWNDdXNvcklkeDogbSh0aGlzLCBXKSxcbiAgICAgICAgc2FtcGxlTGVuOiB0aGlzLnNhbXBsZXMubGVuZ3RoLFxuICAgICAgICBpbnB1dENudDogbSh0aGlzLCBjdCksXG4gICAgICAgIG91dHB1dENudDogbSh0aGlzLCBydCksXG4gICAgICAgIGNhY2hlRnJhbWVMZW46IG0odGhpcywgaykubGVuZ3RoLFxuICAgICAgICBzb2Z0RGVvY2RlOiBtKHRoaXMsIGR0KVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBSKHRoaXMsIFwiZGVzdHJveVwiLCAoKSA9PiB7XG4gICAgICB2YXIgciwgaDtcbiAgICAgICgociA9IG0odGhpcywgTCkpID09IG51bGwgPyB2b2lkIDAgOiByLnN0YXRlKSAhPT0gXCJjbG9zZWRcIiAmJiAoKGggPSBtKHRoaXMsIEwpKSA9PSBudWxsIHx8IGguY2xvc2UoKSksIEUodGhpcywgTCwgbnVsbCksIG0odGhpcywgZnQpLmFib3J0ID0gITAsIG0odGhpcywgaykuZm9yRWFjaCgoYSkgPT4gYS5jbG9zZSgpKSwgRSh0aGlzLCBrLCBbXSksIHRoaXMubG9jYWxGaWxlUmVhZGVyLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5sb2NhbEZpbGVSZWFkZXIgPSByLCB0aGlzLnNhbXBsZXMgPSBoLCB0aGlzLmNvbmYgPSBhO1xuICB9XG59XG5MID0gbmV3IFdlYWtNYXAoKSwgbHQgPSBuZXcgV2Vha01hcCgpLCBmdCA9IG5ldyBXZWFrTWFwKCksIGt0ID0gbmV3IFdlYWtNYXAoKSwgZHQgPSBuZXcgV2Vha01hcCgpLCBXID0gbmV3IFdlYWtNYXAoKSwgayA9IG5ldyBXZWFrTWFwKCksIHJ0ID0gbmV3IFdlYWtNYXAoKSwgY3QgPSBuZXcgV2Vha01hcCgpLCB4dCA9IG5ldyBXZWFrTWFwKCksIGF0ID0gbmV3IFdlYWtNYXAoKSwgRHQgPSBuZXcgV2Vha01hcCgpLCB1dCA9IG5ldyBXZWFrTWFwKCksIEp0ID0gbmV3IFdlYWtNYXAoKTtcbnZhciBSdCwgTXQsIFosIHB0LCBYLCBKLCBqLCBPdCwgTnQsICR0LCBxdDtcbmNsYXNzIENpIHtcbiAgY29uc3RydWN0b3IociwgaCwgYSwgZikge1xuICAgIEEodGhpcywgUnQsIDEpO1xuICAgIEEodGhpcywgTXQpO1xuICAgIEEodGhpcywgWiwgbnVsbCk7XG4gICAgQSh0aGlzLCBwdCwgeyBhYm9ydDogITEsIHN0OiBwZXJmb3JtYW5jZS5ub3coKSB9KTtcbiAgICBSKHRoaXMsIFwiZmluZFwiLCBhc3luYyAocikgPT4ge1xuICAgICAgaWYgKG0odGhpcywgWikgPT0gbnVsbCB8fCByIDw9IG0odGhpcywgWCkgfHwgciAtIG0odGhpcywgWCkgPiAxZTUpIHtcbiAgICAgICAgbSh0aGlzLCAkdCkuY2FsbCh0aGlzKSwgRSh0aGlzLCBYLCByKTtcbiAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0aGlzLnNhbXBsZXMubGVuZ3RoOyBhKyspXG4gICAgICAgICAgaWYgKCEodGhpcy5zYW1wbGVzW2FdLmN0cyA8IHIpKSB7XG4gICAgICAgICAgICBFKHRoaXMsIEosIGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBtKHRoaXMsIHB0KS5hYm9ydCA9ICEwO1xuICAgICAgY29uc3QgaCA9IHIgLSBtKHRoaXMsIFgpO1xuICAgICAgcmV0dXJuIEUodGhpcywgWCwgciksIEUodGhpcywgcHQsIHsgYWJvcnQ6ICExLCBzdDogcGVyZm9ybWFuY2Uubm93KCkgfSksIGF3YWl0IG0odGhpcywgT3QpLmNhbGwodGhpcywgaCwgbSh0aGlzLCBaKSwgbSh0aGlzLCBwdCkpO1xuICAgIH0pO1xuICAgIEEodGhpcywgWCwgMCk7XG4gICAgQSh0aGlzLCBKLCAwKTtcbiAgICBBKHRoaXMsIGosIHtcbiAgICAgIGZyYW1lQ250OiAwLFxuICAgICAgZGF0YTogW11cbiAgICB9KTtcbiAgICBBKHRoaXMsIE90LCBhc3luYyAociwgaCA9IG51bGwsIGEpID0+IHtcbiAgICAgIGlmIChoID09IG51bGwgfHwgYS5hYm9ydCB8fCBoLnN0YXRlID09PSBcImNsb3NlZFwiKSByZXR1cm4gW107XG4gICAgICBjb25zdCBmID0gTWF0aC5jZWlsKHIgKiAobSh0aGlzLCBNdCkgLyAxZTYpKTtcbiAgICAgIGlmIChmID09PSAwKSByZXR1cm4gW107XG4gICAgICBjb25zdCBkID0gbSh0aGlzLCBqKS5mcmFtZUNudCAtIGY7XG4gICAgICBpZiAoZCA+IDApXG4gICAgICAgIHJldHVybiBkIDwgcS5zYW1wbGVSYXRlIC8gMTAgJiYgbSh0aGlzLCBOdCkuY2FsbCh0aGlzLCBoKSwgUGkobSh0aGlzLCBqKSwgZik7XG4gICAgICBpZiAoaC5kZWNvZGVRdWV1ZVNpemUgPiAxMCkge1xuICAgICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSBhLnN0ID4gM2UzKVxuICAgICAgICAgIHRocm93IGEuYWJvcnQgPSAhMCwgRXJyb3IoXG4gICAgICAgICAgICBgTVA0Q2xpcC50aWNrIGF1ZGlvIHRpbWVvdXQsICR7SlNPTi5zdHJpbmdpZnkobSh0aGlzLCBxdCkuY2FsbCh0aGlzKSl9YFxuICAgICAgICAgICk7XG4gICAgICAgIGF3YWl0IE5lKDE1KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtKHRoaXMsIEopID49IHRoaXMuc2FtcGxlcy5sZW5ndGggLSAxKVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbSh0aGlzLCBOdCkuY2FsbCh0aGlzLCBoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtKHRoaXMsIE90KS5jYWxsKHRoaXMsIHIsIGgsIGEpO1xuICAgIH0pO1xuICAgIEEodGhpcywgTnQsIChyKSA9PiB7XG4gICAgICBpZiAoci5kZWNvZGVRdWV1ZVNpemUgPiAxMDApIHJldHVybjtcbiAgICAgIGNvbnN0IGggPSBbXTtcbiAgICAgIGxldCBhID0gbSh0aGlzLCBKKTtcbiAgICAgIGZvciAoOyBhIDwgdGhpcy5zYW1wbGVzLmxlbmd0aDsgKSB7XG4gICAgICAgIGNvbnN0IGYgPSB0aGlzLnNhbXBsZXNbYV07XG4gICAgICAgIGlmIChhICs9IDEsICFmLmRlbGV0ZWQgJiYgKGgucHVzaChmKSwgaC5sZW5ndGggPj0gMTApKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgRSh0aGlzLCBKLCBhKSwgci5kZWNvZGUoXG4gICAgICAgIGgubWFwKFxuICAgICAgICAgIChmKSA9PiBuZXcgRW5jb2RlZEF1ZGlvQ2h1bmsoe1xuICAgICAgICAgICAgdHlwZTogXCJrZXlcIixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZi5jdHMsXG4gICAgICAgICAgICBkdXJhdGlvbjogZi5kdXJhdGlvbixcbiAgICAgICAgICAgIGRhdGE6IGYuZGF0YVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSk7XG4gICAgQSh0aGlzLCAkdCwgKCkgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICBFKHRoaXMsIFgsIDApLCBFKHRoaXMsIEosIDApLCBFKHRoaXMsIGosIHtcbiAgICAgICAgZnJhbWVDbnQ6IDAsXG4gICAgICAgIGRhdGE6IFtdXG4gICAgICB9KSwgKHIgPSBtKHRoaXMsIFopKSA9PSBudWxsIHx8IHIuY2xvc2UoKSwgRSh0aGlzLCBaLCB6aShcbiAgICAgICAgdGhpcy5jb25mLFxuICAgICAgICB7XG4gICAgICAgICAgcmVzYW1wbGVSYXRlOiBxLnNhbXBsZVJhdGUsXG4gICAgICAgICAgdm9sdW1lOiBtKHRoaXMsIFJ0KVxuICAgICAgICB9LFxuICAgICAgICAoaCkgPT4ge1xuICAgICAgICAgIG0odGhpcywgaikuZGF0YS5wdXNoKGgpLCBtKHRoaXMsIGopLmZyYW1lQ250ICs9IGhbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICApKTtcbiAgICB9KTtcbiAgICBBKHRoaXMsIHF0LCAoKSA9PiB7XG4gICAgICB2YXIgciwgaDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRpbWU6IG0odGhpcywgWCksXG4gICAgICAgIGRlY1N0YXRlOiAociA9IG0odGhpcywgWikpID09IG51bGwgPyB2b2lkIDAgOiByLnN0YXRlLFxuICAgICAgICBkZWNRU2l6ZTogKGggPSBtKHRoaXMsIFopKSA9PSBudWxsID8gdm9pZCAwIDogaC5kZWNvZGVRdWV1ZVNpemUsXG4gICAgICAgIGRlY0N1c29ySWR4OiBtKHRoaXMsIEopLFxuICAgICAgICBzYW1wbGVMZW46IHRoaXMuc2FtcGxlcy5sZW5ndGgsXG4gICAgICAgIHBjbUxlbjogbSh0aGlzLCBqKS5mcmFtZUNudFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBSKHRoaXMsIFwiZGVzdHJveVwiLCAoKSA9PiB7XG4gICAgICBFKHRoaXMsIFosIG51bGwpLCBtKHRoaXMsIHB0KS5hYm9ydCA9ICEwLCBFKHRoaXMsIGosIHtcbiAgICAgICAgZnJhbWVDbnQ6IDAsXG4gICAgICAgIGRhdGE6IFtdXG4gICAgICB9KSwgdGhpcy5sb2NhbEZpbGVSZWFkZXIuY2xvc2UoKTtcbiAgICB9KTtcbiAgICB0aGlzLmxvY2FsRmlsZVJlYWRlciA9IHIsIHRoaXMuc2FtcGxlcyA9IGgsIHRoaXMuY29uZiA9IGEsIEUodGhpcywgUnQsIGYudm9sdW1lKSwgRSh0aGlzLCBNdCwgZi50YXJnZXRTYW1wbGVSYXRlKTtcbiAgfVxufVxuUnQgPSBuZXcgV2Vha01hcCgpLCBNdCA9IG5ldyBXZWFrTWFwKCksIFogPSBuZXcgV2Vha01hcCgpLCBwdCA9IG5ldyBXZWFrTWFwKCksIFggPSBuZXcgV2Vha01hcCgpLCBKID0gbmV3IFdlYWtNYXAoKSwgaiA9IG5ldyBXZWFrTWFwKCksIE90ID0gbmV3IFdlYWtNYXAoKSwgTnQgPSBuZXcgV2Vha01hcCgpLCAkdCA9IG5ldyBXZWFrTWFwKCksIHF0ID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHppKGwsIHIsIGgpIHtcbiAgY29uc3QgYSA9IChuKSA9PiB7XG4gICAgaWYgKG4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpZiAoci52b2x1bWUgIT09IDEpXG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBuKVxuICAgICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgdi5sZW5ndGg7IGIrKykgdltiXSAqPSByLnZvbHVtZTtcbiAgICAgIG4ubGVuZ3RoID09PSAxICYmIChuID0gW25bMF0sIG5bMF1dKSwgaChuKTtcbiAgICB9XG4gIH0sIGYgPSBUaShhKSwgZCA9IHIucmVzYW1wbGVSYXRlICE9PSBsLnNhbXBsZVJhdGUsIHAgPSBuZXcgQXVkaW9EZWNvZGVyKHtcbiAgICBvdXRwdXQ6IChuKSA9PiB7XG4gICAgICBjb25zdCB2ID0gbGUobik7XG4gICAgICBkID8gZihcbiAgICAgICAgKCkgPT4gYmkodiwgbi5zYW1wbGVSYXRlLCB7XG4gICAgICAgICAgcmF0ZTogci5yZXNhbXBsZVJhdGUsXG4gICAgICAgICAgY2hhbkNvdW50OiBuLm51bWJlck9mQ2hhbm5lbHNcbiAgICAgICAgfSlcbiAgICAgICkgOiBhKHYpLCBuLmNsb3NlKCk7XG4gICAgfSxcbiAgICBlcnJvcjogKG4pID0+IHtcbiAgICAgIHouZXJyb3IoYE1QNENsaXAgQXVkaW9EZWNvZGVyIGVycjogJHtuLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHAuY29uZmlndXJlKGwpLCB7XG4gICAgZGVjb2RlKG4pIHtcbiAgICAgIGZvciAoY29uc3QgdiBvZiBuKSBwLmRlY29kZSh2KTtcbiAgICB9LFxuICAgIGNsb3NlKCkge1xuICAgICAgcC5zdGF0ZSAhPT0gXCJjbG9zZWRcIiAmJiBwLmNsb3NlKCk7XG4gICAgfSxcbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICByZXR1cm4gcC5zdGF0ZTtcbiAgICB9LFxuICAgIGdldCBkZWNvZGVRdWV1ZVNpemUoKSB7XG4gICAgICByZXR1cm4gcC5kZWNvZGVRdWV1ZVNpemU7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gVGkobCkge1xuICBjb25zdCByID0gW107XG4gIGxldCBoID0gMDtcbiAgZnVuY3Rpb24gYShwLCBuKSB7XG4gICAgcltuXSA9IHAsIGYoKTtcbiAgfVxuICBmdW5jdGlvbiBmKCkge1xuICAgIGNvbnN0IHAgPSByW2hdO1xuICAgIHAgIT0gbnVsbCAmJiAobChwKSwgaCArPSAxLCBmKCkpO1xuICB9XG4gIGxldCBkID0gMDtcbiAgcmV0dXJuIChwKSA9PiB7XG4gICAgY29uc3QgbiA9IGQ7XG4gICAgZCArPSAxLCBwKCkudGhlbigodikgPT4gYSh2LCBuKSkuY2F0Y2goKHYpID0+IGEodiwgbikpO1xuICB9O1xufVxuZnVuY3Rpb24gUGkobCwgcikge1xuICBjb25zdCBoID0gW25ldyBGbG9hdDMyQXJyYXkociksIG5ldyBGbG9hdDMyQXJyYXkocildO1xuICBsZXQgYSA9IDAsIGYgPSAwO1xuICBmb3IgKDsgZiA8IGwuZGF0YS5sZW5ndGg7ICkge1xuICAgIGNvbnN0IFtkLCBwXSA9IGwuZGF0YVtmXTtcbiAgICBpZiAoYSArIGQubGVuZ3RoID4gcikge1xuICAgICAgY29uc3QgbiA9IHIgLSBhO1xuICAgICAgaFswXS5zZXQoZC5zdWJhcnJheSgwLCBuKSwgYSksIGhbMV0uc2V0KHAuc3ViYXJyYXkoMCwgbiksIGEpLCBsLmRhdGFbZl1bMF0gPSBkLnN1YmFycmF5KG4sIGQubGVuZ3RoKSwgbC5kYXRhW2ZdWzFdID0gcC5zdWJhcnJheShuLCBwLmxlbmd0aCk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2VcbiAgICAgIGhbMF0uc2V0KGQsIGEpLCBoWzFdLnNldChwLCBhKSwgYSArPSBkLmxlbmd0aCwgZisrO1xuICB9XG4gIHJldHVybiBsLmRhdGEgPSBsLmRhdGEuc2xpY2UoZiksIGwuZnJhbWVDbnQgLT0gciwgaDtcbn1cbmFzeW5jIGZ1bmN0aW9uIExpKGwsIHIpIHtcbiAgY29uc3QgaCA9IGxbMF0sIGEgPSBsLmF0KC0xKTtcbiAgaWYgKGEgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICBjb25zdCBmID0gYS5vZmZzZXQgKyBhLnNpemUgLSBoLm9mZnNldDtcbiAgaWYgKGYgPCAzZTcpIHtcbiAgICBjb25zdCBkID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICBhd2FpdCByLnJlYWQoZiwgeyBhdDogaC5vZmZzZXQgfSlcbiAgICApO1xuICAgIHJldHVybiBsLm1hcCgocCkgPT4ge1xuICAgICAgY29uc3QgbiA9IHAub2Zmc2V0IC0gaC5vZmZzZXQ7XG4gICAgICBsZXQgdiA9IGQuc3ViYXJyYXkobiwgbiArIHAuc2l6ZSk7XG4gICAgICByZXR1cm4gcC5pc19pZHIgJiYgKHYgPSBFZSh2KSksIG5ldyBFbmNvZGVkVmlkZW9DaHVuayh7XG4gICAgICAgIHR5cGU6IHAuaXNfc3luYyA/IFwia2V5XCIgOiBcImRlbHRhXCIsXG4gICAgICAgIHRpbWVzdGFtcDogcC5jdHMsXG4gICAgICAgIGR1cmF0aW9uOiBwLmR1cmF0aW9uLFxuICAgICAgICBkYXRhOiB2XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbC5tYXAoYXN5bmMgKGQpID0+IHtcbiAgICAgIGxldCBwID0gYXdhaXQgci5yZWFkKGQuc2l6ZSwge1xuICAgICAgICBhdDogZC5vZmZzZXRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGQuaXNfaWRyICYmIChwID0gRWUobmV3IFVpbnQ4QXJyYXkocCkpKSwgbmV3IEVuY29kZWRWaWRlb0NodW5rKHtcbiAgICAgICAgdHlwZTogZC5pc19zeW5jID8gXCJrZXlcIiA6IFwiZGVsdGFcIixcbiAgICAgICAgdGltZXN0YW1wOiBkLmN0cyxcbiAgICAgICAgZHVyYXRpb246IGQuZHVyYXRpb24sXG4gICAgICAgIGRhdGE6IHBcbiAgICAgIH0pO1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBVZShsLCByLCBoKSB7XG4gIGNvbnN0IGEgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGwsIHIpLCBmID0gYS5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHJldHVybiBhc3luYyAoZCkgPT4gKGYuZHJhd0ltYWdlKGQsIDAsIDAsIGwsIHIpLCBkLmNsb3NlKCksIGF3YWl0IGEuY29udmVydFRvQmxvYihoKSk7XG59XG5mdW5jdGlvbiBraShsLCByLCBoKSB7XG4gIGxldCBhID0gMDtcbiAgaWYgKGwuc3RhdGUgPT09IFwiY29uZmlndXJlZFwiKSB7XG4gICAgZm9yICg7IGEgPCByLmxlbmd0aDsgYSsrKSBsLmRlY29kZShyW2FdKTtcbiAgICBsLmZsdXNoKCkuY2F0Y2goKGYpID0+IHtcbiAgICAgIGlmICghKGYgaW5zdGFuY2VvZiBFcnJvcikpIHRocm93IGY7XG4gICAgICBpZiAoZi5tZXNzYWdlLmluY2x1ZGVzKFwiRGVjb2RpbmcgZXJyb3JcIikgJiYgaC5vbkRlY29kaW5nRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBoLm9uRGVjb2RpbmdFcnJvcihmKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmLm1lc3NhZ2UuaW5jbHVkZXMoXCJBYm9ydGVkIGR1ZSB0byBjbG9zZVwiKSlcbiAgICAgICAgdGhyb3cgZjtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gRWUobCkge1xuICBjb25zdCByID0gbmV3IERhdGFWaWV3KGwuYnVmZmVyLCBsLmJ5dGVPZmZzZXQsIGwuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiAoci5nZXRVaW50OCg0KSAmIDMxKSA9PT0gNiA/IGwuc3ViYXJyYXkoci5nZXRVaW50MzIoMCkgKyA0KSA6IGw7XG59XG5mdW5jdGlvbiBEaShsLCByKSB7XG4gIGlmIChyICE9PSBcImF2YzFcIiAmJiByICE9PSBcImh2YzFcIikgcmV0dXJuICExO1xuICBjb25zdCBoID0gbmV3IERhdGFWaWV3KGwuYnVmZmVyKTtcbiAgbGV0IGEgPSAwO1xuICBmb3IgKDsgYSA8IGwuYnl0ZUxlbmd0aCAtIDQ7ICkge1xuICAgIGlmIChyID09PSBcImF2YzFcIikge1xuICAgICAgaWYgKChoLmdldFVpbnQ4KGEgKyA0KSAmIDMxKSA9PT0gNSkgcmV0dXJuICEwO1xuICAgIH0gZWxzZSBpZiAociA9PT0gXCJodmMxXCIgJiYgKGguZ2V0VWludDgoYSArIDQpID4+IDEgJiA2MykgPT09IDIwKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGEgKz0gaC5nZXRVaW50MzIoYSkgKyA0O1xuICB9XG4gIHJldHVybiAhMTtcbn1cbnZhciAkO1xuY2xhc3MgUmkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBBKHRoaXMsICQsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIFIodGhpcywgXCJvblwiLCAociwgaCkgPT4ge1xuICAgICAgY29uc3QgYSA9IG0odGhpcywgJCkuZ2V0KHIpID8/IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICByZXR1cm4gYS5hZGQoaCksIG0odGhpcywgJCkuaGFzKHIpIHx8IG0odGhpcywgJCkuc2V0KHIsIGEpLCAoKSA9PiB7XG4gICAgICAgIGEuZGVsZXRlKGgpLCBhLnNpemUgPT09IDAgJiYgbSh0aGlzLCAkKS5kZWxldGUocik7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIFIodGhpcywgXCJvbmNlXCIsIChyLCBoKSA9PiB7XG4gICAgICBjb25zdCBhID0gdGhpcy5vbihyLCAoLi4uZikgPT4ge1xuICAgICAgICBhKCksIGgoLi4uZik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0pO1xuICAgIFIodGhpcywgXCJlbWl0XCIsIChyLCAuLi5oKSA9PiB7XG4gICAgICBjb25zdCBhID0gbSh0aGlzLCAkKS5nZXQocik7XG4gICAgICBhICE9IG51bGwgJiYgYS5mb3JFYWNoKChmKSA9PiBmKC4uLmgpKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZm9yd2FyZEV2ZW50KHIsIGgsIGEpIHtcbiAgICBjb25zdCBmID0gYS5tYXAoKGQpID0+IHtcbiAgICAgIGNvbnN0IFtwLCBuXSA9IEFycmF5LmlzQXJyYXkoZCkgPyBkIDogW2QsIGRdO1xuICAgICAgcmV0dXJuIHIub24ocCwgKC4uLnYpID0+IHtcbiAgICAgICAgaC5lbWl0KG4sIC4uLnYpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGYuZm9yRWFjaCgoZCkgPT4gZCgpKTtcbiAgICB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgbSh0aGlzLCAkKS5jbGVhcigpO1xuICB9XG59XG4kID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHVlID0gKGwsIHIpID0+IHtcbiAgY29uc3QgaCA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBuZXcgRGF0YVZpZXcoaC5idWZmZXIpLnNldFVpbnQzMigwLCByKTtcbiAgZm9yIChsZXQgZiA9IDA7IGYgPCA0OyBmKyspXG4gICAgaFs0ICsgZl0gPSBsLmNoYXJDb2RlQXQoZik7XG4gIHJldHVybiBoO1xufSwgTWkgPSAoKSA9PiB7XG4gIGNvbnN0IGwgPSBuZXcgVGV4dEVuY29kZXIoKSwgciA9IGwuZW5jb2RlKFwibWR0YVwiKSwgaCA9IGwuZW5jb2RlKFwibXA0IGhhbmRsZXJcIiksIGEgPSAzMiArIGguYnl0ZUxlbmd0aCArIDEsIGYgPSBuZXcgVWludDhBcnJheShhKSwgZCA9IG5ldyBEYXRhVmlldyhmLmJ1ZmZlcik7XG4gIHJldHVybiBmLnNldCh1ZShcImhkbHJcIiwgYSksIDApLCBkLnNldFVpbnQzMig4LCAwKSwgZi5zZXQociwgMTYpLCBmLnNldChoLCAzMiksIGY7XG59LCBPaSA9IChsKSA9PiB7XG4gIGNvbnN0IHIgPSBuZXcgVGV4dEVuY29kZXIoKSwgaCA9IHIuZW5jb2RlKFwibWR0YVwiKSwgYSA9IGwubWFwKChiKSA9PiB7XG4gICAgY29uc3QgeSA9IHIuZW5jb2RlKGIpLCBCID0gOCArIHkuYnl0ZUxlbmd0aCwgdCA9IG5ldyBVaW50OEFycmF5KEIpO1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcodC5idWZmZXIpLnNldFVpbnQzMigwLCBCKSwgdC5zZXQoaCwgNCksIHQuc2V0KHksIDQgKyBoLmJ5dGVMZW5ndGgpLCB0O1xuICB9KSwgZCA9IDE2ICsgYS5yZWR1Y2UoKGIsIHkpID0+IGIgKyB5LmJ5dGVMZW5ndGgsIDApLCBwID0gbmV3IFVpbnQ4QXJyYXkoZCksIG4gPSBuZXcgRGF0YVZpZXcocC5idWZmZXIpO1xuICBwLnNldCh1ZShcImtleXNcIiwgZCksIDApLCBuLnNldFVpbnQzMig4LCAwKSwgbi5zZXRVaW50MzIoMTIsIGwubGVuZ3RoKTtcbiAgbGV0IHYgPSAxNjtcbiAgZm9yIChjb25zdCBiIG9mIGEpXG4gICAgcC5zZXQoYiwgdiksIHYgKz0gYi5ieXRlTGVuZ3RoO1xuICByZXR1cm4gcDtcbn0sIE5pID0gKGwpID0+IHtcbiAgY29uc3QgciA9IG5ldyBUZXh0RW5jb2RlcigpLCBoID0gci5lbmNvZGUoXCJkYXRhXCIpLCBhID0gT2JqZWN0LmVudHJpZXMobCkubWFwKChbdiwgYl0sIHkpID0+IHtcbiAgICBjb25zdCBCID0geSArIDEsIHQgPSByLmVuY29kZShiKSwgZSA9IDI0ICsgdC5ieXRlTGVuZ3RoLCBpID0gbmV3IFVpbnQ4QXJyYXkoZSksIHMgPSBuZXcgRGF0YVZpZXcoaS5idWZmZXIpO1xuICAgIHJldHVybiBzLnNldFVpbnQzMigwLCBlKSwgcy5zZXRVaW50MzIoNCwgQiksIHMuc2V0VWludDMyKDgsIDE2ICsgdC5ieXRlTGVuZ3RoKSwgaS5zZXQoaCwgMTIpLCBzLnNldFVpbnQzMigxNiwgMSksIGkuc2V0KHQsIDI0KSwgaTtcbiAgfSksIGQgPSA4ICsgYS5yZWR1Y2UoKHYsIGIpID0+IHYgKyBiLmJ5dGVMZW5ndGgsIDApLCBwID0gbmV3IFVpbnQ4QXJyYXkoZCk7XG4gIHAuc2V0KHVlKFwiaWxzdFwiLCBkKSwgMCk7XG4gIGxldCBuID0gODtcbiAgZm9yIChjb25zdCB2IG9mIGEpXG4gICAgcC5zZXQodiwgbiksIG4gKz0gdi5ieXRlTGVuZ3RoO1xuICByZXR1cm4gcDtcbn0sIEdpID0gKGwpID0+IHtcbiAgY29uc3QgciA9IE1pKCksIGggPSBPaShPYmplY3Qua2V5cyhsKSksIGEgPSBOaShsKSwgZiA9IHIubGVuZ3RoICsgaC5sZW5ndGggKyBhLmxlbmd0aCwgZCA9IG5ldyBVaW50OEFycmF5KGYpO1xuICByZXR1cm4gZC5zZXQociwgMCksIGQuc2V0KGgsIHIubGVuZ3RoKSwgZC5zZXQoYSwgci5sZW5ndGggKyBoLmxlbmd0aCksIGQ7XG59O1xuZnVuY3Rpb24gcm4obCkge1xuICB6LmluZm8oXCJyZWNvZGVtdXggb3B0czpcIiwgbCk7XG4gIGNvbnN0IHIgPSBELmNyZWF0ZUZpbGUoKSwgaCA9IG5ldyBSaSgpLCBhID0gKHYsIGIpID0+IHtcbiAgICBjb25zdCBCID0gdi5hZGQoXCJ1ZHRhXCIpLmFkZChcIm1ldGFcIik7XG4gICAgQi5kYXRhID0gR2koYiksIEIuc2l6ZSA9IEIuZGF0YS5ieXRlTGVuZ3RoO1xuICB9O1xuICBsZXQgZiA9ICExO1xuICBjb25zdCBkID0gKCkgPT4ge1xuICAgIHIubW9vdiA9PSBudWxsIHx8IGYgfHwgKGYgPSAhMCwgbC5tZXRhRGF0YVRhZ3MgIT0gbnVsbCAmJiBhKHIubW9vdiwgbC5tZXRhRGF0YVRhZ3MpLCBsLmR1cmF0aW9uICE9IG51bGwgJiYgKHIubW9vdi5tdmhkLmR1cmF0aW9uID0gbC5kdXJhdGlvbikpO1xuICB9O1xuICBoLm9uY2UoXCJWaWRlb1JlYWR5XCIsIGQpLCBoLm9uY2UoXCJBdWRpb1JlYWR5XCIsIGQpO1xuICBsZXQgcCA9IGwudmlkZW8gIT0gbnVsbCA/IEhpKGwudmlkZW8sIHIsIGgpIDogbnVsbCwgbiA9IGwuYXVkaW8gIT0gbnVsbCA/IFZpKGwuYXVkaW8sIHIsIGgpIDogbnVsbDtcbiAgcmV0dXJuIGwudmlkZW8gPT0gbnVsbCAmJiBoLmVtaXQoXCJWaWRlb1JlYWR5XCIpLCBsLmF1ZGlvID09IG51bGwgJiYgaC5lbWl0KFwiQXVkaW9SZWFkeVwiKSwge1xuICAgIGVuY29kZVZpZGVvOiAodiwgYikgPT4ge1xuICAgICAgcCA9PSBudWxsIHx8IHAuZW5jb2RlKHYsIGIpLCB2LmNsb3NlKCk7XG4gICAgfSxcbiAgICBlbmNvZGVBdWRpbzogKHYpID0+IHtcbiAgICAgIG4gIT0gbnVsbCAmJiAobi5lbmNvZGUodiksIHYuY2xvc2UoKSk7XG4gICAgfSxcbiAgICBnZXRFbmNvZGVRdWV1ZVNpemU6ICgpID0+IChwID09IG51bGwgPyB2b2lkIDAgOiBwLmVuY29kZVF1ZXVlU2l6ZSkgPz8gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uZW5jb2RlUXVldWVTaXplKSA/PyAwLFxuICAgIGZsdXNoOiBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHAgPT0gbnVsbCA/IHZvaWQgMCA6IHAuZmx1c2goKSxcbiAgICAgICAgKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uc3RhdGUpID09PSBcImNvbmZpZ3VyZWRcIiA/IG4uZmx1c2goKSA6IG51bGxcbiAgICAgIF0pO1xuICAgIH0sXG4gICAgY2xvc2U6ICgpID0+IHtcbiAgICAgIGguZGVzdHJveSgpLCBwID09IG51bGwgfHwgcC5jbG9zZSgpLCAobiA9PSBudWxsID8gdm9pZCAwIDogbi5zdGF0ZSkgPT09IFwiY29uZmlndXJlZFwiICYmIG4uY2xvc2UoKTtcbiAgICB9LFxuICAgIG1wNGZpbGU6IHJcbiAgfTtcbn1cbmZ1bmN0aW9uIEhpKGwsIHIsIGgpIHtcbiAgY29uc3QgYSA9IHtcbiAgICB0aW1lc2NhbGU6IDFlNixcbiAgICB3aWR0aDogbC53aWR0aCxcbiAgICBoZWlnaHQ6IGwuaGVpZ2h0LFxuICAgIGJyYW5kczogW1wiaXNvbVwiLCBcImlzbzJcIiwgXCJhdmMxXCIsIFwibXA0MlwiLCBcIm1wNDFcIl0sXG4gICAgYXZjRGVjb2RlckNvbmZpZ1JlY29yZDogbnVsbCxcbiAgICBuYW1lOiBcIlRyYWNrIGNyZWF0ZWQgd2l0aCBXZWJBVlwiXG4gIH07XG4gIGxldCBmID0gLTEsIGQgPSAhMTtcbiAgaC5vbmNlKFwiQXVkaW9SZWFkeVwiLCAoKSA9PiB7XG4gICAgZCA9ICEwO1xuICB9KTtcbiAgY29uc3QgcCA9IHtcbiAgICBlbmNvZGVyMDogW10sXG4gICAgZW5jb2RlcjE6IFtdXG4gIH0sIG4gPSAoYywgdSwgXykgPT4ge1xuICAgIHZhciBnO1xuICAgIGlmIChmID09PSAtMSAmJiBfICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHcgPSAoZyA9IF8uZGVjb2RlckNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IGcuZGVzY3JpcHRpb247XG4gICAgICBZaSh3KSwgYS5hdmNEZWNvZGVyQ29uZmlnUmVjb3JkID0gdywgZiA9IHIuYWRkVHJhY2soYSksIGguZW1pdChcIlZpZGVvUmVhZHlcIiksIHouaW5mbyhcIlZpZGVvRW5jb2RlciwgdmlkZW8gdHJhY2sgcmVhZHksIHRyYWNrSWQ6XCIsIGYpO1xuICAgIH1cbiAgICBwW2NdLnB1c2goUXQodSkpO1xuICB9O1xuICBsZXQgdiA9IFwiZW5jb2RlcjFcIiwgYiA9IDA7XG4gIGNvbnN0IHkgPSBNYXRoLmZsb29yKDFlMyAvIGwuZXhwZWN0RlBTICogMWUzKTtcbiAgZnVuY3Rpb24gQigpIHtcbiAgICBpZiAoIWQpIHJldHVybjtcbiAgICBjb25zdCBjID0gdiA9PT0gXCJlbmNvZGVyMVwiID8gXCJlbmNvZGVyMFwiIDogXCJlbmNvZGVyMVwiLCB1ID0gcFt2XSwgXyA9IHBbY107XG4gICAgaWYgKHUubGVuZ3RoID09PSAwICYmIF8ubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgbGV0IGcgPSB1WzBdO1xuICAgIGlmIChnICE9IG51bGwgJiYgKCFnLmlzX3N5bmMgfHwgZy5jdHMgLSBiIDwgeSkpIHtcbiAgICAgIGNvbnN0IFMgPSB0KHUpO1xuICAgICAgUyA+IGIgJiYgKGIgPSBTKTtcbiAgICB9XG4gICAgY29uc3QgdyA9IF9bMF07XG4gICAgaWYgKHcgIT0gbnVsbCAmJiB3LmlzX3N5bmMgJiYgdy5jdHMgLSBiIDwgeSkge1xuICAgICAgdiA9IGMsIEIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGcgIT0gbnVsbCAmJiBnLmlzX3N5bmMgJiYgKHcgIT0gbnVsbCAmJiB3LmlzX3N5bmMpKVxuICAgICAgaWYgKGcuY3RzIDw9IHcuY3RzKSB7XG4gICAgICAgIGNvbnN0IFMgPSB0KHUpO1xuICAgICAgICBTID4gYiAmJiAoYiA9IFMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IGMsIEIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIHQoYykge1xuICAgIGxldCB1ID0gLTEsIF8gPSAwO1xuICAgIGZvciAoOyBfIDwgYy5sZW5ndGg7IF8rKykge1xuICAgICAgY29uc3QgZyA9IGNbX107XG4gICAgICBpZiAoXyA+IDAgJiYgZy5pc19zeW5jKSBicmVhaztcbiAgICAgIHIuYWRkU2FtcGxlKGYsIGcuZGF0YSwgZyksIHUgPSBnLmN0cyArIGcuZHVyYXRpb247XG4gICAgfVxuICAgIHJldHVybiBjLnNwbGljZSgwLCBfKSwgdTtcbiAgfVxuICBjb25zdCBlID0gRGUoQiwgMTUpLCBpID0gQWUoXG4gICAgbCxcbiAgICAoYywgdSkgPT4gbihcImVuY29kZXIwXCIsIGMsIHUpXG4gICksIHMgPSBBZShcbiAgICBsLFxuICAgIChjLCB1KSA9PiBuKFwiZW5jb2RlcjFcIiwgYywgdSlcbiAgKTtcbiAgbGV0IG8gPSAwO1xuICByZXR1cm4ge1xuICAgIGdldCBlbmNvZGVRdWV1ZVNpemUoKSB7XG4gICAgICByZXR1cm4gaS5lbmNvZGVRdWV1ZVNpemUgKyBzLmVuY29kZVF1ZXVlU2l6ZTtcbiAgICB9LFxuICAgIGVuY29kZTogKGMsIHUpID0+IHtcbiAgICAgIHUua2V5RnJhbWUgJiYgKG8gKz0gMSksIChvICUgMiA9PT0gMCA/IGkgOiBzKS5lbmNvZGUoYywgdSk7XG4gICAgfSxcbiAgICBmbHVzaDogYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBpLnN0YXRlID09PSBcImNvbmZpZ3VyZWRcIiA/IGF3YWl0IGkuZmx1c2goKSA6IG51bGwsXG4gICAgICAgIHMuc3RhdGUgPT09IFwiY29uZmlndXJlZFwiID8gYXdhaXQgcy5mbHVzaCgpIDogbnVsbFxuICAgICAgXSksIGUoKSwgQigpO1xuICAgIH0sXG4gICAgY2xvc2U6ICgpID0+IHtcbiAgICAgIGkuc3RhdGUgPT09IFwiY29uZmlndXJlZFwiICYmIGkuY2xvc2UoKSwgcy5zdGF0ZSA9PT0gXCJjb25maWd1cmVkXCIgJiYgcy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIFlpKGwpIHtcbiAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGwpO1xuICByWzJdLnRvU3RyaW5nKDIpLnNsaWNlKC0yKS5pbmNsdWRlcyhcIjFcIikgJiYgKHJbMl0gPSAwKTtcbn1cbmZ1bmN0aW9uIEFlKGwsIHIpIHtcbiAgY29uc3QgaCA9IG5ldyBWaWRlb0VuY29kZXIoe1xuICAgIGVycm9yOiB6LmVycm9yLFxuICAgIG91dHB1dDogclxuICB9KTtcbiAgcmV0dXJuIGguY29uZmlndXJlKHtcbiAgICBjb2RlYzogbC5jb2RlYyxcbiAgICBmcmFtZXJhdGU6IGwuZXhwZWN0RlBTLFxuICAgIGhhcmR3YXJlQWNjZWxlcmF0aW9uOiBsLl9fdW5zYWZlX2hhcmR3YXJlQWNjZWxlcmF0aW9uX18sXG4gICAgYml0cmF0ZTogbC5iaXRyYXRlLFxuICAgIHdpZHRoOiBsLndpZHRoLFxuICAgIGhlaWdodDogbC5oZWlnaHQsXG4gICAgYWxwaGE6IFwiZGlzY2FyZFwiLFxuICAgIGF2YzogeyBmb3JtYXQ6IFwiYXZjXCIgfVxuICB9KSwgaDtcbn1cbmZ1bmN0aW9uIFZpKGwsIHIsIGgpIHtcbiAgY29uc3QgYSA9IHtcbiAgICB0aW1lc2NhbGU6IDFlNixcbiAgICBzYW1wbGVyYXRlOiBsLnNhbXBsZVJhdGUsXG4gICAgY2hhbm5lbF9jb3VudDogbC5jaGFubmVsQ291bnQsXG4gICAgaGRscjogXCJzb3VuXCIsXG4gICAgdHlwZTogbC5jb2RlYyA9PT0gXCJhYWNcIiA/IFwibXA0YVwiIDogXCJPcHVzXCIsXG4gICAgbmFtZTogXCJUcmFjayBjcmVhdGVkIHdpdGggV2ViQVZcIlxuICB9O1xuICBsZXQgZiA9IC0xLCBkID0gW10sIHAgPSAhMTtcbiAgaC5vbmNlKFwiVmlkZW9SZWFkeVwiLCAoKSA9PiB7XG4gICAgcCA9ICEwLCBkLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGNvbnN0IGIgPSBRdCh2KTtcbiAgICAgIHIuYWRkU2FtcGxlKGYsIGIuZGF0YSwgYik7XG4gICAgfSksIGQgPSBbXTtcbiAgfSk7XG4gIGNvbnN0IG4gPSBuZXcgQXVkaW9FbmNvZGVyKHtcbiAgICBlcnJvcjogei5lcnJvcixcbiAgICBvdXRwdXQ6ICh2LCBiKSA9PiB7XG4gICAgICB2YXIgeTtcbiAgICAgIGlmIChmID09PSAtMSkge1xuICAgICAgICBjb25zdCBCID0gKHkgPSBiLmRlY29kZXJDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiB5LmRlc2NyaXB0aW9uO1xuICAgICAgICBmID0gci5hZGRUcmFjayh7XG4gICAgICAgICAgLi4uYSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogQiA9PSBudWxsID8gdm9pZCAwIDogJGkoQilcbiAgICAgICAgfSksIGguZW1pdChcIkF1ZGlvUmVhZHlcIiksIHouaW5mbyhcIkF1ZGlvRW5jb2RlciwgYXVkaW8gdHJhY2sgcmVhZHksIHRyYWNrSWQ6XCIsIGYpO1xuICAgICAgfVxuICAgICAgaWYgKHApIHtcbiAgICAgICAgY29uc3QgQiA9IFF0KHYpO1xuICAgICAgICByLmFkZFNhbXBsZShmLCBCLmRhdGEsIEIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGQucHVzaCh2KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbi5jb25maWd1cmUoe1xuICAgIGNvZGVjOiBsLmNvZGVjID09PSBcImFhY1wiID8gcS5jb2RlYyA6IFwib3B1c1wiLFxuICAgIHNhbXBsZVJhdGU6IGwuc2FtcGxlUmF0ZSxcbiAgICBudW1iZXJPZkNoYW5uZWxzOiBsLmNoYW5uZWxDb3VudCxcbiAgICBiaXRyYXRlOiAxMjhlM1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIFdpKGwsIHIsIGgpIHtcbiAgbGV0IGEgPSAwLCBmID0gMDtcbiAgY29uc3QgZCA9IGwuYm94ZXM7XG4gIGxldCBwID0gITE7XG4gIGNvbnN0IG4gPSAoKSA9PiB7XG4gICAgdmFyIGk7XG4gICAgaWYgKCFwKVxuICAgICAgaWYgKGQuZmluZCgocykgPT4gcy50eXBlID09PSBcIm1vb2ZcIikgIT0gbnVsbClcbiAgICAgICAgcCA9ICEwO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoZiA+PSBkLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgdCA9IG5ldyBELkRhdGFTdHJlYW0oKTtcbiAgICB0LmVuZGlhbm5lc3MgPSBELkRhdGFTdHJlYW0uQklHX0VORElBTjtcbiAgICBsZXQgZSA9IGY7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyBlIDwgZC5sZW5ndGg7IClcbiAgICAgICAgZFtlXS53cml0ZSh0KSwgZGVsZXRlIGRbZV0sIGUgKz0gMTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICBjb25zdCBvID0gZFtlXTtcbiAgICAgIHRocm93IHMgaW5zdGFuY2VvZiBFcnJvciAmJiBvICE9IG51bGwgPyBFcnJvcihcbiAgICAgICAgYCR7cy5tZXNzYWdlfSB8IGRlbHRhQnVmKCBib3hUeXBlOiAke28udHlwZX0sIGJveFNpemU6ICR7by5zaXplfSwgYm94RGF0YUxlbjogJHsoKGkgPSBvLmRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBpLmxlbmd0aCkgPz8gLTF9KWBcbiAgICAgICkgOiBzO1xuICAgIH1cbiAgICByZXR1cm4gQWkobCksIGYgPSBkLmxlbmd0aCwgbmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpO1xuICB9O1xuICBsZXQgdiA9ICExLCBiID0gITEsIHkgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0KHQpIHtcbiAgICAgICAgYSA9IHNlbGYuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGUgPSBuKCk7XG4gICAgICAgICAgZSAhPSBudWxsICYmICFiICYmIHQuZW5xdWV1ZShlKTtcbiAgICAgICAgfSwgciksIHkgPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChjbGVhckludGVydmFsKGEpLCBsLmZsdXNoKCksIGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdC5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaSA9IG4oKTtcbiAgICAgICAgICBpICE9IG51bGwgJiYgIWIgJiYgdC5lbnF1ZXVlKGkpLCBiIHx8IHQuY2xvc2UoKTtcbiAgICAgICAgfSwgdiAmJiB5KCk7XG4gICAgICB9LFxuICAgICAgY2FuY2VsKCkge1xuICAgICAgICBiID0gITAsIGNsZWFySW50ZXJ2YWwoYSksIGggPT0gbnVsbCB8fCBoKCk7XG4gICAgICB9XG4gICAgfSksXG4gICAgc3RvcDogKHQpID0+IHtcbiAgICAgIHYgfHwgKHYgPSAhMCwgeSA9PSBudWxsIHx8IHkodCkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIFppKGwpIHtcbiAgbGV0IHIgPSAwO1xuICBjb25zdCBoID0gbC5ib3hlcywgYSA9IFtdO1xuICBsZXQgZiA9IDA7XG4gIGFzeW5jIGZ1bmN0aW9uIGQoKSB7XG4gICAgY29uc3QgaSA9IGUoaCwgcik7XG4gICAgciA9IGgubGVuZ3RoLCBhLmZvckVhY2goKHsgdHJhY2s6IHMsIGlkOiBvIH0pID0+IHtcbiAgICAgIGNvbnN0IGMgPSBzLnNhbXBsZXMuYXQoLTEpO1xuICAgICAgYyAhPSBudWxsICYmIChmID0gTWF0aC5tYXgoZiwgYy5jdHMgKyBjLmR1cmF0aW9uKSksIGwucmVsZWFzZVVzZWRTYW1wbGVzKG8sIHMuc2FtcGxlcy5sZW5ndGgpLCBzLnNhbXBsZXMgPSBbXTtcbiAgICB9KSwgbC5tZGF0cyA9IFtdLCBsLm1vb2ZzID0gW10sIGkgIT0gbnVsbCAmJiBhd2FpdCAoeSA9PSBudWxsID8gdm9pZCAwIDogeS53cml0ZShpKSk7XG4gIH1cbiAgbGV0IHAgPSBbXTtcbiAgZnVuY3Rpb24gbigpIHtcbiAgICBpZiAocC5sZW5ndGggPiAwKSByZXR1cm4gITA7XG4gICAgY29uc3QgaSA9IGguZmluZEluZGV4KChzKSA9PiBzLnR5cGUgPT09IFwibW9vdlwiKTtcbiAgICBpZiAoaSA9PT0gLTEpIHJldHVybiAhMTtcbiAgICBpZiAocCA9IGguc2xpY2UoMCwgaSArIDEpLCByID0gaSArIDEsIGEubGVuZ3RoID09PSAwKVxuICAgICAgZm9yIChsZXQgcyA9IDE7IDsgcyArPSAxKSB7XG4gICAgICAgIGNvbnN0IG8gPSBsLmdldFRyYWNrQnlJZChzKTtcbiAgICAgICAgaWYgKG8gPT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIGEucHVzaCh7IHRyYWNrOiBvLCBpZDogcyB9KTtcbiAgICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgbGV0IHYgPSAwO1xuICBjb25zdCBiID0gS3QoKTtcbiAgbGV0IHkgPSBudWxsO1xuICBjb25zdCBCID0gKGFzeW5jICgpID0+IHtcbiAgICB5ID0gYXdhaXQgYi5jcmVhdGVXcml0ZXIoKSwgdiA9IHNlbGYuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgbigpICYmIGQoKTtcbiAgICB9LCAxMDApO1xuICB9KSgpO1xuICBsZXQgdCA9ICExO1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICh0KSB0aHJvdyBFcnJvcihcIkZpbGUgZXhwb3J0ZWRcIik7XG4gICAgaWYgKHQgPSAhMCwgYXdhaXQgQiwgY2xlYXJJbnRlcnZhbCh2KSwgIW4oKSB8fCB5ID09IG51bGwpIHJldHVybiBudWxsO1xuICAgIGwuZmx1c2goKSwgYXdhaXQgZCgpLCBhd2FpdCAoeSA9PSBudWxsID8gdm9pZCAwIDogeS5jbG9zZSgpKTtcbiAgICBjb25zdCBpID0gcC5maW5kKChjKSA9PiBjLnR5cGUgPT09IFwibW9vdlwiKTtcbiAgICBpZiAoaSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBpLm12aGQuZHVyYXRpb24gPSBmO1xuICAgIGNvbnN0IHMgPSBLdCgpLCBvID0gZShwLCAwKTtcbiAgICByZXR1cm4gYXdhaXQgQ3QocywgbyksIGF3YWl0IEN0KHMsIGIsIHsgb3ZlcndyaXRlOiAhMSB9KSwgYXdhaXQgcy5zdHJlYW0oKTtcbiAgfTtcbiAgZnVuY3Rpb24gZShpLCBzKSB7XG4gICAgaWYgKHMgPj0gaS5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG8gPSBuZXcgRC5EYXRhU3RyZWFtKCk7XG4gICAgby5lbmRpYW5uZXNzID0gRC5EYXRhU3RyZWFtLkJJR19FTkRJQU47XG4gICAgZm9yIChsZXQgYyA9IHM7IGMgPCBpLmxlbmd0aDsgYysrKVxuICAgICAgaVtjXSAhPT0gbnVsbCAmJiAoaVtjXS53cml0ZShvKSwgZGVsZXRlIGlbY10pO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvLmJ1ZmZlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIFF0KGwpIHtcbiAgY29uc3QgciA9IG5ldyBBcnJheUJ1ZmZlcihsLmJ5dGVMZW5ndGgpO1xuICBsLmNvcHlUbyhyKTtcbiAgY29uc3QgaCA9IGwudGltZXN0YW1wO1xuICByZXR1cm4ge1xuICAgIGR1cmF0aW9uOiBsLmR1cmF0aW9uID8/IDAsXG4gICAgZHRzOiBoLFxuICAgIGN0czogaCxcbiAgICBpc19zeW5jOiBsLnR5cGUgPT09IFwia2V5XCIsXG4gICAgZGF0YTogclxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gWGkobCkge1xuICBjb25zdCByID0gRC5jcmVhdGVGaWxlKCksIGggPSBaaShyKTtcbiAgYXdhaXQgamkobCwgcik7XG4gIGNvbnN0IGEgPSBhd2FpdCBoKCk7XG4gIGlmIChhID09IG51bGwpIHRocm93IEVycm9yKFwiQ2FuIG5vdCBnZW5lcmF0ZSBmaWxlIGZyb20gc3RyZWFtc1wiKTtcbiAgcmV0dXJuIGE7XG59XG5hc3luYyBmdW5jdGlvbiBqaShsLCByKSB7XG4gIGxldCBoID0gMCwgYSA9IDAsIGYgPSAwLCBkID0gMCwgcCA9IDAsIG4gPSAwLCB2ID0gbnVsbCwgYiA9IG51bGw7XG4gIGZvciAoY29uc3QgeSBvZiBsKVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKGFzeW5jIChCKSA9PiB7XG4gICAgICBmZSh5LnBpcGVUaHJvdWdoKG5ldyBjZSgpKSwge1xuICAgICAgICBvbkRvbmU6IEIsXG4gICAgICAgIG9uQ2h1bms6IGFzeW5jICh7IGNodW5rVHlwZTogdCwgZGF0YTogZSB9KSA9PiB7XG4gICAgICAgICAgaWYgKHQgPT09IFwicmVhZHlcIikge1xuICAgICAgICAgICAgY29uc3QgeyB2aWRlb1RyYWNrQ29uZjogaSwgYXVkaW9UcmFja0NvbmY6IHMgfSA9IGRlKFxuICAgICAgICAgICAgICBlLmZpbGUsXG4gICAgICAgICAgICAgIGUuaW5mb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGggPT09IDAgJiYgaSAhPSBudWxsICYmIChoID0gci5hZGRUcmFjayhpKSksIGQgPT09IDAgJiYgcyAhPSBudWxsICYmIChkID0gci5hZGRUcmFjayhzKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0ID09PSBcInNhbXBsZXNcIikge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlOiBpLCBzYW1wbGVzOiBzIH0gPSBlLCBvID0gaSA9PT0gXCJ2aWRlb1wiID8gaCA6IGQsIGMgPSBpID09PSBcInZpZGVvXCIgPyBhIDogcCwgdSA9IGkgPT09IFwidmlkZW9cIiA/IGYgOiBuO1xuICAgICAgICAgICAgcy5mb3JFYWNoKChnKSA9PiB7XG4gICAgICAgICAgICAgIHIuYWRkU2FtcGxlKG8sIGcuZGF0YSwge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBnLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGR0czogZy5kdHMgKyBjLFxuICAgICAgICAgICAgICAgIGN0czogZy5jdHMgKyB1LFxuICAgICAgICAgICAgICAgIGlzX3N5bmM6IGcuaXNfc3luY1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgXyA9IHMuYXQoLTEpO1xuICAgICAgICAgICAgaWYgKF8gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgaSA9PT0gXCJ2aWRlb1wiID8gdiA9IF8gOiBpID09PSBcImF1ZGlvXCIgJiYgKGIgPSBfKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLCB2ICE9IG51bGwgJiYgKGEgKz0gdi5kdHMsIGYgKz0gdi5jdHMpLCBiICE9IG51bGwgJiYgKHAgKz0gYi5kdHMsIG4gKz0gYi5jdHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gYW4obCkge1xuICByZXR1cm4gYXdhaXQgWGkoW2xdKTtcbn1cbmZ1bmN0aW9uIEtpKGwpIHtcbiAgbGV0IHIgPSBbXTtcbiAgY29uc3QgaCA9IG5ldyBBdWRpb0RlY29kZXIoe1xuICAgIG91dHB1dDogKGEpID0+IHtcbiAgICAgIHIucHVzaChhKTtcbiAgICB9LFxuICAgIGVycm9yOiB6LmVycm9yXG4gIH0pO1xuICByZXR1cm4gaC5jb25maWd1cmUobCksIHtcbiAgICBkZWNvZGU6IGFzeW5jIChhKSA9PiB7XG4gICAgICBhLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgaC5kZWNvZGUoXG4gICAgICAgICAgbmV3IEVuY29kZWRBdWRpb0NodW5rKHtcbiAgICAgICAgICAgIHR5cGU6IGQuaXNfc3luYyA/IFwia2V5XCIgOiBcImRlbHRhXCIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IDFlNiAqIGQuY3RzIC8gZC50aW1lc2NhbGUsXG4gICAgICAgICAgICBkdXJhdGlvbjogMWU2ICogZC5kdXJhdGlvbiAvIGQudGltZXNjYWxlLFxuICAgICAgICAgICAgZGF0YTogZC5kYXRhXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pLCBhd2FpdCBoLmZsdXNoKCk7XG4gICAgICBjb25zdCBmID0gcjtcbiAgICAgIHJldHVybiByID0gW10sIGY7XG4gICAgfSxcbiAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgaC5jbG9zZSgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIFFpKGwsIHIpIHtcbiAgY29uc3QgaCA9IG5ldyBBdWRpb0VuY29kZXIoe1xuICAgIG91dHB1dDogKGQpID0+IHtcbiAgICAgIHIoUXQoZCkpO1xuICAgIH0sXG4gICAgZXJyb3I6IHouZXJyb3JcbiAgfSk7XG4gIGguY29uZmlndXJlKHtcbiAgICBjb2RlYzogbC5jb2RlYyxcbiAgICBzYW1wbGVSYXRlOiBsLnNhbXBsZVJhdGUsXG4gICAgbnVtYmVyT2ZDaGFubmVsczogbC5udW1iZXJPZkNoYW5uZWxzXG4gIH0pO1xuICBsZXQgYSA9IG51bGw7XG4gIGZ1bmN0aW9uIGYoZCwgcCkge1xuICAgIHJldHVybiBuZXcgQXVkaW9EYXRhKHtcbiAgICAgIHRpbWVzdGFtcDogcCxcbiAgICAgIG51bWJlck9mQ2hhbm5lbHM6IGwubnVtYmVyT2ZDaGFubmVscyxcbiAgICAgIG51bWJlck9mRnJhbWVzOiBkLmxlbmd0aCAvIGwubnVtYmVyT2ZDaGFubmVscyxcbiAgICAgIHNhbXBsZVJhdGU6IGwuc2FtcGxlUmF0ZSxcbiAgICAgIGZvcm1hdDogXCJmMzItcGxhbmFyXCIsXG4gICAgICBkYXRhOiBkXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGFzeW5jIChkLCBwKSA9PiB7XG4gICAgICBhICE9IG51bGwgJiYgaC5lbmNvZGUoZihhLmRhdGEsIGEudHMpKSwgYSA9IHsgZGF0YTogZCwgdHM6IHAgfTtcbiAgICB9LFxuICAgIHN0b3A6IGFzeW5jICgpID0+IHtcbiAgICAgIGEgIT0gbnVsbCAmJiAoSmkoYS5kYXRhLCBsLm51bWJlck9mQ2hhbm5lbHMsIGwuc2FtcGxlUmF0ZSksIGguZW5jb2RlKGYoYS5kYXRhLCBhLnRzKSksIGEgPSBudWxsKSwgYXdhaXQgaC5mbHVzaCgpLCBoLmNsb3NlKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gSmkobCwgciwgaCkge1xuICBjb25zdCBhID0gbC5sZW5ndGggLSAxLCBmID0gTWF0aC5taW4oaCAvIDIsIGEpO1xuICBmb3IgKGxldCBkID0gMDsgZCA8IGY7IGQrKylcbiAgICBmb3IgKGxldCBwID0gMTsgcCA8PSByOyBwKyspXG4gICAgICBsW01hdGguZmxvb3IoYSAvIHApIC0gZF0gKj0gZCAvIGY7XG59XG5mdW5jdGlvbiBvbihsLCByKSB7XG4gIHouaW5mbyhcIm1peGluTVA0QW5kQXVkaW8sIG9wdHM6XCIsIHtcbiAgICB2b2x1bWU6IHIudm9sdW1lLFxuICAgIGxvb3A6IHIubG9vcFxuICB9KTtcbiAgY29uc3QgaCA9IEQuY3JlYXRlRmlsZSgpLCB7IHN0cmVhbTogYSwgc3RvcDogZiB9ID0gV2koaCwgNTAwKTtcbiAgbGV0IGQgPSBudWxsLCBwID0gbnVsbCwgbiA9IFtdLCB2ID0gMCwgYiA9IDAsIHkgPSAwLCBCID0gITAsIHQgPSA0OGUzO1xuICBmZShsLnBpcGVUaHJvdWdoKG5ldyBjZSgpKSwge1xuICAgIG9uRG9uZTogYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgKHAgPT0gbnVsbCA/IHZvaWQgMCA6IHAuc3RvcCgpKSwgZCA9PSBudWxsIHx8IGQuY2xvc2UoKSwgZigpO1xuICAgIH0sXG4gICAgb25DaHVuazogYXN5bmMgKHsgY2h1bmtUeXBlOiBvLCBkYXRhOiBjIH0pID0+IHtcbiAgICAgIGlmIChvID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgY29uc3QgeyB2aWRlb1RyYWNrQ29uZjogdSwgYXVkaW9UcmFja0NvbmY6IF8sIGF1ZGlvRGVjb2RlckNvbmY6IGcgfSA9IGRlKGMuZmlsZSwgYy5pbmZvKTtcbiAgICAgICAgdiA9PT0gMCAmJiB1ICE9IG51bGwgJiYgKHYgPSBoLmFkZFRyYWNrKHUpKTtcbiAgICAgICAgY29uc3QgdyA9IF8gPz8ge1xuICAgICAgICAgIHRpbWVzY2FsZTogMWU2LFxuICAgICAgICAgIHNhbXBsZXJhdGU6IHQsXG4gICAgICAgICAgY2hhbm5lbF9jb3VudDogcS5jaGFubmVsQ291bnQsXG4gICAgICAgICAgaGRscjogXCJzb3VuXCIsXG4gICAgICAgICAgbmFtZTogXCJTb3VuZEhhbmRsZXJcIixcbiAgICAgICAgICB0eXBlOiBcIm1wNGFcIlxuICAgICAgICB9O1xuICAgICAgICBiID09PSAwICYmIChiID0gaC5hZGRUcmFjayh3KSwgdCA9IChfID09IG51bGwgPyB2b2lkIDAgOiBfLnNhbXBsZXJhdGUpID8/IHQsIEIgPSBfICE9IG51bGwpO1xuICAgICAgICBjb25zdCBTID0gbmV3IEF1ZGlvQ29udGV4dCh7IHNhbXBsZVJhdGU6IHQgfSk7XG4gICAgICAgIG4gPSBPZShcbiAgICAgICAgICBhd2FpdCBTLmRlY29kZUF1ZGlvRGF0YShcbiAgICAgICAgICAgIGF3YWl0IG5ldyBSZXNwb25zZShyLnN0cmVhbSkuYXJyYXlCdWZmZXIoKVxuICAgICAgICAgIClcbiAgICAgICAgKSwgZyAhPSBudWxsICYmIChkID0gS2koZykpLCBwID0gUWkoXG4gICAgICAgICAgZyA/PyB7XG4gICAgICAgICAgICBjb2RlYzogdy50eXBlID09PSBcIm1wNGFcIiA/IHEuY29kZWMgOiB3LnR5cGUsXG4gICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzOiB3LmNoYW5uZWxfY291bnQsXG4gICAgICAgICAgICBzYW1wbGVSYXRlOiB3LnNhbXBsZXJhdGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIChVKSA9PiBoLmFkZFNhbXBsZShiLCBVLmRhdGEsIFUpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKG8gPT09IFwic2FtcGxlc1wiKSB7XG4gICAgICAgIGNvbnN0IHsgaWQ6IHUsIHR5cGU6IF8sIHNhbXBsZXM6IGcgfSA9IGM7XG4gICAgICAgIGlmIChfID09PSBcInZpZGVvXCIpIHtcbiAgICAgICAgICBnLmZvckVhY2goKHcpID0+IGguYWRkU2FtcGxlKHUsIHcuZGF0YSwgdykpLCBCIHx8IGF3YWl0IGkoZyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF8gPT09IFwiYXVkaW9cIiAmJiBhd2FpdCBzKGcpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGUobykge1xuICAgIGNvbnN0IGMgPSBuLm1hcChcbiAgICAgICh1KSA9PiByLmxvb3AgPyBTaSh1LCB5LCB5ICsgbykgOiB1LnNsaWNlKHksIHkgKyBvKVxuICAgICk7XG4gICAgaWYgKHkgKz0gbywgci52b2x1bWUgIT09IDEpXG4gICAgICBmb3IgKGNvbnN0IHUgb2YgYylcbiAgICAgICAgZm9yIChsZXQgXyA9IDA7IF8gPCB1Lmxlbmd0aDsgXysrKSB1W19dICo9IHIudm9sdW1lO1xuICAgIHJldHVybiBjO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGkobykge1xuICAgIGNvbnN0IGMgPSBvWzBdLCB1ID0gb1tvLmxlbmd0aCAtIDFdLCBfID0gTWF0aC5mbG9vcihcbiAgICAgICh1LmN0cyArIHUuZHVyYXRpb24gLSBjLmN0cykgLyB1LnRpbWVzY2FsZSAqIHRcbiAgICApLCBnID0gYmUoW2UoXyldKTtcbiAgICBnLmxlbmd0aCAhPT0gMCAmJiAocCA9PSBudWxsIHx8IHAuZW5jb2RlKFxuICAgICAgZyxcbiAgICAgIGMuY3RzIC8gYy50aW1lc2NhbGUgKiAxZTZcbiAgICApKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzKG8pIHtcbiAgICBpZiAoZCA9PSBudWxsKSByZXR1cm47XG4gICAgY29uc3QgYyA9IChhd2FpdCBkLmRlY29kZShvKSkubWFwKFxuICAgICAgbGVcbiAgICApLCB1ID0gbWkoYyksIF8gPSBlKHVbMF0ubGVuZ3RoKSwgZyA9IG9bMF07XG4gICAgcCA9PSBudWxsIHx8IHAuZW5jb2RlKFxuICAgICAgYmUoW3UsIF9dKSxcbiAgICAgIGcuY3RzIC8gZy50aW1lc2NhbGUgKiAxZTZcbiAgICApO1xuICB9XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gJGkobCkge1xuICBjb25zdCByID0gbC5ieXRlTGVuZ3RoLCBoID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgLy8gZmxhZ3NcbiAgICAzLFxuICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIDIzICsgcixcbiAgICAvLyBsZW5ndGhcbiAgICAwLFxuICAgIC8vIDB4MDEsIC8vIGVzX2lkXG4gICAgMixcbiAgICAvLyBlc19pZFxuICAgIDAsXG4gICAgLy8gc3RyZWFtX3ByaW9yaXR5XG4gICAgNCxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAxOCArIHIsXG4gICAgLy8gbGVuZ3RoXG4gICAgNjQsXG4gICAgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgIDIxLFxuICAgIC8vIHN0cmVhbV90eXBlXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgLy8gYnVmZmVyX3NpemVcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIC8vIG1heEJpdHJhdGVcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIC8vIGF2Z0JpdHJhdGVcbiAgICA1LFxuICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIHIsXG4gICAgLi4ubmV3IFVpbnQ4QXJyYXkobCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbCA6IGwuYnVmZmVyKSxcbiAgICA2LFxuICAgIDEsXG4gICAgMlxuICBdKSwgYSA9IG5ldyBELkJveFBhcnNlci5lc2RzQm94KGguYnl0ZUxlbmd0aCk7XG4gIHJldHVybiBhLmhkcl9zaXplID0gMCwgYS5wYXJzZShuZXcgRC5EYXRhU3RyZWFtKGgsIDAsIEQuRGF0YVN0cmVhbS5CSUdfRU5ESUFOKSksIGE7XG59XG5leHBvcnQge1xuICBxIGFzIERFRkFVTFRfQVVESU9fQ09ORixcbiAgUmkgYXMgRXZlbnRUb29sLFxuICB6IGFzIExvZyxcbiAgc24gYXMgTVA0Q2xpcCxcbiAgZW4gYXMgYWRqdXN0QXVkaW9EYXRhVm9sdW1lLFxuICBiaSBhcyBhdWRpb1Jlc2FtcGxlLFxuICBmZSBhcyBhdXRvUmVhZFN0cmVhbSxcbiAgTWUgYXMgY29uY2F0RmxvYXQzMkFycmF5LFxuICBtaSBhcyBjb25jYXRQQ01GcmFnbWVudHMsXG4gIFZlIGFzIGNyZWF0ZUVsLFxuICBubiBhcyBkZWNvZGVJbWcsXG4gIE9lIGFzIGV4dHJhY3RQQ000QXVkaW9CdWZmZXIsXG4gIGxlIGFzIGV4dHJhY3RQQ000QXVkaW9EYXRhLFxuICBYaSBhcyBmYXN0Q29uY2F0TVA0LFxuICBXaSBhcyBmaWxlMnN0cmVhbSxcbiAgYW4gYXMgZml4Rk1QNER1cmF0aW9uLFxuICBvbiBhcyBtaXhpbk1QNEFuZEF1ZGlvLFxuICBiZSBhcyBtaXhpblBDTSxcbiAgcm4gYXMgcmVjb2RlbXV4LFxuICBXZSBhcyByZW5kZXJUeHQySW1nLFxuICB0biBhcyByZW5kZXJUeHQySW1nQml0bWFwLFxuICBTaSBhcyByaW5nU2xpY2VGbG9hdDMyQXJyYXksXG4gIERlIGFzIHdvcmtlclRpbWVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhbWVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@designcombo/frames/dist/frames.js\n");

/***/ })

};
;
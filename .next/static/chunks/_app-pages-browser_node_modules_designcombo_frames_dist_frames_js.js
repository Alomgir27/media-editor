"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_designcombo_frames_dist_frames_js"],{

/***/ "(app-pages-browser)/./node_modules/@designcombo/frames/dist/frames.js":
/*!*********************************************************!*\
  !*** ./node_modules/@designcombo/frames/dist/frames.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_AUDIO_CONF: function() { return /* binding */ q; },\n/* harmony export */   EventTool: function() { return /* binding */ Ri; },\n/* harmony export */   Log: function() { return /* binding */ z; },\n/* harmony export */   MP4Clip: function() { return /* binding */ sn; },\n/* harmony export */   adjustAudioDataVolume: function() { return /* binding */ en; },\n/* harmony export */   audioResample: function() { return /* binding */ bi; },\n/* harmony export */   autoReadStream: function() { return /* binding */ fe; },\n/* harmony export */   concatFloat32Array: function() { return /* binding */ Me; },\n/* harmony export */   concatPCMFragments: function() { return /* binding */ mi; },\n/* harmony export */   createEl: function() { return /* binding */ Ve; },\n/* harmony export */   decodeImg: function() { return /* binding */ nn; },\n/* harmony export */   extractPCM4AudioBuffer: function() { return /* binding */ Oe; },\n/* harmony export */   extractPCM4AudioData: function() { return /* binding */ le; },\n/* harmony export */   fastConcatMP4: function() { return /* binding */ Xi; },\n/* harmony export */   file2stream: function() { return /* binding */ Wi; },\n/* harmony export */   fixFMP4Duration: function() { return /* binding */ an; },\n/* harmony export */   mixinMP4AndAudio: function() { return /* binding */ on; },\n/* harmony export */   mixinPCM: function() { return /* binding */ be; },\n/* harmony export */   recodemux: function() { return /* binding */ rn; },\n/* harmony export */   renderTxt2Img: function() { return /* binding */ We; },\n/* harmony export */   renderTxt2ImgBitmap: function() { return /* binding */ tn; },\n/* harmony export */   ringSliceFloat32Array: function() { return /* binding */ Si; },\n/* harmony export */   workerTimer: function() { return /* binding */ De; }\n/* harmony export */ });\nvar He = Object.defineProperty;\nvar pe = (l) => {\n  throw TypeError(l);\n};\nvar Ye = (l, r, h) => r in l ? He(l, r, { enumerable: !0, configurable: !0, writable: !0, value: h }) : l[r] = h;\nvar R = (l, r, h) => Ye(l, typeof r != \"symbol\" ? r + \"\" : r, h), _e = (l, r, h) => r.has(l) || pe(\"Cannot \" + h);\nvar m = (l, r, h) => (_e(l, r, \"read from private field\"), h ? h.call(l) : r.get(l)), A = (l, r, h) => r.has(l) ? pe(\"Cannot add the same private member more than once\") : r instanceof WeakSet ? r.add(l) : r.set(l, h), E = (l, r, h, a) => (_e(l, r, \"write to private field\"), a ? a.call(l, h) : r.set(l, h), h);\nfunction Ve(l) {\n  return document.createElement(l);\n}\nfunction We(l, r) {\n  const h = Ve(\"pre\");\n  h.style.cssText = `margin: 0; ${r}; visibility: hidden; position: fixed;`, h.textContent = l, document.body.appendChild(h);\n  const { width: a, height: f } = h.getBoundingClientRect();\n  h.remove(), h.style.visibility = \"visible\";\n  const d = new Image();\n  d.width = a, d.height = f;\n  const p = `\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${a}\" height=\"${f}\">\n    <foreignObject width=\"100%\" height=\"100%\">\n        <div xmlns=\"http://www.w3.org/1999/xhtml\">${h.outerHTML}</div>\n    </foreignObject>\n    </svg>\n  `.replace(/\\t/g, \"\").replace(/#/g, \"%23\");\n  return d.src = `data:image/svg+xml;charset=utf-8,${p}`, d;\n}\nasync function tn(l, r) {\n  const h = We(l, r);\n  await new Promise((d) => {\n    h.onload = d;\n  });\n  const a = new OffscreenCanvas(h.width, h.height), f = a.getContext(\"2d\");\n  return f == null || f.drawImage(h, 0, 0, h.width, h.height), await createImageBitmap(a);\n}\nvar Be = (l) => {\n  throw TypeError(l);\n}, Fe = (l, r, h) => r.has(l) || Be(\"Cannot \" + h), I = (l, r, h) => (Fe(l, r, \"read from private field\"), h ? h.call(l) : r.get(l)), N = (l, r, h) => r.has(l) ? Be(\"Cannot add the same private member more than once\") : r instanceof WeakSet ? r.add(l) : r.set(l, h), M = (l, r, h, a) => (Fe(l, r, \"write to private field\"), r.set(l, h), h);\nconst Ie = \"KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHUobil7aWYobj09PSIvIilyZXR1cm57cGFyZW50Om51bGwsbmFtZToiIn07Y29uc3QgZT1uLnNwbGl0KCIvIikuZmlsdGVyKGk9PmkubGVuZ3RoPjApO2lmKGUubGVuZ3RoPT09MCl0aHJvdyBFcnJvcigiSW52YWxpZCBwYXRoIik7Y29uc3QgYT1lW2UubGVuZ3RoLTFdLHI9Ii8iK2Uuc2xpY2UoMCwtMSkuam9pbigiLyIpO3JldHVybntuYW1lOmEscGFyZW50OnJ9fWFzeW5jIGZ1bmN0aW9uIHcobixlKXtjb25zdHtwYXJlbnQ6YSxuYW1lOnJ9PXUobik7aWYoYT09bnVsbClyZXR1cm4gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7Y29uc3QgaT1hLnNwbGl0KCIvIikuZmlsdGVyKHQ9PnQubGVuZ3RoPjApO3RyeXtsZXQgdD1hd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtmb3IoY29uc3QgcyBvZiBpKXQ9YXdhaXQgdC5nZXREaXJlY3RvcnlIYW5kbGUocyx7Y3JlYXRlOmUuY3JlYXRlfSk7aWYoZS5pc0ZpbGUpcmV0dXJuIGF3YWl0IHQuZ2V0RmlsZUhhbmRsZShyLHtjcmVhdGU6ZS5jcmVhdGV9KX1jYXRjaCh0KXtpZih0Lm5hbWU9PT0iTm90Rm91bmRFcnJvciIpcmV0dXJuIG51bGw7dGhyb3cgdH19Y29uc3QgZj17fTtzZWxmLm9ubWVzc2FnZT1hc3luYyBuPT57dmFyIGk7Y29uc3R7ZXZ0VHlwZTplLGFyZ3M6YX09bi5kYXRhO2xldCByPWZbYS5maWxlSWRdO3RyeXtsZXQgdDtjb25zdCBzPVtdO2lmKGU9PT0icmVnaXN0ZXIiKXtjb25zdCBsPWF3YWl0IHcoYS5maWxlUGF0aCx7Y3JlYXRlOiEwLGlzRmlsZTohMH0pO2lmKGw9PW51bGwpdGhyb3cgRXJyb3IoYG5vdCBmb3VuZCBmaWxlOiAke2EuZmlsZUlkfWApO3I9YXdhaXQgbC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKHttb2RlOmEubW9kZX0pLGZbYS5maWxlSWRdPXJ9ZWxzZSBpZihlPT09ImNsb3NlIilhd2FpdCByLmNsb3NlKCksZGVsZXRlIGZbYS5maWxlSWRdO2Vsc2UgaWYoZT09PSJ0cnVuY2F0ZSIpYXdhaXQgci50cnVuY2F0ZShhLm5ld1NpemUpO2Vsc2UgaWYoZT09PSJ3cml0ZSIpe2NvbnN0e2RhdGE6bCxvcHRzOm99PW4uZGF0YS5hcmdzO3Q9YXdhaXQgci53cml0ZShsLG8pfWVsc2UgaWYoZT09PSJyZWFkIil7Y29uc3R7b2Zmc2V0Omwsc2l6ZTpvfT1uLmRhdGEuYXJncyxnPW5ldyBVaW50OEFycmF5KG8pLGQ9YXdhaXQgci5yZWFkKGcse2F0Omx9KSxjPWcuYnVmZmVyO3Q9ZD09PW8/YzooKGk9Yy50cmFuc2Zlcik9PW51bGw/dm9pZCAwOmkuY2FsbChjLGQpKT8/Yy5zbGljZSgwLGQpLHMucHVzaCh0KX1lbHNlIGU9PT0iZ2V0U2l6ZSI/dD1hd2FpdCByLmdldFNpemUoKTplPT09ImZsdXNoIiYmYXdhaXQgci5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2V2dFR5cGU6ImNhbGxiYWNrIixjYklkOm4uZGF0YS5jYklkLHJldHVyblZhbDp0fSxzKX1jYXRjaCh0KXtjb25zdCBzPXQ7c2VsZi5wb3N0TWVzc2FnZSh7ZXZ0VHlwZToidGhyb3dFcnJvciIsY2JJZDpuLmRhdGEuY2JJZCxlcnJNc2c6cy5uYW1lKyI6ICIrcy5tZXNzYWdlK2AKYCtKU09OLnN0cmluZ2lmeShuLmRhdGEpfSl9fX0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZnMtd29ya2VyLUY0UldscWNfLmpzLm1hcAo=\", Ze = (l) => Uint8Array.from(atob(l), (r) => r.charCodeAt(0)), ge = typeof self < \"u\" && self.Blob && new Blob([Ze(Ie)], { type: \"text/javascript;charset=utf-8\" });\nfunction Xe(l) {\n  let r;\n  try {\n    if (r = ge && (self.URL || self.webkitURL).createObjectURL(ge), !r) throw \"\";\n    const h = new Worker(r, {\n      name: l == null ? void 0 : l.name\n    });\n    return h.addEventListener(\"error\", () => {\n      (self.URL || self.webkitURL).revokeObjectURL(r);\n    }), h;\n  } catch {\n    return new Worker(\n      \"data:text/javascript;base64,\" + Ie,\n      {\n        name: l == null ? void 0 : l.name\n      }\n    );\n  } finally {\n    r && (self.URL || self.webkitURL).revokeObjectURL(r);\n  }\n}\nasync function je(l, r, h) {\n  const a = Ke();\n  return await a(\"register\", { fileId: l, filePath: r, mode: h }), {\n    read: async (f, d) => await a(\"read\", {\n      fileId: l,\n      offset: f,\n      size: d\n    }),\n    write: async (f, d) => await a(\n      \"write\",\n      {\n        fileId: l,\n        data: f,\n        opts: d\n      },\n      [ArrayBuffer.isView(f) ? f.buffer : f]\n    ),\n    close: async () => await a(\"close\", {\n      fileId: l\n    }),\n    truncate: async (f) => await a(\"truncate\", {\n      fileId: l,\n      newSize: f\n    }),\n    getSize: async () => await a(\"getSize\", {\n      fileId: l\n    }),\n    flush: async () => await a(\"flush\", {\n      fileId: l\n    })\n  };\n}\nconst Yt = [];\nlet ie = 0;\nfunction Ke() {\n  if (Yt.length < 3) {\n    const r = l();\n    return Yt.push(r), r;\n  } else {\n    const r = Yt[ie];\n    return ie = (ie + 1) % Yt.length, r;\n  }\n  function l() {\n    const r = new Xe();\n    let h = 0, a = {};\n    return r.onmessage = ({\n      data: f\n    }) => {\n      var d, p;\n      f.evtType === \"callback\" ? (d = a[f.cbId]) == null || d.resolve(f.returnVal) : f.evtType === \"throwError\" && ((p = a[f.cbId]) == null || p.reject(Error(f.errMsg))), delete a[f.cbId];\n    }, async function(f, d, p = []) {\n      h += 1;\n      const n = new Promise((v, b) => {\n        a[h] = { resolve: v, reject: b };\n      });\n      return r.postMessage(\n        {\n          cbId: h,\n          evtType: f,\n          args: d\n        },\n        p\n      ), n;\n    };\n  }\n}\nfunction te(l) {\n  if (l === \"/\") return { parent: null, name: \"\" };\n  const r = l.split(\"/\").filter((f) => f.length > 0);\n  if (r.length === 0) throw Error(\"Invalid path\");\n  const h = r[r.length - 1], a = \"/\" + r.slice(0, -1).join(\"/\");\n  return { name: h, parent: a };\n}\nasync function ot(l, r) {\n  const { parent: h, name: a } = te(l);\n  if (h == null) return await navigator.storage.getDirectory();\n  const f = h.split(\"/\").filter((d) => d.length > 0);\n  try {\n    let d = await navigator.storage.getDirectory();\n    for (const p of f)\n      d = await d.getDirectoryHandle(p, {\n        create: r.create\n      });\n    return r.isFile ? await d.getFileHandle(a, {\n      create: r.create\n    }) : await d.getDirectoryHandle(a, {\n      create: r.create\n    });\n  } catch (d) {\n    if (d.name === \"NotFoundError\")\n      return null;\n    throw d;\n  }\n}\nasync function Ce(l) {\n  const { parent: r, name: h } = te(l);\n  if (r == null) {\n    const f = await navigator.storage.getDirectory();\n    for await (const d of f.keys())\n      await f.removeEntry(d, { recursive: !0 });\n    return;\n  }\n  const a = await ot(r, {\n    create: !1,\n    isFile: !1\n  });\n  a != null && await a.removeEntry(h, { recursive: !0 });\n}\nfunction se(l, r) {\n  return `${l}/${r}`.replace(\"//\", \"/\");\n}\nfunction vt(l) {\n  return new ze(l);\n}\nvar H, Vt, At;\nclass ze {\n  constructor(r) {\n    N(this, H), N(this, Vt), N(this, At), M(this, H, r);\n    const { parent: h, name: a } = te(r);\n    M(this, Vt, a), M(this, At, h);\n  }\n  get kind() {\n    return \"dir\";\n  }\n  get name() {\n    return I(this, Vt);\n  }\n  get path() {\n    return I(this, H);\n  }\n  get parent() {\n    return I(this, At) == null ? null : vt(I(this, At));\n  }\n  /**\n   * Creates the directory.\n   * return A promise that resolves when the directory is created.\n   */\n  async create() {\n    return await ot(I(this, H), {\n      create: !0,\n      isFile: !1\n    }), vt(I(this, H));\n  }\n  /**\n   * Checks if the directory exists.\n   * return A promise that resolves to true if the directory exists, otherwise false.\n   */\n  async exists() {\n    return await ot(I(this, H), {\n      create: !1,\n      isFile: !1\n    }) instanceof FileSystemDirectoryHandle;\n  }\n  /**\n   * Removes the directory.\n   * return A promise that resolves when the directory is removed.\n   */\n  async remove() {\n    for (const r of await this.children())\n      try {\n        await r.remove();\n      } catch (h) {\n        console.warn(h);\n      }\n    try {\n      await Ce(I(this, H));\n    } catch (r) {\n      console.warn(r);\n    }\n  }\n  /**\n   * Retrieves the children of the directory.\n   * return A promise that resolves to an array of objects representing the children.\n   */\n  async children() {\n    const r = await ot(I(this, H), {\n      create: !1,\n      isFile: !1\n    });\n    if (r == null) return [];\n    const h = [];\n    for await (const a of r.values())\n      h.push((a.kind === \"file\" ? _t : vt)(se(I(this, H), a.name)));\n    return h;\n  }\n  /**\n   * If the dest folder exists, copy the current directory into the dest folder;\n   * if the dest folder does not exist, rename the current directory to dest name.\n   */\n  async copyTo(r) {\n    if (!await this.exists())\n      throw Error(`dir ${this.path} not exists`);\n    const h = await r.exists() ? vt(se(r.path, this.name)) : r;\n    return await h.create(), await Promise.all((await this.children()).map((a) => a.copyTo(h))), h;\n  }\n  /**\n   * move directory, copy then remove current\n   */\n  async moveTo(r) {\n    const h = await this.copyTo(r);\n    return await this.remove(), h;\n  }\n}\nH = /* @__PURE__ */ new WeakMap(), Vt = /* @__PURE__ */ new WeakMap(), At = /* @__PURE__ */ new WeakMap();\nconst ye = /* @__PURE__ */ new Map();\nfunction _t(l, r = \"rw\") {\n  if (r === \"rw\") {\n    const h = ye.get(l) ?? new jt(l, r);\n    return ye.set(l, h), h;\n  }\n  return new jt(l, r);\n}\nasync function Ct(l, r, h = { overwrite: !0 }) {\n  if (r instanceof jt) {\n    await Ct(l, await r.stream(), h);\n    return;\n  }\n  const a = await (l instanceof jt ? l : _t(l, \"rw\")).createWriter();\n  try {\n    if (h.overwrite && await a.truncate(0), r instanceof ReadableStream) {\n      const f = r.getReader();\n      for (; ; ) {\n        const { done: d, value: p } = await f.read();\n        if (d) break;\n        await a.write(p);\n      }\n    } else\n      await a.write(r);\n  } catch (f) {\n    throw f;\n  } finally {\n    await a.close();\n  }\n}\nlet Qe = 0;\nconst Je = () => ++Qe;\nvar Y, Bt, Wt, Ft, Zt, it, Xt, It;\nconst $e = class Te {\n  constructor(r, h) {\n    N(this, Y), N(this, Bt), N(this, Wt), N(this, Ft), N(this, Zt), N(this, it, 0), N(this, Xt, /* @__PURE__ */ (() => {\n      let d = null;\n      return () => (M(this, it, I(this, it) + 1), d ?? (d = new Promise(async (p, n) => {\n        try {\n          const v = await je(\n            I(this, Zt),\n            I(this, Y),\n            I(this, Ft)\n          );\n          p([\n            v,\n            async () => {\n              M(this, it, I(this, it) - 1), !(I(this, it) > 0) && (d = null, await v.close());\n            }\n          ]);\n        } catch (v) {\n          n(v);\n        }\n      })));\n    })()), N(this, It, !1), M(this, Zt, Je()), M(this, Y, r), M(this, Ft, {\n      r: \"read-only\",\n      rw: \"readwrite\",\n      \"rw-unsafe\": \"readwrite-unsafe\"\n    }[h]);\n    const { parent: a, name: f } = te(r);\n    M(this, Wt, f), M(this, Bt, a);\n  }\n  get kind() {\n    return \"file\";\n  }\n  get path() {\n    return I(this, Y);\n  }\n  get name() {\n    return I(this, Wt);\n  }\n  get parent() {\n    return I(this, Bt) == null ? null : vt(I(this, Bt));\n  }\n  /**\n   * Random write to file\n   */\n  async createWriter() {\n    if (I(this, Ft) === \"read-only\") throw Error(\"file is read-only\");\n    if (I(this, It)) throw Error(\"Other writer have not been closed\");\n    M(this, It, !0);\n    const r = new TextEncoder(), [h, a] = await I(this, Xt).call(this);\n    let f = await h.getSize(), d = !1;\n    return {\n      write: async (p, n = {}) => {\n        if (d) throw Error(\"Writer is closed\");\n        const v = typeof p == \"string\" ? r.encode(p) : p, b = n.at ?? f, y = v.byteLength;\n        return f = b + y, await h.write(v, { at: b });\n      },\n      truncate: async (p) => {\n        if (d) throw Error(\"Writer is closed\");\n        await h.truncate(p), f > p && (f = p);\n      },\n      flush: async () => {\n        if (d) throw Error(\"Writer is closed\");\n        await h.flush();\n      },\n      close: async () => {\n        if (d) throw Error(\"Writer is closed\");\n        d = !0, M(this, It, !1), await a();\n      }\n    };\n  }\n  /**\n   * Random access to file\n   */\n  async createReader() {\n    const [r, h] = await I(this, Xt).call(this);\n    let a = !1, f = 0;\n    return {\n      read: async (d, p = {}) => {\n        if (a) throw Error(\"Reader is closed\");\n        const n = p.at ?? f, v = await r.read(n, d);\n        return f = n + v.byteLength, v;\n      },\n      getSize: async () => {\n        if (a) throw Error(\"Reader is closed\");\n        return await r.getSize();\n      },\n      close: async () => {\n        a || (a = !0, await h());\n      }\n    };\n  }\n  async text() {\n    return new TextDecoder().decode(await this.arrayBuffer());\n  }\n  async arrayBuffer() {\n    const r = await ot(I(this, Y), { create: !1, isFile: !0 });\n    return r == null ? new ArrayBuffer(0) : (await r.getFile()).arrayBuffer();\n  }\n  async stream() {\n    const r = await this.getOriginFile();\n    return r == null ? new ReadableStream({\n      pull: (h) => {\n        h.close();\n      }\n    }) : r.stream();\n  }\n  async getOriginFile() {\n    var r;\n    return (r = await ot(I(this, Y), { create: !1, isFile: !0 })) == null ? void 0 : r.getFile();\n  }\n  async getSize() {\n    const r = await ot(I(this, Y), { create: !1, isFile: !0 });\n    return r == null ? 0 : (await r.getFile()).size;\n  }\n  async exists() {\n    return await ot(I(this, Y), {\n      create: !1,\n      isFile: !0\n    }) instanceof FileSystemFileHandle;\n  }\n  async remove() {\n    if (I(this, it)) throw Error(\"exists unclosed reader/writer\");\n    await Ce(I(this, Y));\n  }\n  /**\n   * If the target is a file, use current overwrite the target;\n   * if the target is a folder, copy the current file into that folder.\n   */\n  async copyTo(r) {\n    if (!await this.exists())\n      throw Error(`file ${this.path} not exists`);\n    if (r instanceof Te)\n      return _t(r.path) === this ? this : (await Ct(r.path, this), _t(r.path));\n    if (r instanceof ze)\n      return await this.copyTo(_t(se(r.path, this.name)));\n    throw Error(\"Illegal target type\");\n  }\n  /**\n   * move file, copy then remove current\n   */\n  async moveTo(r) {\n    const h = await this.copyTo(r);\n    return await this.remove(), h;\n  }\n};\nY = /* @__PURE__ */ new WeakMap(), Bt = /* @__PURE__ */ new WeakMap(), Wt = /* @__PURE__ */ new WeakMap(), Ft = /* @__PURE__ */ new WeakMap(), Zt = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakMap(), Xt = /* @__PURE__ */ new WeakMap(), It = /* @__PURE__ */ new WeakMap();\nlet jt = $e;\nconst he = \"/.opfs-tools-temp-dir\";\nasync function Pe(l) {\n  try {\n    if (l.kind === \"file\") {\n      if (!await l.exists()) return !0;\n      const r = await l.createWriter();\n      await r.truncate(0), await r.close(), await l.remove();\n    } else\n      await l.remove();\n    return !0;\n  } catch (r) {\n    return console.warn(r), !1;\n  }\n}\nfunction qe() {\n  setInterval(async () => {\n    for (const l of await vt(he).children()) {\n      const r = /^\\d+-(\\d+)$/.exec(l.name);\n      (r == null || Date.now() - Number(r[1]) > 2592e5) && await Pe(l);\n    }\n  }, 60 * 1e3);\n}\nconst re = [];\nlet me = !1;\nasync function ti() {\n  if (globalThis.localStorage == null) return;\n  const l = \"OPFS_TOOLS_EXPIRES_TMP_FILES\";\n  me || (me = !0, globalThis.addEventListener(\"unload\", () => {\n    re.length !== 0 && localStorage.setItem(\n      l,\n      `${localStorage.getItem(l) ?? \"\"},${re.join(\",\")}`\n    );\n  }));\n  let r = localStorage.getItem(l) ?? \"\";\n  for (const h of r.split(\",\"))\n    h.length !== 0 && await Pe(_t(`${he}/${h}`)) && (r = r.replace(h, \"\"));\n  localStorage.setItem(l, r.replace(/,{2,}/g, \",\"));\n}\n(async function() {\n  var l;\n  globalThis.__opfs_tools_tmpfile_init__ !== !0 && (globalThis.__opfs_tools_tmpfile_init__ = !0, !(globalThis.FileSystemDirectoryHandle == null || globalThis.FileSystemFileHandle == null || ((l = globalThis.navigator) == null ? void 0 : l.storage.getDirectory) == null) && (qe(), await ti()));\n})();\nfunction Kt() {\n  const l = `${Math.random().toString().slice(2)}-${Date.now()}`;\n  return re.push(l), _t(`${he}/${l}`);\n}\nfunction ei(l) {\n  return l instanceof Error ? String(l) : typeof l == \"object\" ? JSON.stringify(l, (r, h) => h instanceof Error ? String(h) : h) : String(l);\n}\nfunction ii() {\n  const l = /* @__PURE__ */ new Date();\n  return `${l.getHours()}:${l.getMinutes()}:${l.getSeconds()}.${l.getMilliseconds()}`;\n}\nlet Le = 1;\nconst ke = Kt();\nlet gt = null;\nconst ve = [\"debug\", \"info\", \"warn\", \"error\"].reduce(\n  (l, r, h) => Object.assign(l, {\n    [r]: (...a) => {\n      Le <= h && (console[r](...a), gt == null || gt.write(\n        `[${r}][${ii()}]  ${a.map((f) => ei(f)).join(\" \")}\n`\n      ));\n    }\n  }),\n  {}\n), Gt = /* @__PURE__ */ new Map(), z = {\n  setLogLevel: (l) => {\n    Le = Gt.get(l) ?? 1;\n  },\n  ...ve,\n  create: (l) => Object.fromEntries(\n    Object.entries(ve).map(([r, h]) => [\n      r,\n      (...a) => h(l, ...a)\n    ])\n  ),\n  async dump() {\n    return await si, await (gt == null ? void 0 : gt.flush()), await ke.text();\n  }\n};\nGt.set(z.debug, 0);\nGt.set(z.info, 1);\nGt.set(z.warn, 2);\nGt.set(z.error, 3);\nasync function ni() {\n  try {\n    gt = await ke.createWriter(), z.info(navigator.userAgent), z.info(\"date: \" + (/* @__PURE__ */ new Date()).toLocaleDateString());\n  } catch (l) {\n    if (!(l instanceof Error)) throw l;\n    if (l.message.includes(\"createSyncAccessHandle is not a function\"))\n      console.warn(l);\n    else\n      throw l;\n  }\n}\nconst si = globalThis.navigator == null ? null : ni(), ri = () => {\n  let l, r = 16.6;\n  self.onmessage = (h) => {\n    h.data.event === \"start\" && (self.clearInterval(l), l = self.setInterval(() => {\n      self.postMessage({});\n    }, r)), h.data.event === \"stop\" && self.clearInterval(l);\n  };\n}, ai = () => {\n  const l = new Blob([`(${ri.toString()})()`]), r = URL.createObjectURL(l);\n  return new Worker(r);\n}, mt = /* @__PURE__ */ new Map();\nlet ae = 1, nt = null;\nglobalThis.Worker != null && (nt = ai(), nt.onmessage = () => {\n  ae += 1;\n  for (const [l, r] of mt)\n    if (ae % l === 0) for (const h of r) h();\n});\nconst De = (l, r) => {\n  const h = Math.round(r / 16.6), a = mt.get(h) ?? /* @__PURE__ */ new Set();\n  return a.add(l), mt.set(h, a), mt.size === 1 && a.size === 1 && (nt == null || nt.postMessage({ event: \"start\" })), () => {\n    a.delete(l), a.size === 0 && mt.delete(h), mt.size === 0 && (ae = 0, nt == null || nt.postMessage({ event: \"stop\" }));\n  };\n};\nclass oi {\n  /**\n   * @param {number} scaleFrom the length of the original array.\n   * @param {number} scaleTo The length of the new array.\n   * @param {?Object} details The extra configuration, if needed.\n   */\n  constructor(r, h, a) {\n    this.length_ = r, this.scaleFactor_ = (r - 1) / h, this.interpolate = this.cubic, a.method === \"point\" ? this.interpolate = this.point : a.method === \"linear\" ? this.interpolate = this.linear : a.method === \"sinc\" && (this.interpolate = this.sinc), this.tangentFactor_ = 1 - Math.max(0, Math.min(1, a.tension || 0)), this.sincFilterSize_ = a.sincFilterSize || 1, this.kernel_ = li(a.sincWindow || hi);\n  }\n  /**\n   * @param {number} t The index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The interpolated value.\n   */\n  point(r, h) {\n    return this.getClippedInput_(Math.round(this.scaleFactor_ * r), h);\n  }\n  /**\n   * @param {number} t The index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The interpolated value.\n   */\n  linear(r, h) {\n    r = this.scaleFactor_ * r;\n    let a = Math.floor(r);\n    return r -= a, (1 - r) * this.getClippedInput_(a, h) + r * this.getClippedInput_(a + 1, h);\n  }\n  /**\n   * @param {number} t The index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The interpolated value.\n   */\n  cubic(r, h) {\n    r = this.scaleFactor_ * r;\n    let a = Math.floor(r), f = [this.getTangent_(a, h), this.getTangent_(a + 1, h)], d = [\n      this.getClippedInput_(a, h),\n      this.getClippedInput_(a + 1, h)\n    ];\n    r -= a;\n    let p = r * r, n = r * p;\n    return (2 * n - 3 * p + 1) * d[0] + (n - 2 * p + r) * f[0] + (-2 * n + 3 * p) * d[1] + (n - p) * f[1];\n  }\n  /**\n   * @param {number} t The index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The interpolated value.\n   */\n  sinc(r, h) {\n    r = this.scaleFactor_ * r;\n    let a = Math.floor(r), f = a - this.sincFilterSize_ + 1, d = a + this.sincFilterSize_, p = 0;\n    for (let n = f; n <= d; n++)\n      p += this.kernel_(r - n) * this.getClippedInput_(n, h);\n    return p;\n  }\n  /**\n   * @param {number} k The scaled index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The tangent.\n   * @private\n   */\n  getTangent_(r, h) {\n    return this.tangentFactor_ * (this.getClippedInput_(r + 1, h) - this.getClippedInput_(r - 1, h)) / 2;\n  }\n  /**\n   * @param {number} t The scaled index to interpolate.\n   * @param {Array|TypedArray} samples the original array.\n   * @return {number} The interpolated value.\n   * @private\n   */\n  getClippedInput_(r, h) {\n    return 0 <= r && r < this.length_ ? h[r] : 0;\n  }\n}\nfunction hi(l) {\n  return Math.exp(-l / 2 * l / 2);\n}\nfunction li(l) {\n  return function(r) {\n    return fi(r) * l(r);\n  };\n}\nfunction fi(l) {\n  return l === 0 ? 1 : Math.sin(Math.PI * l) / (Math.PI * l);\n}\nclass di {\n  /**\n   * @param {number} order The order of the filter.\n   * @param {number} sampleRate The sample rate.\n   * @param {number} cutOff The cut off frequency.\n   */\n  constructor(r, h, a) {\n    let f = 2 * Math.PI * a / h, d = 0;\n    this.filters = [];\n    for (let p = 0; p <= r; p++)\n      p - r / 2 === 0 ? this.filters[p] = f : (this.filters[p] = Math.sin(f * (p - r / 2)) / (p - r / 2), this.filters[p] *= 0.54 - 0.46 * Math.cos(2 * Math.PI * p / r)), d = d + this.filters[p];\n    for (let p = 0; p <= r; p++)\n      this.filters[p] /= d;\n    this.z = this.initZ_();\n  }\n  /**\n   * @param {number} sample A sample of a sequence.\n   * @return {number}\n   */\n  filter(r) {\n    this.z.buf[this.z.pointer] = r;\n    let h = 0;\n    for (let a = 0, f = this.z.buf.length; a < f; a++)\n      h += this.filters[a] * this.z.buf[(this.z.pointer + a) % this.z.buf.length];\n    return this.z.pointer = (this.z.pointer + 1) % this.z.buf.length, h;\n  }\n  /**\n   * Reset the filter.\n   */\n  reset() {\n    this.z = this.initZ_();\n  }\n  /**\n   * Return the default value for z.\n   * @private\n   */\n  initZ_() {\n    let r = [];\n    for (let h = 0; h < this.filters.length - 1; h++)\n      r.push(0);\n    return {\n      buf: r,\n      pointer: 0\n    };\n  }\n}\nclass ci {\n  /**\n   * @param {number} order The order of the filter.\n   * @param {number} sampleRate The sample rate.\n   * @param {number} cutOff The cut off frequency.\n   */\n  constructor(r, h, a) {\n    let f = [];\n    for (let d = 0; d < r; d++)\n      f.push(this.getCoeffs_({\n        Fs: h,\n        Fc: a,\n        Q: 0.5 / Math.sin(Math.PI / (r * 2) * (d + 0.5))\n      }));\n    this.stages = [];\n    for (let d = 0; d < f.length; d++)\n      this.stages[d] = {\n        b0: f[d].b[0],\n        b1: f[d].b[1],\n        b2: f[d].b[2],\n        a1: f[d].a[0],\n        a2: f[d].a[1],\n        k: f[d].k,\n        z: [0, 0]\n      };\n  }\n  /**\n   * @param {number} sample A sample of a sequence.\n   * @return {number}\n   */\n  filter(r) {\n    let h = r;\n    for (let a = 0, f = this.stages.length; a < f; a++)\n      h = this.runStage_(a, h);\n    return h;\n  }\n  getCoeffs_(r) {\n    let h = {};\n    h.z = [0, 0], h.a = [], h.b = [];\n    let a = this.preCalc_(r, h);\n    return h.k = 1, h.b.push((1 - a.cw) / (2 * a.a0)), h.b.push(2 * h.b[0]), h.b.push(h.b[0]), h;\n  }\n  preCalc_(r, h) {\n    let a = {}, f = 2 * Math.PI * r.Fc / r.Fs;\n    return a.alpha = Math.sin(f) / (2 * r.Q), a.cw = Math.cos(f), a.a0 = 1 + a.alpha, h.a0 = a.a0, h.a.push(-2 * a.cw / a.a0), h.k = 1, h.a.push((1 - a.alpha) / a.a0), a;\n  }\n  runStage_(r, h) {\n    let a = h * this.stages[r].k - this.stages[r].a1 * this.stages[r].z[0] - this.stages[r].a2 * this.stages[r].z[1], f = this.stages[r].b0 * a + this.stages[r].b1 * this.stages[r].z[0] + this.stages[r].b2 * this.stages[r].z[1];\n    return this.stages[r].z[1] = this.stages[r].z[0], this.stages[r].z[0] = a, f;\n  }\n  /**\n   * Reset the filter.\n   */\n  reset() {\n    for (let r = 0; r < this.stages.length; r++)\n      this.stages[r].z = [0, 0];\n  }\n}\nconst ui = {\n  point: !1,\n  linear: !1,\n  cubic: !0,\n  sinc: !0\n}, we = {\n  IIR: 16,\n  FIR: 71\n}, pi = {\n  IIR: ci,\n  FIR: di\n};\nfunction _i(l, r, h, a = {}) {\n  let f = (h - r) / r + 1, d = new Float64Array(l.length * f);\n  a.method = a.method || \"cubic\";\n  let p = new oi(\n    l.length,\n    d.length,\n    {\n      method: a.method,\n      tension: a.tension || 0,\n      sincFilterSize: a.sincFilterSize || 6,\n      sincWindow: a.sincWindow || void 0\n    }\n  );\n  if (a.LPF === void 0 && (a.LPF = ui[a.method]), a.LPF) {\n    a.LPFType = a.LPFType || \"IIR\";\n    const n = pi[a.LPFType];\n    if (h > r) {\n      let v = new n(\n        a.LPFOrder || we[a.LPFType],\n        h,\n        r / 2\n      );\n      gi(\n        l,\n        d,\n        p,\n        v\n      );\n    } else {\n      let v = new n(\n        a.LPFOrder || we[a.LPFType],\n        r,\n        h / 2\n      );\n      yi(\n        l,\n        d,\n        p,\n        v\n      );\n    }\n  } else\n    Re(l, d, p);\n  return d;\n}\nfunction Re(l, r, h) {\n  for (let a = 0, f = r.length; a < f; a++)\n    r[a] = h.interpolate(a, l);\n}\nfunction gi(l, r, h, a) {\n  for (let f = 0, d = r.length; f < d; f++)\n    r[f] = a.filter(h.interpolate(f, l));\n  a.reset();\n  for (let f = r.length - 1; f >= 0; f--)\n    r[f] = a.filter(r[f]);\n}\nfunction yi(l, r, h, a) {\n  for (let f = 0, d = l.length; f < d; f++)\n    l[f] = a.filter(l[f]);\n  a.reset();\n  for (let f = l.length - 1; f >= 0; f--)\n    l[f] = a.filter(l[f]);\n  Re(l, r, h);\n}\nfunction Me(l) {\n  const r = new Float32Array(\n    l.map((a) => a.length).reduce((a, f) => a + f)\n  );\n  let h = 0;\n  for (const a of l)\n    r.set(a, h), h += a.length;\n  return r;\n}\nfunction mi(l) {\n  const r = [];\n  for (let h = 0; h < l.length; h += 1)\n    for (let a = 0; a < l[h].length; a += 1)\n      r[a] == null && (r[a] = []), r[a].push(l[h][a]);\n  return r.map(Me);\n}\nfunction le(l) {\n  if (l.format === \"f32-planar\") {\n    const r = [];\n    for (let h = 0; h < l.numberOfChannels; h += 1) {\n      const a = l.allocationSize({ planeIndex: h }), f = new ArrayBuffer(a);\n      l.copyTo(f, { planeIndex: h }), r.push(new Float32Array(f));\n    }\n    return r;\n  } else if (l.format === \"f32\") {\n    const r = new ArrayBuffer(l.allocationSize({ planeIndex: 0 }));\n    return l.copyTo(r, { planeIndex: 0 }), wi(new Float32Array(r), l.numberOfChannels);\n  } else if (l.format === \"s16\") {\n    const r = new ArrayBuffer(l.allocationSize({ planeIndex: 0 }));\n    return l.copyTo(r, { planeIndex: 0 }), vi(new Int16Array(r), l.numberOfChannels);\n  }\n  throw Error(\"Unsupported audio data format\");\n}\nfunction vi(l, r) {\n  const h = l.length / r, a = Array.from(\n    { length: r },\n    () => new Float32Array(h)\n  );\n  for (let f = 0; f < h; f++)\n    for (let d = 0; d < r; d++) {\n      const p = l[f * r + d];\n      a[d][f] = p / 32768;\n    }\n  return a;\n}\nfunction wi(l, r) {\n  const h = l.length / r, a = Array.from(\n    { length: r },\n    () => new Float32Array(h)\n  );\n  for (let f = 0; f < h; f++)\n    for (let d = 0; d < r; d++)\n      a[d][f] = l[f * r + d];\n  return a;\n}\nfunction Oe(l) {\n  return Array(l.numberOfChannels).fill(0).map((r, h) => l.getChannelData(h));\n}\nfunction en(l, r) {\n  const h = new Float32Array(\n    Me(le(l))\n  ).map((f) => f * r), a = new AudioData({\n    sampleRate: l.sampleRate,\n    numberOfChannels: l.numberOfChannels,\n    timestamp: l.timestamp,\n    format: l.format,\n    numberOfFrames: l.numberOfFrames,\n    data: h\n  });\n  return l.close(), a;\n}\nasync function nn(l, r) {\n  var p;\n  const h = {\n    type: r,\n    data: l\n  }, a = new ImageDecoder(h);\n  await Promise.all([a.completed, a.tracks.ready]);\n  let f = ((p = a.tracks.selectedTrack) == null ? void 0 : p.frameCount) ?? 1;\n  const d = [];\n  for (let n = 0; n < f; n += 1)\n    d.push((await a.decode({ frameIndex: n })).image);\n  return d;\n}\nfunction be(l) {\n  var a, f;\n  const r = Math.max(...l.map((d) => {\n    var p;\n    return ((p = d[0]) == null ? void 0 : p.length) ?? 0;\n  })), h = new Float32Array(r * 2);\n  for (let d = 0; d < r; d++) {\n    let p = 0, n = 0;\n    for (let v = 0; v < l.length; v++) {\n      const b = ((a = l[v][0]) == null ? void 0 : a[d]) ?? 0, y = ((f = l[v][1]) == null ? void 0 : f[d]) ?? b;\n      p += b, n += y;\n    }\n    h[d] = p, h[d + r] = n;\n  }\n  return h;\n}\nasync function bi(l, r, h) {\n  const a = l.length, f = Array(h.chanCount).fill(0).map(() => new Float32Array(0));\n  if (a === 0) return f;\n  const d = Math.max(...l.map((b) => b.length));\n  if (d === 0) return f;\n  if (globalThis.OfflineAudioContext == null)\n    return l.map(\n      (b) => new Float32Array(\n        _i(b, r, h.rate, { method: \"sinc\", LPF: !1 })\n      )\n    );\n  const p = new globalThis.OfflineAudioContext(\n    h.chanCount,\n    d * h.rate / r,\n    h.rate\n  ), n = p.createBufferSource(), v = p.createBuffer(a, d, r);\n  return l.forEach((b, y) => v.copyToChannel(b, y)), n.buffer = v, n.connect(p.destination), n.start(), Oe(await p.startRendering());\n}\nfunction Ne(l) {\n  return new Promise((r) => {\n    const h = De(() => {\n      h(), r();\n    }, l);\n  });\n}\nfunction Si(l, r, h) {\n  const a = h - r, f = new Float32Array(a);\n  let d = 0;\n  for (; d < a; )\n    f[d] = l[(r + d) % l.length], d += 1;\n  return f;\n}\nfunction fe(l, r) {\n  let h = !1;\n  async function a() {\n    const f = l.getReader();\n    for (; !h; ) {\n      const { value: d, done: p } = await f.read();\n      if (p) {\n        r.onDone();\n        return;\n      }\n      await r.onChunk(d);\n    }\n    f.releaseLock(), await l.cancel();\n  }\n  return a().catch(z.error), () => {\n    h = !0;\n  };\n}\nfunction xi(l) {\n  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, \"default\") ? l.default : l;\n}\nvar Ge = {};\n(function(l) {\n  var r = /* @__PURE__ */ function() {\n    var t = /* @__PURE__ */ new Date(), e = 4, i = 3, s = 2, o = 1, c = e, u = {\n      setLogLevel: function(_) {\n        _ == this.debug ? c = o : _ == this.info ? c = s : _ == this.warn ? c = i : (_ == this.error, c = e);\n      },\n      debug: function(_, g) {\n        console.debug === void 0 && (console.debug = console.log), o >= c && console.debug(\"[\" + r.getDurationString(/* @__PURE__ */ new Date() - t, 1e3) + \"]\", \"[\" + _ + \"]\", g);\n      },\n      log: function(_, g) {\n        this.debug(_.msg);\n      },\n      info: function(_, g) {\n        s >= c && console.info(\"[\" + r.getDurationString(/* @__PURE__ */ new Date() - t, 1e3) + \"]\", \"[\" + _ + \"]\", g);\n      },\n      warn: function(_, g) {\n        i >= c && console.warn(\"[\" + r.getDurationString(/* @__PURE__ */ new Date() - t, 1e3) + \"]\", \"[\" + _ + \"]\", g);\n      },\n      error: function(_, g) {\n        e >= c && console.error(\"[\" + r.getDurationString(/* @__PURE__ */ new Date() - t, 1e3) + \"]\", \"[\" + _ + \"]\", g);\n      }\n    };\n    return u;\n  }();\n  r.getDurationString = function(t, e) {\n    var i;\n    function s(w, S) {\n      for (var U = \"\" + w, C = U.split(\".\"); C[0].length < S; )\n        C[0] = \"0\" + C[0];\n      return C.join(\".\");\n    }\n    t < 0 ? (i = !0, t = -t) : i = !1;\n    var o = e || 1, c = t / o, u = Math.floor(c / 3600);\n    c -= u * 3600;\n    var _ = Math.floor(c / 60);\n    c -= _ * 60;\n    var g = c * 1e3;\n    return c = Math.floor(c), g -= c * 1e3, g = Math.floor(g), (i ? \"-\" : \"\") + u + \":\" + s(_, 2) + \":\" + s(c, 2) + \".\" + s(g, 3);\n  }, r.printRanges = function(t) {\n    var e = t.length;\n    if (e > 0) {\n      for (var i = \"\", s = 0; s < e; s++)\n        s > 0 && (i += \",\"), i += \"[\" + r.getDurationString(t.start(s)) + \",\" + r.getDurationString(t.end(s)) + \"]\";\n      return i;\n    } else\n      return \"(empty)\";\n  }, l.Log = r;\n  var h = function(t) {\n    if (t instanceof ArrayBuffer)\n      this.buffer = t, this.dataview = new DataView(t);\n    else\n      throw \"Needs an array buffer\";\n    this.position = 0;\n  };\n  h.prototype.getPosition = function() {\n    return this.position;\n  }, h.prototype.getEndPosition = function() {\n    return this.buffer.byteLength;\n  }, h.prototype.getLength = function() {\n    return this.buffer.byteLength;\n  }, h.prototype.seek = function(t) {\n    var e = Math.max(0, Math.min(this.buffer.byteLength, t));\n    return this.position = isNaN(e) || !isFinite(e) ? 0 : e, !0;\n  }, h.prototype.isEos = function() {\n    return this.getPosition() >= this.getEndPosition();\n  }, h.prototype.readAnyInt = function(t, e) {\n    var i = 0;\n    if (this.position + t <= this.buffer.byteLength) {\n      switch (t) {\n        case 1:\n          e ? i = this.dataview.getInt8(this.position) : i = this.dataview.getUint8(this.position);\n          break;\n        case 2:\n          e ? i = this.dataview.getInt16(this.position) : i = this.dataview.getUint16(this.position);\n          break;\n        case 3:\n          if (e)\n            throw \"No method for reading signed 24 bits values\";\n          i = this.dataview.getUint8(this.position) << 16, i |= this.dataview.getUint8(this.position + 1) << 8, i |= this.dataview.getUint8(this.position + 2);\n          break;\n        case 4:\n          e ? i = this.dataview.getInt32(this.position) : i = this.dataview.getUint32(this.position);\n          break;\n        case 8:\n          if (e)\n            throw \"No method for reading signed 64 bits values\";\n          i = this.dataview.getUint32(this.position) << 32, i |= this.dataview.getUint32(this.position + 4);\n          break;\n        default:\n          throw \"readInt method not implemented for size: \" + t;\n      }\n      return this.position += t, i;\n    } else\n      throw \"Not enough bytes in buffer\";\n  }, h.prototype.readUint8 = function() {\n    return this.readAnyInt(1, !1);\n  }, h.prototype.readUint16 = function() {\n    return this.readAnyInt(2, !1);\n  }, h.prototype.readUint24 = function() {\n    return this.readAnyInt(3, !1);\n  }, h.prototype.readUint32 = function() {\n    return this.readAnyInt(4, !1);\n  }, h.prototype.readUint64 = function() {\n    return this.readAnyInt(8, !1);\n  }, h.prototype.readString = function(t) {\n    if (this.position + t <= this.buffer.byteLength) {\n      for (var e = \"\", i = 0; i < t; i++)\n        e += String.fromCharCode(this.readUint8());\n      return e;\n    } else\n      throw \"Not enough bytes in buffer\";\n  }, h.prototype.readCString = function() {\n    for (var t = []; ; ) {\n      var e = this.readUint8();\n      if (e !== 0)\n        t.push(e);\n      else\n        break;\n    }\n    return String.fromCharCode.apply(null, t);\n  }, h.prototype.readInt8 = function() {\n    return this.readAnyInt(1, !0);\n  }, h.prototype.readInt16 = function() {\n    return this.readAnyInt(2, !0);\n  }, h.prototype.readInt32 = function() {\n    return this.readAnyInt(4, !0);\n  }, h.prototype.readInt64 = function() {\n    return this.readAnyInt(8, !1);\n  }, h.prototype.readUint8Array = function(t) {\n    for (var e = new Uint8Array(t), i = 0; i < t; i++)\n      e[i] = this.readUint8();\n    return e;\n  }, h.prototype.readInt16Array = function(t) {\n    for (var e = new Int16Array(t), i = 0; i < t; i++)\n      e[i] = this.readInt16();\n    return e;\n  }, h.prototype.readUint16Array = function(t) {\n    for (var e = new Int16Array(t), i = 0; i < t; i++)\n      e[i] = this.readUint16();\n    return e;\n  }, h.prototype.readUint32Array = function(t) {\n    for (var e = new Uint32Array(t), i = 0; i < t; i++)\n      e[i] = this.readUint32();\n    return e;\n  }, h.prototype.readInt32Array = function(t) {\n    for (var e = new Int32Array(t), i = 0; i < t; i++)\n      e[i] = this.readInt32();\n    return e;\n  }, l.MP4BoxStream = h;\n  var a = function(t, e, i) {\n    this._byteOffset = e || 0, t instanceof ArrayBuffer ? this.buffer = t : typeof t == \"object\" ? (this.dataView = t, e && (this._byteOffset += e)) : this.buffer = new ArrayBuffer(t || 0), this.position = 0, this.endianness = i ?? a.LITTLE_ENDIAN;\n  };\n  a.prototype = {}, a.prototype.getPosition = function() {\n    return this.position;\n  }, a.prototype._realloc = function(t) {\n    if (this._dynamicSize) {\n      var e = this._byteOffset + this.position + t, i = this._buffer.byteLength;\n      if (e <= i) {\n        e > this._byteLength && (this._byteLength = e);\n        return;\n      }\n      for (i < 1 && (i = 1); e > i; )\n        i *= 2;\n      var s = new ArrayBuffer(i), o = new Uint8Array(this._buffer), c = new Uint8Array(s, 0, o.length);\n      c.set(o), this.buffer = s, this._byteLength = e;\n    }\n  }, a.prototype._trimAlloc = function() {\n    if (this._byteLength != this._buffer.byteLength) {\n      var t = new ArrayBuffer(this._byteLength), e = new Uint8Array(t), i = new Uint8Array(this._buffer, 0, e.length);\n      e.set(i), this.buffer = t;\n    }\n  }, a.BIG_ENDIAN = !1, a.LITTLE_ENDIAN = !0, a.prototype._byteLength = 0, Object.defineProperty(\n    a.prototype,\n    \"byteLength\",\n    { get: function() {\n      return this._byteLength - this._byteOffset;\n    } }\n  ), Object.defineProperty(\n    a.prototype,\n    \"buffer\",\n    {\n      get: function() {\n        return this._trimAlloc(), this._buffer;\n      },\n      set: function(t) {\n        this._buffer = t, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength;\n      }\n    }\n  ), Object.defineProperty(\n    a.prototype,\n    \"byteOffset\",\n    {\n      get: function() {\n        return this._byteOffset;\n      },\n      set: function(t) {\n        this._byteOffset = t, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength;\n      }\n    }\n  ), Object.defineProperty(\n    a.prototype,\n    \"dataView\",\n    {\n      get: function() {\n        return this._dataView;\n      },\n      set: function(t) {\n        this._byteOffset = t.byteOffset, this._buffer = t.buffer, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._byteOffset + t.byteLength;\n      }\n    }\n  ), a.prototype.seek = function(t) {\n    var e = Math.max(0, Math.min(this.byteLength, t));\n    this.position = isNaN(e) || !isFinite(e) ? 0 : e;\n  }, a.prototype.isEof = function() {\n    return this.position >= this._byteLength;\n  }, a.prototype.mapUint8Array = function(t) {\n    this._realloc(t * 1);\n    var e = new Uint8Array(this._buffer, this.byteOffset + this.position, t);\n    return this.position += t * 1, e;\n  }, a.prototype.readInt32Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 4;\n    var i = new Int32Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readInt16Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 2;\n    var i = new Int16Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readInt8Array = function(t) {\n    t = t ?? this.byteLength - this.position;\n    var e = new Int8Array(t);\n    return a.memcpy(\n      e.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * e.BYTES_PER_ELEMENT\n    ), this.position += e.byteLength, e;\n  }, a.prototype.readUint32Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 4;\n    var i = new Uint32Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readUint16Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 2;\n    var i = new Uint16Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readUint8Array = function(t) {\n    t = t ?? this.byteLength - this.position;\n    var e = new Uint8Array(t);\n    return a.memcpy(\n      e.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * e.BYTES_PER_ELEMENT\n    ), this.position += e.byteLength, e;\n  }, a.prototype.readFloat64Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 8;\n    var i = new Float64Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readFloat32Array = function(t, e) {\n    t = t ?? this.byteLength - this.position / 4;\n    var i = new Float32Array(t);\n    return a.memcpy(\n      i.buffer,\n      0,\n      this.buffer,\n      this.byteOffset + this.position,\n      t * i.BYTES_PER_ELEMENT\n    ), a.arrayToNative(i, e ?? this.endianness), this.position += i.byteLength, i;\n  }, a.prototype.readInt32 = function(t) {\n    var e = this._dataView.getInt32(this.position, t ?? this.endianness);\n    return this.position += 4, e;\n  }, a.prototype.readInt16 = function(t) {\n    var e = this._dataView.getInt16(this.position, t ?? this.endianness);\n    return this.position += 2, e;\n  }, a.prototype.readInt8 = function() {\n    var t = this._dataView.getInt8(this.position);\n    return this.position += 1, t;\n  }, a.prototype.readUint32 = function(t) {\n    var e = this._dataView.getUint32(this.position, t ?? this.endianness);\n    return this.position += 4, e;\n  }, a.prototype.readUint16 = function(t) {\n    var e = this._dataView.getUint16(this.position, t ?? this.endianness);\n    return this.position += 2, e;\n  }, a.prototype.readUint8 = function() {\n    var t = this._dataView.getUint8(this.position);\n    return this.position += 1, t;\n  }, a.prototype.readFloat32 = function(t) {\n    var e = this._dataView.getFloat32(this.position, t ?? this.endianness);\n    return this.position += 4, e;\n  }, a.prototype.readFloat64 = function(t) {\n    var e = this._dataView.getFloat64(this.position, t ?? this.endianness);\n    return this.position += 8, e;\n  }, a.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0, a.memcpy = function(t, e, i, s, o) {\n    var c = new Uint8Array(t, e, o), u = new Uint8Array(i, s, o);\n    c.set(u);\n  }, a.arrayToNative = function(t, e) {\n    return e == this.endianness ? t : this.flipArrayEndianness(t);\n  }, a.nativeToEndian = function(t, e) {\n    return this.endianness == e ? t : this.flipArrayEndianness(t);\n  }, a.flipArrayEndianness = function(t) {\n    for (var e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength), i = 0; i < t.byteLength; i += t.BYTES_PER_ELEMENT)\n      for (var s = i + t.BYTES_PER_ELEMENT - 1, o = i; s > o; s--, o++) {\n        var c = e[o];\n        e[o] = e[s], e[s] = c;\n      }\n    return t;\n  }, a.prototype.failurePosition = 0, String.fromCharCodeUint8 = function(t) {\n    for (var e = [], i = 0; i < t.length; i++)\n      e[i] = t[i];\n    return String.fromCharCode.apply(null, e);\n  }, a.prototype.readString = function(t, e) {\n    return e == null || e == \"ASCII\" ? String.fromCharCodeUint8.apply(null, [this.mapUint8Array(t ?? this.byteLength - this.position)]) : new TextDecoder(e).decode(this.mapUint8Array(t));\n  }, a.prototype.readCString = function(t) {\n    var e = this.byteLength - this.position, i = new Uint8Array(this._buffer, this._byteOffset + this.position), s = e;\n    t != null && (s = Math.min(t, e));\n    for (var o = 0; o < s && i[o] !== 0; o++) ;\n    var c = String.fromCharCodeUint8.apply(null, [this.mapUint8Array(o)]);\n    return t != null ? this.position += s - o : o != e && (this.position += 1), c;\n  };\n  var f = Math.pow(2, 32);\n  a.prototype.readInt64 = function() {\n    return this.readInt32() * f + this.readUint32();\n  }, a.prototype.readUint64 = function() {\n    return this.readUint32() * f + this.readUint32();\n  }, a.prototype.readInt64 = function() {\n    return this.readUint32() * f + this.readUint32();\n  }, a.prototype.readUint24 = function() {\n    return (this.readUint8() << 16) + (this.readUint8() << 8) + this.readUint8();\n  }, l.DataStream = a, a.prototype.save = function(t) {\n    var e = new Blob([this.buffer]);\n    if (window.URL && URL.createObjectURL) {\n      var i = window.URL.createObjectURL(e), s = document.createElement(\"a\");\n      document.body.appendChild(s), s.setAttribute(\"href\", i), s.setAttribute(\"download\", t), s.setAttribute(\"target\", \"_self\"), s.click(), window.URL.revokeObjectURL(i);\n    } else\n      throw \"DataStream.save: Can't create object URL.\";\n  }, a.prototype._dynamicSize = !0, Object.defineProperty(\n    a.prototype,\n    \"dynamicSize\",\n    {\n      get: function() {\n        return this._dynamicSize;\n      },\n      set: function(t) {\n        t || this._trimAlloc(), this._dynamicSize = t;\n      }\n    }\n  ), a.prototype.shift = function(t) {\n    var e = new ArrayBuffer(this._byteLength - t), i = new Uint8Array(e), s = new Uint8Array(this._buffer, t, i.length);\n    i.set(s), this.buffer = e, this.position -= t;\n  }, a.prototype.writeInt32Array = function(t, e) {\n    if (this._realloc(t.length * 4), t instanceof Int32Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapInt32Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeInt32(t[i], e);\n  }, a.prototype.writeInt16Array = function(t, e) {\n    if (this._realloc(t.length * 2), t instanceof Int16Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapInt16Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeInt16(t[i], e);\n  }, a.prototype.writeInt8Array = function(t) {\n    if (this._realloc(t.length * 1), t instanceof Int8Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapInt8Array(t.length);\n    else\n      for (var e = 0; e < t.length; e++)\n        this.writeInt8(t[e]);\n  }, a.prototype.writeUint32Array = function(t, e) {\n    if (this._realloc(t.length * 4), t instanceof Uint32Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapUint32Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeUint32(t[i], e);\n  }, a.prototype.writeUint16Array = function(t, e) {\n    if (this._realloc(t.length * 2), t instanceof Uint16Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapUint16Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeUint16(t[i], e);\n  }, a.prototype.writeUint8Array = function(t) {\n    if (this._realloc(t.length * 1), t instanceof Uint8Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapUint8Array(t.length);\n    else\n      for (var e = 0; e < t.length; e++)\n        this.writeUint8(t[e]);\n  }, a.prototype.writeFloat64Array = function(t, e) {\n    if (this._realloc(t.length * 8), t instanceof Float64Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapFloat64Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeFloat64(t[i], e);\n  }, a.prototype.writeFloat32Array = function(t, e) {\n    if (this._realloc(t.length * 4), t instanceof Float32Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0)\n      a.memcpy(\n        this._buffer,\n        this.byteOffset + this.position,\n        t.buffer,\n        0,\n        t.byteLength\n      ), this.mapFloat32Array(t.length, e);\n    else\n      for (var i = 0; i < t.length; i++)\n        this.writeFloat32(t[i], e);\n  }, a.prototype.writeInt32 = function(t, e) {\n    this._realloc(4), this._dataView.setInt32(this.position, t, e ?? this.endianness), this.position += 4;\n  }, a.prototype.writeInt16 = function(t, e) {\n    this._realloc(2), this._dataView.setInt16(this.position, t, e ?? this.endianness), this.position += 2;\n  }, a.prototype.writeInt8 = function(t) {\n    this._realloc(1), this._dataView.setInt8(this.position, t), this.position += 1;\n  }, a.prototype.writeUint32 = function(t, e) {\n    this._realloc(4), this._dataView.setUint32(this.position, t, e ?? this.endianness), this.position += 4;\n  }, a.prototype.writeUint16 = function(t, e) {\n    this._realloc(2), this._dataView.setUint16(this.position, t, e ?? this.endianness), this.position += 2;\n  }, a.prototype.writeUint8 = function(t) {\n    this._realloc(1), this._dataView.setUint8(this.position, t), this.position += 1;\n  }, a.prototype.writeFloat32 = function(t, e) {\n    this._realloc(4), this._dataView.setFloat32(this.position, t, e ?? this.endianness), this.position += 4;\n  }, a.prototype.writeFloat64 = function(t, e) {\n    this._realloc(8), this._dataView.setFloat64(this.position, t, e ?? this.endianness), this.position += 8;\n  }, a.prototype.writeUCS2String = function(t, e, i) {\n    i == null && (i = t.length);\n    for (var s = 0; s < t.length && s < i; s++)\n      this.writeUint16(t.charCodeAt(s), e);\n    for (; s < i; s++)\n      this.writeUint16(0);\n  }, a.prototype.writeString = function(t, e, i) {\n    var s = 0;\n    if (e == null || e == \"ASCII\")\n      if (i != null) {\n        var o = Math.min(t.length, i);\n        for (s = 0; s < o; s++)\n          this.writeUint8(t.charCodeAt(s));\n        for (; s < i; s++)\n          this.writeUint8(0);\n      } else\n        for (s = 0; s < t.length; s++)\n          this.writeUint8(t.charCodeAt(s));\n    else\n      this.writeUint8Array(new TextEncoder(e).encode(t.substring(0, i)));\n  }, a.prototype.writeCString = function(t, e) {\n    var i = 0;\n    if (e != null) {\n      var s = Math.min(t.length, e);\n      for (i = 0; i < s; i++)\n        this.writeUint8(t.charCodeAt(i));\n      for (; i < e; i++)\n        this.writeUint8(0);\n    } else {\n      for (i = 0; i < t.length; i++)\n        this.writeUint8(t.charCodeAt(i));\n      this.writeUint8(0);\n    }\n  }, a.prototype.writeStruct = function(t, e) {\n    for (var i = 0; i < t.length; i += 2) {\n      var s = t[i + 1];\n      this.writeType(s, e[t[i]], e);\n    }\n  }, a.prototype.writeType = function(t, e, i) {\n    var s;\n    if (typeof t == \"function\")\n      return t(this, e);\n    if (typeof t == \"object\" && !(t instanceof Array))\n      return t.set(this, e, i);\n    var o = null, c = \"ASCII\", u = this.position;\n    switch (typeof t == \"string\" && /:/.test(t) && (s = t.split(\":\"), t = s[0], o = parseInt(s[1])), typeof t == \"string\" && /,/.test(t) && (s = t.split(\",\"), t = s[0], c = parseInt(s[1])), t) {\n      case \"uint8\":\n        this.writeUint8(e);\n        break;\n      case \"int8\":\n        this.writeInt8(e);\n        break;\n      case \"uint16\":\n        this.writeUint16(e, this.endianness);\n        break;\n      case \"int16\":\n        this.writeInt16(e, this.endianness);\n        break;\n      case \"uint32\":\n        this.writeUint32(e, this.endianness);\n        break;\n      case \"int32\":\n        this.writeInt32(e, this.endianness);\n        break;\n      case \"float32\":\n        this.writeFloat32(e, this.endianness);\n        break;\n      case \"float64\":\n        this.writeFloat64(e, this.endianness);\n        break;\n      case \"uint16be\":\n        this.writeUint16(e, a.BIG_ENDIAN);\n        break;\n      case \"int16be\":\n        this.writeInt16(e, a.BIG_ENDIAN);\n        break;\n      case \"uint32be\":\n        this.writeUint32(e, a.BIG_ENDIAN);\n        break;\n      case \"int32be\":\n        this.writeInt32(e, a.BIG_ENDIAN);\n        break;\n      case \"float32be\":\n        this.writeFloat32(e, a.BIG_ENDIAN);\n        break;\n      case \"float64be\":\n        this.writeFloat64(e, a.BIG_ENDIAN);\n        break;\n      case \"uint16le\":\n        this.writeUint16(e, a.LITTLE_ENDIAN);\n        break;\n      case \"int16le\":\n        this.writeInt16(e, a.LITTLE_ENDIAN);\n        break;\n      case \"uint32le\":\n        this.writeUint32(e, a.LITTLE_ENDIAN);\n        break;\n      case \"int32le\":\n        this.writeInt32(e, a.LITTLE_ENDIAN);\n        break;\n      case \"float32le\":\n        this.writeFloat32(e, a.LITTLE_ENDIAN);\n        break;\n      case \"float64le\":\n        this.writeFloat64(e, a.LITTLE_ENDIAN);\n        break;\n      case \"cstring\":\n        this.writeCString(e, o);\n        break;\n      case \"string\":\n        this.writeString(e, c, o);\n        break;\n      case \"u16string\":\n        this.writeUCS2String(e, this.endianness, o);\n        break;\n      case \"u16stringle\":\n        this.writeUCS2String(e, a.LITTLE_ENDIAN, o);\n        break;\n      case \"u16stringbe\":\n        this.writeUCS2String(e, a.BIG_ENDIAN, o);\n        break;\n      default:\n        if (t.length == 3) {\n          for (var _ = t[1], g = 0; g < e.length; g++)\n            this.writeType(_, e[g]);\n          break;\n        } else {\n          this.writeStruct(t, e);\n          break;\n        }\n    }\n    o != null && (this.position = u, this._realloc(o), this.position = u + o);\n  }, a.prototype.writeUint64 = function(t) {\n    var e = Math.floor(t / f);\n    this.writeUint32(e), this.writeUint32(t & 4294967295);\n  }, a.prototype.writeUint24 = function(t) {\n    this.writeUint8((t & 16711680) >> 16), this.writeUint8((t & 65280) >> 8), this.writeUint8(t & 255);\n  }, a.prototype.adjustUint32 = function(t, e) {\n    var i = this.position;\n    this.seek(t), this.writeUint32(e), this.seek(i);\n  }, a.prototype.mapInt32Array = function(t, e) {\n    this._realloc(t * 4);\n    var i = new Int32Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 4, i;\n  }, a.prototype.mapInt16Array = function(t, e) {\n    this._realloc(t * 2);\n    var i = new Int16Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 2, i;\n  }, a.prototype.mapInt8Array = function(t) {\n    this._realloc(t * 1);\n    var e = new Int8Array(this._buffer, this.byteOffset + this.position, t);\n    return this.position += t * 1, e;\n  }, a.prototype.mapUint32Array = function(t, e) {\n    this._realloc(t * 4);\n    var i = new Uint32Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 4, i;\n  }, a.prototype.mapUint16Array = function(t, e) {\n    this._realloc(t * 2);\n    var i = new Uint16Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 2, i;\n  }, a.prototype.mapFloat64Array = function(t, e) {\n    this._realloc(t * 8);\n    var i = new Float64Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 8, i;\n  }, a.prototype.mapFloat32Array = function(t, e) {\n    this._realloc(t * 4);\n    var i = new Float32Array(this._buffer, this.byteOffset + this.position, t);\n    return a.arrayToNative(i, e ?? this.endianness), this.position += t * 4, i;\n  };\n  var d = function(t) {\n    this.buffers = [], this.bufferIndex = -1, t && (this.insertBuffer(t), this.bufferIndex = 0);\n  };\n  d.prototype = new a(new ArrayBuffer(), 0, a.BIG_ENDIAN), d.prototype.initialized = function() {\n    var t;\n    return this.bufferIndex > -1 ? !0 : this.buffers.length > 0 ? (t = this.buffers[0], t.fileStart === 0 ? (this.buffer = t, this.bufferIndex = 0, r.debug(\"MultiBufferStream\", \"Stream ready for parsing\"), !0) : (r.warn(\"MultiBufferStream\", \"The first buffer should have a fileStart of 0\"), this.logBufferLevel(), !1)) : (r.warn(\"MultiBufferStream\", \"No buffer to start parsing from\"), this.logBufferLevel(), !1);\n  }, ArrayBuffer.concat = function(t, e) {\n    r.debug(\"ArrayBuffer\", \"Trying to create a new buffer of size: \" + (t.byteLength + e.byteLength));\n    var i = new Uint8Array(t.byteLength + e.byteLength);\n    return i.set(new Uint8Array(t), 0), i.set(new Uint8Array(e), t.byteLength), i.buffer;\n  }, d.prototype.reduceBuffer = function(t, e, i) {\n    var s;\n    return s = new Uint8Array(i), s.set(new Uint8Array(t, e, i)), s.buffer.fileStart = t.fileStart + e, s.buffer.usedBytes = 0, s.buffer;\n  }, d.prototype.insertBuffer = function(t) {\n    for (var e = !0, i = 0; i < this.buffers.length; i++) {\n      var s = this.buffers[i];\n      if (t.fileStart <= s.fileStart) {\n        if (t.fileStart === s.fileStart)\n          if (t.byteLength > s.byteLength) {\n            this.buffers.splice(i, 1), i--;\n            continue;\n          } else\n            r.warn(\"MultiBufferStream\", \"Buffer (fileStart: \" + t.fileStart + \" - Length: \" + t.byteLength + \") already appended, ignoring\");\n        else\n          t.fileStart + t.byteLength <= s.fileStart || (t = this.reduceBuffer(t, 0, s.fileStart - t.fileStart)), r.debug(\"MultiBufferStream\", \"Appending new buffer (fileStart: \" + t.fileStart + \" - Length: \" + t.byteLength + \")\"), this.buffers.splice(i, 0, t), i === 0 && (this.buffer = t);\n        e = !1;\n        break;\n      } else if (t.fileStart < s.fileStart + s.byteLength) {\n        var o = s.fileStart + s.byteLength - t.fileStart, c = t.byteLength - o;\n        if (c > 0)\n          t = this.reduceBuffer(t, o, c);\n        else {\n          e = !1;\n          break;\n        }\n      }\n    }\n    e && (r.debug(\"MultiBufferStream\", \"Appending new buffer (fileStart: \" + t.fileStart + \" - Length: \" + t.byteLength + \")\"), this.buffers.push(t), i === 0 && (this.buffer = t));\n  }, d.prototype.logBufferLevel = function(t) {\n    var e, i, s, o, c = [], u, _ = \"\";\n    for (s = 0, o = 0, e = 0; e < this.buffers.length; e++)\n      i = this.buffers[e], e === 0 ? (u = {}, c.push(u), u.start = i.fileStart, u.end = i.fileStart + i.byteLength, _ += \"[\" + u.start + \"-\") : u.end === i.fileStart ? u.end = i.fileStart + i.byteLength : (u = {}, u.start = i.fileStart, _ += c[c.length - 1].end - 1 + \"], [\" + u.start + \"-\", u.end = i.fileStart + i.byteLength, c.push(u)), s += i.usedBytes, o += i.byteLength;\n    c.length > 0 && (_ += u.end - 1 + \"]\");\n    var g = t ? r.info : r.debug;\n    this.buffers.length === 0 ? g(\"MultiBufferStream\", \"No more buffer in memory\") : g(\"MultiBufferStream\", \"\" + this.buffers.length + \" stored buffer(s) (\" + s + \"/\" + o + \" bytes), continuous ranges: \" + _);\n  }, d.prototype.cleanBuffers = function() {\n    var t, e;\n    for (t = 0; t < this.buffers.length; t++)\n      e = this.buffers[t], e.usedBytes === e.byteLength && (r.debug(\"MultiBufferStream\", \"Removing buffer #\" + t), this.buffers.splice(t, 1), t--);\n  }, d.prototype.mergeNextBuffer = function() {\n    var t;\n    if (this.bufferIndex + 1 < this.buffers.length)\n      if (t = this.buffers[this.bufferIndex + 1], t.fileStart === this.buffer.fileStart + this.buffer.byteLength) {\n        var e = this.buffer.byteLength, i = this.buffer.usedBytes, s = this.buffer.fileStart;\n        return this.buffers[this.bufferIndex] = ArrayBuffer.concat(this.buffer, t), this.buffer = this.buffers[this.bufferIndex], this.buffers.splice(this.bufferIndex + 1, 1), this.buffer.usedBytes = i, this.buffer.fileStart = s, r.debug(\"ISOFile\", \"Concatenating buffer for box parsing (length: \" + e + \"->\" + this.buffer.byteLength + \")\"), !0;\n      } else\n        return !1;\n    else\n      return !1;\n  }, d.prototype.findPosition = function(t, e, i) {\n    var s, o = null, c = -1;\n    for (t === !0 ? s = 0 : s = this.bufferIndex; s < this.buffers.length && (o = this.buffers[s], o.fileStart <= e); ) {\n      c = s, i && (o.fileStart + o.byteLength <= e ? o.usedBytes = o.byteLength : o.usedBytes = e - o.fileStart, this.logBufferLevel());\n      s++;\n    }\n    return c !== -1 ? (o = this.buffers[c], o.fileStart + o.byteLength >= e ? (r.debug(\"MultiBufferStream\", \"Found position in existing buffer #\" + c), c) : -1) : -1;\n  }, d.prototype.findEndContiguousBuf = function(t) {\n    var e, i, s, o = t !== void 0 ? t : this.bufferIndex;\n    if (i = this.buffers[o], this.buffers.length > o + 1)\n      for (e = o + 1; e < this.buffers.length && (s = this.buffers[e], s.fileStart === i.fileStart + i.byteLength); e++)\n        i = s;\n    return i.fileStart + i.byteLength;\n  }, d.prototype.getEndFilePositionAfter = function(t) {\n    var e = this.findPosition(!0, t, !1);\n    return e !== -1 ? this.findEndContiguousBuf(e) : t;\n  }, d.prototype.addUsedBytes = function(t) {\n    this.buffer.usedBytes += t, this.logBufferLevel();\n  }, d.prototype.setAllUsedBytes = function() {\n    this.buffer.usedBytes = this.buffer.byteLength, this.logBufferLevel();\n  }, d.prototype.seek = function(t, e, i) {\n    var s;\n    return s = this.findPosition(e, t, i), s !== -1 ? (this.buffer = this.buffers[s], this.bufferIndex = s, this.position = t - this.buffer.fileStart, r.debug(\"MultiBufferStream\", \"Repositioning parser at buffer position: \" + this.position), !0) : (r.debug(\"MultiBufferStream\", \"Position \" + t + \" not found in buffered data\"), !1);\n  }, d.prototype.getPosition = function() {\n    if (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null)\n      throw \"Error accessing position in the MultiBufferStream\";\n    return this.buffers[this.bufferIndex].fileStart + this.position;\n  }, d.prototype.getLength = function() {\n    return this.byteLength;\n  }, d.prototype.getEndPosition = function() {\n    if (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null)\n      throw \"Error accessing position in the MultiBufferStream\";\n    return this.buffers[this.bufferIndex].fileStart + this.byteLength;\n  }, l.MultiBufferStream = d;\n  var p = function() {\n    var t = 3, e = 4, i = 5, s = 6, o = [];\n    o[t] = \"ES_Descriptor\", o[e] = \"DecoderConfigDescriptor\", o[i] = \"DecoderSpecificInfo\", o[s] = \"SLConfigDescriptor\", this.getDescriptorName = function(_) {\n      return o[_];\n    };\n    var c = this, u = {};\n    return this.parseOneDescriptor = function(_) {\n      var g = 0, w, S, U;\n      for (w = _.readUint8(), U = _.readUint8(); U & 128; )\n        g = (U & 127) << 7, U = _.readUint8();\n      return g += U & 127, r.debug(\"MPEG4DescriptorParser\", \"Found \" + (o[w] || \"Descriptor \" + w) + \", size \" + g + \" at position \" + _.getPosition()), o[w] ? S = new u[o[w]](g) : S = new u.Descriptor(g), S.parse(_), S;\n    }, u.Descriptor = function(_, g) {\n      this.tag = _, this.size = g, this.descs = [];\n    }, u.Descriptor.prototype.parse = function(_) {\n      this.data = _.readUint8Array(this.size);\n    }, u.Descriptor.prototype.findDescriptor = function(_) {\n      for (var g = 0; g < this.descs.length; g++)\n        if (this.descs[g].tag == _)\n          return this.descs[g];\n      return null;\n    }, u.Descriptor.prototype.parseRemainingDescriptors = function(_) {\n      for (var g = _.position; _.position < g + this.size; ) {\n        var w = c.parseOneDescriptor(_);\n        this.descs.push(w);\n      }\n    }, u.ES_Descriptor = function(_) {\n      u.Descriptor.call(this, t, _);\n    }, u.ES_Descriptor.prototype = new u.Descriptor(), u.ES_Descriptor.prototype.parse = function(_) {\n      if (this.ES_ID = _.readUint16(), this.flags = _.readUint8(), this.size -= 3, this.flags & 128 ? (this.dependsOn_ES_ID = _.readUint16(), this.size -= 2) : this.dependsOn_ES_ID = 0, this.flags & 64) {\n        var g = _.readUint8();\n        this.URL = _.readString(g), this.size -= g + 1;\n      } else\n        this.URL = \"\";\n      this.flags & 32 ? (this.OCR_ES_ID = _.readUint16(), this.size -= 2) : this.OCR_ES_ID = 0, this.parseRemainingDescriptors(_);\n    }, u.ES_Descriptor.prototype.getOTI = function(_) {\n      var g = this.findDescriptor(e);\n      return g ? g.oti : 0;\n    }, u.ES_Descriptor.prototype.getAudioConfig = function(_) {\n      var g = this.findDescriptor(e);\n      if (!g) return null;\n      var w = g.findDescriptor(i);\n      if (w && w.data) {\n        var S = (w.data[0] & 248) >> 3;\n        return S === 31 && w.data.length >= 2 && (S = 32 + ((w.data[0] & 7) << 3) + ((w.data[1] & 224) >> 5)), S;\n      } else\n        return null;\n    }, u.DecoderConfigDescriptor = function(_) {\n      u.Descriptor.call(this, e, _);\n    }, u.DecoderConfigDescriptor.prototype = new u.Descriptor(), u.DecoderConfigDescriptor.prototype.parse = function(_) {\n      this.oti = _.readUint8(), this.streamType = _.readUint8(), this.bufferSize = _.readUint24(), this.maxBitrate = _.readUint32(), this.avgBitrate = _.readUint32(), this.size -= 13, this.parseRemainingDescriptors(_);\n    }, u.DecoderSpecificInfo = function(_) {\n      u.Descriptor.call(this, i, _);\n    }, u.DecoderSpecificInfo.prototype = new u.Descriptor(), u.SLConfigDescriptor = function(_) {\n      u.Descriptor.call(this, s, _);\n    }, u.SLConfigDescriptor.prototype = new u.Descriptor(), this;\n  };\n  l.MPEG4DescriptorParser = p;\n  var n = {\n    ERR_INVALID_DATA: -1,\n    ERR_NOT_ENOUGH_DATA: 0,\n    OK: 1,\n    // Boxes to be created with default parsing\n    BASIC_BOXES: [\"mdat\", \"idat\", \"free\", \"skip\", \"meco\", \"strk\"],\n    FULL_BOXES: [\"hmhd\", \"nmhd\", \"iods\", \"xml \", \"bxml\", \"ipro\", \"mere\"],\n    CONTAINER_BOXES: [\n      [\"moov\", [\"trak\", \"pssh\"]],\n      [\"trak\"],\n      [\"edts\"],\n      [\"mdia\"],\n      [\"minf\"],\n      [\"dinf\"],\n      [\"stbl\", [\"sgpd\", \"sbgp\"]],\n      [\"mvex\", [\"trex\"]],\n      [\"moof\", [\"traf\"]],\n      [\"traf\", [\"trun\", \"sgpd\", \"sbgp\"]],\n      [\"vttc\"],\n      [\"tref\"],\n      [\"iref\"],\n      [\"mfra\", [\"tfra\"]],\n      [\"meco\"],\n      [\"hnti\"],\n      [\"hinf\"],\n      [\"strk\"],\n      [\"strd\"],\n      [\"sinf\"],\n      [\"rinf\"],\n      [\"schi\"],\n      [\"trgr\"],\n      [\"udta\", [\"kind\"]],\n      [\"iprp\", [\"ipma\"]],\n      [\"ipco\"]\n    ],\n    // Boxes effectively created\n    boxCodes: [],\n    fullBoxCodes: [],\n    containerBoxCodes: [],\n    sampleEntryCodes: {},\n    sampleGroupEntryCodes: [],\n    trackGroupTypes: [],\n    UUIDBoxes: {},\n    UUIDs: [],\n    initialize: function() {\n      n.FullBox.prototype = new n.Box(), n.ContainerBox.prototype = new n.Box(), n.SampleEntry.prototype = new n.Box(), n.TrackGroupTypeBox.prototype = new n.FullBox(), n.BASIC_BOXES.forEach(function(t) {\n        n.createBoxCtor(t);\n      }), n.FULL_BOXES.forEach(function(t) {\n        n.createFullBoxCtor(t);\n      }), n.CONTAINER_BOXES.forEach(function(t) {\n        n.createContainerBoxCtor(t[0], null, t[1]);\n      });\n    },\n    Box: function(t, e, i) {\n      this.type = t, this.size = e, this.uuid = i;\n    },\n    FullBox: function(t, e, i) {\n      n.Box.call(this, t, e, i), this.flags = 0, this.version = 0;\n    },\n    ContainerBox: function(t, e, i) {\n      n.Box.call(this, t, e, i), this.boxes = [];\n    },\n    SampleEntry: function(t, e, i, s) {\n      n.ContainerBox.call(this, t, e), this.hdr_size = i, this.start = s;\n    },\n    SampleGroupEntry: function(t) {\n      this.grouping_type = t;\n    },\n    TrackGroupTypeBox: function(t, e) {\n      n.FullBox.call(this, t, e);\n    },\n    createBoxCtor: function(t, e) {\n      n.boxCodes.push(t), n[t + \"Box\"] = function(i) {\n        n.Box.call(this, t, i);\n      }, n[t + \"Box\"].prototype = new n.Box(), e && (n[t + \"Box\"].prototype.parse = e);\n    },\n    createFullBoxCtor: function(t, e) {\n      n[t + \"Box\"] = function(i) {\n        n.FullBox.call(this, t, i);\n      }, n[t + \"Box\"].prototype = new n.FullBox(), n[t + \"Box\"].prototype.parse = function(i) {\n        this.parseFullHeader(i), e && e.call(this, i);\n      };\n    },\n    addSubBoxArrays: function(t) {\n      if (t) {\n        this.subBoxNames = t;\n        for (var e = t.length, i = 0; i < e; i++)\n          this[t[i] + \"s\"] = [];\n      }\n    },\n    createContainerBoxCtor: function(t, e, i) {\n      n[t + \"Box\"] = function(s) {\n        n.ContainerBox.call(this, t, s), n.addSubBoxArrays.call(this, i);\n      }, n[t + \"Box\"].prototype = new n.ContainerBox(), e && (n[t + \"Box\"].prototype.parse = e);\n    },\n    createMediaSampleEntryCtor: function(t, e, i) {\n      n.sampleEntryCodes[t] = [], n[t + \"SampleEntry\"] = function(s, o) {\n        n.SampleEntry.call(this, s, o), n.addSubBoxArrays.call(this, i);\n      }, n[t + \"SampleEntry\"].prototype = new n.SampleEntry(), e && (n[t + \"SampleEntry\"].prototype.parse = e);\n    },\n    createSampleEntryCtor: function(t, e, i, s) {\n      n.sampleEntryCodes[t].push(e), n[e + \"SampleEntry\"] = function(o) {\n        n[t + \"SampleEntry\"].call(this, e, o), n.addSubBoxArrays.call(this, s);\n      }, n[e + \"SampleEntry\"].prototype = new n[t + \"SampleEntry\"](), i && (n[e + \"SampleEntry\"].prototype.parse = i);\n    },\n    createEncryptedSampleEntryCtor: function(t, e, i) {\n      n.createSampleEntryCtor.call(this, t, e, i, [\"sinf\"]);\n    },\n    createSampleGroupCtor: function(t, e) {\n      n[t + \"SampleGroupEntry\"] = function(i) {\n        n.SampleGroupEntry.call(this, t, i);\n      }, n[t + \"SampleGroupEntry\"].prototype = new n.SampleGroupEntry(), e && (n[t + \"SampleGroupEntry\"].prototype.parse = e);\n    },\n    createTrackGroupCtor: function(t, e) {\n      n[t + \"TrackGroupTypeBox\"] = function(i) {\n        n.TrackGroupTypeBox.call(this, t, i);\n      }, n[t + \"TrackGroupTypeBox\"].prototype = new n.TrackGroupTypeBox(), e && (n[t + \"TrackGroupTypeBox\"].prototype.parse = e);\n    },\n    createUUIDBox: function(t, e, i, s) {\n      n.UUIDs.push(t), n.UUIDBoxes[t] = function(o) {\n        e ? n.FullBox.call(this, \"uuid\", o, t) : i ? n.ContainerBox.call(this, \"uuid\", o, t) : n.Box.call(this, \"uuid\", o, t);\n      }, n.UUIDBoxes[t].prototype = e ? new n.FullBox() : i ? new n.ContainerBox() : new n.Box(), s && (e ? n.UUIDBoxes[t].prototype.parse = function(o) {\n        this.parseFullHeader(o), s && s.call(this, o);\n      } : n.UUIDBoxes[t].prototype.parse = s);\n    }\n  };\n  n.initialize(), n.TKHD_FLAG_ENABLED = 1, n.TKHD_FLAG_IN_MOVIE = 2, n.TKHD_FLAG_IN_PREVIEW = 4, n.TFHD_FLAG_BASE_DATA_OFFSET = 1, n.TFHD_FLAG_SAMPLE_DESC = 2, n.TFHD_FLAG_SAMPLE_DUR = 8, n.TFHD_FLAG_SAMPLE_SIZE = 16, n.TFHD_FLAG_SAMPLE_FLAGS = 32, n.TFHD_FLAG_DUR_EMPTY = 65536, n.TFHD_FLAG_DEFAULT_BASE_IS_MOOF = 131072, n.TRUN_FLAGS_DATA_OFFSET = 1, n.TRUN_FLAGS_FIRST_FLAG = 4, n.TRUN_FLAGS_DURATION = 256, n.TRUN_FLAGS_SIZE = 512, n.TRUN_FLAGS_FLAGS = 1024, n.TRUN_FLAGS_CTS_OFFSET = 2048, n.Box.prototype.add = function(t) {\n    return this.addBox(new n[t + \"Box\"]());\n  }, n.Box.prototype.addBox = function(t) {\n    return this.boxes.push(t), this[t.type + \"s\"] ? this[t.type + \"s\"].push(t) : this[t.type] = t, t;\n  }, n.Box.prototype.set = function(t, e) {\n    return this[t] = e, this;\n  }, n.Box.prototype.addEntry = function(t, e) {\n    var i = e || \"entries\";\n    return this[i] || (this[i] = []), this[i].push(t), this;\n  }, l.BoxParser = n, n.parseUUID = function(t) {\n    return n.parseHex16(t);\n  }, n.parseHex16 = function(t) {\n    for (var e = \"\", i = 0; i < 16; i++) {\n      var s = t.readUint8().toString(16);\n      e += s.length === 1 ? \"0\" + s : s;\n    }\n    return e;\n  }, n.parseOneBox = function(t, e, i) {\n    var s, o = t.getPosition(), c = 0, u, _;\n    if (t.getEndPosition() - o < 8)\n      return r.debug(\"BoxParser\", \"Not enough data in stream to parse the type and size of the box\"), { code: n.ERR_NOT_ENOUGH_DATA };\n    if (i && i < 8)\n      return r.debug(\"BoxParser\", \"Not enough bytes left in the parent box to parse a new box\"), { code: n.ERR_NOT_ENOUGH_DATA };\n    var g = t.readUint32(), w = t.readString(4), S = w;\n    if (r.debug(\"BoxParser\", \"Found box of type '\" + w + \"' and size \" + g + \" at position \" + o), c = 8, w == \"uuid\") {\n      if (t.getEndPosition() - t.getPosition() < 16 || i - c < 16)\n        return t.seek(o), r.debug(\"BoxParser\", \"Not enough bytes left in the parent box to parse a UUID box\"), { code: n.ERR_NOT_ENOUGH_DATA };\n      _ = n.parseUUID(t), c += 16, S = _;\n    }\n    if (g == 1) {\n      if (t.getEndPosition() - t.getPosition() < 8 || i && i - c < 8)\n        return t.seek(o), r.warn(\"BoxParser\", 'Not enough data in stream to parse the extended size of the \"' + w + '\" box'), { code: n.ERR_NOT_ENOUGH_DATA };\n      g = t.readUint64(), c += 8;\n    } else if (g === 0) {\n      if (i)\n        g = i;\n      else if (w !== \"mdat\")\n        return r.error(\"BoxParser\", \"Unlimited box size not supported for type: '\" + w + \"'\"), s = new n.Box(w, g), { code: n.OK, box: s, size: s.size };\n    }\n    return g !== 0 && g < c ? (r.error(\"BoxParser\", \"Box of type \" + w + \" has an invalid size \" + g + \" (too small to be a box)\"), { code: n.ERR_NOT_ENOUGH_DATA, type: w, size: g, hdr_size: c, start: o }) : g !== 0 && i && g > i ? (r.error(\"BoxParser\", \"Box of type '\" + w + \"' has a size \" + g + \" greater than its container size \" + i), { code: n.ERR_NOT_ENOUGH_DATA, type: w, size: g, hdr_size: c, start: o }) : g !== 0 && o + g > t.getEndPosition() ? (t.seek(o), r.info(\"BoxParser\", \"Not enough data in stream to parse the entire '\" + w + \"' box\"), { code: n.ERR_NOT_ENOUGH_DATA, type: w, size: g, hdr_size: c, start: o }) : e ? { code: n.OK, type: w, size: g, hdr_size: c, start: o } : (n[w + \"Box\"] ? s = new n[w + \"Box\"](g) : w !== \"uuid\" ? (r.warn(\"BoxParser\", \"Unknown box type: '\" + w + \"'\"), s = new n.Box(w, g), s.has_unparsed_data = !0) : n.UUIDBoxes[_] ? s = new n.UUIDBoxes[_](g) : (r.warn(\"BoxParser\", \"Unknown uuid type: '\" + _ + \"'\"), s = new n.Box(w, g), s.uuid = _, s.has_unparsed_data = !0), s.hdr_size = c, s.start = o, s.write === n.Box.prototype.write && s.type !== \"mdat\" && (r.info(\"BoxParser\", \"'\" + S + \"' box writing not yet implemented, keeping unparsed data in memory for later write\"), s.parseDataAndRewind(t)), s.parse(t), u = t.getPosition() - (s.start + s.size), u < 0 ? (r.warn(\"BoxParser\", \"Parsing of box '\" + S + \"' did not read the entire indicated box data size (missing \" + -u + \" bytes), seeking forward\"), t.seek(s.start + s.size)) : u > 0 && (r.error(\"BoxParser\", \"Parsing of box '\" + S + \"' read \" + u + \" more bytes than the indicated box data size, seeking backwards\"), s.size !== 0 && t.seek(s.start + s.size)), { code: n.OK, box: s, size: s.size });\n  }, n.Box.prototype.parse = function(t) {\n    this.type != \"mdat\" ? this.data = t.readUint8Array(this.size - this.hdr_size) : this.size === 0 ? t.seek(t.getEndPosition()) : t.seek(this.start + this.size);\n  }, n.Box.prototype.parseDataAndRewind = function(t) {\n    this.data = t.readUint8Array(this.size - this.hdr_size), t.position -= this.size - this.hdr_size;\n  }, n.FullBox.prototype.parseDataAndRewind = function(t) {\n    this.parseFullHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 4, t.position -= this.size - this.hdr_size;\n  }, n.FullBox.prototype.parseFullHeader = function(t) {\n    this.version = t.readUint8(), this.flags = t.readUint24(), this.hdr_size += 4;\n  }, n.FullBox.prototype.parse = function(t) {\n    this.parseFullHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size);\n  }, n.ContainerBox.prototype.parse = function(t) {\n    for (var e, i; t.getPosition() < this.start + this.size; )\n      if (e = n.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), e.code === n.OK)\n        if (i = e.box, this.boxes.push(i), this.subBoxNames && this.subBoxNames.indexOf(i.type) != -1)\n          this[this.subBoxNames[this.subBoxNames.indexOf(i.type)] + \"s\"].push(i);\n        else {\n          var s = i.type !== \"uuid\" ? i.type : i.uuid;\n          this[s] ? r.warn(\"Box of type \" + s + \" already stored in field of this type\") : this[s] = i;\n        }\n      else\n        return;\n  }, n.Box.prototype.parseLanguage = function(t) {\n    this.language = t.readUint16();\n    var e = [];\n    e[0] = this.language >> 10 & 31, e[1] = this.language >> 5 & 31, e[2] = this.language & 31, this.languageString = String.fromCharCode(e[0] + 96, e[1] + 96, e[2] + 96);\n  }, n.SAMPLE_ENTRY_TYPE_VISUAL = \"Visual\", n.SAMPLE_ENTRY_TYPE_AUDIO = \"Audio\", n.SAMPLE_ENTRY_TYPE_HINT = \"Hint\", n.SAMPLE_ENTRY_TYPE_METADATA = \"Metadata\", n.SAMPLE_ENTRY_TYPE_SUBTITLE = \"Subtitle\", n.SAMPLE_ENTRY_TYPE_SYSTEM = \"System\", n.SAMPLE_ENTRY_TYPE_TEXT = \"Text\", n.SampleEntry.prototype.parseHeader = function(t) {\n    t.readUint8Array(6), this.data_reference_index = t.readUint16(), this.hdr_size += 8;\n  }, n.SampleEntry.prototype.parse = function(t) {\n    this.parseHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size);\n  }, n.SampleEntry.prototype.parseDataAndRewind = function(t) {\n    this.parseHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 8, t.position -= this.size - this.hdr_size;\n  }, n.SampleEntry.prototype.parseFooter = function(t) {\n    n.ContainerBox.prototype.parse.call(this, t);\n  }, n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_HINT), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_METADATA), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SYSTEM), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_TEXT), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, function(t) {\n    var e;\n    this.parseHeader(t), t.readUint16(), t.readUint16(), t.readUint32Array(3), this.width = t.readUint16(), this.height = t.readUint16(), this.horizresolution = t.readUint32(), this.vertresolution = t.readUint32(), t.readUint32(), this.frame_count = t.readUint16(), e = Math.min(31, t.readUint8()), this.compressorname = t.readString(e), e < 31 && t.readString(31 - e), this.depth = t.readUint16(), t.readUint16(), this.parseFooter(t);\n  }), n.createMediaSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, function(t) {\n    this.parseHeader(t), t.readUint32Array(2), this.channel_count = t.readUint16(), this.samplesize = t.readUint16(), t.readUint16(), t.readUint16(), this.samplerate = t.readUint32() / 65536, this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"avc1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"avc2\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"avc3\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"avc4\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"av01\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"hvc1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"hev1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vvc1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vvi1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vvs1\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vvcN\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vp08\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"vp09\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, \"mp4a\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, \"ac-3\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, \"ec-3\"), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, \"Opus\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_VISUAL, \"encv\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_AUDIO, \"enca\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE, \"encu\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SYSTEM, \"encs\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_TEXT, \"enct\"), n.createEncryptedSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_METADATA, \"encm\"), n.createBoxCtor(\"a1lx\", function(t) {\n    var e = t.readUint8() & 1, i = ((e & 1) + 1) * 16;\n    this.layer_size = [];\n    for (var s = 0; s < 3; s++)\n      i == 16 ? this.layer_size[s] = t.readUint16() : this.layer_size[s] = t.readUint32();\n  }), n.createBoxCtor(\"a1op\", function(t) {\n    this.op_index = t.readUint8();\n  }), n.createFullBoxCtor(\"auxC\", function(t) {\n    this.aux_type = t.readCString();\n    var e = this.size - this.hdr_size - (this.aux_type.length + 1);\n    this.aux_subtype = t.readUint8Array(e);\n  }), n.createBoxCtor(\"av1C\", function(t) {\n    var e = t.readUint8();\n    if (e >> 7 & !1) {\n      r.error(\"av1C marker problem\");\n      return;\n    }\n    if (this.version = e & 127, this.version !== 1) {\n      r.error(\"av1C version \" + this.version + \" not supported\");\n      return;\n    }\n    if (e = t.readUint8(), this.seq_profile = e >> 5 & 7, this.seq_level_idx_0 = e & 31, e = t.readUint8(), this.seq_tier_0 = e >> 7 & 1, this.high_bitdepth = e >> 6 & 1, this.twelve_bit = e >> 5 & 1, this.monochrome = e >> 4 & 1, this.chroma_subsampling_x = e >> 3 & 1, this.chroma_subsampling_y = e >> 2 & 1, this.chroma_sample_position = e & 3, e = t.readUint8(), this.reserved_1 = e >> 5 & 7, this.reserved_1 !== 0) {\n      r.error(\"av1C reserved_1 parsing problem\");\n      return;\n    }\n    if (this.initial_presentation_delay_present = e >> 4 & 1, this.initial_presentation_delay_present === 1)\n      this.initial_presentation_delay_minus_one = e & 15;\n    else if (this.reserved_2 = e & 15, this.reserved_2 !== 0) {\n      r.error(\"av1C reserved_2 parsing problem\");\n      return;\n    }\n    var i = this.size - this.hdr_size - 4;\n    this.configOBUs = t.readUint8Array(i);\n  }), n.createBoxCtor(\"avcC\", function(t) {\n    var e, i;\n    for (this.configurationVersion = t.readUint8(), this.AVCProfileIndication = t.readUint8(), this.profile_compatibility = t.readUint8(), this.AVCLevelIndication = t.readUint8(), this.lengthSizeMinusOne = t.readUint8() & 3, this.nb_SPS_nalus = t.readUint8() & 31, i = this.size - this.hdr_size - 6, this.SPS = [], e = 0; e < this.nb_SPS_nalus; e++)\n      this.SPS[e] = {}, this.SPS[e].length = t.readUint16(), this.SPS[e].nalu = t.readUint8Array(this.SPS[e].length), i -= 2 + this.SPS[e].length;\n    for (this.nb_PPS_nalus = t.readUint8(), i--, this.PPS = [], e = 0; e < this.nb_PPS_nalus; e++)\n      this.PPS[e] = {}, this.PPS[e].length = t.readUint16(), this.PPS[e].nalu = t.readUint8Array(this.PPS[e].length), i -= 2 + this.PPS[e].length;\n    i > 0 && (this.ext = t.readUint8Array(i));\n  }), n.createBoxCtor(\"btrt\", function(t) {\n    this.bufferSizeDB = t.readUint32(), this.maxBitrate = t.readUint32(), this.avgBitrate = t.readUint32();\n  }), n.createBoxCtor(\"clap\", function(t) {\n    this.cleanApertureWidthN = t.readUint32(), this.cleanApertureWidthD = t.readUint32(), this.cleanApertureHeightN = t.readUint32(), this.cleanApertureHeightD = t.readUint32(), this.horizOffN = t.readUint32(), this.horizOffD = t.readUint32(), this.vertOffN = t.readUint32(), this.vertOffD = t.readUint32();\n  }), n.createBoxCtor(\"clli\", function(t) {\n    this.max_content_light_level = t.readUint16(), this.max_pic_average_light_level = t.readUint16();\n  }), n.createFullBoxCtor(\"co64\", function(t) {\n    var e, i;\n    if (e = t.readUint32(), this.chunk_offsets = [], this.version === 0)\n      for (i = 0; i < e; i++)\n        this.chunk_offsets.push(t.readUint64());\n  }), n.createFullBoxCtor(\"CoLL\", function(t) {\n    this.maxCLL = t.readUint16(), this.maxFALL = t.readUint16();\n  }), n.createBoxCtor(\"colr\", function(t) {\n    if (this.colour_type = t.readString(4), this.colour_type === \"nclx\") {\n      this.colour_primaries = t.readUint16(), this.transfer_characteristics = t.readUint16(), this.matrix_coefficients = t.readUint16();\n      var e = t.readUint8();\n      this.full_range_flag = e >> 7;\n    } else this.colour_type === \"rICC\" ? this.ICC_profile = t.readUint8Array(this.size - 4) : this.colour_type === \"prof\" && (this.ICC_profile = t.readUint8Array(this.size - 4));\n  }), n.createFullBoxCtor(\"cprt\", function(t) {\n    this.parseLanguage(t), this.notice = t.readCString();\n  }), n.createFullBoxCtor(\"cslg\", function(t) {\n    this.version === 0 && (this.compositionToDTSShift = t.readInt32(), this.leastDecodeToDisplayDelta = t.readInt32(), this.greatestDecodeToDisplayDelta = t.readInt32(), this.compositionStartTime = t.readInt32(), this.compositionEndTime = t.readInt32());\n  }), n.createFullBoxCtor(\"ctts\", function(t) {\n    var e, i;\n    if (e = t.readUint32(), this.sample_counts = [], this.sample_offsets = [], this.version === 0)\n      for (i = 0; i < e; i++) {\n        this.sample_counts.push(t.readUint32());\n        var s = t.readInt32();\n        s < 0 && r.warn(\"BoxParser\", \"ctts box uses negative values without using version 1\"), this.sample_offsets.push(s);\n      }\n    else if (this.version == 1)\n      for (i = 0; i < e; i++)\n        this.sample_counts.push(t.readUint32()), this.sample_offsets.push(t.readInt32());\n  }), n.createBoxCtor(\"dac3\", function(t) {\n    var e = t.readUint8(), i = t.readUint8(), s = t.readUint8();\n    this.fscod = e >> 6, this.bsid = e >> 1 & 31, this.bsmod = (e & 1) << 2 | i >> 6 & 3, this.acmod = i >> 3 & 7, this.lfeon = i >> 2 & 1, this.bit_rate_code = i & 3 | s >> 5 & 7;\n  }), n.createBoxCtor(\"dec3\", function(t) {\n    var e = t.readUint16();\n    this.data_rate = e >> 3, this.num_ind_sub = e & 7, this.ind_subs = [];\n    for (var i = 0; i < this.num_ind_sub + 1; i++) {\n      var s = {};\n      this.ind_subs.push(s);\n      var o = t.readUint8(), c = t.readUint8(), u = t.readUint8();\n      s.fscod = o >> 6, s.bsid = o >> 1 & 31, s.bsmod = (o & 1) << 4 | c >> 4 & 15, s.acmod = c >> 1 & 7, s.lfeon = c & 1, s.num_dep_sub = u >> 1 & 15, s.num_dep_sub > 0 && (s.chan_loc = (u & 1) << 8 | t.readUint8());\n    }\n  }), n.createFullBoxCtor(\"dfLa\", function(t) {\n    var e = 127, i = 128, s = [], o = [\n      \"STREAMINFO\",\n      \"PADDING\",\n      \"APPLICATION\",\n      \"SEEKTABLE\",\n      \"VORBIS_COMMENT\",\n      \"CUESHEET\",\n      \"PICTURE\",\n      \"RESERVED\"\n    ];\n    this.parseFullHeader(t);\n    do {\n      var c = t.readUint8(), u = Math.min(\n        c & e,\n        o.length - 1\n      );\n      if (u ? t.readUint8Array(t.readUint24()) : (t.readUint8Array(13), this.samplerate = t.readUint32() >> 12, t.readUint8Array(20)), s.push(o[u]), c & i)\n        break;\n    } while (!0);\n    this.numMetadataBlocks = s.length + \" (\" + s.join(\", \") + \")\";\n  }), n.createBoxCtor(\"dimm\", function(t) {\n    this.bytessent = t.readUint64();\n  }), n.createBoxCtor(\"dmax\", function(t) {\n    this.time = t.readUint32();\n  }), n.createBoxCtor(\"dmed\", function(t) {\n    this.bytessent = t.readUint64();\n  }), n.createBoxCtor(\"dOps\", function(t) {\n    if (this.Version = t.readUint8(), this.OutputChannelCount = t.readUint8(), this.PreSkip = t.readUint16(), this.InputSampleRate = t.readUint32(), this.OutputGain = t.readInt16(), this.ChannelMappingFamily = t.readUint8(), this.ChannelMappingFamily !== 0) {\n      this.StreamCount = t.readUint8(), this.CoupledCount = t.readUint8(), this.ChannelMapping = [];\n      for (var e = 0; e < this.OutputChannelCount; e++)\n        this.ChannelMapping[e] = t.readUint8();\n    }\n  }), n.createFullBoxCtor(\"dref\", function(t) {\n    var e, i;\n    this.entries = [];\n    for (var s = t.readUint32(), o = 0; o < s; o++)\n      if (e = n.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), e.code === n.OK)\n        i = e.box, this.entries.push(i);\n      else\n        return;\n  }), n.createBoxCtor(\"drep\", function(t) {\n    this.bytessent = t.readUint64();\n  }), n.createFullBoxCtor(\"elng\", function(t) {\n    this.extended_language = t.readString(this.size - this.hdr_size);\n  }), n.createFullBoxCtor(\"elst\", function(t) {\n    this.entries = [];\n    for (var e = t.readUint32(), i = 0; i < e; i++) {\n      var s = {};\n      this.entries.push(s), this.version === 1 ? (s.segment_duration = t.readUint64(), s.media_time = t.readInt64()) : (s.segment_duration = t.readUint32(), s.media_time = t.readInt32()), s.media_rate_integer = t.readInt16(), s.media_rate_fraction = t.readInt16();\n    }\n  }), n.createFullBoxCtor(\"emsg\", function(t) {\n    this.version == 1 ? (this.timescale = t.readUint32(), this.presentation_time = t.readUint64(), this.event_duration = t.readUint32(), this.id = t.readUint32(), this.scheme_id_uri = t.readCString(), this.value = t.readCString()) : (this.scheme_id_uri = t.readCString(), this.value = t.readCString(), this.timescale = t.readUint32(), this.presentation_time_delta = t.readUint32(), this.event_duration = t.readUint32(), this.id = t.readUint32());\n    var e = this.size - this.hdr_size - (4 * 4 + (this.scheme_id_uri.length + 1) + (this.value.length + 1));\n    this.version == 1 && (e -= 4), this.message_data = t.readUint8Array(e);\n  }), n.createFullBoxCtor(\"esds\", function(t) {\n    var e = t.readUint8Array(this.size - this.hdr_size);\n    if (typeof p < \"u\") {\n      var i = new p();\n      this.esd = i.parseOneDescriptor(new a(e.buffer, 0, a.BIG_ENDIAN));\n    }\n  }), n.createBoxCtor(\"fiel\", function(t) {\n    this.fieldCount = t.readUint8(), this.fieldOrdering = t.readUint8();\n  }), n.createBoxCtor(\"frma\", function(t) {\n    this.data_format = t.readString(4);\n  }), n.createBoxCtor(\"ftyp\", function(t) {\n    var e = this.size - this.hdr_size;\n    this.major_brand = t.readString(4), this.minor_version = t.readUint32(), e -= 8, this.compatible_brands = [];\n    for (var i = 0; e >= 4; )\n      this.compatible_brands[i] = t.readString(4), e -= 4, i++;\n  }), n.createFullBoxCtor(\"hdlr\", function(t) {\n    this.version === 0 && (t.readUint32(), this.handler = t.readString(4), t.readUint32Array(3), this.name = t.readString(this.size - this.hdr_size - 20), this.name[this.name.length - 1] === \"\\0\" && (this.name = this.name.slice(0, -1)));\n  }), n.createBoxCtor(\"hvcC\", function(t) {\n    var e, i, s, o;\n    this.configurationVersion = t.readUint8(), o = t.readUint8(), this.general_profile_space = o >> 6, this.general_tier_flag = (o & 32) >> 5, this.general_profile_idc = o & 31, this.general_profile_compatibility = t.readUint32(), this.general_constraint_indicator = t.readUint8Array(6), this.general_level_idc = t.readUint8(), this.min_spatial_segmentation_idc = t.readUint16() & 4095, this.parallelismType = t.readUint8() & 3, this.chroma_format_idc = t.readUint8() & 3, this.bit_depth_luma_minus8 = t.readUint8() & 7, this.bit_depth_chroma_minus8 = t.readUint8() & 7, this.avgFrameRate = t.readUint16(), o = t.readUint8(), this.constantFrameRate = o >> 6, this.numTemporalLayers = (o & 13) >> 3, this.temporalIdNested = (o & 4) >> 2, this.lengthSizeMinusOne = o & 3, this.nalu_arrays = [];\n    var c = t.readUint8();\n    for (e = 0; e < c; e++) {\n      var u = [];\n      this.nalu_arrays.push(u), o = t.readUint8(), u.completeness = (o & 128) >> 7, u.nalu_type = o & 63;\n      var _ = t.readUint16();\n      for (i = 0; i < _; i++) {\n        var g = {};\n        u.push(g), s = t.readUint16(), g.data = t.readUint8Array(s);\n      }\n    }\n  }), n.createFullBoxCtor(\"iinf\", function(t) {\n    var e;\n    this.version === 0 ? this.entry_count = t.readUint16() : this.entry_count = t.readUint32(), this.item_infos = [];\n    for (var i = 0; i < this.entry_count; i++)\n      if (e = n.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), e.code === n.OK)\n        e.box.type !== \"infe\" && r.error(\"BoxParser\", \"Expected 'infe' box, got \" + e.box.type), this.item_infos[i] = e.box;\n      else\n        return;\n  }), n.createFullBoxCtor(\"iloc\", function(t) {\n    var e;\n    e = t.readUint8(), this.offset_size = e >> 4 & 15, this.length_size = e & 15, e = t.readUint8(), this.base_offset_size = e >> 4 & 15, this.version === 1 || this.version === 2 ? this.index_size = e & 15 : this.index_size = 0, this.items = [];\n    var i = 0;\n    if (this.version < 2)\n      i = t.readUint16();\n    else if (this.version === 2)\n      i = t.readUint32();\n    else\n      throw \"version of iloc box not supported\";\n    for (var s = 0; s < i; s++) {\n      var o = {};\n      if (this.items.push(o), this.version < 2)\n        o.item_ID = t.readUint16();\n      else if (this.version === 2)\n        o.item_ID = t.readUint16();\n      else\n        throw \"version of iloc box not supported\";\n      switch (this.version === 1 || this.version === 2 ? o.construction_method = t.readUint16() & 15 : o.construction_method = 0, o.data_reference_index = t.readUint16(), this.base_offset_size) {\n        case 0:\n          o.base_offset = 0;\n          break;\n        case 4:\n          o.base_offset = t.readUint32();\n          break;\n        case 8:\n          o.base_offset = t.readUint64();\n          break;\n        default:\n          throw \"Error reading base offset size\";\n      }\n      var c = t.readUint16();\n      o.extents = [];\n      for (var u = 0; u < c; u++) {\n        var _ = {};\n        if (o.extents.push(_), this.version === 1 || this.version === 2)\n          switch (this.index_size) {\n            case 0:\n              _.extent_index = 0;\n              break;\n            case 4:\n              _.extent_index = t.readUint32();\n              break;\n            case 8:\n              _.extent_index = t.readUint64();\n              break;\n            default:\n              throw \"Error reading extent index\";\n          }\n        switch (this.offset_size) {\n          case 0:\n            _.extent_offset = 0;\n            break;\n          case 4:\n            _.extent_offset = t.readUint32();\n            break;\n          case 8:\n            _.extent_offset = t.readUint64();\n            break;\n          default:\n            throw \"Error reading extent index\";\n        }\n        switch (this.length_size) {\n          case 0:\n            _.extent_length = 0;\n            break;\n          case 4:\n            _.extent_length = t.readUint32();\n            break;\n          case 8:\n            _.extent_length = t.readUint64();\n            break;\n          default:\n            throw \"Error reading extent index\";\n        }\n      }\n    }\n  }), n.createBoxCtor(\"imir\", function(t) {\n    var e = t.readUint8();\n    this.reserved = e >> 7, this.axis = e & 1;\n  }), n.createFullBoxCtor(\"infe\", function(t) {\n    if ((this.version === 0 || this.version === 1) && (this.item_ID = t.readUint16(), this.item_protection_index = t.readUint16(), this.item_name = t.readCString(), this.content_type = t.readCString(), this.content_encoding = t.readCString()), this.version === 1) {\n      this.extension_type = t.readString(4), r.warn(\"BoxParser\", \"Cannot parse extension type\"), t.seek(this.start + this.size);\n      return;\n    }\n    this.version >= 2 && (this.version === 2 ? this.item_ID = t.readUint16() : this.version === 3 && (this.item_ID = t.readUint32()), this.item_protection_index = t.readUint16(), this.item_type = t.readString(4), this.item_name = t.readCString(), this.item_type === \"mime\" ? (this.content_type = t.readCString(), this.content_encoding = t.readCString()) : this.item_type === \"uri \" && (this.item_uri_type = t.readCString()));\n  }), n.createFullBoxCtor(\"ipma\", function(t) {\n    var e, i;\n    for (entry_count = t.readUint32(), this.associations = [], e = 0; e < entry_count; e++) {\n      var s = {};\n      this.associations.push(s), this.version < 1 ? s.id = t.readUint16() : s.id = t.readUint32();\n      var o = t.readUint8();\n      for (s.props = [], i = 0; i < o; i++) {\n        var c = t.readUint8(), u = {};\n        s.props.push(u), u.essential = (c & 128) >> 7 === 1, this.flags & 1 ? u.property_index = (c & 127) << 8 | t.readUint8() : u.property_index = c & 127;\n      }\n    }\n  }), n.createFullBoxCtor(\"iref\", function(t) {\n    var e, i;\n    for (this.references = []; t.getPosition() < this.start + this.size; )\n      if (e = n.parseOneBox(t, !0, this.size - (t.getPosition() - this.start)), e.code === n.OK)\n        this.version === 0 ? i = new n.SingleItemTypeReferenceBox(e.type, e.size, e.hdr_size, e.start) : i = new n.SingleItemTypeReferenceBoxLarge(e.type, e.size, e.hdr_size, e.start), i.write === n.Box.prototype.write && i.type !== \"mdat\" && (r.warn(\"BoxParser\", i.type + \" box writing not yet implemented, keeping unparsed data in memory for later write\"), i.parseDataAndRewind(t)), i.parse(t), this.references.push(i);\n      else\n        return;\n  }), n.createBoxCtor(\"irot\", function(t) {\n    this.angle = t.readUint8() & 3;\n  }), n.createFullBoxCtor(\"ispe\", function(t) {\n    this.image_width = t.readUint32(), this.image_height = t.readUint32();\n  }), n.createFullBoxCtor(\"kind\", function(t) {\n    this.schemeURI = t.readCString(), this.value = t.readCString();\n  }), n.createFullBoxCtor(\"leva\", function(t) {\n    var e = t.readUint8();\n    this.levels = [];\n    for (var i = 0; i < e; i++) {\n      var s = {};\n      this.levels[i] = s, s.track_ID = t.readUint32();\n      var o = t.readUint8();\n      switch (s.padding_flag = o >> 7, s.assignment_type = o & 127, s.assignment_type) {\n        case 0:\n          s.grouping_type = t.readString(4);\n          break;\n        case 1:\n          s.grouping_type = t.readString(4), s.grouping_type_parameter = t.readUint32();\n          break;\n        case 2:\n          break;\n        case 3:\n          break;\n        case 4:\n          s.sub_track_id = t.readUint32();\n          break;\n        default:\n          r.warn(\"BoxParser\", \"Unknown leva assignement type\");\n      }\n    }\n  }), n.createBoxCtor(\"lsel\", function(t) {\n    this.layer_id = t.readUint16();\n  }), n.createBoxCtor(\"maxr\", function(t) {\n    this.period = t.readUint32(), this.bytes = t.readUint32();\n  }), n.createBoxCtor(\"mdcv\", function(t) {\n    this.display_primaries = [], this.display_primaries[0] = {}, this.display_primaries[0].x = t.readUint16(), this.display_primaries[0].y = t.readUint16(), this.display_primaries[1] = {}, this.display_primaries[1].x = t.readUint16(), this.display_primaries[1].y = t.readUint16(), this.display_primaries[2] = {}, this.display_primaries[2].x = t.readUint16(), this.display_primaries[2].y = t.readUint16(), this.white_point = {}, this.white_point.x = t.readUint16(), this.white_point.y = t.readUint16(), this.max_display_mastering_luminance = t.readUint32(), this.min_display_mastering_luminance = t.readUint32();\n  }), n.createFullBoxCtor(\"mdhd\", function(t) {\n    this.version == 1 ? (this.creation_time = t.readUint64(), this.modification_time = t.readUint64(), this.timescale = t.readUint32(), this.duration = t.readUint64()) : (this.creation_time = t.readUint32(), this.modification_time = t.readUint32(), this.timescale = t.readUint32(), this.duration = t.readUint32()), this.parseLanguage(t), t.readUint16();\n  }), n.createFullBoxCtor(\"mehd\", function(t) {\n    this.flags & 1 && (r.warn(\"BoxParser\", \"mehd box incorrectly uses flags set to 1, converting version to 1\"), this.version = 1), this.version == 1 ? this.fragment_duration = t.readUint64() : this.fragment_duration = t.readUint32();\n  }), n.createFullBoxCtor(\"meta\", function(t) {\n    this.boxes = [], n.ContainerBox.prototype.parse.call(this, t);\n  }), n.createFullBoxCtor(\"mfhd\", function(t) {\n    this.sequence_number = t.readUint32();\n  }), n.createFullBoxCtor(\"mfro\", function(t) {\n    this._size = t.readUint32();\n  }), n.createFullBoxCtor(\"mvhd\", function(t) {\n    this.version == 1 ? (this.creation_time = t.readUint64(), this.modification_time = t.readUint64(), this.timescale = t.readUint32(), this.duration = t.readUint64()) : (this.creation_time = t.readUint32(), this.modification_time = t.readUint32(), this.timescale = t.readUint32(), this.duration = t.readUint32()), this.rate = t.readUint32(), this.volume = t.readUint16() >> 8, t.readUint16(), t.readUint32Array(2), this.matrix = t.readUint32Array(9), t.readUint32Array(6), this.next_track_id = t.readUint32();\n  }), n.createBoxCtor(\"npck\", function(t) {\n    this.packetssent = t.readUint32();\n  }), n.createBoxCtor(\"nump\", function(t) {\n    this.packetssent = t.readUint64();\n  }), n.createFullBoxCtor(\"padb\", function(t) {\n    var e = t.readUint32();\n    this.padbits = [];\n    for (var i = 0; i < Math.floor((e + 1) / 2); i++)\n      this.padbits = t.readUint8();\n  }), n.createBoxCtor(\"pasp\", function(t) {\n    this.hSpacing = t.readUint32(), this.vSpacing = t.readUint32();\n  }), n.createBoxCtor(\"payl\", function(t) {\n    this.text = t.readString(this.size - this.hdr_size);\n  }), n.createBoxCtor(\"payt\", function(t) {\n    this.payloadID = t.readUint32();\n    var e = t.readUint8();\n    this.rtpmap_string = t.readString(e);\n  }), n.createFullBoxCtor(\"pdin\", function(t) {\n    var e = (this.size - this.hdr_size) / 8;\n    this.rate = [], this.initial_delay = [];\n    for (var i = 0; i < e; i++)\n      this.rate[i] = t.readUint32(), this.initial_delay[i] = t.readUint32();\n  }), n.createFullBoxCtor(\"pitm\", function(t) {\n    this.version === 0 ? this.item_id = t.readUint16() : this.item_id = t.readUint32();\n  }), n.createFullBoxCtor(\"pixi\", function(t) {\n    var e;\n    for (this.num_channels = t.readUint8(), this.bits_per_channels = [], e = 0; e < this.num_channels; e++)\n      this.bits_per_channels[e] = t.readUint8();\n  }), n.createBoxCtor(\"pmax\", function(t) {\n    this.bytes = t.readUint32();\n  }), n.createFullBoxCtor(\"prft\", function(t) {\n    this.ref_track_id = t.readUint32(), this.ntp_timestamp = t.readUint64(), this.version === 0 ? this.media_time = t.readUint32() : this.media_time = t.readUint64();\n  }), n.createFullBoxCtor(\"pssh\", function(t) {\n    if (this.system_id = n.parseHex16(t), this.version > 0) {\n      var e = t.readUint32();\n      this.kid = [];\n      for (var i = 0; i < e; i++)\n        this.kid[i] = n.parseHex16(t);\n    }\n    var s = t.readUint32();\n    s > 0 && (this.data = t.readUint8Array(s));\n  }), n.createFullBoxCtor(\"clef\", function(t) {\n    this.width = t.readUint32(), this.height = t.readUint32();\n  }), n.createFullBoxCtor(\"enof\", function(t) {\n    this.width = t.readUint32(), this.height = t.readUint32();\n  }), n.createFullBoxCtor(\"prof\", function(t) {\n    this.width = t.readUint32(), this.height = t.readUint32();\n  }), n.createContainerBoxCtor(\"tapt\", null, [\"clef\", \"prof\", \"enof\"]), n.createBoxCtor(\"rtp \", function(t) {\n    this.descriptionformat = t.readString(4), this.sdptext = t.readString(this.size - this.hdr_size - 4);\n  }), n.createFullBoxCtor(\"saio\", function(t) {\n    this.flags & 1 && (this.aux_info_type = t.readUint32(), this.aux_info_type_parameter = t.readUint32());\n    var e = t.readUint32();\n    this.offset = [];\n    for (var i = 0; i < e; i++)\n      this.version === 0 ? this.offset[i] = t.readUint32() : this.offset[i] = t.readUint64();\n  }), n.createFullBoxCtor(\"saiz\", function(t) {\n    this.flags & 1 && (this.aux_info_type = t.readUint32(), this.aux_info_type_parameter = t.readUint32()), this.default_sample_info_size = t.readUint8();\n    var e = t.readUint32();\n    if (this.sample_info_size = [], this.default_sample_info_size === 0)\n      for (var i = 0; i < e; i++)\n        this.sample_info_size[i] = t.readUint8();\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_METADATA, \"mett\", function(t) {\n    this.parseHeader(t), this.content_encoding = t.readCString(), this.mime_format = t.readCString(), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_METADATA, \"metx\", function(t) {\n    this.parseHeader(t), this.content_encoding = t.readCString(), this.namespace = t.readCString(), this.schema_location = t.readCString(), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE, \"sbtt\", function(t) {\n    this.parseHeader(t), this.content_encoding = t.readCString(), this.mime_format = t.readCString(), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE, \"stpp\", function(t) {\n    this.parseHeader(t), this.namespace = t.readCString(), this.schema_location = t.readCString(), this.auxiliary_mime_types = t.readCString(), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE, \"stxt\", function(t) {\n    this.parseHeader(t), this.content_encoding = t.readCString(), this.mime_format = t.readCString(), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_SUBTITLE, \"tx3g\", function(t) {\n    this.parseHeader(t), this.displayFlags = t.readUint32(), this.horizontal_justification = t.readInt8(), this.vertical_justification = t.readInt8(), this.bg_color_rgba = t.readUint8Array(4), this.box_record = t.readInt16Array(4), this.style_record = t.readUint8Array(12), this.parseFooter(t);\n  }), n.createSampleEntryCtor(n.SAMPLE_ENTRY_TYPE_METADATA, \"wvtt\", function(t) {\n    this.parseHeader(t), this.parseFooter(t);\n  }), n.createSampleGroupCtor(\"alst\", function(t) {\n    var e, i = t.readUint16();\n    for (this.first_output_sample = t.readUint16(), this.sample_offset = [], e = 0; e < i; e++)\n      this.sample_offset[e] = t.readUint32();\n    var s = this.description_length - 4 - 4 * i;\n    for (this.num_output_samples = [], this.num_total_samples = [], e = 0; e < s / 4; e++)\n      this.num_output_samples[e] = t.readUint16(), this.num_total_samples[e] = t.readUint16();\n  }), n.createSampleGroupCtor(\"avll\", function(t) {\n    this.layerNumber = t.readUint8(), this.accurateStatisticsFlag = t.readUint8(), this.avgBitRate = t.readUint16(), this.avgFrameRate = t.readUint16();\n  }), n.createSampleGroupCtor(\"avss\", function(t) {\n    this.subSequenceIdentifier = t.readUint16(), this.layerNumber = t.readUint8();\n    var e = t.readUint8();\n    this.durationFlag = e >> 7, this.avgRateFlag = e >> 6 & 1, this.durationFlag && (this.duration = t.readUint32()), this.avgRateFlag && (this.accurateStatisticsFlag = t.readUint8(), this.avgBitRate = t.readUint16(), this.avgFrameRate = t.readUint16()), this.dependency = [];\n    for (var i = t.readUint8(), s = 0; s < i; s++) {\n      var o = {};\n      this.dependency.push(o), o.subSeqDirectionFlag = t.readUint8(), o.layerNumber = t.readUint8(), o.subSequenceIdentifier = t.readUint16();\n    }\n  }), n.createSampleGroupCtor(\"dtrt\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"mvif\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"prol\", function(t) {\n    this.roll_distance = t.readInt16();\n  }), n.createSampleGroupCtor(\"rap \", function(t) {\n    var e = t.readUint8();\n    this.num_leading_samples_known = e >> 7, this.num_leading_samples = e & 127;\n  }), n.createSampleGroupCtor(\"rash\", function(t) {\n    if (this.operation_point_count = t.readUint16(), this.description_length !== 2 + (this.operation_point_count === 1 ? 2 : this.operation_point_count * 6) + 9)\n      r.warn(\"BoxParser\", \"Mismatch in \" + this.grouping_type + \" sample group length\"), this.data = t.readUint8Array(this.description_length - 2);\n    else {\n      if (this.operation_point_count === 1)\n        this.target_rate_share = t.readUint16();\n      else {\n        this.target_rate_share = [], this.available_bitrate = [];\n        for (var e = 0; e < this.operation_point_count; e++)\n          this.available_bitrate[e] = t.readUint32(), this.target_rate_share[e] = t.readUint16();\n      }\n      this.maximum_bitrate = t.readUint32(), this.minimum_bitrate = t.readUint32(), this.discard_priority = t.readUint8();\n    }\n  }), n.createSampleGroupCtor(\"roll\", function(t) {\n    this.roll_distance = t.readInt16();\n  }), n.SampleGroupEntry.prototype.parse = function(t) {\n    r.warn(\"BoxParser\", \"Unknown Sample Group type: \" + this.grouping_type), this.data = t.readUint8Array(this.description_length);\n  }, n.createSampleGroupCtor(\"scif\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"scnm\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"seig\", function(t) {\n    this.reserved = t.readUint8();\n    var e = t.readUint8();\n    this.crypt_byte_block = e >> 4, this.skip_byte_block = e & 15, this.isProtected = t.readUint8(), this.Per_Sample_IV_Size = t.readUint8(), this.KID = n.parseHex16(t), this.constant_IV_size = 0, this.constant_IV = 0, this.isProtected === 1 && this.Per_Sample_IV_Size === 0 && (this.constant_IV_size = t.readUint8(), this.constant_IV = t.readUint8Array(this.constant_IV_size));\n  }), n.createSampleGroupCtor(\"stsa\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"sync\", function(t) {\n    var e = t.readUint8();\n    this.NAL_unit_type = e & 63;\n  }), n.createSampleGroupCtor(\"tele\", function(t) {\n    var e = t.readUint8();\n    this.level_independently_decodable = e >> 7;\n  }), n.createSampleGroupCtor(\"tsas\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"tscl\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createSampleGroupCtor(\"vipr\", function(t) {\n    r.warn(\"BoxParser\", \"Sample Group type: \" + this.grouping_type + \" not fully parsed\");\n  }), n.createFullBoxCtor(\"sbgp\", function(t) {\n    this.grouping_type = t.readString(4), this.version === 1 ? this.grouping_type_parameter = t.readUint32() : this.grouping_type_parameter = 0, this.entries = [];\n    for (var e = t.readUint32(), i = 0; i < e; i++) {\n      var s = {};\n      this.entries.push(s), s.sample_count = t.readInt32(), s.group_description_index = t.readInt32();\n    }\n  }), n.createFullBoxCtor(\"schm\", function(t) {\n    this.scheme_type = t.readString(4), this.scheme_version = t.readUint32(), this.flags & 1 && (this.scheme_uri = t.readString(this.size - this.hdr_size - 8));\n  }), n.createBoxCtor(\"sdp \", function(t) {\n    this.sdptext = t.readString(this.size - this.hdr_size);\n  }), n.createFullBoxCtor(\"sdtp\", function(t) {\n    var e, i = this.size - this.hdr_size;\n    this.is_leading = [], this.sample_depends_on = [], this.sample_is_depended_on = [], this.sample_has_redundancy = [];\n    for (var s = 0; s < i; s++)\n      e = t.readUint8(), this.is_leading[s] = e >> 6, this.sample_depends_on[s] = e >> 4 & 3, this.sample_is_depended_on[s] = e >> 2 & 3, this.sample_has_redundancy[s] = e & 3;\n  }), n.createFullBoxCtor(\n    \"senc\"\n    /*, function(stream) {\n    \tthis.parseFullHeader(stream);\n    \tvar sample_count = stream.readUint32();\n    \tthis.samples = [];\n    \tfor (var i = 0; i < sample_count; i++) {\n    \t\tvar sample = {};\n    \t\t// tenc.default_Per_Sample_IV_Size or seig.Per_Sample_IV_Size\n    \t\tsample.InitializationVector = this.readUint8Array(Per_Sample_IV_Size*8);\n    \t\tif (this.flags & 0x2) {\n    \t\t\tsample.subsamples = [];\n    \t\t\tsubsample_count = stream.readUint16();\n    \t\t\tfor (var j = 0; j < subsample_count; j++) {\n    \t\t\t\tvar subsample = {};\n    \t\t\t\tsubsample.BytesOfClearData = stream.readUint16();\n    \t\t\t\tsubsample.BytesOfProtectedData = stream.readUint32();\n    \t\t\t\tsample.subsamples.push(subsample);\n    \t\t\t}\n    \t\t}\n    \t\t// TODO\n    \t\tthis.samples.push(sample);\n    \t}\n    }*/\n  ), n.createFullBoxCtor(\"sgpd\", function(t) {\n    this.grouping_type = t.readString(4), r.debug(\"BoxParser\", \"Found Sample Groups of type \" + this.grouping_type), this.version === 1 ? this.default_length = t.readUint32() : this.default_length = 0, this.version >= 2 && (this.default_group_description_index = t.readUint32()), this.entries = [];\n    for (var e = t.readUint32(), i = 0; i < e; i++) {\n      var s;\n      n[this.grouping_type + \"SampleGroupEntry\"] ? s = new n[this.grouping_type + \"SampleGroupEntry\"](this.grouping_type) : s = new n.SampleGroupEntry(this.grouping_type), this.entries.push(s), this.version === 1 ? this.default_length === 0 ? s.description_length = t.readUint32() : s.description_length = this.default_length : s.description_length = this.default_length, s.write === n.SampleGroupEntry.prototype.write && (r.info(\"BoxParser\", \"SampleGroup for type \" + this.grouping_type + \" writing not yet implemented, keeping unparsed data in memory for later write\"), s.data = t.readUint8Array(s.description_length), t.position -= s.description_length), s.parse(t);\n    }\n  }), n.createFullBoxCtor(\"sidx\", function(t) {\n    this.reference_ID = t.readUint32(), this.timescale = t.readUint32(), this.version === 0 ? (this.earliest_presentation_time = t.readUint32(), this.first_offset = t.readUint32()) : (this.earliest_presentation_time = t.readUint64(), this.first_offset = t.readUint64()), t.readUint16(), this.references = [];\n    for (var e = t.readUint16(), i = 0; i < e; i++) {\n      var s = {};\n      this.references.push(s);\n      var o = t.readUint32();\n      s.reference_type = o >> 31 & 1, s.referenced_size = o & 2147483647, s.subsegment_duration = t.readUint32(), o = t.readUint32(), s.starts_with_SAP = o >> 31 & 1, s.SAP_type = o >> 28 & 7, s.SAP_delta_time = o & 268435455;\n    }\n  }), n.SingleItemTypeReferenceBox = function(t, e, i, s) {\n    n.Box.call(this, t, e), this.hdr_size = i, this.start = s;\n  }, n.SingleItemTypeReferenceBox.prototype = new n.Box(), n.SingleItemTypeReferenceBox.prototype.parse = function(t) {\n    this.from_item_ID = t.readUint16();\n    var e = t.readUint16();\n    this.references = [];\n    for (var i = 0; i < e; i++)\n      this.references[i] = t.readUint16();\n  }, n.SingleItemTypeReferenceBoxLarge = function(t, e, i, s) {\n    n.Box.call(this, t, e), this.hdr_size = i, this.start = s;\n  }, n.SingleItemTypeReferenceBoxLarge.prototype = new n.Box(), n.SingleItemTypeReferenceBoxLarge.prototype.parse = function(t) {\n    this.from_item_ID = t.readUint32();\n    var e = t.readUint16();\n    this.references = [];\n    for (var i = 0; i < e; i++)\n      this.references[i] = t.readUint32();\n  }, n.createFullBoxCtor(\"SmDm\", function(t) {\n    this.primaryRChromaticity_x = t.readUint16(), this.primaryRChromaticity_y = t.readUint16(), this.primaryGChromaticity_x = t.readUint16(), this.primaryGChromaticity_y = t.readUint16(), this.primaryBChromaticity_x = t.readUint16(), this.primaryBChromaticity_y = t.readUint16(), this.whitePointChromaticity_x = t.readUint16(), this.whitePointChromaticity_y = t.readUint16(), this.luminanceMax = t.readUint32(), this.luminanceMin = t.readUint32();\n  }), n.createFullBoxCtor(\"smhd\", function(t) {\n    this.balance = t.readUint16(), t.readUint16();\n  }), n.createFullBoxCtor(\"ssix\", function(t) {\n    this.subsegments = [];\n    for (var e = t.readUint32(), i = 0; i < e; i++) {\n      var s = {};\n      this.subsegments.push(s), s.ranges = [];\n      for (var o = t.readUint32(), c = 0; c < o; c++) {\n        var u = {};\n        s.ranges.push(u), u.level = t.readUint8(), u.range_size = t.readUint24();\n      }\n    }\n  }), n.createFullBoxCtor(\"stco\", function(t) {\n    var e;\n    if (e = t.readUint32(), this.chunk_offsets = [], this.version === 0)\n      for (var i = 0; i < e; i++)\n        this.chunk_offsets.push(t.readUint32());\n  }), n.createFullBoxCtor(\"stdp\", function(t) {\n    var e = (this.size - this.hdr_size) / 2;\n    this.priority = [];\n    for (var i = 0; i < e; i++)\n      this.priority[i] = t.readUint16();\n  }), n.createFullBoxCtor(\"sthd\"), n.createFullBoxCtor(\"stri\", function(t) {\n    this.switch_group = t.readUint16(), this.alternate_group = t.readUint16(), this.sub_track_id = t.readUint32();\n    var e = (this.size - this.hdr_size - 8) / 4;\n    this.attribute_list = [];\n    for (var i = 0; i < e; i++)\n      this.attribute_list[i] = t.readUint32();\n  }), n.createFullBoxCtor(\"stsc\", function(t) {\n    var e, i;\n    if (e = t.readUint32(), this.first_chunk = [], this.samples_per_chunk = [], this.sample_description_index = [], this.version === 0)\n      for (i = 0; i < e; i++)\n        this.first_chunk.push(t.readUint32()), this.samples_per_chunk.push(t.readUint32()), this.sample_description_index.push(t.readUint32());\n  }), n.createFullBoxCtor(\"stsd\", function(t) {\n    var e, i, s, o;\n    for (this.entries = [], s = t.readUint32(), e = 1; e <= s; e++)\n      if (i = n.parseOneBox(t, !0, this.size - (t.getPosition() - this.start)), i.code === n.OK)\n        n[i.type + \"SampleEntry\"] ? (o = new n[i.type + \"SampleEntry\"](i.size), o.hdr_size = i.hdr_size, o.start = i.start) : (r.warn(\"BoxParser\", \"Unknown sample entry type: \" + i.type), o = new n.SampleEntry(i.type, i.size, i.hdr_size, i.start)), o.write === n.SampleEntry.prototype.write && (r.info(\"BoxParser\", \"SampleEntry \" + o.type + \" box writing not yet implemented, keeping unparsed data in memory for later write\"), o.parseDataAndRewind(t)), o.parse(t), this.entries.push(o);\n      else\n        return;\n  }), n.createFullBoxCtor(\"stsg\", function(t) {\n    this.grouping_type = t.readUint32();\n    var e = t.readUint16();\n    this.group_description_index = [];\n    for (var i = 0; i < e; i++)\n      this.group_description_index[i] = t.readUint32();\n  }), n.createFullBoxCtor(\"stsh\", function(t) {\n    var e, i;\n    if (e = t.readUint32(), this.shadowed_sample_numbers = [], this.sync_sample_numbers = [], this.version === 0)\n      for (i = 0; i < e; i++)\n        this.shadowed_sample_numbers.push(t.readUint32()), this.sync_sample_numbers.push(t.readUint32());\n  }), n.createFullBoxCtor(\"stss\", function(t) {\n    var e, i;\n    if (i = t.readUint32(), this.version === 0)\n      for (this.sample_numbers = [], e = 0; e < i; e++)\n        this.sample_numbers.push(t.readUint32());\n  }), n.createFullBoxCtor(\"stsz\", function(t) {\n    var e;\n    if (this.sample_sizes = [], this.version === 0)\n      for (this.sample_size = t.readUint32(), this.sample_count = t.readUint32(), e = 0; e < this.sample_count; e++)\n        this.sample_size === 0 ? this.sample_sizes.push(t.readUint32()) : this.sample_sizes[e] = this.sample_size;\n  }), n.createFullBoxCtor(\"stts\", function(t) {\n    var e, i, s;\n    if (e = t.readUint32(), this.sample_counts = [], this.sample_deltas = [], this.version === 0)\n      for (i = 0; i < e; i++)\n        this.sample_counts.push(t.readUint32()), s = t.readInt32(), s < 0 && (r.warn(\"BoxParser\", \"File uses negative stts sample delta, using value 1 instead, sync may be lost!\"), s = 1), this.sample_deltas.push(s);\n  }), n.createFullBoxCtor(\"stvi\", function(t) {\n    var e = t.readUint32();\n    this.single_view_allowed = e & 3, this.stereo_scheme = t.readUint32();\n    var i = t.readUint32();\n    this.stereo_indication_type = t.readString(i);\n    var s, o;\n    for (this.boxes = []; t.getPosition() < this.start + this.size; )\n      if (s = n.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), s.code === n.OK)\n        o = s.box, this.boxes.push(o), this[o.type] = o;\n      else\n        return;\n  }), n.createBoxCtor(\"styp\", function(t) {\n    n.ftypBox.prototype.parse.call(this, t);\n  }), n.createFullBoxCtor(\"stz2\", function(t) {\n    var e, i;\n    if (this.sample_sizes = [], this.version === 0)\n      if (this.reserved = t.readUint24(), this.field_size = t.readUint8(), i = t.readUint32(), this.field_size === 4)\n        for (e = 0; e < i; e += 2) {\n          var s = t.readUint8();\n          this.sample_sizes[e] = s >> 4 & 15, this.sample_sizes[e + 1] = s & 15;\n        }\n      else if (this.field_size === 8)\n        for (e = 0; e < i; e++)\n          this.sample_sizes[e] = t.readUint8();\n      else if (this.field_size === 16)\n        for (e = 0; e < i; e++)\n          this.sample_sizes[e] = t.readUint16();\n      else\n        r.error(\"BoxParser\", \"Error in length field in stz2 box\");\n  }), n.createFullBoxCtor(\"subs\", function(t) {\n    var e, i, s, o;\n    for (s = t.readUint32(), this.entries = [], e = 0; e < s; e++) {\n      var c = {};\n      if (this.entries[e] = c, c.sample_delta = t.readUint32(), c.subsamples = [], o = t.readUint16(), o > 0)\n        for (i = 0; i < o; i++) {\n          var u = {};\n          c.subsamples.push(u), this.version == 1 ? u.size = t.readUint32() : u.size = t.readUint16(), u.priority = t.readUint8(), u.discardable = t.readUint8(), u.codec_specific_parameters = t.readUint32();\n        }\n    }\n  }), n.createFullBoxCtor(\"tenc\", function(t) {\n    if (t.readUint8(), this.version === 0)\n      t.readUint8();\n    else {\n      var e = t.readUint8();\n      this.default_crypt_byte_block = e >> 4 & 15, this.default_skip_byte_block = e & 15;\n    }\n    this.default_isProtected = t.readUint8(), this.default_Per_Sample_IV_Size = t.readUint8(), this.default_KID = n.parseHex16(t), this.default_isProtected === 1 && this.default_Per_Sample_IV_Size === 0 && (this.default_constant_IV_size = t.readUint8(), this.default_constant_IV = t.readUint8Array(this.default_constant_IV_size));\n  }), n.createFullBoxCtor(\"tfdt\", function(t) {\n    this.version == 1 ? this.baseMediaDecodeTime = t.readUint64() : this.baseMediaDecodeTime = t.readUint32();\n  }), n.createFullBoxCtor(\"tfhd\", function(t) {\n    var e = 0;\n    this.track_id = t.readUint32(), this.size - this.hdr_size > e && this.flags & n.TFHD_FLAG_BASE_DATA_OFFSET ? (this.base_data_offset = t.readUint64(), e += 8) : this.base_data_offset = 0, this.size - this.hdr_size > e && this.flags & n.TFHD_FLAG_SAMPLE_DESC ? (this.default_sample_description_index = t.readUint32(), e += 4) : this.default_sample_description_index = 0, this.size - this.hdr_size > e && this.flags & n.TFHD_FLAG_SAMPLE_DUR ? (this.default_sample_duration = t.readUint32(), e += 4) : this.default_sample_duration = 0, this.size - this.hdr_size > e && this.flags & n.TFHD_FLAG_SAMPLE_SIZE ? (this.default_sample_size = t.readUint32(), e += 4) : this.default_sample_size = 0, this.size - this.hdr_size > e && this.flags & n.TFHD_FLAG_SAMPLE_FLAGS ? (this.default_sample_flags = t.readUint32(), e += 4) : this.default_sample_flags = 0;\n  }), n.createFullBoxCtor(\"tfra\", function(t) {\n    this.track_ID = t.readUint32(), t.readUint24();\n    var e = t.readUint8();\n    this.length_size_of_traf_num = e >> 4 & 3, this.length_size_of_trun_num = e >> 2 & 3, this.length_size_of_sample_num = e & 3, this.entries = [];\n    for (var i = t.readUint32(), s = 0; s < i; s++)\n      this.version === 1 ? (this.time = t.readUint64(), this.moof_offset = t.readUint64()) : (this.time = t.readUint32(), this.moof_offset = t.readUint32()), this.traf_number = t[\"readUint\" + 8 * (this.length_size_of_traf_num + 1)](), this.trun_number = t[\"readUint\" + 8 * (this.length_size_of_trun_num + 1)](), this.sample_number = t[\"readUint\" + 8 * (this.length_size_of_sample_num + 1)]();\n  }), n.createFullBoxCtor(\"tkhd\", function(t) {\n    this.version == 1 ? (this.creation_time = t.readUint64(), this.modification_time = t.readUint64(), this.track_id = t.readUint32(), t.readUint32(), this.duration = t.readUint64()) : (this.creation_time = t.readUint32(), this.modification_time = t.readUint32(), this.track_id = t.readUint32(), t.readUint32(), this.duration = t.readUint32()), t.readUint32Array(2), this.layer = t.readInt16(), this.alternate_group = t.readInt16(), this.volume = t.readInt16() >> 8, t.readUint16(), this.matrix = t.readInt32Array(9), this.width = t.readUint32(), this.height = t.readUint32();\n  }), n.createBoxCtor(\"tmax\", function(t) {\n    this.time = t.readUint32();\n  }), n.createBoxCtor(\"tmin\", function(t) {\n    this.time = t.readUint32();\n  }), n.createBoxCtor(\"totl\", function(t) {\n    this.bytessent = t.readUint32();\n  }), n.createBoxCtor(\"tpay\", function(t) {\n    this.bytessent = t.readUint32();\n  }), n.createBoxCtor(\"tpyl\", function(t) {\n    this.bytessent = t.readUint64();\n  }), n.TrackGroupTypeBox.prototype.parse = function(t) {\n    this.parseFullHeader(t), this.track_group_id = t.readUint32();\n  }, n.createTrackGroupCtor(\"msrc\"), n.TrackReferenceTypeBox = function(t, e, i, s) {\n    n.Box.call(this, t, e), this.hdr_size = i, this.start = s;\n  }, n.TrackReferenceTypeBox.prototype = new n.Box(), n.TrackReferenceTypeBox.prototype.parse = function(t) {\n    this.track_ids = t.readUint32Array((this.size - this.hdr_size) / 4);\n  }, n.trefBox.prototype.parse = function(t) {\n    for (var e, i; t.getPosition() < this.start + this.size; )\n      if (e = n.parseOneBox(t, !0, this.size - (t.getPosition() - this.start)), e.code === n.OK)\n        i = new n.TrackReferenceTypeBox(e.type, e.size, e.hdr_size, e.start), i.write === n.Box.prototype.write && i.type !== \"mdat\" && (r.info(\"BoxParser\", \"TrackReference \" + i.type + \" box writing not yet implemented, keeping unparsed data in memory for later write\"), i.parseDataAndRewind(t)), i.parse(t), this.boxes.push(i);\n      else\n        return;\n  }, n.createFullBoxCtor(\"trep\", function(t) {\n    for (this.track_ID = t.readUint32(), this.boxes = []; t.getPosition() < this.start + this.size; )\n      if (ret = n.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), ret.code === n.OK)\n        box = ret.box, this.boxes.push(box);\n      else\n        return;\n  }), n.createFullBoxCtor(\"trex\", function(t) {\n    this.track_id = t.readUint32(), this.default_sample_description_index = t.readUint32(), this.default_sample_duration = t.readUint32(), this.default_sample_size = t.readUint32(), this.default_sample_flags = t.readUint32();\n  }), n.createBoxCtor(\"trpy\", function(t) {\n    this.bytessent = t.readUint64();\n  }), n.createFullBoxCtor(\"trun\", function(t) {\n    var e = 0;\n    if (this.sample_count = t.readUint32(), e += 4, this.size - this.hdr_size > e && this.flags & n.TRUN_FLAGS_DATA_OFFSET ? (this.data_offset = t.readInt32(), e += 4) : this.data_offset = 0, this.size - this.hdr_size > e && this.flags & n.TRUN_FLAGS_FIRST_FLAG ? (this.first_sample_flags = t.readUint32(), e += 4) : this.first_sample_flags = 0, this.sample_duration = [], this.sample_size = [], this.sample_flags = [], this.sample_composition_time_offset = [], this.size - this.hdr_size > e)\n      for (var i = 0; i < this.sample_count; i++)\n        this.flags & n.TRUN_FLAGS_DURATION && (this.sample_duration[i] = t.readUint32()), this.flags & n.TRUN_FLAGS_SIZE && (this.sample_size[i] = t.readUint32()), this.flags & n.TRUN_FLAGS_FLAGS && (this.sample_flags[i] = t.readUint32()), this.flags & n.TRUN_FLAGS_CTS_OFFSET && (this.version === 0 ? this.sample_composition_time_offset[i] = t.readUint32() : this.sample_composition_time_offset[i] = t.readInt32());\n  }), n.createFullBoxCtor(\"tsel\", function(t) {\n    this.switch_group = t.readUint32();\n    var e = (this.size - this.hdr_size - 4) / 4;\n    this.attribute_list = [];\n    for (var i = 0; i < e; i++)\n      this.attribute_list[i] = t.readUint32();\n  }), n.createFullBoxCtor(\"txtC\", function(t) {\n    this.config = t.readCString();\n  }), n.createFullBoxCtor(\"url \", function(t) {\n    this.flags !== 1 && (this.location = t.readCString());\n  }), n.createFullBoxCtor(\"urn \", function(t) {\n    this.name = t.readCString(), this.size - this.hdr_size - this.name.length - 1 > 0 && (this.location = t.readCString());\n  }), n.createUUIDBox(\"a5d40b30e81411ddba2f0800200c9a66\", !0, !1, function(t) {\n    this.LiveServerManifest = t.readString(this.size - this.hdr_size).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n  }), n.createUUIDBox(\"d08a4f1810f34a82b6c832d8aba183d3\", !0, !1, function(t) {\n    this.system_id = n.parseHex16(t);\n    var e = t.readUint32();\n    e > 0 && (this.data = t.readUint8Array(e));\n  }), n.createUUIDBox(\n    \"a2394f525a9b4f14a2446c427c648df4\",\n    !0,\n    !1\n    /*, function(stream) {\n    \tif (this.flags & 0x1) {\n    \t\tthis.AlgorithmID = stream.readUint24();\n    \t\tthis.IV_size = stream.readUint8();\n    \t\tthis.KID = BoxParser.parseHex16(stream);\n    \t}\n    \tvar sample_count = stream.readUint32();\n    \tthis.samples = [];\n    \tfor (var i = 0; i < sample_count; i++) {\n    \t\tvar sample = {};\n    \t\tsample.InitializationVector = this.readUint8Array(this.IV_size*8);\n    \t\tif (this.flags & 0x2) {\n    \t\t\tsample.subsamples = [];\n    \t\t\tsample.NumberOfEntries = stream.readUint16();\n    \t\t\tfor (var j = 0; j < sample.NumberOfEntries; j++) {\n    \t\t\t\tvar subsample = {};\n    \t\t\t\tsubsample.BytesOfClearData = stream.readUint16();\n    \t\t\t\tsubsample.BytesOfProtectedData = stream.readUint32();\n    \t\t\t\tsample.subsamples.push(subsample);\n    \t\t\t}\n    \t\t}\n    \t\tthis.samples.push(sample);\n    \t}\n    }*/\n  ), n.createUUIDBox(\"8974dbce7be74c5184f97148f9882554\", !0, !1, function(t) {\n    this.default_AlgorithmID = t.readUint24(), this.default_IV_size = t.readUint8(), this.default_KID = n.parseHex16(t);\n  }), n.createUUIDBox(\"d4807ef2ca3946958e5426cb9e46a79f\", !0, !1, function(t) {\n    this.fragment_count = t.readUint8(), this.entries = [];\n    for (var e = 0; e < this.fragment_count; e++) {\n      var i = {}, s = 0, o = 0;\n      this.version === 1 ? (s = t.readUint64(), o = t.readUint64()) : (s = t.readUint32(), o = t.readUint32()), i.absolute_time = s, i.absolute_duration = o, this.entries.push(i);\n    }\n  }), n.createUUIDBox(\"6d1d9b0542d544e680e2141daff757b2\", !0, !1, function(t) {\n    this.version === 1 ? (this.absolute_time = t.readUint64(), this.duration = t.readUint64()) : (this.absolute_time = t.readUint32(), this.duration = t.readUint32());\n  }), n.createFullBoxCtor(\"vmhd\", function(t) {\n    this.graphicsmode = t.readUint16(), this.opcolor = t.readUint16Array(3);\n  }), n.createFullBoxCtor(\"vpcC\", function(t) {\n    var e;\n    this.version === 1 ? (this.profile = t.readUint8(), this.level = t.readUint8(), e = t.readUint8(), this.bitDepth = e >> 4, this.chromaSubsampling = e >> 1 & 7, this.videoFullRangeFlag = e & 1, this.colourPrimaries = t.readUint8(), this.transferCharacteristics = t.readUint8(), this.matrixCoefficients = t.readUint8(), this.codecIntializationDataSize = t.readUint16(), this.codecIntializationData = t.readUint8Array(this.codecIntializationDataSize)) : (this.profile = t.readUint8(), this.level = t.readUint8(), e = t.readUint8(), this.bitDepth = e >> 4 & 15, this.colorSpace = e & 15, e = t.readUint8(), this.chromaSubsampling = e >> 4 & 15, this.transferFunction = e >> 1 & 7, this.videoFullRangeFlag = e & 1, this.codecIntializationDataSize = t.readUint16(), this.codecIntializationData = t.readUint8Array(this.codecIntializationDataSize));\n  }), n.createBoxCtor(\"vttC\", function(t) {\n    this.text = t.readString(this.size - this.hdr_size);\n  }), n.createFullBoxCtor(\"vvcC\", function(t) {\n    var e, i, s = {\n      held_bits: void 0,\n      num_held_bits: 0,\n      stream_read_1_bytes: function(x) {\n        this.held_bits = x.readUint8(), this.num_held_bits = 8;\n      },\n      stream_read_2_bytes: function(x) {\n        this.held_bits = x.readUint16(), this.num_held_bits = 16;\n      },\n      extract_bits: function(x) {\n        var P = this.held_bits >> this.num_held_bits - x & (1 << x) - 1;\n        return this.num_held_bits -= x, P;\n      }\n    };\n    if (s.stream_read_1_bytes(t), s.extract_bits(5), this.lengthSizeMinusOne = s.extract_bits(2), this.ptl_present_flag = s.extract_bits(1), this.ptl_present_flag) {\n      s.stream_read_2_bytes(t), this.ols_idx = s.extract_bits(9), this.num_sublayers = s.extract_bits(3), this.constant_frame_rate = s.extract_bits(2), this.chroma_format_idc = s.extract_bits(2), s.stream_read_1_bytes(t), this.bit_depth_minus8 = s.extract_bits(3), s.extract_bits(5);\n      {\n        if (s.stream_read_2_bytes(t), s.extract_bits(2), this.num_bytes_constraint_info = s.extract_bits(6), this.general_profile_idc = s.extract_bits(7), this.general_tier_flag = s.extract_bits(1), this.general_level_idc = t.readUint8(), s.stream_read_1_bytes(t), this.ptl_frame_only_constraint_flag = s.extract_bits(1), this.ptl_multilayer_enabled_flag = s.extract_bits(1), this.general_constraint_info = new Uint8Array(this.num_bytes_constraint_info), this.num_bytes_constraint_info) {\n          for (e = 0; e < this.num_bytes_constraint_info - 1; e++) {\n            var o = s.extract_bits(6);\n            s.stream_read_1_bytes(t);\n            var c = s.extract_bits(2);\n            this.general_constraint_info[e] = o << 2 | c;\n          }\n          this.general_constraint_info[this.num_bytes_constraint_info - 1] = s.extract_bits(6);\n        } else\n          s.extract_bits(6);\n        for (s.stream_read_1_bytes(t), this.ptl_sublayer_present_mask = 0, i = this.num_sublayers - 2; i >= 0; --i) {\n          var u = s.extract_bits(1);\n          this.ptl_sublayer_present_mask |= u << i;\n        }\n        for (i = this.num_sublayers; i <= 8 && this.num_sublayers > 1; ++i)\n          s.extract_bits(1);\n        for (i = this.num_sublayers - 2; i >= 0; --i)\n          this.ptl_sublayer_present_mask & 1 << i && (this.sublayer_level_idc[i] = t.readUint8());\n        if (this.ptl_num_sub_profiles = t.readUint8(), this.general_sub_profile_idc = [], this.ptl_num_sub_profiles)\n          for (e = 0; e < this.ptl_num_sub_profiles; e++)\n            this.general_sub_profile_idc.push(t.readUint32());\n      }\n      this.max_picture_width = t.readUint16(), this.max_picture_height = t.readUint16(), this.avg_frame_rate = t.readUint16();\n    }\n    var _ = 12, g = 13;\n    this.nalu_arrays = [];\n    var w = t.readUint8();\n    for (e = 0; e < w; e++) {\n      var S = [];\n      this.nalu_arrays.push(S), s.stream_read_1_bytes(t), S.completeness = s.extract_bits(1), s.extract_bits(2), S.nalu_type = s.extract_bits(5);\n      var U = 1;\n      for (S.nalu_type != g && S.nalu_type != _ && (U = t.readUint16()), i = 0; i < U; i++) {\n        var C = t.readUint16();\n        S.push({\n          data: t.readUint8Array(C),\n          length: C\n        });\n      }\n    }\n  }), n.createFullBoxCtor(\"vvnC\", function(t) {\n    var e = strm.readUint8();\n    this.lengthSizeMinusOne = e & 3;\n  }), n.SampleEntry.prototype.isVideo = function() {\n    return !1;\n  }, n.SampleEntry.prototype.isAudio = function() {\n    return !1;\n  }, n.SampleEntry.prototype.isSubtitle = function() {\n    return !1;\n  }, n.SampleEntry.prototype.isMetadata = function() {\n    return !1;\n  }, n.SampleEntry.prototype.isHint = function() {\n    return !1;\n  }, n.SampleEntry.prototype.getCodec = function() {\n    return this.type.replace(\".\", \"\");\n  }, n.SampleEntry.prototype.getWidth = function() {\n    return \"\";\n  }, n.SampleEntry.prototype.getHeight = function() {\n    return \"\";\n  }, n.SampleEntry.prototype.getChannelCount = function() {\n    return \"\";\n  }, n.SampleEntry.prototype.getSampleRate = function() {\n    return \"\";\n  }, n.SampleEntry.prototype.getSampleSize = function() {\n    return \"\";\n  }, n.VisualSampleEntry.prototype.isVideo = function() {\n    return !0;\n  }, n.VisualSampleEntry.prototype.getWidth = function() {\n    return this.width;\n  }, n.VisualSampleEntry.prototype.getHeight = function() {\n    return this.height;\n  }, n.AudioSampleEntry.prototype.isAudio = function() {\n    return !0;\n  }, n.AudioSampleEntry.prototype.getChannelCount = function() {\n    return this.channel_count;\n  }, n.AudioSampleEntry.prototype.getSampleRate = function() {\n    return this.samplerate;\n  }, n.AudioSampleEntry.prototype.getSampleSize = function() {\n    return this.samplesize;\n  }, n.SubtitleSampleEntry.prototype.isSubtitle = function() {\n    return !0;\n  }, n.MetadataSampleEntry.prototype.isMetadata = function() {\n    return !0;\n  }, n.decimalToHex = function(t, e) {\n    var i = Number(t).toString(16);\n    for (e = typeof e > \"u\" || e === null ? e = 2 : e; i.length < e; )\n      i = \"0\" + i;\n    return i;\n  }, n.avc1SampleEntry.prototype.getCodec = n.avc2SampleEntry.prototype.getCodec = n.avc3SampleEntry.prototype.getCodec = n.avc4SampleEntry.prototype.getCodec = function() {\n    var t = n.SampleEntry.prototype.getCodec.call(this);\n    return this.avcC ? t + \".\" + n.decimalToHex(this.avcC.AVCProfileIndication) + n.decimalToHex(this.avcC.profile_compatibility) + n.decimalToHex(this.avcC.AVCLevelIndication) : t;\n  }, n.hev1SampleEntry.prototype.getCodec = n.hvc1SampleEntry.prototype.getCodec = function() {\n    var t, e = n.SampleEntry.prototype.getCodec.call(this);\n    if (this.hvcC) {\n      switch (e += \".\", this.hvcC.general_profile_space) {\n        case 0:\n          e += \"\";\n          break;\n        case 1:\n          e += \"A\";\n          break;\n        case 2:\n          e += \"B\";\n          break;\n        case 3:\n          e += \"C\";\n          break;\n      }\n      e += this.hvcC.general_profile_idc, e += \".\";\n      var i = this.hvcC.general_profile_compatibility, s = 0;\n      for (t = 0; t < 32 && (s |= i & 1, t != 31); t++)\n        s <<= 1, i >>= 1;\n      e += n.decimalToHex(s, 0), e += \".\", this.hvcC.general_tier_flag === 0 ? e += \"L\" : e += \"H\", e += this.hvcC.general_level_idc;\n      var o = !1, c = \"\";\n      for (t = 5; t >= 0; t--)\n        (this.hvcC.general_constraint_indicator[t] || o) && (c = \".\" + n.decimalToHex(this.hvcC.general_constraint_indicator[t], 0) + c, o = !0);\n      e += c;\n    }\n    return e;\n  }, n.vvc1SampleEntry.prototype.getCodec = n.vvi1SampleEntry.prototype.getCodec = function() {\n    var t, e = n.SampleEntry.prototype.getCodec.call(this);\n    if (this.vvcC) {\n      e += \".\" + this.vvcC.general_profile_idc, this.vvcC.general_tier_flag ? e += \".H\" : e += \".L\", e += this.vvcC.general_level_idc;\n      var i = \"\";\n      if (this.vvcC.general_constraint_info) {\n        var s = [], o = 0;\n        o |= this.vvcC.ptl_frame_only_constraint << 7, o |= this.vvcC.ptl_multilayer_enabled << 6;\n        var c;\n        for (t = 0; t < this.vvcC.general_constraint_info.length; ++t)\n          o |= this.vvcC.general_constraint_info[t] >> 2 & 63, s.push(o), o && (c = t), o = this.vvcC.general_constraint_info[t] >> 2 & 3;\n        if (c === void 0)\n          i = \".CA\";\n        else {\n          i = \".C\";\n          var u = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\", _ = 0, g = 0;\n          for (t = 0; t <= c; ++t)\n            for (_ = _ << 8 | s[t], g += 8; g >= 5; ) {\n              var w = _ >> g - 5 & 31;\n              i += u[w], g -= 5, _ &= (1 << g) - 1;\n            }\n          g && (_ <<= 5 - g, i += u[_ & 31]);\n        }\n      }\n      e += i;\n    }\n    return e;\n  }, n.mp4aSampleEntry.prototype.getCodec = function() {\n    var t = n.SampleEntry.prototype.getCodec.call(this);\n    if (this.esds && this.esds.esd) {\n      var e = this.esds.esd.getOTI(), i = this.esds.esd.getAudioConfig();\n      return t + \".\" + n.decimalToHex(e) + (i ? \".\" + i : \"\");\n    } else\n      return t;\n  }, n.stxtSampleEntry.prototype.getCodec = function() {\n    var t = n.SampleEntry.prototype.getCodec.call(this);\n    return this.mime_format ? t + \".\" + this.mime_format : t;\n  }, n.vp08SampleEntry.prototype.getCodec = n.vp09SampleEntry.prototype.getCodec = function() {\n    var t = n.SampleEntry.prototype.getCodec.call(this), e = this.vpcC.level;\n    e == 0 && (e = \"00\");\n    var i = this.vpcC.bitDepth;\n    return i == 8 && (i = \"08\"), t + \".0\" + this.vpcC.profile + \".\" + e + \".\" + i;\n  }, n.av01SampleEntry.prototype.getCodec = function() {\n    var t = n.SampleEntry.prototype.getCodec.call(this), e = this.av1C.seq_level_idx_0;\n    e < 10 && (e = \"0\" + e);\n    var i;\n    return this.av1C.seq_profile === 2 && this.av1C.high_bitdepth === 1 ? i = this.av1C.twelve_bit === 1 ? \"12\" : \"10\" : this.av1C.seq_profile <= 2 && (i = this.av1C.high_bitdepth === 1 ? \"10\" : \"08\"), t + \".\" + this.av1C.seq_profile + \".\" + e + (this.av1C.seq_tier_0 ? \"H\" : \"M\") + \".\" + i;\n  }, n.Box.prototype.writeHeader = function(t, e) {\n    this.size += 8, this.size > f && (this.size += 8), this.type === \"uuid\" && (this.size += 16), r.debug(\"BoxWriter\", \"Writing box \" + this.type + \" of size: \" + this.size + \" at position \" + t.getPosition() + (e || \"\")), this.size > f ? t.writeUint32(1) : (this.sizePosition = t.getPosition(), t.writeUint32(this.size)), t.writeString(this.type, null, 4), this.type === \"uuid\" && t.writeUint8Array(this.uuid), this.size > f && t.writeUint64(this.size);\n  }, n.FullBox.prototype.writeHeader = function(t) {\n    this.size += 4, n.Box.prototype.writeHeader.call(this, t, \" v=\" + this.version + \" f=\" + this.flags), t.writeUint8(this.version), t.writeUint24(this.flags);\n  }, n.Box.prototype.write = function(t) {\n    this.type === \"mdat\" ? this.data && (this.size = this.data.length, this.writeHeader(t), t.writeUint8Array(this.data)) : (this.size = this.data ? this.data.length : 0, this.writeHeader(t), this.data && t.writeUint8Array(this.data));\n  }, n.ContainerBox.prototype.write = function(t) {\n    this.size = 0, this.writeHeader(t);\n    for (var e = 0; e < this.boxes.length; e++)\n      this.boxes[e] && (this.boxes[e].write(t), this.size += this.boxes[e].size);\n    r.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size), t.adjustUint32(this.sizePosition, this.size);\n  }, n.TrackReferenceTypeBox.prototype.write = function(t) {\n    this.size = this.track_ids.length * 4, this.writeHeader(t), t.writeUint32Array(this.track_ids);\n  }, n.avcCBox.prototype.write = function(t) {\n    var e;\n    for (this.size = 7, e = 0; e < this.SPS.length; e++)\n      this.size += 2 + this.SPS[e].length;\n    for (e = 0; e < this.PPS.length; e++)\n      this.size += 2 + this.PPS[e].length;\n    for (this.ext && (this.size += this.ext.length), this.writeHeader(t), t.writeUint8(this.configurationVersion), t.writeUint8(this.AVCProfileIndication), t.writeUint8(this.profile_compatibility), t.writeUint8(this.AVCLevelIndication), t.writeUint8(this.lengthSizeMinusOne + 252), t.writeUint8(this.SPS.length + 224), e = 0; e < this.SPS.length; e++)\n      t.writeUint16(this.SPS[e].length), t.writeUint8Array(this.SPS[e].nalu);\n    for (t.writeUint8(this.PPS.length), e = 0; e < this.PPS.length; e++)\n      t.writeUint16(this.PPS[e].length), t.writeUint8Array(this.PPS[e].nalu);\n    this.ext && t.writeUint8Array(this.ext);\n  }, n.co64Box.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.chunk_offsets.length, this.writeHeader(t), t.writeUint32(this.chunk_offsets.length), e = 0; e < this.chunk_offsets.length; e++)\n      t.writeUint64(this.chunk_offsets[e]);\n  }, n.cslgBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 * 5, this.writeHeader(t), t.writeInt32(this.compositionToDTSShift), t.writeInt32(this.leastDecodeToDisplayDelta), t.writeInt32(this.greatestDecodeToDisplayDelta), t.writeInt32(this.compositionStartTime), t.writeInt32(this.compositionEndTime);\n  }, n.cttsBox.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(t), t.writeUint32(this.sample_counts.length), e = 0; e < this.sample_counts.length; e++)\n      t.writeUint32(this.sample_counts[e]), this.version === 1 ? t.writeInt32(this.sample_offsets[e]) : t.writeUint32(this.sample_offsets[e]);\n  }, n.drefBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(t), t.writeUint32(this.entries.length);\n    for (var e = 0; e < this.entries.length; e++)\n      this.entries[e].write(t), this.size += this.entries[e].size;\n    r.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size), t.adjustUint32(this.sizePosition, this.size);\n  }, n.elngBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = this.extended_language.length, this.writeHeader(t), t.writeString(this.extended_language);\n  }, n.elstBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 + 12 * this.entries.length, this.writeHeader(t), t.writeUint32(this.entries.length);\n    for (var e = 0; e < this.entries.length; e++) {\n      var i = this.entries[e];\n      t.writeUint32(i.segment_duration), t.writeInt32(i.media_time), t.writeInt16(i.media_rate_integer), t.writeInt16(i.media_rate_fraction);\n    }\n  }, n.emsgBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 * 4 + this.message_data.length + (this.scheme_id_uri.length + 1) + (this.value.length + 1), this.writeHeader(t), t.writeCString(this.scheme_id_uri), t.writeCString(this.value), t.writeUint32(this.timescale), t.writeUint32(this.presentation_time_delta), t.writeUint32(this.event_duration), t.writeUint32(this.id), t.writeUint8Array(this.message_data);\n  }, n.ftypBox.prototype.write = function(t) {\n    this.size = 8 + 4 * this.compatible_brands.length, this.writeHeader(t), t.writeString(this.major_brand, null, 4), t.writeUint32(this.minor_version);\n    for (var e = 0; e < this.compatible_brands.length; e++)\n      t.writeString(this.compatible_brands[e], null, 4);\n  }, n.hdlrBox.prototype.write = function(t) {\n    this.size = 5 * 4 + this.name.length + 1, this.version = 0, this.flags = 0, this.writeHeader(t), t.writeUint32(0), t.writeString(this.handler, null, 4), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeCString(this.name);\n  }, n.kindBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = this.schemeURI.length + 1 + (this.value.length + 1), this.writeHeader(t), t.writeCString(this.schemeURI), t.writeCString(this.value);\n  }, n.mdhdBox.prototype.write = function(t) {\n    this.size = 4 * 4 + 2 * 2, this.flags = 0, this.version = 0, this.writeHeader(t), t.writeUint32(this.creation_time), t.writeUint32(this.modification_time), t.writeUint32(this.timescale), t.writeUint32(this.duration), t.writeUint16(this.language), t.writeUint16(0);\n  }, n.mehdBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(t), t.writeUint32(this.fragment_duration);\n  }, n.mfhdBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(t), t.writeUint32(this.sequence_number);\n  }, n.mvhdBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 23 * 4 + 2 * 2, this.writeHeader(t), t.writeUint32(this.creation_time), t.writeUint32(this.modification_time), t.writeUint32(this.timescale), t.writeUint32(this.duration), t.writeUint32(this.rate), t.writeUint16(this.volume << 8), t.writeUint16(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32Array(this.matrix), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(this.next_track_id);\n  }, n.SampleEntry.prototype.writeHeader = function(t) {\n    this.size = 8, n.Box.prototype.writeHeader.call(this, t), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint16(this.data_reference_index);\n  }, n.SampleEntry.prototype.writeFooter = function(t) {\n    for (var e = 0; e < this.boxes.length; e++)\n      this.boxes[e].write(t), this.size += this.boxes[e].size;\n    r.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size), t.adjustUint32(this.sizePosition, this.size);\n  }, n.SampleEntry.prototype.write = function(t) {\n    this.writeHeader(t), t.writeUint8Array(this.data), this.size += this.data.length, r.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size), t.adjustUint32(this.sizePosition, this.size);\n  }, n.VisualSampleEntry.prototype.write = function(t) {\n    this.writeHeader(t), this.size += 2 * 7 + 6 * 4 + 32, t.writeUint16(0), t.writeUint16(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint16(this.width), t.writeUint16(this.height), t.writeUint32(this.horizresolution), t.writeUint32(this.vertresolution), t.writeUint32(0), t.writeUint16(this.frame_count), t.writeUint8(Math.min(31, this.compressorname.length)), t.writeString(this.compressorname, null, 31), t.writeUint16(this.depth), t.writeInt16(-1), this.writeFooter(t);\n  }, n.AudioSampleEntry.prototype.write = function(t) {\n    this.writeHeader(t), this.size += 2 * 4 + 3 * 4, t.writeUint32(0), t.writeUint32(0), t.writeUint16(this.channel_count), t.writeUint16(this.samplesize), t.writeUint16(0), t.writeUint16(0), t.writeUint32(this.samplerate << 16), this.writeFooter(t);\n  }, n.stppSampleEntry.prototype.write = function(t) {\n    this.writeHeader(t), this.size += this.namespace.length + 1 + this.schema_location.length + 1 + this.auxiliary_mime_types.length + 1, t.writeCString(this.namespace), t.writeCString(this.schema_location), t.writeCString(this.auxiliary_mime_types), this.writeFooter(t);\n  }, n.SampleGroupEntry.prototype.write = function(t) {\n    t.writeUint8Array(this.data);\n  }, n.sbgpBox.prototype.write = function(t) {\n    this.version = 1, this.flags = 0, this.size = 12 + 8 * this.entries.length, this.writeHeader(t), t.writeString(this.grouping_type, null, 4), t.writeUint32(this.grouping_type_parameter), t.writeUint32(this.entries.length);\n    for (var e = 0; e < this.entries.length; e++) {\n      var i = this.entries[e];\n      t.writeInt32(i.sample_count), t.writeInt32(i.group_description_index);\n    }\n  }, n.sgpdBox.prototype.write = function(t) {\n    var e, i;\n    for (this.flags = 0, this.size = 12, e = 0; e < this.entries.length; e++)\n      i = this.entries[e], this.version === 1 && (this.default_length === 0 && (this.size += 4), this.size += i.data.length);\n    for (this.writeHeader(t), t.writeString(this.grouping_type, null, 4), this.version === 1 && t.writeUint32(this.default_length), this.version >= 2 && t.writeUint32(this.default_sample_description_index), t.writeUint32(this.entries.length), e = 0; e < this.entries.length; e++)\n      i = this.entries[e], this.version === 1 && this.default_length === 0 && t.writeUint32(i.description_length), i.write(t);\n  }, n.sidxBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 * 4 + 2 + 2 + 12 * this.references.length, this.writeHeader(t), t.writeUint32(this.reference_ID), t.writeUint32(this.timescale), t.writeUint32(this.earliest_presentation_time), t.writeUint32(this.first_offset), t.writeUint16(0), t.writeUint16(this.references.length);\n    for (var e = 0; e < this.references.length; e++) {\n      var i = this.references[e];\n      t.writeUint32(i.reference_type << 31 | i.referenced_size), t.writeUint32(i.subsegment_duration), t.writeUint32(i.starts_with_SAP << 31 | i.SAP_type << 28 | i.SAP_delta_time);\n    }\n  }, n.smhdBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 1, this.size = 4, this.writeHeader(t), t.writeUint16(this.balance), t.writeUint16(0);\n  }, n.stcoBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 + 4 * this.chunk_offsets.length, this.writeHeader(t), t.writeUint32(this.chunk_offsets.length), t.writeUint32Array(this.chunk_offsets);\n  }, n.stscBox.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 4 + 12 * this.first_chunk.length, this.writeHeader(t), t.writeUint32(this.first_chunk.length), e = 0; e < this.first_chunk.length; e++)\n      t.writeUint32(this.first_chunk[e]), t.writeUint32(this.samples_per_chunk[e]), t.writeUint32(this.sample_description_index[e]);\n  }, n.stsdBox.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 0, this.writeHeader(t), t.writeUint32(this.entries.length), this.size += 4, e = 0; e < this.entries.length; e++)\n      this.entries[e].write(t), this.size += this.entries[e].size;\n    r.debug(\"BoxWriter\", \"Adjusting box \" + this.type + \" with new size \" + this.size), t.adjustUint32(this.sizePosition, this.size);\n  }, n.stshBox.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.shadowed_sample_numbers.length, this.writeHeader(t), t.writeUint32(this.shadowed_sample_numbers.length), e = 0; e < this.shadowed_sample_numbers.length; e++)\n      t.writeUint32(this.shadowed_sample_numbers[e]), t.writeUint32(this.sync_sample_numbers[e]);\n  }, n.stssBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 + 4 * this.sample_numbers.length, this.writeHeader(t), t.writeUint32(this.sample_numbers.length), t.writeUint32Array(this.sample_numbers);\n  }, n.stszBox.prototype.write = function(t) {\n    var e, i = !0;\n    if (this.version = 0, this.flags = 0, this.sample_sizes.length > 0)\n      for (e = 0; e + 1 < this.sample_sizes.length; )\n        if (this.sample_sizes[e + 1] !== this.sample_sizes[0]) {\n          i = !1;\n          break;\n        } else\n          e++;\n    else\n      i = !1;\n    this.size = 8, i || (this.size += 4 * this.sample_sizes.length), this.writeHeader(t), i ? t.writeUint32(this.sample_sizes[0]) : t.writeUint32(0), t.writeUint32(this.sample_sizes.length), i || t.writeUint32Array(this.sample_sizes);\n  }, n.sttsBox.prototype.write = function(t) {\n    var e;\n    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(t), t.writeUint32(this.sample_counts.length), e = 0; e < this.sample_counts.length; e++)\n      t.writeUint32(this.sample_counts[e]), t.writeUint32(this.sample_deltas[e]);\n  }, n.tfdtBox.prototype.write = function(t) {\n    var e = Math.pow(2, 32) - 1;\n    this.version = this.baseMediaDecodeTime > e ? 1 : 0, this.flags = 0, this.size = 4, this.version === 1 && (this.size += 4), this.writeHeader(t), this.version === 1 ? t.writeUint64(this.baseMediaDecodeTime) : t.writeUint32(this.baseMediaDecodeTime);\n  }, n.tfhdBox.prototype.write = function(t) {\n    this.version = 0, this.size = 4, this.flags & n.TFHD_FLAG_BASE_DATA_OFFSET && (this.size += 8), this.flags & n.TFHD_FLAG_SAMPLE_DESC && (this.size += 4), this.flags & n.TFHD_FLAG_SAMPLE_DUR && (this.size += 4), this.flags & n.TFHD_FLAG_SAMPLE_SIZE && (this.size += 4), this.flags & n.TFHD_FLAG_SAMPLE_FLAGS && (this.size += 4), this.writeHeader(t), t.writeUint32(this.track_id), this.flags & n.TFHD_FLAG_BASE_DATA_OFFSET && t.writeUint64(this.base_data_offset), this.flags & n.TFHD_FLAG_SAMPLE_DESC && t.writeUint32(this.default_sample_description_index), this.flags & n.TFHD_FLAG_SAMPLE_DUR && t.writeUint32(this.default_sample_duration), this.flags & n.TFHD_FLAG_SAMPLE_SIZE && t.writeUint32(this.default_sample_size), this.flags & n.TFHD_FLAG_SAMPLE_FLAGS && t.writeUint32(this.default_sample_flags);\n  }, n.tkhdBox.prototype.write = function(t) {\n    this.version = 0, this.size = 4 * 18 + 2 * 4, this.writeHeader(t), t.writeUint32(this.creation_time), t.writeUint32(this.modification_time), t.writeUint32(this.track_id), t.writeUint32(0), t.writeUint32(this.duration), t.writeUint32(0), t.writeUint32(0), t.writeInt16(this.layer), t.writeInt16(this.alternate_group), t.writeInt16(this.volume << 8), t.writeUint16(0), t.writeInt32Array(this.matrix), t.writeUint32(this.width), t.writeUint32(this.height);\n  }, n.trexBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = 4 * 5, this.writeHeader(t), t.writeUint32(this.track_id), t.writeUint32(this.default_sample_description_index), t.writeUint32(this.default_sample_duration), t.writeUint32(this.default_sample_size), t.writeUint32(this.default_sample_flags);\n  }, n.trunBox.prototype.write = function(t) {\n    this.version = 0, this.size = 4, this.flags & n.TRUN_FLAGS_DATA_OFFSET && (this.size += 4), this.flags & n.TRUN_FLAGS_FIRST_FLAG && (this.size += 4), this.flags & n.TRUN_FLAGS_DURATION && (this.size += 4 * this.sample_duration.length), this.flags & n.TRUN_FLAGS_SIZE && (this.size += 4 * this.sample_size.length), this.flags & n.TRUN_FLAGS_FLAGS && (this.size += 4 * this.sample_flags.length), this.flags & n.TRUN_FLAGS_CTS_OFFSET && (this.size += 4 * this.sample_composition_time_offset.length), this.writeHeader(t), t.writeUint32(this.sample_count), this.flags & n.TRUN_FLAGS_DATA_OFFSET && (this.data_offset_position = t.getPosition(), t.writeInt32(this.data_offset)), this.flags & n.TRUN_FLAGS_FIRST_FLAG && t.writeUint32(this.first_sample_flags);\n    for (var e = 0; e < this.sample_count; e++)\n      this.flags & n.TRUN_FLAGS_DURATION && t.writeUint32(this.sample_duration[e]), this.flags & n.TRUN_FLAGS_SIZE && t.writeUint32(this.sample_size[e]), this.flags & n.TRUN_FLAGS_FLAGS && t.writeUint32(this.sample_flags[e]), this.flags & n.TRUN_FLAGS_CTS_OFFSET && (this.version === 0 ? t.writeUint32(this.sample_composition_time_offset[e]) : t.writeInt32(this.sample_composition_time_offset[e]));\n  }, n[\"url Box\"].prototype.write = function(t) {\n    this.version = 0, this.location ? (this.flags = 0, this.size = this.location.length + 1) : (this.flags = 1, this.size = 0), this.writeHeader(t), this.location && t.writeCString(this.location);\n  }, n[\"urn Box\"].prototype.write = function(t) {\n    this.version = 0, this.flags = 0, this.size = this.name.length + 1 + (this.location ? this.location.length + 1 : 0), this.writeHeader(t), t.writeCString(this.name), this.location && t.writeCString(this.location);\n  }, n.vmhdBox.prototype.write = function(t) {\n    this.version = 0, this.flags = 1, this.size = 8, this.writeHeader(t), t.writeUint16(this.graphicsmode), t.writeUint16Array(this.opcolor);\n  }, n.cttsBox.prototype.unpack = function(t) {\n    var e, i, s;\n    for (s = 0, e = 0; e < this.sample_counts.length; e++)\n      for (i = 0; i < this.sample_counts[e]; i++)\n        t[s].pts = t[s].dts + this.sample_offsets[e], s++;\n  }, n.sttsBox.prototype.unpack = function(t) {\n    var e, i, s;\n    for (s = 0, e = 0; e < this.sample_counts.length; e++)\n      for (i = 0; i < this.sample_counts[e]; i++)\n        s === 0 ? t[s].dts = 0 : t[s].dts = t[s - 1].dts + this.sample_deltas[e], s++;\n  }, n.stcoBox.prototype.unpack = function(t) {\n    var e;\n    for (e = 0; e < this.chunk_offsets.length; e++)\n      t[e].offset = this.chunk_offsets[e];\n  }, n.stscBox.prototype.unpack = function(t) {\n    var e, i, s, o, c;\n    for (o = 0, c = 0, e = 0; e < this.first_chunk.length; e++)\n      for (i = 0; i < (e + 1 < this.first_chunk.length ? this.first_chunk[e + 1] : 1 / 0); i++)\n        for (c++, s = 0; s < this.samples_per_chunk[e]; s++) {\n          if (t[o])\n            t[o].description_index = this.sample_description_index[e], t[o].chunk_index = c;\n          else\n            return;\n          o++;\n        }\n  }, n.stszBox.prototype.unpack = function(t) {\n    var e;\n    for (e = 0; e < this.sample_sizes.length; e++)\n      t[e].size = this.sample_sizes[e];\n  }, n.DIFF_BOXES_PROP_NAMES = [\n    \"boxes\",\n    \"entries\",\n    \"references\",\n    \"subsamples\",\n    \"items\",\n    \"item_infos\",\n    \"extents\",\n    \"associations\",\n    \"subsegments\",\n    \"ranges\",\n    \"seekLists\",\n    \"seekPoints\",\n    \"esd\",\n    \"levels\"\n  ], n.DIFF_PRIMITIVE_ARRAY_PROP_NAMES = [\n    \"compatible_brands\",\n    \"matrix\",\n    \"opcolor\",\n    \"sample_counts\",\n    \"sample_counts\",\n    \"sample_deltas\",\n    \"first_chunk\",\n    \"samples_per_chunk\",\n    \"sample_sizes\",\n    \"chunk_offsets\",\n    \"sample_offsets\",\n    \"sample_description_index\",\n    \"sample_duration\"\n  ], n.boxEqualFields = function(t, e) {\n    if (t && !e) return !1;\n    var i;\n    for (i in t)\n      if (!(n.DIFF_BOXES_PROP_NAMES.indexOf(i) > -1)) {\n        if (t[i] instanceof n.Box || e[i] instanceof n.Box)\n          continue;\n        if (typeof t[i] > \"u\" || typeof e[i] > \"u\")\n          continue;\n        if (typeof t[i] == \"function\" || typeof e[i] == \"function\")\n          continue;\n        if (t.subBoxNames && t.subBoxNames.indexOf(i.slice(0, 4)) > -1 || e.subBoxNames && e.subBoxNames.indexOf(i.slice(0, 4)) > -1)\n          continue;\n        if (i === \"data\" || i === \"start\" || i === \"size\" || i === \"creation_time\" || i === \"modification_time\")\n          continue;\n        if (n.DIFF_PRIMITIVE_ARRAY_PROP_NAMES.indexOf(i) > -1)\n          continue;\n        if (t[i] !== e[i])\n          return !1;\n      }\n    return !0;\n  }, n.boxEqual = function(t, e) {\n    if (!n.boxEqualFields(t, e))\n      return !1;\n    for (var i = 0; i < n.DIFF_BOXES_PROP_NAMES.length; i++) {\n      var s = n.DIFF_BOXES_PROP_NAMES[i];\n      if (t[s] && e[s] && !n.boxEqual(t[s], e[s]))\n        return !1;\n    }\n    return !0;\n  };\n  var v = function() {\n  };\n  v.prototype.parseSample = function(t) {\n    var e = {}, i;\n    e.resources = [];\n    var s = new h(t.data.buffer);\n    if (!t.subsamples || t.subsamples.length === 0)\n      e.documentString = s.readString(t.data.length);\n    else if (e.documentString = s.readString(t.subsamples[0].size), t.subsamples.length > 1)\n      for (i = 1; i < t.subsamples.length; i++)\n        e.resources[i] = s.readUint8Array(t.subsamples[i].size);\n    return typeof DOMParser < \"u\" && (e.document = new DOMParser().parseFromString(e.documentString, \"application/xml\")), e;\n  };\n  var b = function() {\n  };\n  b.prototype.parseSample = function(t) {\n    var e, i = new h(t.data.buffer);\n    return e = i.readString(t.data.length), e;\n  }, b.prototype.parseConfig = function(t) {\n    var e, i = new h(t.buffer);\n    return i.readUint32(), e = i.readCString(), e;\n  }, l.XMLSubtitlein4Parser = v, l.Textin4Parser = b;\n  var y = function(t) {\n    this.stream = t || new d(), this.boxes = [], this.mdats = [], this.moofs = [], this.isProgressive = !1, this.moovStartFound = !1, this.onMoovStart = null, this.moovStartSent = !1, this.onReady = null, this.readySent = !1, this.onSegment = null, this.onSamples = null, this.onError = null, this.sampleListBuilt = !1, this.fragmentedTracks = [], this.extractedTracks = [], this.isFragmentationInitialized = !1, this.sampleProcessingStarted = !1, this.nextMoofNumber = 0, this.itemListBuilt = !1, this.onSidx = null, this.sidxSent = !1;\n  };\n  y.prototype.setSegmentOptions = function(t, e, i) {\n    var s = this.getTrackById(t);\n    if (s) {\n      var o = {};\n      this.fragmentedTracks.push(o), o.id = t, o.user = e, o.trak = s, s.nextSample = 0, o.segmentStream = null, o.nb_samples = 1e3, o.rapAlignement = !0, i && (i.nbSamples && (o.nb_samples = i.nbSamples), i.rapAlignement && (o.rapAlignement = i.rapAlignement));\n    }\n  }, y.prototype.unsetSegmentOptions = function(t) {\n    for (var e = -1, i = 0; i < this.fragmentedTracks.length; i++) {\n      var s = this.fragmentedTracks[i];\n      s.id == t && (e = i);\n    }\n    e > -1 && this.fragmentedTracks.splice(e, 1);\n  }, y.prototype.setExtractionOptions = function(t, e, i) {\n    var s = this.getTrackById(t);\n    if (s) {\n      var o = {};\n      this.extractedTracks.push(o), o.id = t, o.user = e, o.trak = s, s.nextSample = 0, o.nb_samples = 1e3, o.samples = [], i && i.nbSamples && (o.nb_samples = i.nbSamples);\n    }\n  }, y.prototype.unsetExtractionOptions = function(t) {\n    for (var e = -1, i = 0; i < this.extractedTracks.length; i++) {\n      var s = this.extractedTracks[i];\n      s.id == t && (e = i);\n    }\n    e > -1 && this.extractedTracks.splice(e, 1);\n  }, y.prototype.parse = function() {\n    var t, e, i = !1;\n    if (!(this.restoreParsePosition && !this.restoreParsePosition()))\n      for (; ; )\n        if (this.hasIncompleteMdat && this.hasIncompleteMdat()) {\n          if (this.processIncompleteMdat())\n            continue;\n          return;\n        } else if (this.saveParsePosition && this.saveParsePosition(), t = n.parseOneBox(this.stream, i), t.code === n.ERR_NOT_ENOUGH_DATA)\n          if (this.processIncompleteBox) {\n            if (this.processIncompleteBox(t))\n              continue;\n            return;\n          } else\n            return;\n        else {\n          var s;\n          switch (e = t.box, s = e.type !== \"uuid\" ? e.type : e.uuid, this.boxes.push(e), s) {\n            case \"mdat\":\n              this.mdats.push(e);\n              break;\n            case \"moof\":\n              this.moofs.push(e);\n              break;\n            case \"moov\":\n              this.moovStartFound = !0, this.mdats.length === 0 && (this.isProgressive = !0);\n            default:\n              this[s] !== void 0 && r.warn(\"ISOFile\", \"Duplicate Box of type: \" + s + \", overriding previous occurrence\"), this[s] = e;\n              break;\n          }\n          this.updateUsedBytes && this.updateUsedBytes(e, t);\n        }\n  }, y.prototype.checkBuffer = function(t) {\n    if (t == null)\n      throw \"Buffer must be defined and non empty\";\n    if (t.fileStart === void 0)\n      throw \"Buffer must have a fileStart property\";\n    return t.byteLength === 0 ? (r.warn(\"ISOFile\", \"Ignoring empty buffer (fileStart: \" + t.fileStart + \")\"), this.stream.logBufferLevel(), !1) : (r.info(\"ISOFile\", \"Processing buffer (fileStart: \" + t.fileStart + \")\"), t.usedBytes = 0, this.stream.insertBuffer(t), this.stream.logBufferLevel(), this.stream.initialized() ? !0 : (r.warn(\"ISOFile\", \"Not ready to start parsing\"), !1));\n  }, y.prototype.appendBuffer = function(t, e) {\n    var i;\n    if (this.checkBuffer(t))\n      return this.parse(), this.moovStartFound && !this.moovStartSent && (this.moovStartSent = !0, this.onMoovStart && this.onMoovStart()), this.moov ? (this.sampleListBuilt || (this.buildSampleLists(), this.sampleListBuilt = !0), this.updateSampleLists(), this.onReady && !this.readySent && (this.readySent = !0, this.onReady(this.getInfo())), this.processSamples(e), this.nextSeekPosition ? (i = this.nextSeekPosition, this.nextSeekPosition = void 0) : i = this.nextParsePosition, this.stream.getEndFilePositionAfter && (i = this.stream.getEndFilePositionAfter(i))) : this.nextParsePosition ? i = this.nextParsePosition : i = 0, this.sidx && this.onSidx && !this.sidxSent && (this.onSidx(this.sidx), this.sidxSent = !0), this.meta && (this.flattenItemInfo && !this.itemListBuilt && (this.flattenItemInfo(), this.itemListBuilt = !0), this.processItems && this.processItems(this.onItem)), this.stream.cleanBuffers && (r.info(\"ISOFile\", \"Done processing buffer (fileStart: \" + t.fileStart + \") - next buffer to fetch should have a fileStart position of \" + i), this.stream.logBufferLevel(), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0), r.info(\"ISOFile\", \"Sample data size in memory: \" + this.getAllocatedSampleDataSize())), i;\n  }, y.prototype.getInfo = function() {\n    var t, e, i = {}, s, o, c, u, _ = (/* @__PURE__ */ new Date(\"1904-01-01T00:00:00Z\")).getTime();\n    if (this.moov)\n      for (i.hasMoov = !0, i.duration = this.moov.mvhd.duration, i.timescale = this.moov.mvhd.timescale, i.isFragmented = this.moov.mvex != null, i.isFragmented && this.moov.mvex.mehd && (i.fragment_duration = this.moov.mvex.mehd.fragment_duration), i.isProgressive = this.isProgressive, i.hasIOD = this.moov.iods != null, i.brands = [], i.brands.push(this.ftyp.major_brand), i.brands = i.brands.concat(this.ftyp.compatible_brands), i.created = new Date(_ + this.moov.mvhd.creation_time * 1e3), i.modified = new Date(_ + this.moov.mvhd.modification_time * 1e3), i.tracks = [], i.audioTracks = [], i.videoTracks = [], i.subtitleTracks = [], i.metadataTracks = [], i.hintTracks = [], i.otherTracks = [], t = 0; t < this.moov.traks.length; t++) {\n        if (s = this.moov.traks[t], u = s.mdia.minf.stbl.stsd.entries[0], o = {}, i.tracks.push(o), o.id = s.tkhd.track_id, o.name = s.mdia.hdlr.name, o.references = [], s.tref)\n          for (e = 0; e < s.tref.boxes.length; e++)\n            c = {}, o.references.push(c), c.type = s.tref.boxes[e].type, c.track_ids = s.tref.boxes[e].track_ids;\n        s.edts && (o.edits = s.edts.elst.entries), o.created = new Date(_ + s.tkhd.creation_time * 1e3), o.modified = new Date(_ + s.tkhd.modification_time * 1e3), o.movie_duration = s.tkhd.duration, o.movie_timescale = i.timescale, o.layer = s.tkhd.layer, o.alternate_group = s.tkhd.alternate_group, o.volume = s.tkhd.volume, o.matrix = s.tkhd.matrix, o.track_width = s.tkhd.width / 65536, o.track_height = s.tkhd.height / 65536, o.timescale = s.mdia.mdhd.timescale, o.cts_shift = s.mdia.minf.stbl.cslg, o.duration = s.mdia.mdhd.duration, o.samples_duration = s.samples_duration, o.codec = u.getCodec(), o.kind = s.udta && s.udta.kinds.length ? s.udta.kinds[0] : { schemeURI: \"\", value: \"\" }, o.language = s.mdia.elng ? s.mdia.elng.extended_language : s.mdia.mdhd.languageString, o.nb_samples = s.samples.length, o.size = s.samples_size, o.bitrate = o.size * 8 * o.timescale / o.samples_duration, u.isAudio() ? (o.type = \"audio\", i.audioTracks.push(o), o.audio = {}, o.audio.sample_rate = u.getSampleRate(), o.audio.channel_count = u.getChannelCount(), o.audio.sample_size = u.getSampleSize()) : u.isVideo() ? (o.type = \"video\", i.videoTracks.push(o), o.video = {}, o.video.width = u.getWidth(), o.video.height = u.getHeight()) : u.isSubtitle() ? (o.type = \"subtitles\", i.subtitleTracks.push(o)) : u.isHint() ? (o.type = \"metadata\", i.hintTracks.push(o)) : u.isMetadata() ? (o.type = \"metadata\", i.metadataTracks.push(o)) : (o.type = \"metadata\", i.otherTracks.push(o));\n      }\n    else\n      i.hasMoov = !1;\n    if (i.mime = \"\", i.hasMoov && i.tracks) {\n      for (i.videoTracks && i.videoTracks.length > 0 ? i.mime += 'video/mp4; codecs=\"' : i.audioTracks && i.audioTracks.length > 0 ? i.mime += 'audio/mp4; codecs=\"' : i.mime += 'application/mp4; codecs=\"', t = 0; t < i.tracks.length; t++)\n        t !== 0 && (i.mime += \",\"), i.mime += i.tracks[t].codec;\n      i.mime += '\"; profiles=\"', i.mime += this.ftyp.compatible_brands.join(), i.mime += '\"';\n    }\n    return i;\n  }, y.prototype.processSamples = function(t) {\n    var e, i;\n    if (this.sampleProcessingStarted) {\n      if (this.isFragmentationInitialized && this.onSegment !== null)\n        for (e = 0; e < this.fragmentedTracks.length; e++) {\n          var s = this.fragmentedTracks[e];\n          for (i = s.trak; i.nextSample < i.samples.length && this.sampleProcessingStarted; ) {\n            r.debug(\"ISOFile\", \"Creating media fragment on track #\" + s.id + \" for sample \" + i.nextSample);\n            var o = this.createFragment(s.id, i.nextSample, s.segmentStream);\n            if (o)\n              s.segmentStream = o, i.nextSample++;\n            else\n              break;\n            if ((i.nextSample % s.nb_samples === 0 || t || i.nextSample >= i.samples.length) && (r.info(\"ISOFile\", \"Sending fragmented data on track #\" + s.id + \" for samples [\" + Math.max(0, i.nextSample - s.nb_samples) + \",\" + (i.nextSample - 1) + \"]\"), r.info(\"ISOFile\", \"Sample data size in memory: \" + this.getAllocatedSampleDataSize()), this.onSegment && this.onSegment(s.id, s.user, s.segmentStream.buffer, i.nextSample, t || i.nextSample >= i.samples.length), s.segmentStream = null, s !== this.fragmentedTracks[e]))\n              break;\n          }\n        }\n      if (this.onSamples !== null)\n        for (e = 0; e < this.extractedTracks.length; e++) {\n          var c = this.extractedTracks[e];\n          for (i = c.trak; i.nextSample < i.samples.length && this.sampleProcessingStarted; ) {\n            r.debug(\"ISOFile\", \"Exporting on track #\" + c.id + \" sample #\" + i.nextSample);\n            var u = this.getSample(i, i.nextSample);\n            if (u)\n              i.nextSample++, c.samples.push(u);\n            else\n              break;\n            if ((i.nextSample % c.nb_samples === 0 || i.nextSample >= i.samples.length) && (r.debug(\"ISOFile\", \"Sending samples on track #\" + c.id + \" for sample \" + i.nextSample), this.onSamples && this.onSamples(c.id, c.user, c.samples), c.samples = [], c !== this.extractedTracks[e]))\n              break;\n          }\n        }\n    }\n  }, y.prototype.getBox = function(t) {\n    var e = this.getBoxes(t, !0);\n    return e.length ? e[0] : null;\n  }, y.prototype.getBoxes = function(t, e) {\n    var i = [];\n    return y._sweep.call(this, t, i, e), i;\n  }, y._sweep = function(t, e, i) {\n    this.type && this.type == t && e.push(this);\n    for (var s in this.boxes) {\n      if (e.length && i) return;\n      y._sweep.call(this.boxes[s], t, e, i);\n    }\n  }, y.prototype.getTrackSamplesInfo = function(t) {\n    var e = this.getTrackById(t);\n    if (e)\n      return e.samples;\n  }, y.prototype.getTrackSample = function(t, e) {\n    var i = this.getTrackById(t), s = this.getSample(i, e);\n    return s;\n  }, y.prototype.releaseUsedSamples = function(t, e) {\n    var i = 0, s = this.getTrackById(t);\n    s.lastValidSample || (s.lastValidSample = 0);\n    for (var o = s.lastValidSample; o < e; o++)\n      i += this.releaseSample(s, o);\n    r.info(\"ISOFile\", \"Track #\" + t + \" released samples up to \" + e + \" (released size: \" + i + \", remaining: \" + this.samplesDataSize + \")\"), s.lastValidSample = e;\n  }, y.prototype.start = function() {\n    this.sampleProcessingStarted = !0, this.processSamples(!1);\n  }, y.prototype.stop = function() {\n    this.sampleProcessingStarted = !1;\n  }, y.prototype.flush = function() {\n    r.info(\"ISOFile\", \"Flushing remaining samples\"), this.updateSampleLists(), this.processSamples(!0), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0);\n  }, y.prototype.seekTrack = function(t, e, i) {\n    var s, o, c = 1 / 0, u = 0, _ = 0, g;\n    if (i.samples.length === 0)\n      return r.info(\"ISOFile\", \"No sample in track, cannot seek! Using time \" + r.getDurationString(0, 1) + \" and offset: 0\"), { offset: 0, time: 0 };\n    for (s = 0; s < i.samples.length; s++) {\n      if (o = i.samples[s], s === 0)\n        _ = 0, g = o.timescale;\n      else if (o.cts > t * o.timescale) {\n        _ = s - 1;\n        break;\n      }\n      e && o.is_sync && (u = s);\n    }\n    for (e && (_ = u), t = i.samples[_].cts, i.nextSample = _; i.samples[_].alreadyRead === i.samples[_].size && i.samples[_ + 1]; )\n      _++;\n    return c = i.samples[_].offset + i.samples[_].alreadyRead, r.info(\"ISOFile\", \"Seeking to \" + (e ? \"RAP\" : \"\") + \" sample #\" + i.nextSample + \" on track \" + i.tkhd.track_id + \", time \" + r.getDurationString(t, g) + \" and offset: \" + c), { offset: c, time: t / g };\n  }, y.prototype.seek = function(t, e) {\n    var i = this.moov, s, o, c, u = { offset: 1 / 0, time: 1 / 0 };\n    if (this.moov) {\n      for (c = 0; c < i.traks.length; c++)\n        s = i.traks[c], o = this.seekTrack(t, e, s), o.offset < u.offset && (u.offset = o.offset), o.time < u.time && (u.time = o.time);\n      return r.info(\"ISOFile\", \"Seeking at time \" + r.getDurationString(u.time, 1) + \" needs a buffer with a fileStart position of \" + u.offset), u.offset === 1 / 0 ? u = { offset: this.nextParsePosition, time: 0 } : u.offset = this.stream.getEndFilePositionAfter(u.offset), r.info(\"ISOFile\", \"Adjusted seek position (after checking data already in buffer): \" + u.offset), u;\n    } else\n      throw \"Cannot seek: moov not received!\";\n  }, y.prototype.equal = function(t) {\n    for (var e = 0; e < this.boxes.length && e < t.boxes.length; ) {\n      var i = this.boxes[e], s = t.boxes[e];\n      if (!n.boxEqual(i, s))\n        return !1;\n      e++;\n    }\n    return !0;\n  }, l.ISOFile = y, y.prototype.lastBoxStartPosition = 0, y.prototype.parsingMdat = null, y.prototype.nextParsePosition = 0, y.prototype.discardMdatData = !1, y.prototype.processIncompleteBox = function(t) {\n    var e, i, s;\n    return t.type === \"mdat\" ? (e = new n[t.type + \"Box\"](t.size), this.parsingMdat = e, this.boxes.push(e), this.mdats.push(e), e.start = t.start, e.hdr_size = t.hdr_size, this.stream.addUsedBytes(e.hdr_size), this.lastBoxStartPosition = e.start + e.size, s = this.stream.seek(e.start + e.size, !1, this.discardMdatData), s ? (this.parsingMdat = null, !0) : (this.moovStartFound ? this.nextParsePosition = this.stream.findEndContiguousBuf() : this.nextParsePosition = e.start + e.size, !1)) : (t.type === \"moov\" && (this.moovStartFound = !0, this.mdats.length === 0 && (this.isProgressive = !0)), i = this.stream.mergeNextBuffer ? this.stream.mergeNextBuffer() : !1, i ? (this.nextParsePosition = this.stream.getEndPosition(), !0) : (t.type ? this.moovStartFound ? this.nextParsePosition = this.stream.getEndPosition() : this.nextParsePosition = this.stream.getPosition() + t.size : this.nextParsePosition = this.stream.getEndPosition(), !1));\n  }, y.prototype.hasIncompleteMdat = function() {\n    return this.parsingMdat !== null;\n  }, y.prototype.processIncompleteMdat = function() {\n    var t, e;\n    return t = this.parsingMdat, e = this.stream.seek(t.start + t.size, !1, this.discardMdatData), e ? (r.debug(\"ISOFile\", \"Found 'mdat' end in buffered data\"), this.parsingMdat = null, !0) : (this.nextParsePosition = this.stream.findEndContiguousBuf(), !1);\n  }, y.prototype.restoreParsePosition = function() {\n    return this.stream.seek(this.lastBoxStartPosition, !0, this.discardMdatData);\n  }, y.prototype.saveParsePosition = function() {\n    this.lastBoxStartPosition = this.stream.getPosition();\n  }, y.prototype.updateUsedBytes = function(t, e) {\n    this.stream.addUsedBytes && (t.type === \"mdat\" ? (this.stream.addUsedBytes(t.hdr_size), this.discardMdatData && this.stream.addUsedBytes(t.size - t.hdr_size)) : this.stream.addUsedBytes(t.size));\n  }, y.prototype.add = n.Box.prototype.add, y.prototype.addBox = n.Box.prototype.addBox, y.prototype.init = function(t) {\n    var e = t || {};\n    this.add(\"ftyp\").set(\"major_brand\", e.brands && e.brands[0] || \"iso4\").set(\"minor_version\", 0).set(\"compatible_brands\", e.brands || [\"iso4\"]);\n    var i = this.add(\"moov\");\n    return i.add(\"mvhd\").set(\"timescale\", e.timescale || 600).set(\"rate\", e.rate || 65536).set(\"creation_time\", 0).set(\"modification_time\", 0).set(\"duration\", e.duration || 0).set(\"volume\", e.width ? 0 : 256).set(\"matrix\", [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]).set(\"next_track_id\", 1), i.add(\"mvex\"), this;\n  }, y.prototype.addTrack = function(t) {\n    this.moov || this.init(t);\n    var e = t || {};\n    e.width = e.width || 320, e.height = e.height || 320, e.id = e.id || this.moov.mvhd.next_track_id, e.type = e.type || \"avc1\";\n    var i = this.moov.add(\"trak\");\n    this.moov.mvhd.next_track_id = e.id + 1, i.add(\"tkhd\").set(\"flags\", n.TKHD_FLAG_ENABLED | n.TKHD_FLAG_IN_MOVIE | n.TKHD_FLAG_IN_PREVIEW).set(\"creation_time\", 0).set(\"modification_time\", 0).set(\"track_id\", e.id).set(\"duration\", e.duration || 0).set(\"layer\", e.layer || 0).set(\"alternate_group\", 0).set(\"volume\", 1).set(\"matrix\", [0, 0, 0, 0, 0, 0, 0, 0, 0]).set(\"width\", e.width << 16).set(\"height\", e.height << 16);\n    var s = i.add(\"mdia\");\n    s.add(\"mdhd\").set(\"creation_time\", 0).set(\"modification_time\", 0).set(\"timescale\", e.timescale || 1).set(\"duration\", e.media_duration || 0).set(\"language\", e.language || \"und\"), s.add(\"hdlr\").set(\"handler\", e.hdlr || \"vide\").set(\"name\", e.name || \"Track created with MP4Box.js\"), s.add(\"elng\").set(\"extended_language\", e.language || \"fr-FR\");\n    var o = s.add(\"minf\");\n    if (n[e.type + \"SampleEntry\"] !== void 0) {\n      var c = new n[e.type + \"SampleEntry\"]();\n      c.data_reference_index = 1;\n      var u = \"\";\n      for (var _ in n.sampleEntryCodes)\n        for (var g = n.sampleEntryCodes[_], w = 0; w < g.length; w++)\n          if (g.indexOf(e.type) > -1) {\n            u = _;\n            break;\n          }\n      switch (u) {\n        case \"Visual\":\n          if (o.add(\"vmhd\").set(\"graphicsmode\", 0).set(\"opcolor\", [0, 0, 0]), c.set(\"width\", e.width).set(\"height\", e.height).set(\"horizresolution\", 72 << 16).set(\"vertresolution\", 72 << 16).set(\"frame_count\", 1).set(\"compressorname\", e.type + \" Compressor\").set(\"depth\", 24), e.avcDecoderConfigRecord) {\n            var S = new n.avcCBox(), U = new h(e.avcDecoderConfigRecord);\n            S.parse(U), c.addBox(S);\n          }\n          break;\n        case \"Audio\":\n          o.add(\"smhd\").set(\"balance\", e.balance || 0), c.set(\"channel_count\", e.channel_count || 2).set(\"samplesize\", e.samplesize || 16).set(\"samplerate\", e.samplerate || 65536);\n          break;\n        case \"Hint\":\n          o.add(\"hmhd\");\n          break;\n        case \"Subtitle\":\n          switch (o.add(\"sthd\"), e.type) {\n            case \"stpp\":\n              c.set(\"namespace\", e.namespace || \"nonamespace\").set(\"schema_location\", e.schema_location || \"\").set(\"auxiliary_mime_types\", e.auxiliary_mime_types || \"\");\n              break;\n          }\n          break;\n        case \"Metadata\":\n          o.add(\"nmhd\");\n          break;\n        case \"System\":\n          o.add(\"nmhd\");\n          break;\n        default:\n          o.add(\"nmhd\");\n          break;\n      }\n      e.description && c.addBox(e.description), e.description_boxes && e.description_boxes.forEach(function(x) {\n        c.addBox(x);\n      }), o.add(\"dinf\").add(\"dref\").addEntry(new n[\"url Box\"]().set(\"flags\", 1));\n      var C = o.add(\"stbl\");\n      return C.add(\"stsd\").addEntry(c), C.add(\"stts\").set(\"sample_counts\", []).set(\"sample_deltas\", []), C.add(\"stsc\").set(\"first_chunk\", []).set(\"samples_per_chunk\", []).set(\"sample_description_index\", []), C.add(\"stco\").set(\"chunk_offsets\", []), C.add(\"stsz\").set(\"sample_sizes\", []), this.moov.mvex.add(\"trex\").set(\"track_id\", e.id).set(\"default_sample_description_index\", e.default_sample_description_index || 1).set(\"default_sample_duration\", e.default_sample_duration || 0).set(\"default_sample_size\", e.default_sample_size || 0).set(\"default_sample_flags\", e.default_sample_flags || 0), this.buildTrakSampleLists(i), e.id;\n    }\n  }, n.Box.prototype.computeSize = function(t) {\n    var e = t || new a();\n    e.endianness = a.BIG_ENDIAN, this.write(e);\n  }, y.prototype.addSample = function(t, e, i) {\n    var s = i || {}, o = {}, c = this.getTrackById(t);\n    if (c !== null) {\n      o.number = c.samples.length, o.track_id = c.tkhd.track_id, o.timescale = c.mdia.mdhd.timescale, o.description_index = s.sample_description_index ? s.sample_description_index - 1 : 0, o.description = c.mdia.minf.stbl.stsd.entries[o.description_index], o.data = e, o.size = e.byteLength, o.alreadyRead = o.size, o.duration = s.duration || 1, o.cts = s.cts || 0, o.dts = s.dts || 0, o.is_sync = s.is_sync || !1, o.is_leading = s.is_leading || 0, o.depends_on = s.depends_on || 0, o.is_depended_on = s.is_depended_on || 0, o.has_redundancy = s.has_redundancy || 0, o.degradation_priority = s.degradation_priority || 0, o.offset = 0, o.subsamples = s.subsamples, c.samples.push(o), c.samples_size += o.size, c.samples_duration += o.duration, c.first_dts || (c.first_dts = s.dts), this.processSamples();\n      var u = this.createSingleSampleMoof(o);\n      return this.addBox(u), u.computeSize(), u.trafs[0].truns[0].data_offset = u.size + 8, this.add(\"mdat\").data = new Uint8Array(e), o;\n    }\n  }, y.prototype.createSingleSampleMoof = function(t) {\n    var e = 0;\n    t.is_sync ? e = 1 << 25 : e = 65536;\n    var i = new n.moofBox();\n    i.add(\"mfhd\").set(\"sequence_number\", this.nextMoofNumber), this.nextMoofNumber++;\n    var s = i.add(\"traf\"), o = this.getTrackById(t.track_id);\n    return s.add(\"tfhd\").set(\"track_id\", t.track_id).set(\"flags\", n.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), s.add(\"tfdt\").set(\"baseMediaDecodeTime\", t.dts - (o.first_dts || 0)), s.add(\"trun\").set(\"flags\", n.TRUN_FLAGS_DATA_OFFSET | n.TRUN_FLAGS_DURATION | n.TRUN_FLAGS_SIZE | n.TRUN_FLAGS_FLAGS | n.TRUN_FLAGS_CTS_OFFSET).set(\"data_offset\", 0).set(\"first_sample_flags\", 0).set(\"sample_count\", 1).set(\"sample_duration\", [t.duration]).set(\"sample_size\", [t.size]).set(\"sample_flags\", [e]).set(\"sample_composition_time_offset\", [t.cts - t.dts]), i;\n  }, y.prototype.lastMoofIndex = 0, y.prototype.samplesDataSize = 0, y.prototype.resetTables = function() {\n    var t, e, i, s, o, c, u, _;\n    for (this.initial_duration = this.moov.mvhd.duration, this.moov.mvhd.duration = 0, t = 0; t < this.moov.traks.length; t++) {\n      e = this.moov.traks[t], e.tkhd.duration = 0, e.mdia.mdhd.duration = 0, i = e.mdia.minf.stbl.stco || e.mdia.minf.stbl.co64, i.chunk_offsets = [], s = e.mdia.minf.stbl.stsc, s.first_chunk = [], s.samples_per_chunk = [], s.sample_description_index = [], o = e.mdia.minf.stbl.stsz || e.mdia.minf.stbl.stz2, o.sample_sizes = [], c = e.mdia.minf.stbl.stts, c.sample_counts = [], c.sample_deltas = [], u = e.mdia.minf.stbl.ctts, u && (u.sample_counts = [], u.sample_offsets = []), _ = e.mdia.minf.stbl.stss;\n      var g = e.mdia.minf.stbl.boxes.indexOf(_);\n      g != -1 && (e.mdia.minf.stbl.boxes[g] = null);\n    }\n  }, y.initSampleGroups = function(t, e, i, s, o) {\n    var c, u, _, g;\n    function w(S, U, C) {\n      this.grouping_type = S, this.grouping_type_parameter = U, this.sbgp = C, this.last_sample_in_run = -1, this.entry_index = -1;\n    }\n    for (e && (e.sample_groups_info = []), t.sample_groups_info || (t.sample_groups_info = []), u = 0; u < i.length; u++) {\n      for (g = i[u].grouping_type + \"/\" + i[u].grouping_type_parameter, _ = new w(i[u].grouping_type, i[u].grouping_type_parameter, i[u]), e && (e.sample_groups_info[g] = _), t.sample_groups_info[g] || (t.sample_groups_info[g] = _), c = 0; c < s.length; c++)\n        s[c].grouping_type === i[u].grouping_type && (_.description = s[c], _.description.used = !0);\n      if (o)\n        for (c = 0; c < o.length; c++)\n          o[c].grouping_type === i[u].grouping_type && (_.fragment_description = o[c], _.fragment_description.used = !0, _.is_fragment = !0);\n    }\n    if (e) {\n      if (o)\n        for (u = 0; u < o.length; u++)\n          !o[u].used && o[u].version >= 2 && (g = o[u].grouping_type + \"/0\", _ = new w(o[u].grouping_type, 0), _.is_fragment = !0, e.sample_groups_info[g] || (e.sample_groups_info[g] = _));\n    } else\n      for (u = 0; u < s.length; u++)\n        !s[u].used && s[u].version >= 2 && (g = s[u].grouping_type + \"/0\", _ = new w(s[u].grouping_type, 0), t.sample_groups_info[g] || (t.sample_groups_info[g] = _));\n  }, y.setSampleGroupProperties = function(t, e, i, s) {\n    var o, c;\n    e.sample_groups = [];\n    for (o in s)\n      if (e.sample_groups[o] = {}, e.sample_groups[o].grouping_type = s[o].grouping_type, e.sample_groups[o].grouping_type_parameter = s[o].grouping_type_parameter, i >= s[o].last_sample_in_run && (s[o].last_sample_in_run < 0 && (s[o].last_sample_in_run = 0), s[o].entry_index++, s[o].entry_index <= s[o].sbgp.entries.length - 1 && (s[o].last_sample_in_run += s[o].sbgp.entries[s[o].entry_index].sample_count)), s[o].entry_index <= s[o].sbgp.entries.length - 1 ? e.sample_groups[o].group_description_index = s[o].sbgp.entries[s[o].entry_index].group_description_index : e.sample_groups[o].group_description_index = -1, e.sample_groups[o].group_description_index !== 0) {\n        var u;\n        s[o].fragment_description ? u = s[o].fragment_description : u = s[o].description, e.sample_groups[o].group_description_index > 0 ? (e.sample_groups[o].group_description_index > 65535 ? c = (e.sample_groups[o].group_description_index >> 16) - 1 : c = e.sample_groups[o].group_description_index - 1, u && c >= 0 && (e.sample_groups[o].description = u.entries[c])) : u && u.version >= 2 && u.default_group_description_index > 0 && (e.sample_groups[o].description = u.entries[u.default_group_description_index - 1]);\n      }\n  }, y.process_sdtp = function(t, e, i) {\n    e && (t ? (e.is_leading = t.is_leading[i], e.depends_on = t.sample_depends_on[i], e.is_depended_on = t.sample_is_depended_on[i], e.has_redundancy = t.sample_has_redundancy[i]) : (e.is_leading = 0, e.depends_on = 0, e.is_depended_on = 0, e.has_redundancy = 0));\n  }, y.prototype.buildSampleLists = function() {\n    var t, e;\n    for (t = 0; t < this.moov.traks.length; t++)\n      e = this.moov.traks[t], this.buildTrakSampleLists(e);\n  }, y.prototype.buildTrakSampleLists = function(t) {\n    var e, i, s, o, c, u, _, g, w, S, U, C, x, P, T, yt, Ut, ht, O, tt, Ht, ee, et, Et;\n    if (t.samples = [], t.samples_duration = 0, t.samples_size = 0, i = t.mdia.minf.stbl.stco || t.mdia.minf.stbl.co64, s = t.mdia.minf.stbl.stsc, o = t.mdia.minf.stbl.stsz || t.mdia.minf.stbl.stz2, c = t.mdia.minf.stbl.stts, u = t.mdia.minf.stbl.ctts, _ = t.mdia.minf.stbl.stss, g = t.mdia.minf.stbl.stsd, w = t.mdia.minf.stbl.subs, C = t.mdia.minf.stbl.stdp, S = t.mdia.minf.stbl.sbgps, U = t.mdia.minf.stbl.sgpds, ht = -1, O = -1, tt = -1, Ht = -1, ee = 0, et = 0, Et = 0, y.initSampleGroups(t, null, S, U), !(typeof o > \"u\")) {\n      for (e = 0; e < o.sample_sizes.length; e++) {\n        var F = {};\n        F.number = e, F.track_id = t.tkhd.track_id, F.timescale = t.mdia.mdhd.timescale, F.alreadyRead = 0, t.samples[e] = F, F.size = o.sample_sizes[e], t.samples_size += F.size, e === 0 ? (P = 1, x = 0, F.chunk_index = P, F.chunk_run_index = x, Ut = s.samples_per_chunk[x], yt = 0, x + 1 < s.first_chunk.length ? T = s.first_chunk[x + 1] - 1 : T = 1 / 0) : e < Ut ? (F.chunk_index = P, F.chunk_run_index = x) : (P++, F.chunk_index = P, yt = 0, P <= T || (x++, x + 1 < s.first_chunk.length ? T = s.first_chunk[x + 1] - 1 : T = 1 / 0), F.chunk_run_index = x, Ut += s.samples_per_chunk[x]), F.description_index = s.sample_description_index[F.chunk_run_index] - 1, F.description = g.entries[F.description_index], F.offset = i.chunk_offsets[F.chunk_index - 1] + yt, yt += F.size, e > ht && (O++, ht < 0 && (ht = 0), ht += c.sample_counts[O]), e > 0 ? (t.samples[e - 1].duration = c.sample_deltas[O], t.samples_duration += t.samples[e - 1].duration, F.dts = t.samples[e - 1].dts + t.samples[e - 1].duration) : F.dts = 0, u ? (e >= tt && (Ht++, tt < 0 && (tt = 0), tt += u.sample_counts[Ht]), F.cts = t.samples[e].dts + u.sample_offsets[Ht]) : F.cts = F.dts, _ ? (e == _.sample_numbers[ee] - 1 ? (F.is_sync = !0, ee++) : (F.is_sync = !1, F.degradation_priority = 0), w && w.entries[et].sample_delta + Et == e + 1 && (F.subsamples = w.entries[et].subsamples, Et += w.entries[et].sample_delta, et++)) : F.is_sync = !0, y.process_sdtp(t.mdia.minf.stbl.sdtp, F, F.number), C ? F.degradation_priority = C.priority[e] : F.degradation_priority = 0, w && w.entries[et].sample_delta + Et == e && (F.subsamples = w.entries[et].subsamples, Et += w.entries[et].sample_delta), (S.length > 0 || U.length > 0) && y.setSampleGroupProperties(t, F, e, t.sample_groups_info);\n      }\n      e > 0 && (t.samples[e - 1].duration = Math.max(t.mdia.mdhd.duration - t.samples[e - 1].dts, 0), t.samples_duration += t.samples[e - 1].duration);\n    }\n  }, y.prototype.updateSampleLists = function() {\n    var t, e, i, s, o, c, u, _, g, w, S, U, C, x, P;\n    if (this.moov !== void 0) {\n      for (; this.lastMoofIndex < this.moofs.length; )\n        if (g = this.moofs[this.lastMoofIndex], this.lastMoofIndex++, g.type == \"moof\")\n          for (w = g, t = 0; t < w.trafs.length; t++) {\n            for (S = w.trafs[t], U = this.getTrackById(S.tfhd.track_id), C = this.getTrexById(S.tfhd.track_id), S.tfhd.flags & n.TFHD_FLAG_SAMPLE_DESC ? s = S.tfhd.default_sample_description_index : s = C ? C.default_sample_description_index : 1, S.tfhd.flags & n.TFHD_FLAG_SAMPLE_DUR ? o = S.tfhd.default_sample_duration : o = C ? C.default_sample_duration : 0, S.tfhd.flags & n.TFHD_FLAG_SAMPLE_SIZE ? c = S.tfhd.default_sample_size : c = C ? C.default_sample_size : 0, S.tfhd.flags & n.TFHD_FLAG_SAMPLE_FLAGS ? u = S.tfhd.default_sample_flags : u = C ? C.default_sample_flags : 0, S.sample_number = 0, S.sbgps.length > 0 && y.initSampleGroups(U, S, S.sbgps, U.mdia.minf.stbl.sgpds, S.sgpds), e = 0; e < S.truns.length; e++) {\n              var T = S.truns[e];\n              for (i = 0; i < T.sample_count; i++) {\n                x = {}, x.moof_number = this.lastMoofIndex, x.number_in_traf = S.sample_number, S.sample_number++, x.number = U.samples.length, S.first_sample_index = U.samples.length, U.samples.push(x), x.track_id = U.tkhd.track_id, x.timescale = U.mdia.mdhd.timescale, x.description_index = s - 1, x.description = U.mdia.minf.stbl.stsd.entries[x.description_index], x.size = c, T.flags & n.TRUN_FLAGS_SIZE && (x.size = T.sample_size[i]), U.samples_size += x.size, x.duration = o, T.flags & n.TRUN_FLAGS_DURATION && (x.duration = T.sample_duration[i]), U.samples_duration += x.duration, U.first_traf_merged || i > 0 ? x.dts = U.samples[U.samples.length - 2].dts + U.samples[U.samples.length - 2].duration : (S.tfdt ? x.dts = S.tfdt.baseMediaDecodeTime : x.dts = 0, U.first_traf_merged = !0), x.cts = x.dts, T.flags & n.TRUN_FLAGS_CTS_OFFSET && (x.cts = x.dts + T.sample_composition_time_offset[i]), P = u, T.flags & n.TRUN_FLAGS_FLAGS ? P = T.sample_flags[i] : i === 0 && T.flags & n.TRUN_FLAGS_FIRST_FLAG && (P = T.first_sample_flags), x.is_sync = !(P >> 16 & 1), x.is_leading = P >> 26 & 3, x.depends_on = P >> 24 & 3, x.is_depended_on = P >> 22 & 3, x.has_redundancy = P >> 20 & 3, x.degradation_priority = P & 65535;\n                var yt = !!(S.tfhd.flags & n.TFHD_FLAG_BASE_DATA_OFFSET), Ut = !!(S.tfhd.flags & n.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), ht = !!(T.flags & n.TRUN_FLAGS_DATA_OFFSET), O = 0;\n                yt ? O = S.tfhd.base_data_offset : Ut || e === 0 ? O = w.start : O = _, e === 0 && i === 0 ? ht ? x.offset = O + T.data_offset : x.offset = O : x.offset = _, _ = x.offset + x.size, (S.sbgps.length > 0 || S.sgpds.length > 0 || U.mdia.minf.stbl.sbgps.length > 0 || U.mdia.minf.stbl.sgpds.length > 0) && y.setSampleGroupProperties(U, x, x.number_in_traf, S.sample_groups_info);\n              }\n            }\n            if (S.subs) {\n              U.has_fragment_subsamples = !0;\n              var tt = S.first_sample_index;\n              for (e = 0; e < S.subs.entries.length; e++)\n                tt += S.subs.entries[e].sample_delta, x = U.samples[tt - 1], x.subsamples = S.subs.entries[e].subsamples;\n            }\n          }\n    }\n  }, y.prototype.getSample = function(t, e) {\n    var i, s = t.samples[e];\n    if (!this.moov)\n      return null;\n    if (!s.data)\n      s.data = new Uint8Array(s.size), s.alreadyRead = 0, this.samplesDataSize += s.size, r.debug(\"ISOFile\", \"Allocating sample #\" + e + \" on track #\" + t.tkhd.track_id + \" of size \" + s.size + \" (total: \" + this.samplesDataSize + \")\");\n    else if (s.alreadyRead == s.size)\n      return s;\n    for (; ; ) {\n      var o = this.stream.findPosition(!0, s.offset + s.alreadyRead, !1);\n      if (o > -1) {\n        i = this.stream.buffers[o];\n        var c = i.byteLength - (s.offset + s.alreadyRead - i.fileStart);\n        if (s.size - s.alreadyRead <= c)\n          return r.debug(\"ISOFile\", \"Getting sample #\" + e + \" data (alreadyRead: \" + s.alreadyRead + \" offset: \" + (s.offset + s.alreadyRead - i.fileStart) + \" read size: \" + (s.size - s.alreadyRead) + \" full size: \" + s.size + \")\"), a.memcpy(\n            s.data.buffer,\n            s.alreadyRead,\n            i,\n            s.offset + s.alreadyRead - i.fileStart,\n            s.size - s.alreadyRead\n          ), i.usedBytes += s.size - s.alreadyRead, this.stream.logBufferLevel(), s.alreadyRead = s.size, s;\n        if (c === 0) return null;\n        r.debug(\"ISOFile\", \"Getting sample #\" + e + \" partial data (alreadyRead: \" + s.alreadyRead + \" offset: \" + (s.offset + s.alreadyRead - i.fileStart) + \" read size: \" + c + \" full size: \" + s.size + \")\"), a.memcpy(\n          s.data.buffer,\n          s.alreadyRead,\n          i,\n          s.offset + s.alreadyRead - i.fileStart,\n          c\n        ), s.alreadyRead += c, i.usedBytes += c, this.stream.logBufferLevel();\n      } else\n        return null;\n    }\n  }, y.prototype.releaseSample = function(t, e) {\n    var i = t.samples[e];\n    return i.data ? (this.samplesDataSize -= i.size, i.data = null, i.alreadyRead = 0, i.size) : 0;\n  }, y.prototype.getAllocatedSampleDataSize = function() {\n    return this.samplesDataSize;\n  }, y.prototype.getCodecs = function() {\n    var t, e = \"\";\n    for (t = 0; t < this.moov.traks.length; t++) {\n      var i = this.moov.traks[t];\n      t > 0 && (e += \",\"), e += i.mdia.minf.stbl.stsd.entries[0].getCodec();\n    }\n    return e;\n  }, y.prototype.getTrexById = function(t) {\n    var e;\n    if (!this.moov || !this.moov.mvex) return null;\n    for (e = 0; e < this.moov.mvex.trexs.length; e++) {\n      var i = this.moov.mvex.trexs[e];\n      if (i.track_id == t) return i;\n    }\n    return null;\n  }, y.prototype.getTrackById = function(t) {\n    if (this.moov === void 0)\n      return null;\n    for (var e = 0; e < this.moov.traks.length; e++) {\n      var i = this.moov.traks[e];\n      if (i.tkhd.track_id == t) return i;\n    }\n    return null;\n  }, y.prototype.items = [], y.prototype.itemsDataSize = 0, y.prototype.flattenItemInfo = function() {\n    var t = this.items, e, i, s, o = this.meta;\n    if (o != null && o.hdlr !== void 0 && o.iinf !== void 0) {\n      for (e = 0; e < o.iinf.item_infos.length; e++)\n        s = {}, s.id = o.iinf.item_infos[e].item_ID, t[s.id] = s, s.ref_to = [], s.name = o.iinf.item_infos[e].item_name, o.iinf.item_infos[e].protection_index > 0 && (s.protection = o.ipro.protections[o.iinf.item_infos[e].protection_index - 1]), o.iinf.item_infos[e].item_type ? s.type = o.iinf.item_infos[e].item_type : s.type = \"mime\", s.content_type = o.iinf.item_infos[e].content_type, s.content_encoding = o.iinf.item_infos[e].content_encoding;\n      if (o.iloc)\n        for (e = 0; e < o.iloc.items.length; e++) {\n          var c = o.iloc.items[e];\n          switch (s = t[c.item_ID], c.data_reference_index !== 0 && (r.warn(\"Item storage with reference to other files: not supported\"), s.source = o.dinf.boxes[c.data_reference_index - 1]), c.construction_method) {\n            case 0:\n              break;\n            case 1:\n              r.warn(\"Item storage with construction_method : not supported\");\n              break;\n            case 2:\n              r.warn(\"Item storage with construction_method : not supported\");\n              break;\n          }\n          for (s.extents = [], s.size = 0, i = 0; i < c.extents.length; i++)\n            s.extents[i] = {}, s.extents[i].offset = c.extents[i].extent_offset + c.base_offset, s.extents[i].length = c.extents[i].extent_length, s.extents[i].alreadyRead = 0, s.size += s.extents[i].length;\n        }\n      if (o.pitm && (t[o.pitm.item_id].primary = !0), o.iref)\n        for (e = 0; e < o.iref.references.length; e++) {\n          var u = o.iref.references[e];\n          for (i = 0; i < u.references.length; i++)\n            t[u.from_item_ID].ref_to.push({ type: u.type, id: u.references[i] });\n        }\n      if (o.iprp)\n        for (var _ = 0; _ < o.iprp.ipmas.length; _++) {\n          var g = o.iprp.ipmas[_];\n          for (e = 0; e < g.associations.length; e++) {\n            var w = g.associations[e];\n            for (s = t[w.id], s.properties === void 0 && (s.properties = {}, s.properties.boxes = []), i = 0; i < w.props.length; i++) {\n              var S = w.props[i];\n              if (S.property_index > 0 && S.property_index - 1 < o.iprp.ipco.boxes.length) {\n                var U = o.iprp.ipco.boxes[S.property_index - 1];\n                s.properties[U.type] = U, s.properties.boxes.push(U);\n              }\n            }\n          }\n        }\n    }\n  }, y.prototype.getItem = function(t) {\n    var e, i;\n    if (!this.meta)\n      return null;\n    if (i = this.items[t], !i.data && i.size)\n      i.data = new Uint8Array(i.size), i.alreadyRead = 0, this.itemsDataSize += i.size, r.debug(\"ISOFile\", \"Allocating item #\" + t + \" of size \" + i.size + \" (total: \" + this.itemsDataSize + \")\");\n    else if (i.alreadyRead === i.size)\n      return i;\n    for (var s = 0; s < i.extents.length; s++) {\n      var o = i.extents[s];\n      if (o.alreadyRead !== o.length) {\n        var c = this.stream.findPosition(!0, o.offset + o.alreadyRead, !1);\n        if (c > -1) {\n          e = this.stream.buffers[c];\n          var u = e.byteLength - (o.offset + o.alreadyRead - e.fileStart);\n          if (o.length - o.alreadyRead <= u)\n            r.debug(\"ISOFile\", \"Getting item #\" + t + \" extent #\" + s + \" data (alreadyRead: \" + o.alreadyRead + \" offset: \" + (o.offset + o.alreadyRead - e.fileStart) + \" read size: \" + (o.length - o.alreadyRead) + \" full extent size: \" + o.length + \" full item size: \" + i.size + \")\"), a.memcpy(\n              i.data.buffer,\n              i.alreadyRead,\n              e,\n              o.offset + o.alreadyRead - e.fileStart,\n              o.length - o.alreadyRead\n            ), e.usedBytes += o.length - o.alreadyRead, this.stream.logBufferLevel(), i.alreadyRead += o.length - o.alreadyRead, o.alreadyRead = o.length;\n          else\n            return r.debug(\"ISOFile\", \"Getting item #\" + t + \" extent #\" + s + \" partial data (alreadyRead: \" + o.alreadyRead + \" offset: \" + (o.offset + o.alreadyRead - e.fileStart) + \" read size: \" + u + \" full extent size: \" + o.length + \" full item size: \" + i.size + \")\"), a.memcpy(\n              i.data.buffer,\n              i.alreadyRead,\n              e,\n              o.offset + o.alreadyRead - e.fileStart,\n              u\n            ), o.alreadyRead += u, i.alreadyRead += u, e.usedBytes += u, this.stream.logBufferLevel(), null;\n        } else\n          return null;\n      }\n    }\n    return i.alreadyRead === i.size ? i : null;\n  }, y.prototype.releaseItem = function(t) {\n    var e = this.items[t];\n    if (e.data) {\n      this.itemsDataSize -= e.size, e.data = null, e.alreadyRead = 0;\n      for (var i = 0; i < e.extents.length; i++) {\n        var s = e.extents[i];\n        s.alreadyRead = 0;\n      }\n      return e.size;\n    } else\n      return 0;\n  }, y.prototype.processItems = function(t) {\n    for (var e in this.items) {\n      var i = this.items[e];\n      this.getItem(i.id), t && !i.sent && (t(i), i.sent = !0, i.data = null);\n    }\n  }, y.prototype.hasItem = function(t) {\n    for (var e in this.items) {\n      var i = this.items[e];\n      if (i.name === t)\n        return i.id;\n    }\n    return -1;\n  }, y.prototype.getMetaHandler = function() {\n    return this.meta ? this.meta.hdlr.handler : null;\n  }, y.prototype.getPrimaryItem = function() {\n    return !this.meta || !this.meta.pitm ? null : this.getItem(this.meta.pitm.item_id);\n  }, y.prototype.itemToFragmentedTrackFile = function(t) {\n    var e = t || {}, i = null;\n    if (e.itemId ? i = this.getItem(e.itemId) : i = this.getPrimaryItem(), i == null) return null;\n    var s = new y();\n    s.discardMdatData = !1;\n    var o = { type: i.type, description_boxes: i.properties.boxes };\n    i.properties.ispe && (o.width = i.properties.ispe.image_width, o.height = i.properties.ispe.image_height);\n    var c = s.addTrack(o);\n    return c ? (s.addSample(c, i.data), s) : null;\n  }, y.prototype.write = function(t) {\n    for (var e = 0; e < this.boxes.length; e++)\n      this.boxes[e].write(t);\n  }, y.prototype.createFragment = function(t, e, i) {\n    var s = this.getTrackById(t), o = this.getSample(s, e);\n    if (o == null)\n      return o = s.samples[e], this.nextSeekPosition ? this.nextSeekPosition = Math.min(o.offset + o.alreadyRead, this.nextSeekPosition) : this.nextSeekPosition = s.samples[e].offset + o.alreadyRead, null;\n    var c = i || new a();\n    c.endianness = a.BIG_ENDIAN;\n    var u = this.createSingleSampleMoof(o);\n    u.write(c), u.trafs[0].truns[0].data_offset = u.size + 8, r.debug(\"MP4Box\", \"Adjusting data_offset with new value \" + u.trafs[0].truns[0].data_offset), c.adjustUint32(u.trafs[0].truns[0].data_offset_position, u.trafs[0].truns[0].data_offset);\n    var _ = new n.mdatBox();\n    return _.data = o.data, _.write(c), c;\n  }, y.writeInitializationSegment = function(t, e, i, s) {\n    var o;\n    r.debug(\"ISOFile\", \"Generating initialization segment\");\n    var c = new a();\n    c.endianness = a.BIG_ENDIAN, t.write(c);\n    var u = e.add(\"mvex\");\n    for (i && u.add(\"mehd\").set(\"fragment_duration\", i), o = 0; o < e.traks.length; o++)\n      u.add(\"trex\").set(\"track_id\", e.traks[o].tkhd.track_id).set(\"default_sample_description_index\", 1).set(\"default_sample_duration\", s).set(\"default_sample_size\", 0).set(\"default_sample_flags\", 65536);\n    return e.write(c), c.buffer;\n  }, y.prototype.save = function(t) {\n    var e = new a();\n    e.endianness = a.BIG_ENDIAN, this.write(e), e.save(t);\n  }, y.prototype.getBuffer = function() {\n    var t = new a();\n    return t.endianness = a.BIG_ENDIAN, this.write(t), t.buffer;\n  }, y.prototype.initializeSegmentation = function() {\n    var t, e, i, s;\n    for (this.onSegment === null && r.warn(\"MP4Box\", \"No segmentation callback set!\"), this.isFragmentationInitialized || (this.isFragmentationInitialized = !0, this.nextMoofNumber = 0, this.resetTables()), e = [], t = 0; t < this.fragmentedTracks.length; t++) {\n      var o = new n.moovBox();\n      o.mvhd = this.moov.mvhd, o.boxes.push(o.mvhd), i = this.getTrackById(this.fragmentedTracks[t].id), o.boxes.push(i), o.traks.push(i), s = {}, s.id = i.tkhd.track_id, s.user = this.fragmentedTracks[t].user, s.buffer = y.writeInitializationSegment(this.ftyp, o, this.moov.mvex && this.moov.mvex.mehd ? this.moov.mvex.mehd.fragment_duration : void 0, this.moov.traks[t].samples.length > 0 ? this.moov.traks[t].samples[0].duration : 0), e.push(s);\n    }\n    return e;\n  }, n.Box.prototype.printHeader = function(t) {\n    this.size += 8, this.size > f && (this.size += 8), this.type === \"uuid\" && (this.size += 16), t.log(t.indent + \"size:\" + this.size), t.log(t.indent + \"type:\" + this.type);\n  }, n.FullBox.prototype.printHeader = function(t) {\n    this.size += 4, n.Box.prototype.printHeader.call(this, t), t.log(t.indent + \"version:\" + this.version), t.log(t.indent + \"flags:\" + this.flags);\n  }, n.Box.prototype.print = function(t) {\n    this.printHeader(t);\n  }, n.ContainerBox.prototype.print = function(t) {\n    this.printHeader(t);\n    for (var e = 0; e < this.boxes.length; e++)\n      if (this.boxes[e]) {\n        var i = t.indent;\n        t.indent += \" \", this.boxes[e].print(t), t.indent = i;\n      }\n  }, y.prototype.print = function(t) {\n    t.indent = \"\";\n    for (var e = 0; e < this.boxes.length; e++)\n      this.boxes[e] && this.boxes[e].print(t);\n  }, n.mvhdBox.prototype.print = function(t) {\n    n.FullBox.prototype.printHeader.call(this, t), t.log(t.indent + \"creation_time: \" + this.creation_time), t.log(t.indent + \"modification_time: \" + this.modification_time), t.log(t.indent + \"timescale: \" + this.timescale), t.log(t.indent + \"duration: \" + this.duration), t.log(t.indent + \"rate: \" + this.rate), t.log(t.indent + \"volume: \" + (this.volume >> 8)), t.log(t.indent + \"matrix: \" + this.matrix.join(\", \")), t.log(t.indent + \"next_track_id: \" + this.next_track_id);\n  }, n.tkhdBox.prototype.print = function(t) {\n    n.FullBox.prototype.printHeader.call(this, t), t.log(t.indent + \"creation_time: \" + this.creation_time), t.log(t.indent + \"modification_time: \" + this.modification_time), t.log(t.indent + \"track_id: \" + this.track_id), t.log(t.indent + \"duration: \" + this.duration), t.log(t.indent + \"volume: \" + (this.volume >> 8)), t.log(t.indent + \"matrix: \" + this.matrix.join(\", \")), t.log(t.indent + \"layer: \" + this.layer), t.log(t.indent + \"alternate_group: \" + this.alternate_group), t.log(t.indent + \"width: \" + this.width), t.log(t.indent + \"height: \" + this.height);\n  };\n  var B = {};\n  B.createFile = function(t, e) {\n    var i = t !== void 0 ? t : !0, s = new y(e);\n    return s.discardMdatData = !i, s;\n  }, l.createFile = B.createFile;\n})(Ge);\nconst D = /* @__PURE__ */ xi(Ge), q = {\n  sampleRate: 48e3,\n  channelCount: 2,\n  codec: \"mp4a.40.2\"\n};\nfunction de(l, r) {\n  const h = r.videoTracks[0], a = {};\n  if (h != null) {\n    const d = Ui(l.getTrackById(h.id)).buffer, { descKey: p, type: n } = h.codec.startsWith(\"avc1\") ? { descKey: \"avcDecoderConfigRecord\", type: \"avc1\" } : h.codec.startsWith(\"hvc1\") ? { descKey: \"hevcDecoderConfigRecord\", type: \"hvc1\" } : { descKey: \"\", type: \"\" };\n    p !== \"\" && (a.videoTrackConf = {\n      timescale: h.timescale,\n      duration: h.duration,\n      width: h.video.width,\n      height: h.video.height,\n      brands: r.brands,\n      type: n,\n      [p]: d\n    }), a.videoDecoderConf = {\n      codec: h.codec,\n      codedHeight: h.video.height,\n      codedWidth: h.video.width,\n      description: d\n    };\n  }\n  const f = r.audioTracks[0];\n  if (f != null) {\n    const d = Se(l);\n    a.audioTrackConf = {\n      timescale: f.timescale,\n      samplerate: f.audio.sample_rate,\n      channel_count: f.audio.channel_count,\n      hdlr: \"soun\",\n      type: f.codec.startsWith(\"mp4a\") ? \"mp4a\" : f.codec,\n      description: Se(l)\n    }, a.audioDecoderConf = {\n      codec: f.codec.startsWith(\"mp4a\") ? q.codec : f.codec,\n      numberOfChannels: f.audio.channel_count,\n      sampleRate: f.audio.sample_rate,\n      ...d == null ? {} : Ei(d)\n    };\n  }\n  return a;\n}\nfunction Ui(l) {\n  for (const r of l.mdia.minf.stbl.stsd.entries) {\n    const h = r.avcC ?? r.hvcC ?? r.vpcC;\n    if (h != null) {\n      const a = new D.DataStream(\n        void 0,\n        0,\n        D.DataStream.BIG_ENDIAN\n      );\n      return h.write(a), new Uint8Array(a.buffer.slice(8));\n    }\n  }\n  throw Error(\"avcC, hvcC or VPX not found\");\n}\nfunction Se(l, r = \"mp4a\") {\n  var a;\n  const h = (a = l.moov) == null ? void 0 : a.traks.map((f) => f.mdia.minf.stbl.stsd.entries).flat().find(({ type: f }) => f === r);\n  return h == null ? void 0 : h.esds;\n}\nfunction Ei(l) {\n  var n;\n  const r = (n = l.esd.descs[0]) == null ? void 0 : n.descs[0];\n  if (r == null) return {};\n  const [h, a] = r.data, f = ((h & 7) << 1) + (a >> 7), d = (a & 127) >> 3;\n  return {\n    sampleRate: [\n      96e3,\n      88200,\n      64e3,\n      48e3,\n      44100,\n      32e3,\n      24e3,\n      22050,\n      16e3,\n      12e3,\n      11025,\n      8e3,\n      7350\n    ][f],\n    numberOfChannels: d\n  };\n}\nfunction Ai(l) {\n  if (l.moov != null) {\n    for (var r = 0; r < l.moov.traks.length; r++)\n      l.moov.traks[r].samples = [];\n    l.mdats = [], l.moofs = [];\n  }\n}\nvar zt;\nclass ce {\n  constructor() {\n    R(this, \"readable\");\n    R(this, \"writable\");\n    A(this, zt, 0);\n    const r = D.createFile();\n    let h = !1;\n    this.readable = new ReadableStream(\n      {\n        start: (a) => {\n          r.onReady = (d) => {\n            var v, b;\n            const p = (v = d.videoTracks[0]) == null ? void 0 : v.id;\n            p != null && r.setExtractionOptions(p, \"video\", { nbSamples: 100 });\n            const n = (b = d.audioTracks[0]) == null ? void 0 : b.id;\n            n != null && r.setExtractionOptions(n, \"audio\", { nbSamples: 100 }), a.enqueue({ chunkType: \"ready\", data: { info: d, file: r } }), r.start();\n          };\n          const f = {};\n          r.onSamples = (d, p, n) => {\n            a.enqueue({\n              chunkType: \"samples\",\n              data: { id: d, type: p, samples: n.map((v) => ({ ...v })) }\n            }), f[d] = (f[d] ?? 0) + n.length, r.releaseUsedSamples(d, f[d]);\n          }, r.onFlush = () => {\n            a.close();\n          };\n        },\n        cancel: () => {\n          r.stop(), h = !0;\n        }\n      },\n      {\n        highWaterMark: 50\n      }\n    ), this.writable = new WritableStream({\n      write: async (a) => {\n        if (h) {\n          this.writable.abort();\n          return;\n        }\n        const f = a.buffer;\n        f.fileStart = m(this, zt), E(this, zt, m(this, zt) + f.byteLength), r.appendBuffer(f);\n      },\n      close: () => {\n        var a;\n        r.flush(), r.stop(), (a = r.onFlush) == null || a.call(r);\n      }\n    });\n  }\n}\nzt = new WeakMap();\nlet Bi = 0;\nfunction ne(l) {\n  return l.kind === \"file\" && l.createReader instanceof Function;\n}\nvar Tt, Pt, G, K, Lt, st, wt, bt, St, V, Q;\nclass sn {\n  constructor(r, h = {}) {\n    A(this, Tt, z.create(`MP4Clip id:${Bi++},`));\n    R(this, \"ready\");\n    A(this, Pt, !1);\n    A(this, G, {\n      duration: 0,\n      width: 0,\n      height: 0,\n      audioSampleRate: 0,\n      audioChanCount: 0\n    });\n    A(this, K);\n    A(this, Lt, 1);\n    A(this, st, []);\n    A(this, wt, null);\n    A(this, bt, null);\n    A(this, St, {\n      video: null,\n      audio: null\n    });\n    A(this, V, { audio: !0 });\n    R(this, \"tickInterceptor\", async (r, h) => h);\n    A(this, Q, new AbortController());\n    if (!(r instanceof ReadableStream) && !ne(r) && !Array.isArray(r.videoSamples))\n      throw Error(\"Illegal argument\");\n    E(this, V, { audio: !0, ...h }), E(this, Lt, typeof h.audio == \"object\" && \"volume\" in h.audio ? h.audio.volume : 1);\n    const a = async (f) => (await Ct(m(this, K), f), await m(this, K).stream());\n    E(this, K, ne(r) ? r : \"localFile\" in r ? r.localFile : Kt()), this.ready = (r instanceof ReadableStream ? a(r).then((f) => xe(f, m(this, V))) : ne(r) ? r.stream().then((f) => xe(f, m(this, V))) : Promise.resolve(r)).then(async ({ videoSamples: f, audioSamples: d, decoderConf: p }) => {\n      E(this, st, f), E(this, St, p);\n      const { videoFrameFinder: n, audioFrameFinder: v } = Ii(\n        {\n          video: p.video == null ? null : {\n            ...p.video,\n            hardwareAcceleration: m(this, V).__unsafe_hardwareAcceleration__\n          },\n          audio: p.audio\n        },\n        await m(this, K).createReader(),\n        f,\n        d,\n        m(this, V).audio !== !1 ? m(this, Lt) : 0\n      );\n      return E(this, wt, n), E(this, bt, v), E(this, G, Fi(p, f, d)), m(this, Tt).info(\"MP4Clip meta:\", m(this, G)), { ...m(this, G) };\n    });\n  }\n  get meta() {\n    return { ...m(this, G) };\n  }\n  async tick(r) {\n    var f, d;\n    if (r >= m(this, G).duration)\n      return await this.tickInterceptor(r, {\n        audio: [],\n        state: \"done\"\n      });\n    const [h, a] = await Promise.all([\n      ((f = m(this, bt)) == null ? void 0 : f.find(r)) ?? [],\n      (d = m(this, wt)) == null ? void 0 : d.find(r)\n    ]);\n    return a == null ? await this.tickInterceptor(r, {\n      audio: h,\n      state: \"success\"\n    }) : await this.tickInterceptor(r, {\n      video: a,\n      audio: h,\n      state: \"success\"\n    });\n  }\n  async thumbnails(r = 100, h) {\n    m(this, Q).abort(), E(this, Q, new AbortController());\n    const a = m(this, Q).signal;\n    await this.ready;\n    const f = \"generate thumbnails aborted\";\n    if (a.aborted) throw Error(f);\n    const { width: d, height: p } = m(this, G), n = Ue(\n      r,\n      Math.round(p * (r / d)),\n      { quality: 0.1, type: \"image/png\" }\n    );\n    return new Promise(\n      async (v, b) => {\n        let y = [];\n        const B = m(this, St).video;\n        if (B == null || m(this, st).length === 0) {\n          t();\n          return;\n        }\n        a.addEventListener(\"abort\", () => {\n          b(Error(f));\n        });\n        async function t() {\n          a.aborted || v(\n            await Promise.all(\n              y.map(async (_) => ({\n                ts: _.ts,\n                img: await _.img\n              }))\n            )\n          );\n        }\n        function e(_) {\n          y.push({\n            ts: _.timestamp,\n            img: n(_)\n          });\n        }\n        const { start: i = 0, end: s = m(this, G).duration, step: o = 1e6 } = h ?? {};\n        let c = i;\n        const u = new oe(\n          await m(this, K).createReader(),\n          m(this, st),\n          {\n            ...B,\n            hardwareAcceleration: m(this, V).__unsafe_hardwareAcceleration__\n          }\n        );\n        for (; c <= s && !a.aborted; ) {\n          const _ = await u.find(c);\n          _ && e(_), c += o;\n        }\n        u.destroy(), t();\n      }\n    );\n  }\n  async thumbnailsList(r = 100, h) {\n    var v;\n    if (((v = h == null ? void 0 : h.timestamps) == null ? void 0 : v.length) === 0) return [];\n    m(this, Q).abort(), E(this, Q, new AbortController());\n    const a = m(this, Q).signal;\n    await this.ready;\n    const f = \"generate thumbnails aborted\";\n    if (a.aborted) throw Error(f);\n    const { width: d, height: p } = m(this, G), n = Ue(\n      r,\n      Math.round(p * (r / d)),\n      { quality: 0.1, type: \"image/png\" }\n    );\n    return new Promise(\n      async (b, y) => {\n        let B = [];\n        const t = m(this, St).video;\n        if (t == null || m(this, st).length === 0) {\n          e();\n          return;\n        }\n        a.addEventListener(\"abort\", () => {\n          y(Error(f));\n        });\n        async function e() {\n          a.aborted || b(\n            await Promise.all(\n              B.map(async (c) => ({\n                ts: c.ts,\n                img: await c.img\n              }))\n            )\n          );\n        }\n        function i(c) {\n          B.push({\n            ts: c.timestamp,\n            img: n(c)\n          });\n        }\n        const s = (h == null ? void 0 : h.timestamps) ?? [];\n        if (s.length === 0) {\n          e();\n          return;\n        }\n        const o = new oe(\n          await m(this, K).createReader(),\n          m(this, st),\n          {\n            ...t,\n            hardwareAcceleration: m(this, V).__unsafe_hardwareAcceleration__\n          }\n        );\n        for (const c of s) {\n          if (a.aborted) break;\n          const u = await o.find(c);\n          u && i(u);\n        }\n        o.destroy(), e();\n      }\n    );\n  }\n  destroy() {\n    var r, h;\n    m(this, Pt) || (m(this, Tt).info(\"MP4Clip destroy\"), E(this, Pt, !0), (r = m(this, wt)) == null || r.destroy(), (h = m(this, bt)) == null || h.destroy());\n  }\n}\nTt = new WeakMap(), Pt = new WeakMap(), G = new WeakMap(), K = new WeakMap(), Lt = new WeakMap(), st = new WeakMap(), wt = new WeakMap(), bt = new WeakMap(), St = new WeakMap(), V = new WeakMap(), Q = new WeakMap();\nfunction Fi(l, r, h) {\n  const a = {\n    duration: 0,\n    width: 0,\n    height: 0,\n    audioSampleRate: 0,\n    audioChanCount: 0\n  };\n  l.video != null && r.length > 0 && (a.width = l.video.codedWidth ?? 0, a.height = l.video.codedHeight ?? 0), l.audio != null && h.length > 0 && (a.audioSampleRate = q.sampleRate, a.audioChanCount = q.channelCount);\n  let f = 0, d = 0;\n  if (r.length > 0)\n    for (let p = r.length - 1; p >= 0; p--) {\n      const n = r[p];\n      if (!n.deleted) {\n        f = n.cts + n.duration;\n        break;\n      }\n    }\n  if (h.length > 0) {\n    const p = h.at(-1);\n    d = p.cts + p.duration;\n  }\n  return a.duration = Math.max(f, d), a;\n}\nfunction Ii(l, r, h, a, f) {\n  return {\n    audioFrameFinder: f === 0 || l.audio == null || a.length === 0 ? null : new Ci(\n      r,\n      a,\n      l.audio,\n      {\n        volume: f,\n        targetSampleRate: q.sampleRate\n      }\n    ),\n    videoFrameFinder: l.video == null || h.length === 0 ? null : new oe(\n      r,\n      h,\n      l.video\n    )\n  };\n}\nasync function xe(l, r = {}) {\n  let h;\n  const a = { video: null, audio: null };\n  let f = [], d = [];\n  return new Promise(async (n, v) => {\n    let b = -1, y = -1;\n    const B = fe(l.pipeThrough(new ce()), {\n      onChunk: async ({ chunkType: t, data: e }) => {\n        if (t === \"ready\") {\n          h = e.info;\n          let { videoDecoderConf: i, audioDecoderConf: s } = de(e.file, e.info);\n          a.video = i ?? null, a.audio = s ?? null, i == null && s == null && (B(), v(\n            Error(\"MP4Clip must contain at least one video or audio track\")\n          )), z.info(\n            \"mp4BoxFile moov ready\",\n            {\n              ...e.info,\n              tracks: null,\n              videoTracks: null,\n              audioTracks: null\n            },\n            a\n          );\n        } else if (t === \"samples\") {\n          if (e.type === \"video\") {\n            b === -1 && (b = e.samples[0].dts);\n            for (const i of e.samples)\n              f.push(p(i, b, \"video\"));\n          } else if (e.type === \"audio\" && r.audio) {\n            y === -1 && (y = e.samples[0].dts);\n            for (const i of e.samples)\n              d.push(p(i, y, \"audio\"));\n          }\n        }\n      },\n      onDone: () => {\n        const t = f.at(-1) ?? d.at(-1);\n        if (h == null) {\n          v(Error(\"MP4Clip stream is done, but not emit ready\"));\n          return;\n        } else if (t == null) {\n          v(Error(\"MP4Clip stream not contain any sample\"));\n          return;\n        }\n        const e = f[0];\n        e != null && e.cts < 2e5 && (e.duration += e.cts, e.cts = 0), z.info(\"mp4 stream parsed\"), n({\n          videoSamples: f,\n          audioSamples: d,\n          decoderConf: a\n        });\n      }\n    });\n  });\n  function p(n, v = 0, b) {\n    return {\n      ...n,\n      is_idr: b === \"video\" && n.is_sync && Di(n.data, n.description.type),\n      cts: (n.cts - v) / n.timescale * 1e6,\n      dts: (n.dts - v) / n.timescale * 1e6,\n      duration: n.duration / n.timescale * 1e6,\n      timescale: 1e6,\n      data: b === \"video\" ? null : n.data\n    };\n  }\n}\nvar L, lt, ft, kt, dt, W, k, rt, ct, xt, at, Dt, ut, Jt;\nclass oe {\n  constructor(r, h, a) {\n    A(this, L, null);\n    A(this, lt, 0);\n    A(this, ft, { abort: !1, st: performance.now() });\n    R(this, \"find\", async (r) => ((m(this, L) == null || r <= m(this, lt) || r - m(this, lt) > 3e6) && m(this, ut).call(this, r), m(this, ft).abort = !0, E(this, lt, r), E(this, ft, { abort: !1, st: performance.now() }), await m(this, xt).call(this, r, m(this, L), m(this, ft))));\n    // fix VideoFrame duration is null\n    A(this, kt, 0);\n    A(this, dt, !1);\n    A(this, W, 0);\n    A(this, k, []);\n    A(this, rt, 0);\n    A(this, ct, 0);\n    A(this, xt, async (r, h, a) => {\n      if (h == null || h.state === \"closed\" || a.abort) return null;\n      if (m(this, k).length > 0) {\n        const f = m(this, k)[0];\n        return r < f.timestamp ? null : (m(this, k).shift(), r > f.timestamp + (f.duration ?? 0) ? (f.close(), await m(this, xt).call(this, r, h, a)) : (m(this, k).length < 10 && m(this, Dt).call(this, h).catch((d) => {\n          throw m(this, ut).call(this, r), d;\n        }), f));\n      }\n      if (m(this, at) || m(this, rt) < m(this, ct) && h.decodeQueueSize > 0) {\n        if (performance.now() - a.st > 6e3)\n          throw Error(\n            `MP4Clip.tick video timeout, ${JSON.stringify(m(this, Jt).call(this))}`\n          );\n        await Ne(15);\n      } else {\n        if (m(this, W) >= this.samples.length)\n          return null;\n        try {\n          await m(this, Dt).call(this, h);\n        } catch (f) {\n          throw m(this, ut).call(this, r), f;\n        }\n      }\n      return await m(this, xt).call(this, r, h, a);\n    });\n    A(this, at, !1);\n    A(this, Dt, async (r) => {\n      var f, d;\n      if (m(this, at)) return;\n      E(this, at, !0);\n      let h = m(this, W) + 1, a = !1;\n      for (; h < this.samples.length; h++) {\n        const p = this.samples[h];\n        if (!a && !p.deleted && (a = !0), p.is_idr) break;\n      }\n      if (a) {\n        const p = this.samples.slice(m(this, W), h);\n        if (((f = p[0]) == null ? void 0 : f.is_idr) !== !0)\n          z.warn(\"First sample not idr frame\");\n        else {\n          const n = await Li(p, this.localFileReader);\n          if (r.state === \"closed\") return;\n          E(this, kt, ((d = n[0]) == null ? void 0 : d.duration) ?? 0), ki(r, n, {\n            onDecodingError: (v) => {\n              if (m(this, dt))\n                throw v;\n              m(this, rt) === 0 && (E(this, dt, !0), z.warn(\"Downgrade to software decode\"), m(this, ut).call(this));\n            }\n          }), E(this, ct, m(this, ct) + n.length);\n        }\n      }\n      E(this, W, h), E(this, at, !1);\n    });\n    A(this, ut, (r) => {\n      var h, a;\n      if (E(this, at, !1), m(this, k).forEach((f) => f.close()), E(this, k, []), r == null || r === 0)\n        E(this, W, 0);\n      else {\n        let f = 0;\n        for (let d = 0; d < this.samples.length; d++) {\n          const p = this.samples[d];\n          if (p.is_idr && (f = d), !(p.cts < r)) {\n            E(this, W, f);\n            break;\n          }\n        }\n      }\n      E(this, ct, 0), E(this, rt, 0), ((h = m(this, L)) == null ? void 0 : h.state) !== \"closed\" && ((a = m(this, L)) == null || a.close()), E(this, L, new VideoDecoder({\n        output: (f) => {\n          if (E(this, rt, m(this, rt) + 1), f.timestamp === -1) {\n            f.close();\n            return;\n          }\n          let d = f;\n          f.duration == null && (d = new VideoFrame(f, {\n            duration: m(this, kt)\n          }), f.close()), m(this, k).push(d);\n        },\n        error: (f) => {\n          z.error(`MP4Clip VideoDecoder err: ${f.message}`);\n        }\n      })), m(this, L).configure({\n        ...this.conf,\n        ...m(this, dt) ? { hardwareAcceleration: \"prefer-software\" } : {}\n      });\n    });\n    A(this, Jt, () => {\n      var r, h;\n      return {\n        time: m(this, lt),\n        decState: (r = m(this, L)) == null ? void 0 : r.state,\n        decQSize: (h = m(this, L)) == null ? void 0 : h.decodeQueueSize,\n        decCusorIdx: m(this, W),\n        sampleLen: this.samples.length,\n        inputCnt: m(this, ct),\n        outputCnt: m(this, rt),\n        cacheFrameLen: m(this, k).length,\n        softDeocde: m(this, dt)\n      };\n    });\n    R(this, \"destroy\", () => {\n      var r, h;\n      ((r = m(this, L)) == null ? void 0 : r.state) !== \"closed\" && ((h = m(this, L)) == null || h.close()), E(this, L, null), m(this, ft).abort = !0, m(this, k).forEach((a) => a.close()), E(this, k, []), this.localFileReader.close();\n    });\n    this.localFileReader = r, this.samples = h, this.conf = a;\n  }\n}\nL = new WeakMap(), lt = new WeakMap(), ft = new WeakMap(), kt = new WeakMap(), dt = new WeakMap(), W = new WeakMap(), k = new WeakMap(), rt = new WeakMap(), ct = new WeakMap(), xt = new WeakMap(), at = new WeakMap(), Dt = new WeakMap(), ut = new WeakMap(), Jt = new WeakMap();\nvar Rt, Mt, Z, pt, X, J, j, Ot, Nt, $t, qt;\nclass Ci {\n  constructor(r, h, a, f) {\n    A(this, Rt, 1);\n    A(this, Mt);\n    A(this, Z, null);\n    A(this, pt, { abort: !1, st: performance.now() });\n    R(this, \"find\", async (r) => {\n      if (m(this, Z) == null || r <= m(this, X) || r - m(this, X) > 1e5) {\n        m(this, $t).call(this), E(this, X, r);\n        for (let a = 0; a < this.samples.length; a++)\n          if (!(this.samples[a].cts < r)) {\n            E(this, J, a);\n            break;\n          }\n        return [];\n      }\n      m(this, pt).abort = !0;\n      const h = r - m(this, X);\n      return E(this, X, r), E(this, pt, { abort: !1, st: performance.now() }), await m(this, Ot).call(this, h, m(this, Z), m(this, pt));\n    });\n    A(this, X, 0);\n    A(this, J, 0);\n    A(this, j, {\n      frameCnt: 0,\n      data: []\n    });\n    A(this, Ot, async (r, h = null, a) => {\n      if (h == null || a.abort || h.state === \"closed\") return [];\n      const f = Math.ceil(r * (m(this, Mt) / 1e6));\n      if (f === 0) return [];\n      const d = m(this, j).frameCnt - f;\n      if (d > 0)\n        return d < q.sampleRate / 10 && m(this, Nt).call(this, h), Pi(m(this, j), f);\n      if (h.decodeQueueSize > 10) {\n        if (performance.now() - a.st > 3e3)\n          throw a.abort = !0, Error(\n            `MP4Clip.tick audio timeout, ${JSON.stringify(m(this, qt).call(this))}`\n          );\n        await Ne(15);\n      } else {\n        if (m(this, J) >= this.samples.length - 1)\n          return [];\n        m(this, Nt).call(this, h);\n      }\n      return m(this, Ot).call(this, r, h, a);\n    });\n    A(this, Nt, (r) => {\n      if (r.decodeQueueSize > 100) return;\n      const h = [];\n      let a = m(this, J);\n      for (; a < this.samples.length; ) {\n        const f = this.samples[a];\n        if (a += 1, !f.deleted && (h.push(f), h.length >= 10))\n          break;\n      }\n      E(this, J, a), r.decode(\n        h.map(\n          (f) => new EncodedAudioChunk({\n            type: \"key\",\n            timestamp: f.cts,\n            duration: f.duration,\n            data: f.data\n          })\n        )\n      );\n    });\n    A(this, $t, () => {\n      var r;\n      E(this, X, 0), E(this, J, 0), E(this, j, {\n        frameCnt: 0,\n        data: []\n      }), (r = m(this, Z)) == null || r.close(), E(this, Z, zi(\n        this.conf,\n        {\n          resampleRate: q.sampleRate,\n          volume: m(this, Rt)\n        },\n        (h) => {\n          m(this, j).data.push(h), m(this, j).frameCnt += h[0].length;\n        }\n      ));\n    });\n    A(this, qt, () => {\n      var r, h;\n      return {\n        time: m(this, X),\n        decState: (r = m(this, Z)) == null ? void 0 : r.state,\n        decQSize: (h = m(this, Z)) == null ? void 0 : h.decodeQueueSize,\n        decCusorIdx: m(this, J),\n        sampleLen: this.samples.length,\n        pcmLen: m(this, j).frameCnt\n      };\n    });\n    R(this, \"destroy\", () => {\n      E(this, Z, null), m(this, pt).abort = !0, E(this, j, {\n        frameCnt: 0,\n        data: []\n      }), this.localFileReader.close();\n    });\n    this.localFileReader = r, this.samples = h, this.conf = a, E(this, Rt, f.volume), E(this, Mt, f.targetSampleRate);\n  }\n}\nRt = new WeakMap(), Mt = new WeakMap(), Z = new WeakMap(), pt = new WeakMap(), X = new WeakMap(), J = new WeakMap(), j = new WeakMap(), Ot = new WeakMap(), Nt = new WeakMap(), $t = new WeakMap(), qt = new WeakMap();\nfunction zi(l, r, h) {\n  const a = (n) => {\n    if (n.length !== 0) {\n      if (r.volume !== 1)\n        for (const v of n)\n          for (let b = 0; b < v.length; b++) v[b] *= r.volume;\n      n.length === 1 && (n = [n[0], n[0]]), h(n);\n    }\n  }, f = Ti(a), d = r.resampleRate !== l.sampleRate, p = new AudioDecoder({\n    output: (n) => {\n      const v = le(n);\n      d ? f(\n        () => bi(v, n.sampleRate, {\n          rate: r.resampleRate,\n          chanCount: n.numberOfChannels\n        })\n      ) : a(v), n.close();\n    },\n    error: (n) => {\n      z.error(`MP4Clip AudioDecoder err: ${n.message}`);\n    }\n  });\n  return p.configure(l), {\n    decode(n) {\n      for (const v of n) p.decode(v);\n    },\n    close() {\n      p.state !== \"closed\" && p.close();\n    },\n    get state() {\n      return p.state;\n    },\n    get decodeQueueSize() {\n      return p.decodeQueueSize;\n    }\n  };\n}\nfunction Ti(l) {\n  const r = [];\n  let h = 0;\n  function a(p, n) {\n    r[n] = p, f();\n  }\n  function f() {\n    const p = r[h];\n    p != null && (l(p), h += 1, f());\n  }\n  let d = 0;\n  return (p) => {\n    const n = d;\n    d += 1, p().then((v) => a(v, n)).catch((v) => a(v, n));\n  };\n}\nfunction Pi(l, r) {\n  const h = [new Float32Array(r), new Float32Array(r)];\n  let a = 0, f = 0;\n  for (; f < l.data.length; ) {\n    const [d, p] = l.data[f];\n    if (a + d.length > r) {\n      const n = r - a;\n      h[0].set(d.subarray(0, n), a), h[1].set(p.subarray(0, n), a), l.data[f][0] = d.subarray(n, d.length), l.data[f][1] = p.subarray(n, p.length);\n      break;\n    } else\n      h[0].set(d, a), h[1].set(p, a), a += d.length, f++;\n  }\n  return l.data = l.data.slice(f), l.frameCnt -= r, h;\n}\nasync function Li(l, r) {\n  const h = l[0], a = l.at(-1);\n  if (a == null) return [];\n  const f = a.offset + a.size - h.offset;\n  if (f < 3e7) {\n    const d = new Uint8Array(\n      await r.read(f, { at: h.offset })\n    );\n    return l.map((p) => {\n      const n = p.offset - h.offset;\n      let v = d.subarray(n, n + p.size);\n      return p.is_idr && (v = Ee(v)), new EncodedVideoChunk({\n        type: p.is_sync ? \"key\" : \"delta\",\n        timestamp: p.cts,\n        duration: p.duration,\n        data: v\n      });\n    });\n  }\n  return await Promise.all(\n    l.map(async (d) => {\n      let p = await r.read(d.size, {\n        at: d.offset\n      });\n      return d.is_idr && (p = Ee(new Uint8Array(p))), new EncodedVideoChunk({\n        type: d.is_sync ? \"key\" : \"delta\",\n        timestamp: d.cts,\n        duration: d.duration,\n        data: p\n      });\n    })\n  );\n}\nfunction Ue(l, r, h) {\n  const a = new OffscreenCanvas(l, r), f = a.getContext(\"2d\");\n  return async (d) => (f.drawImage(d, 0, 0, l, r), d.close(), await a.convertToBlob(h));\n}\nfunction ki(l, r, h) {\n  let a = 0;\n  if (l.state === \"configured\") {\n    for (; a < r.length; a++) l.decode(r[a]);\n    l.flush().catch((f) => {\n      if (!(f instanceof Error)) throw f;\n      if (f.message.includes(\"Decoding error\") && h.onDecodingError != null) {\n        h.onDecodingError(f);\n        return;\n      }\n      if (!f.message.includes(\"Aborted due to close\"))\n        throw f;\n    });\n  }\n}\nfunction Ee(l) {\n  const r = new DataView(l.buffer, l.byteOffset, l.byteLength);\n  return (r.getUint8(4) & 31) === 6 ? l.subarray(r.getUint32(0) + 4) : l;\n}\nfunction Di(l, r) {\n  if (r !== \"avc1\" && r !== \"hvc1\") return !1;\n  const h = new DataView(l.buffer);\n  let a = 0;\n  for (; a < l.byteLength - 4; ) {\n    if (r === \"avc1\") {\n      if ((h.getUint8(a + 4) & 31) === 5) return !0;\n    } else if (r === \"hvc1\" && (h.getUint8(a + 4) >> 1 & 63) === 20)\n      return !0;\n    a += h.getUint32(a) + 4;\n  }\n  return !1;\n}\nvar $;\nclass Ri {\n  constructor() {\n    A(this, $, /* @__PURE__ */ new Map());\n    R(this, \"on\", (r, h) => {\n      const a = m(this, $).get(r) ?? /* @__PURE__ */ new Set();\n      return a.add(h), m(this, $).has(r) || m(this, $).set(r, a), () => {\n        a.delete(h), a.size === 0 && m(this, $).delete(r);\n      };\n    });\n    R(this, \"once\", (r, h) => {\n      const a = this.on(r, (...f) => {\n        a(), h(...f);\n      });\n      return a;\n    });\n    R(this, \"emit\", (r, ...h) => {\n      const a = m(this, $).get(r);\n      a != null && a.forEach((f) => f(...h));\n    });\n  }\n  static forwardEvent(r, h, a) {\n    const f = a.map((d) => {\n      const [p, n] = Array.isArray(d) ? d : [d, d];\n      return r.on(p, (...v) => {\n        h.emit(n, ...v);\n      });\n    });\n    return () => {\n      f.forEach((d) => d());\n    };\n  }\n  destroy() {\n    m(this, $).clear();\n  }\n}\n$ = new WeakMap();\nconst ue = (l, r) => {\n  const h = new Uint8Array(8);\n  new DataView(h.buffer).setUint32(0, r);\n  for (let f = 0; f < 4; f++)\n    h[4 + f] = l.charCodeAt(f);\n  return h;\n}, Mi = () => {\n  const l = new TextEncoder(), r = l.encode(\"mdta\"), h = l.encode(\"mp4 handler\"), a = 32 + h.byteLength + 1, f = new Uint8Array(a), d = new DataView(f.buffer);\n  return f.set(ue(\"hdlr\", a), 0), d.setUint32(8, 0), f.set(r, 16), f.set(h, 32), f;\n}, Oi = (l) => {\n  const r = new TextEncoder(), h = r.encode(\"mdta\"), a = l.map((b) => {\n    const y = r.encode(b), B = 8 + y.byteLength, t = new Uint8Array(B);\n    return new DataView(t.buffer).setUint32(0, B), t.set(h, 4), t.set(y, 4 + h.byteLength), t;\n  }), d = 16 + a.reduce((b, y) => b + y.byteLength, 0), p = new Uint8Array(d), n = new DataView(p.buffer);\n  p.set(ue(\"keys\", d), 0), n.setUint32(8, 0), n.setUint32(12, l.length);\n  let v = 16;\n  for (const b of a)\n    p.set(b, v), v += b.byteLength;\n  return p;\n}, Ni = (l) => {\n  const r = new TextEncoder(), h = r.encode(\"data\"), a = Object.entries(l).map(([v, b], y) => {\n    const B = y + 1, t = r.encode(b), e = 24 + t.byteLength, i = new Uint8Array(e), s = new DataView(i.buffer);\n    return s.setUint32(0, e), s.setUint32(4, B), s.setUint32(8, 16 + t.byteLength), i.set(h, 12), s.setUint32(16, 1), i.set(t, 24), i;\n  }), d = 8 + a.reduce((v, b) => v + b.byteLength, 0), p = new Uint8Array(d);\n  p.set(ue(\"ilst\", d), 0);\n  let n = 8;\n  for (const v of a)\n    p.set(v, n), n += v.byteLength;\n  return p;\n}, Gi = (l) => {\n  const r = Mi(), h = Oi(Object.keys(l)), a = Ni(l), f = r.length + h.length + a.length, d = new Uint8Array(f);\n  return d.set(r, 0), d.set(h, r.length), d.set(a, r.length + h.length), d;\n};\nfunction rn(l) {\n  z.info(\"recodemux opts:\", l);\n  const r = D.createFile(), h = new Ri(), a = (v, b) => {\n    const B = v.add(\"udta\").add(\"meta\");\n    B.data = Gi(b), B.size = B.data.byteLength;\n  };\n  let f = !1;\n  const d = () => {\n    r.moov == null || f || (f = !0, l.metaDataTags != null && a(r.moov, l.metaDataTags), l.duration != null && (r.moov.mvhd.duration = l.duration));\n  };\n  h.once(\"VideoReady\", d), h.once(\"AudioReady\", d);\n  let p = l.video != null ? Hi(l.video, r, h) : null, n = l.audio != null ? Vi(l.audio, r, h) : null;\n  return l.video == null && h.emit(\"VideoReady\"), l.audio == null && h.emit(\"AudioReady\"), {\n    encodeVideo: (v, b) => {\n      p == null || p.encode(v, b), v.close();\n    },\n    encodeAudio: (v) => {\n      n != null && (n.encode(v), v.close());\n    },\n    getEncodeQueueSize: () => (p == null ? void 0 : p.encodeQueueSize) ?? (n == null ? void 0 : n.encodeQueueSize) ?? 0,\n    flush: async () => {\n      await Promise.all([\n        p == null ? void 0 : p.flush(),\n        (n == null ? void 0 : n.state) === \"configured\" ? n.flush() : null\n      ]);\n    },\n    close: () => {\n      h.destroy(), p == null || p.close(), (n == null ? void 0 : n.state) === \"configured\" && n.close();\n    },\n    mp4file: r\n  };\n}\nfunction Hi(l, r, h) {\n  const a = {\n    timescale: 1e6,\n    width: l.width,\n    height: l.height,\n    brands: [\"isom\", \"iso2\", \"avc1\", \"mp42\", \"mp41\"],\n    avcDecoderConfigRecord: null,\n    name: \"Track created with WebAV\"\n  };\n  let f = -1, d = !1;\n  h.once(\"AudioReady\", () => {\n    d = !0;\n  });\n  const p = {\n    encoder0: [],\n    encoder1: []\n  }, n = (c, u, _) => {\n    var g;\n    if (f === -1 && _ != null) {\n      const w = (g = _.decoderConfig) == null ? void 0 : g.description;\n      Yi(w), a.avcDecoderConfigRecord = w, f = r.addTrack(a), h.emit(\"VideoReady\"), z.info(\"VideoEncoder, video track ready, trackId:\", f);\n    }\n    p[c].push(Qt(u));\n  };\n  let v = \"encoder1\", b = 0;\n  const y = Math.floor(1e3 / l.expectFPS * 1e3);\n  function B() {\n    if (!d) return;\n    const c = v === \"encoder1\" ? \"encoder0\" : \"encoder1\", u = p[v], _ = p[c];\n    if (u.length === 0 && _.length === 0) return;\n    let g = u[0];\n    if (g != null && (!g.is_sync || g.cts - b < y)) {\n      const S = t(u);\n      S > b && (b = S);\n    }\n    const w = _[0];\n    if (w != null && w.is_sync && w.cts - b < y) {\n      v = c, B();\n      return;\n    }\n    if (g != null && g.is_sync && (w != null && w.is_sync))\n      if (g.cts <= w.cts) {\n        const S = t(u);\n        S > b && (b = S);\n      } else {\n        v = c, B();\n        return;\n      }\n  }\n  function t(c) {\n    let u = -1, _ = 0;\n    for (; _ < c.length; _++) {\n      const g = c[_];\n      if (_ > 0 && g.is_sync) break;\n      r.addSample(f, g.data, g), u = g.cts + g.duration;\n    }\n    return c.splice(0, _), u;\n  }\n  const e = De(B, 15), i = Ae(\n    l,\n    (c, u) => n(\"encoder0\", c, u)\n  ), s = Ae(\n    l,\n    (c, u) => n(\"encoder1\", c, u)\n  );\n  let o = 0;\n  return {\n    get encodeQueueSize() {\n      return i.encodeQueueSize + s.encodeQueueSize;\n    },\n    encode: (c, u) => {\n      u.keyFrame && (o += 1), (o % 2 === 0 ? i : s).encode(c, u);\n    },\n    flush: async () => {\n      await Promise.all([\n        i.state === \"configured\" ? await i.flush() : null,\n        s.state === \"configured\" ? await s.flush() : null\n      ]), e(), B();\n    },\n    close: () => {\n      i.state === \"configured\" && i.close(), s.state === \"configured\" && s.close();\n    }\n  };\n}\nfunction Yi(l) {\n  const r = new Uint8Array(l);\n  r[2].toString(2).slice(-2).includes(\"1\") && (r[2] = 0);\n}\nfunction Ae(l, r) {\n  const h = new VideoEncoder({\n    error: z.error,\n    output: r\n  });\n  return h.configure({\n    codec: l.codec,\n    framerate: l.expectFPS,\n    hardwareAcceleration: l.__unsafe_hardwareAcceleration__,\n    bitrate: l.bitrate,\n    width: l.width,\n    height: l.height,\n    alpha: \"discard\",\n    avc: { format: \"avc\" }\n  }), h;\n}\nfunction Vi(l, r, h) {\n  const a = {\n    timescale: 1e6,\n    samplerate: l.sampleRate,\n    channel_count: l.channelCount,\n    hdlr: \"soun\",\n    type: l.codec === \"aac\" ? \"mp4a\" : \"Opus\",\n    name: \"Track created with WebAV\"\n  };\n  let f = -1, d = [], p = !1;\n  h.once(\"VideoReady\", () => {\n    p = !0, d.forEach((v) => {\n      const b = Qt(v);\n      r.addSample(f, b.data, b);\n    }), d = [];\n  });\n  const n = new AudioEncoder({\n    error: z.error,\n    output: (v, b) => {\n      var y;\n      if (f === -1) {\n        const B = (y = b.decoderConfig) == null ? void 0 : y.description;\n        f = r.addTrack({\n          ...a,\n          description: B == null ? void 0 : $i(B)\n        }), h.emit(\"AudioReady\"), z.info(\"AudioEncoder, audio track ready, trackId:\", f);\n      }\n      if (p) {\n        const B = Qt(v);\n        r.addSample(f, B.data, B);\n      } else\n        d.push(v);\n    }\n  });\n  return n.configure({\n    codec: l.codec === \"aac\" ? q.codec : \"opus\",\n    sampleRate: l.sampleRate,\n    numberOfChannels: l.channelCount,\n    bitrate: 128e3\n  }), n;\n}\nfunction Wi(l, r, h) {\n  let a = 0, f = 0;\n  const d = l.boxes;\n  let p = !1;\n  const n = () => {\n    var i;\n    if (!p)\n      if (d.find((s) => s.type === \"moof\") != null)\n        p = !0;\n      else\n        return null;\n    if (f >= d.length) return null;\n    const t = new D.DataStream();\n    t.endianness = D.DataStream.BIG_ENDIAN;\n    let e = f;\n    try {\n      for (; e < d.length; )\n        d[e].write(t), delete d[e], e += 1;\n    } catch (s) {\n      const o = d[e];\n      throw s instanceof Error && o != null ? Error(\n        `${s.message} | deltaBuf( boxType: ${o.type}, boxSize: ${o.size}, boxDataLen: ${((i = o.data) == null ? void 0 : i.length) ?? -1})`\n      ) : s;\n    }\n    return Ai(l), f = d.length, new Uint8Array(t.buffer);\n  };\n  let v = !1, b = !1, y = null;\n  return {\n    stream: new ReadableStream({\n      start(t) {\n        a = self.setInterval(() => {\n          const e = n();\n          e != null && !b && t.enqueue(e);\n        }, r), y = (e) => {\n          if (clearInterval(a), l.flush(), e != null) {\n            t.error(e);\n            return;\n          }\n          const i = n();\n          i != null && !b && t.enqueue(i), b || t.close();\n        }, v && y();\n      },\n      cancel() {\n        b = !0, clearInterval(a), h == null || h();\n      }\n    }),\n    stop: (t) => {\n      v || (v = !0, y == null || y(t));\n    }\n  };\n}\nfunction Zi(l) {\n  let r = 0;\n  const h = l.boxes, a = [];\n  let f = 0;\n  async function d() {\n    const i = e(h, r);\n    r = h.length, a.forEach(({ track: s, id: o }) => {\n      const c = s.samples.at(-1);\n      c != null && (f = Math.max(f, c.cts + c.duration)), l.releaseUsedSamples(o, s.samples.length), s.samples = [];\n    }), l.mdats = [], l.moofs = [], i != null && await (y == null ? void 0 : y.write(i));\n  }\n  let p = [];\n  function n() {\n    if (p.length > 0) return !0;\n    const i = h.findIndex((s) => s.type === \"moov\");\n    if (i === -1) return !1;\n    if (p = h.slice(0, i + 1), r = i + 1, a.length === 0)\n      for (let s = 1; ; s += 1) {\n        const o = l.getTrackById(s);\n        if (o == null) break;\n        a.push({ track: o, id: s });\n      }\n    return !0;\n  }\n  let v = 0;\n  const b = Kt();\n  let y = null;\n  const B = (async () => {\n    y = await b.createWriter(), v = self.setInterval(() => {\n      n() && d();\n    }, 100);\n  })();\n  let t = !1;\n  return async () => {\n    if (t) throw Error(\"File exported\");\n    if (t = !0, await B, clearInterval(v), !n() || y == null) return null;\n    l.flush(), await d(), await (y == null ? void 0 : y.close());\n    const i = p.find((c) => c.type === \"moov\");\n    if (i == null) return null;\n    i.mvhd.duration = f;\n    const s = Kt(), o = e(p, 0);\n    return await Ct(s, o), await Ct(s, b, { overwrite: !1 }), await s.stream();\n  };\n  function e(i, s) {\n    if (s >= i.length) return null;\n    const o = new D.DataStream();\n    o.endianness = D.DataStream.BIG_ENDIAN;\n    for (let c = s; c < i.length; c++)\n      i[c] !== null && (i[c].write(o), delete i[c]);\n    return new Uint8Array(o.buffer);\n  }\n}\nfunction Qt(l) {\n  const r = new ArrayBuffer(l.byteLength);\n  l.copyTo(r);\n  const h = l.timestamp;\n  return {\n    duration: l.duration ?? 0,\n    dts: h,\n    cts: h,\n    is_sync: l.type === \"key\",\n    data: r\n  };\n}\nasync function Xi(l) {\n  const r = D.createFile(), h = Zi(r);\n  await ji(l, r);\n  const a = await h();\n  if (a == null) throw Error(\"Can not generate file from streams\");\n  return a;\n}\nasync function ji(l, r) {\n  let h = 0, a = 0, f = 0, d = 0, p = 0, n = 0, v = null, b = null;\n  for (const y of l)\n    await new Promise(async (B) => {\n      fe(y.pipeThrough(new ce()), {\n        onDone: B,\n        onChunk: async ({ chunkType: t, data: e }) => {\n          if (t === \"ready\") {\n            const { videoTrackConf: i, audioTrackConf: s } = de(\n              e.file,\n              e.info\n            );\n            h === 0 && i != null && (h = r.addTrack(i)), d === 0 && s != null && (d = r.addTrack(s));\n          } else if (t === \"samples\") {\n            const { type: i, samples: s } = e, o = i === \"video\" ? h : d, c = i === \"video\" ? a : p, u = i === \"video\" ? f : n;\n            s.forEach((g) => {\n              r.addSample(o, g.data, {\n                duration: g.duration,\n                dts: g.dts + c,\n                cts: g.cts + u,\n                is_sync: g.is_sync\n              });\n            });\n            const _ = s.at(-1);\n            if (_ == null) return;\n            i === \"video\" ? v = _ : i === \"audio\" && (b = _);\n          }\n        }\n      });\n    }), v != null && (a += v.dts, f += v.cts), b != null && (p += b.dts, n += b.cts);\n}\nasync function an(l) {\n  return await Xi([l]);\n}\nfunction Ki(l) {\n  let r = [];\n  const h = new AudioDecoder({\n    output: (a) => {\n      r.push(a);\n    },\n    error: z.error\n  });\n  return h.configure(l), {\n    decode: async (a) => {\n      a.forEach((d) => {\n        h.decode(\n          new EncodedAudioChunk({\n            type: d.is_sync ? \"key\" : \"delta\",\n            timestamp: 1e6 * d.cts / d.timescale,\n            duration: 1e6 * d.duration / d.timescale,\n            data: d.data\n          })\n        );\n      }), await h.flush();\n      const f = r;\n      return r = [], f;\n    },\n    close: () => {\n      h.close();\n    }\n  };\n}\nfunction Qi(l, r) {\n  const h = new AudioEncoder({\n    output: (d) => {\n      r(Qt(d));\n    },\n    error: z.error\n  });\n  h.configure({\n    codec: l.codec,\n    sampleRate: l.sampleRate,\n    numberOfChannels: l.numberOfChannels\n  });\n  let a = null;\n  function f(d, p) {\n    return new AudioData({\n      timestamp: p,\n      numberOfChannels: l.numberOfChannels,\n      numberOfFrames: d.length / l.numberOfChannels,\n      sampleRate: l.sampleRate,\n      format: \"f32-planar\",\n      data: d\n    });\n  }\n  return {\n    encode: async (d, p) => {\n      a != null && h.encode(f(a.data, a.ts)), a = { data: d, ts: p };\n    },\n    stop: async () => {\n      a != null && (Ji(a.data, l.numberOfChannels, l.sampleRate), h.encode(f(a.data, a.ts)), a = null), await h.flush(), h.close();\n    }\n  };\n}\nfunction Ji(l, r, h) {\n  const a = l.length - 1, f = Math.min(h / 2, a);\n  for (let d = 0; d < f; d++)\n    for (let p = 1; p <= r; p++)\n      l[Math.floor(a / p) - d] *= d / f;\n}\nfunction on(l, r) {\n  z.info(\"mixinMP4AndAudio, opts:\", {\n    volume: r.volume,\n    loop: r.loop\n  });\n  const h = D.createFile(), { stream: a, stop: f } = Wi(h, 500);\n  let d = null, p = null, n = [], v = 0, b = 0, y = 0, B = !0, t = 48e3;\n  fe(l.pipeThrough(new ce()), {\n    onDone: async () => {\n      await (p == null ? void 0 : p.stop()), d == null || d.close(), f();\n    },\n    onChunk: async ({ chunkType: o, data: c }) => {\n      if (o === \"ready\") {\n        const { videoTrackConf: u, audioTrackConf: _, audioDecoderConf: g } = de(c.file, c.info);\n        v === 0 && u != null && (v = h.addTrack(u));\n        const w = _ ?? {\n          timescale: 1e6,\n          samplerate: t,\n          channel_count: q.channelCount,\n          hdlr: \"soun\",\n          name: \"SoundHandler\",\n          type: \"mp4a\"\n        };\n        b === 0 && (b = h.addTrack(w), t = (_ == null ? void 0 : _.samplerate) ?? t, B = _ != null);\n        const S = new AudioContext({ sampleRate: t });\n        n = Oe(\n          await S.decodeAudioData(\n            await new Response(r.stream).arrayBuffer()\n          )\n        ), g != null && (d = Ki(g)), p = Qi(\n          g ?? {\n            codec: w.type === \"mp4a\" ? q.codec : w.type,\n            numberOfChannels: w.channel_count,\n            sampleRate: w.samplerate\n          },\n          (U) => h.addSample(b, U.data, U)\n        );\n      } else if (o === \"samples\") {\n        const { id: u, type: _, samples: g } = c;\n        if (_ === \"video\") {\n          g.forEach((w) => h.addSample(u, w.data, w)), B || await i(g);\n          return;\n        }\n        _ === \"audio\" && await s(g);\n      }\n    }\n  });\n  function e(o) {\n    const c = n.map(\n      (u) => r.loop ? Si(u, y, y + o) : u.slice(y, y + o)\n    );\n    if (y += o, r.volume !== 1)\n      for (const u of c)\n        for (let _ = 0; _ < u.length; _++) u[_] *= r.volume;\n    return c;\n  }\n  async function i(o) {\n    const c = o[0], u = o[o.length - 1], _ = Math.floor(\n      (u.cts + u.duration - c.cts) / u.timescale * t\n    ), g = be([e(_)]);\n    g.length !== 0 && (p == null || p.encode(\n      g,\n      c.cts / c.timescale * 1e6\n    ));\n  }\n  async function s(o) {\n    if (d == null) return;\n    const c = (await d.decode(o)).map(\n      le\n    ), u = mi(c), _ = e(u[0].length), g = o[0];\n    p == null || p.encode(\n      be([u, _]),\n      g.cts / g.timescale * 1e6\n    );\n  }\n  return a;\n}\nfunction $i(l) {\n  const r = l.byteLength, h = new Uint8Array([\n    0,\n    // version 0\n    0,\n    0,\n    0,\n    // flags\n    3,\n    // descriptor_type\n    23 + r,\n    // length\n    0,\n    // 0x01, // es_id\n    2,\n    // es_id\n    0,\n    // stream_priority\n    4,\n    // descriptor_type\n    18 + r,\n    // length\n    64,\n    // codec : mpeg4_audio\n    21,\n    // stream_type\n    0,\n    0,\n    0,\n    // buffer_size\n    0,\n    0,\n    0,\n    0,\n    // maxBitrate\n    0,\n    0,\n    0,\n    0,\n    // avgBitrate\n    5,\n    // descriptor_type\n    r,\n    ...new Uint8Array(l instanceof ArrayBuffer ? l : l.buffer),\n    6,\n    1,\n    2\n  ]), a = new D.BoxParser.esdsBox(h.byteLength);\n  return a.hdr_size = 0, a.parse(new D.DataStream(h, 0, D.DataStream.BIG_ENDIAN)), a;\n}\n\n//# sourceMappingURL=frames.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGVzaWduY29tYm8vZnJhbWVzL2Rpc3QvZnJhbWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUUsSUFBSSxvQkFBb0IsZ0JBQWdCO0FBQzFFLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUUsWUFBWSxFQUFFO0FBQ3JFO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQixFQUFFO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5dkVBQXl2RSx1QkFBdUIsZ0JBQWdCO0FBQ2h5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQ0FBaUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCw4RUFBOEUsa0JBQWtCO0FBQ2hHLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7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Q1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SDtBQUN2SCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsZ0JBQWdCLDREQUE0RDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBbUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5QkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRlc2lnbmNvbWJvL2ZyYW1lcy9kaXN0L2ZyYW1lcy5qcz81OTc2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBIZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBwZSA9IChsKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihsKTtcbn07XG52YXIgWWUgPSAobCwgciwgaCkgPT4gciBpbiBsID8gSGUobCwgciwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogaCB9KSA6IGxbcl0gPSBoO1xudmFyIFIgPSAobCwgciwgaCkgPT4gWWUobCwgdHlwZW9mIHIgIT0gXCJzeW1ib2xcIiA/IHIgKyBcIlwiIDogciwgaCksIF9lID0gKGwsIHIsIGgpID0+IHIuaGFzKGwpIHx8IHBlKFwiQ2Fubm90IFwiICsgaCk7XG52YXIgbSA9IChsLCByLCBoKSA9PiAoX2UobCwgciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgaCA/IGguY2FsbChsKSA6IHIuZ2V0KGwpKSwgQSA9IChsLCByLCBoKSA9PiByLmhhcyhsKSA/IHBlKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKSA6IHIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gci5hZGQobCkgOiByLnNldChsLCBoKSwgRSA9IChsLCByLCBoLCBhKSA9PiAoX2UobCwgciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBhID8gYS5jYWxsKGwsIGgpIDogci5zZXQobCwgaCksIGgpO1xuZnVuY3Rpb24gVmUobCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChsKTtcbn1cbmZ1bmN0aW9uIFdlKGwsIHIpIHtcbiAgY29uc3QgaCA9IFZlKFwicHJlXCIpO1xuICBoLnN0eWxlLmNzc1RleHQgPSBgbWFyZ2luOiAwOyAke3J9OyB2aXNpYmlsaXR5OiBoaWRkZW47IHBvc2l0aW9uOiBmaXhlZDtgLCBoLnRleHRDb250ZW50ID0gbCwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChoKTtcbiAgY29uc3QgeyB3aWR0aDogYSwgaGVpZ2h0OiBmIH0gPSBoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBoLnJlbW92ZSgpLCBoLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgY29uc3QgZCA9IG5ldyBJbWFnZSgpO1xuICBkLndpZHRoID0gYSwgZC5oZWlnaHQgPSBmO1xuICBjb25zdCBwID0gYFxuICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiJHthfVwiIGhlaWdodD1cIiR7Zn1cIj5cbiAgICA8Zm9yZWlnbk9iamVjdCB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+XG4gICAgICAgIDxkaXYgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI+JHtoLm91dGVySFRNTH08L2Rpdj5cbiAgICA8L2ZvcmVpZ25PYmplY3Q+XG4gICAgPC9zdmc+XG4gIGAucmVwbGFjZSgvXFx0L2csIFwiXCIpLnJlcGxhY2UoLyMvZywgXCIlMjNcIik7XG4gIHJldHVybiBkLnNyYyA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwke3B9YCwgZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRuKGwsIHIpIHtcbiAgY29uc3QgaCA9IFdlKGwsIHIpO1xuICBhd2FpdCBuZXcgUHJvbWlzZSgoZCkgPT4ge1xuICAgIGgub25sb2FkID0gZDtcbiAgfSk7XG4gIGNvbnN0IGEgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGgud2lkdGgsIGguaGVpZ2h0KSwgZiA9IGEuZ2V0Q29udGV4dChcIjJkXCIpO1xuICByZXR1cm4gZiA9PSBudWxsIHx8IGYuZHJhd0ltYWdlKGgsIDAsIDAsIGgud2lkdGgsIGguaGVpZ2h0KSwgYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYSk7XG59XG52YXIgQmUgPSAobCkgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3IobCk7XG59LCBGZSA9IChsLCByLCBoKSA9PiByLmhhcyhsKSB8fCBCZShcIkNhbm5vdCBcIiArIGgpLCBJID0gKGwsIHIsIGgpID0+IChGZShsLCByLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBoID8gaC5jYWxsKGwpIDogci5nZXQobCkpLCBOID0gKGwsIHIsIGgpID0+IHIuaGFzKGwpID8gQmUoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogciBpbnN0YW5jZW9mIFdlYWtTZXQgPyByLmFkZChsKSA6IHIuc2V0KGwsIGgpLCBNID0gKGwsIHIsIGgsIGEpID0+IChGZShsLCByLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIHIuc2V0KGwsIGgpLCBoKTtcbmNvbnN0IEllID0gXCJLR1oxYm1OMGFXOXVLQ2w3SW5WelpTQnpkSEpwWTNRaU8yWjFibU4wYVc5dUlIVW9iaWw3YVdZb2JqMDlQU0l2SWlseVpYUjFjbTU3Y0dGeVpXNTBPbTUxYkd3c2JtRnRaVG9pSW4wN1kyOXVjM1FnWlQxdUxuTndiR2wwS0NJdklpa3VabWxzZEdWeUtHazlQbWt1YkdWdVozUm9QakFwTzJsbUtHVXViR1Z1WjNSb1BUMDlNQ2wwYUhKdmR5QkZjbkp2Y2lnaVNXNTJZV3hwWkNCd1lYUm9JaWs3WTI5dWMzUWdZVDFsVzJVdWJHVnVaM1JvTFRGZExISTlJaThpSzJVdWMyeHBZMlVvTUN3dE1Ta3VhbTlwYmlnaUx5SXBPM0psZEhWeWJudHVZVzFsT21Fc2NHRnlaVzUwT25KOWZXRnplVzVqSUdaMWJtTjBhVzl1SUhjb2JpeGxLWHRqYjI1emRIdHdZWEpsYm5RNllTeHVZVzFsT25KOVBYVW9iaWs3YVdZb1lUMDliblZzYkNseVpYUjFjbTRnWVhkaGFYUWdibUYyYVdkaGRHOXlMbk4wYjNKaFoyVXVaMlYwUkdseVpXTjBiM0o1S0NrN1kyOXVjM1FnYVQxaExuTndiR2wwS0NJdklpa3VabWxzZEdWeUtIUTlQblF1YkdWdVozUm9QakFwTzNSeWVYdHNaWFFnZEQxaGQyRnBkQ0J1WVhacFoyRjBiM0l1YzNSdmNtRm5aUzVuWlhSRWFYSmxZM1J2Y25rb0tUdG1iM0lvWTI5dWMzUWdjeUJ2WmlCcEtYUTlZWGRoYVhRZ2RDNW5aWFJFYVhKbFkzUnZjbmxJWVc1a2JHVW9jeXg3WTNKbFlYUmxPbVV1WTNKbFlYUmxmU2s3YVdZb1pTNXBjMFpwYkdVcGNtVjBkWEp1SUdGM1lXbDBJSFF1WjJWMFJtbHNaVWhoYm1Sc1pTaHlMSHRqY21WaGRHVTZaUzVqY21WaGRHVjlLWDFqWVhSamFDaDBLWHRwWmloMExtNWhiV1U5UFQwaVRtOTBSbTkxYm1SRmNuSnZjaUlwY21WMGRYSnVJRzUxYkd3N2RHaHliM2NnZEgxOVkyOXVjM1FnWmoxN2ZUdHpaV3htTG05dWJXVnpjMkZuWlQxaGMzbHVZeUJ1UFQ1N2RtRnlJR2s3WTI5dWMzUjdaWFowVkhsd1pUcGxMR0Z5WjNNNllYMDliaTVrWVhSaE8yeGxkQ0J5UFdaYllTNW1hV3hsU1dSZE8zUnllWHRzWlhRZ2REdGpiMjV6ZENCelBWdGRPMmxtS0dVOVBUMGljbVZuYVhOMFpYSWlLWHRqYjI1emRDQnNQV0YzWVdsMElIY29ZUzVtYVd4bFVHRjBhQ3g3WTNKbFlYUmxPaUV3TEdselJtbHNaVG9oTUgwcE8ybG1LR3c5UFc1MWJHd3BkR2h5YjNjZ1JYSnliM0lvWUc1dmRDQm1iM1Z1WkNCbWFXeGxPaUFrZTJFdVptbHNaVWxrZldBcE8zSTlZWGRoYVhRZ2JDNWpjbVZoZEdWVGVXNWpRV05qWlhOelNHRnVaR3hsS0h0dGIyUmxPbUV1Ylc5a1pYMHBMR1piWVM1bWFXeGxTV1JkUFhKOVpXeHpaU0JwWmlobFBUMDlJbU5zYjNObElpbGhkMkZwZENCeUxtTnNiM05sS0Nrc1pHVnNaWFJsSUdaYllTNW1hV3hsU1dSZE8yVnNjMlVnYVdZb1pUMDlQU0owY25WdVkyRjBaU0lwWVhkaGFYUWdjaTUwY25WdVkyRjBaU2hoTG01bGQxTnBlbVVwTzJWc2MyVWdhV1lvWlQwOVBTSjNjbWwwWlNJcGUyTnZibk4wZTJSaGRHRTZiQ3h2Y0hSek9tOTlQVzR1WkdGMFlTNWhjbWR6TzNROVlYZGhhWFFnY2k1M2NtbDBaU2hzTEc4cGZXVnNjMlVnYVdZb1pUMDlQU0p5WldGa0lpbDdZMjl1YzNSN2IyWm1jMlYwT213c2MybDZaVHB2ZlQxdUxtUmhkR0V1WVhKbmN5eG5QVzVsZHlCVmFXNTBPRUZ5Y21GNUtHOHBMR1E5WVhkaGFYUWdjaTV5WldGa0tHY3NlMkYwT214OUtTeGpQV2N1WW5WbVptVnlPM1E5WkQwOVBXOC9Zem9vS0drOVl5NTBjbUZ1YzJabGNpazlQVzUxYkd3L2RtOXBaQ0F3T21rdVkyRnNiQ2hqTEdRcEtUOC9ZeTV6YkdsalpTZ3dMR1FwTEhNdWNIVnphQ2gwS1gxbGJITmxJR1U5UFQwaVoyVjBVMmw2WlNJL2REMWhkMkZwZENCeUxtZGxkRk5wZW1Vb0tUcGxQVDA5SW1ac2RYTm9JaVltWVhkaGFYUWdjaTVtYkhWemFDZ3BPM05sYkdZdWNHOXpkRTFsYzNOaFoyVW9lMlYyZEZSNWNHVTZJbU5oYkd4aVlXTnJJaXhqWWtsa09tNHVaR0YwWVM1allrbGtMSEpsZEhWeWJsWmhiRHAwZlN4ektYMWpZWFJqYUNoMEtYdGpiMjV6ZENCelBYUTdjMlZzWmk1d2IzTjBUV1Z6YzJGblpTaDdaWFowVkhsd1pUb2lkR2h5YjNkRmNuSnZjaUlzWTJKSlpEcHVMbVJoZEdFdVkySkpaQ3hsY25KTmMyYzZjeTV1WVcxbEt5STZJQ0lyY3k1dFpYTnpZV2RsSzJBS1lDdEtVMDlPTG5OMGNtbHVaMmxtZVNodUxtUmhkR0VwZlNsOWZYMHBLQ2s3Q2k4dkl5QnpiM1Z5WTJWTllYQndhVzVuVlZKTVBXOXdabk10ZDI5eWEyVnlMVVkwVWxkc2NXTmZMbXB6TG0xaGNBbz1cIiwgWmUgPSAobCkgPT4gVWludDhBcnJheS5mcm9tKGF0b2IobCksIChyKSA9PiByLmNoYXJDb2RlQXQoMCkpLCBnZSA9IHR5cGVvZiBzZWxmIDwgXCJ1XCIgJiYgc2VsZi5CbG9iICYmIG5ldyBCbG9iKFtaZShJZSldLCB7IHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0O2NoYXJzZXQ9dXRmLThcIiB9KTtcbmZ1bmN0aW9uIFhlKGwpIHtcbiAgbGV0IHI7XG4gIHRyeSB7XG4gICAgaWYgKHIgPSBnZSAmJiAoc2VsZi5VUkwgfHwgc2VsZi53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChnZSksICFyKSB0aHJvdyBcIlwiO1xuICAgIGNvbnN0IGggPSBuZXcgV29ya2VyKHIsIHtcbiAgICAgIG5hbWU6IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwubmFtZVxuICAgIH0pO1xuICAgIHJldHVybiBoLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAoc2VsZi5VUkwgfHwgc2VsZi53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChyKTtcbiAgICB9KSwgaDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG5ldyBXb3JrZXIoXG4gICAgICBcImRhdGE6dGV4dC9qYXZhc2NyaXB0O2Jhc2U2NCxcIiArIEllLFxuICAgICAge1xuICAgICAgICBuYW1lOiBsID09IG51bGwgPyB2b2lkIDAgOiBsLm5hbWVcbiAgICAgIH1cbiAgICApO1xuICB9IGZpbmFsbHkge1xuICAgIHIgJiYgKHNlbGYuVVJMIHx8IHNlbGYud2Via2l0VVJMKS5yZXZva2VPYmplY3RVUkwocik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGplKGwsIHIsIGgpIHtcbiAgY29uc3QgYSA9IEtlKCk7XG4gIHJldHVybiBhd2FpdCBhKFwicmVnaXN0ZXJcIiwgeyBmaWxlSWQ6IGwsIGZpbGVQYXRoOiByLCBtb2RlOiBoIH0pLCB7XG4gICAgcmVhZDogYXN5bmMgKGYsIGQpID0+IGF3YWl0IGEoXCJyZWFkXCIsIHtcbiAgICAgIGZpbGVJZDogbCxcbiAgICAgIG9mZnNldDogZixcbiAgICAgIHNpemU6IGRcbiAgICB9KSxcbiAgICB3cml0ZTogYXN5bmMgKGYsIGQpID0+IGF3YWl0IGEoXG4gICAgICBcIndyaXRlXCIsXG4gICAgICB7XG4gICAgICAgIGZpbGVJZDogbCxcbiAgICAgICAgZGF0YTogZixcbiAgICAgICAgb3B0czogZFxuICAgICAgfSxcbiAgICAgIFtBcnJheUJ1ZmZlci5pc1ZpZXcoZikgPyBmLmJ1ZmZlciA6IGZdXG4gICAgKSxcbiAgICBjbG9zZTogYXN5bmMgKCkgPT4gYXdhaXQgYShcImNsb3NlXCIsIHtcbiAgICAgIGZpbGVJZDogbFxuICAgIH0pLFxuICAgIHRydW5jYXRlOiBhc3luYyAoZikgPT4gYXdhaXQgYShcInRydW5jYXRlXCIsIHtcbiAgICAgIGZpbGVJZDogbCxcbiAgICAgIG5ld1NpemU6IGZcbiAgICB9KSxcbiAgICBnZXRTaXplOiBhc3luYyAoKSA9PiBhd2FpdCBhKFwiZ2V0U2l6ZVwiLCB7XG4gICAgICBmaWxlSWQ6IGxcbiAgICB9KSxcbiAgICBmbHVzaDogYXN5bmMgKCkgPT4gYXdhaXQgYShcImZsdXNoXCIsIHtcbiAgICAgIGZpbGVJZDogbFxuICAgIH0pXG4gIH07XG59XG5jb25zdCBZdCA9IFtdO1xubGV0IGllID0gMDtcbmZ1bmN0aW9uIEtlKCkge1xuICBpZiAoWXQubGVuZ3RoIDwgMykge1xuICAgIGNvbnN0IHIgPSBsKCk7XG4gICAgcmV0dXJuIFl0LnB1c2gociksIHI7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgciA9IFl0W2llXTtcbiAgICByZXR1cm4gaWUgPSAoaWUgKyAxKSAlIFl0Lmxlbmd0aCwgcjtcbiAgfVxuICBmdW5jdGlvbiBsKCkge1xuICAgIGNvbnN0IHIgPSBuZXcgWGUoKTtcbiAgICBsZXQgaCA9IDAsIGEgPSB7fTtcbiAgICByZXR1cm4gci5vbm1lc3NhZ2UgPSAoe1xuICAgICAgZGF0YTogZlxuICAgIH0pID0+IHtcbiAgICAgIHZhciBkLCBwO1xuICAgICAgZi5ldnRUeXBlID09PSBcImNhbGxiYWNrXCIgPyAoZCA9IGFbZi5jYklkXSkgPT0gbnVsbCB8fCBkLnJlc29sdmUoZi5yZXR1cm5WYWwpIDogZi5ldnRUeXBlID09PSBcInRocm93RXJyb3JcIiAmJiAoKHAgPSBhW2YuY2JJZF0pID09IG51bGwgfHwgcC5yZWplY3QoRXJyb3IoZi5lcnJNc2cpKSksIGRlbGV0ZSBhW2YuY2JJZF07XG4gICAgfSwgYXN5bmMgZnVuY3Rpb24oZiwgZCwgcCA9IFtdKSB7XG4gICAgICBoICs9IDE7XG4gICAgICBjb25zdCBuID0gbmV3IFByb21pc2UoKHYsIGIpID0+IHtcbiAgICAgICAgYVtoXSA9IHsgcmVzb2x2ZTogdiwgcmVqZWN0OiBiIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByLnBvc3RNZXNzYWdlKFxuICAgICAgICB7XG4gICAgICAgICAgY2JJZDogaCxcbiAgICAgICAgICBldnRUeXBlOiBmLFxuICAgICAgICAgIGFyZ3M6IGRcbiAgICAgICAgfSxcbiAgICAgICAgcFxuICAgICAgKSwgbjtcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiB0ZShsKSB7XG4gIGlmIChsID09PSBcIi9cIikgcmV0dXJuIHsgcGFyZW50OiBudWxsLCBuYW1lOiBcIlwiIH07XG4gIGNvbnN0IHIgPSBsLnNwbGl0KFwiL1wiKS5maWx0ZXIoKGYpID0+IGYubGVuZ3RoID4gMCk7XG4gIGlmIChyLmxlbmd0aCA9PT0gMCkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHBhdGhcIik7XG4gIGNvbnN0IGggPSByW3IubGVuZ3RoIC0gMV0sIGEgPSBcIi9cIiArIHIuc2xpY2UoMCwgLTEpLmpvaW4oXCIvXCIpO1xuICByZXR1cm4geyBuYW1lOiBoLCBwYXJlbnQ6IGEgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG90KGwsIHIpIHtcbiAgY29uc3QgeyBwYXJlbnQ6IGgsIG5hbWU6IGEgfSA9IHRlKGwpO1xuICBpZiAoaCA9PSBudWxsKSByZXR1cm4gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gIGNvbnN0IGYgPSBoLnNwbGl0KFwiL1wiKS5maWx0ZXIoKGQpID0+IGQubGVuZ3RoID4gMCk7XG4gIHRyeSB7XG4gICAgbGV0IGQgPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICBmb3IgKGNvbnN0IHAgb2YgZilcbiAgICAgIGQgPSBhd2FpdCBkLmdldERpcmVjdG9yeUhhbmRsZShwLCB7XG4gICAgICAgIGNyZWF0ZTogci5jcmVhdGVcbiAgICAgIH0pO1xuICAgIHJldHVybiByLmlzRmlsZSA/IGF3YWl0IGQuZ2V0RmlsZUhhbmRsZShhLCB7XG4gICAgICBjcmVhdGU6IHIuY3JlYXRlXG4gICAgfSkgOiBhd2FpdCBkLmdldERpcmVjdG9yeUhhbmRsZShhLCB7XG4gICAgICBjcmVhdGU6IHIuY3JlYXRlXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGQpIHtcbiAgICBpZiAoZC5uYW1lID09PSBcIk5vdEZvdW5kRXJyb3JcIilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHRocm93IGQ7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIENlKGwpIHtcbiAgY29uc3QgeyBwYXJlbnQ6IHIsIG5hbWU6IGggfSA9IHRlKGwpO1xuICBpZiAociA9PSBudWxsKSB7XG4gICAgY29uc3QgZiA9IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgZCBvZiBmLmtleXMoKSlcbiAgICAgIGF3YWl0IGYucmVtb3ZlRW50cnkoZCwgeyByZWN1cnNpdmU6ICEwIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhID0gYXdhaXQgb3Qociwge1xuICAgIGNyZWF0ZTogITEsXG4gICAgaXNGaWxlOiAhMVxuICB9KTtcbiAgYSAhPSBudWxsICYmIGF3YWl0IGEucmVtb3ZlRW50cnkoaCwgeyByZWN1cnNpdmU6ICEwIH0pO1xufVxuZnVuY3Rpb24gc2UobCwgcikge1xuICByZXR1cm4gYCR7bH0vJHtyfWAucmVwbGFjZShcIi8vXCIsIFwiL1wiKTtcbn1cbmZ1bmN0aW9uIHZ0KGwpIHtcbiAgcmV0dXJuIG5ldyB6ZShsKTtcbn1cbnZhciBILCBWdCwgQXQ7XG5jbGFzcyB6ZSB7XG4gIGNvbnN0cnVjdG9yKHIpIHtcbiAgICBOKHRoaXMsIEgpLCBOKHRoaXMsIFZ0KSwgTih0aGlzLCBBdCksIE0odGhpcywgSCwgcik7XG4gICAgY29uc3QgeyBwYXJlbnQ6IGgsIG5hbWU6IGEgfSA9IHRlKHIpO1xuICAgIE0odGhpcywgVnQsIGEpLCBNKHRoaXMsIEF0LCBoKTtcbiAgfVxuICBnZXQga2luZCgpIHtcbiAgICByZXR1cm4gXCJkaXJcIjtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gSSh0aGlzLCBWdCk7XG4gIH1cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIEkodGhpcywgSCk7XG4gIH1cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gSSh0aGlzLCBBdCkgPT0gbnVsbCA/IG51bGwgOiB2dChJKHRoaXMsIEF0KSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGRpcmVjdG9yeS5cbiAgICogcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGRpcmVjdG9yeSBpcyBjcmVhdGVkLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKCkge1xuICAgIHJldHVybiBhd2FpdCBvdChJKHRoaXMsIEgpLCB7XG4gICAgICBjcmVhdGU6ICEwLFxuICAgICAgaXNGaWxlOiAhMVxuICAgIH0pLCB2dChJKHRoaXMsIEgpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBkaXJlY3RvcnkgZXhpc3RzLlxuICAgKiByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgZGlyZWN0b3J5IGV4aXN0cywgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgYXN5bmMgZXhpc3RzKCkge1xuICAgIHJldHVybiBhd2FpdCBvdChJKHRoaXMsIEgpLCB7XG4gICAgICBjcmVhdGU6ICExLFxuICAgICAgaXNGaWxlOiAhMVxuICAgIH0pIGluc3RhbmNlb2YgRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZGlyZWN0b3J5LlxuICAgKiByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZGlyZWN0b3J5IGlzIHJlbW92ZWQuXG4gICAqL1xuICBhc3luYyByZW1vdmUoKSB7XG4gICAgZm9yIChjb25zdCByIG9mIGF3YWl0IHRoaXMuY2hpbGRyZW4oKSlcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHIucmVtb3ZlKCk7XG4gICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihoKTtcbiAgICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgQ2UoSSh0aGlzLCBIKSk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgY29uc29sZS53YXJuKHIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlyZWN0b3J5LlxuICAgKiByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGNoaWxkcmVuLlxuICAgKi9cbiAgYXN5bmMgY2hpbGRyZW4oKSB7XG4gICAgY29uc3QgciA9IGF3YWl0IG90KEkodGhpcywgSCksIHtcbiAgICAgIGNyZWF0ZTogITEsXG4gICAgICBpc0ZpbGU6ICExXG4gICAgfSk7XG4gICAgaWYgKHIgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGggPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGEgb2Ygci52YWx1ZXMoKSlcbiAgICAgIGgucHVzaCgoYS5raW5kID09PSBcImZpbGVcIiA/IF90IDogdnQpKHNlKEkodGhpcywgSCksIGEubmFtZSkpKTtcbiAgICByZXR1cm4gaDtcbiAgfVxuICAvKipcbiAgICogSWYgdGhlIGRlc3QgZm9sZGVyIGV4aXN0cywgY29weSB0aGUgY3VycmVudCBkaXJlY3RvcnkgaW50byB0aGUgZGVzdCBmb2xkZXI7XG4gICAqIGlmIHRoZSBkZXN0IGZvbGRlciBkb2VzIG5vdCBleGlzdCwgcmVuYW1lIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB0byBkZXN0IG5hbWUuXG4gICAqL1xuICBhc3luYyBjb3B5VG8ocikge1xuICAgIGlmICghYXdhaXQgdGhpcy5leGlzdHMoKSlcbiAgICAgIHRocm93IEVycm9yKGBkaXIgJHt0aGlzLnBhdGh9IG5vdCBleGlzdHNgKTtcbiAgICBjb25zdCBoID0gYXdhaXQgci5leGlzdHMoKSA/IHZ0KHNlKHIucGF0aCwgdGhpcy5uYW1lKSkgOiByO1xuICAgIHJldHVybiBhd2FpdCBoLmNyZWF0ZSgpLCBhd2FpdCBQcm9taXNlLmFsbCgoYXdhaXQgdGhpcy5jaGlsZHJlbigpKS5tYXAoKGEpID0+IGEuY29weVRvKGgpKSksIGg7XG4gIH1cbiAgLyoqXG4gICAqIG1vdmUgZGlyZWN0b3J5LCBjb3B5IHRoZW4gcmVtb3ZlIGN1cnJlbnRcbiAgICovXG4gIGFzeW5jIG1vdmVUbyhyKSB7XG4gICAgY29uc3QgaCA9IGF3YWl0IHRoaXMuY29weVRvKHIpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlbW92ZSgpLCBoO1xuICB9XG59XG5IID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFZ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCB5ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBfdChsLCByID0gXCJyd1wiKSB7XG4gIGlmIChyID09PSBcInJ3XCIpIHtcbiAgICBjb25zdCBoID0geWUuZ2V0KGwpID8/IG5ldyBqdChsLCByKTtcbiAgICByZXR1cm4geWUuc2V0KGwsIGgpLCBoO1xuICB9XG4gIHJldHVybiBuZXcganQobCwgcik7XG59XG5hc3luYyBmdW5jdGlvbiBDdChsLCByLCBoID0geyBvdmVyd3JpdGU6ICEwIH0pIHtcbiAgaWYgKHIgaW5zdGFuY2VvZiBqdCkge1xuICAgIGF3YWl0IEN0KGwsIGF3YWl0IHIuc3RyZWFtKCksIGgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhID0gYXdhaXQgKGwgaW5zdGFuY2VvZiBqdCA/IGwgOiBfdChsLCBcInJ3XCIpKS5jcmVhdGVXcml0ZXIoKTtcbiAgdHJ5IHtcbiAgICBpZiAoaC5vdmVyd3JpdGUgJiYgYXdhaXQgYS50cnVuY2F0ZSgwKSwgciBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICBjb25zdCBmID0gci5nZXRSZWFkZXIoKTtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBjb25zdCB7IGRvbmU6IGQsIHZhbHVlOiBwIH0gPSBhd2FpdCBmLnJlYWQoKTtcbiAgICAgICAgaWYgKGQpIGJyZWFrO1xuICAgICAgICBhd2FpdCBhLndyaXRlKHApO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgYXdhaXQgYS53cml0ZShyKTtcbiAgfSBjYXRjaCAoZikge1xuICAgIHRocm93IGY7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgYS5jbG9zZSgpO1xuICB9XG59XG5sZXQgUWUgPSAwO1xuY29uc3QgSmUgPSAoKSA9PiArK1FlO1xudmFyIFksIEJ0LCBXdCwgRnQsIFp0LCBpdCwgWHQsIEl0O1xuY29uc3QgJGUgPSBjbGFzcyBUZSB7XG4gIGNvbnN0cnVjdG9yKHIsIGgpIHtcbiAgICBOKHRoaXMsIFkpLCBOKHRoaXMsIEJ0KSwgTih0aGlzLCBXdCksIE4odGhpcywgRnQpLCBOKHRoaXMsIFp0KSwgTih0aGlzLCBpdCwgMCksIE4odGhpcywgWHQsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgICAgbGV0IGQgPSBudWxsO1xuICAgICAgcmV0dXJuICgpID0+IChNKHRoaXMsIGl0LCBJKHRoaXMsIGl0KSArIDEpLCBkID8/IChkID0gbmV3IFByb21pc2UoYXN5bmMgKHAsIG4pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2ID0gYXdhaXQgamUoXG4gICAgICAgICAgICBJKHRoaXMsIFp0KSxcbiAgICAgICAgICAgIEkodGhpcywgWSksXG4gICAgICAgICAgICBJKHRoaXMsIEZ0KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcChbXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBNKHRoaXMsIGl0LCBJKHRoaXMsIGl0KSAtIDEpLCAhKEkodGhpcywgaXQpID4gMCkgJiYgKGQgPSBudWxsLCBhd2FpdCB2LmNsb3NlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0pO1xuICAgICAgICB9IGNhdGNoICh2KSB7XG4gICAgICAgICAgbih2KTtcbiAgICAgICAgfVxuICAgICAgfSkpKTtcbiAgICB9KSgpKSwgTih0aGlzLCBJdCwgITEpLCBNKHRoaXMsIFp0LCBKZSgpKSwgTSh0aGlzLCBZLCByKSwgTSh0aGlzLCBGdCwge1xuICAgICAgcjogXCJyZWFkLW9ubHlcIixcbiAgICAgIHJ3OiBcInJlYWR3cml0ZVwiLFxuICAgICAgXCJydy11bnNhZmVcIjogXCJyZWFkd3JpdGUtdW5zYWZlXCJcbiAgICB9W2hdKTtcbiAgICBjb25zdCB7IHBhcmVudDogYSwgbmFtZTogZiB9ID0gdGUocik7XG4gICAgTSh0aGlzLCBXdCwgZiksIE0odGhpcywgQnQsIGEpO1xuICB9XG4gIGdldCBraW5kKCkge1xuICAgIHJldHVybiBcImZpbGVcIjtcbiAgfVxuICBnZXQgcGF0aCgpIHtcbiAgICByZXR1cm4gSSh0aGlzLCBZKTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gSSh0aGlzLCBXdCk7XG4gIH1cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gSSh0aGlzLCBCdCkgPT0gbnVsbCA/IG51bGwgOiB2dChJKHRoaXMsIEJ0KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJhbmRvbSB3cml0ZSB0byBmaWxlXG4gICAqL1xuICBhc3luYyBjcmVhdGVXcml0ZXIoKSB7XG4gICAgaWYgKEkodGhpcywgRnQpID09PSBcInJlYWQtb25seVwiKSB0aHJvdyBFcnJvcihcImZpbGUgaXMgcmVhZC1vbmx5XCIpO1xuICAgIGlmIChJKHRoaXMsIEl0KSkgdGhyb3cgRXJyb3IoXCJPdGhlciB3cml0ZXIgaGF2ZSBub3QgYmVlbiBjbG9zZWRcIik7XG4gICAgTSh0aGlzLCBJdCwgITApO1xuICAgIGNvbnN0IHIgPSBuZXcgVGV4dEVuY29kZXIoKSwgW2gsIGFdID0gYXdhaXQgSSh0aGlzLCBYdCkuY2FsbCh0aGlzKTtcbiAgICBsZXQgZiA9IGF3YWl0IGguZ2V0U2l6ZSgpLCBkID0gITE7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBhc3luYyAocCwgbiA9IHt9KSA9PiB7XG4gICAgICAgIGlmIChkKSB0aHJvdyBFcnJvcihcIldyaXRlciBpcyBjbG9zZWRcIik7XG4gICAgICAgIGNvbnN0IHYgPSB0eXBlb2YgcCA9PSBcInN0cmluZ1wiID8gci5lbmNvZGUocCkgOiBwLCBiID0gbi5hdCA/PyBmLCB5ID0gdi5ieXRlTGVuZ3RoO1xuICAgICAgICByZXR1cm4gZiA9IGIgKyB5LCBhd2FpdCBoLndyaXRlKHYsIHsgYXQ6IGIgfSk7XG4gICAgICB9LFxuICAgICAgdHJ1bmNhdGU6IGFzeW5jIChwKSA9PiB7XG4gICAgICAgIGlmIChkKSB0aHJvdyBFcnJvcihcIldyaXRlciBpcyBjbG9zZWRcIik7XG4gICAgICAgIGF3YWl0IGgudHJ1bmNhdGUocCksIGYgPiBwICYmIChmID0gcCk7XG4gICAgICB9LFxuICAgICAgZmx1c2g6IGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGQpIHRocm93IEVycm9yKFwiV3JpdGVyIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgYXdhaXQgaC5mbHVzaCgpO1xuICAgICAgfSxcbiAgICAgIGNsb3NlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChkKSB0aHJvdyBFcnJvcihcIldyaXRlciBpcyBjbG9zZWRcIik7XG4gICAgICAgIGQgPSAhMCwgTSh0aGlzLCBJdCwgITEpLCBhd2FpdCBhKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmFuZG9tIGFjY2VzcyB0byBmaWxlXG4gICAqL1xuICBhc3luYyBjcmVhdGVSZWFkZXIoKSB7XG4gICAgY29uc3QgW3IsIGhdID0gYXdhaXQgSSh0aGlzLCBYdCkuY2FsbCh0aGlzKTtcbiAgICBsZXQgYSA9ICExLCBmID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgcmVhZDogYXN5bmMgKGQsIHAgPSB7fSkgPT4ge1xuICAgICAgICBpZiAoYSkgdGhyb3cgRXJyb3IoXCJSZWFkZXIgaXMgY2xvc2VkXCIpO1xuICAgICAgICBjb25zdCBuID0gcC5hdCA/PyBmLCB2ID0gYXdhaXQgci5yZWFkKG4sIGQpO1xuICAgICAgICByZXR1cm4gZiA9IG4gKyB2LmJ5dGVMZW5ndGgsIHY7XG4gICAgICB9LFxuICAgICAgZ2V0U2l6ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoYSkgdGhyb3cgRXJyb3IoXCJSZWFkZXIgaXMgY2xvc2VkXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgci5nZXRTaXplKCk7XG4gICAgICB9LFxuICAgICAgY2xvc2U6IGFzeW5jICgpID0+IHtcbiAgICAgICAgYSB8fCAoYSA9ICEwLCBhd2FpdCBoKCkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgdGV4dCgpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGF3YWl0IHRoaXMuYXJyYXlCdWZmZXIoKSk7XG4gIH1cbiAgYXN5bmMgYXJyYXlCdWZmZXIoKSB7XG4gICAgY29uc3QgciA9IGF3YWl0IG90KEkodGhpcywgWSksIHsgY3JlYXRlOiAhMSwgaXNGaWxlOiAhMCB9KTtcbiAgICByZXR1cm4gciA9PSBudWxsID8gbmV3IEFycmF5QnVmZmVyKDApIDogKGF3YWl0IHIuZ2V0RmlsZSgpKS5hcnJheUJ1ZmZlcigpO1xuICB9XG4gIGFzeW5jIHN0cmVhbSgpIHtcbiAgICBjb25zdCByID0gYXdhaXQgdGhpcy5nZXRPcmlnaW5GaWxlKCk7XG4gICAgcmV0dXJuIHIgPT0gbnVsbCA/IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBwdWxsOiAoaCkgPT4ge1xuICAgICAgICBoLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSkgOiByLnN0cmVhbSgpO1xuICB9XG4gIGFzeW5jIGdldE9yaWdpbkZpbGUoKSB7XG4gICAgdmFyIHI7XG4gICAgcmV0dXJuIChyID0gYXdhaXQgb3QoSSh0aGlzLCBZKSwgeyBjcmVhdGU6ICExLCBpc0ZpbGU6ICEwIH0pKSA9PSBudWxsID8gdm9pZCAwIDogci5nZXRGaWxlKCk7XG4gIH1cbiAgYXN5bmMgZ2V0U2l6ZSgpIHtcbiAgICBjb25zdCByID0gYXdhaXQgb3QoSSh0aGlzLCBZKSwgeyBjcmVhdGU6ICExLCBpc0ZpbGU6ICEwIH0pO1xuICAgIHJldHVybiByID09IG51bGwgPyAwIDogKGF3YWl0IHIuZ2V0RmlsZSgpKS5zaXplO1xuICB9XG4gIGFzeW5jIGV4aXN0cygpIHtcbiAgICByZXR1cm4gYXdhaXQgb3QoSSh0aGlzLCBZKSwge1xuICAgICAgY3JlYXRlOiAhMSxcbiAgICAgIGlzRmlsZTogITBcbiAgICB9KSBpbnN0YW5jZW9mIEZpbGVTeXN0ZW1GaWxlSGFuZGxlO1xuICB9XG4gIGFzeW5jIHJlbW92ZSgpIHtcbiAgICBpZiAoSSh0aGlzLCBpdCkpIHRocm93IEVycm9yKFwiZXhpc3RzIHVuY2xvc2VkIHJlYWRlci93cml0ZXJcIik7XG4gICAgYXdhaXQgQ2UoSSh0aGlzLCBZKSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZSB0YXJnZXQgaXMgYSBmaWxlLCB1c2UgY3VycmVudCBvdmVyd3JpdGUgdGhlIHRhcmdldDtcbiAgICogaWYgdGhlIHRhcmdldCBpcyBhIGZvbGRlciwgY29weSB0aGUgY3VycmVudCBmaWxlIGludG8gdGhhdCBmb2xkZXIuXG4gICAqL1xuICBhc3luYyBjb3B5VG8ocikge1xuICAgIGlmICghYXdhaXQgdGhpcy5leGlzdHMoKSlcbiAgICAgIHRocm93IEVycm9yKGBmaWxlICR7dGhpcy5wYXRofSBub3QgZXhpc3RzYCk7XG4gICAgaWYgKHIgaW5zdGFuY2VvZiBUZSlcbiAgICAgIHJldHVybiBfdChyLnBhdGgpID09PSB0aGlzID8gdGhpcyA6IChhd2FpdCBDdChyLnBhdGgsIHRoaXMpLCBfdChyLnBhdGgpKTtcbiAgICBpZiAociBpbnN0YW5jZW9mIHplKVxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29weVRvKF90KHNlKHIucGF0aCwgdGhpcy5uYW1lKSkpO1xuICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0YXJnZXQgdHlwZVwiKTtcbiAgfVxuICAvKipcbiAgICogbW92ZSBmaWxlLCBjb3B5IHRoZW4gcmVtb3ZlIGN1cnJlbnRcbiAgICovXG4gIGFzeW5jIG1vdmVUbyhyKSB7XG4gICAgY29uc3QgaCA9IGF3YWl0IHRoaXMuY29weVRvKHIpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlbW92ZSgpLCBoO1xuICB9XG59O1xuWSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBCdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBXdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBGdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBadCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBpdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBYdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IGp0ID0gJGU7XG5jb25zdCBoZSA9IFwiLy5vcGZzLXRvb2xzLXRlbXAtZGlyXCI7XG5hc3luYyBmdW5jdGlvbiBQZShsKSB7XG4gIHRyeSB7XG4gICAgaWYgKGwua2luZCA9PT0gXCJmaWxlXCIpIHtcbiAgICAgIGlmICghYXdhaXQgbC5leGlzdHMoKSkgcmV0dXJuICEwO1xuICAgICAgY29uc3QgciA9IGF3YWl0IGwuY3JlYXRlV3JpdGVyKCk7XG4gICAgICBhd2FpdCByLnRydW5jYXRlKDApLCBhd2FpdCByLmNsb3NlKCksIGF3YWl0IGwucmVtb3ZlKCk7XG4gICAgfSBlbHNlXG4gICAgICBhd2FpdCBsLnJlbW92ZSgpO1xuICAgIHJldHVybiAhMDtcbiAgfSBjYXRjaCAocikge1xuICAgIHJldHVybiBjb25zb2xlLndhcm4ociksICExO1xuICB9XG59XG5mdW5jdGlvbiBxZSgpIHtcbiAgc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgIGZvciAoY29uc3QgbCBvZiBhd2FpdCB2dChoZSkuY2hpbGRyZW4oKSkge1xuICAgICAgY29uc3QgciA9IC9eXFxkKy0oXFxkKykkLy5leGVjKGwubmFtZSk7XG4gICAgICAociA9PSBudWxsIHx8IERhdGUubm93KCkgLSBOdW1iZXIoclsxXSkgPiAyNTkyZTUpICYmIGF3YWl0IFBlKGwpO1xuICAgIH1cbiAgfSwgNjAgKiAxZTMpO1xufVxuY29uc3QgcmUgPSBbXTtcbmxldCBtZSA9ICExO1xuYXN5bmMgZnVuY3Rpb24gdGkoKSB7XG4gIGlmIChnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSA9PSBudWxsKSByZXR1cm47XG4gIGNvbnN0IGwgPSBcIk9QRlNfVE9PTFNfRVhQSVJFU19UTVBfRklMRVNcIjtcbiAgbWUgfHwgKG1lID0gITAsIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCAoKSA9PiB7XG4gICAgcmUubGVuZ3RoICE9PSAwICYmIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgbCxcbiAgICAgIGAke2xvY2FsU3RvcmFnZS5nZXRJdGVtKGwpID8/IFwiXCJ9LCR7cmUuam9pbihcIixcIil9YFxuICAgICk7XG4gIH0pKTtcbiAgbGV0IHIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsKSA/PyBcIlwiO1xuICBmb3IgKGNvbnN0IGggb2Ygci5zcGxpdChcIixcIikpXG4gICAgaC5sZW5ndGggIT09IDAgJiYgYXdhaXQgUGUoX3QoYCR7aGV9LyR7aH1gKSkgJiYgKHIgPSByLnJlcGxhY2UoaCwgXCJcIikpO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsLCByLnJlcGxhY2UoLyx7Mix9L2csIFwiLFwiKSk7XG59XG4oYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHZhciBsO1xuICBnbG9iYWxUaGlzLl9fb3Bmc190b29sc190bXBmaWxlX2luaXRfXyAhPT0gITAgJiYgKGdsb2JhbFRoaXMuX19vcGZzX3Rvb2xzX3RtcGZpbGVfaW5pdF9fID0gITAsICEoZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlID09IG51bGwgfHwgZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZSA9PSBudWxsIHx8ICgobCA9IGdsb2JhbFRoaXMubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogbC5zdG9yYWdlLmdldERpcmVjdG9yeSkgPT0gbnVsbCkgJiYgKHFlKCksIGF3YWl0IHRpKCkpKTtcbn0pKCk7XG5mdW5jdGlvbiBLdCgpIHtcbiAgY29uc3QgbCA9IGAke01hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKX0tJHtEYXRlLm5vdygpfWA7XG4gIHJldHVybiByZS5wdXNoKGwpLCBfdChgJHtoZX0vJHtsfWApO1xufVxuZnVuY3Rpb24gZWkobCkge1xuICByZXR1cm4gbCBpbnN0YW5jZW9mIEVycm9yID8gU3RyaW5nKGwpIDogdHlwZW9mIGwgPT0gXCJvYmplY3RcIiA/IEpTT04uc3RyaW5naWZ5KGwsIChyLCBoKSA9PiBoIGluc3RhbmNlb2YgRXJyb3IgPyBTdHJpbmcoaCkgOiBoKSA6IFN0cmluZyhsKTtcbn1cbmZ1bmN0aW9uIGlpKCkge1xuICBjb25zdCBsID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHJldHVybiBgJHtsLmdldEhvdXJzKCl9OiR7bC5nZXRNaW51dGVzKCl9OiR7bC5nZXRTZWNvbmRzKCl9LiR7bC5nZXRNaWxsaXNlY29uZHMoKX1gO1xufVxubGV0IExlID0gMTtcbmNvbnN0IGtlID0gS3QoKTtcbmxldCBndCA9IG51bGw7XG5jb25zdCB2ZSA9IFtcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiXS5yZWR1Y2UoXG4gIChsLCByLCBoKSA9PiBPYmplY3QuYXNzaWduKGwsIHtcbiAgICBbcl06ICguLi5hKSA9PiB7XG4gICAgICBMZSA8PSBoICYmIChjb25zb2xlW3JdKC4uLmEpLCBndCA9PSBudWxsIHx8IGd0LndyaXRlKFxuICAgICAgICBgWyR7cn1dWyR7aWkoKX1dICAke2EubWFwKChmKSA9PiBlaShmKSkuam9pbihcIiBcIil9XG5gXG4gICAgICApKTtcbiAgICB9XG4gIH0pLFxuICB7fVxuKSwgR3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB6ID0ge1xuICBzZXRMb2dMZXZlbDogKGwpID0+IHtcbiAgICBMZSA9IEd0LmdldChsKSA/PyAxO1xuICB9LFxuICAuLi52ZSxcbiAgY3JlYXRlOiAobCkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHZlKS5tYXAoKFtyLCBoXSkgPT4gW1xuICAgICAgcixcbiAgICAgICguLi5hKSA9PiBoKGwsIC4uLmEpXG4gICAgXSlcbiAgKSxcbiAgYXN5bmMgZHVtcCgpIHtcbiAgICByZXR1cm4gYXdhaXQgc2ksIGF3YWl0IChndCA9PSBudWxsID8gdm9pZCAwIDogZ3QuZmx1c2goKSksIGF3YWl0IGtlLnRleHQoKTtcbiAgfVxufTtcbkd0LnNldCh6LmRlYnVnLCAwKTtcbkd0LnNldCh6LmluZm8sIDEpO1xuR3Quc2V0KHoud2FybiwgMik7XG5HdC5zZXQoei5lcnJvciwgMyk7XG5hc3luYyBmdW5jdGlvbiBuaSgpIHtcbiAgdHJ5IHtcbiAgICBndCA9IGF3YWl0IGtlLmNyZWF0ZVdyaXRlcigpLCB6LmluZm8obmF2aWdhdG9yLnVzZXJBZ2VudCksIHouaW5mbyhcImRhdGU6IFwiICsgKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0xvY2FsZURhdGVTdHJpbmcoKSk7XG4gIH0gY2F0Y2ggKGwpIHtcbiAgICBpZiAoIShsIGluc3RhbmNlb2YgRXJyb3IpKSB0aHJvdyBsO1xuICAgIGlmIChsLm1lc3NhZ2UuaW5jbHVkZXMoXCJjcmVhdGVTeW5jQWNjZXNzSGFuZGxlIGlzIG5vdCBhIGZ1bmN0aW9uXCIpKVxuICAgICAgY29uc29sZS53YXJuKGwpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IGw7XG4gIH1cbn1cbmNvbnN0IHNpID0gZ2xvYmFsVGhpcy5uYXZpZ2F0b3IgPT0gbnVsbCA/IG51bGwgOiBuaSgpLCByaSA9ICgpID0+IHtcbiAgbGV0IGwsIHIgPSAxNi42O1xuICBzZWxmLm9ubWVzc2FnZSA9IChoKSA9PiB7XG4gICAgaC5kYXRhLmV2ZW50ID09PSBcInN0YXJ0XCIgJiYgKHNlbGYuY2xlYXJJbnRlcnZhbChsKSwgbCA9IHNlbGYuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7fSk7XG4gICAgfSwgcikpLCBoLmRhdGEuZXZlbnQgPT09IFwic3RvcFwiICYmIHNlbGYuY2xlYXJJbnRlcnZhbChsKTtcbiAgfTtcbn0sIGFpID0gKCkgPT4ge1xuICBjb25zdCBsID0gbmV3IEJsb2IoW2AoJHtyaS50b1N0cmluZygpfSkoKWBdKSwgciA9IFVSTC5jcmVhdGVPYmplY3RVUkwobCk7XG4gIHJldHVybiBuZXcgV29ya2VyKHIpO1xufSwgbXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xubGV0IGFlID0gMSwgbnQgPSBudWxsO1xuZ2xvYmFsVGhpcy5Xb3JrZXIgIT0gbnVsbCAmJiAobnQgPSBhaSgpLCBudC5vbm1lc3NhZ2UgPSAoKSA9PiB7XG4gIGFlICs9IDE7XG4gIGZvciAoY29uc3QgW2wsIHJdIG9mIG10KVxuICAgIGlmIChhZSAlIGwgPT09IDApIGZvciAoY29uc3QgaCBvZiByKSBoKCk7XG59KTtcbmNvbnN0IERlID0gKGwsIHIpID0+IHtcbiAgY29uc3QgaCA9IE1hdGgucm91bmQociAvIDE2LjYpLCBhID0gbXQuZ2V0KGgpID8/IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiBhLmFkZChsKSwgbXQuc2V0KGgsIGEpLCBtdC5zaXplID09PSAxICYmIGEuc2l6ZSA9PT0gMSAmJiAobnQgPT0gbnVsbCB8fCBudC5wb3N0TWVzc2FnZSh7IGV2ZW50OiBcInN0YXJ0XCIgfSkpLCAoKSA9PiB7XG4gICAgYS5kZWxldGUobCksIGEuc2l6ZSA9PT0gMCAmJiBtdC5kZWxldGUoaCksIG10LnNpemUgPT09IDAgJiYgKGFlID0gMCwgbnQgPT0gbnVsbCB8fCBudC5wb3N0TWVzc2FnZSh7IGV2ZW50OiBcInN0b3BcIiB9KSk7XG4gIH07XG59O1xuY2xhc3Mgb2kge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlRnJvbSB0aGUgbGVuZ3RoIG9mIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlVG8gVGhlIGxlbmd0aCBvZiB0aGUgbmV3IGFycmF5LlxuICAgKiBAcGFyYW0gez9PYmplY3R9IGRldGFpbHMgVGhlIGV4dHJhIGNvbmZpZ3VyYXRpb24sIGlmIG5lZWRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHIsIGgsIGEpIHtcbiAgICB0aGlzLmxlbmd0aF8gPSByLCB0aGlzLnNjYWxlRmFjdG9yXyA9IChyIC0gMSkgLyBoLCB0aGlzLmludGVycG9sYXRlID0gdGhpcy5jdWJpYywgYS5tZXRob2QgPT09IFwicG9pbnRcIiA/IHRoaXMuaW50ZXJwb2xhdGUgPSB0aGlzLnBvaW50IDogYS5tZXRob2QgPT09IFwibGluZWFyXCIgPyB0aGlzLmludGVycG9sYXRlID0gdGhpcy5saW5lYXIgOiBhLm1ldGhvZCA9PT0gXCJzaW5jXCIgJiYgKHRoaXMuaW50ZXJwb2xhdGUgPSB0aGlzLnNpbmMpLCB0aGlzLnRhbmdlbnRGYWN0b3JfID0gMSAtIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEudGVuc2lvbiB8fCAwKSksIHRoaXMuc2luY0ZpbHRlclNpemVfID0gYS5zaW5jRmlsdGVyU2l6ZSB8fCAxLCB0aGlzLmtlcm5lbF8gPSBsaShhLnNpbmNXaW5kb3cgfHwgaGkpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdCBUaGUgaW5kZXggdG8gaW50ZXJwb2xhdGUuXG4gICAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gc2FtcGxlcyB0aGUgb3JpZ2luYWwgYXJyYXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZS5cbiAgICovXG4gIHBvaW50KHIsIGgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDbGlwcGVkSW5wdXRfKE1hdGgucm91bmQodGhpcy5zY2FsZUZhY3Rvcl8gKiByKSwgaCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IFRoZSBpbmRleCB0byBpbnRlcnBvbGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBzYW1wbGVzIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlLlxuICAgKi9cbiAgbGluZWFyKHIsIGgpIHtcbiAgICByID0gdGhpcy5zY2FsZUZhY3Rvcl8gKiByO1xuICAgIGxldCBhID0gTWF0aC5mbG9vcihyKTtcbiAgICByZXR1cm4gciAtPSBhLCAoMSAtIHIpICogdGhpcy5nZXRDbGlwcGVkSW5wdXRfKGEsIGgpICsgciAqIHRoaXMuZ2V0Q2xpcHBlZElucHV0XyhhICsgMSwgaCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IFRoZSBpbmRleCB0byBpbnRlcnBvbGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBzYW1wbGVzIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlLlxuICAgKi9cbiAgY3ViaWMociwgaCkge1xuICAgIHIgPSB0aGlzLnNjYWxlRmFjdG9yXyAqIHI7XG4gICAgbGV0IGEgPSBNYXRoLmZsb29yKHIpLCBmID0gW3RoaXMuZ2V0VGFuZ2VudF8oYSwgaCksIHRoaXMuZ2V0VGFuZ2VudF8oYSArIDEsIGgpXSwgZCA9IFtcbiAgICAgIHRoaXMuZ2V0Q2xpcHBlZElucHV0XyhhLCBoKSxcbiAgICAgIHRoaXMuZ2V0Q2xpcHBlZElucHV0XyhhICsgMSwgaClcbiAgICBdO1xuICAgIHIgLT0gYTtcbiAgICBsZXQgcCA9IHIgKiByLCBuID0gciAqIHA7XG4gICAgcmV0dXJuICgyICogbiAtIDMgKiBwICsgMSkgKiBkWzBdICsgKG4gLSAyICogcCArIHIpICogZlswXSArICgtMiAqIG4gKyAzICogcCkgKiBkWzFdICsgKG4gLSBwKSAqIGZbMV07XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IFRoZSBpbmRleCB0byBpbnRlcnBvbGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBzYW1wbGVzIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlLlxuICAgKi9cbiAgc2luYyhyLCBoKSB7XG4gICAgciA9IHRoaXMuc2NhbGVGYWN0b3JfICogcjtcbiAgICBsZXQgYSA9IE1hdGguZmxvb3IociksIGYgPSBhIC0gdGhpcy5zaW5jRmlsdGVyU2l6ZV8gKyAxLCBkID0gYSArIHRoaXMuc2luY0ZpbHRlclNpemVfLCBwID0gMDtcbiAgICBmb3IgKGxldCBuID0gZjsgbiA8PSBkOyBuKyspXG4gICAgICBwICs9IHRoaXMua2VybmVsXyhyIC0gbikgKiB0aGlzLmdldENsaXBwZWRJbnB1dF8obiwgaCk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFRoZSBzY2FsZWQgaW5kZXggdG8gaW50ZXJwb2xhdGUuXG4gICAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gc2FtcGxlcyB0aGUgb3JpZ2luYWwgYXJyYXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRhbmdlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRUYW5nZW50XyhyLCBoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFuZ2VudEZhY3Rvcl8gKiAodGhpcy5nZXRDbGlwcGVkSW5wdXRfKHIgKyAxLCBoKSAtIHRoaXMuZ2V0Q2xpcHBlZElucHV0XyhyIC0gMSwgaCkpIC8gMjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIHNjYWxlZCBpbmRleCB0byBpbnRlcnBvbGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBzYW1wbGVzIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q2xpcHBlZElucHV0XyhyLCBoKSB7XG4gICAgcmV0dXJuIDAgPD0gciAmJiByIDwgdGhpcy5sZW5ndGhfID8gaFtyXSA6IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGhpKGwpIHtcbiAgcmV0dXJuIE1hdGguZXhwKC1sIC8gMiAqIGwgLyAyKTtcbn1cbmZ1bmN0aW9uIGxpKGwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gZmkocikgKiBsKHIpO1xuICB9O1xufVxuZnVuY3Rpb24gZmkobCkge1xuICByZXR1cm4gbCA9PT0gMCA/IDEgOiBNYXRoLnNpbihNYXRoLlBJICogbCkgLyAoTWF0aC5QSSAqIGwpO1xufVxuY2xhc3MgZGkge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yZGVyIFRoZSBvcmRlciBvZiB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlUmF0ZSBUaGUgc2FtcGxlIHJhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXRPZmYgVGhlIGN1dCBvZmYgZnJlcXVlbmN5LlxuICAgKi9cbiAgY29uc3RydWN0b3IociwgaCwgYSkge1xuICAgIGxldCBmID0gMiAqIE1hdGguUEkgKiBhIC8gaCwgZCA9IDA7XG4gICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPD0gcjsgcCsrKVxuICAgICAgcCAtIHIgLyAyID09PSAwID8gdGhpcy5maWx0ZXJzW3BdID0gZiA6ICh0aGlzLmZpbHRlcnNbcF0gPSBNYXRoLnNpbihmICogKHAgLSByIC8gMikpIC8gKHAgLSByIC8gMiksIHRoaXMuZmlsdGVyc1twXSAqPSAwLjU0IC0gMC40NiAqIE1hdGguY29zKDIgKiBNYXRoLlBJICogcCAvIHIpKSwgZCA9IGQgKyB0aGlzLmZpbHRlcnNbcF07XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPD0gcjsgcCsrKVxuICAgICAgdGhpcy5maWx0ZXJzW3BdIC89IGQ7XG4gICAgdGhpcy56ID0gdGhpcy5pbml0Wl8oKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZSBBIHNhbXBsZSBvZiBhIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBmaWx0ZXIocikge1xuICAgIHRoaXMuei5idWZbdGhpcy56LnBvaW50ZXJdID0gcjtcbiAgICBsZXQgaCA9IDA7XG4gICAgZm9yIChsZXQgYSA9IDAsIGYgPSB0aGlzLnouYnVmLmxlbmd0aDsgYSA8IGY7IGErKylcbiAgICAgIGggKz0gdGhpcy5maWx0ZXJzW2FdICogdGhpcy56LmJ1ZlsodGhpcy56LnBvaW50ZXIgKyBhKSAlIHRoaXMuei5idWYubGVuZ3RoXTtcbiAgICByZXR1cm4gdGhpcy56LnBvaW50ZXIgPSAodGhpcy56LnBvaW50ZXIgKyAxKSAlIHRoaXMuei5idWYubGVuZ3RoLCBoO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCB0aGUgZmlsdGVyLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy56ID0gdGhpcy5pbml0Wl8oKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB6LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdFpfKCkge1xuICAgIGxldCByID0gW107XG4gICAgZm9yIChsZXQgaCA9IDA7IGggPCB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaCsrKVxuICAgICAgci5wdXNoKDApO1xuICAgIHJldHVybiB7XG4gICAgICBidWY6IHIsXG4gICAgICBwb2ludGVyOiAwXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgY2kge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yZGVyIFRoZSBvcmRlciBvZiB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlUmF0ZSBUaGUgc2FtcGxlIHJhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXRPZmYgVGhlIGN1dCBvZmYgZnJlcXVlbmN5LlxuICAgKi9cbiAgY29uc3RydWN0b3IociwgaCwgYSkge1xuICAgIGxldCBmID0gW107XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCByOyBkKyspXG4gICAgICBmLnB1c2godGhpcy5nZXRDb2VmZnNfKHtcbiAgICAgICAgRnM6IGgsXG4gICAgICAgIEZjOiBhLFxuICAgICAgICBROiAwLjUgLyBNYXRoLnNpbihNYXRoLlBJIC8gKHIgKiAyKSAqIChkICsgMC41KSlcbiAgICAgIH0pKTtcbiAgICB0aGlzLnN0YWdlcyA9IFtdO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZi5sZW5ndGg7IGQrKylcbiAgICAgIHRoaXMuc3RhZ2VzW2RdID0ge1xuICAgICAgICBiMDogZltkXS5iWzBdLFxuICAgICAgICBiMTogZltkXS5iWzFdLFxuICAgICAgICBiMjogZltkXS5iWzJdLFxuICAgICAgICBhMTogZltkXS5hWzBdLFxuICAgICAgICBhMjogZltkXS5hWzFdLFxuICAgICAgICBrOiBmW2RdLmssXG4gICAgICAgIHo6IFswLCAwXVxuICAgICAgfTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZSBBIHNhbXBsZSBvZiBhIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBmaWx0ZXIocikge1xuICAgIGxldCBoID0gcjtcbiAgICBmb3IgKGxldCBhID0gMCwgZiA9IHRoaXMuc3RhZ2VzLmxlbmd0aDsgYSA8IGY7IGErKylcbiAgICAgIGggPSB0aGlzLnJ1blN0YWdlXyhhLCBoKTtcbiAgICByZXR1cm4gaDtcbiAgfVxuICBnZXRDb2VmZnNfKHIpIHtcbiAgICBsZXQgaCA9IHt9O1xuICAgIGgueiA9IFswLCAwXSwgaC5hID0gW10sIGguYiA9IFtdO1xuICAgIGxldCBhID0gdGhpcy5wcmVDYWxjXyhyLCBoKTtcbiAgICByZXR1cm4gaC5rID0gMSwgaC5iLnB1c2goKDEgLSBhLmN3KSAvICgyICogYS5hMCkpLCBoLmIucHVzaCgyICogaC5iWzBdKSwgaC5iLnB1c2goaC5iWzBdKSwgaDtcbiAgfVxuICBwcmVDYWxjXyhyLCBoKSB7XG4gICAgbGV0IGEgPSB7fSwgZiA9IDIgKiBNYXRoLlBJICogci5GYyAvIHIuRnM7XG4gICAgcmV0dXJuIGEuYWxwaGEgPSBNYXRoLnNpbihmKSAvICgyICogci5RKSwgYS5jdyA9IE1hdGguY29zKGYpLCBhLmEwID0gMSArIGEuYWxwaGEsIGguYTAgPSBhLmEwLCBoLmEucHVzaCgtMiAqIGEuY3cgLyBhLmEwKSwgaC5rID0gMSwgaC5hLnB1c2goKDEgLSBhLmFscGhhKSAvIGEuYTApLCBhO1xuICB9XG4gIHJ1blN0YWdlXyhyLCBoKSB7XG4gICAgbGV0IGEgPSBoICogdGhpcy5zdGFnZXNbcl0uayAtIHRoaXMuc3RhZ2VzW3JdLmExICogdGhpcy5zdGFnZXNbcl0uelswXSAtIHRoaXMuc3RhZ2VzW3JdLmEyICogdGhpcy5zdGFnZXNbcl0uelsxXSwgZiA9IHRoaXMuc3RhZ2VzW3JdLmIwICogYSArIHRoaXMuc3RhZ2VzW3JdLmIxICogdGhpcy5zdGFnZXNbcl0uelswXSArIHRoaXMuc3RhZ2VzW3JdLmIyICogdGhpcy5zdGFnZXNbcl0uelsxXTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZXNbcl0uelsxXSA9IHRoaXMuc3RhZ2VzW3JdLnpbMF0sIHRoaXMuc3RhZ2VzW3JdLnpbMF0gPSBhLCBmO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCB0aGUgZmlsdGVyLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCB0aGlzLnN0YWdlcy5sZW5ndGg7IHIrKylcbiAgICAgIHRoaXMuc3RhZ2VzW3JdLnogPSBbMCwgMF07XG4gIH1cbn1cbmNvbnN0IHVpID0ge1xuICBwb2ludDogITEsXG4gIGxpbmVhcjogITEsXG4gIGN1YmljOiAhMCxcbiAgc2luYzogITBcbn0sIHdlID0ge1xuICBJSVI6IDE2LFxuICBGSVI6IDcxXG59LCBwaSA9IHtcbiAgSUlSOiBjaSxcbiAgRklSOiBkaVxufTtcbmZ1bmN0aW9uIF9pKGwsIHIsIGgsIGEgPSB7fSkge1xuICBsZXQgZiA9IChoIC0gcikgLyByICsgMSwgZCA9IG5ldyBGbG9hdDY0QXJyYXkobC5sZW5ndGggKiBmKTtcbiAgYS5tZXRob2QgPSBhLm1ldGhvZCB8fCBcImN1YmljXCI7XG4gIGxldCBwID0gbmV3IG9pKFxuICAgIGwubGVuZ3RoLFxuICAgIGQubGVuZ3RoLFxuICAgIHtcbiAgICAgIG1ldGhvZDogYS5tZXRob2QsXG4gICAgICB0ZW5zaW9uOiBhLnRlbnNpb24gfHwgMCxcbiAgICAgIHNpbmNGaWx0ZXJTaXplOiBhLnNpbmNGaWx0ZXJTaXplIHx8IDYsXG4gICAgICBzaW5jV2luZG93OiBhLnNpbmNXaW5kb3cgfHwgdm9pZCAwXG4gICAgfVxuICApO1xuICBpZiAoYS5MUEYgPT09IHZvaWQgMCAmJiAoYS5MUEYgPSB1aVthLm1ldGhvZF0pLCBhLkxQRikge1xuICAgIGEuTFBGVHlwZSA9IGEuTFBGVHlwZSB8fCBcIklJUlwiO1xuICAgIGNvbnN0IG4gPSBwaVthLkxQRlR5cGVdO1xuICAgIGlmIChoID4gcikge1xuICAgICAgbGV0IHYgPSBuZXcgbihcbiAgICAgICAgYS5MUEZPcmRlciB8fCB3ZVthLkxQRlR5cGVdLFxuICAgICAgICBoLFxuICAgICAgICByIC8gMlxuICAgICAgKTtcbiAgICAgIGdpKFxuICAgICAgICBsLFxuICAgICAgICBkLFxuICAgICAgICBwLFxuICAgICAgICB2XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdiA9IG5ldyBuKFxuICAgICAgICBhLkxQRk9yZGVyIHx8IHdlW2EuTFBGVHlwZV0sXG4gICAgICAgIHIsXG4gICAgICAgIGggLyAyXG4gICAgICApO1xuICAgICAgeWkoXG4gICAgICAgIGwsXG4gICAgICAgIGQsXG4gICAgICAgIHAsXG4gICAgICAgIHZcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2VcbiAgICBSZShsLCBkLCBwKTtcbiAgcmV0dXJuIGQ7XG59XG5mdW5jdGlvbiBSZShsLCByLCBoKSB7XG4gIGZvciAobGV0IGEgPSAwLCBmID0gci5sZW5ndGg7IGEgPCBmOyBhKyspXG4gICAgclthXSA9IGguaW50ZXJwb2xhdGUoYSwgbCk7XG59XG5mdW5jdGlvbiBnaShsLCByLCBoLCBhKSB7XG4gIGZvciAobGV0IGYgPSAwLCBkID0gci5sZW5ndGg7IGYgPCBkOyBmKyspXG4gICAgcltmXSA9IGEuZmlsdGVyKGguaW50ZXJwb2xhdGUoZiwgbCkpO1xuICBhLnJlc2V0KCk7XG4gIGZvciAobGV0IGYgPSByLmxlbmd0aCAtIDE7IGYgPj0gMDsgZi0tKVxuICAgIHJbZl0gPSBhLmZpbHRlcihyW2ZdKTtcbn1cbmZ1bmN0aW9uIHlpKGwsIHIsIGgsIGEpIHtcbiAgZm9yIChsZXQgZiA9IDAsIGQgPSBsLmxlbmd0aDsgZiA8IGQ7IGYrKylcbiAgICBsW2ZdID0gYS5maWx0ZXIobFtmXSk7XG4gIGEucmVzZXQoKTtcbiAgZm9yIChsZXQgZiA9IGwubGVuZ3RoIC0gMTsgZiA+PSAwOyBmLS0pXG4gICAgbFtmXSA9IGEuZmlsdGVyKGxbZl0pO1xuICBSZShsLCByLCBoKTtcbn1cbmZ1bmN0aW9uIE1lKGwpIHtcbiAgY29uc3QgciA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgbC5tYXAoKGEpID0+IGEubGVuZ3RoKS5yZWR1Y2UoKGEsIGYpID0+IGEgKyBmKVxuICApO1xuICBsZXQgaCA9IDA7XG4gIGZvciAoY29uc3QgYSBvZiBsKVxuICAgIHIuc2V0KGEsIGgpLCBoICs9IGEubGVuZ3RoO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIG1pKGwpIHtcbiAgY29uc3QgciA9IFtdO1xuICBmb3IgKGxldCBoID0gMDsgaCA8IGwubGVuZ3RoOyBoICs9IDEpXG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCBsW2hdLmxlbmd0aDsgYSArPSAxKVxuICAgICAgclthXSA9PSBudWxsICYmIChyW2FdID0gW10pLCByW2FdLnB1c2gobFtoXVthXSk7XG4gIHJldHVybiByLm1hcChNZSk7XG59XG5mdW5jdGlvbiBsZShsKSB7XG4gIGlmIChsLmZvcm1hdCA9PT0gXCJmMzItcGxhbmFyXCIpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChsZXQgaCA9IDA7IGggPCBsLm51bWJlck9mQ2hhbm5lbHM7IGggKz0gMSkge1xuICAgICAgY29uc3QgYSA9IGwuYWxsb2NhdGlvblNpemUoeyBwbGFuZUluZGV4OiBoIH0pLCBmID0gbmV3IEFycmF5QnVmZmVyKGEpO1xuICAgICAgbC5jb3B5VG8oZiwgeyBwbGFuZUluZGV4OiBoIH0pLCByLnB1c2gobmV3IEZsb2F0MzJBcnJheShmKSk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9IGVsc2UgaWYgKGwuZm9ybWF0ID09PSBcImYzMlwiKSB7XG4gICAgY29uc3QgciA9IG5ldyBBcnJheUJ1ZmZlcihsLmFsbG9jYXRpb25TaXplKHsgcGxhbmVJbmRleDogMCB9KSk7XG4gICAgcmV0dXJuIGwuY29weVRvKHIsIHsgcGxhbmVJbmRleDogMCB9KSwgd2kobmV3IEZsb2F0MzJBcnJheShyKSwgbC5udW1iZXJPZkNoYW5uZWxzKTtcbiAgfSBlbHNlIGlmIChsLmZvcm1hdCA9PT0gXCJzMTZcIikge1xuICAgIGNvbnN0IHIgPSBuZXcgQXJyYXlCdWZmZXIobC5hbGxvY2F0aW9uU2l6ZSh7IHBsYW5lSW5kZXg6IDAgfSkpO1xuICAgIHJldHVybiBsLmNvcHlUbyhyLCB7IHBsYW5lSW5kZXg6IDAgfSksIHZpKG5ldyBJbnQxNkFycmF5KHIpLCBsLm51bWJlck9mQ2hhbm5lbHMpO1xuICB9XG4gIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgYXVkaW8gZGF0YSBmb3JtYXRcIik7XG59XG5mdW5jdGlvbiB2aShsLCByKSB7XG4gIGNvbnN0IGggPSBsLmxlbmd0aCAvIHIsIGEgPSBBcnJheS5mcm9tKFxuICAgIHsgbGVuZ3RoOiByIH0sXG4gICAgKCkgPT4gbmV3IEZsb2F0MzJBcnJheShoKVxuICApO1xuICBmb3IgKGxldCBmID0gMDsgZiA8IGg7IGYrKylcbiAgICBmb3IgKGxldCBkID0gMDsgZCA8IHI7IGQrKykge1xuICAgICAgY29uc3QgcCA9IGxbZiAqIHIgKyBkXTtcbiAgICAgIGFbZF1bZl0gPSBwIC8gMzI3Njg7XG4gICAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIHdpKGwsIHIpIHtcbiAgY29uc3QgaCA9IGwubGVuZ3RoIC8gciwgYSA9IEFycmF5LmZyb20oXG4gICAgeyBsZW5ndGg6IHIgfSxcbiAgICAoKSA9PiBuZXcgRmxvYXQzMkFycmF5KGgpXG4gICk7XG4gIGZvciAobGV0IGYgPSAwOyBmIDwgaDsgZisrKVxuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgcjsgZCsrKVxuICAgICAgYVtkXVtmXSA9IGxbZiAqIHIgKyBkXTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBPZShsKSB7XG4gIHJldHVybiBBcnJheShsLm51bWJlck9mQ2hhbm5lbHMpLmZpbGwoMCkubWFwKChyLCBoKSA9PiBsLmdldENoYW5uZWxEYXRhKGgpKTtcbn1cbmZ1bmN0aW9uIGVuKGwsIHIpIHtcbiAgY29uc3QgaCA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgTWUobGUobCkpXG4gICkubWFwKChmKSA9PiBmICogciksIGEgPSBuZXcgQXVkaW9EYXRhKHtcbiAgICBzYW1wbGVSYXRlOiBsLnNhbXBsZVJhdGUsXG4gICAgbnVtYmVyT2ZDaGFubmVsczogbC5udW1iZXJPZkNoYW5uZWxzLFxuICAgIHRpbWVzdGFtcDogbC50aW1lc3RhbXAsXG4gICAgZm9ybWF0OiBsLmZvcm1hdCxcbiAgICBudW1iZXJPZkZyYW1lczogbC5udW1iZXJPZkZyYW1lcyxcbiAgICBkYXRhOiBoXG4gIH0pO1xuICByZXR1cm4gbC5jbG9zZSgpLCBhO1xufVxuYXN5bmMgZnVuY3Rpb24gbm4obCwgcikge1xuICB2YXIgcDtcbiAgY29uc3QgaCA9IHtcbiAgICB0eXBlOiByLFxuICAgIGRhdGE6IGxcbiAgfSwgYSA9IG5ldyBJbWFnZURlY29kZXIoaCk7XG4gIGF3YWl0IFByb21pc2UuYWxsKFthLmNvbXBsZXRlZCwgYS50cmFja3MucmVhZHldKTtcbiAgbGV0IGYgPSAoKHAgPSBhLnRyYWNrcy5zZWxlY3RlZFRyYWNrKSA9PSBudWxsID8gdm9pZCAwIDogcC5mcmFtZUNvdW50KSA/PyAxO1xuICBjb25zdCBkID0gW107XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgZjsgbiArPSAxKVxuICAgIGQucHVzaCgoYXdhaXQgYS5kZWNvZGUoeyBmcmFtZUluZGV4OiBuIH0pKS5pbWFnZSk7XG4gIHJldHVybiBkO1xufVxuZnVuY3Rpb24gYmUobCkge1xuICB2YXIgYSwgZjtcbiAgY29uc3QgciA9IE1hdGgubWF4KC4uLmwubWFwKChkKSA9PiB7XG4gICAgdmFyIHA7XG4gICAgcmV0dXJuICgocCA9IGRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBwLmxlbmd0aCkgPz8gMDtcbiAgfSkpLCBoID0gbmV3IEZsb2F0MzJBcnJheShyICogMik7XG4gIGZvciAobGV0IGQgPSAwOyBkIDwgcjsgZCsrKSB7XG4gICAgbGV0IHAgPSAwLCBuID0gMDtcbiAgICBmb3IgKGxldCB2ID0gMDsgdiA8IGwubGVuZ3RoOyB2KyspIHtcbiAgICAgIGNvbnN0IGIgPSAoKGEgPSBsW3ZdWzBdKSA9PSBudWxsID8gdm9pZCAwIDogYVtkXSkgPz8gMCwgeSA9ICgoZiA9IGxbdl1bMV0pID09IG51bGwgPyB2b2lkIDAgOiBmW2RdKSA/PyBiO1xuICAgICAgcCArPSBiLCBuICs9IHk7XG4gICAgfVxuICAgIGhbZF0gPSBwLCBoW2QgKyByXSA9IG47XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5hc3luYyBmdW5jdGlvbiBiaShsLCByLCBoKSB7XG4gIGNvbnN0IGEgPSBsLmxlbmd0aCwgZiA9IEFycmF5KGguY2hhbkNvdW50KS5maWxsKDApLm1hcCgoKSA9PiBuZXcgRmxvYXQzMkFycmF5KDApKTtcbiAgaWYgKGEgPT09IDApIHJldHVybiBmO1xuICBjb25zdCBkID0gTWF0aC5tYXgoLi4ubC5tYXAoKGIpID0+IGIubGVuZ3RoKSk7XG4gIGlmIChkID09PSAwKSByZXR1cm4gZjtcbiAgaWYgKGdsb2JhbFRoaXMuT2ZmbGluZUF1ZGlvQ29udGV4dCA9PSBudWxsKVxuICAgIHJldHVybiBsLm1hcChcbiAgICAgIChiKSA9PiBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICBfaShiLCByLCBoLnJhdGUsIHsgbWV0aG9kOiBcInNpbmNcIiwgTFBGOiAhMSB9KVxuICAgICAgKVxuICAgICk7XG4gIGNvbnN0IHAgPSBuZXcgZ2xvYmFsVGhpcy5PZmZsaW5lQXVkaW9Db250ZXh0KFxuICAgIGguY2hhbkNvdW50LFxuICAgIGQgKiBoLnJhdGUgLyByLFxuICAgIGgucmF0ZVxuICApLCBuID0gcC5jcmVhdGVCdWZmZXJTb3VyY2UoKSwgdiA9IHAuY3JlYXRlQnVmZmVyKGEsIGQsIHIpO1xuICByZXR1cm4gbC5mb3JFYWNoKChiLCB5KSA9PiB2LmNvcHlUb0NoYW5uZWwoYiwgeSkpLCBuLmJ1ZmZlciA9IHYsIG4uY29ubmVjdChwLmRlc3RpbmF0aW9uKSwgbi5zdGFydCgpLCBPZShhd2FpdCBwLnN0YXJ0UmVuZGVyaW5nKCkpO1xufVxuZnVuY3Rpb24gTmUobCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICBjb25zdCBoID0gRGUoKCkgPT4ge1xuICAgICAgaCgpLCByKCk7XG4gICAgfSwgbCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gU2kobCwgciwgaCkge1xuICBjb25zdCBhID0gaCAtIHIsIGYgPSBuZXcgRmxvYXQzMkFycmF5KGEpO1xuICBsZXQgZCA9IDA7XG4gIGZvciAoOyBkIDwgYTsgKVxuICAgIGZbZF0gPSBsWyhyICsgZCkgJSBsLmxlbmd0aF0sIGQgKz0gMTtcbiAgcmV0dXJuIGY7XG59XG5mdW5jdGlvbiBmZShsLCByKSB7XG4gIGxldCBoID0gITE7XG4gIGFzeW5jIGZ1bmN0aW9uIGEoKSB7XG4gICAgY29uc3QgZiA9IGwuZ2V0UmVhZGVyKCk7XG4gICAgZm9yICg7ICFoOyApIHtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IGQsIGRvbmU6IHAgfSA9IGF3YWl0IGYucmVhZCgpO1xuICAgICAgaWYgKHApIHtcbiAgICAgICAgci5vbkRvbmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgci5vbkNodW5rKGQpO1xuICAgIH1cbiAgICBmLnJlbGVhc2VMb2NrKCksIGF3YWl0IGwuY2FuY2VsKCk7XG4gIH1cbiAgcmV0dXJuIGEoKS5jYXRjaCh6LmVycm9yKSwgKCkgPT4ge1xuICAgIGggPSAhMDtcbiAgfTtcbn1cbmZ1bmN0aW9uIHhpKGwpIHtcbiAgcmV0dXJuIGwgJiYgbC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsLCBcImRlZmF1bHRcIikgPyBsLmRlZmF1bHQgOiBsO1xufVxudmFyIEdlID0ge307XG4oZnVuY3Rpb24obCkge1xuICB2YXIgciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBlID0gNCwgaSA9IDMsIHMgPSAyLCBvID0gMSwgYyA9IGUsIHUgPSB7XG4gICAgICBzZXRMb2dMZXZlbDogZnVuY3Rpb24oXykge1xuICAgICAgICBfID09IHRoaXMuZGVidWcgPyBjID0gbyA6IF8gPT0gdGhpcy5pbmZvID8gYyA9IHMgOiBfID09IHRoaXMud2FybiA/IGMgPSBpIDogKF8gPT0gdGhpcy5lcnJvciwgYyA9IGUpO1xuICAgICAgfSxcbiAgICAgIGRlYnVnOiBmdW5jdGlvbihfLCBnKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcgPT09IHZvaWQgMCAmJiAoY29uc29sZS5kZWJ1ZyA9IGNvbnNvbGUubG9nKSwgbyA+PSBjICYmIGNvbnNvbGUuZGVidWcoXCJbXCIgKyByLmdldER1cmF0aW9uU3RyaW5nKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpIC0gdCwgMWUzKSArIFwiXVwiLCBcIltcIiArIF8gKyBcIl1cIiwgZyk7XG4gICAgICB9LFxuICAgICAgbG9nOiBmdW5jdGlvbihfLCBnKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXy5tc2cpO1xuICAgICAgfSxcbiAgICAgIGluZm86IGZ1bmN0aW9uKF8sIGcpIHtcbiAgICAgICAgcyA+PSBjICYmIGNvbnNvbGUuaW5mbyhcIltcIiArIHIuZ2V0RHVyYXRpb25TdHJpbmcoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgLSB0LCAxZTMpICsgXCJdXCIsIFwiW1wiICsgXyArIFwiXVwiLCBnKTtcbiAgICAgIH0sXG4gICAgICB3YXJuOiBmdW5jdGlvbihfLCBnKSB7XG4gICAgICAgIGkgPj0gYyAmJiBjb25zb2xlLndhcm4oXCJbXCIgKyByLmdldER1cmF0aW9uU3RyaW5nKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpIC0gdCwgMWUzKSArIFwiXVwiLCBcIltcIiArIF8gKyBcIl1cIiwgZyk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uKF8sIGcpIHtcbiAgICAgICAgZSA+PSBjICYmIGNvbnNvbGUuZXJyb3IoXCJbXCIgKyByLmdldER1cmF0aW9uU3RyaW5nKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpIC0gdCwgMWUzKSArIFwiXVwiLCBcIltcIiArIF8gKyBcIl1cIiwgZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdTtcbiAgfSgpO1xuICByLmdldER1cmF0aW9uU3RyaW5nID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHZhciBpO1xuICAgIGZ1bmN0aW9uIHModywgUykge1xuICAgICAgZm9yICh2YXIgVSA9IFwiXCIgKyB3LCBDID0gVS5zcGxpdChcIi5cIik7IENbMF0ubGVuZ3RoIDwgUzsgKVxuICAgICAgICBDWzBdID0gXCIwXCIgKyBDWzBdO1xuICAgICAgcmV0dXJuIEMuam9pbihcIi5cIik7XG4gICAgfVxuICAgIHQgPCAwID8gKGkgPSAhMCwgdCA9IC10KSA6IGkgPSAhMTtcbiAgICB2YXIgbyA9IGUgfHwgMSwgYyA9IHQgLyBvLCB1ID0gTWF0aC5mbG9vcihjIC8gMzYwMCk7XG4gICAgYyAtPSB1ICogMzYwMDtcbiAgICB2YXIgXyA9IE1hdGguZmxvb3IoYyAvIDYwKTtcbiAgICBjIC09IF8gKiA2MDtcbiAgICB2YXIgZyA9IGMgKiAxZTM7XG4gICAgcmV0dXJuIGMgPSBNYXRoLmZsb29yKGMpLCBnIC09IGMgKiAxZTMsIGcgPSBNYXRoLmZsb29yKGcpLCAoaSA/IFwiLVwiIDogXCJcIikgKyB1ICsgXCI6XCIgKyBzKF8sIDIpICsgXCI6XCIgKyBzKGMsIDIpICsgXCIuXCIgKyBzKGcsIDMpO1xuICB9LCByLnByaW50UmFuZ2VzID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5sZW5ndGg7XG4gICAgaWYgKGUgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gXCJcIiwgcyA9IDA7IHMgPCBlOyBzKyspXG4gICAgICAgIHMgPiAwICYmIChpICs9IFwiLFwiKSwgaSArPSBcIltcIiArIHIuZ2V0RHVyYXRpb25TdHJpbmcodC5zdGFydChzKSkgKyBcIixcIiArIHIuZ2V0RHVyYXRpb25TdHJpbmcodC5lbmQocykpICsgXCJdXCI7XG4gICAgICByZXR1cm4gaTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBcIihlbXB0eSlcIjtcbiAgfSwgbC5Mb2cgPSByO1xuICB2YXIgaCA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgdGhpcy5idWZmZXIgPSB0LCB0aGlzLmRhdGF2aWV3ID0gbmV3IERhdGFWaWV3KHQpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IFwiTmVlZHMgYW4gYXJyYXkgYnVmZmVyXCI7XG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gIH07XG4gIGgucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gIH0sIGgucHJvdG90eXBlLmdldEVuZFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH0sIGgucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICB9LCBoLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5idWZmZXIuYnl0ZUxlbmd0aCwgdCkpO1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID0gaXNOYU4oZSkgfHwgIWlzRmluaXRlKGUpID8gMCA6IGUsICEwO1xuICB9LCBoLnByb3RvdHlwZS5pc0VvcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvc2l0aW9uKCkgPj0gdGhpcy5nZXRFbmRQb3NpdGlvbigpO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkQW55SW50ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5wb3NpdGlvbiArIHQgPD0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBlID8gaSA9IHRoaXMuZGF0YXZpZXcuZ2V0SW50OCh0aGlzLnBvc2l0aW9uKSA6IGkgPSB0aGlzLmRhdGF2aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZSA/IGkgPSB0aGlzLmRhdGF2aWV3LmdldEludDE2KHRoaXMucG9zaXRpb24pIDogaSA9IHRoaXMuZGF0YXZpZXcuZ2V0VWludDE2KHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICB0aHJvdyBcIk5vIG1ldGhvZCBmb3IgcmVhZGluZyBzaWduZWQgMjQgYml0cyB2YWx1ZXNcIjtcbiAgICAgICAgICBpID0gdGhpcy5kYXRhdmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uKSA8PCAxNiwgaSB8PSB0aGlzLmRhdGF2aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24gKyAxKSA8PCA4LCBpIHw9IHRoaXMuZGF0YXZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiArIDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgZSA/IGkgPSB0aGlzLmRhdGF2aWV3LmdldEludDMyKHRoaXMucG9zaXRpb24pIDogaSA9IHRoaXMuZGF0YXZpZXcuZ2V0VWludDMyKHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICB0aHJvdyBcIk5vIG1ldGhvZCBmb3IgcmVhZGluZyBzaWduZWQgNjQgYml0cyB2YWx1ZXNcIjtcbiAgICAgICAgICBpID0gdGhpcy5kYXRhdmlldy5nZXRVaW50MzIodGhpcy5wb3NpdGlvbikgPDwgMzIsIGkgfD0gdGhpcy5kYXRhdmlldy5nZXRVaW50MzIodGhpcy5wb3NpdGlvbiArIDQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IFwicmVhZEludCBtZXRob2Qgbm90IGltcGxlbWVudGVkIGZvciBzaXplOiBcIiArIHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiArPSB0LCBpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgXCJOb3QgZW5vdWdoIGJ5dGVzIGluIGJ1ZmZlclwiO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkVWludDggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQW55SW50KDEsICExKTtcbiAgfSwgaC5wcm90b3R5cGUucmVhZFVpbnQxNiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoMiwgITEpO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkVWludDI0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEFueUludCgzLCAhMSk7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQW55SW50KDQsICExKTtcbiAgfSwgaC5wcm90b3R5cGUucmVhZFVpbnQ2NCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoOCwgITEpO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24odCkge1xuICAgIGlmICh0aGlzLnBvc2l0aW9uICsgdCA8PSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBlID0gXCJcIiwgaSA9IDA7IGkgPCB0OyBpKyspXG4gICAgICAgIGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRVaW50OCgpKTtcbiAgICAgIHJldHVybiBlO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgXCJOb3QgZW5vdWdoIGJ5dGVzIGluIGJ1ZmZlclwiO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkQ1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHQgPSBbXTsgOyApIHtcbiAgICAgIHZhciBlID0gdGhpcy5yZWFkVWludDgoKTtcbiAgICAgIGlmIChlICE9PSAwKVxuICAgICAgICB0LnB1c2goZSk7XG4gICAgICBlbHNlXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB0KTtcbiAgfSwgaC5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQW55SW50KDEsICEwKTtcbiAgfSwgaC5wcm90b3R5cGUucmVhZEludDE2ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEFueUludCgyLCAhMCk7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoNCwgITApO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkSW50NjQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQW55SW50KDgsICExKTtcbiAgfSwgaC5wcm90b3R5cGUucmVhZFVpbnQ4QXJyYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IG5ldyBVaW50OEFycmF5KHQpLCBpID0gMDsgaSA8IHQ7IGkrKylcbiAgICAgIGVbaV0gPSB0aGlzLnJlYWRVaW50OCgpO1xuICAgIHJldHVybiBlO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkSW50MTZBcnJheSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gbmV3IEludDE2QXJyYXkodCksIGkgPSAwOyBpIDwgdDsgaSsrKVxuICAgICAgZVtpXSA9IHRoaXMucmVhZEludDE2KCk7XG4gICAgcmV0dXJuIGU7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRVaW50MTZBcnJheSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gbmV3IEludDE2QXJyYXkodCksIGkgPSAwOyBpIDwgdDsgaSsrKVxuICAgICAgZVtpXSA9IHRoaXMucmVhZFVpbnQxNigpO1xuICAgIHJldHVybiBlO1xuICB9LCBoLnByb3RvdHlwZS5yZWFkVWludDMyQXJyYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IG5ldyBVaW50MzJBcnJheSh0KSwgaSA9IDA7IGkgPCB0OyBpKyspXG4gICAgICBlW2ldID0gdGhpcy5yZWFkVWludDMyKCk7XG4gICAgcmV0dXJuIGU7XG4gIH0sIGgucHJvdG90eXBlLnJlYWRJbnQzMkFycmF5ID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgPSBuZXcgSW50MzJBcnJheSh0KSwgaSA9IDA7IGkgPCB0OyBpKyspXG4gICAgICBlW2ldID0gdGhpcy5yZWFkSW50MzIoKTtcbiAgICByZXR1cm4gZTtcbiAgfSwgbC5NUDRCb3hTdHJlYW0gPSBoO1xuICB2YXIgYSA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9ieXRlT2Zmc2V0ID0gZSB8fCAwLCB0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyB0aGlzLmJ1ZmZlciA9IHQgOiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gKHRoaXMuZGF0YVZpZXcgPSB0LCBlICYmICh0aGlzLl9ieXRlT2Zmc2V0ICs9IGUpKSA6IHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHQgfHwgMCksIHRoaXMucG9zaXRpb24gPSAwLCB0aGlzLmVuZGlhbm5lc3MgPSBpID8/IGEuTElUVExFX0VORElBTjtcbiAgfTtcbiAgYS5wcm90b3R5cGUgPSB7fSwgYS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbiAgfSwgYS5wcm90b3R5cGUuX3JlYWxsb2MgPSBmdW5jdGlvbih0KSB7XG4gICAgaWYgKHRoaXMuX2R5bmFtaWNTaXplKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2J5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uICsgdCwgaSA9IHRoaXMuX2J1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgaWYgKGUgPD0gaSkge1xuICAgICAgICBlID4gdGhpcy5fYnl0ZUxlbmd0aCAmJiAodGhpcy5fYnl0ZUxlbmd0aCA9IGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGkgPCAxICYmIChpID0gMSk7IGUgPiBpOyApXG4gICAgICAgIGkgKj0gMjtcbiAgICAgIHZhciBzID0gbmV3IEFycmF5QnVmZmVyKGkpLCBvID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyKSwgYyA9IG5ldyBVaW50OEFycmF5KHMsIDAsIG8ubGVuZ3RoKTtcbiAgICAgIGMuc2V0KG8pLCB0aGlzLmJ1ZmZlciA9IHMsIHRoaXMuX2J5dGVMZW5ndGggPSBlO1xuICAgIH1cbiAgfSwgYS5wcm90b3R5cGUuX3RyaW1BbGxvYyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ieXRlTGVuZ3RoICE9IHRoaXMuX2J1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICB2YXIgdCA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLl9ieXRlTGVuZ3RoKSwgZSA9IG5ldyBVaW50OEFycmF5KHQpLCBpID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyLCAwLCBlLmxlbmd0aCk7XG4gICAgICBlLnNldChpKSwgdGhpcy5idWZmZXIgPSB0O1xuICAgIH1cbiAgfSwgYS5CSUdfRU5ESUFOID0gITEsIGEuTElUVExFX0VORElBTiA9ICEwLCBhLnByb3RvdHlwZS5fYnl0ZUxlbmd0aCA9IDAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICBhLnByb3RvdHlwZSxcbiAgICBcImJ5dGVMZW5ndGhcIixcbiAgICB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYnl0ZUxlbmd0aCAtIHRoaXMuX2J5dGVPZmZzZXQ7XG4gICAgfSB9XG4gICksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICBhLnByb3RvdHlwZSxcbiAgICBcImJ1ZmZlclwiLFxuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmltQWxsb2MoKSwgdGhpcy5fYnVmZmVyO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSB0LCB0aGlzLl9kYXRhVmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLl9idWZmZXIsIHRoaXMuX2J5dGVPZmZzZXQpLCB0aGlzLl9ieXRlTGVuZ3RoID0gdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgYS5wcm90b3R5cGUsXG4gICAgXCJieXRlT2Zmc2V0XCIsXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVPZmZzZXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuX2J5dGVPZmZzZXQgPSB0LCB0aGlzLl9kYXRhVmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLl9idWZmZXIsIHRoaXMuX2J5dGVPZmZzZXQpLCB0aGlzLl9ieXRlTGVuZ3RoID0gdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgYS5wcm90b3R5cGUsXG4gICAgXCJkYXRhVmlld1wiLFxuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhVmlldztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy5fYnl0ZU9mZnNldCA9IHQuYnl0ZU9mZnNldCwgdGhpcy5fYnVmZmVyID0gdC5idWZmZXIsIHRoaXMuX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuX2J1ZmZlciwgdGhpcy5fYnl0ZU9mZnNldCksIHRoaXMuX2J5dGVMZW5ndGggPSB0aGlzLl9ieXRlT2Zmc2V0ICsgdC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgKSwgYS5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuYnl0ZUxlbmd0aCwgdCkpO1xuICAgIHRoaXMucG9zaXRpb24gPSBpc05hTihlKSB8fCAhaXNGaW5pdGUoZSkgPyAwIDogZTtcbiAgfSwgYS5wcm90b3R5cGUuaXNFb2YgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA+PSB0aGlzLl9ieXRlTGVuZ3RoO1xuICB9LCBhLnByb3RvdHlwZS5tYXBVaW50OEFycmF5ID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuX3JlYWxsb2ModCAqIDEpO1xuICAgIHZhciBlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLCB0KTtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiArPSB0ICogMSwgZTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZEludDMyQXJyYXkgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdCA9IHQgPz8gdGhpcy5ieXRlTGVuZ3RoIC0gdGhpcy5wb3NpdGlvbiAvIDQ7XG4gICAgdmFyIGkgPSBuZXcgSW50MzJBcnJheSh0KTtcbiAgICByZXR1cm4gYS5tZW1jcHkoXG4gICAgICBpLmJ1ZmZlcixcbiAgICAgIDAsXG4gICAgICB0aGlzLmJ1ZmZlcixcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICB0ICogaS5CWVRFU19QRVJfRUxFTUVOVFxuICAgICksIGEuYXJyYXlUb05hdGl2ZShpLCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gaS5ieXRlTGVuZ3RoLCBpO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkSW50MTZBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0ID0gdCA/PyB0aGlzLmJ5dGVMZW5ndGggLSB0aGlzLnBvc2l0aW9uIC8gMjtcbiAgICB2YXIgaSA9IG5ldyBJbnQxNkFycmF5KHQpO1xuICAgIHJldHVybiBhLm1lbWNweShcbiAgICAgIGkuYnVmZmVyLFxuICAgICAgMCxcbiAgICAgIHRoaXMuYnVmZmVyLFxuICAgICAgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbixcbiAgICAgIHQgKiBpLkJZVEVTX1BFUl9FTEVNRU5UXG4gICAgKSwgYS5hcnJheVRvTmF0aXZlKGksIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSBpLmJ5dGVMZW5ndGgsIGk7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRJbnQ4QXJyYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgdCA9IHQgPz8gdGhpcy5ieXRlTGVuZ3RoIC0gdGhpcy5wb3NpdGlvbjtcbiAgICB2YXIgZSA9IG5ldyBJbnQ4QXJyYXkodCk7XG4gICAgcmV0dXJuIGEubWVtY3B5KFxuICAgICAgZS5idWZmZXIsXG4gICAgICAwLFxuICAgICAgdGhpcy5idWZmZXIsXG4gICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgdCAqIGUuQllURVNfUEVSX0VMRU1FTlRcbiAgICApLCB0aGlzLnBvc2l0aW9uICs9IGUuYnl0ZUxlbmd0aCwgZTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZFVpbnQzMkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHQgPSB0ID8/IHRoaXMuYnl0ZUxlbmd0aCAtIHRoaXMucG9zaXRpb24gLyA0O1xuICAgIHZhciBpID0gbmV3IFVpbnQzMkFycmF5KHQpO1xuICAgIHJldHVybiBhLm1lbWNweShcbiAgICAgIGkuYnVmZmVyLFxuICAgICAgMCxcbiAgICAgIHRoaXMuYnVmZmVyLFxuICAgICAgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbixcbiAgICAgIHQgKiBpLkJZVEVTX1BFUl9FTEVNRU5UXG4gICAgKSwgYS5hcnJheVRvTmF0aXZlKGksIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSBpLmJ5dGVMZW5ndGgsIGk7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRVaW50MTZBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0ID0gdCA/PyB0aGlzLmJ5dGVMZW5ndGggLSB0aGlzLnBvc2l0aW9uIC8gMjtcbiAgICB2YXIgaSA9IG5ldyBVaW50MTZBcnJheSh0KTtcbiAgICByZXR1cm4gYS5tZW1jcHkoXG4gICAgICBpLmJ1ZmZlcixcbiAgICAgIDAsXG4gICAgICB0aGlzLmJ1ZmZlcixcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICB0ICogaS5CWVRFU19QRVJfRUxFTUVOVFxuICAgICksIGEuYXJyYXlUb05hdGl2ZShpLCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gaS5ieXRlTGVuZ3RoLCBpO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkVWludDhBcnJheSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0ID0gdCA/PyB0aGlzLmJ5dGVMZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xuICAgIHZhciBlID0gbmV3IFVpbnQ4QXJyYXkodCk7XG4gICAgcmV0dXJuIGEubWVtY3B5KFxuICAgICAgZS5idWZmZXIsXG4gICAgICAwLFxuICAgICAgdGhpcy5idWZmZXIsXG4gICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgdCAqIGUuQllURVNfUEVSX0VMRU1FTlRcbiAgICApLCB0aGlzLnBvc2l0aW9uICs9IGUuYnl0ZUxlbmd0aCwgZTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZEZsb2F0NjRBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0ID0gdCA/PyB0aGlzLmJ5dGVMZW5ndGggLSB0aGlzLnBvc2l0aW9uIC8gODtcbiAgICB2YXIgaSA9IG5ldyBGbG9hdDY0QXJyYXkodCk7XG4gICAgcmV0dXJuIGEubWVtY3B5KFxuICAgICAgaS5idWZmZXIsXG4gICAgICAwLFxuICAgICAgdGhpcy5idWZmZXIsXG4gICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgdCAqIGkuQllURVNfUEVSX0VMRU1FTlRcbiAgICApLCBhLmFycmF5VG9OYXRpdmUoaSwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IGkuYnl0ZUxlbmd0aCwgaTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZEZsb2F0MzJBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0ID0gdCA/PyB0aGlzLmJ5dGVMZW5ndGggLSB0aGlzLnBvc2l0aW9uIC8gNDtcbiAgICB2YXIgaSA9IG5ldyBGbG9hdDMyQXJyYXkodCk7XG4gICAgcmV0dXJuIGEubWVtY3B5KFxuICAgICAgaS5idWZmZXIsXG4gICAgICAwLFxuICAgICAgdGhpcy5idWZmZXIsXG4gICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgdCAqIGkuQllURVNfUEVSX0VMRU1FTlRcbiAgICApLCBhLmFycmF5VG9OYXRpdmUoaSwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IGkuYnl0ZUxlbmd0aCwgaTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MzIodGhpcy5wb3NpdGlvbiwgdCA/PyB0aGlzLmVuZGlhbm5lc3MpO1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICs9IDQsIGU7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRJbnQxNiA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHRoaXMuX2RhdGFWaWV3LmdldEludDE2KHRoaXMucG9zaXRpb24sIHQgPz8gdGhpcy5lbmRpYW5uZXNzKTtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiArPSAyLCBlO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gdGhpcy5fZGF0YVZpZXcuZ2V0SW50OCh0aGlzLnBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiArPSAxLCB0O1xuICB9LCBhLnByb3RvdHlwZS5yZWFkVWludDMyID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDMyKHRoaXMucG9zaXRpb24sIHQgPz8gdGhpcy5lbmRpYW5uZXNzKTtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiArPSA0LCBlO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDE2KHRoaXMucG9zaXRpb24sIHQgPz8gdGhpcy5lbmRpYW5uZXNzKTtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiArPSAyLCBlO1xuICB9LCBhLnByb3RvdHlwZS5yZWFkVWludDggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICs9IDEsIHQ7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRGbG9hdDMyID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLnBvc2l0aW9uLCB0ID8/IHRoaXMuZW5kaWFubmVzcyk7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb24gKz0gNCwgZTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZEZsb2F0NjQgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0aGlzLl9kYXRhVmlldy5nZXRGbG9hdDY0KHRoaXMucG9zaXRpb24sIHQgPz8gdGhpcy5lbmRpYW5uZXNzKTtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiArPSA4LCBlO1xuICB9LCBhLmVuZGlhbm5lc3MgPSBuZXcgSW50OEFycmF5KG5ldyBJbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA+IDAsIGEubWVtY3B5ID0gZnVuY3Rpb24odCwgZSwgaSwgcywgbykge1xuICAgIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkodCwgZSwgbyksIHUgPSBuZXcgVWludDhBcnJheShpLCBzLCBvKTtcbiAgICBjLnNldCh1KTtcbiAgfSwgYS5hcnJheVRvTmF0aXZlID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHJldHVybiBlID09IHRoaXMuZW5kaWFubmVzcyA/IHQgOiB0aGlzLmZsaXBBcnJheUVuZGlhbm5lc3ModCk7XG4gIH0sIGEubmF0aXZlVG9FbmRpYW4gPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kaWFubmVzcyA9PSBlID8gdCA6IHRoaXMuZmxpcEFycmF5RW5kaWFubmVzcyh0KTtcbiAgfSwgYS5mbGlwQXJyYXlFbmRpYW5uZXNzID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgPSBuZXcgVWludDhBcnJheSh0LmJ1ZmZlciwgdC5ieXRlT2Zmc2V0LCB0LmJ5dGVMZW5ndGgpLCBpID0gMDsgaSA8IHQuYnl0ZUxlbmd0aDsgaSArPSB0LkJZVEVTX1BFUl9FTEVNRU5UKVxuICAgICAgZm9yICh2YXIgcyA9IGkgKyB0LkJZVEVTX1BFUl9FTEVNRU5UIC0gMSwgbyA9IGk7IHMgPiBvOyBzLS0sIG8rKykge1xuICAgICAgICB2YXIgYyA9IGVbb107XG4gICAgICAgIGVbb10gPSBlW3NdLCBlW3NdID0gYztcbiAgICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSwgYS5wcm90b3R5cGUuZmFpbHVyZVBvc2l0aW9uID0gMCwgU3RyaW5nLmZyb21DaGFyQ29kZVVpbnQ4ID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgPSBbXSwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKVxuICAgICAgZVtpXSA9IHRbaV07XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZSk7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRTdHJpbmcgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgcmV0dXJuIGUgPT0gbnVsbCB8fCBlID09IFwiQVNDSUlcIiA/IFN0cmluZy5mcm9tQ2hhckNvZGVVaW50OC5hcHBseShudWxsLCBbdGhpcy5tYXBVaW50OEFycmF5KHQgPz8gdGhpcy5ieXRlTGVuZ3RoIC0gdGhpcy5wb3NpdGlvbildKSA6IG5ldyBUZXh0RGVjb2RlcihlKS5kZWNvZGUodGhpcy5tYXBVaW50OEFycmF5KHQpKTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZENTdHJpbmcgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0aGlzLmJ5dGVMZW5ndGggLSB0aGlzLnBvc2l0aW9uLCBpID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiksIHMgPSBlO1xuICAgIHQgIT0gbnVsbCAmJiAocyA9IE1hdGgubWluKHQsIGUpKTtcbiAgICBmb3IgKHZhciBvID0gMDsgbyA8IHMgJiYgaVtvXSAhPT0gMDsgbysrKSA7XG4gICAgdmFyIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlVWludDguYXBwbHkobnVsbCwgW3RoaXMubWFwVWludDhBcnJheShvKV0pO1xuICAgIHJldHVybiB0ICE9IG51bGwgPyB0aGlzLnBvc2l0aW9uICs9IHMgLSBvIDogbyAhPSBlICYmICh0aGlzLnBvc2l0aW9uICs9IDEpLCBjO1xuICB9O1xuICB2YXIgZiA9IE1hdGgucG93KDIsIDMyKTtcbiAgYS5wcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEludDMyKCkgKiBmICsgdGhpcy5yZWFkVWludDMyKCk7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRVaW50NjQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkVWludDMyKCkgKiBmICsgdGhpcy5yZWFkVWludDMyKCk7XG4gIH0sIGEucHJvdG90eXBlLnJlYWRJbnQ2NCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRVaW50MzIoKSAqIGYgKyB0aGlzLnJlYWRVaW50MzIoKTtcbiAgfSwgYS5wcm90b3R5cGUucmVhZFVpbnQyNCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5yZWFkVWludDgoKSA8PCAxNikgKyAodGhpcy5yZWFkVWludDgoKSA8PCA4KSArIHRoaXMucmVhZFVpbnQ4KCk7XG4gIH0sIGwuRGF0YVN0cmVhbSA9IGEsIGEucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBuZXcgQmxvYihbdGhpcy5idWZmZXJdKTtcbiAgICBpZiAod2luZG93LlVSTCAmJiBVUkwuY3JlYXRlT2JqZWN0VVJMKSB7XG4gICAgICB2YXIgaSA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGUpLCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHMpLCBzLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgaSksIHMuc2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIiwgdCksIHMuc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsIFwiX3NlbGZcIiksIHMuY2xpY2soKSwgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwoaSk7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBcIkRhdGFTdHJlYW0uc2F2ZTogQ2FuJ3QgY3JlYXRlIG9iamVjdCBVUkwuXCI7XG4gIH0sIGEucHJvdG90eXBlLl9keW5hbWljU2l6ZSA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgYS5wcm90b3R5cGUsXG4gICAgXCJkeW5hbWljU2l6ZVwiLFxuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9keW5hbWljU2l6ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdCB8fCB0aGlzLl90cmltQWxsb2MoKSwgdGhpcy5fZHluYW1pY1NpemUgPSB0O1xuICAgICAgfVxuICAgIH1cbiAgKSwgYS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5fYnl0ZUxlbmd0aCAtIHQpLCBpID0gbmV3IFVpbnQ4QXJyYXkoZSksIHMgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIsIHQsIGkubGVuZ3RoKTtcbiAgICBpLnNldChzKSwgdGhpcy5idWZmZXIgPSBlLCB0aGlzLnBvc2l0aW9uIC09IHQ7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlSW50MzJBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICBpZiAodGhpcy5fcmVhbGxvYyh0Lmxlbmd0aCAqIDQpLCB0IGluc3RhbmNlb2YgSW50MzJBcnJheSAmJiB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uICUgdC5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMClcbiAgICAgIGEubWVtY3B5KFxuICAgICAgICB0aGlzLl9idWZmZXIsXG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICAgIHQuYnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICB0LmJ5dGVMZW5ndGhcbiAgICAgICksIHRoaXMubWFwSW50MzJBcnJheSh0Lmxlbmd0aCwgZSk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLndyaXRlSW50MzIodFtpXSwgZSk7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlSW50MTZBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICBpZiAodGhpcy5fcmVhbGxvYyh0Lmxlbmd0aCAqIDIpLCB0IGluc3RhbmNlb2YgSW50MTZBcnJheSAmJiB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uICUgdC5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMClcbiAgICAgIGEubWVtY3B5KFxuICAgICAgICB0aGlzLl9idWZmZXIsXG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sXG4gICAgICAgIHQuYnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICB0LmJ5dGVMZW5ndGhcbiAgICAgICksIHRoaXMubWFwSW50MTZBcnJheSh0Lmxlbmd0aCwgZSk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLndyaXRlSW50MTYodFtpXSwgZSk7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlSW50OEFycmF5ID0gZnVuY3Rpb24odCkge1xuICAgIGlmICh0aGlzLl9yZWFsbG9jKHQubGVuZ3RoICogMSksIHQgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgJiYgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiAlIHQuQllURVNfUEVSX0VMRU1FTlQgPT09IDApXG4gICAgICBhLm1lbWNweShcbiAgICAgICAgdGhpcy5fYnVmZmVyLFxuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgICB0LmJ1ZmZlcixcbiAgICAgICAgMCxcbiAgICAgICAgdC5ieXRlTGVuZ3RoXG4gICAgICApLCB0aGlzLm1hcEludDhBcnJheSh0Lmxlbmd0aCk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSsrKVxuICAgICAgICB0aGlzLndyaXRlSW50OCh0W2VdKTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVVaW50MzJBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICBpZiAodGhpcy5fcmVhbGxvYyh0Lmxlbmd0aCAqIDQpLCB0IGluc3RhbmNlb2YgVWludDMyQXJyYXkgJiYgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiAlIHQuQllURVNfUEVSX0VMRU1FTlQgPT09IDApXG4gICAgICBhLm1lbWNweShcbiAgICAgICAgdGhpcy5fYnVmZmVyLFxuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgICB0LmJ1ZmZlcixcbiAgICAgICAgMCxcbiAgICAgICAgdC5ieXRlTGVuZ3RoXG4gICAgICApLCB0aGlzLm1hcFVpbnQzMkFycmF5KHQubGVuZ3RoLCBlKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMud3JpdGVVaW50MzIodFtpXSwgZSk7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlVWludDE2QXJyYXkgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWxsb2ModC5sZW5ndGggKiAyKSwgdCBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ICYmIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24gJSB0LkJZVEVTX1BFUl9FTEVNRU5UID09PSAwKVxuICAgICAgYS5tZW1jcHkoXG4gICAgICAgIHRoaXMuX2J1ZmZlcixcbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbixcbiAgICAgICAgdC5idWZmZXIsXG4gICAgICAgIDAsXG4gICAgICAgIHQuYnl0ZUxlbmd0aFxuICAgICAgKSwgdGhpcy5tYXBVaW50MTZBcnJheSh0Lmxlbmd0aCwgZSk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLndyaXRlVWludDE2KHRbaV0sIGUpO1xuICB9LCBhLnByb3RvdHlwZS53cml0ZVVpbnQ4QXJyYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgaWYgKHRoaXMuX3JlYWxsb2ModC5sZW5ndGggKiAxKSwgdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiAlIHQuQllURVNfUEVSX0VMRU1FTlQgPT09IDApXG4gICAgICBhLm1lbWNweShcbiAgICAgICAgdGhpcy5fYnVmZmVyLFxuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgICB0LmJ1ZmZlcixcbiAgICAgICAgMCxcbiAgICAgICAgdC5ieXRlTGVuZ3RoXG4gICAgICApLCB0aGlzLm1hcFVpbnQ4QXJyYXkodC5sZW5ndGgpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdC5sZW5ndGg7IGUrKylcbiAgICAgICAgdGhpcy53cml0ZVVpbnQ4KHRbZV0pO1xuICB9LCBhLnByb3RvdHlwZS53cml0ZUZsb2F0NjRBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICBpZiAodGhpcy5fcmVhbGxvYyh0Lmxlbmd0aCAqIDgpLCB0IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5ICYmIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24gJSB0LkJZVEVTX1BFUl9FTEVNRU5UID09PSAwKVxuICAgICAgYS5tZW1jcHkoXG4gICAgICAgIHRoaXMuX2J1ZmZlcixcbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbixcbiAgICAgICAgdC5idWZmZXIsXG4gICAgICAgIDAsXG4gICAgICAgIHQuYnl0ZUxlbmd0aFxuICAgICAgKSwgdGhpcy5tYXBGbG9hdDY0QXJyYXkodC5sZW5ndGgsIGUpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy53cml0ZUZsb2F0NjQodFtpXSwgZSk7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlRmxvYXQzMkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIGlmICh0aGlzLl9yZWFsbG9jKHQubGVuZ3RoICogNCksIHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgJiYgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiAlIHQuQllURVNfUEVSX0VMRU1FTlQgPT09IDApXG4gICAgICBhLm1lbWNweShcbiAgICAgICAgdGhpcy5fYnVmZmVyLFxuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLFxuICAgICAgICB0LmJ1ZmZlcixcbiAgICAgICAgMCxcbiAgICAgICAgdC5ieXRlTGVuZ3RoXG4gICAgICApLCB0aGlzLm1hcEZsb2F0MzJBcnJheSh0Lmxlbmd0aCwgZSk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLndyaXRlRmxvYXQzMih0W2ldLCBlKTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVJbnQzMiA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl9yZWFsbG9jKDQpLCB0aGlzLl9kYXRhVmlldy5zZXRJbnQzMih0aGlzLnBvc2l0aW9uLCB0LCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVJbnQxNiA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl9yZWFsbG9jKDIpLCB0aGlzLl9kYXRhVmlldy5zZXRJbnQxNih0aGlzLnBvc2l0aW9uLCB0LCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuX3JlYWxsb2MoMSksIHRoaXMuX2RhdGFWaWV3LnNldEludDgodGhpcy5wb3NpdGlvbiwgdCksIHRoaXMucG9zaXRpb24gKz0gMTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVVaW50MzIgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdGhpcy5fcmVhbGxvYyg0KSwgdGhpcy5fZGF0YVZpZXcuc2V0VWludDMyKHRoaXMucG9zaXRpb24sIHQsIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSA0O1xuICB9LCBhLnByb3RvdHlwZS53cml0ZVVpbnQxNiA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl9yZWFsbG9jKDIpLCB0aGlzLl9kYXRhVmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdCwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IDI7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlVWludDggPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5fcmVhbGxvYygxKSwgdGhpcy5fZGF0YVZpZXcuc2V0VWludDgodGhpcy5wb3NpdGlvbiwgdCksIHRoaXMucG9zaXRpb24gKz0gMTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHRoaXMuX3JlYWxsb2MoNCksIHRoaXMuX2RhdGFWaWV3LnNldEZsb2F0MzIodGhpcy5wb3NpdGlvbiwgdCwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IDQ7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlRmxvYXQ2NCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl9yZWFsbG9jKDgpLCB0aGlzLl9kYXRhVmlldy5zZXRGbG9hdDY0KHRoaXMucG9zaXRpb24sIHQsIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSA4O1xuICB9LCBhLnByb3RvdHlwZS53cml0ZVVDUzJTdHJpbmcgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgaSA9PSBudWxsICYmIChpID0gdC5sZW5ndGgpO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdC5sZW5ndGggJiYgcyA8IGk7IHMrKylcbiAgICAgIHRoaXMud3JpdGVVaW50MTYodC5jaGFyQ29kZUF0KHMpLCBlKTtcbiAgICBmb3IgKDsgcyA8IGk7IHMrKylcbiAgICAgIHRoaXMud3JpdGVVaW50MTYoMCk7XG4gIH0sIGEucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICAgIHZhciBzID0gMDtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPT0gXCJBU0NJSVwiKVxuICAgICAgaWYgKGkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbyA9IE1hdGgubWluKHQubGVuZ3RoLCBpKTtcbiAgICAgICAgZm9yIChzID0gMDsgcyA8IG87IHMrKylcbiAgICAgICAgICB0aGlzLndyaXRlVWludDgodC5jaGFyQ29kZUF0KHMpKTtcbiAgICAgICAgZm9yICg7IHMgPCBpOyBzKyspXG4gICAgICAgICAgdGhpcy53cml0ZVVpbnQ4KDApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGZvciAocyA9IDA7IHMgPCB0Lmxlbmd0aDsgcysrKVxuICAgICAgICAgIHRoaXMud3JpdGVVaW50OCh0LmNoYXJDb2RlQXQocykpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMud3JpdGVVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcihlKS5lbmNvZGUodC5zdWJzdHJpbmcoMCwgaSkpKTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVDU3RyaW5nID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAoZSAhPSBudWxsKSB7XG4gICAgICB2YXIgcyA9IE1hdGgubWluKHQubGVuZ3RoLCBlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspXG4gICAgICAgIHRoaXMud3JpdGVVaW50OCh0LmNoYXJDb2RlQXQoaSkpO1xuICAgICAgZm9yICg7IGkgPCBlOyBpKyspXG4gICAgICAgIHRoaXMud3JpdGVVaW50OCgwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMud3JpdGVVaW50OCh0LmNoYXJDb2RlQXQoaSkpO1xuICAgICAgdGhpcy53cml0ZVVpbnQ4KDApO1xuICAgIH1cbiAgfSwgYS5wcm90b3R5cGUud3JpdGVTdHJ1Y3QgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgcyA9IHRbaSArIDFdO1xuICAgICAgdGhpcy53cml0ZVR5cGUocywgZVt0W2ldXSwgZSk7XG4gICAgfVxuICB9LCBhLnByb3RvdHlwZS53cml0ZVR5cGUgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgdmFyIHM7XG4gICAgaWYgKHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiB0KHRoaXMsIGUpO1xuICAgIGlmICh0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmICEodCBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgIHJldHVybiB0LnNldCh0aGlzLCBlLCBpKTtcbiAgICB2YXIgbyA9IG51bGwsIGMgPSBcIkFTQ0lJXCIsIHUgPSB0aGlzLnBvc2l0aW9uO1xuICAgIHN3aXRjaCAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAvOi8udGVzdCh0KSAmJiAocyA9IHQuc3BsaXQoXCI6XCIpLCB0ID0gc1swXSwgbyA9IHBhcnNlSW50KHNbMV0pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAvLC8udGVzdCh0KSAmJiAocyA9IHQuc3BsaXQoXCIsXCIpLCB0ID0gc1swXSwgYyA9IHBhcnNlSW50KHNbMV0pKSwgdCkge1xuICAgICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIHRoaXMud3JpdGVVaW50OChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW50OFwiOlxuICAgICAgICB0aGlzLndyaXRlSW50OChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIHRoaXMud3JpdGVVaW50MTYoZSwgdGhpcy5lbmRpYW5uZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgICAgdGhpcy53cml0ZUludDE2KGUsIHRoaXMuZW5kaWFubmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICB0aGlzLndyaXRlVWludDMyKGUsIHRoaXMuZW5kaWFubmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihlLCB0aGlzLmVuZGlhbm5lc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdDMyKGUsIHRoaXMuZW5kaWFubmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZsb2F0NjRcIjpcbiAgICAgICAgdGhpcy53cml0ZUZsb2F0NjQoZSwgdGhpcy5lbmRpYW5uZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidWludDE2YmVcIjpcbiAgICAgICAgdGhpcy53cml0ZVVpbnQxNihlLCBhLkJJR19FTkRJQU4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbnQxNmJlXCI6XG4gICAgICAgIHRoaXMud3JpdGVJbnQxNihlLCBhLkJJR19FTkRJQU4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ1aW50MzJiZVwiOlxuICAgICAgICB0aGlzLndyaXRlVWludDMyKGUsIGEuQklHX0VORElBTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludDMyYmVcIjpcbiAgICAgICAgdGhpcy53cml0ZUludDMyKGUsIGEuQklHX0VORElBTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZsb2F0MzJiZVwiOlxuICAgICAgICB0aGlzLndyaXRlRmxvYXQzMihlLCBhLkJJR19FTkRJQU4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmbG9hdDY0YmVcIjpcbiAgICAgICAgdGhpcy53cml0ZUZsb2F0NjQoZSwgYS5CSUdfRU5ESUFOKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidWludDE2bGVcIjpcbiAgICAgICAgdGhpcy53cml0ZVVpbnQxNihlLCBhLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbnQxNmxlXCI6XG4gICAgICAgIHRoaXMud3JpdGVJbnQxNihlLCBhLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ1aW50MzJsZVwiOlxuICAgICAgICB0aGlzLndyaXRlVWludDMyKGUsIGEuTElUVExFX0VORElBTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludDMybGVcIjpcbiAgICAgICAgdGhpcy53cml0ZUludDMyKGUsIGEuTElUVExFX0VORElBTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZsb2F0MzJsZVwiOlxuICAgICAgICB0aGlzLndyaXRlRmxvYXQzMihlLCBhLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmbG9hdDY0bGVcIjpcbiAgICAgICAgdGhpcy53cml0ZUZsb2F0NjQoZSwgYS5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY3N0cmluZ1wiOlxuICAgICAgICB0aGlzLndyaXRlQ1N0cmluZyhlLCBvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHRoaXMud3JpdGVTdHJpbmcoZSwgYywgbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInUxNnN0cmluZ1wiOlxuICAgICAgICB0aGlzLndyaXRlVUNTMlN0cmluZyhlLCB0aGlzLmVuZGlhbm5lc3MsIG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ1MTZzdHJpbmdsZVwiOlxuICAgICAgICB0aGlzLndyaXRlVUNTMlN0cmluZyhlLCBhLkxJVFRMRV9FTkRJQU4sIG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ1MTZzdHJpbmdiZVwiOlxuICAgICAgICB0aGlzLndyaXRlVUNTMlN0cmluZyhlLCBhLkJJR19FTkRJQU4sIG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0Lmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgZm9yICh2YXIgXyA9IHRbMV0sIGcgPSAwOyBnIDwgZS5sZW5ndGg7IGcrKylcbiAgICAgICAgICAgIHRoaXMud3JpdGVUeXBlKF8sIGVbZ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud3JpdGVTdHJ1Y3QodCwgZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbyAhPSBudWxsICYmICh0aGlzLnBvc2l0aW9uID0gdSwgdGhpcy5fcmVhbGxvYyhvKSwgdGhpcy5wb3NpdGlvbiA9IHUgKyBvKTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVVaW50NjQgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBNYXRoLmZsb29yKHQgLyBmKTtcbiAgICB0aGlzLndyaXRlVWludDMyKGUpLCB0aGlzLndyaXRlVWludDMyKHQgJiA0Mjk0OTY3Mjk1KTtcbiAgfSwgYS5wcm90b3R5cGUud3JpdGVVaW50MjQgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy53cml0ZVVpbnQ4KCh0ICYgMTY3MTE2ODApID4+IDE2KSwgdGhpcy53cml0ZVVpbnQ4KCh0ICYgNjUyODApID4+IDgpLCB0aGlzLndyaXRlVWludDgodCAmIDI1NSk7XG4gIH0sIGEucHJvdG90eXBlLmFkanVzdFVpbnQzMiA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB2YXIgaSA9IHRoaXMucG9zaXRpb247XG4gICAgdGhpcy5zZWVrKHQpLCB0aGlzLndyaXRlVWludDMyKGUpLCB0aGlzLnNlZWsoaSk7XG4gIH0sIGEucHJvdG90eXBlLm1hcEludDMyQXJyYXkgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdGhpcy5fcmVhbGxvYyh0ICogNCk7XG4gICAgdmFyIGkgPSBuZXcgSW50MzJBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sIHQpO1xuICAgIHJldHVybiBhLmFycmF5VG9OYXRpdmUoaSwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IHQgKiA0LCBpO1xuICB9LCBhLnByb3RvdHlwZS5tYXBJbnQxNkFycmF5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHRoaXMuX3JlYWxsb2ModCAqIDIpO1xuICAgIHZhciBpID0gbmV3IEludDE2QXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLCB0KTtcbiAgICByZXR1cm4gYS5hcnJheVRvTmF0aXZlKGksIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSB0ICogMiwgaTtcbiAgfSwgYS5wcm90b3R5cGUubWFwSW50OEFycmF5ID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuX3JlYWxsb2ModCAqIDEpO1xuICAgIHZhciBlID0gbmV3IEludDhBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sIHQpO1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICs9IHQgKiAxLCBlO1xuICB9LCBhLnByb3RvdHlwZS5tYXBVaW50MzJBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl9yZWFsbG9jKHQgKiA0KTtcbiAgICB2YXIgaSA9IG5ldyBVaW50MzJBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sIHQpO1xuICAgIHJldHVybiBhLmFycmF5VG9OYXRpdmUoaSwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IHQgKiA0LCBpO1xuICB9LCBhLnByb3RvdHlwZS5tYXBVaW50MTZBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl9yZWFsbG9jKHQgKiAyKTtcbiAgICB2YXIgaSA9IG5ldyBVaW50MTZBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24sIHQpO1xuICAgIHJldHVybiBhLmFycmF5VG9OYXRpdmUoaSwgZSA/PyB0aGlzLmVuZGlhbm5lc3MpLCB0aGlzLnBvc2l0aW9uICs9IHQgKiAyLCBpO1xuICB9LCBhLnByb3RvdHlwZS5tYXBGbG9hdDY0QXJyYXkgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdGhpcy5fcmVhbGxvYyh0ICogOCk7XG4gICAgdmFyIGkgPSBuZXcgRmxvYXQ2NEFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbiwgdCk7XG4gICAgcmV0dXJuIGEuYXJyYXlUb05hdGl2ZShpLCBlID8/IHRoaXMuZW5kaWFubmVzcyksIHRoaXMucG9zaXRpb24gKz0gdCAqIDgsIGk7XG4gIH0sIGEucHJvdG90eXBlLm1hcEZsb2F0MzJBcnJheSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl9yZWFsbG9jKHQgKiA0KTtcbiAgICB2YXIgaSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uLCB0KTtcbiAgICByZXR1cm4gYS5hcnJheVRvTmF0aXZlKGksIGUgPz8gdGhpcy5lbmRpYW5uZXNzKSwgdGhpcy5wb3NpdGlvbiArPSB0ICogNCwgaTtcbiAgfTtcbiAgdmFyIGQgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5idWZmZXJzID0gW10sIHRoaXMuYnVmZmVySW5kZXggPSAtMSwgdCAmJiAodGhpcy5pbnNlcnRCdWZmZXIodCksIHRoaXMuYnVmZmVySW5kZXggPSAwKTtcbiAgfTtcbiAgZC5wcm90b3R5cGUgPSBuZXcgYShuZXcgQXJyYXlCdWZmZXIoKSwgMCwgYS5CSUdfRU5ESUFOKSwgZC5wcm90b3R5cGUuaW5pdGlhbGl6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdDtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJJbmRleCA+IC0xID8gITAgOiB0aGlzLmJ1ZmZlcnMubGVuZ3RoID4gMCA/ICh0ID0gdGhpcy5idWZmZXJzWzBdLCB0LmZpbGVTdGFydCA9PT0gMCA/ICh0aGlzLmJ1ZmZlciA9IHQsIHRoaXMuYnVmZmVySW5kZXggPSAwLCByLmRlYnVnKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJTdHJlYW0gcmVhZHkgZm9yIHBhcnNpbmdcIiksICEwKSA6IChyLndhcm4oXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIlRoZSBmaXJzdCBidWZmZXIgc2hvdWxkIGhhdmUgYSBmaWxlU3RhcnQgb2YgMFwiKSwgdGhpcy5sb2dCdWZmZXJMZXZlbCgpLCAhMSkpIDogKHIud2FybihcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiTm8gYnVmZmVyIHRvIHN0YXJ0IHBhcnNpbmcgZnJvbVwiKSwgdGhpcy5sb2dCdWZmZXJMZXZlbCgpLCAhMSk7XG4gIH0sIEFycmF5QnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICByLmRlYnVnKFwiQXJyYXlCdWZmZXJcIiwgXCJUcnlpbmcgdG8gY3JlYXRlIGEgbmV3IGJ1ZmZlciBvZiBzaXplOiBcIiArICh0LmJ5dGVMZW5ndGggKyBlLmJ5dGVMZW5ndGgpKTtcbiAgICB2YXIgaSA9IG5ldyBVaW50OEFycmF5KHQuYnl0ZUxlbmd0aCArIGUuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIGkuc2V0KG5ldyBVaW50OEFycmF5KHQpLCAwKSwgaS5zZXQobmV3IFVpbnQ4QXJyYXkoZSksIHQuYnl0ZUxlbmd0aCksIGkuYnVmZmVyO1xuICB9LCBkLnByb3RvdHlwZS5yZWR1Y2VCdWZmZXIgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgdmFyIHM7XG4gICAgcmV0dXJuIHMgPSBuZXcgVWludDhBcnJheShpKSwgcy5zZXQobmV3IFVpbnQ4QXJyYXkodCwgZSwgaSkpLCBzLmJ1ZmZlci5maWxlU3RhcnQgPSB0LmZpbGVTdGFydCArIGUsIHMuYnVmZmVyLnVzZWRCeXRlcyA9IDAsIHMuYnVmZmVyO1xuICB9LCBkLnByb3RvdHlwZS5pbnNlcnRCdWZmZXIgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9ICEwLCBpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHMgPSB0aGlzLmJ1ZmZlcnNbaV07XG4gICAgICBpZiAodC5maWxlU3RhcnQgPD0gcy5maWxlU3RhcnQpIHtcbiAgICAgICAgaWYgKHQuZmlsZVN0YXJ0ID09PSBzLmZpbGVTdGFydClcbiAgICAgICAgICBpZiAodC5ieXRlTGVuZ3RoID4gcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnMuc3BsaWNlKGksIDEpLCBpLS07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHIud2FybihcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiQnVmZmVyIChmaWxlU3RhcnQ6IFwiICsgdC5maWxlU3RhcnQgKyBcIiAtIExlbmd0aDogXCIgKyB0LmJ5dGVMZW5ndGggKyBcIikgYWxyZWFkeSBhcHBlbmRlZCwgaWdub3JpbmdcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0LmZpbGVTdGFydCArIHQuYnl0ZUxlbmd0aCA8PSBzLmZpbGVTdGFydCB8fCAodCA9IHRoaXMucmVkdWNlQnVmZmVyKHQsIDAsIHMuZmlsZVN0YXJ0IC0gdC5maWxlU3RhcnQpKSwgci5kZWJ1ZyhcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiQXBwZW5kaW5nIG5ldyBidWZmZXIgKGZpbGVTdGFydDogXCIgKyB0LmZpbGVTdGFydCArIFwiIC0gTGVuZ3RoOiBcIiArIHQuYnl0ZUxlbmd0aCArIFwiKVwiKSwgdGhpcy5idWZmZXJzLnNwbGljZShpLCAwLCB0KSwgaSA9PT0gMCAmJiAodGhpcy5idWZmZXIgPSB0KTtcbiAgICAgICAgZSA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodC5maWxlU3RhcnQgPCBzLmZpbGVTdGFydCArIHMuYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgbyA9IHMuZmlsZVN0YXJ0ICsgcy5ieXRlTGVuZ3RoIC0gdC5maWxlU3RhcnQsIGMgPSB0LmJ5dGVMZW5ndGggLSBvO1xuICAgICAgICBpZiAoYyA+IDApXG4gICAgICAgICAgdCA9IHRoaXMucmVkdWNlQnVmZmVyKHQsIG8sIGMpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlID0gITE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZSAmJiAoci5kZWJ1ZyhcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiQXBwZW5kaW5nIG5ldyBidWZmZXIgKGZpbGVTdGFydDogXCIgKyB0LmZpbGVTdGFydCArIFwiIC0gTGVuZ3RoOiBcIiArIHQuYnl0ZUxlbmd0aCArIFwiKVwiKSwgdGhpcy5idWZmZXJzLnB1c2godCksIGkgPT09IDAgJiYgKHRoaXMuYnVmZmVyID0gdCkpO1xuICB9LCBkLnByb3RvdHlwZS5sb2dCdWZmZXJMZXZlbCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSwgcywgbywgYyA9IFtdLCB1LCBfID0gXCJcIjtcbiAgICBmb3IgKHMgPSAwLCBvID0gMCwgZSA9IDA7IGUgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBlKyspXG4gICAgICBpID0gdGhpcy5idWZmZXJzW2VdLCBlID09PSAwID8gKHUgPSB7fSwgYy5wdXNoKHUpLCB1LnN0YXJ0ID0gaS5maWxlU3RhcnQsIHUuZW5kID0gaS5maWxlU3RhcnQgKyBpLmJ5dGVMZW5ndGgsIF8gKz0gXCJbXCIgKyB1LnN0YXJ0ICsgXCItXCIpIDogdS5lbmQgPT09IGkuZmlsZVN0YXJ0ID8gdS5lbmQgPSBpLmZpbGVTdGFydCArIGkuYnl0ZUxlbmd0aCA6ICh1ID0ge30sIHUuc3RhcnQgPSBpLmZpbGVTdGFydCwgXyArPSBjW2MubGVuZ3RoIC0gMV0uZW5kIC0gMSArIFwiXSwgW1wiICsgdS5zdGFydCArIFwiLVwiLCB1LmVuZCA9IGkuZmlsZVN0YXJ0ICsgaS5ieXRlTGVuZ3RoLCBjLnB1c2godSkpLCBzICs9IGkudXNlZEJ5dGVzLCBvICs9IGkuYnl0ZUxlbmd0aDtcbiAgICBjLmxlbmd0aCA+IDAgJiYgKF8gKz0gdS5lbmQgLSAxICsgXCJdXCIpO1xuICAgIHZhciBnID0gdCA/IHIuaW5mbyA6IHIuZGVidWc7XG4gICAgdGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMCA/IGcoXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIk5vIG1vcmUgYnVmZmVyIGluIG1lbW9yeVwiKSA6IGcoXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIlwiICsgdGhpcy5idWZmZXJzLmxlbmd0aCArIFwiIHN0b3JlZCBidWZmZXIocykgKFwiICsgcyArIFwiL1wiICsgbyArIFwiIGJ5dGVzKSwgY29udGludW91cyByYW5nZXM6IFwiICsgXyk7XG4gIH0sIGQucHJvdG90eXBlLmNsZWFuQnVmZmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0LCBlO1xuICAgIGZvciAodCA9IDA7IHQgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyB0KyspXG4gICAgICBlID0gdGhpcy5idWZmZXJzW3RdLCBlLnVzZWRCeXRlcyA9PT0gZS5ieXRlTGVuZ3RoICYmIChyLmRlYnVnKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJSZW1vdmluZyBidWZmZXIgI1wiICsgdCksIHRoaXMuYnVmZmVycy5zcGxpY2UodCwgMSksIHQtLSk7XG4gIH0sIGQucHJvdG90eXBlLm1lcmdlTmV4dEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0O1xuICAgIGlmICh0aGlzLmJ1ZmZlckluZGV4ICsgMSA8IHRoaXMuYnVmZmVycy5sZW5ndGgpXG4gICAgICBpZiAodCA9IHRoaXMuYnVmZmVyc1t0aGlzLmJ1ZmZlckluZGV4ICsgMV0sIHQuZmlsZVN0YXJ0ID09PSB0aGlzLmJ1ZmZlci5maWxlU3RhcnQgKyB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCwgaSA9IHRoaXMuYnVmZmVyLnVzZWRCeXRlcywgcyA9IHRoaXMuYnVmZmVyLmZpbGVTdGFydDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyc1t0aGlzLmJ1ZmZlckluZGV4XSA9IEFycmF5QnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZmZlciwgdCksIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXJzW3RoaXMuYnVmZmVySW5kZXhdLCB0aGlzLmJ1ZmZlcnMuc3BsaWNlKHRoaXMuYnVmZmVySW5kZXggKyAxLCAxKSwgdGhpcy5idWZmZXIudXNlZEJ5dGVzID0gaSwgdGhpcy5idWZmZXIuZmlsZVN0YXJ0ID0gcywgci5kZWJ1ZyhcIklTT0ZpbGVcIiwgXCJDb25jYXRlbmF0aW5nIGJ1ZmZlciBmb3IgYm94IHBhcnNpbmcgKGxlbmd0aDogXCIgKyBlICsgXCItPlwiICsgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCArIFwiKVwiKSwgITA7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuICExO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAhMTtcbiAgfSwgZC5wcm90b3R5cGUuZmluZFBvc2l0aW9uID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICAgIHZhciBzLCBvID0gbnVsbCwgYyA9IC0xO1xuICAgIGZvciAodCA9PT0gITAgPyBzID0gMCA6IHMgPSB0aGlzLmJ1ZmZlckluZGV4OyBzIDwgdGhpcy5idWZmZXJzLmxlbmd0aCAmJiAobyA9IHRoaXMuYnVmZmVyc1tzXSwgby5maWxlU3RhcnQgPD0gZSk7ICkge1xuICAgICAgYyA9IHMsIGkgJiYgKG8uZmlsZVN0YXJ0ICsgby5ieXRlTGVuZ3RoIDw9IGUgPyBvLnVzZWRCeXRlcyA9IG8uYnl0ZUxlbmd0aCA6IG8udXNlZEJ5dGVzID0gZSAtIG8uZmlsZVN0YXJ0LCB0aGlzLmxvZ0J1ZmZlckxldmVsKCkpO1xuICAgICAgcysrO1xuICAgIH1cbiAgICByZXR1cm4gYyAhPT0gLTEgPyAobyA9IHRoaXMuYnVmZmVyc1tjXSwgby5maWxlU3RhcnQgKyBvLmJ5dGVMZW5ndGggPj0gZSA/IChyLmRlYnVnKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJGb3VuZCBwb3NpdGlvbiBpbiBleGlzdGluZyBidWZmZXIgI1wiICsgYyksIGMpIDogLTEpIDogLTE7XG4gIH0sIGQucHJvdG90eXBlLmZpbmRFbmRDb250aWd1b3VzQnVmID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpLCBzLCBvID0gdCAhPT0gdm9pZCAwID8gdCA6IHRoaXMuYnVmZmVySW5kZXg7XG4gICAgaWYgKGkgPSB0aGlzLmJ1ZmZlcnNbb10sIHRoaXMuYnVmZmVycy5sZW5ndGggPiBvICsgMSlcbiAgICAgIGZvciAoZSA9IG8gKyAxOyBlIDwgdGhpcy5idWZmZXJzLmxlbmd0aCAmJiAocyA9IHRoaXMuYnVmZmVyc1tlXSwgcy5maWxlU3RhcnQgPT09IGkuZmlsZVN0YXJ0ICsgaS5ieXRlTGVuZ3RoKTsgZSsrKVxuICAgICAgICBpID0gcztcbiAgICByZXR1cm4gaS5maWxlU3RhcnQgKyBpLmJ5dGVMZW5ndGg7XG4gIH0sIGQucHJvdG90eXBlLmdldEVuZEZpbGVQb3NpdGlvbkFmdGVyID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdGhpcy5maW5kUG9zaXRpb24oITAsIHQsICExKTtcbiAgICByZXR1cm4gZSAhPT0gLTEgPyB0aGlzLmZpbmRFbmRDb250aWd1b3VzQnVmKGUpIDogdDtcbiAgfSwgZC5wcm90b3R5cGUuYWRkVXNlZEJ5dGVzID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuYnVmZmVyLnVzZWRCeXRlcyArPSB0LCB0aGlzLmxvZ0J1ZmZlckxldmVsKCk7XG4gIH0sIGQucHJvdG90eXBlLnNldEFsbFVzZWRCeXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYnVmZmVyLnVzZWRCeXRlcyA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgsIHRoaXMubG9nQnVmZmVyTGV2ZWwoKTtcbiAgfSwgZC5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICB2YXIgcztcbiAgICByZXR1cm4gcyA9IHRoaXMuZmluZFBvc2l0aW9uKGUsIHQsIGkpLCBzICE9PSAtMSA/ICh0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyc1tzXSwgdGhpcy5idWZmZXJJbmRleCA9IHMsIHRoaXMucG9zaXRpb24gPSB0IC0gdGhpcy5idWZmZXIuZmlsZVN0YXJ0LCByLmRlYnVnKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJSZXBvc2l0aW9uaW5nIHBhcnNlciBhdCBidWZmZXIgcG9zaXRpb246IFwiICsgdGhpcy5wb3NpdGlvbiksICEwKSA6IChyLmRlYnVnKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJQb3NpdGlvbiBcIiArIHQgKyBcIiBub3QgZm91bmQgaW4gYnVmZmVyZWQgZGF0YVwiKSwgITEpO1xuICB9LCBkLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlckluZGV4ID09PSAtMSB8fCB0aGlzLmJ1ZmZlcnNbdGhpcy5idWZmZXJJbmRleF0gPT09IG51bGwpXG4gICAgICB0aHJvdyBcIkVycm9yIGFjY2Vzc2luZyBwb3NpdGlvbiBpbiB0aGUgTXVsdGlCdWZmZXJTdHJlYW1cIjtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJzW3RoaXMuYnVmZmVySW5kZXhdLmZpbGVTdGFydCArIHRoaXMucG9zaXRpb247XG4gIH0sIGQucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVMZW5ndGg7XG4gIH0sIGQucHJvdG90eXBlLmdldEVuZFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVySW5kZXggPT09IC0xIHx8IHRoaXMuYnVmZmVyc1t0aGlzLmJ1ZmZlckluZGV4XSA9PT0gbnVsbClcbiAgICAgIHRocm93IFwiRXJyb3IgYWNjZXNzaW5nIHBvc2l0aW9uIGluIHRoZSBNdWx0aUJ1ZmZlclN0cmVhbVwiO1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbdGhpcy5idWZmZXJJbmRleF0uZmlsZVN0YXJ0ICsgdGhpcy5ieXRlTGVuZ3RoO1xuICB9LCBsLk11bHRpQnVmZmVyU3RyZWFtID0gZDtcbiAgdmFyIHAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IDMsIGUgPSA0LCBpID0gNSwgcyA9IDYsIG8gPSBbXTtcbiAgICBvW3RdID0gXCJFU19EZXNjcmlwdG9yXCIsIG9bZV0gPSBcIkRlY29kZXJDb25maWdEZXNjcmlwdG9yXCIsIG9baV0gPSBcIkRlY29kZXJTcGVjaWZpY0luZm9cIiwgb1tzXSA9IFwiU0xDb25maWdEZXNjcmlwdG9yXCIsIHRoaXMuZ2V0RGVzY3JpcHRvck5hbWUgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gb1tfXTtcbiAgICB9O1xuICAgIHZhciBjID0gdGhpcywgdSA9IHt9O1xuICAgIHJldHVybiB0aGlzLnBhcnNlT25lRGVzY3JpcHRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHZhciBnID0gMCwgdywgUywgVTtcbiAgICAgIGZvciAodyA9IF8ucmVhZFVpbnQ4KCksIFUgPSBfLnJlYWRVaW50OCgpOyBVICYgMTI4OyApXG4gICAgICAgIGcgPSAoVSAmIDEyNykgPDwgNywgVSA9IF8ucmVhZFVpbnQ4KCk7XG4gICAgICByZXR1cm4gZyArPSBVICYgMTI3LCByLmRlYnVnKFwiTVBFRzREZXNjcmlwdG9yUGFyc2VyXCIsIFwiRm91bmQgXCIgKyAob1t3XSB8fCBcIkRlc2NyaXB0b3IgXCIgKyB3KSArIFwiLCBzaXplIFwiICsgZyArIFwiIGF0IHBvc2l0aW9uIFwiICsgXy5nZXRQb3NpdGlvbigpKSwgb1t3XSA/IFMgPSBuZXcgdVtvW3ddXShnKSA6IFMgPSBuZXcgdS5EZXNjcmlwdG9yKGcpLCBTLnBhcnNlKF8pLCBTO1xuICAgIH0sIHUuRGVzY3JpcHRvciA9IGZ1bmN0aW9uKF8sIGcpIHtcbiAgICAgIHRoaXMudGFnID0gXywgdGhpcy5zaXplID0gZywgdGhpcy5kZXNjcyA9IFtdO1xuICAgIH0sIHUuRGVzY3JpcHRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICB0aGlzLmRhdGEgPSBfLnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZSk7XG4gICAgfSwgdS5EZXNjcmlwdG9yLnByb3RvdHlwZS5maW5kRGVzY3JpcHRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgdGhpcy5kZXNjcy5sZW5ndGg7IGcrKylcbiAgICAgICAgaWYgKHRoaXMuZGVzY3NbZ10udGFnID09IF8pXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzY3NbZ107XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCB1LkRlc2NyaXB0b3IucHJvdG90eXBlLnBhcnNlUmVtYWluaW5nRGVzY3JpcHRvcnMgPSBmdW5jdGlvbihfKSB7XG4gICAgICBmb3IgKHZhciBnID0gXy5wb3NpdGlvbjsgXy5wb3NpdGlvbiA8IGcgKyB0aGlzLnNpemU7ICkge1xuICAgICAgICB2YXIgdyA9IGMucGFyc2VPbmVEZXNjcmlwdG9yKF8pO1xuICAgICAgICB0aGlzLmRlc2NzLnB1c2godyk7XG4gICAgICB9XG4gICAgfSwgdS5FU19EZXNjcmlwdG9yID0gZnVuY3Rpb24oXykge1xuICAgICAgdS5EZXNjcmlwdG9yLmNhbGwodGhpcywgdCwgXyk7XG4gICAgfSwgdS5FU19EZXNjcmlwdG9yLnByb3RvdHlwZSA9IG5ldyB1LkRlc2NyaXB0b3IoKSwgdS5FU19EZXNjcmlwdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICh0aGlzLkVTX0lEID0gXy5yZWFkVWludDE2KCksIHRoaXMuZmxhZ3MgPSBfLnJlYWRVaW50OCgpLCB0aGlzLnNpemUgLT0gMywgdGhpcy5mbGFncyAmIDEyOCA/ICh0aGlzLmRlcGVuZHNPbl9FU19JRCA9IF8ucmVhZFVpbnQxNigpLCB0aGlzLnNpemUgLT0gMikgOiB0aGlzLmRlcGVuZHNPbl9FU19JRCA9IDAsIHRoaXMuZmxhZ3MgJiA2NCkge1xuICAgICAgICB2YXIgZyA9IF8ucmVhZFVpbnQ4KCk7XG4gICAgICAgIHRoaXMuVVJMID0gXy5yZWFkU3RyaW5nKGcpLCB0aGlzLnNpemUgLT0gZyArIDE7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy5VUkwgPSBcIlwiO1xuICAgICAgdGhpcy5mbGFncyAmIDMyID8gKHRoaXMuT0NSX0VTX0lEID0gXy5yZWFkVWludDE2KCksIHRoaXMuc2l6ZSAtPSAyKSA6IHRoaXMuT0NSX0VTX0lEID0gMCwgdGhpcy5wYXJzZVJlbWFpbmluZ0Rlc2NyaXB0b3JzKF8pO1xuICAgIH0sIHUuRVNfRGVzY3JpcHRvci5wcm90b3R5cGUuZ2V0T1RJID0gZnVuY3Rpb24oXykge1xuICAgICAgdmFyIGcgPSB0aGlzLmZpbmREZXNjcmlwdG9yKGUpO1xuICAgICAgcmV0dXJuIGcgPyBnLm90aSA6IDA7XG4gICAgfSwgdS5FU19EZXNjcmlwdG9yLnByb3RvdHlwZS5nZXRBdWRpb0NvbmZpZyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHZhciBnID0gdGhpcy5maW5kRGVzY3JpcHRvcihlKTtcbiAgICAgIGlmICghZykgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgdyA9IGcuZmluZERlc2NyaXB0b3IoaSk7XG4gICAgICBpZiAodyAmJiB3LmRhdGEpIHtcbiAgICAgICAgdmFyIFMgPSAody5kYXRhWzBdICYgMjQ4KSA+PiAzO1xuICAgICAgICByZXR1cm4gUyA9PT0gMzEgJiYgdy5kYXRhLmxlbmd0aCA+PSAyICYmIChTID0gMzIgKyAoKHcuZGF0YVswXSAmIDcpIDw8IDMpICsgKCh3LmRhdGFbMV0gJiAyMjQpID4+IDUpKSwgUztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCB1LkRlY29kZXJDb25maWdEZXNjcmlwdG9yID0gZnVuY3Rpb24oXykge1xuICAgICAgdS5EZXNjcmlwdG9yLmNhbGwodGhpcywgZSwgXyk7XG4gICAgfSwgdS5EZWNvZGVyQ29uZmlnRGVzY3JpcHRvci5wcm90b3R5cGUgPSBuZXcgdS5EZXNjcmlwdG9yKCksIHUuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oXykge1xuICAgICAgdGhpcy5vdGkgPSBfLnJlYWRVaW50OCgpLCB0aGlzLnN0cmVhbVR5cGUgPSBfLnJlYWRVaW50OCgpLCB0aGlzLmJ1ZmZlclNpemUgPSBfLnJlYWRVaW50MjQoKSwgdGhpcy5tYXhCaXRyYXRlID0gXy5yZWFkVWludDMyKCksIHRoaXMuYXZnQml0cmF0ZSA9IF8ucmVhZFVpbnQzMigpLCB0aGlzLnNpemUgLT0gMTMsIHRoaXMucGFyc2VSZW1haW5pbmdEZXNjcmlwdG9ycyhfKTtcbiAgICB9LCB1LkRlY29kZXJTcGVjaWZpY0luZm8gPSBmdW5jdGlvbihfKSB7XG4gICAgICB1LkRlc2NyaXB0b3IuY2FsbCh0aGlzLCBpLCBfKTtcbiAgICB9LCB1LkRlY29kZXJTcGVjaWZpY0luZm8ucHJvdG90eXBlID0gbmV3IHUuRGVzY3JpcHRvcigpLCB1LlNMQ29uZmlnRGVzY3JpcHRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHUuRGVzY3JpcHRvci5jYWxsKHRoaXMsIHMsIF8pO1xuICAgIH0sIHUuU0xDb25maWdEZXNjcmlwdG9yLnByb3RvdHlwZSA9IG5ldyB1LkRlc2NyaXB0b3IoKSwgdGhpcztcbiAgfTtcbiAgbC5NUEVHNERlc2NyaXB0b3JQYXJzZXIgPSBwO1xuICB2YXIgbiA9IHtcbiAgICBFUlJfSU5WQUxJRF9EQVRBOiAtMSxcbiAgICBFUlJfTk9UX0VOT1VHSF9EQVRBOiAwLFxuICAgIE9LOiAxLFxuICAgIC8vIEJveGVzIHRvIGJlIGNyZWF0ZWQgd2l0aCBkZWZhdWx0IHBhcnNpbmdcbiAgICBCQVNJQ19CT1hFUzogW1wibWRhdFwiLCBcImlkYXRcIiwgXCJmcmVlXCIsIFwic2tpcFwiLCBcIm1lY29cIiwgXCJzdHJrXCJdLFxuICAgIEZVTExfQk9YRVM6IFtcImhtaGRcIiwgXCJubWhkXCIsIFwiaW9kc1wiLCBcInhtbCBcIiwgXCJieG1sXCIsIFwiaXByb1wiLCBcIm1lcmVcIl0sXG4gICAgQ09OVEFJTkVSX0JPWEVTOiBbXG4gICAgICBbXCJtb292XCIsIFtcInRyYWtcIiwgXCJwc3NoXCJdXSxcbiAgICAgIFtcInRyYWtcIl0sXG4gICAgICBbXCJlZHRzXCJdLFxuICAgICAgW1wibWRpYVwiXSxcbiAgICAgIFtcIm1pbmZcIl0sXG4gICAgICBbXCJkaW5mXCJdLFxuICAgICAgW1wic3RibFwiLCBbXCJzZ3BkXCIsIFwic2JncFwiXV0sXG4gICAgICBbXCJtdmV4XCIsIFtcInRyZXhcIl1dLFxuICAgICAgW1wibW9vZlwiLCBbXCJ0cmFmXCJdXSxcbiAgICAgIFtcInRyYWZcIiwgW1widHJ1blwiLCBcInNncGRcIiwgXCJzYmdwXCJdXSxcbiAgICAgIFtcInZ0dGNcIl0sXG4gICAgICBbXCJ0cmVmXCJdLFxuICAgICAgW1wiaXJlZlwiXSxcbiAgICAgIFtcIm1mcmFcIiwgW1widGZyYVwiXV0sXG4gICAgICBbXCJtZWNvXCJdLFxuICAgICAgW1wiaG50aVwiXSxcbiAgICAgIFtcImhpbmZcIl0sXG4gICAgICBbXCJzdHJrXCJdLFxuICAgICAgW1wic3RyZFwiXSxcbiAgICAgIFtcInNpbmZcIl0sXG4gICAgICBbXCJyaW5mXCJdLFxuICAgICAgW1wic2NoaVwiXSxcbiAgICAgIFtcInRyZ3JcIl0sXG4gICAgICBbXCJ1ZHRhXCIsIFtcImtpbmRcIl1dLFxuICAgICAgW1wiaXBycFwiLCBbXCJpcG1hXCJdXSxcbiAgICAgIFtcImlwY29cIl1cbiAgICBdLFxuICAgIC8vIEJveGVzIGVmZmVjdGl2ZWx5IGNyZWF0ZWRcbiAgICBib3hDb2RlczogW10sXG4gICAgZnVsbEJveENvZGVzOiBbXSxcbiAgICBjb250YWluZXJCb3hDb2RlczogW10sXG4gICAgc2FtcGxlRW50cnlDb2Rlczoge30sXG4gICAgc2FtcGxlR3JvdXBFbnRyeUNvZGVzOiBbXSxcbiAgICB0cmFja0dyb3VwVHlwZXM6IFtdLFxuICAgIFVVSURCb3hlczoge30sXG4gICAgVVVJRHM6IFtdLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgbi5GdWxsQm94LnByb3RvdHlwZSA9IG5ldyBuLkJveCgpLCBuLkNvbnRhaW5lckJveC5wcm90b3R5cGUgPSBuZXcgbi5Cb3goKSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUgPSBuZXcgbi5Cb3goKSwgbi5UcmFja0dyb3VwVHlwZUJveC5wcm90b3R5cGUgPSBuZXcgbi5GdWxsQm94KCksIG4uQkFTSUNfQk9YRVMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgIG4uY3JlYXRlQm94Q3Rvcih0KTtcbiAgICAgIH0pLCBuLkZVTExfQk9YRVMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgIG4uY3JlYXRlRnVsbEJveEN0b3IodCk7XG4gICAgICB9KSwgbi5DT05UQUlORVJfQk9YRVMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgIG4uY3JlYXRlQ29udGFpbmVyQm94Q3Rvcih0WzBdLCBudWxsLCB0WzFdKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgQm94OiBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLnNpemUgPSBlLCB0aGlzLnV1aWQgPSBpO1xuICAgIH0sXG4gICAgRnVsbEJveDogZnVuY3Rpb24odCwgZSwgaSkge1xuICAgICAgbi5Cb3guY2FsbCh0aGlzLCB0LCBlLCBpKSwgdGhpcy5mbGFncyA9IDAsIHRoaXMudmVyc2lvbiA9IDA7XG4gICAgfSxcbiAgICBDb250YWluZXJCb3g6IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICAgIG4uQm94LmNhbGwodGhpcywgdCwgZSwgaSksIHRoaXMuYm94ZXMgPSBbXTtcbiAgICB9LFxuICAgIFNhbXBsZUVudHJ5OiBmdW5jdGlvbih0LCBlLCBpLCBzKSB7XG4gICAgICBuLkNvbnRhaW5lckJveC5jYWxsKHRoaXMsIHQsIGUpLCB0aGlzLmhkcl9zaXplID0gaSwgdGhpcy5zdGFydCA9IHM7XG4gICAgfSxcbiAgICBTYW1wbGVHcm91cEVudHJ5OiBmdW5jdGlvbih0KSB7XG4gICAgICB0aGlzLmdyb3VwaW5nX3R5cGUgPSB0O1xuICAgIH0sXG4gICAgVHJhY2tHcm91cFR5cGVCb3g6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgIG4uRnVsbEJveC5jYWxsKHRoaXMsIHQsIGUpO1xuICAgIH0sXG4gICAgY3JlYXRlQm94Q3RvcjogZnVuY3Rpb24odCwgZSkge1xuICAgICAgbi5ib3hDb2Rlcy5wdXNoKHQpLCBuW3QgKyBcIkJveFwiXSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgbi5Cb3guY2FsbCh0aGlzLCB0LCBpKTtcbiAgICAgIH0sIG5bdCArIFwiQm94XCJdLnByb3RvdHlwZSA9IG5ldyBuLkJveCgpLCBlICYmIChuW3QgKyBcIkJveFwiXS5wcm90b3R5cGUucGFyc2UgPSBlKTtcbiAgICB9LFxuICAgIGNyZWF0ZUZ1bGxCb3hDdG9yOiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICBuW3QgKyBcIkJveFwiXSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgbi5GdWxsQm94LmNhbGwodGhpcywgdCwgaSk7XG4gICAgICB9LCBuW3QgKyBcIkJveFwiXS5wcm90b3R5cGUgPSBuZXcgbi5GdWxsQm94KCksIG5bdCArIFwiQm94XCJdLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdGhpcy5wYXJzZUZ1bGxIZWFkZXIoaSksIGUgJiYgZS5jYWxsKHRoaXMsIGkpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFN1YkJveEFycmF5czogZnVuY3Rpb24odCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdGhpcy5zdWJCb3hOYW1lcyA9IHQ7XG4gICAgICAgIGZvciAodmFyIGUgPSB0Lmxlbmd0aCwgaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICAgICAgdGhpc1t0W2ldICsgXCJzXCJdID0gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVDb250YWluZXJCb3hDdG9yOiBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgICBuW3QgKyBcIkJveFwiXSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgbi5Db250YWluZXJCb3guY2FsbCh0aGlzLCB0LCBzKSwgbi5hZGRTdWJCb3hBcnJheXMuY2FsbCh0aGlzLCBpKTtcbiAgICAgIH0sIG5bdCArIFwiQm94XCJdLnByb3RvdHlwZSA9IG5ldyBuLkNvbnRhaW5lckJveCgpLCBlICYmIChuW3QgKyBcIkJveFwiXS5wcm90b3R5cGUucGFyc2UgPSBlKTtcbiAgICB9LFxuICAgIGNyZWF0ZU1lZGlhU2FtcGxlRW50cnlDdG9yOiBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgICBuLnNhbXBsZUVudHJ5Q29kZXNbdF0gPSBbXSwgblt0ICsgXCJTYW1wbGVFbnRyeVwiXSA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgbi5TYW1wbGVFbnRyeS5jYWxsKHRoaXMsIHMsIG8pLCBuLmFkZFN1YkJveEFycmF5cy5jYWxsKHRoaXMsIGkpO1xuICAgICAgfSwgblt0ICsgXCJTYW1wbGVFbnRyeVwiXS5wcm90b3R5cGUgPSBuZXcgbi5TYW1wbGVFbnRyeSgpLCBlICYmIChuW3QgKyBcIlNhbXBsZUVudHJ5XCJdLnByb3RvdHlwZS5wYXJzZSA9IGUpO1xuICAgIH0sXG4gICAgY3JlYXRlU2FtcGxlRW50cnlDdG9yOiBmdW5jdGlvbih0LCBlLCBpLCBzKSB7XG4gICAgICBuLnNhbXBsZUVudHJ5Q29kZXNbdF0ucHVzaChlKSwgbltlICsgXCJTYW1wbGVFbnRyeVwiXSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgblt0ICsgXCJTYW1wbGVFbnRyeVwiXS5jYWxsKHRoaXMsIGUsIG8pLCBuLmFkZFN1YkJveEFycmF5cy5jYWxsKHRoaXMsIHMpO1xuICAgICAgfSwgbltlICsgXCJTYW1wbGVFbnRyeVwiXS5wcm90b3R5cGUgPSBuZXcgblt0ICsgXCJTYW1wbGVFbnRyeVwiXSgpLCBpICYmIChuW2UgKyBcIlNhbXBsZUVudHJ5XCJdLnByb3RvdHlwZS5wYXJzZSA9IGkpO1xuICAgIH0sXG4gICAgY3JlYXRlRW5jcnlwdGVkU2FtcGxlRW50cnlDdG9yOiBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgICBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3Rvci5jYWxsKHRoaXMsIHQsIGUsIGksIFtcInNpbmZcIl0pO1xuICAgIH0sXG4gICAgY3JlYXRlU2FtcGxlR3JvdXBDdG9yOiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICBuW3QgKyBcIlNhbXBsZUdyb3VwRW50cnlcIl0gPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIG4uU2FtcGxlR3JvdXBFbnRyeS5jYWxsKHRoaXMsIHQsIGkpO1xuICAgICAgfSwgblt0ICsgXCJTYW1wbGVHcm91cEVudHJ5XCJdLnByb3RvdHlwZSA9IG5ldyBuLlNhbXBsZUdyb3VwRW50cnkoKSwgZSAmJiAoblt0ICsgXCJTYW1wbGVHcm91cEVudHJ5XCJdLnByb3RvdHlwZS5wYXJzZSA9IGUpO1xuICAgIH0sXG4gICAgY3JlYXRlVHJhY2tHcm91cEN0b3I6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgIG5bdCArIFwiVHJhY2tHcm91cFR5cGVCb3hcIl0gPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIG4uVHJhY2tHcm91cFR5cGVCb3guY2FsbCh0aGlzLCB0LCBpKTtcbiAgICAgIH0sIG5bdCArIFwiVHJhY2tHcm91cFR5cGVCb3hcIl0ucHJvdG90eXBlID0gbmV3IG4uVHJhY2tHcm91cFR5cGVCb3goKSwgZSAmJiAoblt0ICsgXCJUcmFja0dyb3VwVHlwZUJveFwiXS5wcm90b3R5cGUucGFyc2UgPSBlKTtcbiAgICB9LFxuICAgIGNyZWF0ZVVVSURCb3g6IGZ1bmN0aW9uKHQsIGUsIGksIHMpIHtcbiAgICAgIG4uVVVJRHMucHVzaCh0KSwgbi5VVUlEQm94ZXNbdF0gPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIGUgPyBuLkZ1bGxCb3guY2FsbCh0aGlzLCBcInV1aWRcIiwgbywgdCkgOiBpID8gbi5Db250YWluZXJCb3guY2FsbCh0aGlzLCBcInV1aWRcIiwgbywgdCkgOiBuLkJveC5jYWxsKHRoaXMsIFwidXVpZFwiLCBvLCB0KTtcbiAgICAgIH0sIG4uVVVJREJveGVzW3RdLnByb3RvdHlwZSA9IGUgPyBuZXcgbi5GdWxsQm94KCkgOiBpID8gbmV3IG4uQ29udGFpbmVyQm94KCkgOiBuZXcgbi5Cb3goKSwgcyAmJiAoZSA/IG4uVVVJREJveGVzW3RdLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdGhpcy5wYXJzZUZ1bGxIZWFkZXIobyksIHMgJiYgcy5jYWxsKHRoaXMsIG8pO1xuICAgICAgfSA6IG4uVVVJREJveGVzW3RdLnByb3RvdHlwZS5wYXJzZSA9IHMpO1xuICAgIH1cbiAgfTtcbiAgbi5pbml0aWFsaXplKCksIG4uVEtIRF9GTEFHX0VOQUJMRUQgPSAxLCBuLlRLSERfRkxBR19JTl9NT1ZJRSA9IDIsIG4uVEtIRF9GTEFHX0lOX1BSRVZJRVcgPSA0LCBuLlRGSERfRkxBR19CQVNFX0RBVEFfT0ZGU0VUID0gMSwgbi5URkhEX0ZMQUdfU0FNUExFX0RFU0MgPSAyLCBuLlRGSERfRkxBR19TQU1QTEVfRFVSID0gOCwgbi5URkhEX0ZMQUdfU0FNUExFX1NJWkUgPSAxNiwgbi5URkhEX0ZMQUdfU0FNUExFX0ZMQUdTID0gMzIsIG4uVEZIRF9GTEFHX0RVUl9FTVBUWSA9IDY1NTM2LCBuLlRGSERfRkxBR19ERUZBVUxUX0JBU0VfSVNfTU9PRiA9IDEzMTA3Miwgbi5UUlVOX0ZMQUdTX0RBVEFfT0ZGU0VUID0gMSwgbi5UUlVOX0ZMQUdTX0ZJUlNUX0ZMQUcgPSA0LCBuLlRSVU5fRkxBR1NfRFVSQVRJT04gPSAyNTYsIG4uVFJVTl9GTEFHU19TSVpFID0gNTEyLCBuLlRSVU5fRkxBR1NfRkxBR1MgPSAxMDI0LCBuLlRSVU5fRkxBR1NfQ1RTX09GRlNFVCA9IDIwNDgsIG4uQm94LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQm94KG5ldyBuW3QgKyBcIkJveFwiXSgpKTtcbiAgfSwgbi5Cb3gucHJvdG90eXBlLmFkZEJveCA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdGhpcy5ib3hlcy5wdXNoKHQpLCB0aGlzW3QudHlwZSArIFwic1wiXSA/IHRoaXNbdC50eXBlICsgXCJzXCJdLnB1c2godCkgOiB0aGlzW3QudHlwZV0gPSB0LCB0O1xuICB9LCBuLkJveC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHJldHVybiB0aGlzW3RdID0gZSwgdGhpcztcbiAgfSwgbi5Cb3gucHJvdG90eXBlLmFkZEVudHJ5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHZhciBpID0gZSB8fCBcImVudHJpZXNcIjtcbiAgICByZXR1cm4gdGhpc1tpXSB8fCAodGhpc1tpXSA9IFtdKSwgdGhpc1tpXS5wdXNoKHQpLCB0aGlzO1xuICB9LCBsLkJveFBhcnNlciA9IG4sIG4ucGFyc2VVVUlEID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBuLnBhcnNlSGV4MTYodCk7XG4gIH0sIG4ucGFyc2VIZXgxNiA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gXCJcIiwgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB2YXIgcyA9IHQucmVhZFVpbnQ4KCkudG9TdHJpbmcoMTYpO1xuICAgICAgZSArPSBzLmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgcyA6IHM7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBuLnBhcnNlT25lQm94ID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICAgIHZhciBzLCBvID0gdC5nZXRQb3NpdGlvbigpLCBjID0gMCwgdSwgXztcbiAgICBpZiAodC5nZXRFbmRQb3NpdGlvbigpIC0gbyA8IDgpXG4gICAgICByZXR1cm4gci5kZWJ1ZyhcIkJveFBhcnNlclwiLCBcIk5vdCBlbm91Z2ggZGF0YSBpbiBzdHJlYW0gdG8gcGFyc2UgdGhlIHR5cGUgYW5kIHNpemUgb2YgdGhlIGJveFwiKSwgeyBjb2RlOiBuLkVSUl9OT1RfRU5PVUdIX0RBVEEgfTtcbiAgICBpZiAoaSAmJiBpIDwgOClcbiAgICAgIHJldHVybiByLmRlYnVnKFwiQm94UGFyc2VyXCIsIFwiTm90IGVub3VnaCBieXRlcyBsZWZ0IGluIHRoZSBwYXJlbnQgYm94IHRvIHBhcnNlIGEgbmV3IGJveFwiKSwgeyBjb2RlOiBuLkVSUl9OT1RfRU5PVUdIX0RBVEEgfTtcbiAgICB2YXIgZyA9IHQucmVhZFVpbnQzMigpLCB3ID0gdC5yZWFkU3RyaW5nKDQpLCBTID0gdztcbiAgICBpZiAoci5kZWJ1ZyhcIkJveFBhcnNlclwiLCBcIkZvdW5kIGJveCBvZiB0eXBlICdcIiArIHcgKyBcIicgYW5kIHNpemUgXCIgKyBnICsgXCIgYXQgcG9zaXRpb24gXCIgKyBvKSwgYyA9IDgsIHcgPT0gXCJ1dWlkXCIpIHtcbiAgICAgIGlmICh0LmdldEVuZFBvc2l0aW9uKCkgLSB0LmdldFBvc2l0aW9uKCkgPCAxNiB8fCBpIC0gYyA8IDE2KVxuICAgICAgICByZXR1cm4gdC5zZWVrKG8pLCByLmRlYnVnKFwiQm94UGFyc2VyXCIsIFwiTm90IGVub3VnaCBieXRlcyBsZWZ0IGluIHRoZSBwYXJlbnQgYm94IHRvIHBhcnNlIGEgVVVJRCBib3hcIiksIHsgY29kZTogbi5FUlJfTk9UX0VOT1VHSF9EQVRBIH07XG4gICAgICBfID0gbi5wYXJzZVVVSUQodCksIGMgKz0gMTYsIFMgPSBfO1xuICAgIH1cbiAgICBpZiAoZyA9PSAxKSB7XG4gICAgICBpZiAodC5nZXRFbmRQb3NpdGlvbigpIC0gdC5nZXRQb3NpdGlvbigpIDwgOCB8fCBpICYmIGkgLSBjIDwgOClcbiAgICAgICAgcmV0dXJuIHQuc2VlayhvKSwgci53YXJuKFwiQm94UGFyc2VyXCIsICdOb3QgZW5vdWdoIGRhdGEgaW4gc3RyZWFtIHRvIHBhcnNlIHRoZSBleHRlbmRlZCBzaXplIG9mIHRoZSBcIicgKyB3ICsgJ1wiIGJveCcpLCB7IGNvZGU6IG4uRVJSX05PVF9FTk9VR0hfREFUQSB9O1xuICAgICAgZyA9IHQucmVhZFVpbnQ2NCgpLCBjICs9IDg7XG4gICAgfSBlbHNlIGlmIChnID09PSAwKSB7XG4gICAgICBpZiAoaSlcbiAgICAgICAgZyA9IGk7XG4gICAgICBlbHNlIGlmICh3ICE9PSBcIm1kYXRcIilcbiAgICAgICAgcmV0dXJuIHIuZXJyb3IoXCJCb3hQYXJzZXJcIiwgXCJVbmxpbWl0ZWQgYm94IHNpemUgbm90IHN1cHBvcnRlZCBmb3IgdHlwZTogJ1wiICsgdyArIFwiJ1wiKSwgcyA9IG5ldyBuLkJveCh3LCBnKSwgeyBjb2RlOiBuLk9LLCBib3g6IHMsIHNpemU6IHMuc2l6ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gZyAhPT0gMCAmJiBnIDwgYyA/IChyLmVycm9yKFwiQm94UGFyc2VyXCIsIFwiQm94IG9mIHR5cGUgXCIgKyB3ICsgXCIgaGFzIGFuIGludmFsaWQgc2l6ZSBcIiArIGcgKyBcIiAodG9vIHNtYWxsIHRvIGJlIGEgYm94KVwiKSwgeyBjb2RlOiBuLkVSUl9OT1RfRU5PVUdIX0RBVEEsIHR5cGU6IHcsIHNpemU6IGcsIGhkcl9zaXplOiBjLCBzdGFydDogbyB9KSA6IGcgIT09IDAgJiYgaSAmJiBnID4gaSA/IChyLmVycm9yKFwiQm94UGFyc2VyXCIsIFwiQm94IG9mIHR5cGUgJ1wiICsgdyArIFwiJyBoYXMgYSBzaXplIFwiICsgZyArIFwiIGdyZWF0ZXIgdGhhbiBpdHMgY29udGFpbmVyIHNpemUgXCIgKyBpKSwgeyBjb2RlOiBuLkVSUl9OT1RfRU5PVUdIX0RBVEEsIHR5cGU6IHcsIHNpemU6IGcsIGhkcl9zaXplOiBjLCBzdGFydDogbyB9KSA6IGcgIT09IDAgJiYgbyArIGcgPiB0LmdldEVuZFBvc2l0aW9uKCkgPyAodC5zZWVrKG8pLCByLmluZm8oXCJCb3hQYXJzZXJcIiwgXCJOb3QgZW5vdWdoIGRhdGEgaW4gc3RyZWFtIHRvIHBhcnNlIHRoZSBlbnRpcmUgJ1wiICsgdyArIFwiJyBib3hcIiksIHsgY29kZTogbi5FUlJfTk9UX0VOT1VHSF9EQVRBLCB0eXBlOiB3LCBzaXplOiBnLCBoZHJfc2l6ZTogYywgc3RhcnQ6IG8gfSkgOiBlID8geyBjb2RlOiBuLk9LLCB0eXBlOiB3LCBzaXplOiBnLCBoZHJfc2l6ZTogYywgc3RhcnQ6IG8gfSA6IChuW3cgKyBcIkJveFwiXSA/IHMgPSBuZXcgblt3ICsgXCJCb3hcIl0oZykgOiB3ICE9PSBcInV1aWRcIiA/IChyLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJVbmtub3duIGJveCB0eXBlOiAnXCIgKyB3ICsgXCInXCIpLCBzID0gbmV3IG4uQm94KHcsIGcpLCBzLmhhc191bnBhcnNlZF9kYXRhID0gITApIDogbi5VVUlEQm94ZXNbX10gPyBzID0gbmV3IG4uVVVJREJveGVzW19dKGcpIDogKHIud2FybihcIkJveFBhcnNlclwiLCBcIlVua25vd24gdXVpZCB0eXBlOiAnXCIgKyBfICsgXCInXCIpLCBzID0gbmV3IG4uQm94KHcsIGcpLCBzLnV1aWQgPSBfLCBzLmhhc191bnBhcnNlZF9kYXRhID0gITApLCBzLmhkcl9zaXplID0gYywgcy5zdGFydCA9IG8sIHMud3JpdGUgPT09IG4uQm94LnByb3RvdHlwZS53cml0ZSAmJiBzLnR5cGUgIT09IFwibWRhdFwiICYmIChyLmluZm8oXCJCb3hQYXJzZXJcIiwgXCInXCIgKyBTICsgXCInIGJveCB3cml0aW5nIG5vdCB5ZXQgaW1wbGVtZW50ZWQsIGtlZXBpbmcgdW5wYXJzZWQgZGF0YSBpbiBtZW1vcnkgZm9yIGxhdGVyIHdyaXRlXCIpLCBzLnBhcnNlRGF0YUFuZFJld2luZCh0KSksIHMucGFyc2UodCksIHUgPSB0LmdldFBvc2l0aW9uKCkgLSAocy5zdGFydCArIHMuc2l6ZSksIHUgPCAwID8gKHIud2FybihcIkJveFBhcnNlclwiLCBcIlBhcnNpbmcgb2YgYm94ICdcIiArIFMgKyBcIicgZGlkIG5vdCByZWFkIHRoZSBlbnRpcmUgaW5kaWNhdGVkIGJveCBkYXRhIHNpemUgKG1pc3NpbmcgXCIgKyAtdSArIFwiIGJ5dGVzKSwgc2Vla2luZyBmb3J3YXJkXCIpLCB0LnNlZWsocy5zdGFydCArIHMuc2l6ZSkpIDogdSA+IDAgJiYgKHIuZXJyb3IoXCJCb3hQYXJzZXJcIiwgXCJQYXJzaW5nIG9mIGJveCAnXCIgKyBTICsgXCInIHJlYWQgXCIgKyB1ICsgXCIgbW9yZSBieXRlcyB0aGFuIHRoZSBpbmRpY2F0ZWQgYm94IGRhdGEgc2l6ZSwgc2Vla2luZyBiYWNrd2FyZHNcIiksIHMuc2l6ZSAhPT0gMCAmJiB0LnNlZWsocy5zdGFydCArIHMuc2l6ZSkpLCB7IGNvZGU6IG4uT0ssIGJveDogcywgc2l6ZTogcy5zaXplIH0pO1xuICB9LCBuLkJveC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50eXBlICE9IFwibWRhdFwiID8gdGhpcy5kYXRhID0gdC5yZWFkVWludDhBcnJheSh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKSA6IHRoaXMuc2l6ZSA9PT0gMCA/IHQuc2Vlayh0LmdldEVuZFBvc2l0aW9uKCkpIDogdC5zZWVrKHRoaXMuc3RhcnQgKyB0aGlzLnNpemUpO1xuICB9LCBuLkJveC5wcm90b3R5cGUucGFyc2VEYXRhQW5kUmV3aW5kID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuZGF0YSA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSksIHQucG9zaXRpb24gLT0gdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZTtcbiAgfSwgbi5GdWxsQm94LnByb3RvdHlwZS5wYXJzZURhdGFBbmRSZXdpbmQgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wYXJzZUZ1bGxIZWFkZXIodCksIHRoaXMuZGF0YSA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSksIHRoaXMuaGRyX3NpemUgLT0gNCwgdC5wb3NpdGlvbiAtPSB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplO1xuICB9LCBuLkZ1bGxCb3gucHJvdG90eXBlLnBhcnNlRnVsbEhlYWRlciA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSB0LnJlYWRVaW50OCgpLCB0aGlzLmZsYWdzID0gdC5yZWFkVWludDI0KCksIHRoaXMuaGRyX3NpemUgKz0gNDtcbiAgfSwgbi5GdWxsQm94LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlRnVsbEhlYWRlcih0KSwgdGhpcy5kYXRhID0gdC5yZWFkVWludDhBcnJheSh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKTtcbiAgfSwgbi5Db250YWluZXJCb3gucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUsIGk7IHQuZ2V0UG9zaXRpb24oKSA8IHRoaXMuc3RhcnQgKyB0aGlzLnNpemU7IClcbiAgICAgIGlmIChlID0gbi5wYXJzZU9uZUJveCh0LCAhMSwgdGhpcy5zaXplIC0gKHQuZ2V0UG9zaXRpb24oKSAtIHRoaXMuc3RhcnQpKSwgZS5jb2RlID09PSBuLk9LKVxuICAgICAgICBpZiAoaSA9IGUuYm94LCB0aGlzLmJveGVzLnB1c2goaSksIHRoaXMuc3ViQm94TmFtZXMgJiYgdGhpcy5zdWJCb3hOYW1lcy5pbmRleE9mKGkudHlwZSkgIT0gLTEpXG4gICAgICAgICAgdGhpc1t0aGlzLnN1YkJveE5hbWVzW3RoaXMuc3ViQm94TmFtZXMuaW5kZXhPZihpLnR5cGUpXSArIFwic1wiXS5wdXNoKGkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcyA9IGkudHlwZSAhPT0gXCJ1dWlkXCIgPyBpLnR5cGUgOiBpLnV1aWQ7XG4gICAgICAgICAgdGhpc1tzXSA/IHIud2FybihcIkJveCBvZiB0eXBlIFwiICsgcyArIFwiIGFscmVhZHkgc3RvcmVkIGluIGZpZWxkIG9mIHRoaXMgdHlwZVwiKSA6IHRoaXNbc10gPSBpO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgfSwgbi5Cb3gucHJvdG90eXBlLnBhcnNlTGFuZ3VhZ2UgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5sYW5ndWFnZSA9IHQucmVhZFVpbnQxNigpO1xuICAgIHZhciBlID0gW107XG4gICAgZVswXSA9IHRoaXMubGFuZ3VhZ2UgPj4gMTAgJiAzMSwgZVsxXSA9IHRoaXMubGFuZ3VhZ2UgPj4gNSAmIDMxLCBlWzJdID0gdGhpcy5sYW5ndWFnZSAmIDMxLCB0aGlzLmxhbmd1YWdlU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZShlWzBdICsgOTYsIGVbMV0gKyA5NiwgZVsyXSArIDk2KTtcbiAgfSwgbi5TQU1QTEVfRU5UUllfVFlQRV9WSVNVQUwgPSBcIlZpc3VhbFwiLCBuLlNBTVBMRV9FTlRSWV9UWVBFX0FVRElPID0gXCJBdWRpb1wiLCBuLlNBTVBMRV9FTlRSWV9UWVBFX0hJTlQgPSBcIkhpbnRcIiwgbi5TQU1QTEVfRU5UUllfVFlQRV9NRVRBREFUQSA9IFwiTWV0YWRhdGFcIiwgbi5TQU1QTEVfRU5UUllfVFlQRV9TVUJUSVRMRSA9IFwiU3VidGl0bGVcIiwgbi5TQU1QTEVfRU5UUllfVFlQRV9TWVNURU0gPSBcIlN5c3RlbVwiLCBuLlNBTVBMRV9FTlRSWV9UWVBFX1RFWFQgPSBcIlRleHRcIiwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUucGFyc2VIZWFkZXIgPSBmdW5jdGlvbih0KSB7XG4gICAgdC5yZWFkVWludDhBcnJheSg2KSwgdGhpcy5kYXRhX3JlZmVyZW5jZV9pbmRleCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmhkcl9zaXplICs9IDg7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIodCksIHRoaXMuZGF0YSA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSk7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLnBhcnNlRGF0YUFuZFJld2luZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlSGVhZGVyKHQpLCB0aGlzLmRhdGEgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpLCB0aGlzLmhkcl9zaXplIC09IDgsIHQucG9zaXRpb24gLT0gdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZTtcbiAgfSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUucGFyc2VGb290ZXIgPSBmdW5jdGlvbih0KSB7XG4gICAgbi5Db250YWluZXJCb3gucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgdCk7XG4gIH0sIG4uY3JlYXRlTWVkaWFTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9ISU5UKSwgbi5jcmVhdGVNZWRpYVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX01FVEFEQVRBKSwgbi5jcmVhdGVNZWRpYVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1NVQlRJVExFKSwgbi5jcmVhdGVNZWRpYVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1NZU1RFTSksIG4uY3JlYXRlTWVkaWFTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9URVhUKSwgbi5jcmVhdGVNZWRpYVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMucGFyc2VIZWFkZXIodCksIHQucmVhZFVpbnQxNigpLCB0LnJlYWRVaW50MTYoKSwgdC5yZWFkVWludDMyQXJyYXkoMyksIHRoaXMud2lkdGggPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5oZWlnaHQgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5ob3JpenJlc29sdXRpb24gPSB0LnJlYWRVaW50MzIoKSwgdGhpcy52ZXJ0cmVzb2x1dGlvbiA9IHQucmVhZFVpbnQzMigpLCB0LnJlYWRVaW50MzIoKSwgdGhpcy5mcmFtZV9jb3VudCA9IHQucmVhZFVpbnQxNigpLCBlID0gTWF0aC5taW4oMzEsIHQucmVhZFVpbnQ4KCkpLCB0aGlzLmNvbXByZXNzb3JuYW1lID0gdC5yZWFkU3RyaW5nKGUpLCBlIDwgMzEgJiYgdC5yZWFkU3RyaW5nKDMxIC0gZSksIHRoaXMuZGVwdGggPSB0LnJlYWRVaW50MTYoKSwgdC5yZWFkVWludDE2KCksIHRoaXMucGFyc2VGb290ZXIodCk7XG4gIH0pLCBuLmNyZWF0ZU1lZGlhU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfQVVESU8sIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlSGVhZGVyKHQpLCB0LnJlYWRVaW50MzJBcnJheSgyKSwgdGhpcy5jaGFubmVsX2NvdW50ID0gdC5yZWFkVWludDE2KCksIHRoaXMuc2FtcGxlc2l6ZSA9IHQucmVhZFVpbnQxNigpLCB0LnJlYWRVaW50MTYoKSwgdC5yZWFkVWludDE2KCksIHRoaXMuc2FtcGxlcmF0ZSA9IHQucmVhZFVpbnQzMigpIC8gNjU1MzYsIHRoaXMucGFyc2VGb290ZXIodCk7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJhdmMxXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJhdmMyXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJhdmMzXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJhdmM0XCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJhdjAxXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJodmMxXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJoZXYxXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJ2dmMxXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJ2dmkxXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJ2dnMxXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJ2dmNOXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJ2cDA4XCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJ2cDA5XCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX0FVRElPLCBcIm1wNGFcIiksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfQVVESU8sIFwiYWMtM1wiKSwgbi5jcmVhdGVTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9BVURJTywgXCJlYy0zXCIpLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX0FVRElPLCBcIk9wdXNcIiksIG4uY3JlYXRlRW5jcnlwdGVkU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImVuY3ZcIiksIG4uY3JlYXRlRW5jcnlwdGVkU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfQVVESU8sIFwiZW5jYVwiKSwgbi5jcmVhdGVFbmNyeXB0ZWRTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9TVUJUSVRMRSwgXCJlbmN1XCIpLCBuLmNyZWF0ZUVuY3J5cHRlZFNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1NZU1RFTSwgXCJlbmNzXCIpLCBuLmNyZWF0ZUVuY3J5cHRlZFNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1RFWFQsIFwiZW5jdFwiKSwgbi5jcmVhdGVFbmNyeXB0ZWRTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9NRVRBREFUQSwgXCJlbmNtXCIpLCBuLmNyZWF0ZUJveEN0b3IoXCJhMWx4XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCkgJiAxLCBpID0gKChlICYgMSkgKyAxKSAqIDE2O1xuICAgIHRoaXMubGF5ZXJfc2l6ZSA9IFtdO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgMzsgcysrKVxuICAgICAgaSA9PSAxNiA/IHRoaXMubGF5ZXJfc2l6ZVtzXSA9IHQucmVhZFVpbnQxNigpIDogdGhpcy5sYXllcl9zaXplW3NdID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJhMW9wXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLm9wX2luZGV4ID0gdC5yZWFkVWludDgoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJhdXhDXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmF1eF90eXBlID0gdC5yZWFkQ1N0cmluZygpO1xuICAgIHZhciBlID0gdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSAtICh0aGlzLmF1eF90eXBlLmxlbmd0aCArIDEpO1xuICAgIHRoaXMuYXV4X3N1YnR5cGUgPSB0LnJlYWRVaW50OEFycmF5KGUpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiYXYxQ1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50OCgpO1xuICAgIGlmIChlID4+IDcgJiAhMSkge1xuICAgICAgci5lcnJvcihcImF2MUMgbWFya2VyIHByb2JsZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnZlcnNpb24gPSBlICYgMTI3LCB0aGlzLnZlcnNpb24gIT09IDEpIHtcbiAgICAgIHIuZXJyb3IoXCJhdjFDIHZlcnNpb24gXCIgKyB0aGlzLnZlcnNpb24gKyBcIiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuc2VxX3Byb2ZpbGUgPSBlID4+IDUgJiA3LCB0aGlzLnNlcV9sZXZlbF9pZHhfMCA9IGUgJiAzMSwgZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuc2VxX3RpZXJfMCA9IGUgPj4gNyAmIDEsIHRoaXMuaGlnaF9iaXRkZXB0aCA9IGUgPj4gNiAmIDEsIHRoaXMudHdlbHZlX2JpdCA9IGUgPj4gNSAmIDEsIHRoaXMubW9ub2Nocm9tZSA9IGUgPj4gNCAmIDEsIHRoaXMuY2hyb21hX3N1YnNhbXBsaW5nX3ggPSBlID4+IDMgJiAxLCB0aGlzLmNocm9tYV9zdWJzYW1wbGluZ195ID0gZSA+PiAyICYgMSwgdGhpcy5jaHJvbWFfc2FtcGxlX3Bvc2l0aW9uID0gZSAmIDMsIGUgPSB0LnJlYWRVaW50OCgpLCB0aGlzLnJlc2VydmVkXzEgPSBlID4+IDUgJiA3LCB0aGlzLnJlc2VydmVkXzEgIT09IDApIHtcbiAgICAgIHIuZXJyb3IoXCJhdjFDIHJlc2VydmVkXzEgcGFyc2luZyBwcm9ibGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbml0aWFsX3ByZXNlbnRhdGlvbl9kZWxheV9wcmVzZW50ID0gZSA+PiA0ICYgMSwgdGhpcy5pbml0aWFsX3ByZXNlbnRhdGlvbl9kZWxheV9wcmVzZW50ID09PSAxKVxuICAgICAgdGhpcy5pbml0aWFsX3ByZXNlbnRhdGlvbl9kZWxheV9taW51c19vbmUgPSBlICYgMTU7XG4gICAgZWxzZSBpZiAodGhpcy5yZXNlcnZlZF8yID0gZSAmIDE1LCB0aGlzLnJlc2VydmVkXzIgIT09IDApIHtcbiAgICAgIHIuZXJyb3IoXCJhdjFDIHJlc2VydmVkXzIgcGFyc2luZyBwcm9ibGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgLSA0O1xuICAgIHRoaXMuY29uZmlnT0JVcyA9IHQucmVhZFVpbnQ4QXJyYXkoaSk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJhdmNDXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaTtcbiAgICBmb3IgKHRoaXMuY29uZmlndXJhdGlvblZlcnNpb24gPSB0LnJlYWRVaW50OCgpLCB0aGlzLkFWQ1Byb2ZpbGVJbmRpY2F0aW9uID0gdC5yZWFkVWludDgoKSwgdGhpcy5wcm9maWxlX2NvbXBhdGliaWxpdHkgPSB0LnJlYWRVaW50OCgpLCB0aGlzLkFWQ0xldmVsSW5kaWNhdGlvbiA9IHQucmVhZFVpbnQ4KCksIHRoaXMubGVuZ3RoU2l6ZU1pbnVzT25lID0gdC5yZWFkVWludDgoKSAmIDMsIHRoaXMubmJfU1BTX25hbHVzID0gdC5yZWFkVWludDgoKSAmIDMxLCBpID0gdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSAtIDYsIHRoaXMuU1BTID0gW10sIGUgPSAwOyBlIDwgdGhpcy5uYl9TUFNfbmFsdXM7IGUrKylcbiAgICAgIHRoaXMuU1BTW2VdID0ge30sIHRoaXMuU1BTW2VdLmxlbmd0aCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLlNQU1tlXS5uYWx1ID0gdC5yZWFkVWludDhBcnJheSh0aGlzLlNQU1tlXS5sZW5ndGgpLCBpIC09IDIgKyB0aGlzLlNQU1tlXS5sZW5ndGg7XG4gICAgZm9yICh0aGlzLm5iX1BQU19uYWx1cyA9IHQucmVhZFVpbnQ4KCksIGktLSwgdGhpcy5QUFMgPSBbXSwgZSA9IDA7IGUgPCB0aGlzLm5iX1BQU19uYWx1czsgZSsrKVxuICAgICAgdGhpcy5QUFNbZV0gPSB7fSwgdGhpcy5QUFNbZV0ubGVuZ3RoID0gdC5yZWFkVWludDE2KCksIHRoaXMuUFBTW2VdLm5hbHUgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuUFBTW2VdLmxlbmd0aCksIGkgLT0gMiArIHRoaXMuUFBTW2VdLmxlbmd0aDtcbiAgICBpID4gMCAmJiAodGhpcy5leHQgPSB0LnJlYWRVaW50OEFycmF5KGkpKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImJ0cnRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuYnVmZmVyU2l6ZURCID0gdC5yZWFkVWludDMyKCksIHRoaXMubWF4Qml0cmF0ZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmF2Z0JpdHJhdGUgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImNsYXBcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuY2xlYW5BcGVydHVyZVdpZHRoTiA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmNsZWFuQXBlcnR1cmVXaWR0aEQgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5jbGVhbkFwZXJ0dXJlSGVpZ2h0TiA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmNsZWFuQXBlcnR1cmVIZWlnaHREID0gdC5yZWFkVWludDMyKCksIHRoaXMuaG9yaXpPZmZOID0gdC5yZWFkVWludDMyKCksIHRoaXMuaG9yaXpPZmZEID0gdC5yZWFkVWludDMyKCksIHRoaXMudmVydE9mZk4gPSB0LnJlYWRVaW50MzIoKSwgdGhpcy52ZXJ0T2ZmRCA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiY2xsaVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5tYXhfY29udGVudF9saWdodF9sZXZlbCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLm1heF9waWNfYXZlcmFnZV9saWdodF9sZXZlbCA9IHQucmVhZFVpbnQxNigpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImNvNjRcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpO1xuICAgIGlmIChlID0gdC5yZWFkVWludDMyKCksIHRoaXMuY2h1bmtfb2Zmc2V0cyA9IFtdLCB0aGlzLnZlcnNpb24gPT09IDApXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgICAgICB0aGlzLmNodW5rX29mZnNldHMucHVzaCh0LnJlYWRVaW50NjQoKSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiQ29MTFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5tYXhDTEwgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5tYXhGQUxMID0gdC5yZWFkVWludDE2KCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJjb2xyXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodGhpcy5jb2xvdXJfdHlwZSA9IHQucmVhZFN0cmluZyg0KSwgdGhpcy5jb2xvdXJfdHlwZSA9PT0gXCJuY2x4XCIpIHtcbiAgICAgIHRoaXMuY29sb3VyX3ByaW1hcmllcyA9IHQucmVhZFVpbnQxNigpLCB0aGlzLnRyYW5zZmVyX2NoYXJhY3RlcmlzdGljcyA9IHQucmVhZFVpbnQxNigpLCB0aGlzLm1hdHJpeF9jb2VmZmljaWVudHMgPSB0LnJlYWRVaW50MTYoKTtcbiAgICAgIHZhciBlID0gdC5yZWFkVWludDgoKTtcbiAgICAgIHRoaXMuZnVsbF9yYW5nZV9mbGFnID0gZSA+PiA3O1xuICAgIH0gZWxzZSB0aGlzLmNvbG91cl90eXBlID09PSBcInJJQ0NcIiA/IHRoaXMuSUNDX3Byb2ZpbGUgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZSAtIDQpIDogdGhpcy5jb2xvdXJfdHlwZSA9PT0gXCJwcm9mXCIgJiYgKHRoaXMuSUNDX3Byb2ZpbGUgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZSAtIDQpKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJjcHJ0XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlTGFuZ3VhZ2UodCksIHRoaXMubm90aWNlID0gdC5yZWFkQ1N0cmluZygpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImNzbGdcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9PT0gMCAmJiAodGhpcy5jb21wb3NpdGlvblRvRFRTU2hpZnQgPSB0LnJlYWRJbnQzMigpLCB0aGlzLmxlYXN0RGVjb2RlVG9EaXNwbGF5RGVsdGEgPSB0LnJlYWRJbnQzMigpLCB0aGlzLmdyZWF0ZXN0RGVjb2RlVG9EaXNwbGF5RGVsdGEgPSB0LnJlYWRJbnQzMigpLCB0aGlzLmNvbXBvc2l0aW9uU3RhcnRUaW1lID0gdC5yZWFkSW50MzIoKSwgdGhpcy5jb21wb3NpdGlvbkVuZFRpbWUgPSB0LnJlYWRJbnQzMigpKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJjdHRzXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaTtcbiAgICBpZiAoZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnNhbXBsZV9jb3VudHMgPSBbXSwgdGhpcy5zYW1wbGVfb2Zmc2V0cyA9IFtdLCB0aGlzLnZlcnNpb24gPT09IDApXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZTsgaSsrKSB7XG4gICAgICAgIHRoaXMuc2FtcGxlX2NvdW50cy5wdXNoKHQucmVhZFVpbnQzMigpKTtcbiAgICAgICAgdmFyIHMgPSB0LnJlYWRJbnQzMigpO1xuICAgICAgICBzIDwgMCAmJiByLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJjdHRzIGJveCB1c2VzIG5lZ2F0aXZlIHZhbHVlcyB3aXRob3V0IHVzaW5nIHZlcnNpb24gMVwiKSwgdGhpcy5zYW1wbGVfb2Zmc2V0cy5wdXNoKHMpO1xuICAgICAgfVxuICAgIGVsc2UgaWYgKHRoaXMudmVyc2lvbiA9PSAxKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgICAgdGhpcy5zYW1wbGVfY291bnRzLnB1c2godC5yZWFkVWludDMyKCkpLCB0aGlzLnNhbXBsZV9vZmZzZXRzLnB1c2godC5yZWFkSW50MzIoKSk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJkYWMzXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCksIGkgPSB0LnJlYWRVaW50OCgpLCBzID0gdC5yZWFkVWludDgoKTtcbiAgICB0aGlzLmZzY29kID0gZSA+PiA2LCB0aGlzLmJzaWQgPSBlID4+IDEgJiAzMSwgdGhpcy5ic21vZCA9IChlICYgMSkgPDwgMiB8IGkgPj4gNiAmIDMsIHRoaXMuYWNtb2QgPSBpID4+IDMgJiA3LCB0aGlzLmxmZW9uID0gaSA+PiAyICYgMSwgdGhpcy5iaXRfcmF0ZV9jb2RlID0gaSAmIDMgfCBzID4+IDUgJiA3O1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiZGVjM1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50MTYoKTtcbiAgICB0aGlzLmRhdGFfcmF0ZSA9IGUgPj4gMywgdGhpcy5udW1faW5kX3N1YiA9IGUgJiA3LCB0aGlzLmluZF9zdWJzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bV9pbmRfc3ViICsgMTsgaSsrKSB7XG4gICAgICB2YXIgcyA9IHt9O1xuICAgICAgdGhpcy5pbmRfc3Vicy5wdXNoKHMpO1xuICAgICAgdmFyIG8gPSB0LnJlYWRVaW50OCgpLCBjID0gdC5yZWFkVWludDgoKSwgdSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgICBzLmZzY29kID0gbyA+PiA2LCBzLmJzaWQgPSBvID4+IDEgJiAzMSwgcy5ic21vZCA9IChvICYgMSkgPDwgNCB8IGMgPj4gNCAmIDE1LCBzLmFjbW9kID0gYyA+PiAxICYgNywgcy5sZmVvbiA9IGMgJiAxLCBzLm51bV9kZXBfc3ViID0gdSA+PiAxICYgMTUsIHMubnVtX2RlcF9zdWIgPiAwICYmIChzLmNoYW5fbG9jID0gKHUgJiAxKSA8PCA4IHwgdC5yZWFkVWludDgoKSk7XG4gICAgfVxuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImRmTGFcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gMTI3LCBpID0gMTI4LCBzID0gW10sIG8gPSBbXG4gICAgICBcIlNUUkVBTUlORk9cIixcbiAgICAgIFwiUEFERElOR1wiLFxuICAgICAgXCJBUFBMSUNBVElPTlwiLFxuICAgICAgXCJTRUVLVEFCTEVcIixcbiAgICAgIFwiVk9SQklTX0NPTU1FTlRcIixcbiAgICAgIFwiQ1VFU0hFRVRcIixcbiAgICAgIFwiUElDVFVSRVwiLFxuICAgICAgXCJSRVNFUlZFRFwiXG4gICAgXTtcbiAgICB0aGlzLnBhcnNlRnVsbEhlYWRlcih0KTtcbiAgICBkbyB7XG4gICAgICB2YXIgYyA9IHQucmVhZFVpbnQ4KCksIHUgPSBNYXRoLm1pbihcbiAgICAgICAgYyAmIGUsXG4gICAgICAgIG8ubGVuZ3RoIC0gMVxuICAgICAgKTtcbiAgICAgIGlmICh1ID8gdC5yZWFkVWludDhBcnJheSh0LnJlYWRVaW50MjQoKSkgOiAodC5yZWFkVWludDhBcnJheSgxMyksIHRoaXMuc2FtcGxlcmF0ZSA9IHQucmVhZFVpbnQzMigpID4+IDEyLCB0LnJlYWRVaW50OEFycmF5KDIwKSksIHMucHVzaChvW3VdKSwgYyAmIGkpXG4gICAgICAgIGJyZWFrO1xuICAgIH0gd2hpbGUgKCEwKTtcbiAgICB0aGlzLm51bU1ldGFkYXRhQmxvY2tzID0gcy5sZW5ndGggKyBcIiAoXCIgKyBzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiZGltbVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5ieXRlc3NlbnQgPSB0LnJlYWRVaW50NjQoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImRtYXhcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGltZSA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiZG1lZFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5ieXRlc3NlbnQgPSB0LnJlYWRVaW50NjQoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImRPcHNcIiwgZnVuY3Rpb24odCkge1xuICAgIGlmICh0aGlzLlZlcnNpb24gPSB0LnJlYWRVaW50OCgpLCB0aGlzLk91dHB1dENoYW5uZWxDb3VudCA9IHQucmVhZFVpbnQ4KCksIHRoaXMuUHJlU2tpcCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLklucHV0U2FtcGxlUmF0ZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLk91dHB1dEdhaW4gPSB0LnJlYWRJbnQxNigpLCB0aGlzLkNoYW5uZWxNYXBwaW5nRmFtaWx5ID0gdC5yZWFkVWludDgoKSwgdGhpcy5DaGFubmVsTWFwcGluZ0ZhbWlseSAhPT0gMCkge1xuICAgICAgdGhpcy5TdHJlYW1Db3VudCA9IHQucmVhZFVpbnQ4KCksIHRoaXMuQ291cGxlZENvdW50ID0gdC5yZWFkVWludDgoKSwgdGhpcy5DaGFubmVsTWFwcGluZyA9IFtdO1xuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLk91dHB1dENoYW5uZWxDb3VudDsgZSsrKVxuICAgICAgICB0aGlzLkNoYW5uZWxNYXBwaW5nW2VdID0gdC5yZWFkVWludDgoKTtcbiAgICB9XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiZHJlZlwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGk7XG4gICAgdGhpcy5lbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgcyA9IHQucmVhZFVpbnQzMigpLCBvID0gMDsgbyA8IHM7IG8rKylcbiAgICAgIGlmIChlID0gbi5wYXJzZU9uZUJveCh0LCAhMSwgdGhpcy5zaXplIC0gKHQuZ2V0UG9zaXRpb24oKSAtIHRoaXMuc3RhcnQpKSwgZS5jb2RlID09PSBuLk9LKVxuICAgICAgICBpID0gZS5ib3gsIHRoaXMuZW50cmllcy5wdXNoKGkpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm47XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJkcmVwXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmJ5dGVzc2VudCA9IHQucmVhZFVpbnQ2NCgpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImVsbmdcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuZXh0ZW5kZWRfbGFuZ3VhZ2UgPSB0LnJlYWRTdHJpbmcodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiZWxzdFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5lbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgZSA9IHQucmVhZFVpbnQzMigpLCBpID0gMDsgaSA8IGU7IGkrKykge1xuICAgICAgdmFyIHMgPSB7fTtcbiAgICAgIHRoaXMuZW50cmllcy5wdXNoKHMpLCB0aGlzLnZlcnNpb24gPT09IDEgPyAocy5zZWdtZW50X2R1cmF0aW9uID0gdC5yZWFkVWludDY0KCksIHMubWVkaWFfdGltZSA9IHQucmVhZEludDY0KCkpIDogKHMuc2VnbWVudF9kdXJhdGlvbiA9IHQucmVhZFVpbnQzMigpLCBzLm1lZGlhX3RpbWUgPSB0LnJlYWRJbnQzMigpKSwgcy5tZWRpYV9yYXRlX2ludGVnZXIgPSB0LnJlYWRJbnQxNigpLCBzLm1lZGlhX3JhdGVfZnJhY3Rpb24gPSB0LnJlYWRJbnQxNigpO1xuICAgIH1cbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJlbXNnXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPT0gMSA/ICh0aGlzLnRpbWVzY2FsZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnByZXNlbnRhdGlvbl90aW1lID0gdC5yZWFkVWludDY0KCksIHRoaXMuZXZlbnRfZHVyYXRpb24gPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5pZCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnNjaGVtZV9pZF91cmkgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMudmFsdWUgPSB0LnJlYWRDU3RyaW5nKCkpIDogKHRoaXMuc2NoZW1lX2lkX3VyaSA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy52YWx1ZSA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy50aW1lc2NhbGUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5wcmVzZW50YXRpb25fdGltZV9kZWx0YSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmV2ZW50X2R1cmF0aW9uID0gdC5yZWFkVWludDMyKCksIHRoaXMuaWQgPSB0LnJlYWRVaW50MzIoKSk7XG4gICAgdmFyIGUgPSB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gKDQgKiA0ICsgKHRoaXMuc2NoZW1lX2lkX3VyaS5sZW5ndGggKyAxKSArICh0aGlzLnZhbHVlLmxlbmd0aCArIDEpKTtcbiAgICB0aGlzLnZlcnNpb24gPT0gMSAmJiAoZSAtPSA0KSwgdGhpcy5tZXNzYWdlX2RhdGEgPSB0LnJlYWRVaW50OEFycmF5KGUpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImVzZHNcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5yZWFkVWludDhBcnJheSh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKTtcbiAgICBpZiAodHlwZW9mIHAgPCBcInVcIikge1xuICAgICAgdmFyIGkgPSBuZXcgcCgpO1xuICAgICAgdGhpcy5lc2QgPSBpLnBhcnNlT25lRGVzY3JpcHRvcihuZXcgYShlLmJ1ZmZlciwgMCwgYS5CSUdfRU5ESUFOKSk7XG4gICAgfVxuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiZmllbFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5maWVsZENvdW50ID0gdC5yZWFkVWludDgoKSwgdGhpcy5maWVsZE9yZGVyaW5nID0gdC5yZWFkVWludDgoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcImZybWFcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuZGF0YV9mb3JtYXQgPSB0LnJlYWRTdHJpbmcoNCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJmdHlwXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemU7XG4gICAgdGhpcy5tYWpvcl9icmFuZCA9IHQucmVhZFN0cmluZyg0KSwgdGhpcy5taW5vcl92ZXJzaW9uID0gdC5yZWFkVWludDMyKCksIGUgLT0gOCwgdGhpcy5jb21wYXRpYmxlX2JyYW5kcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBlID49IDQ7IClcbiAgICAgIHRoaXMuY29tcGF0aWJsZV9icmFuZHNbaV0gPSB0LnJlYWRTdHJpbmcoNCksIGUgLT0gNCwgaSsrO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImhkbHJcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9PT0gMCAmJiAodC5yZWFkVWludDMyKCksIHRoaXMuaGFuZGxlciA9IHQucmVhZFN0cmluZyg0KSwgdC5yZWFkVWludDMyQXJyYXkoMyksIHRoaXMubmFtZSA9IHQucmVhZFN0cmluZyh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gMjApLCB0aGlzLm5hbWVbdGhpcy5uYW1lLmxlbmd0aCAtIDFdID09PSBcIlxcMFwiICYmICh0aGlzLm5hbWUgPSB0aGlzLm5hbWUuc2xpY2UoMCwgLTEpKSk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJodmNDXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSwgcywgbztcbiAgICB0aGlzLmNvbmZpZ3VyYXRpb25WZXJzaW9uID0gdC5yZWFkVWludDgoKSwgbyA9IHQucmVhZFVpbnQ4KCksIHRoaXMuZ2VuZXJhbF9wcm9maWxlX3NwYWNlID0gbyA+PiA2LCB0aGlzLmdlbmVyYWxfdGllcl9mbGFnID0gKG8gJiAzMikgPj4gNSwgdGhpcy5nZW5lcmFsX3Byb2ZpbGVfaWRjID0gbyAmIDMxLCB0aGlzLmdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5ID0gdC5yZWFkVWludDMyKCksIHRoaXMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvciA9IHQucmVhZFVpbnQ4QXJyYXkoNiksIHRoaXMuZ2VuZXJhbF9sZXZlbF9pZGMgPSB0LnJlYWRVaW50OCgpLCB0aGlzLm1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMgPSB0LnJlYWRVaW50MTYoKSAmIDQwOTUsIHRoaXMucGFyYWxsZWxpc21UeXBlID0gdC5yZWFkVWludDgoKSAmIDMsIHRoaXMuY2hyb21hX2Zvcm1hdF9pZGMgPSB0LnJlYWRVaW50OCgpICYgMywgdGhpcy5iaXRfZGVwdGhfbHVtYV9taW51czggPSB0LnJlYWRVaW50OCgpICYgNywgdGhpcy5iaXRfZGVwdGhfY2hyb21hX21pbnVzOCA9IHQucmVhZFVpbnQ4KCkgJiA3LCB0aGlzLmF2Z0ZyYW1lUmF0ZSA9IHQucmVhZFVpbnQxNigpLCBvID0gdC5yZWFkVWludDgoKSwgdGhpcy5jb25zdGFudEZyYW1lUmF0ZSA9IG8gPj4gNiwgdGhpcy5udW1UZW1wb3JhbExheWVycyA9IChvICYgMTMpID4+IDMsIHRoaXMudGVtcG9yYWxJZE5lc3RlZCA9IChvICYgNCkgPj4gMiwgdGhpcy5sZW5ndGhTaXplTWludXNPbmUgPSBvICYgMywgdGhpcy5uYWx1X2FycmF5cyA9IFtdO1xuICAgIHZhciBjID0gdC5yZWFkVWludDgoKTtcbiAgICBmb3IgKGUgPSAwOyBlIDwgYzsgZSsrKSB7XG4gICAgICB2YXIgdSA9IFtdO1xuICAgICAgdGhpcy5uYWx1X2FycmF5cy5wdXNoKHUpLCBvID0gdC5yZWFkVWludDgoKSwgdS5jb21wbGV0ZW5lc3MgPSAobyAmIDEyOCkgPj4gNywgdS5uYWx1X3R5cGUgPSBvICYgNjM7XG4gICAgICB2YXIgXyA9IHQucmVhZFVpbnQxNigpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IF87IGkrKykge1xuICAgICAgICB2YXIgZyA9IHt9O1xuICAgICAgICB1LnB1c2goZyksIHMgPSB0LnJlYWRVaW50MTYoKSwgZy5kYXRhID0gdC5yZWFkVWludDhBcnJheShzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiaWluZlwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy52ZXJzaW9uID09PSAwID8gdGhpcy5lbnRyeV9jb3VudCA9IHQucmVhZFVpbnQxNigpIDogdGhpcy5lbnRyeV9jb3VudCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLml0ZW1faW5mb3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cnlfY291bnQ7IGkrKylcbiAgICAgIGlmIChlID0gbi5wYXJzZU9uZUJveCh0LCAhMSwgdGhpcy5zaXplIC0gKHQuZ2V0UG9zaXRpb24oKSAtIHRoaXMuc3RhcnQpKSwgZS5jb2RlID09PSBuLk9LKVxuICAgICAgICBlLmJveC50eXBlICE9PSBcImluZmVcIiAmJiByLmVycm9yKFwiQm94UGFyc2VyXCIsIFwiRXhwZWN0ZWQgJ2luZmUnIGJveCwgZ290IFwiICsgZS5ib3gudHlwZSksIHRoaXMuaXRlbV9pbmZvc1tpXSA9IGUuYm94O1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm47XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiaWxvY1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMub2Zmc2V0X3NpemUgPSBlID4+IDQgJiAxNSwgdGhpcy5sZW5ndGhfc2l6ZSA9IGUgJiAxNSwgZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuYmFzZV9vZmZzZXRfc2l6ZSA9IGUgPj4gNCAmIDE1LCB0aGlzLnZlcnNpb24gPT09IDEgfHwgdGhpcy52ZXJzaW9uID09PSAyID8gdGhpcy5pbmRleF9zaXplID0gZSAmIDE1IDogdGhpcy5pbmRleF9zaXplID0gMCwgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy52ZXJzaW9uIDwgMilcbiAgICAgIGkgPSB0LnJlYWRVaW50MTYoKTtcbiAgICBlbHNlIGlmICh0aGlzLnZlcnNpb24gPT09IDIpXG4gICAgICBpID0gdC5yZWFkVWludDMyKCk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgXCJ2ZXJzaW9uIG9mIGlsb2MgYm94IG5vdCBzdXBwb3J0ZWRcIjtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IGk7IHMrKykge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIGlmICh0aGlzLml0ZW1zLnB1c2gobyksIHRoaXMudmVyc2lvbiA8IDIpXG4gICAgICAgIG8uaXRlbV9JRCA9IHQucmVhZFVpbnQxNigpO1xuICAgICAgZWxzZSBpZiAodGhpcy52ZXJzaW9uID09PSAyKVxuICAgICAgICBvLml0ZW1fSUQgPSB0LnJlYWRVaW50MTYoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgXCJ2ZXJzaW9uIG9mIGlsb2MgYm94IG5vdCBzdXBwb3J0ZWRcIjtcbiAgICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uID09PSAxIHx8IHRoaXMudmVyc2lvbiA9PT0gMiA/IG8uY29uc3RydWN0aW9uX21ldGhvZCA9IHQucmVhZFVpbnQxNigpICYgMTUgOiBvLmNvbnN0cnVjdGlvbl9tZXRob2QgPSAwLCBvLmRhdGFfcmVmZXJlbmNlX2luZGV4ID0gdC5yZWFkVWludDE2KCksIHRoaXMuYmFzZV9vZmZzZXRfc2l6ZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgby5iYXNlX29mZnNldCA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBvLmJhc2Vfb2Zmc2V0ID0gdC5yZWFkVWludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBvLmJhc2Vfb2Zmc2V0ID0gdC5yZWFkVWludDY0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgXCJFcnJvciByZWFkaW5nIGJhc2Ugb2Zmc2V0IHNpemVcIjtcbiAgICAgIH1cbiAgICAgIHZhciBjID0gdC5yZWFkVWludDE2KCk7XG4gICAgICBvLmV4dGVudHMgPSBbXTtcbiAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgYzsgdSsrKSB7XG4gICAgICAgIHZhciBfID0ge307XG4gICAgICAgIGlmIChvLmV4dGVudHMucHVzaChfKSwgdGhpcy52ZXJzaW9uID09PSAxIHx8IHRoaXMudmVyc2lvbiA9PT0gMilcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuaW5kZXhfc2l6ZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfLmV4dGVudF9pbmRleCA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBfLmV4dGVudF9pbmRleCA9IHQucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgXy5leHRlbnRfaW5kZXggPSB0LnJlYWRVaW50NjQoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBcIkVycm9yIHJlYWRpbmcgZXh0ZW50IGluZGV4XCI7XG4gICAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMub2Zmc2V0X3NpemUpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfLmV4dGVudF9vZmZzZXQgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgXy5leHRlbnRfb2Zmc2V0ID0gdC5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfLmV4dGVudF9vZmZzZXQgPSB0LnJlYWRVaW50NjQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBcIkVycm9yIHJlYWRpbmcgZXh0ZW50IGluZGV4XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLmxlbmd0aF9zaXplKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgXy5leHRlbnRfbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF8uZXh0ZW50X2xlbmd0aCA9IHQucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgXy5leHRlbnRfbGVuZ3RoID0gdC5yZWFkVWludDY0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgXCJFcnJvciByZWFkaW5nIGV4dGVudCBpbmRleFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiaW1pclwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50OCgpO1xuICAgIHRoaXMucmVzZXJ2ZWQgPSBlID4+IDcsIHRoaXMuYXhpcyA9IGUgJiAxO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImluZmVcIiwgZnVuY3Rpb24odCkge1xuICAgIGlmICgodGhpcy52ZXJzaW9uID09PSAwIHx8IHRoaXMudmVyc2lvbiA9PT0gMSkgJiYgKHRoaXMuaXRlbV9JRCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLml0ZW1fcHJvdGVjdGlvbl9pbmRleCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLml0ZW1fbmFtZSA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5jb250ZW50X3R5cGUgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMuY29udGVudF9lbmNvZGluZyA9IHQucmVhZENTdHJpbmcoKSksIHRoaXMudmVyc2lvbiA9PT0gMSkge1xuICAgICAgdGhpcy5leHRlbnNpb25fdHlwZSA9IHQucmVhZFN0cmluZyg0KSwgci53YXJuKFwiQm94UGFyc2VyXCIsIFwiQ2Fubm90IHBhcnNlIGV4dGVuc2lvbiB0eXBlXCIpLCB0LnNlZWsodGhpcy5zdGFydCArIHRoaXMuc2l6ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudmVyc2lvbiA+PSAyICYmICh0aGlzLnZlcnNpb24gPT09IDIgPyB0aGlzLml0ZW1fSUQgPSB0LnJlYWRVaW50MTYoKSA6IHRoaXMudmVyc2lvbiA9PT0gMyAmJiAodGhpcy5pdGVtX0lEID0gdC5yZWFkVWludDMyKCkpLCB0aGlzLml0ZW1fcHJvdGVjdGlvbl9pbmRleCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLml0ZW1fdHlwZSA9IHQucmVhZFN0cmluZyg0KSwgdGhpcy5pdGVtX25hbWUgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMuaXRlbV90eXBlID09PSBcIm1pbWVcIiA/ICh0aGlzLmNvbnRlbnRfdHlwZSA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5jb250ZW50X2VuY29kaW5nID0gdC5yZWFkQ1N0cmluZygpKSA6IHRoaXMuaXRlbV90eXBlID09PSBcInVyaSBcIiAmJiAodGhpcy5pdGVtX3VyaV90eXBlID0gdC5yZWFkQ1N0cmluZygpKSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiaXBtYVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGk7XG4gICAgZm9yIChlbnRyeV9jb3VudCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmFzc29jaWF0aW9ucyA9IFtdLCBlID0gMDsgZSA8IGVudHJ5X2NvdW50OyBlKyspIHtcbiAgICAgIHZhciBzID0ge307XG4gICAgICB0aGlzLmFzc29jaWF0aW9ucy5wdXNoKHMpLCB0aGlzLnZlcnNpb24gPCAxID8gcy5pZCA9IHQucmVhZFVpbnQxNigpIDogcy5pZCA9IHQucmVhZFVpbnQzMigpO1xuICAgICAgdmFyIG8gPSB0LnJlYWRVaW50OCgpO1xuICAgICAgZm9yIChzLnByb3BzID0gW10sIGkgPSAwOyBpIDwgbzsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gdC5yZWFkVWludDgoKSwgdSA9IHt9O1xuICAgICAgICBzLnByb3BzLnB1c2godSksIHUuZXNzZW50aWFsID0gKGMgJiAxMjgpID4+IDcgPT09IDEsIHRoaXMuZmxhZ3MgJiAxID8gdS5wcm9wZXJ0eV9pbmRleCA9IChjICYgMTI3KSA8PCA4IHwgdC5yZWFkVWludDgoKSA6IHUucHJvcGVydHlfaW5kZXggPSBjICYgMTI3O1xuICAgICAgfVxuICAgIH1cbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJpcmVmXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaTtcbiAgICBmb3IgKHRoaXMucmVmZXJlbmNlcyA9IFtdOyB0LmdldFBvc2l0aW9uKCkgPCB0aGlzLnN0YXJ0ICsgdGhpcy5zaXplOyApXG4gICAgICBpZiAoZSA9IG4ucGFyc2VPbmVCb3godCwgITAsIHRoaXMuc2l6ZSAtICh0LmdldFBvc2l0aW9uKCkgLSB0aGlzLnN0YXJ0KSksIGUuY29kZSA9PT0gbi5PSylcbiAgICAgICAgdGhpcy52ZXJzaW9uID09PSAwID8gaSA9IG5ldyBuLlNpbmdsZUl0ZW1UeXBlUmVmZXJlbmNlQm94KGUudHlwZSwgZS5zaXplLCBlLmhkcl9zaXplLCBlLnN0YXJ0KSA6IGkgPSBuZXcgbi5TaW5nbGVJdGVtVHlwZVJlZmVyZW5jZUJveExhcmdlKGUudHlwZSwgZS5zaXplLCBlLmhkcl9zaXplLCBlLnN0YXJ0KSwgaS53cml0ZSA9PT0gbi5Cb3gucHJvdG90eXBlLndyaXRlICYmIGkudHlwZSAhPT0gXCJtZGF0XCIgJiYgKHIud2FybihcIkJveFBhcnNlclwiLCBpLnR5cGUgKyBcIiBib3ggd3JpdGluZyBub3QgeWV0IGltcGxlbWVudGVkLCBrZWVwaW5nIHVucGFyc2VkIGRhdGEgaW4gbWVtb3J5IGZvciBsYXRlciB3cml0ZVwiKSwgaS5wYXJzZURhdGFBbmRSZXdpbmQodCkpLCBpLnBhcnNlKHQpLCB0aGlzLnJlZmVyZW5jZXMucHVzaChpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwiaXJvdFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5hbmdsZSA9IHQucmVhZFVpbnQ4KCkgJiAzO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImlzcGVcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuaW1hZ2Vfd2lkdGggPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5pbWFnZV9oZWlnaHQgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJraW5kXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNjaGVtZVVSSSA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy52YWx1ZSA9IHQucmVhZENTdHJpbmcoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJsZXZhXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5sZXZlbHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGU7IGkrKykge1xuICAgICAgdmFyIHMgPSB7fTtcbiAgICAgIHRoaXMubGV2ZWxzW2ldID0gcywgcy50cmFja19JRCA9IHQucmVhZFVpbnQzMigpO1xuICAgICAgdmFyIG8gPSB0LnJlYWRVaW50OCgpO1xuICAgICAgc3dpdGNoIChzLnBhZGRpbmdfZmxhZyA9IG8gPj4gNywgcy5hc3NpZ25tZW50X3R5cGUgPSBvICYgMTI3LCBzLmFzc2lnbm1lbnRfdHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcy5ncm91cGluZ190eXBlID0gdC5yZWFkU3RyaW5nKDQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcy5ncm91cGluZ190eXBlID0gdC5yZWFkU3RyaW5nKDQpLCBzLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyID0gdC5yZWFkVWludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcy5zdWJfdHJhY2tfaWQgPSB0LnJlYWRVaW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJVbmtub3duIGxldmEgYXNzaWduZW1lbnQgdHlwZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJsc2VsXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmxheWVyX2lkID0gdC5yZWFkVWludDE2KCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJtYXhyXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBlcmlvZCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmJ5dGVzID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJtZGN2XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmRpc3BsYXlfcHJpbWFyaWVzID0gW10sIHRoaXMuZGlzcGxheV9wcmltYXJpZXNbMF0gPSB7fSwgdGhpcy5kaXNwbGF5X3ByaW1hcmllc1swXS54ID0gdC5yZWFkVWludDE2KCksIHRoaXMuZGlzcGxheV9wcmltYXJpZXNbMF0ueSA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmRpc3BsYXlfcHJpbWFyaWVzWzFdID0ge30sIHRoaXMuZGlzcGxheV9wcmltYXJpZXNbMV0ueCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmRpc3BsYXlfcHJpbWFyaWVzWzFdLnkgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5kaXNwbGF5X3ByaW1hcmllc1syXSA9IHt9LCB0aGlzLmRpc3BsYXlfcHJpbWFyaWVzWzJdLnggPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5kaXNwbGF5X3ByaW1hcmllc1syXS55ID0gdC5yZWFkVWludDE2KCksIHRoaXMud2hpdGVfcG9pbnQgPSB7fSwgdGhpcy53aGl0ZV9wb2ludC54ID0gdC5yZWFkVWludDE2KCksIHRoaXMud2hpdGVfcG9pbnQueSA9IHQucmVhZFVpbnQxNigpLCB0aGlzLm1heF9kaXNwbGF5X21hc3RlcmluZ19sdW1pbmFuY2UgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5taW5fZGlzcGxheV9tYXN0ZXJpbmdfbHVtaW5hbmNlID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwibWRoZFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID09IDEgPyAodGhpcy5jcmVhdGlvbl90aW1lID0gdC5yZWFkVWludDY0KCksIHRoaXMubW9kaWZpY2F0aW9uX3RpbWUgPSB0LnJlYWRVaW50NjQoKSwgdGhpcy50aW1lc2NhbGUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5kdXJhdGlvbiA9IHQucmVhZFVpbnQ2NCgpKSA6ICh0aGlzLmNyZWF0aW9uX3RpbWUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5tb2RpZmljYXRpb25fdGltZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnRpbWVzY2FsZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmR1cmF0aW9uID0gdC5yZWFkVWludDMyKCkpLCB0aGlzLnBhcnNlTGFuZ3VhZ2UodCksIHQucmVhZFVpbnQxNigpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcIm1laGRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuZmxhZ3MgJiAxICYmIChyLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJtZWhkIGJveCBpbmNvcnJlY3RseSB1c2VzIGZsYWdzIHNldCB0byAxLCBjb252ZXJ0aW5nIHZlcnNpb24gdG8gMVwiKSwgdGhpcy52ZXJzaW9uID0gMSksIHRoaXMudmVyc2lvbiA9PSAxID8gdGhpcy5mcmFnbWVudF9kdXJhdGlvbiA9IHQucmVhZFVpbnQ2NCgpIDogdGhpcy5mcmFnbWVudF9kdXJhdGlvbiA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcIm1ldGFcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuYm94ZXMgPSBbXSwgbi5Db250YWluZXJCb3gucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgdCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwibWZoZFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXF1ZW5jZV9udW1iZXIgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJtZnJvXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLl9zaXplID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwibXZoZFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID09IDEgPyAodGhpcy5jcmVhdGlvbl90aW1lID0gdC5yZWFkVWludDY0KCksIHRoaXMubW9kaWZpY2F0aW9uX3RpbWUgPSB0LnJlYWRVaW50NjQoKSwgdGhpcy50aW1lc2NhbGUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5kdXJhdGlvbiA9IHQucmVhZFVpbnQ2NCgpKSA6ICh0aGlzLmNyZWF0aW9uX3RpbWUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5tb2RpZmljYXRpb25fdGltZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnRpbWVzY2FsZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmR1cmF0aW9uID0gdC5yZWFkVWludDMyKCkpLCB0aGlzLnJhdGUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy52b2x1bWUgPSB0LnJlYWRVaW50MTYoKSA+PiA4LCB0LnJlYWRVaW50MTYoKSwgdC5yZWFkVWludDMyQXJyYXkoMiksIHRoaXMubWF0cml4ID0gdC5yZWFkVWludDMyQXJyYXkoOSksIHQucmVhZFVpbnQzMkFycmF5KDYpLCB0aGlzLm5leHRfdHJhY2tfaWQgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcIm5wY2tcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFja2V0c3NlbnQgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcIm51bXBcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFja2V0c3NlbnQgPSB0LnJlYWRVaW50NjQoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJwYWRiXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQzMigpO1xuICAgIHRoaXMucGFkYml0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5mbG9vcigoZSArIDEpIC8gMik7IGkrKylcbiAgICAgIHRoaXMucGFkYml0cyA9IHQucmVhZFVpbnQ4KCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJwYXNwXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmhTcGFjaW5nID0gdC5yZWFkVWludDMyKCksIHRoaXMudlNwYWNpbmcgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInBheWxcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGV4dCA9IHQucmVhZFN0cmluZyh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInBheXRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGF5bG9hZElEID0gdC5yZWFkVWludDMyKCk7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50OCgpO1xuICAgIHRoaXMucnRwbWFwX3N0cmluZyA9IHQucmVhZFN0cmluZyhlKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJwZGluXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9ICh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKSAvIDg7XG4gICAgdGhpcy5yYXRlID0gW10sIHRoaXMuaW5pdGlhbF9kZWxheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgICAgdGhpcy5yYXRlW2ldID0gdC5yZWFkVWludDMyKCksIHRoaXMuaW5pdGlhbF9kZWxheVtpXSA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInBpdG1cIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9PT0gMCA/IHRoaXMuaXRlbV9pZCA9IHQucmVhZFVpbnQxNigpIDogdGhpcy5pdGVtX2lkID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwicGl4aVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgZm9yICh0aGlzLm51bV9jaGFubmVscyA9IHQucmVhZFVpbnQ4KCksIHRoaXMuYml0c19wZXJfY2hhbm5lbHMgPSBbXSwgZSA9IDA7IGUgPCB0aGlzLm51bV9jaGFubmVsczsgZSsrKVxuICAgICAgdGhpcy5iaXRzX3Blcl9jaGFubmVsc1tlXSA9IHQucmVhZFVpbnQ4KCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJwbWF4XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmJ5dGVzID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwicHJmdFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5yZWZfdHJhY2tfaWQgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5udHBfdGltZXN0YW1wID0gdC5yZWFkVWludDY0KCksIHRoaXMudmVyc2lvbiA9PT0gMCA/IHRoaXMubWVkaWFfdGltZSA9IHQucmVhZFVpbnQzMigpIDogdGhpcy5tZWRpYV90aW1lID0gdC5yZWFkVWludDY0KCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwicHNzaFwiLCBmdW5jdGlvbih0KSB7XG4gICAgaWYgKHRoaXMuc3lzdGVtX2lkID0gbi5wYXJzZUhleDE2KHQpLCB0aGlzLnZlcnNpb24gPiAwKSB7XG4gICAgICB2YXIgZSA9IHQucmVhZFVpbnQzMigpO1xuICAgICAgdGhpcy5raWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgICAgICB0aGlzLmtpZFtpXSA9IG4ucGFyc2VIZXgxNih0KTtcbiAgICB9XG4gICAgdmFyIHMgPSB0LnJlYWRVaW50MzIoKTtcbiAgICBzID4gMCAmJiAodGhpcy5kYXRhID0gdC5yZWFkVWludDhBcnJheShzKSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiY2xlZlwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy53aWR0aCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmhlaWdodCA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcImVub2ZcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMud2lkdGggPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5oZWlnaHQgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJwcm9mXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLndpZHRoID0gdC5yZWFkVWludDMyKCksIHRoaXMuaGVpZ2h0ID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUNvbnRhaW5lckJveEN0b3IoXCJ0YXB0XCIsIG51bGwsIFtcImNsZWZcIiwgXCJwcm9mXCIsIFwiZW5vZlwiXSksIG4uY3JlYXRlQm94Q3RvcihcInJ0cCBcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuZGVzY3JpcHRpb25mb3JtYXQgPSB0LnJlYWRTdHJpbmcoNCksIHRoaXMuc2RwdGV4dCA9IHQucmVhZFN0cmluZyh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gNCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic2Fpb1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5mbGFncyAmIDEgJiYgKHRoaXMuYXV4X2luZm9fdHlwZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmF1eF9pbmZvX3R5cGVfcGFyYW1ldGVyID0gdC5yZWFkVWludDMyKCkpO1xuICAgIHZhciBlID0gdC5yZWFkVWludDMyKCk7XG4gICAgdGhpcy5vZmZzZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgIHRoaXMudmVyc2lvbiA9PT0gMCA/IHRoaXMub2Zmc2V0W2ldID0gdC5yZWFkVWludDMyKCkgOiB0aGlzLm9mZnNldFtpXSA9IHQucmVhZFVpbnQ2NCgpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInNhaXpcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuZmxhZ3MgJiAxICYmICh0aGlzLmF1eF9pbmZvX3R5cGUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5hdXhfaW5mb190eXBlX3BhcmFtZXRlciA9IHQucmVhZFVpbnQzMigpKSwgdGhpcy5kZWZhdWx0X3NhbXBsZV9pbmZvX3NpemUgPSB0LnJlYWRVaW50OCgpO1xuICAgIHZhciBlID0gdC5yZWFkVWludDMyKCk7XG4gICAgaWYgKHRoaXMuc2FtcGxlX2luZm9fc2l6ZSA9IFtdLCB0aGlzLmRlZmF1bHRfc2FtcGxlX2luZm9fc2l6ZSA9PT0gMClcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgICAgICB0aGlzLnNhbXBsZV9pbmZvX3NpemVbaV0gPSB0LnJlYWRVaW50OCgpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9NRVRBREFUQSwgXCJtZXR0XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlSGVhZGVyKHQpLCB0aGlzLmNvbnRlbnRfZW5jb2RpbmcgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMubWltZV9mb3JtYXQgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMucGFyc2VGb290ZXIodCk7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX01FVEFEQVRBLCBcIm1ldHhcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIodCksIHRoaXMuY29udGVudF9lbmNvZGluZyA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5uYW1lc3BhY2UgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMuc2NoZW1hX2xvY2F0aW9uID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLnBhcnNlRm9vdGVyKHQpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9TVUJUSVRMRSwgXCJzYnR0XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlSGVhZGVyKHQpLCB0aGlzLmNvbnRlbnRfZW5jb2RpbmcgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMubWltZV9mb3JtYXQgPSB0LnJlYWRDU3RyaW5nKCksIHRoaXMucGFyc2VGb290ZXIodCk7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihuLlNBTVBMRV9FTlRSWV9UWVBFX1NVQlRJVExFLCBcInN0cHBcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIodCksIHRoaXMubmFtZXNwYWNlID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLnNjaGVtYV9sb2NhdGlvbiA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5hdXhpbGlhcnlfbWltZV90eXBlcyA9IHQucmVhZENTdHJpbmcoKSwgdGhpcy5wYXJzZUZvb3Rlcih0KTtcbiAgfSksIG4uY3JlYXRlU2FtcGxlRW50cnlDdG9yKG4uU0FNUExFX0VOVFJZX1RZUEVfU1VCVElUTEUsIFwic3R4dFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wYXJzZUhlYWRlcih0KSwgdGhpcy5jb250ZW50X2VuY29kaW5nID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLm1pbWVfZm9ybWF0ID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLnBhcnNlRm9vdGVyKHQpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9TVUJUSVRMRSwgXCJ0eDNnXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlSGVhZGVyKHQpLCB0aGlzLmRpc3BsYXlGbGFncyA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmhvcml6b250YWxfanVzdGlmaWNhdGlvbiA9IHQucmVhZEludDgoKSwgdGhpcy52ZXJ0aWNhbF9qdXN0aWZpY2F0aW9uID0gdC5yZWFkSW50OCgpLCB0aGlzLmJnX2NvbG9yX3JnYmEgPSB0LnJlYWRVaW50OEFycmF5KDQpLCB0aGlzLmJveF9yZWNvcmQgPSB0LnJlYWRJbnQxNkFycmF5KDQpLCB0aGlzLnN0eWxlX3JlY29yZCA9IHQucmVhZFVpbnQ4QXJyYXkoMTIpLCB0aGlzLnBhcnNlRm9vdGVyKHQpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVFbnRyeUN0b3Iobi5TQU1QTEVfRU5UUllfVFlQRV9NRVRBREFUQSwgXCJ3dnR0XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnBhcnNlSGVhZGVyKHQpLCB0aGlzLnBhcnNlRm9vdGVyKHQpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJhbHN0XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSA9IHQucmVhZFVpbnQxNigpO1xuICAgIGZvciAodGhpcy5maXJzdF9vdXRwdXRfc2FtcGxlID0gdC5yZWFkVWludDE2KCksIHRoaXMuc2FtcGxlX29mZnNldCA9IFtdLCBlID0gMDsgZSA8IGk7IGUrKylcbiAgICAgIHRoaXMuc2FtcGxlX29mZnNldFtlXSA9IHQucmVhZFVpbnQzMigpO1xuICAgIHZhciBzID0gdGhpcy5kZXNjcmlwdGlvbl9sZW5ndGggLSA0IC0gNCAqIGk7XG4gICAgZm9yICh0aGlzLm51bV9vdXRwdXRfc2FtcGxlcyA9IFtdLCB0aGlzLm51bV90b3RhbF9zYW1wbGVzID0gW10sIGUgPSAwOyBlIDwgcyAvIDQ7IGUrKylcbiAgICAgIHRoaXMubnVtX291dHB1dF9zYW1wbGVzW2VdID0gdC5yZWFkVWludDE2KCksIHRoaXMubnVtX3RvdGFsX3NhbXBsZXNbZV0gPSB0LnJlYWRVaW50MTYoKTtcbiAgfSksIG4uY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwiYXZsbFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5sYXllck51bWJlciA9IHQucmVhZFVpbnQ4KCksIHRoaXMuYWNjdXJhdGVTdGF0aXN0aWNzRmxhZyA9IHQucmVhZFVpbnQ4KCksIHRoaXMuYXZnQml0UmF0ZSA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmF2Z0ZyYW1lUmF0ZSA9IHQucmVhZFVpbnQxNigpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJhdnNzXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnN1YlNlcXVlbmNlSWRlbnRpZmllciA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmxheWVyTnVtYmVyID0gdC5yZWFkVWludDgoKTtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5kdXJhdGlvbkZsYWcgPSBlID4+IDcsIHRoaXMuYXZnUmF0ZUZsYWcgPSBlID4+IDYgJiAxLCB0aGlzLmR1cmF0aW9uRmxhZyAmJiAodGhpcy5kdXJhdGlvbiA9IHQucmVhZFVpbnQzMigpKSwgdGhpcy5hdmdSYXRlRmxhZyAmJiAodGhpcy5hY2N1cmF0ZVN0YXRpc3RpY3NGbGFnID0gdC5yZWFkVWludDgoKSwgdGhpcy5hdmdCaXRSYXRlID0gdC5yZWFkVWludDE2KCksIHRoaXMuYXZnRnJhbWVSYXRlID0gdC5yZWFkVWludDE2KCkpLCB0aGlzLmRlcGVuZGVuY3kgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gdC5yZWFkVWludDgoKSwgcyA9IDA7IHMgPCBpOyBzKyspIHtcbiAgICAgIHZhciBvID0ge307XG4gICAgICB0aGlzLmRlcGVuZGVuY3kucHVzaChvKSwgby5zdWJTZXFEaXJlY3Rpb25GbGFnID0gdC5yZWFkVWludDgoKSwgby5sYXllck51bWJlciA9IHQucmVhZFVpbnQ4KCksIG8uc3ViU2VxdWVuY2VJZGVudGlmaWVyID0gdC5yZWFkVWludDE2KCk7XG4gICAgfVxuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJkdHJ0XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGUgR3JvdXAgdHlwZTogXCIgKyB0aGlzLmdyb3VwaW5nX3R5cGUgKyBcIiBub3QgZnVsbHkgcGFyc2VkXCIpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJtdmlmXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGUgR3JvdXAgdHlwZTogXCIgKyB0aGlzLmdyb3VwaW5nX3R5cGUgKyBcIiBub3QgZnVsbHkgcGFyc2VkXCIpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJwcm9sXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnJvbGxfZGlzdGFuY2UgPSB0LnJlYWRJbnQxNigpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJyYXAgXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5udW1fbGVhZGluZ19zYW1wbGVzX2tub3duID0gZSA+PiA3LCB0aGlzLm51bV9sZWFkaW5nX3NhbXBsZXMgPSBlICYgMTI3O1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJyYXNoXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodGhpcy5vcGVyYXRpb25fcG9pbnRfY291bnQgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5kZXNjcmlwdGlvbl9sZW5ndGggIT09IDIgKyAodGhpcy5vcGVyYXRpb25fcG9pbnRfY291bnQgPT09IDEgPyAyIDogdGhpcy5vcGVyYXRpb25fcG9pbnRfY291bnQgKiA2KSArIDkpXG4gICAgICByLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJNaXNtYXRjaCBpbiBcIiArIHRoaXMuZ3JvdXBpbmdfdHlwZSArIFwiIHNhbXBsZSBncm91cCBsZW5ndGhcIiksIHRoaXMuZGF0YSA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5kZXNjcmlwdGlvbl9sZW5ndGggLSAyKTtcbiAgICBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wZXJhdGlvbl9wb2ludF9jb3VudCA9PT0gMSlcbiAgICAgICAgdGhpcy50YXJnZXRfcmF0ZV9zaGFyZSA9IHQucmVhZFVpbnQxNigpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMudGFyZ2V0X3JhdGVfc2hhcmUgPSBbXSwgdGhpcy5hdmFpbGFibGVfYml0cmF0ZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMub3BlcmF0aW9uX3BvaW50X2NvdW50OyBlKyspXG4gICAgICAgICAgdGhpcy5hdmFpbGFibGVfYml0cmF0ZVtlXSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnRhcmdldF9yYXRlX3NoYXJlW2VdID0gdC5yZWFkVWludDE2KCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1heGltdW1fYml0cmF0ZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLm1pbmltdW1fYml0cmF0ZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmRpc2NhcmRfcHJpb3JpdHkgPSB0LnJlYWRVaW50OCgpO1xuICAgIH1cbiAgfSksIG4uY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwicm9sbFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5yb2xsX2Rpc3RhbmNlID0gdC5yZWFkSW50MTYoKTtcbiAgfSksIG4uU2FtcGxlR3JvdXBFbnRyeS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih0KSB7XG4gICAgci53YXJuKFwiQm94UGFyc2VyXCIsIFwiVW5rbm93biBTYW1wbGUgR3JvdXAgdHlwZTogXCIgKyB0aGlzLmdyb3VwaW5nX3R5cGUpLCB0aGlzLmRhdGEgPSB0LnJlYWRVaW50OEFycmF5KHRoaXMuZGVzY3JpcHRpb25fbGVuZ3RoKTtcbiAgfSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJzY2lmXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGUgR3JvdXAgdHlwZTogXCIgKyB0aGlzLmdyb3VwaW5nX3R5cGUgKyBcIiBub3QgZnVsbHkgcGFyc2VkXCIpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJzY25tXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGUgR3JvdXAgdHlwZTogXCIgKyB0aGlzLmdyb3VwaW5nX3R5cGUgKyBcIiBub3QgZnVsbHkgcGFyc2VkXCIpO1xuICB9KSwgbi5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJzZWlnXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnJlc2VydmVkID0gdC5yZWFkVWludDgoKTtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5jcnlwdF9ieXRlX2Jsb2NrID0gZSA+PiA0LCB0aGlzLnNraXBfYnl0ZV9ibG9jayA9IGUgJiAxNSwgdGhpcy5pc1Byb3RlY3RlZCA9IHQucmVhZFVpbnQ4KCksIHRoaXMuUGVyX1NhbXBsZV9JVl9TaXplID0gdC5yZWFkVWludDgoKSwgdGhpcy5LSUQgPSBuLnBhcnNlSGV4MTYodCksIHRoaXMuY29uc3RhbnRfSVZfc2l6ZSA9IDAsIHRoaXMuY29uc3RhbnRfSVYgPSAwLCB0aGlzLmlzUHJvdGVjdGVkID09PSAxICYmIHRoaXMuUGVyX1NhbXBsZV9JVl9TaXplID09PSAwICYmICh0aGlzLmNvbnN0YW50X0lWX3NpemUgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmNvbnN0YW50X0lWID0gdC5yZWFkVWludDhBcnJheSh0aGlzLmNvbnN0YW50X0lWX3NpemUpKTtcbiAgfSksIG4uY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwic3RzYVwiLCBmdW5jdGlvbih0KSB7XG4gICAgci53YXJuKFwiQm94UGFyc2VyXCIsIFwiU2FtcGxlIEdyb3VwIHR5cGU6IFwiICsgdGhpcy5ncm91cGluZ190eXBlICsgXCIgbm90IGZ1bGx5IHBhcnNlZFwiKTtcbiAgfSksIG4uY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwic3luY1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50OCgpO1xuICAgIHRoaXMuTkFMX3VuaXRfdHlwZSA9IGUgJiA2MztcbiAgfSksIG4uY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwidGVsZVwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50OCgpO1xuICAgIHRoaXMubGV2ZWxfaW5kZXBlbmRlbnRseV9kZWNvZGFibGUgPSBlID4+IDc7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInRzYXNcIiwgZnVuY3Rpb24odCkge1xuICAgIHIud2FybihcIkJveFBhcnNlclwiLCBcIlNhbXBsZSBHcm91cCB0eXBlOiBcIiArIHRoaXMuZ3JvdXBpbmdfdHlwZSArIFwiIG5vdCBmdWxseSBwYXJzZWRcIik7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInRzY2xcIiwgZnVuY3Rpb24odCkge1xuICAgIHIud2FybihcIkJveFBhcnNlclwiLCBcIlNhbXBsZSBHcm91cCB0eXBlOiBcIiArIHRoaXMuZ3JvdXBpbmdfdHlwZSArIFwiIG5vdCBmdWxseSBwYXJzZWRcIik7XG4gIH0pLCBuLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInZpcHJcIiwgZnVuY3Rpb24odCkge1xuICAgIHIud2FybihcIkJveFBhcnNlclwiLCBcIlNhbXBsZSBHcm91cCB0eXBlOiBcIiArIHRoaXMuZ3JvdXBpbmdfdHlwZSArIFwiIG5vdCBmdWxseSBwYXJzZWRcIik7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic2JncFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5ncm91cGluZ190eXBlID0gdC5yZWFkU3RyaW5nKDQpLCB0aGlzLnZlcnNpb24gPT09IDEgPyB0aGlzLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyID0gdC5yZWFkVWludDMyKCkgOiB0aGlzLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyID0gMCwgdGhpcy5lbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgZSA9IHQucmVhZFVpbnQzMigpLCBpID0gMDsgaSA8IGU7IGkrKykge1xuICAgICAgdmFyIHMgPSB7fTtcbiAgICAgIHRoaXMuZW50cmllcy5wdXNoKHMpLCBzLnNhbXBsZV9jb3VudCA9IHQucmVhZEludDMyKCksIHMuZ3JvdXBfZGVzY3JpcHRpb25faW5kZXggPSB0LnJlYWRJbnQzMigpO1xuICAgIH1cbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzY2htXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNjaGVtZV90eXBlID0gdC5yZWFkU3RyaW5nKDQpLCB0aGlzLnNjaGVtZV92ZXJzaW9uID0gdC5yZWFkVWludDMyKCksIHRoaXMuZmxhZ3MgJiAxICYmICh0aGlzLnNjaGVtZV91cmkgPSB0LnJlYWRTdHJpbmcodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSAtIDgpKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInNkcCBcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2RwdGV4dCA9IHQucmVhZFN0cmluZyh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzZHRwXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSA9IHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemU7XG4gICAgdGhpcy5pc19sZWFkaW5nID0gW10sIHRoaXMuc2FtcGxlX2RlcGVuZHNfb24gPSBbXSwgdGhpcy5zYW1wbGVfaXNfZGVwZW5kZWRfb24gPSBbXSwgdGhpcy5zYW1wbGVfaGFzX3JlZHVuZGFuY3kgPSBbXTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IGk7IHMrKylcbiAgICAgIGUgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmlzX2xlYWRpbmdbc10gPSBlID4+IDYsIHRoaXMuc2FtcGxlX2RlcGVuZHNfb25bc10gPSBlID4+IDQgJiAzLCB0aGlzLnNhbXBsZV9pc19kZXBlbmRlZF9vbltzXSA9IGUgPj4gMiAmIDMsIHRoaXMuc2FtcGxlX2hhc19yZWR1bmRhbmN5W3NdID0gZSAmIDM7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFxuICAgIFwic2VuY1wiXG4gICAgLyosIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIFx0dGhpcy5wYXJzZUZ1bGxIZWFkZXIoc3RyZWFtKTtcbiAgICBcdHZhciBzYW1wbGVfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuICAgIFx0dGhpcy5zYW1wbGVzID0gW107XG4gICAgXHRmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZV9jb3VudDsgaSsrKSB7XG4gICAgXHRcdHZhciBzYW1wbGUgPSB7fTtcbiAgICBcdFx0Ly8gdGVuYy5kZWZhdWx0X1Blcl9TYW1wbGVfSVZfU2l6ZSBvciBzZWlnLlBlcl9TYW1wbGVfSVZfU2l6ZVxuICAgIFx0XHRzYW1wbGUuSW5pdGlhbGl6YXRpb25WZWN0b3IgPSB0aGlzLnJlYWRVaW50OEFycmF5KFBlcl9TYW1wbGVfSVZfU2l6ZSo4KTtcbiAgICBcdFx0aWYgKHRoaXMuZmxhZ3MgJiAweDIpIHtcbiAgICBcdFx0XHRzYW1wbGUuc3Vic2FtcGxlcyA9IFtdO1xuICAgIFx0XHRcdHN1YnNhbXBsZV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzdWJzYW1wbGVfY291bnQ7IGorKykge1xuICAgIFx0XHRcdFx0dmFyIHN1YnNhbXBsZSA9IHt9O1xuICAgIFx0XHRcdFx0c3Vic2FtcGxlLkJ5dGVzT2ZDbGVhckRhdGEgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgIFx0XHRcdFx0c3Vic2FtcGxlLkJ5dGVzT2ZQcm90ZWN0ZWREYXRhID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICBcdFx0XHRcdHNhbXBsZS5zdWJzYW1wbGVzLnB1c2goc3Vic2FtcGxlKTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cbiAgICBcdFx0Ly8gVE9ET1xuICAgIFx0XHR0aGlzLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgIFx0fVxuICAgIH0qL1xuICApLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic2dwZFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5ncm91cGluZ190eXBlID0gdC5yZWFkU3RyaW5nKDQpLCByLmRlYnVnKFwiQm94UGFyc2VyXCIsIFwiRm91bmQgU2FtcGxlIEdyb3VwcyBvZiB0eXBlIFwiICsgdGhpcy5ncm91cGluZ190eXBlKSwgdGhpcy52ZXJzaW9uID09PSAxID8gdGhpcy5kZWZhdWx0X2xlbmd0aCA9IHQucmVhZFVpbnQzMigpIDogdGhpcy5kZWZhdWx0X2xlbmd0aCA9IDAsIHRoaXMudmVyc2lvbiA+PSAyICYmICh0aGlzLmRlZmF1bHRfZ3JvdXBfZGVzY3JpcHRpb25faW5kZXggPSB0LnJlYWRVaW50MzIoKSksIHRoaXMuZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGUgPSB0LnJlYWRVaW50MzIoKSwgaSA9IDA7IGkgPCBlOyBpKyspIHtcbiAgICAgIHZhciBzO1xuICAgICAgblt0aGlzLmdyb3VwaW5nX3R5cGUgKyBcIlNhbXBsZUdyb3VwRW50cnlcIl0gPyBzID0gbmV3IG5bdGhpcy5ncm91cGluZ190eXBlICsgXCJTYW1wbGVHcm91cEVudHJ5XCJdKHRoaXMuZ3JvdXBpbmdfdHlwZSkgOiBzID0gbmV3IG4uU2FtcGxlR3JvdXBFbnRyeSh0aGlzLmdyb3VwaW5nX3R5cGUpLCB0aGlzLmVudHJpZXMucHVzaChzKSwgdGhpcy52ZXJzaW9uID09PSAxID8gdGhpcy5kZWZhdWx0X2xlbmd0aCA9PT0gMCA/IHMuZGVzY3JpcHRpb25fbGVuZ3RoID0gdC5yZWFkVWludDMyKCkgOiBzLmRlc2NyaXB0aW9uX2xlbmd0aCA9IHRoaXMuZGVmYXVsdF9sZW5ndGggOiBzLmRlc2NyaXB0aW9uX2xlbmd0aCA9IHRoaXMuZGVmYXVsdF9sZW5ndGgsIHMud3JpdGUgPT09IG4uU2FtcGxlR3JvdXBFbnRyeS5wcm90b3R5cGUud3JpdGUgJiYgKHIuaW5mbyhcIkJveFBhcnNlclwiLCBcIlNhbXBsZUdyb3VwIGZvciB0eXBlIFwiICsgdGhpcy5ncm91cGluZ190eXBlICsgXCIgd3JpdGluZyBub3QgeWV0IGltcGxlbWVudGVkLCBrZWVwaW5nIHVucGFyc2VkIGRhdGEgaW4gbWVtb3J5IGZvciBsYXRlciB3cml0ZVwiKSwgcy5kYXRhID0gdC5yZWFkVWludDhBcnJheShzLmRlc2NyaXB0aW9uX2xlbmd0aCksIHQucG9zaXRpb24gLT0gcy5kZXNjcmlwdGlvbl9sZW5ndGgpLCBzLnBhcnNlKHQpO1xuICAgIH1cbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzaWR4XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnJlZmVyZW5jZV9JRCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnRpbWVzY2FsZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLnZlcnNpb24gPT09IDAgPyAodGhpcy5lYXJsaWVzdF9wcmVzZW50YXRpb25fdGltZSA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmZpcnN0X29mZnNldCA9IHQucmVhZFVpbnQzMigpKSA6ICh0aGlzLmVhcmxpZXN0X3ByZXNlbnRhdGlvbl90aW1lID0gdC5yZWFkVWludDY0KCksIHRoaXMuZmlyc3Rfb2Zmc2V0ID0gdC5yZWFkVWludDY0KCkpLCB0LnJlYWRVaW50MTYoKSwgdGhpcy5yZWZlcmVuY2VzID0gW107XG4gICAgZm9yICh2YXIgZSA9IHQucmVhZFVpbnQxNigpLCBpID0gMDsgaSA8IGU7IGkrKykge1xuICAgICAgdmFyIHMgPSB7fTtcbiAgICAgIHRoaXMucmVmZXJlbmNlcy5wdXNoKHMpO1xuICAgICAgdmFyIG8gPSB0LnJlYWRVaW50MzIoKTtcbiAgICAgIHMucmVmZXJlbmNlX3R5cGUgPSBvID4+IDMxICYgMSwgcy5yZWZlcmVuY2VkX3NpemUgPSBvICYgMjE0NzQ4MzY0Nywgcy5zdWJzZWdtZW50X2R1cmF0aW9uID0gdC5yZWFkVWludDMyKCksIG8gPSB0LnJlYWRVaW50MzIoKSwgcy5zdGFydHNfd2l0aF9TQVAgPSBvID4+IDMxICYgMSwgcy5TQVBfdHlwZSA9IG8gPj4gMjggJiA3LCBzLlNBUF9kZWx0YV90aW1lID0gbyAmIDI2ODQzNTQ1NTtcbiAgICB9XG4gIH0pLCBuLlNpbmdsZUl0ZW1UeXBlUmVmZXJlbmNlQm94ID0gZnVuY3Rpb24odCwgZSwgaSwgcykge1xuICAgIG4uQm94LmNhbGwodGhpcywgdCwgZSksIHRoaXMuaGRyX3NpemUgPSBpLCB0aGlzLnN0YXJ0ID0gcztcbiAgfSwgbi5TaW5nbGVJdGVtVHlwZVJlZmVyZW5jZUJveC5wcm90b3R5cGUgPSBuZXcgbi5Cb3goKSwgbi5TaW5nbGVJdGVtVHlwZVJlZmVyZW5jZUJveC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5mcm9tX2l0ZW1fSUQgPSB0LnJlYWRVaW50MTYoKTtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQxNigpO1xuICAgIHRoaXMucmVmZXJlbmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgICAgdGhpcy5yZWZlcmVuY2VzW2ldID0gdC5yZWFkVWludDE2KCk7XG4gIH0sIG4uU2luZ2xlSXRlbVR5cGVSZWZlcmVuY2VCb3hMYXJnZSA9IGZ1bmN0aW9uKHQsIGUsIGksIHMpIHtcbiAgICBuLkJveC5jYWxsKHRoaXMsIHQsIGUpLCB0aGlzLmhkcl9zaXplID0gaSwgdGhpcy5zdGFydCA9IHM7XG4gIH0sIG4uU2luZ2xlSXRlbVR5cGVSZWZlcmVuY2VCb3hMYXJnZS5wcm90b3R5cGUgPSBuZXcgbi5Cb3goKSwgbi5TaW5nbGVJdGVtVHlwZVJlZmVyZW5jZUJveExhcmdlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmZyb21faXRlbV9JRCA9IHQucmVhZFVpbnQzMigpO1xuICAgIHZhciBlID0gdC5yZWFkVWludDE2KCk7XG4gICAgdGhpcy5yZWZlcmVuY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICB0aGlzLnJlZmVyZW5jZXNbaV0gPSB0LnJlYWRVaW50MzIoKTtcbiAgfSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcIlNtRG1cIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMucHJpbWFyeVJDaHJvbWF0aWNpdHlfeCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLnByaW1hcnlSQ2hyb21hdGljaXR5X3kgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5wcmltYXJ5R0Nocm9tYXRpY2l0eV94ID0gdC5yZWFkVWludDE2KCksIHRoaXMucHJpbWFyeUdDaHJvbWF0aWNpdHlfeSA9IHQucmVhZFVpbnQxNigpLCB0aGlzLnByaW1hcnlCQ2hyb21hdGljaXR5X3ggPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5wcmltYXJ5QkNocm9tYXRpY2l0eV95ID0gdC5yZWFkVWludDE2KCksIHRoaXMud2hpdGVQb2ludENocm9tYXRpY2l0eV94ID0gdC5yZWFkVWludDE2KCksIHRoaXMud2hpdGVQb2ludENocm9tYXRpY2l0eV95ID0gdC5yZWFkVWludDE2KCksIHRoaXMubHVtaW5hbmNlTWF4ID0gdC5yZWFkVWludDMyKCksIHRoaXMubHVtaW5hbmNlTWluID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic21oZFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5iYWxhbmNlID0gdC5yZWFkVWludDE2KCksIHQucmVhZFVpbnQxNigpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInNzaXhcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3Vic2VnbWVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBlID0gdC5yZWFkVWludDMyKCksIGkgPSAwOyBpIDwgZTsgaSsrKSB7XG4gICAgICB2YXIgcyA9IHt9O1xuICAgICAgdGhpcy5zdWJzZWdtZW50cy5wdXNoKHMpLCBzLnJhbmdlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgbyA9IHQucmVhZFVpbnQzMigpLCBjID0gMDsgYyA8IG87IGMrKykge1xuICAgICAgICB2YXIgdSA9IHt9O1xuICAgICAgICBzLnJhbmdlcy5wdXNoKHUpLCB1LmxldmVsID0gdC5yZWFkVWludDgoKSwgdS5yYW5nZV9zaXplID0gdC5yZWFkVWludDI0KCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInN0Y29cIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIGlmIChlID0gdC5yZWFkVWludDMyKCksIHRoaXMuY2h1bmtfb2Zmc2V0cyA9IFtdLCB0aGlzLnZlcnNpb24gPT09IDApXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgICAgdGhpcy5jaHVua19vZmZzZXRzLnB1c2godC5yZWFkVWludDMyKCkpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInN0ZHBcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpIC8gMjtcbiAgICB0aGlzLnByaW9yaXR5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICB0aGlzLnByaW9yaXR5W2ldID0gdC5yZWFkVWludDE2KCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RoZFwiKSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInN0cmlcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3dpdGNoX2dyb3VwID0gdC5yZWFkVWludDE2KCksIHRoaXMuYWx0ZXJuYXRlX2dyb3VwID0gdC5yZWFkVWludDE2KCksIHRoaXMuc3ViX3RyYWNrX2lkID0gdC5yZWFkVWludDMyKCk7XG4gICAgdmFyIGUgPSAodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSAtIDgpIC8gNDtcbiAgICB0aGlzLmF0dHJpYnV0ZV9saXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICB0aGlzLmF0dHJpYnV0ZV9saXN0W2ldID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RzY1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGk7XG4gICAgaWYgKGUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5maXJzdF9jaHVuayA9IFtdLCB0aGlzLnNhbXBsZXNfcGVyX2NodW5rID0gW10sIHRoaXMuc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4ID0gW10sIHRoaXMudmVyc2lvbiA9PT0gMClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICAgIHRoaXMuZmlyc3RfY2h1bmsucHVzaCh0LnJlYWRVaW50MzIoKSksIHRoaXMuc2FtcGxlc19wZXJfY2h1bmsucHVzaCh0LnJlYWRVaW50MzIoKSksIHRoaXMuc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4LnB1c2godC5yZWFkVWludDMyKCkpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInN0c2RcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpLCBzLCBvO1xuICAgIGZvciAodGhpcy5lbnRyaWVzID0gW10sIHMgPSB0LnJlYWRVaW50MzIoKSwgZSA9IDE7IGUgPD0gczsgZSsrKVxuICAgICAgaWYgKGkgPSBuLnBhcnNlT25lQm94KHQsICEwLCB0aGlzLnNpemUgLSAodC5nZXRQb3NpdGlvbigpIC0gdGhpcy5zdGFydCkpLCBpLmNvZGUgPT09IG4uT0spXG4gICAgICAgIG5baS50eXBlICsgXCJTYW1wbGVFbnRyeVwiXSA/IChvID0gbmV3IG5baS50eXBlICsgXCJTYW1wbGVFbnRyeVwiXShpLnNpemUpLCBvLmhkcl9zaXplID0gaS5oZHJfc2l6ZSwgby5zdGFydCA9IGkuc3RhcnQpIDogKHIud2FybihcIkJveFBhcnNlclwiLCBcIlVua25vd24gc2FtcGxlIGVudHJ5IHR5cGU6IFwiICsgaS50eXBlKSwgbyA9IG5ldyBuLlNhbXBsZUVudHJ5KGkudHlwZSwgaS5zaXplLCBpLmhkcl9zaXplLCBpLnN0YXJ0KSksIG8ud3JpdGUgPT09IG4uU2FtcGxlRW50cnkucHJvdG90eXBlLndyaXRlICYmIChyLmluZm8oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGVFbnRyeSBcIiArIG8udHlwZSArIFwiIGJveCB3cml0aW5nIG5vdCB5ZXQgaW1wbGVtZW50ZWQsIGtlZXBpbmcgdW5wYXJzZWQgZGF0YSBpbiBtZW1vcnkgZm9yIGxhdGVyIHdyaXRlXCIpLCBvLnBhcnNlRGF0YUFuZFJld2luZCh0KSksIG8ucGFyc2UodCksIHRoaXMuZW50cmllcy5wdXNoKG8pO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm47XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RzZ1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5ncm91cGluZ190eXBlID0gdC5yZWFkVWludDMyKCk7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50MTYoKTtcbiAgICB0aGlzLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICB0aGlzLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4W2ldID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RzaFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGk7XG4gICAgaWYgKGUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5zaGFkb3dlZF9zYW1wbGVfbnVtYmVycyA9IFtdLCB0aGlzLnN5bmNfc2FtcGxlX251bWJlcnMgPSBbXSwgdGhpcy52ZXJzaW9uID09PSAwKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgICAgdGhpcy5zaGFkb3dlZF9zYW1wbGVfbnVtYmVycy5wdXNoKHQucmVhZFVpbnQzMigpKSwgdGhpcy5zeW5jX3NhbXBsZV9udW1iZXJzLnB1c2godC5yZWFkVWludDMyKCkpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInN0c3NcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpO1xuICAgIGlmIChpID0gdC5yZWFkVWludDMyKCksIHRoaXMudmVyc2lvbiA9PT0gMClcbiAgICAgIGZvciAodGhpcy5zYW1wbGVfbnVtYmVycyA9IFtdLCBlID0gMDsgZSA8IGk7IGUrKylcbiAgICAgICAgdGhpcy5zYW1wbGVfbnVtYmVycy5wdXNoKHQucmVhZFVpbnQzMigpKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzdHN6XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZTtcbiAgICBpZiAodGhpcy5zYW1wbGVfc2l6ZXMgPSBbXSwgdGhpcy52ZXJzaW9uID09PSAwKVxuICAgICAgZm9yICh0aGlzLnNhbXBsZV9zaXplID0gdC5yZWFkVWludDMyKCksIHRoaXMuc2FtcGxlX2NvdW50ID0gdC5yZWFkVWludDMyKCksIGUgPSAwOyBlIDwgdGhpcy5zYW1wbGVfY291bnQ7IGUrKylcbiAgICAgICAgdGhpcy5zYW1wbGVfc2l6ZSA9PT0gMCA/IHRoaXMuc2FtcGxlX3NpemVzLnB1c2godC5yZWFkVWludDMyKCkpIDogdGhpcy5zYW1wbGVfc2l6ZXNbZV0gPSB0aGlzLnNhbXBsZV9zaXplO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInN0dHNcIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpLCBzO1xuICAgIGlmIChlID0gdC5yZWFkVWludDMyKCksIHRoaXMuc2FtcGxlX2NvdW50cyA9IFtdLCB0aGlzLnNhbXBsZV9kZWx0YXMgPSBbXSwgdGhpcy52ZXJzaW9uID09PSAwKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGU7IGkrKylcbiAgICAgICAgdGhpcy5zYW1wbGVfY291bnRzLnB1c2godC5yZWFkVWludDMyKCkpLCBzID0gdC5yZWFkSW50MzIoKSwgcyA8IDAgJiYgKHIud2FybihcIkJveFBhcnNlclwiLCBcIkZpbGUgdXNlcyBuZWdhdGl2ZSBzdHRzIHNhbXBsZSBkZWx0YSwgdXNpbmcgdmFsdWUgMSBpbnN0ZWFkLCBzeW5jIG1heSBiZSBsb3N0IVwiKSwgcyA9IDEpLCB0aGlzLnNhbXBsZV9kZWx0YXMucHVzaChzKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzdHZpXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucmVhZFVpbnQzMigpO1xuICAgIHRoaXMuc2luZ2xlX3ZpZXdfYWxsb3dlZCA9IGUgJiAzLCB0aGlzLnN0ZXJlb19zY2hlbWUgPSB0LnJlYWRVaW50MzIoKTtcbiAgICB2YXIgaSA9IHQucmVhZFVpbnQzMigpO1xuICAgIHRoaXMuc3RlcmVvX2luZGljYXRpb25fdHlwZSA9IHQucmVhZFN0cmluZyhpKTtcbiAgICB2YXIgcywgbztcbiAgICBmb3IgKHRoaXMuYm94ZXMgPSBbXTsgdC5nZXRQb3NpdGlvbigpIDwgdGhpcy5zdGFydCArIHRoaXMuc2l6ZTsgKVxuICAgICAgaWYgKHMgPSBuLnBhcnNlT25lQm94KHQsICExLCB0aGlzLnNpemUgLSAodC5nZXRQb3NpdGlvbigpIC0gdGhpcy5zdGFydCkpLCBzLmNvZGUgPT09IG4uT0spXG4gICAgICAgIG8gPSBzLmJveCwgdGhpcy5ib3hlcy5wdXNoKG8pLCB0aGlzW28udHlwZV0gPSBvO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm47XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJzdHlwXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICBuLmZ0eXBCb3gucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgdCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3R6MlwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGk7XG4gICAgaWYgKHRoaXMuc2FtcGxlX3NpemVzID0gW10sIHRoaXMudmVyc2lvbiA9PT0gMClcbiAgICAgIGlmICh0aGlzLnJlc2VydmVkID0gdC5yZWFkVWludDI0KCksIHRoaXMuZmllbGRfc2l6ZSA9IHQucmVhZFVpbnQ4KCksIGkgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5maWVsZF9zaXplID09PSA0KVxuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgaTsgZSArPSAyKSB7XG4gICAgICAgICAgdmFyIHMgPSB0LnJlYWRVaW50OCgpO1xuICAgICAgICAgIHRoaXMuc2FtcGxlX3NpemVzW2VdID0gcyA+PiA0ICYgMTUsIHRoaXMuc2FtcGxlX3NpemVzW2UgKyAxXSA9IHMgJiAxNTtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5maWVsZF9zaXplID09PSA4KVxuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgaTsgZSsrKVxuICAgICAgICAgIHRoaXMuc2FtcGxlX3NpemVzW2VdID0gdC5yZWFkVWludDgoKTtcbiAgICAgIGVsc2UgaWYgKHRoaXMuZmllbGRfc2l6ZSA9PT0gMTYpXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCBpOyBlKyspXG4gICAgICAgICAgdGhpcy5zYW1wbGVfc2l6ZXNbZV0gPSB0LnJlYWRVaW50MTYoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgci5lcnJvcihcIkJveFBhcnNlclwiLCBcIkVycm9yIGluIGxlbmd0aCBmaWVsZCBpbiBzdHoyIGJveFwiKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJzdWJzXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSwgcywgbztcbiAgICBmb3IgKHMgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5lbnRyaWVzID0gW10sIGUgPSAwOyBlIDwgczsgZSsrKSB7XG4gICAgICB2YXIgYyA9IHt9O1xuICAgICAgaWYgKHRoaXMuZW50cmllc1tlXSA9IGMsIGMuc2FtcGxlX2RlbHRhID0gdC5yZWFkVWludDMyKCksIGMuc3Vic2FtcGxlcyA9IFtdLCBvID0gdC5yZWFkVWludDE2KCksIG8gPiAwKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbzsgaSsrKSB7XG4gICAgICAgICAgdmFyIHUgPSB7fTtcbiAgICAgICAgICBjLnN1YnNhbXBsZXMucHVzaCh1KSwgdGhpcy52ZXJzaW9uID09IDEgPyB1LnNpemUgPSB0LnJlYWRVaW50MzIoKSA6IHUuc2l6ZSA9IHQucmVhZFVpbnQxNigpLCB1LnByaW9yaXR5ID0gdC5yZWFkVWludDgoKSwgdS5kaXNjYXJkYWJsZSA9IHQucmVhZFVpbnQ4KCksIHUuY29kZWNfc3BlY2lmaWNfcGFyYW1ldGVycyA9IHQucmVhZFVpbnQzMigpO1xuICAgICAgICB9XG4gICAgfVxuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInRlbmNcIiwgZnVuY3Rpb24odCkge1xuICAgIGlmICh0LnJlYWRVaW50OCgpLCB0aGlzLnZlcnNpb24gPT09IDApXG4gICAgICB0LnJlYWRVaW50OCgpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGUgPSB0LnJlYWRVaW50OCgpO1xuICAgICAgdGhpcy5kZWZhdWx0X2NyeXB0X2J5dGVfYmxvY2sgPSBlID4+IDQgJiAxNSwgdGhpcy5kZWZhdWx0X3NraXBfYnl0ZV9ibG9jayA9IGUgJiAxNTtcbiAgICB9XG4gICAgdGhpcy5kZWZhdWx0X2lzUHJvdGVjdGVkID0gdC5yZWFkVWludDgoKSwgdGhpcy5kZWZhdWx0X1Blcl9TYW1wbGVfSVZfU2l6ZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuZGVmYXVsdF9LSUQgPSBuLnBhcnNlSGV4MTYodCksIHRoaXMuZGVmYXVsdF9pc1Byb3RlY3RlZCA9PT0gMSAmJiB0aGlzLmRlZmF1bHRfUGVyX1NhbXBsZV9JVl9TaXplID09PSAwICYmICh0aGlzLmRlZmF1bHRfY29uc3RhbnRfSVZfc2l6ZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMuZGVmYXVsdF9jb25zdGFudF9JViA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5kZWZhdWx0X2NvbnN0YW50X0lWX3NpemUpKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ0ZmR0XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPT0gMSA/IHRoaXMuYmFzZU1lZGlhRGVjb2RlVGltZSA9IHQucmVhZFVpbnQ2NCgpIDogdGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidGZoZFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSAwO1xuICAgIHRoaXMudHJhY2tfaWQgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSA+IGUgJiYgdGhpcy5mbGFncyAmIG4uVEZIRF9GTEFHX0JBU0VfREFUQV9PRkZTRVQgPyAodGhpcy5iYXNlX2RhdGFfb2Zmc2V0ID0gdC5yZWFkVWludDY0KCksIGUgKz0gOCkgOiB0aGlzLmJhc2VfZGF0YV9vZmZzZXQgPSAwLCB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplID4gZSAmJiB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX0RFU0MgPyAodGhpcy5kZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCA9IHQucmVhZFVpbnQzMigpLCBlICs9IDQpIDogdGhpcy5kZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCA9IDAsIHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgPiBlICYmIHRoaXMuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfRFVSID8gKHRoaXMuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gPSB0LnJlYWRVaW50MzIoKSwgZSArPSA0KSA6IHRoaXMuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gPSAwLCB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplID4gZSAmJiB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX1NJWkUgPyAodGhpcy5kZWZhdWx0X3NhbXBsZV9zaXplID0gdC5yZWFkVWludDMyKCksIGUgKz0gNCkgOiB0aGlzLmRlZmF1bHRfc2FtcGxlX3NpemUgPSAwLCB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplID4gZSAmJiB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX0ZMQUdTID8gKHRoaXMuZGVmYXVsdF9zYW1wbGVfZmxhZ3MgPSB0LnJlYWRVaW50MzIoKSwgZSArPSA0KSA6IHRoaXMuZGVmYXVsdF9zYW1wbGVfZmxhZ3MgPSAwO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInRmcmFcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudHJhY2tfSUQgPSB0LnJlYWRVaW50MzIoKSwgdC5yZWFkVWludDI0KCk7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50OCgpO1xuICAgIHRoaXMubGVuZ3RoX3NpemVfb2ZfdHJhZl9udW0gPSBlID4+IDQgJiAzLCB0aGlzLmxlbmd0aF9zaXplX29mX3RydW5fbnVtID0gZSA+PiAyICYgMywgdGhpcy5sZW5ndGhfc2l6ZV9vZl9zYW1wbGVfbnVtID0gZSAmIDMsIHRoaXMuZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSB0LnJlYWRVaW50MzIoKSwgcyA9IDA7IHMgPCBpOyBzKyspXG4gICAgICB0aGlzLnZlcnNpb24gPT09IDEgPyAodGhpcy50aW1lID0gdC5yZWFkVWludDY0KCksIHRoaXMubW9vZl9vZmZzZXQgPSB0LnJlYWRVaW50NjQoKSkgOiAodGhpcy50aW1lID0gdC5yZWFkVWludDMyKCksIHRoaXMubW9vZl9vZmZzZXQgPSB0LnJlYWRVaW50MzIoKSksIHRoaXMudHJhZl9udW1iZXIgPSB0W1wicmVhZFVpbnRcIiArIDggKiAodGhpcy5sZW5ndGhfc2l6ZV9vZl90cmFmX251bSArIDEpXSgpLCB0aGlzLnRydW5fbnVtYmVyID0gdFtcInJlYWRVaW50XCIgKyA4ICogKHRoaXMubGVuZ3RoX3NpemVfb2ZfdHJ1bl9udW0gKyAxKV0oKSwgdGhpcy5zYW1wbGVfbnVtYmVyID0gdFtcInJlYWRVaW50XCIgKyA4ICogKHRoaXMubGVuZ3RoX3NpemVfb2Zfc2FtcGxlX251bSArIDEpXSgpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInRraGRcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9PSAxID8gKHRoaXMuY3JlYXRpb25fdGltZSA9IHQucmVhZFVpbnQ2NCgpLCB0aGlzLm1vZGlmaWNhdGlvbl90aW1lID0gdC5yZWFkVWludDY0KCksIHRoaXMudHJhY2tfaWQgPSB0LnJlYWRVaW50MzIoKSwgdC5yZWFkVWludDMyKCksIHRoaXMuZHVyYXRpb24gPSB0LnJlYWRVaW50NjQoKSkgOiAodGhpcy5jcmVhdGlvbl90aW1lID0gdC5yZWFkVWludDMyKCksIHRoaXMubW9kaWZpY2F0aW9uX3RpbWUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy50cmFja19pZCA9IHQucmVhZFVpbnQzMigpLCB0LnJlYWRVaW50MzIoKSwgdGhpcy5kdXJhdGlvbiA9IHQucmVhZFVpbnQzMigpKSwgdC5yZWFkVWludDMyQXJyYXkoMiksIHRoaXMubGF5ZXIgPSB0LnJlYWRJbnQxNigpLCB0aGlzLmFsdGVybmF0ZV9ncm91cCA9IHQucmVhZEludDE2KCksIHRoaXMudm9sdW1lID0gdC5yZWFkSW50MTYoKSA+PiA4LCB0LnJlYWRVaW50MTYoKSwgdGhpcy5tYXRyaXggPSB0LnJlYWRJbnQzMkFycmF5KDkpLCB0aGlzLndpZHRoID0gdC5yZWFkVWludDMyKCksIHRoaXMuaGVpZ2h0ID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJ0bWF4XCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRpbWUgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInRtaW5cIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGltZSA9IHQucmVhZFVpbnQzMigpO1xuICB9KSwgbi5jcmVhdGVCb3hDdG9yKFwidG90bFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5ieXRlc3NlbnQgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInRwYXlcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuYnl0ZXNzZW50ID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJ0cHlsXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmJ5dGVzc2VudCA9IHQucmVhZFVpbnQ2NCgpO1xuICB9KSwgbi5UcmFja0dyb3VwVHlwZUJveC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5wYXJzZUZ1bGxIZWFkZXIodCksIHRoaXMudHJhY2tfZ3JvdXBfaWQgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSwgbi5jcmVhdGVUcmFja0dyb3VwQ3RvcihcIm1zcmNcIiksIG4uVHJhY2tSZWZlcmVuY2VUeXBlQm94ID0gZnVuY3Rpb24odCwgZSwgaSwgcykge1xuICAgIG4uQm94LmNhbGwodGhpcywgdCwgZSksIHRoaXMuaGRyX3NpemUgPSBpLCB0aGlzLnN0YXJ0ID0gcztcbiAgfSwgbi5UcmFja1JlZmVyZW5jZVR5cGVCb3gucHJvdG90eXBlID0gbmV3IG4uQm94KCksIG4uVHJhY2tSZWZlcmVuY2VUeXBlQm94LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRyYWNrX2lkcyA9IHQucmVhZFVpbnQzMkFycmF5KCh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplKSAvIDQpO1xuICB9LCBuLnRyZWZCb3gucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUsIGk7IHQuZ2V0UG9zaXRpb24oKSA8IHRoaXMuc3RhcnQgKyB0aGlzLnNpemU7IClcbiAgICAgIGlmIChlID0gbi5wYXJzZU9uZUJveCh0LCAhMCwgdGhpcy5zaXplIC0gKHQuZ2V0UG9zaXRpb24oKSAtIHRoaXMuc3RhcnQpKSwgZS5jb2RlID09PSBuLk9LKVxuICAgICAgICBpID0gbmV3IG4uVHJhY2tSZWZlcmVuY2VUeXBlQm94KGUudHlwZSwgZS5zaXplLCBlLmhkcl9zaXplLCBlLnN0YXJ0KSwgaS53cml0ZSA9PT0gbi5Cb3gucHJvdG90eXBlLndyaXRlICYmIGkudHlwZSAhPT0gXCJtZGF0XCIgJiYgKHIuaW5mbyhcIkJveFBhcnNlclwiLCBcIlRyYWNrUmVmZXJlbmNlIFwiICsgaS50eXBlICsgXCIgYm94IHdyaXRpbmcgbm90IHlldCBpbXBsZW1lbnRlZCwga2VlcGluZyB1bnBhcnNlZCBkYXRhIGluIG1lbW9yeSBmb3IgbGF0ZXIgd3JpdGVcIiksIGkucGFyc2VEYXRhQW5kUmV3aW5kKHQpKSwgaS5wYXJzZSh0KSwgdGhpcy5ib3hlcy5wdXNoKGkpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm47XG4gIH0sIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ0cmVwXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHRoaXMudHJhY2tfSUQgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5ib3hlcyA9IFtdOyB0LmdldFBvc2l0aW9uKCkgPCB0aGlzLnN0YXJ0ICsgdGhpcy5zaXplOyApXG4gICAgICBpZiAocmV0ID0gbi5wYXJzZU9uZUJveCh0LCAhMSwgdGhpcy5zaXplIC0gKHQuZ2V0UG9zaXRpb24oKSAtIHRoaXMuc3RhcnQpKSwgcmV0LmNvZGUgPT09IG4uT0spXG4gICAgICAgIGJveCA9IHJldC5ib3gsIHRoaXMuYm94ZXMucHVzaChib3gpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm47XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidHJleFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50cmFja19pZCA9IHQucmVhZFVpbnQzMigpLCB0aGlzLmRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4ID0gdC5yZWFkVWludDMyKCksIHRoaXMuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5kZWZhdWx0X3NhbXBsZV9zaXplID0gdC5yZWFkVWludDMyKCksIHRoaXMuZGVmYXVsdF9zYW1wbGVfZmxhZ3MgPSB0LnJlYWRVaW50MzIoKTtcbiAgfSksIG4uY3JlYXRlQm94Q3RvcihcInRycHlcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuYnl0ZXNzZW50ID0gdC5yZWFkVWludDY0KCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidHJ1blwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSAwO1xuICAgIGlmICh0aGlzLnNhbXBsZV9jb3VudCA9IHQucmVhZFVpbnQzMigpLCBlICs9IDQsIHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgPiBlICYmIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfREFUQV9PRkZTRVQgPyAodGhpcy5kYXRhX29mZnNldCA9IHQucmVhZEludDMyKCksIGUgKz0gNCkgOiB0aGlzLmRhdGFfb2Zmc2V0ID0gMCwgdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSA+IGUgJiYgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19GSVJTVF9GTEFHID8gKHRoaXMuZmlyc3Rfc2FtcGxlX2ZsYWdzID0gdC5yZWFkVWludDMyKCksIGUgKz0gNCkgOiB0aGlzLmZpcnN0X3NhbXBsZV9mbGFncyA9IDAsIHRoaXMuc2FtcGxlX2R1cmF0aW9uID0gW10sIHRoaXMuc2FtcGxlX3NpemUgPSBbXSwgdGhpcy5zYW1wbGVfZmxhZ3MgPSBbXSwgdGhpcy5zYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXQgPSBbXSwgdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSA+IGUpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2FtcGxlX2NvdW50OyBpKyspXG4gICAgICAgIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfRFVSQVRJT04gJiYgKHRoaXMuc2FtcGxlX2R1cmF0aW9uW2ldID0gdC5yZWFkVWludDMyKCkpLCB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX1NJWkUgJiYgKHRoaXMuc2FtcGxlX3NpemVbaV0gPSB0LnJlYWRVaW50MzIoKSksIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfRkxBR1MgJiYgKHRoaXMuc2FtcGxlX2ZsYWdzW2ldID0gdC5yZWFkVWludDMyKCkpLCB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX0NUU19PRkZTRVQgJiYgKHRoaXMudmVyc2lvbiA9PT0gMCA/IHRoaXMuc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0W2ldID0gdC5yZWFkVWludDMyKCkgOiB0aGlzLnNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFtpXSA9IHQucmVhZEludDMyKCkpO1xuICB9KSwgbi5jcmVhdGVGdWxsQm94Q3RvcihcInRzZWxcIiwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3dpdGNoX2dyb3VwID0gdC5yZWFkVWludDMyKCk7XG4gICAgdmFyIGUgPSAodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSAtIDQpIC8gNDtcbiAgICB0aGlzLmF0dHJpYnV0ZV9saXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlOyBpKyspXG4gICAgICB0aGlzLmF0dHJpYnV0ZV9saXN0W2ldID0gdC5yZWFkVWludDMyKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidHh0Q1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5jb25maWcgPSB0LnJlYWRDU3RyaW5nKCk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidXJsIFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5mbGFncyAhPT0gMSAmJiAodGhpcy5sb2NhdGlvbiA9IHQucmVhZENTdHJpbmcoKSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidXJuIFwiLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5uYW1lID0gdC5yZWFkQ1N0cmluZygpLCB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gdGhpcy5uYW1lLmxlbmd0aCAtIDEgPiAwICYmICh0aGlzLmxvY2F0aW9uID0gdC5yZWFkQ1N0cmluZygpKTtcbiAgfSksIG4uY3JlYXRlVVVJREJveChcImE1ZDQwYjMwZTgxNDExZGRiYTJmMDgwMDIwMGM5YTY2XCIsICEwLCAhMSwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMuTGl2ZVNlcnZlck1hbmlmZXN0ID0gdC5yZWFkU3RyaW5nKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKS5yZXBsYWNlKC8nL2csIFwiJiMwMzk7XCIpO1xuICB9KSwgbi5jcmVhdGVVVUlEQm94KFwiZDA4YTRmMTgxMGYzNGE4MmI2YzgzMmQ4YWJhMTgzZDNcIiwgITAsICExLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zeXN0ZW1faWQgPSBuLnBhcnNlSGV4MTYodCk7XG4gICAgdmFyIGUgPSB0LnJlYWRVaW50MzIoKTtcbiAgICBlID4gMCAmJiAodGhpcy5kYXRhID0gdC5yZWFkVWludDhBcnJheShlKSk7XG4gIH0pLCBuLmNyZWF0ZVVVSURCb3goXG4gICAgXCJhMjM5NGY1MjVhOWI0ZjE0YTI0NDZjNDI3YzY0OGRmNFwiLFxuICAgICEwLFxuICAgICExXG4gICAgLyosIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIFx0aWYgKHRoaXMuZmxhZ3MgJiAweDEpIHtcbiAgICBcdFx0dGhpcy5BbGdvcml0aG1JRCA9IHN0cmVhbS5yZWFkVWludDI0KCk7XG4gICAgXHRcdHRoaXMuSVZfc2l6ZSA9IHN0cmVhbS5yZWFkVWludDgoKTtcbiAgICBcdFx0dGhpcy5LSUQgPSBCb3hQYXJzZXIucGFyc2VIZXgxNihzdHJlYW0pO1xuICAgIFx0fVxuICAgIFx0dmFyIHNhbXBsZV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG4gICAgXHR0aGlzLnNhbXBsZXMgPSBbXTtcbiAgICBcdGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlX2NvdW50OyBpKyspIHtcbiAgICBcdFx0dmFyIHNhbXBsZSA9IHt9O1xuICAgIFx0XHRzYW1wbGUuSW5pdGlhbGl6YXRpb25WZWN0b3IgPSB0aGlzLnJlYWRVaW50OEFycmF5KHRoaXMuSVZfc2l6ZSo4KTtcbiAgICBcdFx0aWYgKHRoaXMuZmxhZ3MgJiAweDIpIHtcbiAgICBcdFx0XHRzYW1wbGUuc3Vic2FtcGxlcyA9IFtdO1xuICAgIFx0XHRcdHNhbXBsZS5OdW1iZXJPZkVudHJpZXMgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgIFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc2FtcGxlLk51bWJlck9mRW50cmllczsgaisrKSB7XG4gICAgXHRcdFx0XHR2YXIgc3Vic2FtcGxlID0ge307XG4gICAgXHRcdFx0XHRzdWJzYW1wbGUuQnl0ZXNPZkNsZWFyRGF0YSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgXHRcdFx0XHRzdWJzYW1wbGUuQnl0ZXNPZlByb3RlY3RlZERhdGEgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuICAgIFx0XHRcdFx0c2FtcGxlLnN1YnNhbXBsZXMucHVzaChzdWJzYW1wbGUpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0XHR0aGlzLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgIFx0fVxuICAgIH0qL1xuICApLCBuLmNyZWF0ZVVVSURCb3goXCI4OTc0ZGJjZTdiZTc0YzUxODRmOTcxNDhmOTg4MjU1NFwiLCAhMCwgITEsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmRlZmF1bHRfQWxnb3JpdGhtSUQgPSB0LnJlYWRVaW50MjQoKSwgdGhpcy5kZWZhdWx0X0lWX3NpemUgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmRlZmF1bHRfS0lEID0gbi5wYXJzZUhleDE2KHQpO1xuICB9KSwgbi5jcmVhdGVVVUlEQm94KFwiZDQ4MDdlZjJjYTM5NDY5NThlNTQyNmNiOWU0NmE3OWZcIiwgITAsICExLCBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5mcmFnbWVudF9jb3VudCA9IHQucmVhZFVpbnQ4KCksIHRoaXMuZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5mcmFnbWVudF9jb3VudDsgZSsrKSB7XG4gICAgICB2YXIgaSA9IHt9LCBzID0gMCwgbyA9IDA7XG4gICAgICB0aGlzLnZlcnNpb24gPT09IDEgPyAocyA9IHQucmVhZFVpbnQ2NCgpLCBvID0gdC5yZWFkVWludDY0KCkpIDogKHMgPSB0LnJlYWRVaW50MzIoKSwgbyA9IHQucmVhZFVpbnQzMigpKSwgaS5hYnNvbHV0ZV90aW1lID0gcywgaS5hYnNvbHV0ZV9kdXJhdGlvbiA9IG8sIHRoaXMuZW50cmllcy5wdXNoKGkpO1xuICAgIH1cbiAgfSksIG4uY3JlYXRlVVVJREJveChcIjZkMWQ5YjA1NDJkNTQ0ZTY4MGUyMTQxZGFmZjc1N2IyXCIsICEwLCAhMSwgZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9PT0gMSA/ICh0aGlzLmFic29sdXRlX3RpbWUgPSB0LnJlYWRVaW50NjQoKSwgdGhpcy5kdXJhdGlvbiA9IHQucmVhZFVpbnQ2NCgpKSA6ICh0aGlzLmFic29sdXRlX3RpbWUgPSB0LnJlYWRVaW50MzIoKSwgdGhpcy5kdXJhdGlvbiA9IHQucmVhZFVpbnQzMigpKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ2bWhkXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLmdyYXBoaWNzbW9kZSA9IHQucmVhZFVpbnQxNigpLCB0aGlzLm9wY29sb3IgPSB0LnJlYWRVaW50MTZBcnJheSgzKTtcbiAgfSksIG4uY3JlYXRlRnVsbEJveEN0b3IoXCJ2cGNDXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLnZlcnNpb24gPT09IDEgPyAodGhpcy5wcm9maWxlID0gdC5yZWFkVWludDgoKSwgdGhpcy5sZXZlbCA9IHQucmVhZFVpbnQ4KCksIGUgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmJpdERlcHRoID0gZSA+PiA0LCB0aGlzLmNocm9tYVN1YnNhbXBsaW5nID0gZSA+PiAxICYgNywgdGhpcy52aWRlb0Z1bGxSYW5nZUZsYWcgPSBlICYgMSwgdGhpcy5jb2xvdXJQcmltYXJpZXMgPSB0LnJlYWRVaW50OCgpLCB0aGlzLnRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzID0gdC5yZWFkVWludDgoKSwgdGhpcy5tYXRyaXhDb2VmZmljaWVudHMgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmNvZGVjSW50aWFsaXphdGlvbkRhdGFTaXplID0gdC5yZWFkVWludDE2KCksIHRoaXMuY29kZWNJbnRpYWxpemF0aW9uRGF0YSA9IHQucmVhZFVpbnQ4QXJyYXkodGhpcy5jb2RlY0ludGlhbGl6YXRpb25EYXRhU2l6ZSkpIDogKHRoaXMucHJvZmlsZSA9IHQucmVhZFVpbnQ4KCksIHRoaXMubGV2ZWwgPSB0LnJlYWRVaW50OCgpLCBlID0gdC5yZWFkVWludDgoKSwgdGhpcy5iaXREZXB0aCA9IGUgPj4gNCAmIDE1LCB0aGlzLmNvbG9yU3BhY2UgPSBlICYgMTUsIGUgPSB0LnJlYWRVaW50OCgpLCB0aGlzLmNocm9tYVN1YnNhbXBsaW5nID0gZSA+PiA0ICYgMTUsIHRoaXMudHJhbnNmZXJGdW5jdGlvbiA9IGUgPj4gMSAmIDcsIHRoaXMudmlkZW9GdWxsUmFuZ2VGbGFnID0gZSAmIDEsIHRoaXMuY29kZWNJbnRpYWxpemF0aW9uRGF0YVNpemUgPSB0LnJlYWRVaW50MTYoKSwgdGhpcy5jb2RlY0ludGlhbGl6YXRpb25EYXRhID0gdC5yZWFkVWludDhBcnJheSh0aGlzLmNvZGVjSW50aWFsaXphdGlvbkRhdGFTaXplKSk7XG4gIH0pLCBuLmNyZWF0ZUJveEN0b3IoXCJ2dHRDXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRleHQgPSB0LnJlYWRTdHJpbmcodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSk7XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidnZjQ1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGksIHMgPSB7XG4gICAgICBoZWxkX2JpdHM6IHZvaWQgMCxcbiAgICAgIG51bV9oZWxkX2JpdHM6IDAsXG4gICAgICBzdHJlYW1fcmVhZF8xX2J5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHRoaXMuaGVsZF9iaXRzID0geC5yZWFkVWludDgoKSwgdGhpcy5udW1faGVsZF9iaXRzID0gODtcbiAgICAgIH0sXG4gICAgICBzdHJlYW1fcmVhZF8yX2J5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHRoaXMuaGVsZF9iaXRzID0geC5yZWFkVWludDE2KCksIHRoaXMubnVtX2hlbGRfYml0cyA9IDE2O1xuICAgICAgfSxcbiAgICAgIGV4dHJhY3RfYml0czogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgUCA9IHRoaXMuaGVsZF9iaXRzID4+IHRoaXMubnVtX2hlbGRfYml0cyAtIHggJiAoMSA8PCB4KSAtIDE7XG4gICAgICAgIHJldHVybiB0aGlzLm51bV9oZWxkX2JpdHMgLT0geCwgUDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChzLnN0cmVhbV9yZWFkXzFfYnl0ZXModCksIHMuZXh0cmFjdF9iaXRzKDUpLCB0aGlzLmxlbmd0aFNpemVNaW51c09uZSA9IHMuZXh0cmFjdF9iaXRzKDIpLCB0aGlzLnB0bF9wcmVzZW50X2ZsYWcgPSBzLmV4dHJhY3RfYml0cygxKSwgdGhpcy5wdGxfcHJlc2VudF9mbGFnKSB7XG4gICAgICBzLnN0cmVhbV9yZWFkXzJfYnl0ZXModCksIHRoaXMub2xzX2lkeCA9IHMuZXh0cmFjdF9iaXRzKDkpLCB0aGlzLm51bV9zdWJsYXllcnMgPSBzLmV4dHJhY3RfYml0cygzKSwgdGhpcy5jb25zdGFudF9mcmFtZV9yYXRlID0gcy5leHRyYWN0X2JpdHMoMiksIHRoaXMuY2hyb21hX2Zvcm1hdF9pZGMgPSBzLmV4dHJhY3RfYml0cygyKSwgcy5zdHJlYW1fcmVhZF8xX2J5dGVzKHQpLCB0aGlzLmJpdF9kZXB0aF9taW51czggPSBzLmV4dHJhY3RfYml0cygzKSwgcy5leHRyYWN0X2JpdHMoNSk7XG4gICAgICB7XG4gICAgICAgIGlmIChzLnN0cmVhbV9yZWFkXzJfYnl0ZXModCksIHMuZXh0cmFjdF9iaXRzKDIpLCB0aGlzLm51bV9ieXRlc19jb25zdHJhaW50X2luZm8gPSBzLmV4dHJhY3RfYml0cyg2KSwgdGhpcy5nZW5lcmFsX3Byb2ZpbGVfaWRjID0gcy5leHRyYWN0X2JpdHMoNyksIHRoaXMuZ2VuZXJhbF90aWVyX2ZsYWcgPSBzLmV4dHJhY3RfYml0cygxKSwgdGhpcy5nZW5lcmFsX2xldmVsX2lkYyA9IHQucmVhZFVpbnQ4KCksIHMuc3RyZWFtX3JlYWRfMV9ieXRlcyh0KSwgdGhpcy5wdGxfZnJhbWVfb25seV9jb25zdHJhaW50X2ZsYWcgPSBzLmV4dHJhY3RfYml0cygxKSwgdGhpcy5wdGxfbXVsdGlsYXllcl9lbmFibGVkX2ZsYWcgPSBzLmV4dHJhY3RfYml0cygxKSwgdGhpcy5nZW5lcmFsX2NvbnN0cmFpbnRfaW5mbyA9IG5ldyBVaW50OEFycmF5KHRoaXMubnVtX2J5dGVzX2NvbnN0cmFpbnRfaW5mbyksIHRoaXMubnVtX2J5dGVzX2NvbnN0cmFpbnRfaW5mbykge1xuICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCB0aGlzLm51bV9ieXRlc19jb25zdHJhaW50X2luZm8gLSAxOyBlKyspIHtcbiAgICAgICAgICAgIHZhciBvID0gcy5leHRyYWN0X2JpdHMoNik7XG4gICAgICAgICAgICBzLnN0cmVhbV9yZWFkXzFfYnl0ZXModCk7XG4gICAgICAgICAgICB2YXIgYyA9IHMuZXh0cmFjdF9iaXRzKDIpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmFsX2NvbnN0cmFpbnRfaW5mb1tlXSA9IG8gPDwgMiB8IGM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ2VuZXJhbF9jb25zdHJhaW50X2luZm9bdGhpcy5udW1fYnl0ZXNfY29uc3RyYWludF9pbmZvIC0gMV0gPSBzLmV4dHJhY3RfYml0cyg2KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcy5leHRyYWN0X2JpdHMoNik7XG4gICAgICAgIGZvciAocy5zdHJlYW1fcmVhZF8xX2J5dGVzKHQpLCB0aGlzLnB0bF9zdWJsYXllcl9wcmVzZW50X21hc2sgPSAwLCBpID0gdGhpcy5udW1fc3VibGF5ZXJzIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgdSA9IHMuZXh0cmFjdF9iaXRzKDEpO1xuICAgICAgICAgIHRoaXMucHRsX3N1YmxheWVyX3ByZXNlbnRfbWFzayB8PSB1IDw8IGk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gdGhpcy5udW1fc3VibGF5ZXJzOyBpIDw9IDggJiYgdGhpcy5udW1fc3VibGF5ZXJzID4gMTsgKytpKVxuICAgICAgICAgIHMuZXh0cmFjdF9iaXRzKDEpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLm51bV9zdWJsYXllcnMgLSAyOyBpID49IDA7IC0taSlcbiAgICAgICAgICB0aGlzLnB0bF9zdWJsYXllcl9wcmVzZW50X21hc2sgJiAxIDw8IGkgJiYgKHRoaXMuc3VibGF5ZXJfbGV2ZWxfaWRjW2ldID0gdC5yZWFkVWludDgoKSk7XG4gICAgICAgIGlmICh0aGlzLnB0bF9udW1fc3ViX3Byb2ZpbGVzID0gdC5yZWFkVWludDgoKSwgdGhpcy5nZW5lcmFsX3N1Yl9wcm9maWxlX2lkYyA9IFtdLCB0aGlzLnB0bF9udW1fc3ViX3Byb2ZpbGVzKVxuICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCB0aGlzLnB0bF9udW1fc3ViX3Byb2ZpbGVzOyBlKyspXG4gICAgICAgICAgICB0aGlzLmdlbmVyYWxfc3ViX3Byb2ZpbGVfaWRjLnB1c2godC5yZWFkVWludDMyKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXhfcGljdHVyZV93aWR0aCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLm1heF9waWN0dXJlX2hlaWdodCA9IHQucmVhZFVpbnQxNigpLCB0aGlzLmF2Z19mcmFtZV9yYXRlID0gdC5yZWFkVWludDE2KCk7XG4gICAgfVxuICAgIHZhciBfID0gMTIsIGcgPSAxMztcbiAgICB0aGlzLm5hbHVfYXJyYXlzID0gW107XG4gICAgdmFyIHcgPSB0LnJlYWRVaW50OCgpO1xuICAgIGZvciAoZSA9IDA7IGUgPCB3OyBlKyspIHtcbiAgICAgIHZhciBTID0gW107XG4gICAgICB0aGlzLm5hbHVfYXJyYXlzLnB1c2goUyksIHMuc3RyZWFtX3JlYWRfMV9ieXRlcyh0KSwgUy5jb21wbGV0ZW5lc3MgPSBzLmV4dHJhY3RfYml0cygxKSwgcy5leHRyYWN0X2JpdHMoMiksIFMubmFsdV90eXBlID0gcy5leHRyYWN0X2JpdHMoNSk7XG4gICAgICB2YXIgVSA9IDE7XG4gICAgICBmb3IgKFMubmFsdV90eXBlICE9IGcgJiYgUy5uYWx1X3R5cGUgIT0gXyAmJiAoVSA9IHQucmVhZFVpbnQxNigpKSwgaSA9IDA7IGkgPCBVOyBpKyspIHtcbiAgICAgICAgdmFyIEMgPSB0LnJlYWRVaW50MTYoKTtcbiAgICAgICAgUy5wdXNoKHtcbiAgICAgICAgICBkYXRhOiB0LnJlYWRVaW50OEFycmF5KEMpLFxuICAgICAgICAgIGxlbmd0aDogQ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBuLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidnZuQ1wiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBzdHJtLnJlYWRVaW50OCgpO1xuICAgIHRoaXMubGVuZ3RoU2l6ZU1pbnVzT25lID0gZSAmIDM7XG4gIH0pLCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5pc1ZpZGVvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICExO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5pc0F1ZGlvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICExO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5pc1N1YnRpdGxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICExO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5pc01ldGFkYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICExO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5pc0hpbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gITE7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZS5yZXBsYWNlKFwiLlwiLCBcIlwiKTtcbiAgfSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENoYW5uZWxDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRTYW1wbGVSYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH0sIG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmdldFNhbXBsZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfSwgbi5WaXN1YWxTYW1wbGVFbnRyeS5wcm90b3R5cGUuaXNWaWRlbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhMDtcbiAgfSwgbi5WaXN1YWxTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgfSwgbi5WaXN1YWxTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICB9LCBuLkF1ZGlvU2FtcGxlRW50cnkucHJvdG90eXBlLmlzQXVkaW8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gITA7XG4gIH0sIG4uQXVkaW9TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q2hhbm5lbENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbF9jb3VudDtcbiAgfSwgbi5BdWRpb1NhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRTYW1wbGVSYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlcmF0ZTtcbiAgfSwgbi5BdWRpb1NhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRTYW1wbGVTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlc2l6ZTtcbiAgfSwgbi5TdWJ0aXRsZVNhbXBsZUVudHJ5LnByb3RvdHlwZS5pc1N1YnRpdGxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEwO1xuICB9LCBuLk1ldGFkYXRhU2FtcGxlRW50cnkucHJvdG90eXBlLmlzTWV0YWRhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gITA7XG4gIH0sIG4uZGVjaW1hbFRvSGV4ID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHZhciBpID0gTnVtYmVyKHQpLnRvU3RyaW5nKDE2KTtcbiAgICBmb3IgKGUgPSB0eXBlb2YgZSA+IFwidVwiIHx8IGUgPT09IG51bGwgPyBlID0gMiA6IGU7IGkubGVuZ3RoIDwgZTsgKVxuICAgICAgaSA9IFwiMFwiICsgaTtcbiAgICByZXR1cm4gaTtcbiAgfSwgbi5hdmMxU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gbi5hdmMyU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gbi5hdmMzU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gbi5hdmM0U2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYy5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmF2Y0MgPyB0ICsgXCIuXCIgKyBuLmRlY2ltYWxUb0hleCh0aGlzLmF2Y0MuQVZDUHJvZmlsZUluZGljYXRpb24pICsgbi5kZWNpbWFsVG9IZXgodGhpcy5hdmNDLnByb2ZpbGVfY29tcGF0aWJpbGl0eSkgKyBuLmRlY2ltYWxUb0hleCh0aGlzLmF2Y0MuQVZDTGV2ZWxJbmRpY2F0aW9uKSA6IHQ7XG4gIH0sIG4uaGV2MVNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYyA9IG4uaHZjMVNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0LCBlID0gbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5odmNDKSB7XG4gICAgICBzd2l0Y2ggKGUgKz0gXCIuXCIsIHRoaXMuaHZjQy5nZW5lcmFsX3Byb2ZpbGVfc3BhY2UpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGUgKz0gXCJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGUgKz0gXCJBXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBlICs9IFwiQlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZSArPSBcIkNcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGUgKz0gdGhpcy5odmNDLmdlbmVyYWxfcHJvZmlsZV9pZGMsIGUgKz0gXCIuXCI7XG4gICAgICB2YXIgaSA9IHRoaXMuaHZjQy5nZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eSwgcyA9IDA7XG4gICAgICBmb3IgKHQgPSAwOyB0IDwgMzIgJiYgKHMgfD0gaSAmIDEsIHQgIT0gMzEpOyB0KyspXG4gICAgICAgIHMgPDw9IDEsIGkgPj49IDE7XG4gICAgICBlICs9IG4uZGVjaW1hbFRvSGV4KHMsIDApLCBlICs9IFwiLlwiLCB0aGlzLmh2Y0MuZ2VuZXJhbF90aWVyX2ZsYWcgPT09IDAgPyBlICs9IFwiTFwiIDogZSArPSBcIkhcIiwgZSArPSB0aGlzLmh2Y0MuZ2VuZXJhbF9sZXZlbF9pZGM7XG4gICAgICB2YXIgbyA9ICExLCBjID0gXCJcIjtcbiAgICAgIGZvciAodCA9IDU7IHQgPj0gMDsgdC0tKVxuICAgICAgICAodGhpcy5odmNDLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JbdF0gfHwgbykgJiYgKGMgPSBcIi5cIiArIG4uZGVjaW1hbFRvSGV4KHRoaXMuaHZjQy5nZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yW3RdLCAwKSArIGMsIG8gPSAhMCk7XG4gICAgICBlICs9IGM7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBuLnZ2YzFTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBuLnZ2aTFTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCwgZSA9IG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMudnZjQykge1xuICAgICAgZSArPSBcIi5cIiArIHRoaXMudnZjQy5nZW5lcmFsX3Byb2ZpbGVfaWRjLCB0aGlzLnZ2Y0MuZ2VuZXJhbF90aWVyX2ZsYWcgPyBlICs9IFwiLkhcIiA6IGUgKz0gXCIuTFwiLCBlICs9IHRoaXMudnZjQy5nZW5lcmFsX2xldmVsX2lkYztcbiAgICAgIHZhciBpID0gXCJcIjtcbiAgICAgIGlmICh0aGlzLnZ2Y0MuZ2VuZXJhbF9jb25zdHJhaW50X2luZm8pIHtcbiAgICAgICAgdmFyIHMgPSBbXSwgbyA9IDA7XG4gICAgICAgIG8gfD0gdGhpcy52dmNDLnB0bF9mcmFtZV9vbmx5X2NvbnN0cmFpbnQgPDwgNywgbyB8PSB0aGlzLnZ2Y0MucHRsX211bHRpbGF5ZXJfZW5hYmxlZCA8PCA2O1xuICAgICAgICB2YXIgYztcbiAgICAgICAgZm9yICh0ID0gMDsgdCA8IHRoaXMudnZjQy5nZW5lcmFsX2NvbnN0cmFpbnRfaW5mby5sZW5ndGg7ICsrdClcbiAgICAgICAgICBvIHw9IHRoaXMudnZjQy5nZW5lcmFsX2NvbnN0cmFpbnRfaW5mb1t0XSA+PiAyICYgNjMsIHMucHVzaChvKSwgbyAmJiAoYyA9IHQpLCBvID0gdGhpcy52dmNDLmdlbmVyYWxfY29uc3RyYWludF9pbmZvW3RdID4+IDIgJiAzO1xuICAgICAgICBpZiAoYyA9PT0gdm9pZCAwKVxuICAgICAgICAgIGkgPSBcIi5DQVwiO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpID0gXCIuQ1wiO1xuICAgICAgICAgIHZhciB1ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiLCBfID0gMCwgZyA9IDA7XG4gICAgICAgICAgZm9yICh0ID0gMDsgdCA8PSBjOyArK3QpXG4gICAgICAgICAgICBmb3IgKF8gPSBfIDw8IDggfCBzW3RdLCBnICs9IDg7IGcgPj0gNTsgKSB7XG4gICAgICAgICAgICAgIHZhciB3ID0gXyA+PiBnIC0gNSAmIDMxO1xuICAgICAgICAgICAgICBpICs9IHVbd10sIGcgLT0gNSwgXyAmPSAoMSA8PCBnKSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZyAmJiAoXyA8PD0gNSAtIGcsIGkgKz0gdVtfICYgMzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZSArPSBpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgbi5tcDRhU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYy5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLmVzZHMgJiYgdGhpcy5lc2RzLmVzZCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmVzZHMuZXNkLmdldE9USSgpLCBpID0gdGhpcy5lc2RzLmVzZC5nZXRBdWRpb0NvbmZpZygpO1xuICAgICAgcmV0dXJuIHQgKyBcIi5cIiArIG4uZGVjaW1hbFRvSGV4KGUpICsgKGkgPyBcIi5cIiArIGkgOiBcIlwiKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiB0O1xuICB9LCBuLnN0eHRTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG4uU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMubWltZV9mb3JtYXQgPyB0ICsgXCIuXCIgKyB0aGlzLm1pbWVfZm9ybWF0IDogdDtcbiAgfSwgbi52cDA4U2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gbi52cDA5U2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYy5jYWxsKHRoaXMpLCBlID0gdGhpcy52cGNDLmxldmVsO1xuICAgIGUgPT0gMCAmJiAoZSA9IFwiMDBcIik7XG4gICAgdmFyIGkgPSB0aGlzLnZwY0MuYml0RGVwdGg7XG4gICAgcmV0dXJuIGkgPT0gOCAmJiAoaSA9IFwiMDhcIiksIHQgKyBcIi4wXCIgKyB0aGlzLnZwY0MucHJvZmlsZSArIFwiLlwiICsgZSArIFwiLlwiICsgaTtcbiAgfSwgbi5hdjAxU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYy5jYWxsKHRoaXMpLCBlID0gdGhpcy5hdjFDLnNlcV9sZXZlbF9pZHhfMDtcbiAgICBlIDwgMTAgJiYgKGUgPSBcIjBcIiArIGUpO1xuICAgIHZhciBpO1xuICAgIHJldHVybiB0aGlzLmF2MUMuc2VxX3Byb2ZpbGUgPT09IDIgJiYgdGhpcy5hdjFDLmhpZ2hfYml0ZGVwdGggPT09IDEgPyBpID0gdGhpcy5hdjFDLnR3ZWx2ZV9iaXQgPT09IDEgPyBcIjEyXCIgOiBcIjEwXCIgOiB0aGlzLmF2MUMuc2VxX3Byb2ZpbGUgPD0gMiAmJiAoaSA9IHRoaXMuYXYxQy5oaWdoX2JpdGRlcHRoID09PSAxID8gXCIxMFwiIDogXCIwOFwiKSwgdCArIFwiLlwiICsgdGhpcy5hdjFDLnNlcV9wcm9maWxlICsgXCIuXCIgKyBlICsgKHRoaXMuYXYxQy5zZXFfdGllcl8wID8gXCJIXCIgOiBcIk1cIikgKyBcIi5cIiArIGk7XG4gIH0sIG4uQm94LnByb3RvdHlwZS53cml0ZUhlYWRlciA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLnNpemUgKz0gOCwgdGhpcy5zaXplID4gZiAmJiAodGhpcy5zaXplICs9IDgpLCB0aGlzLnR5cGUgPT09IFwidXVpZFwiICYmICh0aGlzLnNpemUgKz0gMTYpLCByLmRlYnVnKFwiQm94V3JpdGVyXCIsIFwiV3JpdGluZyBib3ggXCIgKyB0aGlzLnR5cGUgKyBcIiBvZiBzaXplOiBcIiArIHRoaXMuc2l6ZSArIFwiIGF0IHBvc2l0aW9uIFwiICsgdC5nZXRQb3NpdGlvbigpICsgKGUgfHwgXCJcIikpLCB0aGlzLnNpemUgPiBmID8gdC53cml0ZVVpbnQzMigxKSA6ICh0aGlzLnNpemVQb3NpdGlvbiA9IHQuZ2V0UG9zaXRpb24oKSwgdC53cml0ZVVpbnQzMih0aGlzLnNpemUpKSwgdC53cml0ZVN0cmluZyh0aGlzLnR5cGUsIG51bGwsIDQpLCB0aGlzLnR5cGUgPT09IFwidXVpZFwiICYmIHQud3JpdGVVaW50OEFycmF5KHRoaXMudXVpZCksIHRoaXMuc2l6ZSA+IGYgJiYgdC53cml0ZVVpbnQ2NCh0aGlzLnNpemUpO1xuICB9LCBuLkZ1bGxCb3gucHJvdG90eXBlLndyaXRlSGVhZGVyID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2l6ZSArPSA0LCBuLkJveC5wcm90b3R5cGUud3JpdGVIZWFkZXIuY2FsbCh0aGlzLCB0LCBcIiB2PVwiICsgdGhpcy52ZXJzaW9uICsgXCIgZj1cIiArIHRoaXMuZmxhZ3MpLCB0LndyaXRlVWludDgodGhpcy52ZXJzaW9uKSwgdC53cml0ZVVpbnQyNCh0aGlzLmZsYWdzKTtcbiAgfSwgbi5Cb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudHlwZSA9PT0gXCJtZGF0XCIgPyB0aGlzLmRhdGEgJiYgKHRoaXMuc2l6ZSA9IHRoaXMuZGF0YS5sZW5ndGgsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50OEFycmF5KHRoaXMuZGF0YSkpIDogKHRoaXMuc2l6ZSA9IHRoaXMuZGF0YSA/IHRoaXMuZGF0YS5sZW5ndGggOiAwLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0aGlzLmRhdGEgJiYgdC53cml0ZVVpbnQ4QXJyYXkodGhpcy5kYXRhKSk7XG4gIH0sIG4uQ29udGFpbmVyQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNpemUgPSAwLCB0aGlzLndyaXRlSGVhZGVyKHQpO1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5ib3hlcy5sZW5ndGg7IGUrKylcbiAgICAgIHRoaXMuYm94ZXNbZV0gJiYgKHRoaXMuYm94ZXNbZV0ud3JpdGUodCksIHRoaXMuc2l6ZSArPSB0aGlzLmJveGVzW2VdLnNpemUpO1xuICAgIHIuZGVidWcoXCJCb3hXcml0ZXJcIiwgXCJBZGp1c3RpbmcgYm94IFwiICsgdGhpcy50eXBlICsgXCIgd2l0aCBuZXcgc2l6ZSBcIiArIHRoaXMuc2l6ZSksIHQuYWRqdXN0VWludDMyKHRoaXMuc2l6ZVBvc2l0aW9uLCB0aGlzLnNpemUpO1xuICB9LCBuLlRyYWNrUmVmZXJlbmNlVHlwZUJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zaXplID0gdGhpcy50cmFja19pZHMubGVuZ3RoICogNCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMkFycmF5KHRoaXMudHJhY2tfaWRzKTtcbiAgfSwgbi5hdmNDQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZTtcbiAgICBmb3IgKHRoaXMuc2l6ZSA9IDcsIGUgPSAwOyBlIDwgdGhpcy5TUFMubGVuZ3RoOyBlKyspXG4gICAgICB0aGlzLnNpemUgKz0gMiArIHRoaXMuU1BTW2VdLmxlbmd0aDtcbiAgICBmb3IgKGUgPSAwOyBlIDwgdGhpcy5QUFMubGVuZ3RoOyBlKyspXG4gICAgICB0aGlzLnNpemUgKz0gMiArIHRoaXMuUFBTW2VdLmxlbmd0aDtcbiAgICBmb3IgKHRoaXMuZXh0ICYmICh0aGlzLnNpemUgKz0gdGhpcy5leHQubGVuZ3RoKSwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQ4KHRoaXMuY29uZmlndXJhdGlvblZlcnNpb24pLCB0LndyaXRlVWludDgodGhpcy5BVkNQcm9maWxlSW5kaWNhdGlvbiksIHQud3JpdGVVaW50OCh0aGlzLnByb2ZpbGVfY29tcGF0aWJpbGl0eSksIHQud3JpdGVVaW50OCh0aGlzLkFWQ0xldmVsSW5kaWNhdGlvbiksIHQud3JpdGVVaW50OCh0aGlzLmxlbmd0aFNpemVNaW51c09uZSArIDI1MiksIHQud3JpdGVVaW50OCh0aGlzLlNQUy5sZW5ndGggKyAyMjQpLCBlID0gMDsgZSA8IHRoaXMuU1BTLmxlbmd0aDsgZSsrKVxuICAgICAgdC53cml0ZVVpbnQxNih0aGlzLlNQU1tlXS5sZW5ndGgpLCB0LndyaXRlVWludDhBcnJheSh0aGlzLlNQU1tlXS5uYWx1KTtcbiAgICBmb3IgKHQud3JpdGVVaW50OCh0aGlzLlBQUy5sZW5ndGgpLCBlID0gMDsgZSA8IHRoaXMuUFBTLmxlbmd0aDsgZSsrKVxuICAgICAgdC53cml0ZVVpbnQxNih0aGlzLlBQU1tlXS5sZW5ndGgpLCB0LndyaXRlVWludDhBcnJheSh0aGlzLlBQU1tlXS5uYWx1KTtcbiAgICB0aGlzLmV4dCAmJiB0LndyaXRlVWludDhBcnJheSh0aGlzLmV4dCk7XG4gIH0sIG4uY282NEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgZm9yICh0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCArIDggKiB0aGlzLmNodW5rX29mZnNldHMubGVuZ3RoLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGgpLCBlID0gMDsgZSA8IHRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGg7IGUrKylcbiAgICAgIHQud3JpdGVVaW50NjQodGhpcy5jaHVua19vZmZzZXRzW2VdKTtcbiAgfSwgbi5jc2xnQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCAqIDUsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVJbnQzMih0aGlzLmNvbXBvc2l0aW9uVG9EVFNTaGlmdCksIHQud3JpdGVJbnQzMih0aGlzLmxlYXN0RGVjb2RlVG9EaXNwbGF5RGVsdGEpLCB0LndyaXRlSW50MzIodGhpcy5ncmVhdGVzdERlY29kZVRvRGlzcGxheURlbHRhKSwgdC53cml0ZUludDMyKHRoaXMuY29tcG9zaXRpb25TdGFydFRpbWUpLCB0LndyaXRlSW50MzIodGhpcy5jb21wb3NpdGlvbkVuZFRpbWUpO1xuICB9LCBuLmN0dHNCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIGZvciAodGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQgKyA4ICogdGhpcy5zYW1wbGVfY291bnRzLmxlbmd0aCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9jb3VudHMubGVuZ3RoKSwgZSA9IDA7IGUgPCB0aGlzLnNhbXBsZV9jb3VudHMubGVuZ3RoOyBlKyspXG4gICAgICB0LndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2NvdW50c1tlXSksIHRoaXMudmVyc2lvbiA9PT0gMSA/IHQud3JpdGVJbnQzMih0aGlzLnNhbXBsZV9vZmZzZXRzW2VdKSA6IHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfb2Zmc2V0c1tlXSk7XG4gIH0sIG4uZHJlZkJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5lbnRyaWVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBlKyspXG4gICAgICB0aGlzLmVudHJpZXNbZV0ud3JpdGUodCksIHRoaXMuc2l6ZSArPSB0aGlzLmVudHJpZXNbZV0uc2l6ZTtcbiAgICByLmRlYnVnKFwiQm94V3JpdGVyXCIsIFwiQWRqdXN0aW5nIGJveCBcIiArIHRoaXMudHlwZSArIFwiIHdpdGggbmV3IHNpemUgXCIgKyB0aGlzLnNpemUpLCB0LmFkanVzdFVpbnQzMih0aGlzLnNpemVQb3NpdGlvbiwgdGhpcy5zaXplKTtcbiAgfSwgbi5lbG5nQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gdGhpcy5leHRlbmRlZF9sYW5ndWFnZS5sZW5ndGgsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVTdHJpbmcodGhpcy5leHRlbmRlZF9sYW5ndWFnZSk7XG4gIH0sIG4uZWxzdEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQgKyAxMiAqIHRoaXMuZW50cmllcy5sZW5ndGgsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5lbnRyaWVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBpID0gdGhpcy5lbnRyaWVzW2VdO1xuICAgICAgdC53cml0ZVVpbnQzMihpLnNlZ21lbnRfZHVyYXRpb24pLCB0LndyaXRlSW50MzIoaS5tZWRpYV90aW1lKSwgdC53cml0ZUludDE2KGkubWVkaWFfcmF0ZV9pbnRlZ2VyKSwgdC53cml0ZUludDE2KGkubWVkaWFfcmF0ZV9mcmFjdGlvbik7XG4gICAgfVxuICB9LCBuLmVtc2dCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSA0ICogNCArIHRoaXMubWVzc2FnZV9kYXRhLmxlbmd0aCArICh0aGlzLnNjaGVtZV9pZF91cmkubGVuZ3RoICsgMSkgKyAodGhpcy52YWx1ZS5sZW5ndGggKyAxKSwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZUNTdHJpbmcodGhpcy5zY2hlbWVfaWRfdXJpKSwgdC53cml0ZUNTdHJpbmcodGhpcy52YWx1ZSksIHQud3JpdGVVaW50MzIodGhpcy50aW1lc2NhbGUpLCB0LndyaXRlVWludDMyKHRoaXMucHJlc2VudGF0aW9uX3RpbWVfZGVsdGEpLCB0LndyaXRlVWludDMyKHRoaXMuZXZlbnRfZHVyYXRpb24pLCB0LndyaXRlVWludDMyKHRoaXMuaWQpLCB0LndyaXRlVWludDhBcnJheSh0aGlzLm1lc3NhZ2VfZGF0YSk7XG4gIH0sIG4uZnR5cEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zaXplID0gOCArIDQgKiB0aGlzLmNvbXBhdGlibGVfYnJhbmRzLmxlbmd0aCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVN0cmluZyh0aGlzLm1ham9yX2JyYW5kLCBudWxsLCA0KSwgdC53cml0ZVVpbnQzMih0aGlzLm1pbm9yX3ZlcnNpb24pO1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5jb21wYXRpYmxlX2JyYW5kcy5sZW5ndGg7IGUrKylcbiAgICAgIHQud3JpdGVTdHJpbmcodGhpcy5jb21wYXRpYmxlX2JyYW5kc1tlXSwgbnVsbCwgNCk7XG4gIH0sIG4uaGRsckJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zaXplID0gNSAqIDQgKyB0aGlzLm5hbWUubGVuZ3RoICsgMSwgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVTdHJpbmcodGhpcy5oYW5kbGVyLCBudWxsLCA0KSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZUNTdHJpbmcodGhpcy5uYW1lKTtcbiAgfSwgbi5raW5kQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gdGhpcy5zY2hlbWVVUkkubGVuZ3RoICsgMSArICh0aGlzLnZhbHVlLmxlbmd0aCArIDEpLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlQ1N0cmluZyh0aGlzLnNjaGVtZVVSSSksIHQud3JpdGVDU3RyaW5nKHRoaXMudmFsdWUpO1xuICB9LCBuLm1kaGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2l6ZSA9IDQgKiA0ICsgMiAqIDIsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMuY3JlYXRpb25fdGltZSksIHQud3JpdGVVaW50MzIodGhpcy5tb2RpZmljYXRpb25fdGltZSksIHQud3JpdGVVaW50MzIodGhpcy50aW1lc2NhbGUpLCB0LndyaXRlVWludDMyKHRoaXMuZHVyYXRpb24pLCB0LndyaXRlVWludDE2KHRoaXMubGFuZ3VhZ2UpLCB0LndyaXRlVWludDE2KDApO1xuICB9LCBuLm1laGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSA0LCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMuZnJhZ21lbnRfZHVyYXRpb24pO1xuICB9LCBuLm1maGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSA0LCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMuc2VxdWVuY2VfbnVtYmVyKTtcbiAgfSwgbi5tdmhkQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gMjMgKiA0ICsgMiAqIDIsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5jcmVhdGlvbl90aW1lKSwgdC53cml0ZVVpbnQzMih0aGlzLm1vZGlmaWNhdGlvbl90aW1lKSwgdC53cml0ZVVpbnQzMih0aGlzLnRpbWVzY2FsZSksIHQud3JpdGVVaW50MzIodGhpcy5kdXJhdGlvbiksIHQud3JpdGVVaW50MzIodGhpcy5yYXRlKSwgdC53cml0ZVVpbnQxNih0aGlzLnZvbHVtZSA8PCA4KSwgdC53cml0ZVVpbnQxNigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMkFycmF5KHRoaXMubWF0cml4KSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMigwKSwgdC53cml0ZVVpbnQzMih0aGlzLm5leHRfdHJhY2tfaWQpO1xuICB9LCBuLlNhbXBsZUVudHJ5LnByb3RvdHlwZS53cml0ZUhlYWRlciA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNpemUgPSA4LCBuLkJveC5wcm90b3R5cGUud3JpdGVIZWFkZXIuY2FsbCh0aGlzLCB0KSwgdC53cml0ZVVpbnQ4KDApLCB0LndyaXRlVWludDgoMCksIHQud3JpdGVVaW50OCgwKSwgdC53cml0ZVVpbnQ4KDApLCB0LndyaXRlVWludDgoMCksIHQud3JpdGVVaW50OCgwKSwgdC53cml0ZVVpbnQxNih0aGlzLmRhdGFfcmVmZXJlbmNlX2luZGV4KTtcbiAgfSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUud3JpdGVGb290ZXIgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmJveGVzLmxlbmd0aDsgZSsrKVxuICAgICAgdGhpcy5ib3hlc1tlXS53cml0ZSh0KSwgdGhpcy5zaXplICs9IHRoaXMuYm94ZXNbZV0uc2l6ZTtcbiAgICByLmRlYnVnKFwiQm94V3JpdGVyXCIsIFwiQWRqdXN0aW5nIGJveCBcIiArIHRoaXMudHlwZSArIFwiIHdpdGggbmV3IHNpemUgXCIgKyB0aGlzLnNpemUpLCB0LmFkanVzdFVpbnQzMih0aGlzLnNpemVQb3NpdGlvbiwgdGhpcy5zaXplKTtcbiAgfSwgbi5TYW1wbGVFbnRyeS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQ4QXJyYXkodGhpcy5kYXRhKSwgdGhpcy5zaXplICs9IHRoaXMuZGF0YS5sZW5ndGgsIHIuZGVidWcoXCJCb3hXcml0ZXJcIiwgXCJBZGp1c3RpbmcgYm94IFwiICsgdGhpcy50eXBlICsgXCIgd2l0aCBuZXcgc2l6ZSBcIiArIHRoaXMuc2l6ZSksIHQuYWRqdXN0VWludDMyKHRoaXMuc2l6ZVBvc2l0aW9uLCB0aGlzLnNpemUpO1xuICB9LCBuLlZpc3VhbFNhbXBsZUVudHJ5LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLndyaXRlSGVhZGVyKHQpLCB0aGlzLnNpemUgKz0gMiAqIDcgKyA2ICogNCArIDMyLCB0LndyaXRlVWludDE2KDApLCB0LndyaXRlVWludDE2KDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDMyKDApLCB0LndyaXRlVWludDE2KHRoaXMud2lkdGgpLCB0LndyaXRlVWludDE2KHRoaXMuaGVpZ2h0KSwgdC53cml0ZVVpbnQzMih0aGlzLmhvcml6cmVzb2x1dGlvbiksIHQud3JpdGVVaW50MzIodGhpcy52ZXJ0cmVzb2x1dGlvbiksIHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVVaW50MTYodGhpcy5mcmFtZV9jb3VudCksIHQud3JpdGVVaW50OChNYXRoLm1pbigzMSwgdGhpcy5jb21wcmVzc29ybmFtZS5sZW5ndGgpKSwgdC53cml0ZVN0cmluZyh0aGlzLmNvbXByZXNzb3JuYW1lLCBudWxsLCAzMSksIHQud3JpdGVVaW50MTYodGhpcy5kZXB0aCksIHQud3JpdGVJbnQxNigtMSksIHRoaXMud3JpdGVGb290ZXIodCk7XG4gIH0sIG4uQXVkaW9TYW1wbGVFbnRyeS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy53cml0ZUhlYWRlcih0KSwgdGhpcy5zaXplICs9IDIgKiA0ICsgMyAqIDQsIHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVVaW50MTYodGhpcy5jaGFubmVsX2NvdW50KSwgdC53cml0ZVVpbnQxNih0aGlzLnNhbXBsZXNpemUpLCB0LndyaXRlVWludDE2KDApLCB0LndyaXRlVWludDE2KDApLCB0LndyaXRlVWludDMyKHRoaXMuc2FtcGxlcmF0ZSA8PCAxNiksIHRoaXMud3JpdGVGb290ZXIodCk7XG4gIH0sIG4uc3RwcFNhbXBsZUVudHJ5LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLndyaXRlSGVhZGVyKHQpLCB0aGlzLnNpemUgKz0gdGhpcy5uYW1lc3BhY2UubGVuZ3RoICsgMSArIHRoaXMuc2NoZW1hX2xvY2F0aW9uLmxlbmd0aCArIDEgKyB0aGlzLmF1eGlsaWFyeV9taW1lX3R5cGVzLmxlbmd0aCArIDEsIHQud3JpdGVDU3RyaW5nKHRoaXMubmFtZXNwYWNlKSwgdC53cml0ZUNTdHJpbmcodGhpcy5zY2hlbWFfbG9jYXRpb24pLCB0LndyaXRlQ1N0cmluZyh0aGlzLmF1eGlsaWFyeV9taW1lX3R5cGVzKSwgdGhpcy53cml0ZUZvb3Rlcih0KTtcbiAgfSwgbi5TYW1wbGVHcm91cEVudHJ5LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0LndyaXRlVWludDhBcnJheSh0aGlzLmRhdGEpO1xuICB9LCBuLnNiZ3BCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDEsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSAxMiArIDggKiB0aGlzLmVudHJpZXMubGVuZ3RoLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlU3RyaW5nKHRoaXMuZ3JvdXBpbmdfdHlwZSwgbnVsbCwgNCksIHQud3JpdGVVaW50MzIodGhpcy5ncm91cGluZ190eXBlX3BhcmFtZXRlciksIHQud3JpdGVVaW50MzIodGhpcy5lbnRyaWVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBpID0gdGhpcy5lbnRyaWVzW2VdO1xuICAgICAgdC53cml0ZUludDMyKGkuc2FtcGxlX2NvdW50KSwgdC53cml0ZUludDMyKGkuZ3JvdXBfZGVzY3JpcHRpb25faW5kZXgpO1xuICAgIH1cbiAgfSwgbi5zZ3BkQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaTtcbiAgICBmb3IgKHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSAxMiwgZSA9IDA7IGUgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBlKyspXG4gICAgICBpID0gdGhpcy5lbnRyaWVzW2VdLCB0aGlzLnZlcnNpb24gPT09IDEgJiYgKHRoaXMuZGVmYXVsdF9sZW5ndGggPT09IDAgJiYgKHRoaXMuc2l6ZSArPSA0KSwgdGhpcy5zaXplICs9IGkuZGF0YS5sZW5ndGgpO1xuICAgIGZvciAodGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVN0cmluZyh0aGlzLmdyb3VwaW5nX3R5cGUsIG51bGwsIDQpLCB0aGlzLnZlcnNpb24gPT09IDEgJiYgdC53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfbGVuZ3RoKSwgdGhpcy52ZXJzaW9uID49IDIgJiYgdC53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4KSwgdC53cml0ZVVpbnQzMih0aGlzLmVudHJpZXMubGVuZ3RoKSwgZSA9IDA7IGUgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBlKyspXG4gICAgICBpID0gdGhpcy5lbnRyaWVzW2VdLCB0aGlzLnZlcnNpb24gPT09IDEgJiYgdGhpcy5kZWZhdWx0X2xlbmd0aCA9PT0gMCAmJiB0LndyaXRlVWludDMyKGkuZGVzY3JpcHRpb25fbGVuZ3RoKSwgaS53cml0ZSh0KTtcbiAgfSwgbi5zaWR4Qm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCAqIDQgKyAyICsgMiArIDEyICogdGhpcy5yZWZlcmVuY2VzLmxlbmd0aCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLnJlZmVyZW5jZV9JRCksIHQud3JpdGVVaW50MzIodGhpcy50aW1lc2NhbGUpLCB0LndyaXRlVWludDMyKHRoaXMuZWFybGllc3RfcHJlc2VudGF0aW9uX3RpbWUpLCB0LndyaXRlVWludDMyKHRoaXMuZmlyc3Rfb2Zmc2V0KSwgdC53cml0ZVVpbnQxNigwKSwgdC53cml0ZVVpbnQxNih0aGlzLnJlZmVyZW5jZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMucmVmZXJlbmNlcy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIGkgPSB0aGlzLnJlZmVyZW5jZXNbZV07XG4gICAgICB0LndyaXRlVWludDMyKGkucmVmZXJlbmNlX3R5cGUgPDwgMzEgfCBpLnJlZmVyZW5jZWRfc2l6ZSksIHQud3JpdGVVaW50MzIoaS5zdWJzZWdtZW50X2R1cmF0aW9uKSwgdC53cml0ZVVpbnQzMihpLnN0YXJ0c193aXRoX1NBUCA8PCAzMSB8IGkuU0FQX3R5cGUgPDwgMjggfCBpLlNBUF9kZWx0YV90aW1lKTtcbiAgICB9XG4gIH0sIG4uc21oZEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDEsIHRoaXMuc2l6ZSA9IDQsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MTYodGhpcy5iYWxhbmNlKSwgdC53cml0ZVVpbnQxNigwKTtcbiAgfSwgbi5zdGNvQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCArIDQgKiB0aGlzLmNodW5rX29mZnNldHMubGVuZ3RoLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGgpLCB0LndyaXRlVWludDMyQXJyYXkodGhpcy5jaHVua19vZmZzZXRzKTtcbiAgfSwgbi5zdHNjQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZTtcbiAgICBmb3IgKHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSA0ICsgMTIgKiB0aGlzLmZpcnN0X2NodW5rLmxlbmd0aCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLmZpcnN0X2NodW5rLmxlbmd0aCksIGUgPSAwOyBlIDwgdGhpcy5maXJzdF9jaHVuay5sZW5ndGg7IGUrKylcbiAgICAgIHQud3JpdGVVaW50MzIodGhpcy5maXJzdF9jaHVua1tlXSksIHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVzX3Blcl9jaHVua1tlXSksIHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhbZV0pO1xuICB9LCBuLnN0c2RCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIGZvciAodGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDAsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5lbnRyaWVzLmxlbmd0aCksIHRoaXMuc2l6ZSArPSA0LCBlID0gMDsgZSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGUrKylcbiAgICAgIHRoaXMuZW50cmllc1tlXS53cml0ZSh0KSwgdGhpcy5zaXplICs9IHRoaXMuZW50cmllc1tlXS5zaXplO1xuICAgIHIuZGVidWcoXCJCb3hXcml0ZXJcIiwgXCJBZGp1c3RpbmcgYm94IFwiICsgdGhpcy50eXBlICsgXCIgd2l0aCBuZXcgc2l6ZSBcIiArIHRoaXMuc2l6ZSksIHQuYWRqdXN0VWludDMyKHRoaXMuc2l6ZVBvc2l0aW9uLCB0aGlzLnNpemUpO1xuICB9LCBuLnN0c2hCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIGZvciAodGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQgKyA4ICogdGhpcy5zaGFkb3dlZF9zYW1wbGVfbnVtYmVycy5sZW5ndGgsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5zaGFkb3dlZF9zYW1wbGVfbnVtYmVycy5sZW5ndGgpLCBlID0gMDsgZSA8IHRoaXMuc2hhZG93ZWRfc2FtcGxlX251bWJlcnMubGVuZ3RoOyBlKyspXG4gICAgICB0LndyaXRlVWludDMyKHRoaXMuc2hhZG93ZWRfc2FtcGxlX251bWJlcnNbZV0pLCB0LndyaXRlVWludDMyKHRoaXMuc3luY19zYW1wbGVfbnVtYmVyc1tlXSk7XG4gIH0sIG4uc3Rzc0JveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQgKyA0ICogdGhpcy5zYW1wbGVfbnVtYmVycy5sZW5ndGgsIHRoaXMud3JpdGVIZWFkZXIodCksIHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfbnVtYmVycy5sZW5ndGgpLCB0LndyaXRlVWludDMyQXJyYXkodGhpcy5zYW1wbGVfbnVtYmVycyk7XG4gIH0sIG4uc3RzekJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGkgPSAhMDtcbiAgICBpZiAodGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2FtcGxlX3NpemVzLmxlbmd0aCA+IDApXG4gICAgICBmb3IgKGUgPSAwOyBlICsgMSA8IHRoaXMuc2FtcGxlX3NpemVzLmxlbmd0aDsgKVxuICAgICAgICBpZiAodGhpcy5zYW1wbGVfc2l6ZXNbZSArIDFdICE9PSB0aGlzLnNhbXBsZV9zaXplc1swXSkge1xuICAgICAgICAgIGkgPSAhMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZSsrO1xuICAgIGVsc2VcbiAgICAgIGkgPSAhMTtcbiAgICB0aGlzLnNpemUgPSA4LCBpIHx8ICh0aGlzLnNpemUgKz0gNCAqIHRoaXMuc2FtcGxlX3NpemVzLmxlbmd0aCksIHRoaXMud3JpdGVIZWFkZXIodCksIGkgPyB0LndyaXRlVWludDMyKHRoaXMuc2FtcGxlX3NpemVzWzBdKSA6IHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfc2l6ZXMubGVuZ3RoKSwgaSB8fCB0LndyaXRlVWludDMyQXJyYXkodGhpcy5zYW1wbGVfc2l6ZXMpO1xuICB9LCBuLnN0dHNCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIGZvciAodGhpcy52ZXJzaW9uID0gMCwgdGhpcy5mbGFncyA9IDAsIHRoaXMuc2l6ZSA9IDQgKyA4ICogdGhpcy5zYW1wbGVfY291bnRzLmxlbmd0aCwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9jb3VudHMubGVuZ3RoKSwgZSA9IDA7IGUgPCB0aGlzLnNhbXBsZV9jb3VudHMubGVuZ3RoOyBlKyspXG4gICAgICB0LndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2NvdW50c1tlXSksIHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfZGVsdGFzW2VdKTtcbiAgfSwgbi50ZmR0Qm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG4gICAgdGhpcy52ZXJzaW9uID0gdGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lID4gZSA/IDEgOiAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gNCwgdGhpcy52ZXJzaW9uID09PSAxICYmICh0aGlzLnNpemUgKz0gNCksIHRoaXMud3JpdGVIZWFkZXIodCksIHRoaXMudmVyc2lvbiA9PT0gMSA/IHQud3JpdGVVaW50NjQodGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lKSA6IHQud3JpdGVVaW50MzIodGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lKTtcbiAgfSwgbi50ZmhkQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLnNpemUgPSA0LCB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfQkFTRV9EQVRBX09GRlNFVCAmJiAodGhpcy5zaXplICs9IDgpLCB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX0RFU0MgJiYgKHRoaXMuc2l6ZSArPSA0KSwgdGhpcy5mbGFncyAmIG4uVEZIRF9GTEFHX1NBTVBMRV9EVVIgJiYgKHRoaXMuc2l6ZSArPSA0KSwgdGhpcy5mbGFncyAmIG4uVEZIRF9GTEFHX1NBTVBMRV9TSVpFICYmICh0aGlzLnNpemUgKz0gNCksIHRoaXMuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfRkxBR1MgJiYgKHRoaXMuc2l6ZSArPSA0KSwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLnRyYWNrX2lkKSwgdGhpcy5mbGFncyAmIG4uVEZIRF9GTEFHX0JBU0VfREFUQV9PRkZTRVQgJiYgdC53cml0ZVVpbnQ2NCh0aGlzLmJhc2VfZGF0YV9vZmZzZXQpLCB0aGlzLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX0RFU0MgJiYgdC53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4KSwgdGhpcy5mbGFncyAmIG4uVEZIRF9GTEFHX1NBTVBMRV9EVVIgJiYgdC53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uKSwgdGhpcy5mbGFncyAmIG4uVEZIRF9GTEFHX1NBTVBMRV9TSVpFICYmIHQud3JpdGVVaW50MzIodGhpcy5kZWZhdWx0X3NhbXBsZV9zaXplKSwgdGhpcy5mbGFncyAmIG4uVEZIRF9GTEFHX1NBTVBMRV9GTEFHUyAmJiB0LndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfZmxhZ3MpO1xuICB9LCBuLnRraGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuc2l6ZSA9IDQgKiAxOCArIDIgKiA0LCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDMyKHRoaXMuY3JlYXRpb25fdGltZSksIHQud3JpdGVVaW50MzIodGhpcy5tb2RpZmljYXRpb25fdGltZSksIHQud3JpdGVVaW50MzIodGhpcy50cmFja19pZCksIHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVVaW50MzIodGhpcy5kdXJhdGlvbiksIHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVVaW50MzIoMCksIHQud3JpdGVJbnQxNih0aGlzLmxheWVyKSwgdC53cml0ZUludDE2KHRoaXMuYWx0ZXJuYXRlX2dyb3VwKSwgdC53cml0ZUludDE2KHRoaXMudm9sdW1lIDw8IDgpLCB0LndyaXRlVWludDE2KDApLCB0LndyaXRlSW50MzJBcnJheSh0aGlzLm1hdHJpeCksIHQud3JpdGVVaW50MzIodGhpcy53aWR0aCksIHQud3JpdGVVaW50MzIodGhpcy5oZWlnaHQpO1xuICB9LCBuLnRyZXhCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAwLCB0aGlzLnNpemUgPSA0ICogNSwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLnRyYWNrX2lkKSwgdC53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4KSwgdC53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uKSwgdC53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfc2FtcGxlX3NpemUpLCB0LndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfZmxhZ3MpO1xuICB9LCBuLnRydW5Cb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuc2l6ZSA9IDQsIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfREFUQV9PRkZTRVQgJiYgKHRoaXMuc2l6ZSArPSA0KSwgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19GSVJTVF9GTEFHICYmICh0aGlzLnNpemUgKz0gNCksIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfRFVSQVRJT04gJiYgKHRoaXMuc2l6ZSArPSA0ICogdGhpcy5zYW1wbGVfZHVyYXRpb24ubGVuZ3RoKSwgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19TSVpFICYmICh0aGlzLnNpemUgKz0gNCAqIHRoaXMuc2FtcGxlX3NpemUubGVuZ3RoKSwgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19GTEFHUyAmJiAodGhpcy5zaXplICs9IDQgKiB0aGlzLnNhbXBsZV9mbGFncy5sZW5ndGgpLCB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX0NUU19PRkZTRVQgJiYgKHRoaXMuc2l6ZSArPSA0ICogdGhpcy5zYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXQubGVuZ3RoKSwgdGhpcy53cml0ZUhlYWRlcih0KSwgdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9jb3VudCksIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfREFUQV9PRkZTRVQgJiYgKHRoaXMuZGF0YV9vZmZzZXRfcG9zaXRpb24gPSB0LmdldFBvc2l0aW9uKCksIHQud3JpdGVJbnQzMih0aGlzLmRhdGFfb2Zmc2V0KSksIHRoaXMuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfRklSU1RfRkxBRyAmJiB0LndyaXRlVWludDMyKHRoaXMuZmlyc3Rfc2FtcGxlX2ZsYWdzKTtcbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuc2FtcGxlX2NvdW50OyBlKyspXG4gICAgICB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX0RVUkFUSU9OICYmIHQud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfZHVyYXRpb25bZV0pLCB0aGlzLmZsYWdzICYgbi5UUlVOX0ZMQUdTX1NJWkUgJiYgdC53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9zaXplW2VdKSwgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19GTEFHUyAmJiB0LndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2ZsYWdzW2VdKSwgdGhpcy5mbGFncyAmIG4uVFJVTl9GTEFHU19DVFNfT0ZGU0VUICYmICh0aGlzLnZlcnNpb24gPT09IDAgPyB0LndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0W2VdKSA6IHQud3JpdGVJbnQzMih0aGlzLnNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFtlXSkpO1xuICB9LCBuW1widXJsIEJveFwiXS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5sb2NhdGlvbiA/ICh0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gdGhpcy5sb2NhdGlvbi5sZW5ndGggKyAxKSA6ICh0aGlzLmZsYWdzID0gMSwgdGhpcy5zaXplID0gMCksIHRoaXMud3JpdGVIZWFkZXIodCksIHRoaXMubG9jYXRpb24gJiYgdC53cml0ZUNTdHJpbmcodGhpcy5sb2NhdGlvbik7XG4gIH0sIG5bXCJ1cm4gQm94XCJdLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zaXplID0gdGhpcy5uYW1lLmxlbmd0aCArIDEgKyAodGhpcy5sb2NhdGlvbiA/IHRoaXMubG9jYXRpb24ubGVuZ3RoICsgMSA6IDApLCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlQ1N0cmluZyh0aGlzLm5hbWUpLCB0aGlzLmxvY2F0aW9uICYmIHQud3JpdGVDU3RyaW5nKHRoaXMubG9jYXRpb24pO1xuICB9LCBuLnZtaGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMuZmxhZ3MgPSAxLCB0aGlzLnNpemUgPSA4LCB0aGlzLndyaXRlSGVhZGVyKHQpLCB0LndyaXRlVWludDE2KHRoaXMuZ3JhcGhpY3Ntb2RlKSwgdC53cml0ZVVpbnQxNkFycmF5KHRoaXMub3Bjb2xvcik7XG4gIH0sIG4uY3R0c0JveC5wcm90b3R5cGUudW5wYWNrID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpLCBzO1xuICAgIGZvciAocyA9IDAsIGUgPSAwOyBlIDwgdGhpcy5zYW1wbGVfY291bnRzLmxlbmd0aDsgZSsrKVxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2FtcGxlX2NvdW50c1tlXTsgaSsrKVxuICAgICAgICB0W3NdLnB0cyA9IHRbc10uZHRzICsgdGhpcy5zYW1wbGVfb2Zmc2V0c1tlXSwgcysrO1xuICB9LCBuLnN0dHNCb3gucHJvdG90eXBlLnVucGFjayA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSwgcztcbiAgICBmb3IgKHMgPSAwLCBlID0gMDsgZSA8IHRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGg7IGUrKylcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNhbXBsZV9jb3VudHNbZV07IGkrKylcbiAgICAgICAgcyA9PT0gMCA/IHRbc10uZHRzID0gMCA6IHRbc10uZHRzID0gdFtzIC0gMV0uZHRzICsgdGhpcy5zYW1wbGVfZGVsdGFzW2VdLCBzKys7XG4gIH0sIG4uc3Rjb0JveC5wcm90b3R5cGUudW5wYWNrID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIGZvciAoZSA9IDA7IGUgPCB0aGlzLmNodW5rX29mZnNldHMubGVuZ3RoOyBlKyspXG4gICAgICB0W2VdLm9mZnNldCA9IHRoaXMuY2h1bmtfb2Zmc2V0c1tlXTtcbiAgfSwgbi5zdHNjQm94LnByb3RvdHlwZS51bnBhY2sgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGksIHMsIG8sIGM7XG4gICAgZm9yIChvID0gMCwgYyA9IDAsIGUgPSAwOyBlIDwgdGhpcy5maXJzdF9jaHVuay5sZW5ndGg7IGUrKylcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAoZSArIDEgPCB0aGlzLmZpcnN0X2NodW5rLmxlbmd0aCA/IHRoaXMuZmlyc3RfY2h1bmtbZSArIDFdIDogMSAvIDApOyBpKyspXG4gICAgICAgIGZvciAoYysrLCBzID0gMDsgcyA8IHRoaXMuc2FtcGxlc19wZXJfY2h1bmtbZV07IHMrKykge1xuICAgICAgICAgIGlmICh0W29dKVxuICAgICAgICAgICAgdFtvXS5kZXNjcmlwdGlvbl9pbmRleCA9IHRoaXMuc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4W2VdLCB0W29dLmNodW5rX2luZGV4ID0gYztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgbysrO1xuICAgICAgICB9XG4gIH0sIG4uc3RzekJveC5wcm90b3R5cGUudW5wYWNrID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlO1xuICAgIGZvciAoZSA9IDA7IGUgPCB0aGlzLnNhbXBsZV9zaXplcy5sZW5ndGg7IGUrKylcbiAgICAgIHRbZV0uc2l6ZSA9IHRoaXMuc2FtcGxlX3NpemVzW2VdO1xuICB9LCBuLkRJRkZfQk9YRVNfUFJPUF9OQU1FUyA9IFtcbiAgICBcImJveGVzXCIsXG4gICAgXCJlbnRyaWVzXCIsXG4gICAgXCJyZWZlcmVuY2VzXCIsXG4gICAgXCJzdWJzYW1wbGVzXCIsXG4gICAgXCJpdGVtc1wiLFxuICAgIFwiaXRlbV9pbmZvc1wiLFxuICAgIFwiZXh0ZW50c1wiLFxuICAgIFwiYXNzb2NpYXRpb25zXCIsXG4gICAgXCJzdWJzZWdtZW50c1wiLFxuICAgIFwicmFuZ2VzXCIsXG4gICAgXCJzZWVrTGlzdHNcIixcbiAgICBcInNlZWtQb2ludHNcIixcbiAgICBcImVzZFwiLFxuICAgIFwibGV2ZWxzXCJcbiAgXSwgbi5ESUZGX1BSSU1JVElWRV9BUlJBWV9QUk9QX05BTUVTID0gW1xuICAgIFwiY29tcGF0aWJsZV9icmFuZHNcIixcbiAgICBcIm1hdHJpeFwiLFxuICAgIFwib3Bjb2xvclwiLFxuICAgIFwic2FtcGxlX2NvdW50c1wiLFxuICAgIFwic2FtcGxlX2NvdW50c1wiLFxuICAgIFwic2FtcGxlX2RlbHRhc1wiLFxuICAgIFwiZmlyc3RfY2h1bmtcIixcbiAgICBcInNhbXBsZXNfcGVyX2NodW5rXCIsXG4gICAgXCJzYW1wbGVfc2l6ZXNcIixcbiAgICBcImNodW5rX29mZnNldHNcIixcbiAgICBcInNhbXBsZV9vZmZzZXRzXCIsXG4gICAgXCJzYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcIixcbiAgICBcInNhbXBsZV9kdXJhdGlvblwiXG4gIF0sIG4uYm94RXF1YWxGaWVsZHMgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgaWYgKHQgJiYgIWUpIHJldHVybiAhMTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgaW4gdClcbiAgICAgIGlmICghKG4uRElGRl9CT1hFU19QUk9QX05BTUVTLmluZGV4T2YoaSkgPiAtMSkpIHtcbiAgICAgICAgaWYgKHRbaV0gaW5zdGFuY2VvZiBuLkJveCB8fCBlW2ldIGluc3RhbmNlb2Ygbi5Cb3gpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2YgdFtpXSA+IFwidVwiIHx8IHR5cGVvZiBlW2ldID4gXCJ1XCIpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2YgdFtpXSA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGVbaV0gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAodC5zdWJCb3hOYW1lcyAmJiB0LnN1YkJveE5hbWVzLmluZGV4T2YoaS5zbGljZSgwLCA0KSkgPiAtMSB8fCBlLnN1YkJveE5hbWVzICYmIGUuc3ViQm94TmFtZXMuaW5kZXhPZihpLnNsaWNlKDAsIDQpKSA+IC0xKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaSA9PT0gXCJkYXRhXCIgfHwgaSA9PT0gXCJzdGFydFwiIHx8IGkgPT09IFwic2l6ZVwiIHx8IGkgPT09IFwiY3JlYXRpb25fdGltZVwiIHx8IGkgPT09IFwibW9kaWZpY2F0aW9uX3RpbWVcIilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKG4uRElGRl9QUklNSVRJVkVfQVJSQVlfUFJPUF9OQU1FUy5pbmRleE9mKGkpID4gLTEpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0W2ldICE9PSBlW2ldKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH0sIG4uYm94RXF1YWwgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgaWYgKCFuLmJveEVxdWFsRmllbGRzKHQsIGUpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbi5ESUZGX0JPWEVTX1BST1BfTkFNRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzID0gbi5ESUZGX0JPWEVTX1BST1BfTkFNRVNbaV07XG4gICAgICBpZiAodFtzXSAmJiBlW3NdICYmICFuLmJveEVxdWFsKHRbc10sIGVbc10pKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfTtcbiAgdmFyIHYgPSBmdW5jdGlvbigpIHtcbiAgfTtcbiAgdi5wcm90b3R5cGUucGFyc2VTYW1wbGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB7fSwgaTtcbiAgICBlLnJlc291cmNlcyA9IFtdO1xuICAgIHZhciBzID0gbmV3IGgodC5kYXRhLmJ1ZmZlcik7XG4gICAgaWYgKCF0LnN1YnNhbXBsZXMgfHwgdC5zdWJzYW1wbGVzLmxlbmd0aCA9PT0gMClcbiAgICAgIGUuZG9jdW1lbnRTdHJpbmcgPSBzLnJlYWRTdHJpbmcodC5kYXRhLmxlbmd0aCk7XG4gICAgZWxzZSBpZiAoZS5kb2N1bWVudFN0cmluZyA9IHMucmVhZFN0cmluZyh0LnN1YnNhbXBsZXNbMF0uc2l6ZSksIHQuc3Vic2FtcGxlcy5sZW5ndGggPiAxKVxuICAgICAgZm9yIChpID0gMTsgaSA8IHQuc3Vic2FtcGxlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgZS5yZXNvdXJjZXNbaV0gPSBzLnJlYWRVaW50OEFycmF5KHQuc3Vic2FtcGxlc1tpXS5zaXplKTtcbiAgICByZXR1cm4gdHlwZW9mIERPTVBhcnNlciA8IFwidVwiICYmIChlLmRvY3VtZW50ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhlLmRvY3VtZW50U3RyaW5nLCBcImFwcGxpY2F0aW9uL3htbFwiKSksIGU7XG4gIH07XG4gIHZhciBiID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIGIucHJvdG90eXBlLnBhcnNlU2FtcGxlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpID0gbmV3IGgodC5kYXRhLmJ1ZmZlcik7XG4gICAgcmV0dXJuIGUgPSBpLnJlYWRTdHJpbmcodC5kYXRhLmxlbmd0aCksIGU7XG4gIH0sIGIucHJvdG90eXBlLnBhcnNlQ29uZmlnID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpID0gbmV3IGgodC5idWZmZXIpO1xuICAgIHJldHVybiBpLnJlYWRVaW50MzIoKSwgZSA9IGkucmVhZENTdHJpbmcoKSwgZTtcbiAgfSwgbC5YTUxTdWJ0aXRsZWluNFBhcnNlciA9IHYsIGwuVGV4dGluNFBhcnNlciA9IGI7XG4gIHZhciB5ID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3RyZWFtID0gdCB8fCBuZXcgZCgpLCB0aGlzLmJveGVzID0gW10sIHRoaXMubWRhdHMgPSBbXSwgdGhpcy5tb29mcyA9IFtdLCB0aGlzLmlzUHJvZ3Jlc3NpdmUgPSAhMSwgdGhpcy5tb292U3RhcnRGb3VuZCA9ICExLCB0aGlzLm9uTW9vdlN0YXJ0ID0gbnVsbCwgdGhpcy5tb292U3RhcnRTZW50ID0gITEsIHRoaXMub25SZWFkeSA9IG51bGwsIHRoaXMucmVhZHlTZW50ID0gITEsIHRoaXMub25TZWdtZW50ID0gbnVsbCwgdGhpcy5vblNhbXBsZXMgPSBudWxsLCB0aGlzLm9uRXJyb3IgPSBudWxsLCB0aGlzLnNhbXBsZUxpc3RCdWlsdCA9ICExLCB0aGlzLmZyYWdtZW50ZWRUcmFja3MgPSBbXSwgdGhpcy5leHRyYWN0ZWRUcmFja3MgPSBbXSwgdGhpcy5pc0ZyYWdtZW50YXRpb25Jbml0aWFsaXplZCA9ICExLCB0aGlzLnNhbXBsZVByb2Nlc3NpbmdTdGFydGVkID0gITEsIHRoaXMubmV4dE1vb2ZOdW1iZXIgPSAwLCB0aGlzLml0ZW1MaXN0QnVpbHQgPSAhMSwgdGhpcy5vblNpZHggPSBudWxsLCB0aGlzLnNpZHhTZW50ID0gITE7XG4gIH07XG4gIHkucHJvdG90eXBlLnNldFNlZ21lbnRPcHRpb25zID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICAgIHZhciBzID0gdGhpcy5nZXRUcmFja0J5SWQodCk7XG4gICAgaWYgKHMpIHtcbiAgICAgIHZhciBvID0ge307XG4gICAgICB0aGlzLmZyYWdtZW50ZWRUcmFja3MucHVzaChvKSwgby5pZCA9IHQsIG8udXNlciA9IGUsIG8udHJhayA9IHMsIHMubmV4dFNhbXBsZSA9IDAsIG8uc2VnbWVudFN0cmVhbSA9IG51bGwsIG8ubmJfc2FtcGxlcyA9IDFlMywgby5yYXBBbGlnbmVtZW50ID0gITAsIGkgJiYgKGkubmJTYW1wbGVzICYmIChvLm5iX3NhbXBsZXMgPSBpLm5iU2FtcGxlcyksIGkucmFwQWxpZ25lbWVudCAmJiAoby5yYXBBbGlnbmVtZW50ID0gaS5yYXBBbGlnbmVtZW50KSk7XG4gICAgfVxuICB9LCB5LnByb3RvdHlwZS51bnNldFNlZ21lbnRPcHRpb25zID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgPSAtMSwgaSA9IDA7IGkgPCB0aGlzLmZyYWdtZW50ZWRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzID0gdGhpcy5mcmFnbWVudGVkVHJhY2tzW2ldO1xuICAgICAgcy5pZCA9PSB0ICYmIChlID0gaSk7XG4gICAgfVxuICAgIGUgPiAtMSAmJiB0aGlzLmZyYWdtZW50ZWRUcmFja3Muc3BsaWNlKGUsIDEpO1xuICB9LCB5LnByb3RvdHlwZS5zZXRFeHRyYWN0aW9uT3B0aW9ucyA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICB2YXIgcyA9IHRoaXMuZ2V0VHJhY2tCeUlkKHQpO1xuICAgIGlmIChzKSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgdGhpcy5leHRyYWN0ZWRUcmFja3MucHVzaChvKSwgby5pZCA9IHQsIG8udXNlciA9IGUsIG8udHJhayA9IHMsIHMubmV4dFNhbXBsZSA9IDAsIG8ubmJfc2FtcGxlcyA9IDFlMywgby5zYW1wbGVzID0gW10sIGkgJiYgaS5uYlNhbXBsZXMgJiYgKG8ubmJfc2FtcGxlcyA9IGkubmJTYW1wbGVzKTtcbiAgICB9XG4gIH0sIHkucHJvdG90eXBlLnVuc2V0RXh0cmFjdGlvbk9wdGlvbnMgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IC0xLCBpID0gMDsgaSA8IHRoaXMuZXh0cmFjdGVkVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuZXh0cmFjdGVkVHJhY2tzW2ldO1xuICAgICAgcy5pZCA9PSB0ICYmIChlID0gaSk7XG4gICAgfVxuICAgIGUgPiAtMSAmJiB0aGlzLmV4dHJhY3RlZFRyYWNrcy5zcGxpY2UoZSwgMSk7XG4gIH0sIHkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQsIGUsIGkgPSAhMTtcbiAgICBpZiAoISh0aGlzLnJlc3RvcmVQYXJzZVBvc2l0aW9uICYmICF0aGlzLnJlc3RvcmVQYXJzZVBvc2l0aW9uKCkpKVxuICAgICAgZm9yICg7IDsgKVxuICAgICAgICBpZiAodGhpcy5oYXNJbmNvbXBsZXRlTWRhdCAmJiB0aGlzLmhhc0luY29tcGxldGVNZGF0KCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzSW5jb21wbGV0ZU1kYXQoKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNhdmVQYXJzZVBvc2l0aW9uICYmIHRoaXMuc2F2ZVBhcnNlUG9zaXRpb24oKSwgdCA9IG4ucGFyc2VPbmVCb3godGhpcy5zdHJlYW0sIGkpLCB0LmNvZGUgPT09IG4uRVJSX05PVF9FTk9VR0hfREFUQSlcbiAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzSW5jb21wbGV0ZUJveCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0luY29tcGxldGVCb3godCkpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcztcbiAgICAgICAgICBzd2l0Y2ggKGUgPSB0LmJveCwgcyA9IGUudHlwZSAhPT0gXCJ1dWlkXCIgPyBlLnR5cGUgOiBlLnV1aWQsIHRoaXMuYm94ZXMucHVzaChlKSwgcykge1xuICAgICAgICAgICAgY2FzZSBcIm1kYXRcIjpcbiAgICAgICAgICAgICAgdGhpcy5tZGF0cy5wdXNoKGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtb29mXCI6XG4gICAgICAgICAgICAgIHRoaXMubW9vZnMucHVzaChlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibW9vdlwiOlxuICAgICAgICAgICAgICB0aGlzLm1vb3ZTdGFydEZvdW5kID0gITAsIHRoaXMubWRhdHMubGVuZ3RoID09PSAwICYmICh0aGlzLmlzUHJvZ3Jlc3NpdmUgPSAhMCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aGlzW3NdICE9PSB2b2lkIDAgJiYgci53YXJuKFwiSVNPRmlsZVwiLCBcIkR1cGxpY2F0ZSBCb3ggb2YgdHlwZTogXCIgKyBzICsgXCIsIG92ZXJyaWRpbmcgcHJldmlvdXMgb2NjdXJyZW5jZVwiKSwgdGhpc1tzXSA9IGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZVVzZWRCeXRlcyAmJiB0aGlzLnVwZGF0ZVVzZWRCeXRlcyhlLCB0KTtcbiAgICAgICAgfVxuICB9LCB5LnByb3RvdHlwZS5jaGVja0J1ZmZlciA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodCA9PSBudWxsKVxuICAgICAgdGhyb3cgXCJCdWZmZXIgbXVzdCBiZSBkZWZpbmVkIGFuZCBub24gZW1wdHlcIjtcbiAgICBpZiAodC5maWxlU3RhcnQgPT09IHZvaWQgMClcbiAgICAgIHRocm93IFwiQnVmZmVyIG11c3QgaGF2ZSBhIGZpbGVTdGFydCBwcm9wZXJ0eVwiO1xuICAgIHJldHVybiB0LmJ5dGVMZW5ndGggPT09IDAgPyAoci53YXJuKFwiSVNPRmlsZVwiLCBcIklnbm9yaW5nIGVtcHR5IGJ1ZmZlciAoZmlsZVN0YXJ0OiBcIiArIHQuZmlsZVN0YXJ0ICsgXCIpXCIpLCB0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCgpLCAhMSkgOiAoci5pbmZvKFwiSVNPRmlsZVwiLCBcIlByb2Nlc3NpbmcgYnVmZmVyIChmaWxlU3RhcnQ6IFwiICsgdC5maWxlU3RhcnQgKyBcIilcIiksIHQudXNlZEJ5dGVzID0gMCwgdGhpcy5zdHJlYW0uaW5zZXJ0QnVmZmVyKHQpLCB0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCgpLCB0aGlzLnN0cmVhbS5pbml0aWFsaXplZCgpID8gITAgOiAoci53YXJuKFwiSVNPRmlsZVwiLCBcIk5vdCByZWFkeSB0byBzdGFydCBwYXJzaW5nXCIpLCAhMSkpO1xuICB9LCB5LnByb3RvdHlwZS5hcHBlbmRCdWZmZXIgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKHRoaXMuY2hlY2tCdWZmZXIodCkpXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZSgpLCB0aGlzLm1vb3ZTdGFydEZvdW5kICYmICF0aGlzLm1vb3ZTdGFydFNlbnQgJiYgKHRoaXMubW9vdlN0YXJ0U2VudCA9ICEwLCB0aGlzLm9uTW9vdlN0YXJ0ICYmIHRoaXMub25Nb292U3RhcnQoKSksIHRoaXMubW9vdiA/ICh0aGlzLnNhbXBsZUxpc3RCdWlsdCB8fCAodGhpcy5idWlsZFNhbXBsZUxpc3RzKCksIHRoaXMuc2FtcGxlTGlzdEJ1aWx0ID0gITApLCB0aGlzLnVwZGF0ZVNhbXBsZUxpc3RzKCksIHRoaXMub25SZWFkeSAmJiAhdGhpcy5yZWFkeVNlbnQgJiYgKHRoaXMucmVhZHlTZW50ID0gITAsIHRoaXMub25SZWFkeSh0aGlzLmdldEluZm8oKSkpLCB0aGlzLnByb2Nlc3NTYW1wbGVzKGUpLCB0aGlzLm5leHRTZWVrUG9zaXRpb24gPyAoaSA9IHRoaXMubmV4dFNlZWtQb3NpdGlvbiwgdGhpcy5uZXh0U2Vla1Bvc2l0aW9uID0gdm9pZCAwKSA6IGkgPSB0aGlzLm5leHRQYXJzZVBvc2l0aW9uLCB0aGlzLnN0cmVhbS5nZXRFbmRGaWxlUG9zaXRpb25BZnRlciAmJiAoaSA9IHRoaXMuc3RyZWFtLmdldEVuZEZpbGVQb3NpdGlvbkFmdGVyKGkpKSkgOiB0aGlzLm5leHRQYXJzZVBvc2l0aW9uID8gaSA9IHRoaXMubmV4dFBhcnNlUG9zaXRpb24gOiBpID0gMCwgdGhpcy5zaWR4ICYmIHRoaXMub25TaWR4ICYmICF0aGlzLnNpZHhTZW50ICYmICh0aGlzLm9uU2lkeCh0aGlzLnNpZHgpLCB0aGlzLnNpZHhTZW50ID0gITApLCB0aGlzLm1ldGEgJiYgKHRoaXMuZmxhdHRlbkl0ZW1JbmZvICYmICF0aGlzLml0ZW1MaXN0QnVpbHQgJiYgKHRoaXMuZmxhdHRlbkl0ZW1JbmZvKCksIHRoaXMuaXRlbUxpc3RCdWlsdCA9ICEwKSwgdGhpcy5wcm9jZXNzSXRlbXMgJiYgdGhpcy5wcm9jZXNzSXRlbXModGhpcy5vbkl0ZW0pKSwgdGhpcy5zdHJlYW0uY2xlYW5CdWZmZXJzICYmIChyLmluZm8oXCJJU09GaWxlXCIsIFwiRG9uZSBwcm9jZXNzaW5nIGJ1ZmZlciAoZmlsZVN0YXJ0OiBcIiArIHQuZmlsZVN0YXJ0ICsgXCIpIC0gbmV4dCBidWZmZXIgdG8gZmV0Y2ggc2hvdWxkIGhhdmUgYSBmaWxlU3RhcnQgcG9zaXRpb24gb2YgXCIgKyBpKSwgdGhpcy5zdHJlYW0ubG9nQnVmZmVyTGV2ZWwoKSwgdGhpcy5zdHJlYW0uY2xlYW5CdWZmZXJzKCksIHRoaXMuc3RyZWFtLmxvZ0J1ZmZlckxldmVsKCEwKSwgci5pbmZvKFwiSVNPRmlsZVwiLCBcIlNhbXBsZSBkYXRhIHNpemUgaW4gbWVtb3J5OiBcIiArIHRoaXMuZ2V0QWxsb2NhdGVkU2FtcGxlRGF0YVNpemUoKSkpLCBpO1xuICB9LCB5LnByb3RvdHlwZS5nZXRJbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQsIGUsIGkgPSB7fSwgcywgbywgYywgdSwgXyA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoXCIxOTA0LTAxLTAxVDAwOjAwOjAwWlwiKSkuZ2V0VGltZSgpO1xuICAgIGlmICh0aGlzLm1vb3YpXG4gICAgICBmb3IgKGkuaGFzTW9vdiA9ICEwLCBpLmR1cmF0aW9uID0gdGhpcy5tb292Lm12aGQuZHVyYXRpb24sIGkudGltZXNjYWxlID0gdGhpcy5tb292Lm12aGQudGltZXNjYWxlLCBpLmlzRnJhZ21lbnRlZCA9IHRoaXMubW9vdi5tdmV4ICE9IG51bGwsIGkuaXNGcmFnbWVudGVkICYmIHRoaXMubW9vdi5tdmV4Lm1laGQgJiYgKGkuZnJhZ21lbnRfZHVyYXRpb24gPSB0aGlzLm1vb3YubXZleC5tZWhkLmZyYWdtZW50X2R1cmF0aW9uKSwgaS5pc1Byb2dyZXNzaXZlID0gdGhpcy5pc1Byb2dyZXNzaXZlLCBpLmhhc0lPRCA9IHRoaXMubW9vdi5pb2RzICE9IG51bGwsIGkuYnJhbmRzID0gW10sIGkuYnJhbmRzLnB1c2godGhpcy5mdHlwLm1ham9yX2JyYW5kKSwgaS5icmFuZHMgPSBpLmJyYW5kcy5jb25jYXQodGhpcy5mdHlwLmNvbXBhdGlibGVfYnJhbmRzKSwgaS5jcmVhdGVkID0gbmV3IERhdGUoXyArIHRoaXMubW9vdi5tdmhkLmNyZWF0aW9uX3RpbWUgKiAxZTMpLCBpLm1vZGlmaWVkID0gbmV3IERhdGUoXyArIHRoaXMubW9vdi5tdmhkLm1vZGlmaWNhdGlvbl90aW1lICogMWUzKSwgaS50cmFja3MgPSBbXSwgaS5hdWRpb1RyYWNrcyA9IFtdLCBpLnZpZGVvVHJhY2tzID0gW10sIGkuc3VidGl0bGVUcmFja3MgPSBbXSwgaS5tZXRhZGF0YVRyYWNrcyA9IFtdLCBpLmhpbnRUcmFja3MgPSBbXSwgaS5vdGhlclRyYWNrcyA9IFtdLCB0ID0gMDsgdCA8IHRoaXMubW9vdi50cmFrcy5sZW5ndGg7IHQrKykge1xuICAgICAgICBpZiAocyA9IHRoaXMubW9vdi50cmFrc1t0XSwgdSA9IHMubWRpYS5taW5mLnN0Ymwuc3RzZC5lbnRyaWVzWzBdLCBvID0ge30sIGkudHJhY2tzLnB1c2gobyksIG8uaWQgPSBzLnRraGQudHJhY2tfaWQsIG8ubmFtZSA9IHMubWRpYS5oZGxyLm5hbWUsIG8ucmVmZXJlbmNlcyA9IFtdLCBzLnRyZWYpXG4gICAgICAgICAgZm9yIChlID0gMDsgZSA8IHMudHJlZi5ib3hlcy5sZW5ndGg7IGUrKylcbiAgICAgICAgICAgIGMgPSB7fSwgby5yZWZlcmVuY2VzLnB1c2goYyksIGMudHlwZSA9IHMudHJlZi5ib3hlc1tlXS50eXBlLCBjLnRyYWNrX2lkcyA9IHMudHJlZi5ib3hlc1tlXS50cmFja19pZHM7XG4gICAgICAgIHMuZWR0cyAmJiAoby5lZGl0cyA9IHMuZWR0cy5lbHN0LmVudHJpZXMpLCBvLmNyZWF0ZWQgPSBuZXcgRGF0ZShfICsgcy50a2hkLmNyZWF0aW9uX3RpbWUgKiAxZTMpLCBvLm1vZGlmaWVkID0gbmV3IERhdGUoXyArIHMudGtoZC5tb2RpZmljYXRpb25fdGltZSAqIDFlMyksIG8ubW92aWVfZHVyYXRpb24gPSBzLnRraGQuZHVyYXRpb24sIG8ubW92aWVfdGltZXNjYWxlID0gaS50aW1lc2NhbGUsIG8ubGF5ZXIgPSBzLnRraGQubGF5ZXIsIG8uYWx0ZXJuYXRlX2dyb3VwID0gcy50a2hkLmFsdGVybmF0ZV9ncm91cCwgby52b2x1bWUgPSBzLnRraGQudm9sdW1lLCBvLm1hdHJpeCA9IHMudGtoZC5tYXRyaXgsIG8udHJhY2tfd2lkdGggPSBzLnRraGQud2lkdGggLyA2NTUzNiwgby50cmFja19oZWlnaHQgPSBzLnRraGQuaGVpZ2h0IC8gNjU1MzYsIG8udGltZXNjYWxlID0gcy5tZGlhLm1kaGQudGltZXNjYWxlLCBvLmN0c19zaGlmdCA9IHMubWRpYS5taW5mLnN0YmwuY3NsZywgby5kdXJhdGlvbiA9IHMubWRpYS5tZGhkLmR1cmF0aW9uLCBvLnNhbXBsZXNfZHVyYXRpb24gPSBzLnNhbXBsZXNfZHVyYXRpb24sIG8uY29kZWMgPSB1LmdldENvZGVjKCksIG8ua2luZCA9IHMudWR0YSAmJiBzLnVkdGEua2luZHMubGVuZ3RoID8gcy51ZHRhLmtpbmRzWzBdIDogeyBzY2hlbWVVUkk6IFwiXCIsIHZhbHVlOiBcIlwiIH0sIG8ubGFuZ3VhZ2UgPSBzLm1kaWEuZWxuZyA/IHMubWRpYS5lbG5nLmV4dGVuZGVkX2xhbmd1YWdlIDogcy5tZGlhLm1kaGQubGFuZ3VhZ2VTdHJpbmcsIG8ubmJfc2FtcGxlcyA9IHMuc2FtcGxlcy5sZW5ndGgsIG8uc2l6ZSA9IHMuc2FtcGxlc19zaXplLCBvLmJpdHJhdGUgPSBvLnNpemUgKiA4ICogby50aW1lc2NhbGUgLyBvLnNhbXBsZXNfZHVyYXRpb24sIHUuaXNBdWRpbygpID8gKG8udHlwZSA9IFwiYXVkaW9cIiwgaS5hdWRpb1RyYWNrcy5wdXNoKG8pLCBvLmF1ZGlvID0ge30sIG8uYXVkaW8uc2FtcGxlX3JhdGUgPSB1LmdldFNhbXBsZVJhdGUoKSwgby5hdWRpby5jaGFubmVsX2NvdW50ID0gdS5nZXRDaGFubmVsQ291bnQoKSwgby5hdWRpby5zYW1wbGVfc2l6ZSA9IHUuZ2V0U2FtcGxlU2l6ZSgpKSA6IHUuaXNWaWRlbygpID8gKG8udHlwZSA9IFwidmlkZW9cIiwgaS52aWRlb1RyYWNrcy5wdXNoKG8pLCBvLnZpZGVvID0ge30sIG8udmlkZW8ud2lkdGggPSB1LmdldFdpZHRoKCksIG8udmlkZW8uaGVpZ2h0ID0gdS5nZXRIZWlnaHQoKSkgOiB1LmlzU3VidGl0bGUoKSA/IChvLnR5cGUgPSBcInN1YnRpdGxlc1wiLCBpLnN1YnRpdGxlVHJhY2tzLnB1c2gobykpIDogdS5pc0hpbnQoKSA/IChvLnR5cGUgPSBcIm1ldGFkYXRhXCIsIGkuaGludFRyYWNrcy5wdXNoKG8pKSA6IHUuaXNNZXRhZGF0YSgpID8gKG8udHlwZSA9IFwibWV0YWRhdGFcIiwgaS5tZXRhZGF0YVRyYWNrcy5wdXNoKG8pKSA6IChvLnR5cGUgPSBcIm1ldGFkYXRhXCIsIGkub3RoZXJUcmFja3MucHVzaChvKSk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgaS5oYXNNb292ID0gITE7XG4gICAgaWYgKGkubWltZSA9IFwiXCIsIGkuaGFzTW9vdiAmJiBpLnRyYWNrcykge1xuICAgICAgZm9yIChpLnZpZGVvVHJhY2tzICYmIGkudmlkZW9UcmFja3MubGVuZ3RoID4gMCA/IGkubWltZSArPSAndmlkZW8vbXA0OyBjb2RlY3M9XCInIDogaS5hdWRpb1RyYWNrcyAmJiBpLmF1ZGlvVHJhY2tzLmxlbmd0aCA+IDAgPyBpLm1pbWUgKz0gJ2F1ZGlvL21wNDsgY29kZWNzPVwiJyA6IGkubWltZSArPSAnYXBwbGljYXRpb24vbXA0OyBjb2RlY3M9XCInLCB0ID0gMDsgdCA8IGkudHJhY2tzLmxlbmd0aDsgdCsrKVxuICAgICAgICB0ICE9PSAwICYmIChpLm1pbWUgKz0gXCIsXCIpLCBpLm1pbWUgKz0gaS50cmFja3NbdF0uY29kZWM7XG4gICAgICBpLm1pbWUgKz0gJ1wiOyBwcm9maWxlcz1cIicsIGkubWltZSArPSB0aGlzLmZ0eXAuY29tcGF0aWJsZV9icmFuZHMuam9pbigpLCBpLm1pbWUgKz0gJ1wiJztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0sIHkucHJvdG90eXBlLnByb2Nlc3NTYW1wbGVzID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpO1xuICAgIGlmICh0aGlzLnNhbXBsZVByb2Nlc3NpbmdTdGFydGVkKSB7XG4gICAgICBpZiAodGhpcy5pc0ZyYWdtZW50YXRpb25Jbml0aWFsaXplZCAmJiB0aGlzLm9uU2VnbWVudCAhPT0gbnVsbClcbiAgICAgICAgZm9yIChlID0gMDsgZSA8IHRoaXMuZnJhZ21lbnRlZFRyYWNrcy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgIHZhciBzID0gdGhpcy5mcmFnbWVudGVkVHJhY2tzW2VdO1xuICAgICAgICAgIGZvciAoaSA9IHMudHJhazsgaS5uZXh0U2FtcGxlIDwgaS5zYW1wbGVzLmxlbmd0aCAmJiB0aGlzLnNhbXBsZVByb2Nlc3NpbmdTdGFydGVkOyApIHtcbiAgICAgICAgICAgIHIuZGVidWcoXCJJU09GaWxlXCIsIFwiQ3JlYXRpbmcgbWVkaWEgZnJhZ21lbnQgb24gdHJhY2sgI1wiICsgcy5pZCArIFwiIGZvciBzYW1wbGUgXCIgKyBpLm5leHRTYW1wbGUpO1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmNyZWF0ZUZyYWdtZW50KHMuaWQsIGkubmV4dFNhbXBsZSwgcy5zZWdtZW50U3RyZWFtKTtcbiAgICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgICBzLnNlZ21lbnRTdHJlYW0gPSBvLCBpLm5leHRTYW1wbGUrKztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoKGkubmV4dFNhbXBsZSAlIHMubmJfc2FtcGxlcyA9PT0gMCB8fCB0IHx8IGkubmV4dFNhbXBsZSA+PSBpLnNhbXBsZXMubGVuZ3RoKSAmJiAoci5pbmZvKFwiSVNPRmlsZVwiLCBcIlNlbmRpbmcgZnJhZ21lbnRlZCBkYXRhIG9uIHRyYWNrICNcIiArIHMuaWQgKyBcIiBmb3Igc2FtcGxlcyBbXCIgKyBNYXRoLm1heCgwLCBpLm5leHRTYW1wbGUgLSBzLm5iX3NhbXBsZXMpICsgXCIsXCIgKyAoaS5uZXh0U2FtcGxlIC0gMSkgKyBcIl1cIiksIHIuaW5mbyhcIklTT0ZpbGVcIiwgXCJTYW1wbGUgZGF0YSBzaXplIGluIG1lbW9yeTogXCIgKyB0aGlzLmdldEFsbG9jYXRlZFNhbXBsZURhdGFTaXplKCkpLCB0aGlzLm9uU2VnbWVudCAmJiB0aGlzLm9uU2VnbWVudChzLmlkLCBzLnVzZXIsIHMuc2VnbWVudFN0cmVhbS5idWZmZXIsIGkubmV4dFNhbXBsZSwgdCB8fCBpLm5leHRTYW1wbGUgPj0gaS5zYW1wbGVzLmxlbmd0aCksIHMuc2VnbWVudFN0cmVhbSA9IG51bGwsIHMgIT09IHRoaXMuZnJhZ21lbnRlZFRyYWNrc1tlXSkpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaWYgKHRoaXMub25TYW1wbGVzICE9PSBudWxsKVxuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgdGhpcy5leHRyYWN0ZWRUcmFja3MubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMuZXh0cmFjdGVkVHJhY2tzW2VdO1xuICAgICAgICAgIGZvciAoaSA9IGMudHJhazsgaS5uZXh0U2FtcGxlIDwgaS5zYW1wbGVzLmxlbmd0aCAmJiB0aGlzLnNhbXBsZVByb2Nlc3NpbmdTdGFydGVkOyApIHtcbiAgICAgICAgICAgIHIuZGVidWcoXCJJU09GaWxlXCIsIFwiRXhwb3J0aW5nIG9uIHRyYWNrICNcIiArIGMuaWQgKyBcIiBzYW1wbGUgI1wiICsgaS5uZXh0U2FtcGxlKTtcbiAgICAgICAgICAgIHZhciB1ID0gdGhpcy5nZXRTYW1wbGUoaSwgaS5uZXh0U2FtcGxlKTtcbiAgICAgICAgICAgIGlmICh1KVxuICAgICAgICAgICAgICBpLm5leHRTYW1wbGUrKywgYy5zYW1wbGVzLnB1c2godSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKChpLm5leHRTYW1wbGUgJSBjLm5iX3NhbXBsZXMgPT09IDAgfHwgaS5uZXh0U2FtcGxlID49IGkuc2FtcGxlcy5sZW5ndGgpICYmIChyLmRlYnVnKFwiSVNPRmlsZVwiLCBcIlNlbmRpbmcgc2FtcGxlcyBvbiB0cmFjayAjXCIgKyBjLmlkICsgXCIgZm9yIHNhbXBsZSBcIiArIGkubmV4dFNhbXBsZSksIHRoaXMub25TYW1wbGVzICYmIHRoaXMub25TYW1wbGVzKGMuaWQsIGMudXNlciwgYy5zYW1wbGVzKSwgYy5zYW1wbGVzID0gW10sIGMgIT09IHRoaXMuZXh0cmFjdGVkVHJhY2tzW2VdKSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9LCB5LnByb3RvdHlwZS5nZXRCb3ggPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0aGlzLmdldEJveGVzKHQsICEwKTtcbiAgICByZXR1cm4gZS5sZW5ndGggPyBlWzBdIDogbnVsbDtcbiAgfSwgeS5wcm90b3R5cGUuZ2V0Qm94ZXMgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGkgPSBbXTtcbiAgICByZXR1cm4geS5fc3dlZXAuY2FsbCh0aGlzLCB0LCBpLCBlKSwgaTtcbiAgfSwgeS5fc3dlZXAgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgdGhpcy50eXBlICYmIHRoaXMudHlwZSA9PSB0ICYmIGUucHVzaCh0aGlzKTtcbiAgICBmb3IgKHZhciBzIGluIHRoaXMuYm94ZXMpIHtcbiAgICAgIGlmIChlLmxlbmd0aCAmJiBpKSByZXR1cm47XG4gICAgICB5Ll9zd2VlcC5jYWxsKHRoaXMuYm94ZXNbc10sIHQsIGUsIGkpO1xuICAgIH1cbiAgfSwgeS5wcm90b3R5cGUuZ2V0VHJhY2tTYW1wbGVzSW5mbyA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHRoaXMuZ2V0VHJhY2tCeUlkKHQpO1xuICAgIGlmIChlKVxuICAgICAgcmV0dXJuIGUuc2FtcGxlcztcbiAgfSwgeS5wcm90b3R5cGUuZ2V0VHJhY2tTYW1wbGUgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGkgPSB0aGlzLmdldFRyYWNrQnlJZCh0KSwgcyA9IHRoaXMuZ2V0U2FtcGxlKGksIGUpO1xuICAgIHJldHVybiBzO1xuICB9LCB5LnByb3RvdHlwZS5yZWxlYXNlVXNlZFNhbXBsZXMgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGkgPSAwLCBzID0gdGhpcy5nZXRUcmFja0J5SWQodCk7XG4gICAgcy5sYXN0VmFsaWRTYW1wbGUgfHwgKHMubGFzdFZhbGlkU2FtcGxlID0gMCk7XG4gICAgZm9yICh2YXIgbyA9IHMubGFzdFZhbGlkU2FtcGxlOyBvIDwgZTsgbysrKVxuICAgICAgaSArPSB0aGlzLnJlbGVhc2VTYW1wbGUocywgbyk7XG4gICAgci5pbmZvKFwiSVNPRmlsZVwiLCBcIlRyYWNrICNcIiArIHQgKyBcIiByZWxlYXNlZCBzYW1wbGVzIHVwIHRvIFwiICsgZSArIFwiIChyZWxlYXNlZCBzaXplOiBcIiArIGkgKyBcIiwgcmVtYWluaW5nOiBcIiArIHRoaXMuc2FtcGxlc0RhdGFTaXplICsgXCIpXCIpLCBzLmxhc3RWYWxpZFNhbXBsZSA9IGU7XG4gIH0sIHkucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zYW1wbGVQcm9jZXNzaW5nU3RhcnRlZCA9ICEwLCB0aGlzLnByb2Nlc3NTYW1wbGVzKCExKTtcbiAgfSwgeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2FtcGxlUHJvY2Vzc2luZ1N0YXJ0ZWQgPSAhMTtcbiAgfSwgeS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICByLmluZm8oXCJJU09GaWxlXCIsIFwiRmx1c2hpbmcgcmVtYWluaW5nIHNhbXBsZXNcIiksIHRoaXMudXBkYXRlU2FtcGxlTGlzdHMoKSwgdGhpcy5wcm9jZXNzU2FtcGxlcyghMCksIHRoaXMuc3RyZWFtLmNsZWFuQnVmZmVycygpLCB0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCghMCk7XG4gIH0sIHkucHJvdG90eXBlLnNlZWtUcmFjayA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICB2YXIgcywgbywgYyA9IDEgLyAwLCB1ID0gMCwgXyA9IDAsIGc7XG4gICAgaWYgKGkuc2FtcGxlcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gci5pbmZvKFwiSVNPRmlsZVwiLCBcIk5vIHNhbXBsZSBpbiB0cmFjaywgY2Fubm90IHNlZWshIFVzaW5nIHRpbWUgXCIgKyByLmdldER1cmF0aW9uU3RyaW5nKDAsIDEpICsgXCIgYW5kIG9mZnNldDogMFwiKSwgeyBvZmZzZXQ6IDAsIHRpbWU6IDAgfTtcbiAgICBmb3IgKHMgPSAwOyBzIDwgaS5zYW1wbGVzLmxlbmd0aDsgcysrKSB7XG4gICAgICBpZiAobyA9IGkuc2FtcGxlc1tzXSwgcyA9PT0gMClcbiAgICAgICAgXyA9IDAsIGcgPSBvLnRpbWVzY2FsZTtcbiAgICAgIGVsc2UgaWYgKG8uY3RzID4gdCAqIG8udGltZXNjYWxlKSB7XG4gICAgICAgIF8gPSBzIC0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlICYmIG8uaXNfc3luYyAmJiAodSA9IHMpO1xuICAgIH1cbiAgICBmb3IgKGUgJiYgKF8gPSB1KSwgdCA9IGkuc2FtcGxlc1tfXS5jdHMsIGkubmV4dFNhbXBsZSA9IF87IGkuc2FtcGxlc1tfXS5hbHJlYWR5UmVhZCA9PT0gaS5zYW1wbGVzW19dLnNpemUgJiYgaS5zYW1wbGVzW18gKyAxXTsgKVxuICAgICAgXysrO1xuICAgIHJldHVybiBjID0gaS5zYW1wbGVzW19dLm9mZnNldCArIGkuc2FtcGxlc1tfXS5hbHJlYWR5UmVhZCwgci5pbmZvKFwiSVNPRmlsZVwiLCBcIlNlZWtpbmcgdG8gXCIgKyAoZSA/IFwiUkFQXCIgOiBcIlwiKSArIFwiIHNhbXBsZSAjXCIgKyBpLm5leHRTYW1wbGUgKyBcIiBvbiB0cmFjayBcIiArIGkudGtoZC50cmFja19pZCArIFwiLCB0aW1lIFwiICsgci5nZXREdXJhdGlvblN0cmluZyh0LCBnKSArIFwiIGFuZCBvZmZzZXQ6IFwiICsgYyksIHsgb2Zmc2V0OiBjLCB0aW1lOiB0IC8gZyB9O1xuICB9LCB5LnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24odCwgZSkge1xuICAgIHZhciBpID0gdGhpcy5tb292LCBzLCBvLCBjLCB1ID0geyBvZmZzZXQ6IDEgLyAwLCB0aW1lOiAxIC8gMCB9O1xuICAgIGlmICh0aGlzLm1vb3YpIHtcbiAgICAgIGZvciAoYyA9IDA7IGMgPCBpLnRyYWtzLmxlbmd0aDsgYysrKVxuICAgICAgICBzID0gaS50cmFrc1tjXSwgbyA9IHRoaXMuc2Vla1RyYWNrKHQsIGUsIHMpLCBvLm9mZnNldCA8IHUub2Zmc2V0ICYmICh1Lm9mZnNldCA9IG8ub2Zmc2V0KSwgby50aW1lIDwgdS50aW1lICYmICh1LnRpbWUgPSBvLnRpbWUpO1xuICAgICAgcmV0dXJuIHIuaW5mbyhcIklTT0ZpbGVcIiwgXCJTZWVraW5nIGF0IHRpbWUgXCIgKyByLmdldER1cmF0aW9uU3RyaW5nKHUudGltZSwgMSkgKyBcIiBuZWVkcyBhIGJ1ZmZlciB3aXRoIGEgZmlsZVN0YXJ0IHBvc2l0aW9uIG9mIFwiICsgdS5vZmZzZXQpLCB1Lm9mZnNldCA9PT0gMSAvIDAgPyB1ID0geyBvZmZzZXQ6IHRoaXMubmV4dFBhcnNlUG9zaXRpb24sIHRpbWU6IDAgfSA6IHUub2Zmc2V0ID0gdGhpcy5zdHJlYW0uZ2V0RW5kRmlsZVBvc2l0aW9uQWZ0ZXIodS5vZmZzZXQpLCByLmluZm8oXCJJU09GaWxlXCIsIFwiQWRqdXN0ZWQgc2VlayBwb3NpdGlvbiAoYWZ0ZXIgY2hlY2tpbmcgZGF0YSBhbHJlYWR5IGluIGJ1ZmZlcik6IFwiICsgdS5vZmZzZXQpLCB1O1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgXCJDYW5ub3Qgc2VlazogbW9vdiBub3QgcmVjZWl2ZWQhXCI7XG4gIH0sIHkucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5ib3hlcy5sZW5ndGggJiYgZSA8IHQuYm94ZXMubGVuZ3RoOyApIHtcbiAgICAgIHZhciBpID0gdGhpcy5ib3hlc1tlXSwgcyA9IHQuYm94ZXNbZV07XG4gICAgICBpZiAoIW4uYm94RXF1YWwoaSwgcykpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGUrKztcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9LCBsLklTT0ZpbGUgPSB5LCB5LnByb3RvdHlwZS5sYXN0Qm94U3RhcnRQb3NpdGlvbiA9IDAsIHkucHJvdG90eXBlLnBhcnNpbmdNZGF0ID0gbnVsbCwgeS5wcm90b3R5cGUubmV4dFBhcnNlUG9zaXRpb24gPSAwLCB5LnByb3RvdHlwZS5kaXNjYXJkTWRhdERhdGEgPSAhMSwgeS5wcm90b3R5cGUucHJvY2Vzc0luY29tcGxldGVCb3ggPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUsIGksIHM7XG4gICAgcmV0dXJuIHQudHlwZSA9PT0gXCJtZGF0XCIgPyAoZSA9IG5ldyBuW3QudHlwZSArIFwiQm94XCJdKHQuc2l6ZSksIHRoaXMucGFyc2luZ01kYXQgPSBlLCB0aGlzLmJveGVzLnB1c2goZSksIHRoaXMubWRhdHMucHVzaChlKSwgZS5zdGFydCA9IHQuc3RhcnQsIGUuaGRyX3NpemUgPSB0Lmhkcl9zaXplLCB0aGlzLnN0cmVhbS5hZGRVc2VkQnl0ZXMoZS5oZHJfc2l6ZSksIHRoaXMubGFzdEJveFN0YXJ0UG9zaXRpb24gPSBlLnN0YXJ0ICsgZS5zaXplLCBzID0gdGhpcy5zdHJlYW0uc2VlayhlLnN0YXJ0ICsgZS5zaXplLCAhMSwgdGhpcy5kaXNjYXJkTWRhdERhdGEpLCBzID8gKHRoaXMucGFyc2luZ01kYXQgPSBudWxsLCAhMCkgOiAodGhpcy5tb292U3RhcnRGb3VuZCA/IHRoaXMubmV4dFBhcnNlUG9zaXRpb24gPSB0aGlzLnN0cmVhbS5maW5kRW5kQ29udGlndW91c0J1ZigpIDogdGhpcy5uZXh0UGFyc2VQb3NpdGlvbiA9IGUuc3RhcnQgKyBlLnNpemUsICExKSkgOiAodC50eXBlID09PSBcIm1vb3ZcIiAmJiAodGhpcy5tb292U3RhcnRGb3VuZCA9ICEwLCB0aGlzLm1kYXRzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5pc1Byb2dyZXNzaXZlID0gITApKSwgaSA9IHRoaXMuc3RyZWFtLm1lcmdlTmV4dEJ1ZmZlciA/IHRoaXMuc3RyZWFtLm1lcmdlTmV4dEJ1ZmZlcigpIDogITEsIGkgPyAodGhpcy5uZXh0UGFyc2VQb3NpdGlvbiA9IHRoaXMuc3RyZWFtLmdldEVuZFBvc2l0aW9uKCksICEwKSA6ICh0LnR5cGUgPyB0aGlzLm1vb3ZTdGFydEZvdW5kID8gdGhpcy5uZXh0UGFyc2VQb3NpdGlvbiA9IHRoaXMuc3RyZWFtLmdldEVuZFBvc2l0aW9uKCkgOiB0aGlzLm5leHRQYXJzZVBvc2l0aW9uID0gdGhpcy5zdHJlYW0uZ2V0UG9zaXRpb24oKSArIHQuc2l6ZSA6IHRoaXMubmV4dFBhcnNlUG9zaXRpb24gPSB0aGlzLnN0cmVhbS5nZXRFbmRQb3NpdGlvbigpLCAhMSkpO1xuICB9LCB5LnByb3RvdHlwZS5oYXNJbmNvbXBsZXRlTWRhdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNpbmdNZGF0ICE9PSBudWxsO1xuICB9LCB5LnByb3RvdHlwZS5wcm9jZXNzSW5jb21wbGV0ZU1kYXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCwgZTtcbiAgICByZXR1cm4gdCA9IHRoaXMucGFyc2luZ01kYXQsIGUgPSB0aGlzLnN0cmVhbS5zZWVrKHQuc3RhcnQgKyB0LnNpemUsICExLCB0aGlzLmRpc2NhcmRNZGF0RGF0YSksIGUgPyAoci5kZWJ1ZyhcIklTT0ZpbGVcIiwgXCJGb3VuZCAnbWRhdCcgZW5kIGluIGJ1ZmZlcmVkIGRhdGFcIiksIHRoaXMucGFyc2luZ01kYXQgPSBudWxsLCAhMCkgOiAodGhpcy5uZXh0UGFyc2VQb3NpdGlvbiA9IHRoaXMuc3RyZWFtLmZpbmRFbmRDb250aWd1b3VzQnVmKCksICExKTtcbiAgfSwgeS5wcm90b3R5cGUucmVzdG9yZVBhcnNlUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW0uc2Vlayh0aGlzLmxhc3RCb3hTdGFydFBvc2l0aW9uLCAhMCwgdGhpcy5kaXNjYXJkTWRhdERhdGEpO1xuICB9LCB5LnByb3RvdHlwZS5zYXZlUGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGFzdEJveFN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0cmVhbS5nZXRQb3NpdGlvbigpO1xuICB9LCB5LnByb3RvdHlwZS51cGRhdGVVc2VkQnl0ZXMgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdGhpcy5zdHJlYW0uYWRkVXNlZEJ5dGVzICYmICh0LnR5cGUgPT09IFwibWRhdFwiID8gKHRoaXMuc3RyZWFtLmFkZFVzZWRCeXRlcyh0Lmhkcl9zaXplKSwgdGhpcy5kaXNjYXJkTWRhdERhdGEgJiYgdGhpcy5zdHJlYW0uYWRkVXNlZEJ5dGVzKHQuc2l6ZSAtIHQuaGRyX3NpemUpKSA6IHRoaXMuc3RyZWFtLmFkZFVzZWRCeXRlcyh0LnNpemUpKTtcbiAgfSwgeS5wcm90b3R5cGUuYWRkID0gbi5Cb3gucHJvdG90eXBlLmFkZCwgeS5wcm90b3R5cGUuYWRkQm94ID0gbi5Cb3gucHJvdG90eXBlLmFkZEJveCwgeS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQgfHwge307XG4gICAgdGhpcy5hZGQoXCJmdHlwXCIpLnNldChcIm1ham9yX2JyYW5kXCIsIGUuYnJhbmRzICYmIGUuYnJhbmRzWzBdIHx8IFwiaXNvNFwiKS5zZXQoXCJtaW5vcl92ZXJzaW9uXCIsIDApLnNldChcImNvbXBhdGlibGVfYnJhbmRzXCIsIGUuYnJhbmRzIHx8IFtcImlzbzRcIl0pO1xuICAgIHZhciBpID0gdGhpcy5hZGQoXCJtb292XCIpO1xuICAgIHJldHVybiBpLmFkZChcIm12aGRcIikuc2V0KFwidGltZXNjYWxlXCIsIGUudGltZXNjYWxlIHx8IDYwMCkuc2V0KFwicmF0ZVwiLCBlLnJhdGUgfHwgNjU1MzYpLnNldChcImNyZWF0aW9uX3RpbWVcIiwgMCkuc2V0KFwibW9kaWZpY2F0aW9uX3RpbWVcIiwgMCkuc2V0KFwiZHVyYXRpb25cIiwgZS5kdXJhdGlvbiB8fCAwKS5zZXQoXCJ2b2x1bWVcIiwgZS53aWR0aCA/IDAgOiAyNTYpLnNldChcIm1hdHJpeFwiLCBbNjU1MzYsIDAsIDAsIDAsIDY1NTM2LCAwLCAwLCAwLCAxMDczNzQxODI0XSkuc2V0KFwibmV4dF90cmFja19pZFwiLCAxKSwgaS5hZGQoXCJtdmV4XCIpLCB0aGlzO1xuICB9LCB5LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLm1vb3YgfHwgdGhpcy5pbml0KHQpO1xuICAgIHZhciBlID0gdCB8fCB7fTtcbiAgICBlLndpZHRoID0gZS53aWR0aCB8fCAzMjAsIGUuaGVpZ2h0ID0gZS5oZWlnaHQgfHwgMzIwLCBlLmlkID0gZS5pZCB8fCB0aGlzLm1vb3YubXZoZC5uZXh0X3RyYWNrX2lkLCBlLnR5cGUgPSBlLnR5cGUgfHwgXCJhdmMxXCI7XG4gICAgdmFyIGkgPSB0aGlzLm1vb3YuYWRkKFwidHJha1wiKTtcbiAgICB0aGlzLm1vb3YubXZoZC5uZXh0X3RyYWNrX2lkID0gZS5pZCArIDEsIGkuYWRkKFwidGtoZFwiKS5zZXQoXCJmbGFnc1wiLCBuLlRLSERfRkxBR19FTkFCTEVEIHwgbi5US0hEX0ZMQUdfSU5fTU9WSUUgfCBuLlRLSERfRkxBR19JTl9QUkVWSUVXKS5zZXQoXCJjcmVhdGlvbl90aW1lXCIsIDApLnNldChcIm1vZGlmaWNhdGlvbl90aW1lXCIsIDApLnNldChcInRyYWNrX2lkXCIsIGUuaWQpLnNldChcImR1cmF0aW9uXCIsIGUuZHVyYXRpb24gfHwgMCkuc2V0KFwibGF5ZXJcIiwgZS5sYXllciB8fCAwKS5zZXQoXCJhbHRlcm5hdGVfZ3JvdXBcIiwgMCkuc2V0KFwidm9sdW1lXCIsIDEpLnNldChcIm1hdHJpeFwiLCBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLnNldChcIndpZHRoXCIsIGUud2lkdGggPDwgMTYpLnNldChcImhlaWdodFwiLCBlLmhlaWdodCA8PCAxNik7XG4gICAgdmFyIHMgPSBpLmFkZChcIm1kaWFcIik7XG4gICAgcy5hZGQoXCJtZGhkXCIpLnNldChcImNyZWF0aW9uX3RpbWVcIiwgMCkuc2V0KFwibW9kaWZpY2F0aW9uX3RpbWVcIiwgMCkuc2V0KFwidGltZXNjYWxlXCIsIGUudGltZXNjYWxlIHx8IDEpLnNldChcImR1cmF0aW9uXCIsIGUubWVkaWFfZHVyYXRpb24gfHwgMCkuc2V0KFwibGFuZ3VhZ2VcIiwgZS5sYW5ndWFnZSB8fCBcInVuZFwiKSwgcy5hZGQoXCJoZGxyXCIpLnNldChcImhhbmRsZXJcIiwgZS5oZGxyIHx8IFwidmlkZVwiKS5zZXQoXCJuYW1lXCIsIGUubmFtZSB8fCBcIlRyYWNrIGNyZWF0ZWQgd2l0aCBNUDRCb3guanNcIiksIHMuYWRkKFwiZWxuZ1wiKS5zZXQoXCJleHRlbmRlZF9sYW5ndWFnZVwiLCBlLmxhbmd1YWdlIHx8IFwiZnItRlJcIik7XG4gICAgdmFyIG8gPSBzLmFkZChcIm1pbmZcIik7XG4gICAgaWYgKG5bZS50eXBlICsgXCJTYW1wbGVFbnRyeVwiXSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgYyA9IG5ldyBuW2UudHlwZSArIFwiU2FtcGxlRW50cnlcIl0oKTtcbiAgICAgIGMuZGF0YV9yZWZlcmVuY2VfaW5kZXggPSAxO1xuICAgICAgdmFyIHUgPSBcIlwiO1xuICAgICAgZm9yICh2YXIgXyBpbiBuLnNhbXBsZUVudHJ5Q29kZXMpXG4gICAgICAgIGZvciAodmFyIGcgPSBuLnNhbXBsZUVudHJ5Q29kZXNbX10sIHcgPSAwOyB3IDwgZy5sZW5ndGg7IHcrKylcbiAgICAgICAgICBpZiAoZy5pbmRleE9mKGUudHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgdSA9IF87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICBzd2l0Y2ggKHUpIHtcbiAgICAgICAgY2FzZSBcIlZpc3VhbFwiOlxuICAgICAgICAgIGlmIChvLmFkZChcInZtaGRcIikuc2V0KFwiZ3JhcGhpY3Ntb2RlXCIsIDApLnNldChcIm9wY29sb3JcIiwgWzAsIDAsIDBdKSwgYy5zZXQoXCJ3aWR0aFwiLCBlLndpZHRoKS5zZXQoXCJoZWlnaHRcIiwgZS5oZWlnaHQpLnNldChcImhvcml6cmVzb2x1dGlvblwiLCA3MiA8PCAxNikuc2V0KFwidmVydHJlc29sdXRpb25cIiwgNzIgPDwgMTYpLnNldChcImZyYW1lX2NvdW50XCIsIDEpLnNldChcImNvbXByZXNzb3JuYW1lXCIsIGUudHlwZSArIFwiIENvbXByZXNzb3JcIikuc2V0KFwiZGVwdGhcIiwgMjQpLCBlLmF2Y0RlY29kZXJDb25maWdSZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciBTID0gbmV3IG4uYXZjQ0JveCgpLCBVID0gbmV3IGgoZS5hdmNEZWNvZGVyQ29uZmlnUmVjb3JkKTtcbiAgICAgICAgICAgIFMucGFyc2UoVSksIGMuYWRkQm94KFMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkF1ZGlvXCI6XG4gICAgICAgICAgby5hZGQoXCJzbWhkXCIpLnNldChcImJhbGFuY2VcIiwgZS5iYWxhbmNlIHx8IDApLCBjLnNldChcImNoYW5uZWxfY291bnRcIiwgZS5jaGFubmVsX2NvdW50IHx8IDIpLnNldChcInNhbXBsZXNpemVcIiwgZS5zYW1wbGVzaXplIHx8IDE2KS5zZXQoXCJzYW1wbGVyYXRlXCIsIGUuc2FtcGxlcmF0ZSB8fCA2NTUzNik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJIaW50XCI6XG4gICAgICAgICAgby5hZGQoXCJobWhkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU3VidGl0bGVcIjpcbiAgICAgICAgICBzd2l0Y2ggKG8uYWRkKFwic3RoZFwiKSwgZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwic3RwcFwiOlxuICAgICAgICAgICAgICBjLnNldChcIm5hbWVzcGFjZVwiLCBlLm5hbWVzcGFjZSB8fCBcIm5vbmFtZXNwYWNlXCIpLnNldChcInNjaGVtYV9sb2NhdGlvblwiLCBlLnNjaGVtYV9sb2NhdGlvbiB8fCBcIlwiKS5zZXQoXCJhdXhpbGlhcnlfbWltZV90eXBlc1wiLCBlLmF1eGlsaWFyeV9taW1lX3R5cGVzIHx8IFwiXCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNZXRhZGF0YVwiOlxuICAgICAgICAgIG8uYWRkKFwibm1oZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlN5c3RlbVwiOlxuICAgICAgICAgIG8uYWRkKFwibm1oZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvLmFkZChcIm5taGRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlLmRlc2NyaXB0aW9uICYmIGMuYWRkQm94KGUuZGVzY3JpcHRpb24pLCBlLmRlc2NyaXB0aW9uX2JveGVzICYmIGUuZGVzY3JpcHRpb25fYm94ZXMuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgIGMuYWRkQm94KHgpO1xuICAgICAgfSksIG8uYWRkKFwiZGluZlwiKS5hZGQoXCJkcmVmXCIpLmFkZEVudHJ5KG5ldyBuW1widXJsIEJveFwiXSgpLnNldChcImZsYWdzXCIsIDEpKTtcbiAgICAgIHZhciBDID0gby5hZGQoXCJzdGJsXCIpO1xuICAgICAgcmV0dXJuIEMuYWRkKFwic3RzZFwiKS5hZGRFbnRyeShjKSwgQy5hZGQoXCJzdHRzXCIpLnNldChcInNhbXBsZV9jb3VudHNcIiwgW10pLnNldChcInNhbXBsZV9kZWx0YXNcIiwgW10pLCBDLmFkZChcInN0c2NcIikuc2V0KFwiZmlyc3RfY2h1bmtcIiwgW10pLnNldChcInNhbXBsZXNfcGVyX2NodW5rXCIsIFtdKS5zZXQoXCJzYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcIiwgW10pLCBDLmFkZChcInN0Y29cIikuc2V0KFwiY2h1bmtfb2Zmc2V0c1wiLCBbXSksIEMuYWRkKFwic3RzelwiKS5zZXQoXCJzYW1wbGVfc2l6ZXNcIiwgW10pLCB0aGlzLm1vb3YubXZleC5hZGQoXCJ0cmV4XCIpLnNldChcInRyYWNrX2lkXCIsIGUuaWQpLnNldChcImRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XCIsIGUuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggfHwgMSkuc2V0KFwiZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cIiwgZS5kZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiB8fCAwKS5zZXQoXCJkZWZhdWx0X3NhbXBsZV9zaXplXCIsIGUuZGVmYXVsdF9zYW1wbGVfc2l6ZSB8fCAwKS5zZXQoXCJkZWZhdWx0X3NhbXBsZV9mbGFnc1wiLCBlLmRlZmF1bHRfc2FtcGxlX2ZsYWdzIHx8IDApLCB0aGlzLmJ1aWxkVHJha1NhbXBsZUxpc3RzKGkpLCBlLmlkO1xuICAgIH1cbiAgfSwgbi5Cb3gucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdCB8fCBuZXcgYSgpO1xuICAgIGUuZW5kaWFubmVzcyA9IGEuQklHX0VORElBTiwgdGhpcy53cml0ZShlKTtcbiAgfSwgeS5wcm90b3R5cGUuYWRkU2FtcGxlID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICAgIHZhciBzID0gaSB8fCB7fSwgbyA9IHt9LCBjID0gdGhpcy5nZXRUcmFja0J5SWQodCk7XG4gICAgaWYgKGMgIT09IG51bGwpIHtcbiAgICAgIG8ubnVtYmVyID0gYy5zYW1wbGVzLmxlbmd0aCwgby50cmFja19pZCA9IGMudGtoZC50cmFja19pZCwgby50aW1lc2NhbGUgPSBjLm1kaWEubWRoZC50aW1lc2NhbGUsIG8uZGVzY3JpcHRpb25faW5kZXggPSBzLnNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCA/IHMuc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4IC0gMSA6IDAsIG8uZGVzY3JpcHRpb24gPSBjLm1kaWEubWluZi5zdGJsLnN0c2QuZW50cmllc1tvLmRlc2NyaXB0aW9uX2luZGV4XSwgby5kYXRhID0gZSwgby5zaXplID0gZS5ieXRlTGVuZ3RoLCBvLmFscmVhZHlSZWFkID0gby5zaXplLCBvLmR1cmF0aW9uID0gcy5kdXJhdGlvbiB8fCAxLCBvLmN0cyA9IHMuY3RzIHx8IDAsIG8uZHRzID0gcy5kdHMgfHwgMCwgby5pc19zeW5jID0gcy5pc19zeW5jIHx8ICExLCBvLmlzX2xlYWRpbmcgPSBzLmlzX2xlYWRpbmcgfHwgMCwgby5kZXBlbmRzX29uID0gcy5kZXBlbmRzX29uIHx8IDAsIG8uaXNfZGVwZW5kZWRfb24gPSBzLmlzX2RlcGVuZGVkX29uIHx8IDAsIG8uaGFzX3JlZHVuZGFuY3kgPSBzLmhhc19yZWR1bmRhbmN5IHx8IDAsIG8uZGVncmFkYXRpb25fcHJpb3JpdHkgPSBzLmRlZ3JhZGF0aW9uX3ByaW9yaXR5IHx8IDAsIG8ub2Zmc2V0ID0gMCwgby5zdWJzYW1wbGVzID0gcy5zdWJzYW1wbGVzLCBjLnNhbXBsZXMucHVzaChvKSwgYy5zYW1wbGVzX3NpemUgKz0gby5zaXplLCBjLnNhbXBsZXNfZHVyYXRpb24gKz0gby5kdXJhdGlvbiwgYy5maXJzdF9kdHMgfHwgKGMuZmlyc3RfZHRzID0gcy5kdHMpLCB0aGlzLnByb2Nlc3NTYW1wbGVzKCk7XG4gICAgICB2YXIgdSA9IHRoaXMuY3JlYXRlU2luZ2xlU2FtcGxlTW9vZihvKTtcbiAgICAgIHJldHVybiB0aGlzLmFkZEJveCh1KSwgdS5jb21wdXRlU2l6ZSgpLCB1LnRyYWZzWzBdLnRydW5zWzBdLmRhdGFfb2Zmc2V0ID0gdS5zaXplICsgOCwgdGhpcy5hZGQoXCJtZGF0XCIpLmRhdGEgPSBuZXcgVWludDhBcnJheShlKSwgbztcbiAgICB9XG4gIH0sIHkucHJvdG90eXBlLmNyZWF0ZVNpbmdsZVNhbXBsZU1vb2YgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSAwO1xuICAgIHQuaXNfc3luYyA/IGUgPSAxIDw8IDI1IDogZSA9IDY1NTM2O1xuICAgIHZhciBpID0gbmV3IG4ubW9vZkJveCgpO1xuICAgIGkuYWRkKFwibWZoZFwiKS5zZXQoXCJzZXF1ZW5jZV9udW1iZXJcIiwgdGhpcy5uZXh0TW9vZk51bWJlciksIHRoaXMubmV4dE1vb2ZOdW1iZXIrKztcbiAgICB2YXIgcyA9IGkuYWRkKFwidHJhZlwiKSwgbyA9IHRoaXMuZ2V0VHJhY2tCeUlkKHQudHJhY2tfaWQpO1xuICAgIHJldHVybiBzLmFkZChcInRmaGRcIikuc2V0KFwidHJhY2tfaWRcIiwgdC50cmFja19pZCkuc2V0KFwiZmxhZ3NcIiwgbi5URkhEX0ZMQUdfREVGQVVMVF9CQVNFX0lTX01PT0YpLCBzLmFkZChcInRmZHRcIikuc2V0KFwiYmFzZU1lZGlhRGVjb2RlVGltZVwiLCB0LmR0cyAtIChvLmZpcnN0X2R0cyB8fCAwKSksIHMuYWRkKFwidHJ1blwiKS5zZXQoXCJmbGFnc1wiLCBuLlRSVU5fRkxBR1NfREFUQV9PRkZTRVQgfCBuLlRSVU5fRkxBR1NfRFVSQVRJT04gfCBuLlRSVU5fRkxBR1NfU0laRSB8IG4uVFJVTl9GTEFHU19GTEFHUyB8IG4uVFJVTl9GTEFHU19DVFNfT0ZGU0VUKS5zZXQoXCJkYXRhX29mZnNldFwiLCAwKS5zZXQoXCJmaXJzdF9zYW1wbGVfZmxhZ3NcIiwgMCkuc2V0KFwic2FtcGxlX2NvdW50XCIsIDEpLnNldChcInNhbXBsZV9kdXJhdGlvblwiLCBbdC5kdXJhdGlvbl0pLnNldChcInNhbXBsZV9zaXplXCIsIFt0LnNpemVdKS5zZXQoXCJzYW1wbGVfZmxhZ3NcIiwgW2VdKS5zZXQoXCJzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcIiwgW3QuY3RzIC0gdC5kdHNdKSwgaTtcbiAgfSwgeS5wcm90b3R5cGUubGFzdE1vb2ZJbmRleCA9IDAsIHkucHJvdG90eXBlLnNhbXBsZXNEYXRhU2l6ZSA9IDAsIHkucHJvdG90eXBlLnJlc2V0VGFibGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQsIGUsIGksIHMsIG8sIGMsIHUsIF87XG4gICAgZm9yICh0aGlzLmluaXRpYWxfZHVyYXRpb24gPSB0aGlzLm1vb3YubXZoZC5kdXJhdGlvbiwgdGhpcy5tb292Lm12aGQuZHVyYXRpb24gPSAwLCB0ID0gMDsgdCA8IHRoaXMubW9vdi50cmFrcy5sZW5ndGg7IHQrKykge1xuICAgICAgZSA9IHRoaXMubW9vdi50cmFrc1t0XSwgZS50a2hkLmR1cmF0aW9uID0gMCwgZS5tZGlhLm1kaGQuZHVyYXRpb24gPSAwLCBpID0gZS5tZGlhLm1pbmYuc3RibC5zdGNvIHx8IGUubWRpYS5taW5mLnN0YmwuY282NCwgaS5jaHVua19vZmZzZXRzID0gW10sIHMgPSBlLm1kaWEubWluZi5zdGJsLnN0c2MsIHMuZmlyc3RfY2h1bmsgPSBbXSwgcy5zYW1wbGVzX3Blcl9jaHVuayA9IFtdLCBzLnNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCA9IFtdLCBvID0gZS5tZGlhLm1pbmYuc3RibC5zdHN6IHx8IGUubWRpYS5taW5mLnN0Ymwuc3R6Miwgby5zYW1wbGVfc2l6ZXMgPSBbXSwgYyA9IGUubWRpYS5taW5mLnN0Ymwuc3R0cywgYy5zYW1wbGVfY291bnRzID0gW10sIGMuc2FtcGxlX2RlbHRhcyA9IFtdLCB1ID0gZS5tZGlhLm1pbmYuc3RibC5jdHRzLCB1ICYmICh1LnNhbXBsZV9jb3VudHMgPSBbXSwgdS5zYW1wbGVfb2Zmc2V0cyA9IFtdKSwgXyA9IGUubWRpYS5taW5mLnN0Ymwuc3RzcztcbiAgICAgIHZhciBnID0gZS5tZGlhLm1pbmYuc3RibC5ib3hlcy5pbmRleE9mKF8pO1xuICAgICAgZyAhPSAtMSAmJiAoZS5tZGlhLm1pbmYuc3RibC5ib3hlc1tnXSA9IG51bGwpO1xuICAgIH1cbiAgfSwgeS5pbml0U2FtcGxlR3JvdXBzID0gZnVuY3Rpb24odCwgZSwgaSwgcywgbykge1xuICAgIHZhciBjLCB1LCBfLCBnO1xuICAgIGZ1bmN0aW9uIHcoUywgVSwgQykge1xuICAgICAgdGhpcy5ncm91cGluZ190eXBlID0gUywgdGhpcy5ncm91cGluZ190eXBlX3BhcmFtZXRlciA9IFUsIHRoaXMuc2JncCA9IEMsIHRoaXMubGFzdF9zYW1wbGVfaW5fcnVuID0gLTEsIHRoaXMuZW50cnlfaW5kZXggPSAtMTtcbiAgICB9XG4gICAgZm9yIChlICYmIChlLnNhbXBsZV9ncm91cHNfaW5mbyA9IFtdKSwgdC5zYW1wbGVfZ3JvdXBzX2luZm8gfHwgKHQuc2FtcGxlX2dyb3Vwc19pbmZvID0gW10pLCB1ID0gMDsgdSA8IGkubGVuZ3RoOyB1KyspIHtcbiAgICAgIGZvciAoZyA9IGlbdV0uZ3JvdXBpbmdfdHlwZSArIFwiL1wiICsgaVt1XS5ncm91cGluZ190eXBlX3BhcmFtZXRlciwgXyA9IG5ldyB3KGlbdV0uZ3JvdXBpbmdfdHlwZSwgaVt1XS5ncm91cGluZ190eXBlX3BhcmFtZXRlciwgaVt1XSksIGUgJiYgKGUuc2FtcGxlX2dyb3Vwc19pbmZvW2ddID0gXyksIHQuc2FtcGxlX2dyb3Vwc19pbmZvW2ddIHx8ICh0LnNhbXBsZV9ncm91cHNfaW5mb1tnXSA9IF8pLCBjID0gMDsgYyA8IHMubGVuZ3RoOyBjKyspXG4gICAgICAgIHNbY10uZ3JvdXBpbmdfdHlwZSA9PT0gaVt1XS5ncm91cGluZ190eXBlICYmIChfLmRlc2NyaXB0aW9uID0gc1tjXSwgXy5kZXNjcmlwdGlvbi51c2VkID0gITApO1xuICAgICAgaWYgKG8pXG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBvLmxlbmd0aDsgYysrKVxuICAgICAgICAgIG9bY10uZ3JvdXBpbmdfdHlwZSA9PT0gaVt1XS5ncm91cGluZ190eXBlICYmIChfLmZyYWdtZW50X2Rlc2NyaXB0aW9uID0gb1tjXSwgXy5mcmFnbWVudF9kZXNjcmlwdGlvbi51c2VkID0gITAsIF8uaXNfZnJhZ21lbnQgPSAhMCk7XG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICBpZiAobylcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8IG8ubGVuZ3RoOyB1KyspXG4gICAgICAgICAgIW9bdV0udXNlZCAmJiBvW3VdLnZlcnNpb24gPj0gMiAmJiAoZyA9IG9bdV0uZ3JvdXBpbmdfdHlwZSArIFwiLzBcIiwgXyA9IG5ldyB3KG9bdV0uZ3JvdXBpbmdfdHlwZSwgMCksIF8uaXNfZnJhZ21lbnQgPSAhMCwgZS5zYW1wbGVfZ3JvdXBzX2luZm9bZ10gfHwgKGUuc2FtcGxlX2dyb3Vwc19pbmZvW2ddID0gXykpO1xuICAgIH0gZWxzZVxuICAgICAgZm9yICh1ID0gMDsgdSA8IHMubGVuZ3RoOyB1KyspXG4gICAgICAgICFzW3VdLnVzZWQgJiYgc1t1XS52ZXJzaW9uID49IDIgJiYgKGcgPSBzW3VdLmdyb3VwaW5nX3R5cGUgKyBcIi8wXCIsIF8gPSBuZXcgdyhzW3VdLmdyb3VwaW5nX3R5cGUsIDApLCB0LnNhbXBsZV9ncm91cHNfaW5mb1tnXSB8fCAodC5zYW1wbGVfZ3JvdXBzX2luZm9bZ10gPSBfKSk7XG4gIH0sIHkuc2V0U2FtcGxlR3JvdXBQcm9wZXJ0aWVzID0gZnVuY3Rpb24odCwgZSwgaSwgcykge1xuICAgIHZhciBvLCBjO1xuICAgIGUuc2FtcGxlX2dyb3VwcyA9IFtdO1xuICAgIGZvciAobyBpbiBzKVxuICAgICAgaWYgKGUuc2FtcGxlX2dyb3Vwc1tvXSA9IHt9LCBlLnNhbXBsZV9ncm91cHNbb10uZ3JvdXBpbmdfdHlwZSA9IHNbb10uZ3JvdXBpbmdfdHlwZSwgZS5zYW1wbGVfZ3JvdXBzW29dLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyID0gc1tvXS5ncm91cGluZ190eXBlX3BhcmFtZXRlciwgaSA+PSBzW29dLmxhc3Rfc2FtcGxlX2luX3J1biAmJiAoc1tvXS5sYXN0X3NhbXBsZV9pbl9ydW4gPCAwICYmIChzW29dLmxhc3Rfc2FtcGxlX2luX3J1biA9IDApLCBzW29dLmVudHJ5X2luZGV4KyssIHNbb10uZW50cnlfaW5kZXggPD0gc1tvXS5zYmdwLmVudHJpZXMubGVuZ3RoIC0gMSAmJiAoc1tvXS5sYXN0X3NhbXBsZV9pbl9ydW4gKz0gc1tvXS5zYmdwLmVudHJpZXNbc1tvXS5lbnRyeV9pbmRleF0uc2FtcGxlX2NvdW50KSksIHNbb10uZW50cnlfaW5kZXggPD0gc1tvXS5zYmdwLmVudHJpZXMubGVuZ3RoIC0gMSA/IGUuc2FtcGxlX2dyb3Vwc1tvXS5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCA9IHNbb10uc2JncC5lbnRyaWVzW3Nbb10uZW50cnlfaW5kZXhdLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4IDogZS5zYW1wbGVfZ3JvdXBzW29dLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ID0gLTEsIGUuc2FtcGxlX2dyb3Vwc1tvXS5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCAhPT0gMCkge1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgc1tvXS5mcmFnbWVudF9kZXNjcmlwdGlvbiA/IHUgPSBzW29dLmZyYWdtZW50X2Rlc2NyaXB0aW9uIDogdSA9IHNbb10uZGVzY3JpcHRpb24sIGUuc2FtcGxlX2dyb3Vwc1tvXS5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCA+IDAgPyAoZS5zYW1wbGVfZ3JvdXBzW29dLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ID4gNjU1MzUgPyBjID0gKGUuc2FtcGxlX2dyb3Vwc1tvXS5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCA+PiAxNikgLSAxIDogYyA9IGUuc2FtcGxlX2dyb3Vwc1tvXS5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCAtIDEsIHUgJiYgYyA+PSAwICYmIChlLnNhbXBsZV9ncm91cHNbb10uZGVzY3JpcHRpb24gPSB1LmVudHJpZXNbY10pKSA6IHUgJiYgdS52ZXJzaW9uID49IDIgJiYgdS5kZWZhdWx0X2dyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ID4gMCAmJiAoZS5zYW1wbGVfZ3JvdXBzW29dLmRlc2NyaXB0aW9uID0gdS5lbnRyaWVzW3UuZGVmYXVsdF9ncm91cF9kZXNjcmlwdGlvbl9pbmRleCAtIDFdKTtcbiAgICAgIH1cbiAgfSwgeS5wcm9jZXNzX3NkdHAgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gICAgZSAmJiAodCA/IChlLmlzX2xlYWRpbmcgPSB0LmlzX2xlYWRpbmdbaV0sIGUuZGVwZW5kc19vbiA9IHQuc2FtcGxlX2RlcGVuZHNfb25baV0sIGUuaXNfZGVwZW5kZWRfb24gPSB0LnNhbXBsZV9pc19kZXBlbmRlZF9vbltpXSwgZS5oYXNfcmVkdW5kYW5jeSA9IHQuc2FtcGxlX2hhc19yZWR1bmRhbmN5W2ldKSA6IChlLmlzX2xlYWRpbmcgPSAwLCBlLmRlcGVuZHNfb24gPSAwLCBlLmlzX2RlcGVuZGVkX29uID0gMCwgZS5oYXNfcmVkdW5kYW5jeSA9IDApKTtcbiAgfSwgeS5wcm90b3R5cGUuYnVpbGRTYW1wbGVMaXN0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0LCBlO1xuICAgIGZvciAodCA9IDA7IHQgPCB0aGlzLm1vb3YudHJha3MubGVuZ3RoOyB0KyspXG4gICAgICBlID0gdGhpcy5tb292LnRyYWtzW3RdLCB0aGlzLmJ1aWxkVHJha1NhbXBsZUxpc3RzKGUpO1xuICB9LCB5LnByb3RvdHlwZS5idWlsZFRyYWtTYW1wbGVMaXN0cyA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSwgaSwgcywgbywgYywgdSwgXywgZywgdywgUywgVSwgQywgeCwgUCwgVCwgeXQsIFV0LCBodCwgTywgdHQsIEh0LCBlZSwgZXQsIEV0O1xuICAgIGlmICh0LnNhbXBsZXMgPSBbXSwgdC5zYW1wbGVzX2R1cmF0aW9uID0gMCwgdC5zYW1wbGVzX3NpemUgPSAwLCBpID0gdC5tZGlhLm1pbmYuc3RibC5zdGNvIHx8IHQubWRpYS5taW5mLnN0YmwuY282NCwgcyA9IHQubWRpYS5taW5mLnN0Ymwuc3RzYywgbyA9IHQubWRpYS5taW5mLnN0Ymwuc3RzeiB8fCB0Lm1kaWEubWluZi5zdGJsLnN0ejIsIGMgPSB0Lm1kaWEubWluZi5zdGJsLnN0dHMsIHUgPSB0Lm1kaWEubWluZi5zdGJsLmN0dHMsIF8gPSB0Lm1kaWEubWluZi5zdGJsLnN0c3MsIGcgPSB0Lm1kaWEubWluZi5zdGJsLnN0c2QsIHcgPSB0Lm1kaWEubWluZi5zdGJsLnN1YnMsIEMgPSB0Lm1kaWEubWluZi5zdGJsLnN0ZHAsIFMgPSB0Lm1kaWEubWluZi5zdGJsLnNiZ3BzLCBVID0gdC5tZGlhLm1pbmYuc3RibC5zZ3BkcywgaHQgPSAtMSwgTyA9IC0xLCB0dCA9IC0xLCBIdCA9IC0xLCBlZSA9IDAsIGV0ID0gMCwgRXQgPSAwLCB5LmluaXRTYW1wbGVHcm91cHModCwgbnVsbCwgUywgVSksICEodHlwZW9mIG8gPiBcInVcIikpIHtcbiAgICAgIGZvciAoZSA9IDA7IGUgPCBvLnNhbXBsZV9zaXplcy5sZW5ndGg7IGUrKykge1xuICAgICAgICB2YXIgRiA9IHt9O1xuICAgICAgICBGLm51bWJlciA9IGUsIEYudHJhY2tfaWQgPSB0LnRraGQudHJhY2tfaWQsIEYudGltZXNjYWxlID0gdC5tZGlhLm1kaGQudGltZXNjYWxlLCBGLmFscmVhZHlSZWFkID0gMCwgdC5zYW1wbGVzW2VdID0gRiwgRi5zaXplID0gby5zYW1wbGVfc2l6ZXNbZV0sIHQuc2FtcGxlc19zaXplICs9IEYuc2l6ZSwgZSA9PT0gMCA/IChQID0gMSwgeCA9IDAsIEYuY2h1bmtfaW5kZXggPSBQLCBGLmNodW5rX3J1bl9pbmRleCA9IHgsIFV0ID0gcy5zYW1wbGVzX3Blcl9jaHVua1t4XSwgeXQgPSAwLCB4ICsgMSA8IHMuZmlyc3RfY2h1bmsubGVuZ3RoID8gVCA9IHMuZmlyc3RfY2h1bmtbeCArIDFdIC0gMSA6IFQgPSAxIC8gMCkgOiBlIDwgVXQgPyAoRi5jaHVua19pbmRleCA9IFAsIEYuY2h1bmtfcnVuX2luZGV4ID0geCkgOiAoUCsrLCBGLmNodW5rX2luZGV4ID0gUCwgeXQgPSAwLCBQIDw9IFQgfHwgKHgrKywgeCArIDEgPCBzLmZpcnN0X2NodW5rLmxlbmd0aCA/IFQgPSBzLmZpcnN0X2NodW5rW3ggKyAxXSAtIDEgOiBUID0gMSAvIDApLCBGLmNodW5rX3J1bl9pbmRleCA9IHgsIFV0ICs9IHMuc2FtcGxlc19wZXJfY2h1bmtbeF0pLCBGLmRlc2NyaXB0aW9uX2luZGV4ID0gcy5zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhbRi5jaHVua19ydW5faW5kZXhdIC0gMSwgRi5kZXNjcmlwdGlvbiA9IGcuZW50cmllc1tGLmRlc2NyaXB0aW9uX2luZGV4XSwgRi5vZmZzZXQgPSBpLmNodW5rX29mZnNldHNbRi5jaHVua19pbmRleCAtIDFdICsgeXQsIHl0ICs9IEYuc2l6ZSwgZSA+IGh0ICYmIChPKyssIGh0IDwgMCAmJiAoaHQgPSAwKSwgaHQgKz0gYy5zYW1wbGVfY291bnRzW09dKSwgZSA+IDAgPyAodC5zYW1wbGVzW2UgLSAxXS5kdXJhdGlvbiA9IGMuc2FtcGxlX2RlbHRhc1tPXSwgdC5zYW1wbGVzX2R1cmF0aW9uICs9IHQuc2FtcGxlc1tlIC0gMV0uZHVyYXRpb24sIEYuZHRzID0gdC5zYW1wbGVzW2UgLSAxXS5kdHMgKyB0LnNhbXBsZXNbZSAtIDFdLmR1cmF0aW9uKSA6IEYuZHRzID0gMCwgdSA/IChlID49IHR0ICYmIChIdCsrLCB0dCA8IDAgJiYgKHR0ID0gMCksIHR0ICs9IHUuc2FtcGxlX2NvdW50c1tIdF0pLCBGLmN0cyA9IHQuc2FtcGxlc1tlXS5kdHMgKyB1LnNhbXBsZV9vZmZzZXRzW0h0XSkgOiBGLmN0cyA9IEYuZHRzLCBfID8gKGUgPT0gXy5zYW1wbGVfbnVtYmVyc1tlZV0gLSAxID8gKEYuaXNfc3luYyA9ICEwLCBlZSsrKSA6IChGLmlzX3N5bmMgPSAhMSwgRi5kZWdyYWRhdGlvbl9wcmlvcml0eSA9IDApLCB3ICYmIHcuZW50cmllc1tldF0uc2FtcGxlX2RlbHRhICsgRXQgPT0gZSArIDEgJiYgKEYuc3Vic2FtcGxlcyA9IHcuZW50cmllc1tldF0uc3Vic2FtcGxlcywgRXQgKz0gdy5lbnRyaWVzW2V0XS5zYW1wbGVfZGVsdGEsIGV0KyspKSA6IEYuaXNfc3luYyA9ICEwLCB5LnByb2Nlc3Nfc2R0cCh0Lm1kaWEubWluZi5zdGJsLnNkdHAsIEYsIEYubnVtYmVyKSwgQyA/IEYuZGVncmFkYXRpb25fcHJpb3JpdHkgPSBDLnByaW9yaXR5W2VdIDogRi5kZWdyYWRhdGlvbl9wcmlvcml0eSA9IDAsIHcgJiYgdy5lbnRyaWVzW2V0XS5zYW1wbGVfZGVsdGEgKyBFdCA9PSBlICYmIChGLnN1YnNhbXBsZXMgPSB3LmVudHJpZXNbZXRdLnN1YnNhbXBsZXMsIEV0ICs9IHcuZW50cmllc1tldF0uc2FtcGxlX2RlbHRhKSwgKFMubGVuZ3RoID4gMCB8fCBVLmxlbmd0aCA+IDApICYmIHkuc2V0U2FtcGxlR3JvdXBQcm9wZXJ0aWVzKHQsIEYsIGUsIHQuc2FtcGxlX2dyb3Vwc19pbmZvKTtcbiAgICAgIH1cbiAgICAgIGUgPiAwICYmICh0LnNhbXBsZXNbZSAtIDFdLmR1cmF0aW9uID0gTWF0aC5tYXgodC5tZGlhLm1kaGQuZHVyYXRpb24gLSB0LnNhbXBsZXNbZSAtIDFdLmR0cywgMCksIHQuc2FtcGxlc19kdXJhdGlvbiArPSB0LnNhbXBsZXNbZSAtIDFdLmR1cmF0aW9uKTtcbiAgICB9XG4gIH0sIHkucHJvdG90eXBlLnVwZGF0ZVNhbXBsZUxpc3RzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQsIGUsIGksIHMsIG8sIGMsIHUsIF8sIGcsIHcsIFMsIFUsIEMsIHgsIFA7XG4gICAgaWYgKHRoaXMubW9vdiAhPT0gdm9pZCAwKSB7XG4gICAgICBmb3IgKDsgdGhpcy5sYXN0TW9vZkluZGV4IDwgdGhpcy5tb29mcy5sZW5ndGg7IClcbiAgICAgICAgaWYgKGcgPSB0aGlzLm1vb2ZzW3RoaXMubGFzdE1vb2ZJbmRleF0sIHRoaXMubGFzdE1vb2ZJbmRleCsrLCBnLnR5cGUgPT0gXCJtb29mXCIpXG4gICAgICAgICAgZm9yICh3ID0gZywgdCA9IDA7IHQgPCB3LnRyYWZzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBmb3IgKFMgPSB3LnRyYWZzW3RdLCBVID0gdGhpcy5nZXRUcmFja0J5SWQoUy50ZmhkLnRyYWNrX2lkKSwgQyA9IHRoaXMuZ2V0VHJleEJ5SWQoUy50ZmhkLnRyYWNrX2lkKSwgUy50ZmhkLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX0RFU0MgPyBzID0gUy50ZmhkLmRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4IDogcyA9IEMgPyBDLmRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4IDogMSwgUy50ZmhkLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX0RVUiA/IG8gPSBTLnRmaGQuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gOiBvID0gQyA/IEMuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gOiAwLCBTLnRmaGQuZmxhZ3MgJiBuLlRGSERfRkxBR19TQU1QTEVfU0laRSA/IGMgPSBTLnRmaGQuZGVmYXVsdF9zYW1wbGVfc2l6ZSA6IGMgPSBDID8gQy5kZWZhdWx0X3NhbXBsZV9zaXplIDogMCwgUy50ZmhkLmZsYWdzICYgbi5URkhEX0ZMQUdfU0FNUExFX0ZMQUdTID8gdSA9IFMudGZoZC5kZWZhdWx0X3NhbXBsZV9mbGFncyA6IHUgPSBDID8gQy5kZWZhdWx0X3NhbXBsZV9mbGFncyA6IDAsIFMuc2FtcGxlX251bWJlciA9IDAsIFMuc2JncHMubGVuZ3RoID4gMCAmJiB5LmluaXRTYW1wbGVHcm91cHMoVSwgUywgUy5zYmdwcywgVS5tZGlhLm1pbmYuc3RibC5zZ3BkcywgUy5zZ3BkcyksIGUgPSAwOyBlIDwgUy50cnVucy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgICAgICB2YXIgVCA9IFMudHJ1bnNbZV07XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBULnNhbXBsZV9jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeCA9IHt9LCB4Lm1vb2ZfbnVtYmVyID0gdGhpcy5sYXN0TW9vZkluZGV4LCB4Lm51bWJlcl9pbl90cmFmID0gUy5zYW1wbGVfbnVtYmVyLCBTLnNhbXBsZV9udW1iZXIrKywgeC5udW1iZXIgPSBVLnNhbXBsZXMubGVuZ3RoLCBTLmZpcnN0X3NhbXBsZV9pbmRleCA9IFUuc2FtcGxlcy5sZW5ndGgsIFUuc2FtcGxlcy5wdXNoKHgpLCB4LnRyYWNrX2lkID0gVS50a2hkLnRyYWNrX2lkLCB4LnRpbWVzY2FsZSA9IFUubWRpYS5tZGhkLnRpbWVzY2FsZSwgeC5kZXNjcmlwdGlvbl9pbmRleCA9IHMgLSAxLCB4LmRlc2NyaXB0aW9uID0gVS5tZGlhLm1pbmYuc3RibC5zdHNkLmVudHJpZXNbeC5kZXNjcmlwdGlvbl9pbmRleF0sIHguc2l6ZSA9IGMsIFQuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfU0laRSAmJiAoeC5zaXplID0gVC5zYW1wbGVfc2l6ZVtpXSksIFUuc2FtcGxlc19zaXplICs9IHguc2l6ZSwgeC5kdXJhdGlvbiA9IG8sIFQuZmxhZ3MgJiBuLlRSVU5fRkxBR1NfRFVSQVRJT04gJiYgKHguZHVyYXRpb24gPSBULnNhbXBsZV9kdXJhdGlvbltpXSksIFUuc2FtcGxlc19kdXJhdGlvbiArPSB4LmR1cmF0aW9uLCBVLmZpcnN0X3RyYWZfbWVyZ2VkIHx8IGkgPiAwID8geC5kdHMgPSBVLnNhbXBsZXNbVS5zYW1wbGVzLmxlbmd0aCAtIDJdLmR0cyArIFUuc2FtcGxlc1tVLnNhbXBsZXMubGVuZ3RoIC0gMl0uZHVyYXRpb24gOiAoUy50ZmR0ID8geC5kdHMgPSBTLnRmZHQuYmFzZU1lZGlhRGVjb2RlVGltZSA6IHguZHRzID0gMCwgVS5maXJzdF90cmFmX21lcmdlZCA9ICEwKSwgeC5jdHMgPSB4LmR0cywgVC5mbGFncyAmIG4uVFJVTl9GTEFHU19DVFNfT0ZGU0VUICYmICh4LmN0cyA9IHguZHRzICsgVC5zYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRbaV0pLCBQID0gdSwgVC5mbGFncyAmIG4uVFJVTl9GTEFHU19GTEFHUyA/IFAgPSBULnNhbXBsZV9mbGFnc1tpXSA6IGkgPT09IDAgJiYgVC5mbGFncyAmIG4uVFJVTl9GTEFHU19GSVJTVF9GTEFHICYmIChQID0gVC5maXJzdF9zYW1wbGVfZmxhZ3MpLCB4LmlzX3N5bmMgPSAhKFAgPj4gMTYgJiAxKSwgeC5pc19sZWFkaW5nID0gUCA+PiAyNiAmIDMsIHguZGVwZW5kc19vbiA9IFAgPj4gMjQgJiAzLCB4LmlzX2RlcGVuZGVkX29uID0gUCA+PiAyMiAmIDMsIHguaGFzX3JlZHVuZGFuY3kgPSBQID4+IDIwICYgMywgeC5kZWdyYWRhdGlvbl9wcmlvcml0eSA9IFAgJiA2NTUzNTtcbiAgICAgICAgICAgICAgICB2YXIgeXQgPSAhIShTLnRmaGQuZmxhZ3MgJiBuLlRGSERfRkxBR19CQVNFX0RBVEFfT0ZGU0VUKSwgVXQgPSAhIShTLnRmaGQuZmxhZ3MgJiBuLlRGSERfRkxBR19ERUZBVUxUX0JBU0VfSVNfTU9PRiksIGh0ID0gISEoVC5mbGFncyAmIG4uVFJVTl9GTEFHU19EQVRBX09GRlNFVCksIE8gPSAwO1xuICAgICAgICAgICAgICAgIHl0ID8gTyA9IFMudGZoZC5iYXNlX2RhdGFfb2Zmc2V0IDogVXQgfHwgZSA9PT0gMCA/IE8gPSB3LnN0YXJ0IDogTyA9IF8sIGUgPT09IDAgJiYgaSA9PT0gMCA/IGh0ID8geC5vZmZzZXQgPSBPICsgVC5kYXRhX29mZnNldCA6IHgub2Zmc2V0ID0gTyA6IHgub2Zmc2V0ID0gXywgXyA9IHgub2Zmc2V0ICsgeC5zaXplLCAoUy5zYmdwcy5sZW5ndGggPiAwIHx8IFMuc2dwZHMubGVuZ3RoID4gMCB8fCBVLm1kaWEubWluZi5zdGJsLnNiZ3BzLmxlbmd0aCA+IDAgfHwgVS5tZGlhLm1pbmYuc3RibC5zZ3Bkcy5sZW5ndGggPiAwKSAmJiB5LnNldFNhbXBsZUdyb3VwUHJvcGVydGllcyhVLCB4LCB4Lm51bWJlcl9pbl90cmFmLCBTLnNhbXBsZV9ncm91cHNfaW5mbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChTLnN1YnMpIHtcbiAgICAgICAgICAgICAgVS5oYXNfZnJhZ21lbnRfc3Vic2FtcGxlcyA9ICEwO1xuICAgICAgICAgICAgICB2YXIgdHQgPSBTLmZpcnN0X3NhbXBsZV9pbmRleDtcbiAgICAgICAgICAgICAgZm9yIChlID0gMDsgZSA8IFMuc3Vicy5lbnRyaWVzLmxlbmd0aDsgZSsrKVxuICAgICAgICAgICAgICAgIHR0ICs9IFMuc3Vicy5lbnRyaWVzW2VdLnNhbXBsZV9kZWx0YSwgeCA9IFUuc2FtcGxlc1t0dCAtIDFdLCB4LnN1YnNhbXBsZXMgPSBTLnN1YnMuZW50cmllc1tlXS5zdWJzYW1wbGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICB9XG4gIH0sIHkucHJvdG90eXBlLmdldFNhbXBsZSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB2YXIgaSwgcyA9IHQuc2FtcGxlc1tlXTtcbiAgICBpZiAoIXRoaXMubW9vdilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICghcy5kYXRhKVxuICAgICAgcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkocy5zaXplKSwgcy5hbHJlYWR5UmVhZCA9IDAsIHRoaXMuc2FtcGxlc0RhdGFTaXplICs9IHMuc2l6ZSwgci5kZWJ1ZyhcIklTT0ZpbGVcIiwgXCJBbGxvY2F0aW5nIHNhbXBsZSAjXCIgKyBlICsgXCIgb24gdHJhY2sgI1wiICsgdC50a2hkLnRyYWNrX2lkICsgXCIgb2Ygc2l6ZSBcIiArIHMuc2l6ZSArIFwiICh0b3RhbDogXCIgKyB0aGlzLnNhbXBsZXNEYXRhU2l6ZSArIFwiKVwiKTtcbiAgICBlbHNlIGlmIChzLmFscmVhZHlSZWFkID09IHMuc2l6ZSlcbiAgICAgIHJldHVybiBzO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgdmFyIG8gPSB0aGlzLnN0cmVhbS5maW5kUG9zaXRpb24oITAsIHMub2Zmc2V0ICsgcy5hbHJlYWR5UmVhZCwgITEpO1xuICAgICAgaWYgKG8gPiAtMSkge1xuICAgICAgICBpID0gdGhpcy5zdHJlYW0uYnVmZmVyc1tvXTtcbiAgICAgICAgdmFyIGMgPSBpLmJ5dGVMZW5ndGggLSAocy5vZmZzZXQgKyBzLmFscmVhZHlSZWFkIC0gaS5maWxlU3RhcnQpO1xuICAgICAgICBpZiAocy5zaXplIC0gcy5hbHJlYWR5UmVhZCA8PSBjKVxuICAgICAgICAgIHJldHVybiByLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkdldHRpbmcgc2FtcGxlICNcIiArIGUgKyBcIiBkYXRhIChhbHJlYWR5UmVhZDogXCIgKyBzLmFscmVhZHlSZWFkICsgXCIgb2Zmc2V0OiBcIiArIChzLm9mZnNldCArIHMuYWxyZWFkeVJlYWQgLSBpLmZpbGVTdGFydCkgKyBcIiByZWFkIHNpemU6IFwiICsgKHMuc2l6ZSAtIHMuYWxyZWFkeVJlYWQpICsgXCIgZnVsbCBzaXplOiBcIiArIHMuc2l6ZSArIFwiKVwiKSwgYS5tZW1jcHkoXG4gICAgICAgICAgICBzLmRhdGEuYnVmZmVyLFxuICAgICAgICAgICAgcy5hbHJlYWR5UmVhZCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzLm9mZnNldCArIHMuYWxyZWFkeVJlYWQgLSBpLmZpbGVTdGFydCxcbiAgICAgICAgICAgIHMuc2l6ZSAtIHMuYWxyZWFkeVJlYWRcbiAgICAgICAgICApLCBpLnVzZWRCeXRlcyArPSBzLnNpemUgLSBzLmFscmVhZHlSZWFkLCB0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCgpLCBzLmFscmVhZHlSZWFkID0gcy5zaXplLCBzO1xuICAgICAgICBpZiAoYyA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHIuZGVidWcoXCJJU09GaWxlXCIsIFwiR2V0dGluZyBzYW1wbGUgI1wiICsgZSArIFwiIHBhcnRpYWwgZGF0YSAoYWxyZWFkeVJlYWQ6IFwiICsgcy5hbHJlYWR5UmVhZCArIFwiIG9mZnNldDogXCIgKyAocy5vZmZzZXQgKyBzLmFscmVhZHlSZWFkIC0gaS5maWxlU3RhcnQpICsgXCIgcmVhZCBzaXplOiBcIiArIGMgKyBcIiBmdWxsIHNpemU6IFwiICsgcy5zaXplICsgXCIpXCIpLCBhLm1lbWNweShcbiAgICAgICAgICBzLmRhdGEuYnVmZmVyLFxuICAgICAgICAgIHMuYWxyZWFkeVJlYWQsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBzLm9mZnNldCArIHMuYWxyZWFkeVJlYWQgLSBpLmZpbGVTdGFydCxcbiAgICAgICAgICBjXG4gICAgICAgICksIHMuYWxyZWFkeVJlYWQgKz0gYywgaS51c2VkQnl0ZXMgKz0gYywgdGhpcy5zdHJlYW0ubG9nQnVmZmVyTGV2ZWwoKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHkucHJvdG90eXBlLnJlbGVhc2VTYW1wbGUgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIGkgPSB0LnNhbXBsZXNbZV07XG4gICAgcmV0dXJuIGkuZGF0YSA/ICh0aGlzLnNhbXBsZXNEYXRhU2l6ZSAtPSBpLnNpemUsIGkuZGF0YSA9IG51bGwsIGkuYWxyZWFkeVJlYWQgPSAwLCBpLnNpemUpIDogMDtcbiAgfSwgeS5wcm90b3R5cGUuZ2V0QWxsb2NhdGVkU2FtcGxlRGF0YVNpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVzRGF0YVNpemU7XG4gIH0sIHkucHJvdG90eXBlLmdldENvZGVjcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0LCBlID0gXCJcIjtcbiAgICBmb3IgKHQgPSAwOyB0IDwgdGhpcy5tb292LnRyYWtzLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgaSA9IHRoaXMubW9vdi50cmFrc1t0XTtcbiAgICAgIHQgPiAwICYmIChlICs9IFwiLFwiKSwgZSArPSBpLm1kaWEubWluZi5zdGJsLnN0c2QuZW50cmllc1swXS5nZXRDb2RlYygpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgeS5wcm90b3R5cGUuZ2V0VHJleEJ5SWQgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKCF0aGlzLm1vb3YgfHwgIXRoaXMubW9vdi5tdmV4KSByZXR1cm4gbnVsbDtcbiAgICBmb3IgKGUgPSAwOyBlIDwgdGhpcy5tb292Lm12ZXgudHJleHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBpID0gdGhpcy5tb292Lm12ZXgudHJleHNbZV07XG4gICAgICBpZiAoaS50cmFja19pZCA9PSB0KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sIHkucHJvdG90eXBlLmdldFRyYWNrQnlJZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodGhpcy5tb292ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMubW9vdi50cmFrcy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIGkgPSB0aGlzLm1vb3YudHJha3NbZV07XG4gICAgICBpZiAoaS50a2hkLnRyYWNrX2lkID09IHQpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSwgeS5wcm90b3R5cGUuaXRlbXMgPSBbXSwgeS5wcm90b3R5cGUuaXRlbXNEYXRhU2l6ZSA9IDAsIHkucHJvdG90eXBlLmZsYXR0ZW5JdGVtSW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gdGhpcy5pdGVtcywgZSwgaSwgcywgbyA9IHRoaXMubWV0YTtcbiAgICBpZiAobyAhPSBudWxsICYmIG8uaGRsciAhPT0gdm9pZCAwICYmIG8uaWluZiAhPT0gdm9pZCAwKSB7XG4gICAgICBmb3IgKGUgPSAwOyBlIDwgby5paW5mLml0ZW1faW5mb3MubGVuZ3RoOyBlKyspXG4gICAgICAgIHMgPSB7fSwgcy5pZCA9IG8uaWluZi5pdGVtX2luZm9zW2VdLml0ZW1fSUQsIHRbcy5pZF0gPSBzLCBzLnJlZl90byA9IFtdLCBzLm5hbWUgPSBvLmlpbmYuaXRlbV9pbmZvc1tlXS5pdGVtX25hbWUsIG8uaWluZi5pdGVtX2luZm9zW2VdLnByb3RlY3Rpb25faW5kZXggPiAwICYmIChzLnByb3RlY3Rpb24gPSBvLmlwcm8ucHJvdGVjdGlvbnNbby5paW5mLml0ZW1faW5mb3NbZV0ucHJvdGVjdGlvbl9pbmRleCAtIDFdKSwgby5paW5mLml0ZW1faW5mb3NbZV0uaXRlbV90eXBlID8gcy50eXBlID0gby5paW5mLml0ZW1faW5mb3NbZV0uaXRlbV90eXBlIDogcy50eXBlID0gXCJtaW1lXCIsIHMuY29udGVudF90eXBlID0gby5paW5mLml0ZW1faW5mb3NbZV0uY29udGVudF90eXBlLCBzLmNvbnRlbnRfZW5jb2RpbmcgPSBvLmlpbmYuaXRlbV9pbmZvc1tlXS5jb250ZW50X2VuY29kaW5nO1xuICAgICAgaWYgKG8uaWxvYylcbiAgICAgICAgZm9yIChlID0gMDsgZSA8IG8uaWxvYy5pdGVtcy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgIHZhciBjID0gby5pbG9jLml0ZW1zW2VdO1xuICAgICAgICAgIHN3aXRjaCAocyA9IHRbYy5pdGVtX0lEXSwgYy5kYXRhX3JlZmVyZW5jZV9pbmRleCAhPT0gMCAmJiAoci53YXJuKFwiSXRlbSBzdG9yYWdlIHdpdGggcmVmZXJlbmNlIHRvIG90aGVyIGZpbGVzOiBub3Qgc3VwcG9ydGVkXCIpLCBzLnNvdXJjZSA9IG8uZGluZi5ib3hlc1tjLmRhdGFfcmVmZXJlbmNlX2luZGV4IC0gMV0pLCBjLmNvbnN0cnVjdGlvbl9tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHIud2FybihcIkl0ZW0gc3RvcmFnZSB3aXRoIGNvbnN0cnVjdGlvbl9tZXRob2QgOiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgci53YXJuKFwiSXRlbSBzdG9yYWdlIHdpdGggY29uc3RydWN0aW9uX21ldGhvZCA6IG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHMuZXh0ZW50cyA9IFtdLCBzLnNpemUgPSAwLCBpID0gMDsgaSA8IGMuZXh0ZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHMuZXh0ZW50c1tpXSA9IHt9LCBzLmV4dGVudHNbaV0ub2Zmc2V0ID0gYy5leHRlbnRzW2ldLmV4dGVudF9vZmZzZXQgKyBjLmJhc2Vfb2Zmc2V0LCBzLmV4dGVudHNbaV0ubGVuZ3RoID0gYy5leHRlbnRzW2ldLmV4dGVudF9sZW5ndGgsIHMuZXh0ZW50c1tpXS5hbHJlYWR5UmVhZCA9IDAsIHMuc2l6ZSArPSBzLmV4dGVudHNbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICBpZiAoby5waXRtICYmICh0W28ucGl0bS5pdGVtX2lkXS5wcmltYXJ5ID0gITApLCBvLmlyZWYpXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCBvLmlyZWYucmVmZXJlbmNlcy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgIHZhciB1ID0gby5pcmVmLnJlZmVyZW5jZXNbZV07XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHUucmVmZXJlbmNlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRbdS5mcm9tX2l0ZW1fSURdLnJlZl90by5wdXNoKHsgdHlwZTogdS50eXBlLCBpZDogdS5yZWZlcmVuY2VzW2ldIH0pO1xuICAgICAgICB9XG4gICAgICBpZiAoby5pcHJwKVxuICAgICAgICBmb3IgKHZhciBfID0gMDsgXyA8IG8uaXBycC5pcG1hcy5sZW5ndGg7IF8rKykge1xuICAgICAgICAgIHZhciBnID0gby5pcHJwLmlwbWFzW19dO1xuICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCBnLmFzc29jaWF0aW9ucy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgICAgdmFyIHcgPSBnLmFzc29jaWF0aW9uc1tlXTtcbiAgICAgICAgICAgIGZvciAocyA9IHRbdy5pZF0sIHMucHJvcGVydGllcyA9PT0gdm9pZCAwICYmIChzLnByb3BlcnRpZXMgPSB7fSwgcy5wcm9wZXJ0aWVzLmJveGVzID0gW10pLCBpID0gMDsgaSA8IHcucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIFMgPSB3LnByb3BzW2ldO1xuICAgICAgICAgICAgICBpZiAoUy5wcm9wZXJ0eV9pbmRleCA+IDAgJiYgUy5wcm9wZXJ0eV9pbmRleCAtIDEgPCBvLmlwcnAuaXBjby5ib3hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgVSA9IG8uaXBycC5pcGNvLmJveGVzW1MucHJvcGVydHlfaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBzLnByb3BlcnRpZXNbVS50eXBlXSA9IFUsIHMucHJvcGVydGllcy5ib3hlcy5wdXNoKFUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9LCB5LnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBlLCBpO1xuICAgIGlmICghdGhpcy5tZXRhKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGkgPSB0aGlzLml0ZW1zW3RdLCAhaS5kYXRhICYmIGkuc2l6ZSlcbiAgICAgIGkuZGF0YSA9IG5ldyBVaW50OEFycmF5KGkuc2l6ZSksIGkuYWxyZWFkeVJlYWQgPSAwLCB0aGlzLml0ZW1zRGF0YVNpemUgKz0gaS5zaXplLCByLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkFsbG9jYXRpbmcgaXRlbSAjXCIgKyB0ICsgXCIgb2Ygc2l6ZSBcIiArIGkuc2l6ZSArIFwiICh0b3RhbDogXCIgKyB0aGlzLml0ZW1zRGF0YVNpemUgKyBcIilcIik7XG4gICAgZWxzZSBpZiAoaS5hbHJlYWR5UmVhZCA9PT0gaS5zaXplKVxuICAgICAgcmV0dXJuIGk7XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBpLmV4dGVudHMubGVuZ3RoOyBzKyspIHtcbiAgICAgIHZhciBvID0gaS5leHRlbnRzW3NdO1xuICAgICAgaWYgKG8uYWxyZWFkeVJlYWQgIT09IG8ubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5zdHJlYW0uZmluZFBvc2l0aW9uKCEwLCBvLm9mZnNldCArIG8uYWxyZWFkeVJlYWQsICExKTtcbiAgICAgICAgaWYgKGMgPiAtMSkge1xuICAgICAgICAgIGUgPSB0aGlzLnN0cmVhbS5idWZmZXJzW2NdO1xuICAgICAgICAgIHZhciB1ID0gZS5ieXRlTGVuZ3RoIC0gKG8ub2Zmc2V0ICsgby5hbHJlYWR5UmVhZCAtIGUuZmlsZVN0YXJ0KTtcbiAgICAgICAgICBpZiAoby5sZW5ndGggLSBvLmFscmVhZHlSZWFkIDw9IHUpXG4gICAgICAgICAgICByLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkdldHRpbmcgaXRlbSAjXCIgKyB0ICsgXCIgZXh0ZW50ICNcIiArIHMgKyBcIiBkYXRhIChhbHJlYWR5UmVhZDogXCIgKyBvLmFscmVhZHlSZWFkICsgXCIgb2Zmc2V0OiBcIiArIChvLm9mZnNldCArIG8uYWxyZWFkeVJlYWQgLSBlLmZpbGVTdGFydCkgKyBcIiByZWFkIHNpemU6IFwiICsgKG8ubGVuZ3RoIC0gby5hbHJlYWR5UmVhZCkgKyBcIiBmdWxsIGV4dGVudCBzaXplOiBcIiArIG8ubGVuZ3RoICsgXCIgZnVsbCBpdGVtIHNpemU6IFwiICsgaS5zaXplICsgXCIpXCIpLCBhLm1lbWNweShcbiAgICAgICAgICAgICAgaS5kYXRhLmJ1ZmZlcixcbiAgICAgICAgICAgICAgaS5hbHJlYWR5UmVhZCxcbiAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgby5vZmZzZXQgKyBvLmFscmVhZHlSZWFkIC0gZS5maWxlU3RhcnQsXG4gICAgICAgICAgICAgIG8ubGVuZ3RoIC0gby5hbHJlYWR5UmVhZFxuICAgICAgICAgICAgKSwgZS51c2VkQnl0ZXMgKz0gby5sZW5ndGggLSBvLmFscmVhZHlSZWFkLCB0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCgpLCBpLmFscmVhZHlSZWFkICs9IG8ubGVuZ3RoIC0gby5hbHJlYWR5UmVhZCwgby5hbHJlYWR5UmVhZCA9IG8ubGVuZ3RoO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiByLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkdldHRpbmcgaXRlbSAjXCIgKyB0ICsgXCIgZXh0ZW50ICNcIiArIHMgKyBcIiBwYXJ0aWFsIGRhdGEgKGFscmVhZHlSZWFkOiBcIiArIG8uYWxyZWFkeVJlYWQgKyBcIiBvZmZzZXQ6IFwiICsgKG8ub2Zmc2V0ICsgby5hbHJlYWR5UmVhZCAtIGUuZmlsZVN0YXJ0KSArIFwiIHJlYWQgc2l6ZTogXCIgKyB1ICsgXCIgZnVsbCBleHRlbnQgc2l6ZTogXCIgKyBvLmxlbmd0aCArIFwiIGZ1bGwgaXRlbSBzaXplOiBcIiArIGkuc2l6ZSArIFwiKVwiKSwgYS5tZW1jcHkoXG4gICAgICAgICAgICAgIGkuZGF0YS5idWZmZXIsXG4gICAgICAgICAgICAgIGkuYWxyZWFkeVJlYWQsXG4gICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgIG8ub2Zmc2V0ICsgby5hbHJlYWR5UmVhZCAtIGUuZmlsZVN0YXJ0LFxuICAgICAgICAgICAgICB1XG4gICAgICAgICAgICApLCBvLmFscmVhZHlSZWFkICs9IHUsIGkuYWxyZWFkeVJlYWQgKz0gdSwgZS51c2VkQnl0ZXMgKz0gdSwgdGhpcy5zdHJlYW0ubG9nQnVmZmVyTGV2ZWwoKSwgbnVsbDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpLmFscmVhZHlSZWFkID09PSBpLnNpemUgPyBpIDogbnVsbDtcbiAgfSwgeS5wcm90b3R5cGUucmVsZWFzZUl0ZW0gPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0aGlzLml0ZW1zW3RdO1xuICAgIGlmIChlLmRhdGEpIHtcbiAgICAgIHRoaXMuaXRlbXNEYXRhU2l6ZSAtPSBlLnNpemUsIGUuZGF0YSA9IG51bGwsIGUuYWxyZWFkeVJlYWQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmV4dGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSBlLmV4dGVudHNbaV07XG4gICAgICAgIHMuYWxyZWFkeVJlYWQgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGUuc2l6ZTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiAwO1xuICB9LCB5LnByb3RvdHlwZS5wcm9jZXNzSXRlbXMgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuaXRlbXNbZV07XG4gICAgICB0aGlzLmdldEl0ZW0oaS5pZCksIHQgJiYgIWkuc2VudCAmJiAodChpKSwgaS5zZW50ID0gITAsIGkuZGF0YSA9IG51bGwpO1xuICAgIH1cbiAgfSwgeS5wcm90b3R5cGUuaGFzSXRlbSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlIGluIHRoaXMuaXRlbXMpIHtcbiAgICAgIHZhciBpID0gdGhpcy5pdGVtc1tlXTtcbiAgICAgIGlmIChpLm5hbWUgPT09IHQpXG4gICAgICAgIHJldHVybiBpLmlkO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0sIHkucHJvdG90eXBlLmdldE1ldGFIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YSA/IHRoaXMubWV0YS5oZGxyLmhhbmRsZXIgOiBudWxsO1xuICB9LCB5LnByb3RvdHlwZS5nZXRQcmltYXJ5SXRlbSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5tZXRhIHx8ICF0aGlzLm1ldGEucGl0bSA/IG51bGwgOiB0aGlzLmdldEl0ZW0odGhpcy5tZXRhLnBpdG0uaXRlbV9pZCk7XG4gIH0sIHkucHJvdG90eXBlLml0ZW1Ub0ZyYWdtZW50ZWRUcmFja0ZpbGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0IHx8IHt9LCBpID0gbnVsbDtcbiAgICBpZiAoZS5pdGVtSWQgPyBpID0gdGhpcy5nZXRJdGVtKGUuaXRlbUlkKSA6IGkgPSB0aGlzLmdldFByaW1hcnlJdGVtKCksIGkgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHMgPSBuZXcgeSgpO1xuICAgIHMuZGlzY2FyZE1kYXREYXRhID0gITE7XG4gICAgdmFyIG8gPSB7IHR5cGU6IGkudHlwZSwgZGVzY3JpcHRpb25fYm94ZXM6IGkucHJvcGVydGllcy5ib3hlcyB9O1xuICAgIGkucHJvcGVydGllcy5pc3BlICYmIChvLndpZHRoID0gaS5wcm9wZXJ0aWVzLmlzcGUuaW1hZ2Vfd2lkdGgsIG8uaGVpZ2h0ID0gaS5wcm9wZXJ0aWVzLmlzcGUuaW1hZ2VfaGVpZ2h0KTtcbiAgICB2YXIgYyA9IHMuYWRkVHJhY2sobyk7XG4gICAgcmV0dXJuIGMgPyAocy5hZGRTYW1wbGUoYywgaS5kYXRhKSwgcykgOiBudWxsO1xuICB9LCB5LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuYm94ZXMubGVuZ3RoOyBlKyspXG4gICAgICB0aGlzLmJveGVzW2VdLndyaXRlKHQpO1xuICB9LCB5LnByb3RvdHlwZS5jcmVhdGVGcmFnbWVudCA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgICB2YXIgcyA9IHRoaXMuZ2V0VHJhY2tCeUlkKHQpLCBvID0gdGhpcy5nZXRTYW1wbGUocywgZSk7XG4gICAgaWYgKG8gPT0gbnVsbClcbiAgICAgIHJldHVybiBvID0gcy5zYW1wbGVzW2VdLCB0aGlzLm5leHRTZWVrUG9zaXRpb24gPyB0aGlzLm5leHRTZWVrUG9zaXRpb24gPSBNYXRoLm1pbihvLm9mZnNldCArIG8uYWxyZWFkeVJlYWQsIHRoaXMubmV4dFNlZWtQb3NpdGlvbikgOiB0aGlzLm5leHRTZWVrUG9zaXRpb24gPSBzLnNhbXBsZXNbZV0ub2Zmc2V0ICsgby5hbHJlYWR5UmVhZCwgbnVsbDtcbiAgICB2YXIgYyA9IGkgfHwgbmV3IGEoKTtcbiAgICBjLmVuZGlhbm5lc3MgPSBhLkJJR19FTkRJQU47XG4gICAgdmFyIHUgPSB0aGlzLmNyZWF0ZVNpbmdsZVNhbXBsZU1vb2Yobyk7XG4gICAgdS53cml0ZShjKSwgdS50cmFmc1swXS50cnVuc1swXS5kYXRhX29mZnNldCA9IHUuc2l6ZSArIDgsIHIuZGVidWcoXCJNUDRCb3hcIiwgXCJBZGp1c3RpbmcgZGF0YV9vZmZzZXQgd2l0aCBuZXcgdmFsdWUgXCIgKyB1LnRyYWZzWzBdLnRydW5zWzBdLmRhdGFfb2Zmc2V0KSwgYy5hZGp1c3RVaW50MzIodS50cmFmc1swXS50cnVuc1swXS5kYXRhX29mZnNldF9wb3NpdGlvbiwgdS50cmFmc1swXS50cnVuc1swXS5kYXRhX29mZnNldCk7XG4gICAgdmFyIF8gPSBuZXcgbi5tZGF0Qm94KCk7XG4gICAgcmV0dXJuIF8uZGF0YSA9IG8uZGF0YSwgXy53cml0ZShjKSwgYztcbiAgfSwgeS53cml0ZUluaXRpYWxpemF0aW9uU2VnbWVudCA9IGZ1bmN0aW9uKHQsIGUsIGksIHMpIHtcbiAgICB2YXIgbztcbiAgICByLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkdlbmVyYXRpbmcgaW5pdGlhbGl6YXRpb24gc2VnbWVudFwiKTtcbiAgICB2YXIgYyA9IG5ldyBhKCk7XG4gICAgYy5lbmRpYW5uZXNzID0gYS5CSUdfRU5ESUFOLCB0LndyaXRlKGMpO1xuICAgIHZhciB1ID0gZS5hZGQoXCJtdmV4XCIpO1xuICAgIGZvciAoaSAmJiB1LmFkZChcIm1laGRcIikuc2V0KFwiZnJhZ21lbnRfZHVyYXRpb25cIiwgaSksIG8gPSAwOyBvIDwgZS50cmFrcy5sZW5ndGg7IG8rKylcbiAgICAgIHUuYWRkKFwidHJleFwiKS5zZXQoXCJ0cmFja19pZFwiLCBlLnRyYWtzW29dLnRraGQudHJhY2tfaWQpLnNldChcImRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XCIsIDEpLnNldChcImRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXCIsIHMpLnNldChcImRlZmF1bHRfc2FtcGxlX3NpemVcIiwgMCkuc2V0KFwiZGVmYXVsdF9zYW1wbGVfZmxhZ3NcIiwgNjU1MzYpO1xuICAgIHJldHVybiBlLndyaXRlKGMpLCBjLmJ1ZmZlcjtcbiAgfSwgeS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IG5ldyBhKCk7XG4gICAgZS5lbmRpYW5uZXNzID0gYS5CSUdfRU5ESUFOLCB0aGlzLndyaXRlKGUpLCBlLnNhdmUodCk7XG4gIH0sIHkucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gbmV3IGEoKTtcbiAgICByZXR1cm4gdC5lbmRpYW5uZXNzID0gYS5CSUdfRU5ESUFOLCB0aGlzLndyaXRlKHQpLCB0LmJ1ZmZlcjtcbiAgfSwgeS5wcm90b3R5cGUuaW5pdGlhbGl6ZVNlZ21lbnRhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0LCBlLCBpLCBzO1xuICAgIGZvciAodGhpcy5vblNlZ21lbnQgPT09IG51bGwgJiYgci53YXJuKFwiTVA0Qm94XCIsIFwiTm8gc2VnbWVudGF0aW9uIGNhbGxiYWNrIHNldCFcIiksIHRoaXMuaXNGcmFnbWVudGF0aW9uSW5pdGlhbGl6ZWQgfHwgKHRoaXMuaXNGcmFnbWVudGF0aW9uSW5pdGlhbGl6ZWQgPSAhMCwgdGhpcy5uZXh0TW9vZk51bWJlciA9IDAsIHRoaXMucmVzZXRUYWJsZXMoKSksIGUgPSBbXSwgdCA9IDA7IHQgPCB0aGlzLmZyYWdtZW50ZWRUcmFja3MubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBvID0gbmV3IG4ubW9vdkJveCgpO1xuICAgICAgby5tdmhkID0gdGhpcy5tb292Lm12aGQsIG8uYm94ZXMucHVzaChvLm12aGQpLCBpID0gdGhpcy5nZXRUcmFja0J5SWQodGhpcy5mcmFnbWVudGVkVHJhY2tzW3RdLmlkKSwgby5ib3hlcy5wdXNoKGkpLCBvLnRyYWtzLnB1c2goaSksIHMgPSB7fSwgcy5pZCA9IGkudGtoZC50cmFja19pZCwgcy51c2VyID0gdGhpcy5mcmFnbWVudGVkVHJhY2tzW3RdLnVzZXIsIHMuYnVmZmVyID0geS53cml0ZUluaXRpYWxpemF0aW9uU2VnbWVudCh0aGlzLmZ0eXAsIG8sIHRoaXMubW9vdi5tdmV4ICYmIHRoaXMubW9vdi5tdmV4Lm1laGQgPyB0aGlzLm1vb3YubXZleC5tZWhkLmZyYWdtZW50X2R1cmF0aW9uIDogdm9pZCAwLCB0aGlzLm1vb3YudHJha3NbdF0uc2FtcGxlcy5sZW5ndGggPiAwID8gdGhpcy5tb292LnRyYWtzW3RdLnNhbXBsZXNbMF0uZHVyYXRpb24gOiAwKSwgZS5wdXNoKHMpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgbi5Cb3gucHJvdG90eXBlLnByaW50SGVhZGVyID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2l6ZSArPSA4LCB0aGlzLnNpemUgPiBmICYmICh0aGlzLnNpemUgKz0gOCksIHRoaXMudHlwZSA9PT0gXCJ1dWlkXCIgJiYgKHRoaXMuc2l6ZSArPSAxNiksIHQubG9nKHQuaW5kZW50ICsgXCJzaXplOlwiICsgdGhpcy5zaXplKSwgdC5sb2codC5pbmRlbnQgKyBcInR5cGU6XCIgKyB0aGlzLnR5cGUpO1xuICB9LCBuLkZ1bGxCb3gucHJvdG90eXBlLnByaW50SGVhZGVyID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2l6ZSArPSA0LCBuLkJveC5wcm90b3R5cGUucHJpbnRIZWFkZXIuY2FsbCh0aGlzLCB0KSwgdC5sb2codC5pbmRlbnQgKyBcInZlcnNpb246XCIgKyB0aGlzLnZlcnNpb24pLCB0LmxvZyh0LmluZGVudCArIFwiZmxhZ3M6XCIgKyB0aGlzLmZsYWdzKTtcbiAgfSwgbi5Cb3gucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMucHJpbnRIZWFkZXIodCk7XG4gIH0sIG4uQ29udGFpbmVyQm94LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnByaW50SGVhZGVyKHQpO1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5ib3hlcy5sZW5ndGg7IGUrKylcbiAgICAgIGlmICh0aGlzLmJveGVzW2VdKSB7XG4gICAgICAgIHZhciBpID0gdC5pbmRlbnQ7XG4gICAgICAgIHQuaW5kZW50ICs9IFwiIFwiLCB0aGlzLmJveGVzW2VdLnByaW50KHQpLCB0LmluZGVudCA9IGk7XG4gICAgICB9XG4gIH0sIHkucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24odCkge1xuICAgIHQuaW5kZW50ID0gXCJcIjtcbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuYm94ZXMubGVuZ3RoOyBlKyspXG4gICAgICB0aGlzLmJveGVzW2VdICYmIHRoaXMuYm94ZXNbZV0ucHJpbnQodCk7XG4gIH0sIG4ubXZoZEJveC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbih0KSB7XG4gICAgbi5GdWxsQm94LnByb3RvdHlwZS5wcmludEhlYWRlci5jYWxsKHRoaXMsIHQpLCB0LmxvZyh0LmluZGVudCArIFwiY3JlYXRpb25fdGltZTogXCIgKyB0aGlzLmNyZWF0aW9uX3RpbWUpLCB0LmxvZyh0LmluZGVudCArIFwibW9kaWZpY2F0aW9uX3RpbWU6IFwiICsgdGhpcy5tb2RpZmljYXRpb25fdGltZSksIHQubG9nKHQuaW5kZW50ICsgXCJ0aW1lc2NhbGU6IFwiICsgdGhpcy50aW1lc2NhbGUpLCB0LmxvZyh0LmluZGVudCArIFwiZHVyYXRpb246IFwiICsgdGhpcy5kdXJhdGlvbiksIHQubG9nKHQuaW5kZW50ICsgXCJyYXRlOiBcIiArIHRoaXMucmF0ZSksIHQubG9nKHQuaW5kZW50ICsgXCJ2b2x1bWU6IFwiICsgKHRoaXMudm9sdW1lID4+IDgpKSwgdC5sb2codC5pbmRlbnQgKyBcIm1hdHJpeDogXCIgKyB0aGlzLm1hdHJpeC5qb2luKFwiLCBcIikpLCB0LmxvZyh0LmluZGVudCArIFwibmV4dF90cmFja19pZDogXCIgKyB0aGlzLm5leHRfdHJhY2tfaWQpO1xuICB9LCBuLnRraGRCb3gucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24odCkge1xuICAgIG4uRnVsbEJveC5wcm90b3R5cGUucHJpbnRIZWFkZXIuY2FsbCh0aGlzLCB0KSwgdC5sb2codC5pbmRlbnQgKyBcImNyZWF0aW9uX3RpbWU6IFwiICsgdGhpcy5jcmVhdGlvbl90aW1lKSwgdC5sb2codC5pbmRlbnQgKyBcIm1vZGlmaWNhdGlvbl90aW1lOiBcIiArIHRoaXMubW9kaWZpY2F0aW9uX3RpbWUpLCB0LmxvZyh0LmluZGVudCArIFwidHJhY2tfaWQ6IFwiICsgdGhpcy50cmFja19pZCksIHQubG9nKHQuaW5kZW50ICsgXCJkdXJhdGlvbjogXCIgKyB0aGlzLmR1cmF0aW9uKSwgdC5sb2codC5pbmRlbnQgKyBcInZvbHVtZTogXCIgKyAodGhpcy52b2x1bWUgPj4gOCkpLCB0LmxvZyh0LmluZGVudCArIFwibWF0cml4OiBcIiArIHRoaXMubWF0cml4LmpvaW4oXCIsIFwiKSksIHQubG9nKHQuaW5kZW50ICsgXCJsYXllcjogXCIgKyB0aGlzLmxheWVyKSwgdC5sb2codC5pbmRlbnQgKyBcImFsdGVybmF0ZV9ncm91cDogXCIgKyB0aGlzLmFsdGVybmF0ZV9ncm91cCksIHQubG9nKHQuaW5kZW50ICsgXCJ3aWR0aDogXCIgKyB0aGlzLndpZHRoKSwgdC5sb2codC5pbmRlbnQgKyBcImhlaWdodDogXCIgKyB0aGlzLmhlaWdodCk7XG4gIH07XG4gIHZhciBCID0ge307XG4gIEIuY3JlYXRlRmlsZSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB2YXIgaSA9IHQgIT09IHZvaWQgMCA/IHQgOiAhMCwgcyA9IG5ldyB5KGUpO1xuICAgIHJldHVybiBzLmRpc2NhcmRNZGF0RGF0YSA9ICFpLCBzO1xuICB9LCBsLmNyZWF0ZUZpbGUgPSBCLmNyZWF0ZUZpbGU7XG59KShHZSk7XG5jb25zdCBEID0gLyogQF9fUFVSRV9fICovIHhpKEdlKSwgcSA9IHtcbiAgc2FtcGxlUmF0ZTogNDhlMyxcbiAgY2hhbm5lbENvdW50OiAyLFxuICBjb2RlYzogXCJtcDRhLjQwLjJcIlxufTtcbmZ1bmN0aW9uIGRlKGwsIHIpIHtcbiAgY29uc3QgaCA9IHIudmlkZW9UcmFja3NbMF0sIGEgPSB7fTtcbiAgaWYgKGggIT0gbnVsbCkge1xuICAgIGNvbnN0IGQgPSBVaShsLmdldFRyYWNrQnlJZChoLmlkKSkuYnVmZmVyLCB7IGRlc2NLZXk6IHAsIHR5cGU6IG4gfSA9IGguY29kZWMuc3RhcnRzV2l0aChcImF2YzFcIikgPyB7IGRlc2NLZXk6IFwiYXZjRGVjb2RlckNvbmZpZ1JlY29yZFwiLCB0eXBlOiBcImF2YzFcIiB9IDogaC5jb2RlYy5zdGFydHNXaXRoKFwiaHZjMVwiKSA/IHsgZGVzY0tleTogXCJoZXZjRGVjb2RlckNvbmZpZ1JlY29yZFwiLCB0eXBlOiBcImh2YzFcIiB9IDogeyBkZXNjS2V5OiBcIlwiLCB0eXBlOiBcIlwiIH07XG4gICAgcCAhPT0gXCJcIiAmJiAoYS52aWRlb1RyYWNrQ29uZiA9IHtcbiAgICAgIHRpbWVzY2FsZTogaC50aW1lc2NhbGUsXG4gICAgICBkdXJhdGlvbjogaC5kdXJhdGlvbixcbiAgICAgIHdpZHRoOiBoLnZpZGVvLndpZHRoLFxuICAgICAgaGVpZ2h0OiBoLnZpZGVvLmhlaWdodCxcbiAgICAgIGJyYW5kczogci5icmFuZHMsXG4gICAgICB0eXBlOiBuLFxuICAgICAgW3BdOiBkXG4gICAgfSksIGEudmlkZW9EZWNvZGVyQ29uZiA9IHtcbiAgICAgIGNvZGVjOiBoLmNvZGVjLFxuICAgICAgY29kZWRIZWlnaHQ6IGgudmlkZW8uaGVpZ2h0LFxuICAgICAgY29kZWRXaWR0aDogaC52aWRlby53aWR0aCxcbiAgICAgIGRlc2NyaXB0aW9uOiBkXG4gICAgfTtcbiAgfVxuICBjb25zdCBmID0gci5hdWRpb1RyYWNrc1swXTtcbiAgaWYgKGYgIT0gbnVsbCkge1xuICAgIGNvbnN0IGQgPSBTZShsKTtcbiAgICBhLmF1ZGlvVHJhY2tDb25mID0ge1xuICAgICAgdGltZXNjYWxlOiBmLnRpbWVzY2FsZSxcbiAgICAgIHNhbXBsZXJhdGU6IGYuYXVkaW8uc2FtcGxlX3JhdGUsXG4gICAgICBjaGFubmVsX2NvdW50OiBmLmF1ZGlvLmNoYW5uZWxfY291bnQsXG4gICAgICBoZGxyOiBcInNvdW5cIixcbiAgICAgIHR5cGU6IGYuY29kZWMuc3RhcnRzV2l0aChcIm1wNGFcIikgPyBcIm1wNGFcIiA6IGYuY29kZWMsXG4gICAgICBkZXNjcmlwdGlvbjogU2UobClcbiAgICB9LCBhLmF1ZGlvRGVjb2RlckNvbmYgPSB7XG4gICAgICBjb2RlYzogZi5jb2RlYy5zdGFydHNXaXRoKFwibXA0YVwiKSA/IHEuY29kZWMgOiBmLmNvZGVjLFxuICAgICAgbnVtYmVyT2ZDaGFubmVsczogZi5hdWRpby5jaGFubmVsX2NvdW50LFxuICAgICAgc2FtcGxlUmF0ZTogZi5hdWRpby5zYW1wbGVfcmF0ZSxcbiAgICAgIC4uLmQgPT0gbnVsbCA/IHt9IDogRWkoZClcbiAgICB9O1xuICB9XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gVWkobCkge1xuICBmb3IgKGNvbnN0IHIgb2YgbC5tZGlhLm1pbmYuc3RibC5zdHNkLmVudHJpZXMpIHtcbiAgICBjb25zdCBoID0gci5hdmNDID8/IHIuaHZjQyA/PyByLnZwY0M7XG4gICAgaWYgKGggIT0gbnVsbCkge1xuICAgICAgY29uc3QgYSA9IG5ldyBELkRhdGFTdHJlYW0oXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgMCxcbiAgICAgICAgRC5EYXRhU3RyZWFtLkJJR19FTkRJQU5cbiAgICAgICk7XG4gICAgICByZXR1cm4gaC53cml0ZShhKSwgbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIuc2xpY2UoOCkpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBFcnJvcihcImF2Y0MsIGh2Y0Mgb3IgVlBYIG5vdCBmb3VuZFwiKTtcbn1cbmZ1bmN0aW9uIFNlKGwsIHIgPSBcIm1wNGFcIikge1xuICB2YXIgYTtcbiAgY29uc3QgaCA9IChhID0gbC5tb292KSA9PSBudWxsID8gdm9pZCAwIDogYS50cmFrcy5tYXAoKGYpID0+IGYubWRpYS5taW5mLnN0Ymwuc3RzZC5lbnRyaWVzKS5mbGF0KCkuZmluZCgoeyB0eXBlOiBmIH0pID0+IGYgPT09IHIpO1xuICByZXR1cm4gaCA9PSBudWxsID8gdm9pZCAwIDogaC5lc2RzO1xufVxuZnVuY3Rpb24gRWkobCkge1xuICB2YXIgbjtcbiAgY29uc3QgciA9IChuID0gbC5lc2QuZGVzY3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBuLmRlc2NzWzBdO1xuICBpZiAociA9PSBudWxsKSByZXR1cm4ge307XG4gIGNvbnN0IFtoLCBhXSA9IHIuZGF0YSwgZiA9ICgoaCAmIDcpIDw8IDEpICsgKGEgPj4gNyksIGQgPSAoYSAmIDEyNykgPj4gMztcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGVSYXRlOiBbXG4gICAgICA5NmUzLFxuICAgICAgODgyMDAsXG4gICAgICA2NGUzLFxuICAgICAgNDhlMyxcbiAgICAgIDQ0MTAwLFxuICAgICAgMzJlMyxcbiAgICAgIDI0ZTMsXG4gICAgICAyMjA1MCxcbiAgICAgIDE2ZTMsXG4gICAgICAxMmUzLFxuICAgICAgMTEwMjUsXG4gICAgICA4ZTMsXG4gICAgICA3MzUwXG4gICAgXVtmXSxcbiAgICBudW1iZXJPZkNoYW5uZWxzOiBkXG4gIH07XG59XG5mdW5jdGlvbiBBaShsKSB7XG4gIGlmIChsLm1vb3YgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIHIgPSAwOyByIDwgbC5tb292LnRyYWtzLmxlbmd0aDsgcisrKVxuICAgICAgbC5tb292LnRyYWtzW3JdLnNhbXBsZXMgPSBbXTtcbiAgICBsLm1kYXRzID0gW10sIGwubW9vZnMgPSBbXTtcbiAgfVxufVxudmFyIHp0O1xuY2xhc3MgY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBSKHRoaXMsIFwicmVhZGFibGVcIik7XG4gICAgUih0aGlzLCBcIndyaXRhYmxlXCIpO1xuICAgIEEodGhpcywgenQsIDApO1xuICAgIGNvbnN0IHIgPSBELmNyZWF0ZUZpbGUoKTtcbiAgICBsZXQgaCA9ICExO1xuICAgIHRoaXMucmVhZGFibGUgPSBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAgICB7XG4gICAgICAgIHN0YXJ0OiAoYSkgPT4ge1xuICAgICAgICAgIHIub25SZWFkeSA9IChkKSA9PiB7XG4gICAgICAgICAgICB2YXIgdiwgYjtcbiAgICAgICAgICAgIGNvbnN0IHAgPSAodiA9IGQudmlkZW9UcmFja3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiB2LmlkO1xuICAgICAgICAgICAgcCAhPSBudWxsICYmIHIuc2V0RXh0cmFjdGlvbk9wdGlvbnMocCwgXCJ2aWRlb1wiLCB7IG5iU2FtcGxlczogMTAwIH0pO1xuICAgICAgICAgICAgY29uc3QgbiA9IChiID0gZC5hdWRpb1RyYWNrc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGIuaWQ7XG4gICAgICAgICAgICBuICE9IG51bGwgJiYgci5zZXRFeHRyYWN0aW9uT3B0aW9ucyhuLCBcImF1ZGlvXCIsIHsgbmJTYW1wbGVzOiAxMDAgfSksIGEuZW5xdWV1ZSh7IGNodW5rVHlwZTogXCJyZWFkeVwiLCBkYXRhOiB7IGluZm86IGQsIGZpbGU6IHIgfSB9KSwgci5zdGFydCgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZiA9IHt9O1xuICAgICAgICAgIHIub25TYW1wbGVzID0gKGQsIHAsIG4pID0+IHtcbiAgICAgICAgICAgIGEuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNodW5rVHlwZTogXCJzYW1wbGVzXCIsXG4gICAgICAgICAgICAgIGRhdGE6IHsgaWQ6IGQsIHR5cGU6IHAsIHNhbXBsZXM6IG4ubWFwKCh2KSA9PiAoeyAuLi52IH0pKSB9XG4gICAgICAgICAgICB9KSwgZltkXSA9IChmW2RdID8/IDApICsgbi5sZW5ndGgsIHIucmVsZWFzZVVzZWRTYW1wbGVzKGQsIGZbZF0pO1xuICAgICAgICAgIH0sIHIub25GbHVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgIGEuY2xvc2UoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICByLnN0b3AoKSwgaCA9ICEwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiA1MFxuICAgICAgfVxuICAgICksIHRoaXMud3JpdGFibGUgPSBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgd3JpdGU6IGFzeW5jIChhKSA9PiB7XG4gICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgdGhpcy53cml0YWJsZS5hYm9ydCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmID0gYS5idWZmZXI7XG4gICAgICAgIGYuZmlsZVN0YXJ0ID0gbSh0aGlzLCB6dCksIEUodGhpcywgenQsIG0odGhpcywgenQpICsgZi5ieXRlTGVuZ3RoKSwgci5hcHBlbmRCdWZmZXIoZik7XG4gICAgICB9LFxuICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIHIuZmx1c2goKSwgci5zdG9wKCksIChhID0gci5vbkZsdXNoKSA9PSBudWxsIHx8IGEuY2FsbChyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuenQgPSBuZXcgV2Vha01hcCgpO1xubGV0IEJpID0gMDtcbmZ1bmN0aW9uIG5lKGwpIHtcbiAgcmV0dXJuIGwua2luZCA9PT0gXCJmaWxlXCIgJiYgbC5jcmVhdGVSZWFkZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn1cbnZhciBUdCwgUHQsIEcsIEssIEx0LCBzdCwgd3QsIGJ0LCBTdCwgViwgUTtcbmNsYXNzIHNuIHtcbiAgY29uc3RydWN0b3IociwgaCA9IHt9KSB7XG4gICAgQSh0aGlzLCBUdCwgei5jcmVhdGUoYE1QNENsaXAgaWQ6JHtCaSsrfSxgKSk7XG4gICAgUih0aGlzLCBcInJlYWR5XCIpO1xuICAgIEEodGhpcywgUHQsICExKTtcbiAgICBBKHRoaXMsIEcsIHtcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBhdWRpb1NhbXBsZVJhdGU6IDAsXG4gICAgICBhdWRpb0NoYW5Db3VudDogMFxuICAgIH0pO1xuICAgIEEodGhpcywgSyk7XG4gICAgQSh0aGlzLCBMdCwgMSk7XG4gICAgQSh0aGlzLCBzdCwgW10pO1xuICAgIEEodGhpcywgd3QsIG51bGwpO1xuICAgIEEodGhpcywgYnQsIG51bGwpO1xuICAgIEEodGhpcywgU3QsIHtcbiAgICAgIHZpZGVvOiBudWxsLFxuICAgICAgYXVkaW86IG51bGxcbiAgICB9KTtcbiAgICBBKHRoaXMsIFYsIHsgYXVkaW86ICEwIH0pO1xuICAgIFIodGhpcywgXCJ0aWNrSW50ZXJjZXB0b3JcIiwgYXN5bmMgKHIsIGgpID0+IGgpO1xuICAgIEEodGhpcywgUSwgbmV3IEFib3J0Q29udHJvbGxlcigpKTtcbiAgICBpZiAoIShyIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pICYmICFuZShyKSAmJiAhQXJyYXkuaXNBcnJheShyLnZpZGVvU2FtcGxlcykpXG4gICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgYXJndW1lbnRcIik7XG4gICAgRSh0aGlzLCBWLCB7IGF1ZGlvOiAhMCwgLi4uaCB9KSwgRSh0aGlzLCBMdCwgdHlwZW9mIGguYXVkaW8gPT0gXCJvYmplY3RcIiAmJiBcInZvbHVtZVwiIGluIGguYXVkaW8gPyBoLmF1ZGlvLnZvbHVtZSA6IDEpO1xuICAgIGNvbnN0IGEgPSBhc3luYyAoZikgPT4gKGF3YWl0IEN0KG0odGhpcywgSyksIGYpLCBhd2FpdCBtKHRoaXMsIEspLnN0cmVhbSgpKTtcbiAgICBFKHRoaXMsIEssIG5lKHIpID8gciA6IFwibG9jYWxGaWxlXCIgaW4gciA/IHIubG9jYWxGaWxlIDogS3QoKSksIHRoaXMucmVhZHkgPSAociBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtID8gYShyKS50aGVuKChmKSA9PiB4ZShmLCBtKHRoaXMsIFYpKSkgOiBuZShyKSA/IHIuc3RyZWFtKCkudGhlbigoZikgPT4geGUoZiwgbSh0aGlzLCBWKSkpIDogUHJvbWlzZS5yZXNvbHZlKHIpKS50aGVuKGFzeW5jICh7IHZpZGVvU2FtcGxlczogZiwgYXVkaW9TYW1wbGVzOiBkLCBkZWNvZGVyQ29uZjogcCB9KSA9PiB7XG4gICAgICBFKHRoaXMsIHN0LCBmKSwgRSh0aGlzLCBTdCwgcCk7XG4gICAgICBjb25zdCB7IHZpZGVvRnJhbWVGaW5kZXI6IG4sIGF1ZGlvRnJhbWVGaW5kZXI6IHYgfSA9IElpKFxuICAgICAgICB7XG4gICAgICAgICAgdmlkZW86IHAudmlkZW8gPT0gbnVsbCA/IG51bGwgOiB7XG4gICAgICAgICAgICAuLi5wLnZpZGVvLFxuICAgICAgICAgICAgaGFyZHdhcmVBY2NlbGVyYXRpb246IG0odGhpcywgVikuX191bnNhZmVfaGFyZHdhcmVBY2NlbGVyYXRpb25fX1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXVkaW86IHAuYXVkaW9cbiAgICAgICAgfSxcbiAgICAgICAgYXdhaXQgbSh0aGlzLCBLKS5jcmVhdGVSZWFkZXIoKSxcbiAgICAgICAgZixcbiAgICAgICAgZCxcbiAgICAgICAgbSh0aGlzLCBWKS5hdWRpbyAhPT0gITEgPyBtKHRoaXMsIEx0KSA6IDBcbiAgICAgICk7XG4gICAgICByZXR1cm4gRSh0aGlzLCB3dCwgbiksIEUodGhpcywgYnQsIHYpLCBFKHRoaXMsIEcsIEZpKHAsIGYsIGQpKSwgbSh0aGlzLCBUdCkuaW5mbyhcIk1QNENsaXAgbWV0YTpcIiwgbSh0aGlzLCBHKSksIHsgLi4ubSh0aGlzLCBHKSB9O1xuICAgIH0pO1xuICB9XG4gIGdldCBtZXRhKCkge1xuICAgIHJldHVybiB7IC4uLm0odGhpcywgRykgfTtcbiAgfVxuICBhc3luYyB0aWNrKHIpIHtcbiAgICB2YXIgZiwgZDtcbiAgICBpZiAociA+PSBtKHRoaXMsIEcpLmR1cmF0aW9uKVxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudGlja0ludGVyY2VwdG9yKHIsIHtcbiAgICAgICAgYXVkaW86IFtdLFxuICAgICAgICBzdGF0ZTogXCJkb25lXCJcbiAgICAgIH0pO1xuICAgIGNvbnN0IFtoLCBhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICgoZiA9IG0odGhpcywgYnQpKSA9PSBudWxsID8gdm9pZCAwIDogZi5maW5kKHIpKSA/PyBbXSxcbiAgICAgIChkID0gbSh0aGlzLCB3dCkpID09IG51bGwgPyB2b2lkIDAgOiBkLmZpbmQocilcbiAgICBdKTtcbiAgICByZXR1cm4gYSA9PSBudWxsID8gYXdhaXQgdGhpcy50aWNrSW50ZXJjZXB0b3Iociwge1xuICAgICAgYXVkaW86IGgsXG4gICAgICBzdGF0ZTogXCJzdWNjZXNzXCJcbiAgICB9KSA6IGF3YWl0IHRoaXMudGlja0ludGVyY2VwdG9yKHIsIHtcbiAgICAgIHZpZGVvOiBhLFxuICAgICAgYXVkaW86IGgsXG4gICAgICBzdGF0ZTogXCJzdWNjZXNzXCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyB0aHVtYm5haWxzKHIgPSAxMDAsIGgpIHtcbiAgICBtKHRoaXMsIFEpLmFib3J0KCksIEUodGhpcywgUSwgbmV3IEFib3J0Q29udHJvbGxlcigpKTtcbiAgICBjb25zdCBhID0gbSh0aGlzLCBRKS5zaWduYWw7XG4gICAgYXdhaXQgdGhpcy5yZWFkeTtcbiAgICBjb25zdCBmID0gXCJnZW5lcmF0ZSB0aHVtYm5haWxzIGFib3J0ZWRcIjtcbiAgICBpZiAoYS5hYm9ydGVkKSB0aHJvdyBFcnJvcihmKTtcbiAgICBjb25zdCB7IHdpZHRoOiBkLCBoZWlnaHQ6IHAgfSA9IG0odGhpcywgRyksIG4gPSBVZShcbiAgICAgIHIsXG4gICAgICBNYXRoLnJvdW5kKHAgKiAociAvIGQpKSxcbiAgICAgIHsgcXVhbGl0eTogMC4xLCB0eXBlOiBcImltYWdlL3BuZ1wiIH1cbiAgICApO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShcbiAgICAgIGFzeW5jICh2LCBiKSA9PiB7XG4gICAgICAgIGxldCB5ID0gW107XG4gICAgICAgIGNvbnN0IEIgPSBtKHRoaXMsIFN0KS52aWRlbztcbiAgICAgICAgaWYgKEIgPT0gbnVsbCB8fCBtKHRoaXMsIHN0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICBiKEVycm9yKGYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHQoKSB7XG4gICAgICAgICAgYS5hYm9ydGVkIHx8IHYoXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgeS5tYXAoYXN5bmMgKF8pID0+ICh7XG4gICAgICAgICAgICAgICAgdHM6IF8udHMsXG4gICAgICAgICAgICAgICAgaW1nOiBhd2FpdCBfLmltZ1xuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGUoXykge1xuICAgICAgICAgIHkucHVzaCh7XG4gICAgICAgICAgICB0czogXy50aW1lc3RhbXAsXG4gICAgICAgICAgICBpbWc6IG4oXylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXJ0OiBpID0gMCwgZW5kOiBzID0gbSh0aGlzLCBHKS5kdXJhdGlvbiwgc3RlcDogbyA9IDFlNiB9ID0gaCA/PyB7fTtcbiAgICAgICAgbGV0IGMgPSBpO1xuICAgICAgICBjb25zdCB1ID0gbmV3IG9lKFxuICAgICAgICAgIGF3YWl0IG0odGhpcywgSykuY3JlYXRlUmVhZGVyKCksXG4gICAgICAgICAgbSh0aGlzLCBzdCksXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uQixcbiAgICAgICAgICAgIGhhcmR3YXJlQWNjZWxlcmF0aW9uOiBtKHRoaXMsIFYpLl9fdW5zYWZlX2hhcmR3YXJlQWNjZWxlcmF0aW9uX19cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGZvciAoOyBjIDw9IHMgJiYgIWEuYWJvcnRlZDsgKSB7XG4gICAgICAgICAgY29uc3QgXyA9IGF3YWl0IHUuZmluZChjKTtcbiAgICAgICAgICBfICYmIGUoXyksIGMgKz0gbztcbiAgICAgICAgfVxuICAgICAgICB1LmRlc3Ryb3koKSwgdCgpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgdGh1bWJuYWlsc0xpc3QociA9IDEwMCwgaCkge1xuICAgIHZhciB2O1xuICAgIGlmICgoKHYgPSBoID09IG51bGwgPyB2b2lkIDAgOiBoLnRpbWVzdGFtcHMpID09IG51bGwgPyB2b2lkIDAgOiB2Lmxlbmd0aCkgPT09IDApIHJldHVybiBbXTtcbiAgICBtKHRoaXMsIFEpLmFib3J0KCksIEUodGhpcywgUSwgbmV3IEFib3J0Q29udHJvbGxlcigpKTtcbiAgICBjb25zdCBhID0gbSh0aGlzLCBRKS5zaWduYWw7XG4gICAgYXdhaXQgdGhpcy5yZWFkeTtcbiAgICBjb25zdCBmID0gXCJnZW5lcmF0ZSB0aHVtYm5haWxzIGFib3J0ZWRcIjtcbiAgICBpZiAoYS5hYm9ydGVkKSB0aHJvdyBFcnJvcihmKTtcbiAgICBjb25zdCB7IHdpZHRoOiBkLCBoZWlnaHQ6IHAgfSA9IG0odGhpcywgRyksIG4gPSBVZShcbiAgICAgIHIsXG4gICAgICBNYXRoLnJvdW5kKHAgKiAociAvIGQpKSxcbiAgICAgIHsgcXVhbGl0eTogMC4xLCB0eXBlOiBcImltYWdlL3BuZ1wiIH1cbiAgICApO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShcbiAgICAgIGFzeW5jIChiLCB5KSA9PiB7XG4gICAgICAgIGxldCBCID0gW107XG4gICAgICAgIGNvbnN0IHQgPSBtKHRoaXMsIFN0KS52aWRlbztcbiAgICAgICAgaWYgKHQgPT0gbnVsbCB8fCBtKHRoaXMsIHN0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICB5KEVycm9yKGYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgYS5hYm9ydGVkIHx8IGIoXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgQi5tYXAoYXN5bmMgKGMpID0+ICh7XG4gICAgICAgICAgICAgICAgdHM6IGMudHMsXG4gICAgICAgICAgICAgICAgaW1nOiBhd2FpdCBjLmltZ1xuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGkoYykge1xuICAgICAgICAgIEIucHVzaCh7XG4gICAgICAgICAgICB0czogYy50aW1lc3RhbXAsXG4gICAgICAgICAgICBpbWc6IG4oYylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzID0gKGggPT0gbnVsbCA/IHZvaWQgMCA6IGgudGltZXN0YW1wcykgPz8gW107XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbyA9IG5ldyBvZShcbiAgICAgICAgICBhd2FpdCBtKHRoaXMsIEspLmNyZWF0ZVJlYWRlcigpLFxuICAgICAgICAgIG0odGhpcywgc3QpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLnQsXG4gICAgICAgICAgICBoYXJkd2FyZUFjY2VsZXJhdGlvbjogbSh0aGlzLCBWKS5fX3Vuc2FmZV9oYXJkd2FyZUFjY2VsZXJhdGlvbl9fXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygcykge1xuICAgICAgICAgIGlmIChhLmFib3J0ZWQpIGJyZWFrO1xuICAgICAgICAgIGNvbnN0IHUgPSBhd2FpdCBvLmZpbmQoYyk7XG4gICAgICAgICAgdSAmJiBpKHUpO1xuICAgICAgICB9XG4gICAgICAgIG8uZGVzdHJveSgpLCBlKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHZhciByLCBoO1xuICAgIG0odGhpcywgUHQpIHx8IChtKHRoaXMsIFR0KS5pbmZvKFwiTVA0Q2xpcCBkZXN0cm95XCIpLCBFKHRoaXMsIFB0LCAhMCksIChyID0gbSh0aGlzLCB3dCkpID09IG51bGwgfHwgci5kZXN0cm95KCksIChoID0gbSh0aGlzLCBidCkpID09IG51bGwgfHwgaC5kZXN0cm95KCkpO1xuICB9XG59XG5UdCA9IG5ldyBXZWFrTWFwKCksIFB0ID0gbmV3IFdlYWtNYXAoKSwgRyA9IG5ldyBXZWFrTWFwKCksIEsgPSBuZXcgV2Vha01hcCgpLCBMdCA9IG5ldyBXZWFrTWFwKCksIHN0ID0gbmV3IFdlYWtNYXAoKSwgd3QgPSBuZXcgV2Vha01hcCgpLCBidCA9IG5ldyBXZWFrTWFwKCksIFN0ID0gbmV3IFdlYWtNYXAoKSwgViA9IG5ldyBXZWFrTWFwKCksIFEgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gRmkobCwgciwgaCkge1xuICBjb25zdCBhID0ge1xuICAgIGR1cmF0aW9uOiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBhdWRpb1NhbXBsZVJhdGU6IDAsXG4gICAgYXVkaW9DaGFuQ291bnQ6IDBcbiAgfTtcbiAgbC52aWRlbyAhPSBudWxsICYmIHIubGVuZ3RoID4gMCAmJiAoYS53aWR0aCA9IGwudmlkZW8uY29kZWRXaWR0aCA/PyAwLCBhLmhlaWdodCA9IGwudmlkZW8uY29kZWRIZWlnaHQgPz8gMCksIGwuYXVkaW8gIT0gbnVsbCAmJiBoLmxlbmd0aCA+IDAgJiYgKGEuYXVkaW9TYW1wbGVSYXRlID0gcS5zYW1wbGVSYXRlLCBhLmF1ZGlvQ2hhbkNvdW50ID0gcS5jaGFubmVsQ291bnQpO1xuICBsZXQgZiA9IDAsIGQgPSAwO1xuICBpZiAoci5sZW5ndGggPiAwKVxuICAgIGZvciAobGV0IHAgPSByLmxlbmd0aCAtIDE7IHAgPj0gMDsgcC0tKSB7XG4gICAgICBjb25zdCBuID0gcltwXTtcbiAgICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICAgIGYgPSBuLmN0cyArIG4uZHVyYXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgaWYgKGgubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHAgPSBoLmF0KC0xKTtcbiAgICBkID0gcC5jdHMgKyBwLmR1cmF0aW9uO1xuICB9XG4gIHJldHVybiBhLmR1cmF0aW9uID0gTWF0aC5tYXgoZiwgZCksIGE7XG59XG5mdW5jdGlvbiBJaShsLCByLCBoLCBhLCBmKSB7XG4gIHJldHVybiB7XG4gICAgYXVkaW9GcmFtZUZpbmRlcjogZiA9PT0gMCB8fCBsLmF1ZGlvID09IG51bGwgfHwgYS5sZW5ndGggPT09IDAgPyBudWxsIDogbmV3IENpKFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsLmF1ZGlvLFxuICAgICAge1xuICAgICAgICB2b2x1bWU6IGYsXG4gICAgICAgIHRhcmdldFNhbXBsZVJhdGU6IHEuc2FtcGxlUmF0ZVxuICAgICAgfVxuICAgICksXG4gICAgdmlkZW9GcmFtZUZpbmRlcjogbC52aWRlbyA9PSBudWxsIHx8IGgubGVuZ3RoID09PSAwID8gbnVsbCA6IG5ldyBvZShcbiAgICAgIHIsXG4gICAgICBoLFxuICAgICAgbC52aWRlb1xuICAgIClcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHhlKGwsIHIgPSB7fSkge1xuICBsZXQgaDtcbiAgY29uc3QgYSA9IHsgdmlkZW86IG51bGwsIGF1ZGlvOiBudWxsIH07XG4gIGxldCBmID0gW10sIGQgPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChuLCB2KSA9PiB7XG4gICAgbGV0IGIgPSAtMSwgeSA9IC0xO1xuICAgIGNvbnN0IEIgPSBmZShsLnBpcGVUaHJvdWdoKG5ldyBjZSgpKSwge1xuICAgICAgb25DaHVuazogYXN5bmMgKHsgY2h1bmtUeXBlOiB0LCBkYXRhOiBlIH0pID0+IHtcbiAgICAgICAgaWYgKHQgPT09IFwicmVhZHlcIikge1xuICAgICAgICAgIGggPSBlLmluZm87XG4gICAgICAgICAgbGV0IHsgdmlkZW9EZWNvZGVyQ29uZjogaSwgYXVkaW9EZWNvZGVyQ29uZjogcyB9ID0gZGUoZS5maWxlLCBlLmluZm8pO1xuICAgICAgICAgIGEudmlkZW8gPSBpID8/IG51bGwsIGEuYXVkaW8gPSBzID8/IG51bGwsIGkgPT0gbnVsbCAmJiBzID09IG51bGwgJiYgKEIoKSwgdihcbiAgICAgICAgICAgIEVycm9yKFwiTVA0Q2xpcCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHZpZGVvIG9yIGF1ZGlvIHRyYWNrXCIpXG4gICAgICAgICAgKSksIHouaW5mbyhcbiAgICAgICAgICAgIFwibXA0Qm94RmlsZSBtb292IHJlYWR5XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmUuaW5mbyxcbiAgICAgICAgICAgICAgdHJhY2tzOiBudWxsLFxuICAgICAgICAgICAgICB2aWRlb1RyYWNrczogbnVsbCxcbiAgICAgICAgICAgICAgYXVkaW9UcmFja3M6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ID09PSBcInNhbXBsZXNcIikge1xuICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwidmlkZW9cIikge1xuICAgICAgICAgICAgYiA9PT0gLTEgJiYgKGIgPSBlLnNhbXBsZXNbMF0uZHRzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBlLnNhbXBsZXMpXG4gICAgICAgICAgICAgIGYucHVzaChwKGksIGIsIFwidmlkZW9cIikpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09PSBcImF1ZGlvXCIgJiYgci5hdWRpbykge1xuICAgICAgICAgICAgeSA9PT0gLTEgJiYgKHkgPSBlLnNhbXBsZXNbMF0uZHRzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBlLnNhbXBsZXMpXG4gICAgICAgICAgICAgIGQucHVzaChwKGksIHksIFwiYXVkaW9cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uRG9uZTogKCkgPT4ge1xuICAgICAgICBjb25zdCB0ID0gZi5hdCgtMSkgPz8gZC5hdCgtMSk7XG4gICAgICAgIGlmIChoID09IG51bGwpIHtcbiAgICAgICAgICB2KEVycm9yKFwiTVA0Q2xpcCBzdHJlYW0gaXMgZG9uZSwgYnV0IG5vdCBlbWl0IHJlYWR5XCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgdihFcnJvcihcIk1QNENsaXAgc3RyZWFtIG5vdCBjb250YWluIGFueSBzYW1wbGVcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlID0gZlswXTtcbiAgICAgICAgZSAhPSBudWxsICYmIGUuY3RzIDwgMmU1ICYmIChlLmR1cmF0aW9uICs9IGUuY3RzLCBlLmN0cyA9IDApLCB6LmluZm8oXCJtcDQgc3RyZWFtIHBhcnNlZFwiKSwgbih7XG4gICAgICAgICAgdmlkZW9TYW1wbGVzOiBmLFxuICAgICAgICAgIGF1ZGlvU2FtcGxlczogZCxcbiAgICAgICAgICBkZWNvZGVyQ29uZjogYVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHAobiwgdiA9IDAsIGIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ubixcbiAgICAgIGlzX2lkcjogYiA9PT0gXCJ2aWRlb1wiICYmIG4uaXNfc3luYyAmJiBEaShuLmRhdGEsIG4uZGVzY3JpcHRpb24udHlwZSksXG4gICAgICBjdHM6IChuLmN0cyAtIHYpIC8gbi50aW1lc2NhbGUgKiAxZTYsXG4gICAgICBkdHM6IChuLmR0cyAtIHYpIC8gbi50aW1lc2NhbGUgKiAxZTYsXG4gICAgICBkdXJhdGlvbjogbi5kdXJhdGlvbiAvIG4udGltZXNjYWxlICogMWU2LFxuICAgICAgdGltZXNjYWxlOiAxZTYsXG4gICAgICBkYXRhOiBiID09PSBcInZpZGVvXCIgPyBudWxsIDogbi5kYXRhXG4gICAgfTtcbiAgfVxufVxudmFyIEwsIGx0LCBmdCwga3QsIGR0LCBXLCBrLCBydCwgY3QsIHh0LCBhdCwgRHQsIHV0LCBKdDtcbmNsYXNzIG9lIHtcbiAgY29uc3RydWN0b3IociwgaCwgYSkge1xuICAgIEEodGhpcywgTCwgbnVsbCk7XG4gICAgQSh0aGlzLCBsdCwgMCk7XG4gICAgQSh0aGlzLCBmdCwgeyBhYm9ydDogITEsIHN0OiBwZXJmb3JtYW5jZS5ub3coKSB9KTtcbiAgICBSKHRoaXMsIFwiZmluZFwiLCBhc3luYyAocikgPT4gKChtKHRoaXMsIEwpID09IG51bGwgfHwgciA8PSBtKHRoaXMsIGx0KSB8fCByIC0gbSh0aGlzLCBsdCkgPiAzZTYpICYmIG0odGhpcywgdXQpLmNhbGwodGhpcywgciksIG0odGhpcywgZnQpLmFib3J0ID0gITAsIEUodGhpcywgbHQsIHIpLCBFKHRoaXMsIGZ0LCB7IGFib3J0OiAhMSwgc3Q6IHBlcmZvcm1hbmNlLm5vdygpIH0pLCBhd2FpdCBtKHRoaXMsIHh0KS5jYWxsKHRoaXMsIHIsIG0odGhpcywgTCksIG0odGhpcywgZnQpKSkpO1xuICAgIC8vIGZpeCBWaWRlb0ZyYW1lIGR1cmF0aW9uIGlzIG51bGxcbiAgICBBKHRoaXMsIGt0LCAwKTtcbiAgICBBKHRoaXMsIGR0LCAhMSk7XG4gICAgQSh0aGlzLCBXLCAwKTtcbiAgICBBKHRoaXMsIGssIFtdKTtcbiAgICBBKHRoaXMsIHJ0LCAwKTtcbiAgICBBKHRoaXMsIGN0LCAwKTtcbiAgICBBKHRoaXMsIHh0LCBhc3luYyAociwgaCwgYSkgPT4ge1xuICAgICAgaWYgKGggPT0gbnVsbCB8fCBoLnN0YXRlID09PSBcImNsb3NlZFwiIHx8IGEuYWJvcnQpIHJldHVybiBudWxsO1xuICAgICAgaWYgKG0odGhpcywgaykubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmID0gbSh0aGlzLCBrKVswXTtcbiAgICAgICAgcmV0dXJuIHIgPCBmLnRpbWVzdGFtcCA/IG51bGwgOiAobSh0aGlzLCBrKS5zaGlmdCgpLCByID4gZi50aW1lc3RhbXAgKyAoZi5kdXJhdGlvbiA/PyAwKSA/IChmLmNsb3NlKCksIGF3YWl0IG0odGhpcywgeHQpLmNhbGwodGhpcywgciwgaCwgYSkpIDogKG0odGhpcywgaykubGVuZ3RoIDwgMTAgJiYgbSh0aGlzLCBEdCkuY2FsbCh0aGlzLCBoKS5jYXRjaCgoZCkgPT4ge1xuICAgICAgICAgIHRocm93IG0odGhpcywgdXQpLmNhbGwodGhpcywgciksIGQ7XG4gICAgICAgIH0pLCBmKSk7XG4gICAgICB9XG4gICAgICBpZiAobSh0aGlzLCBhdCkgfHwgbSh0aGlzLCBydCkgPCBtKHRoaXMsIGN0KSAmJiBoLmRlY29kZVF1ZXVlU2l6ZSA+IDApIHtcbiAgICAgICAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gYS5zdCA+IDZlMylcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBNUDRDbGlwLnRpY2sgdmlkZW8gdGltZW91dCwgJHtKU09OLnN0cmluZ2lmeShtKHRoaXMsIEp0KS5jYWxsKHRoaXMpKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgTmUoMTUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG0odGhpcywgVykgPj0gdGhpcy5zYW1wbGVzLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBtKHRoaXMsIER0KS5jYWxsKHRoaXMsIGgpO1xuICAgICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgICAgdGhyb3cgbSh0aGlzLCB1dCkuY2FsbCh0aGlzLCByKSwgZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IG0odGhpcywgeHQpLmNhbGwodGhpcywgciwgaCwgYSk7XG4gICAgfSk7XG4gICAgQSh0aGlzLCBhdCwgITEpO1xuICAgIEEodGhpcywgRHQsIGFzeW5jIChyKSA9PiB7XG4gICAgICB2YXIgZiwgZDtcbiAgICAgIGlmIChtKHRoaXMsIGF0KSkgcmV0dXJuO1xuICAgICAgRSh0aGlzLCBhdCwgITApO1xuICAgICAgbGV0IGggPSBtKHRoaXMsIFcpICsgMSwgYSA9ICExO1xuICAgICAgZm9yICg7IGggPCB0aGlzLnNhbXBsZXMubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuc2FtcGxlc1toXTtcbiAgICAgICAgaWYgKCFhICYmICFwLmRlbGV0ZWQgJiYgKGEgPSAhMCksIHAuaXNfaWRyKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChhKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnNhbXBsZXMuc2xpY2UobSh0aGlzLCBXKSwgaCk7XG4gICAgICAgIGlmICgoKGYgPSBwWzBdKSA9PSBudWxsID8gdm9pZCAwIDogZi5pc19pZHIpICE9PSAhMClcbiAgICAgICAgICB6Lndhcm4oXCJGaXJzdCBzYW1wbGUgbm90IGlkciBmcmFtZVwiKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgbiA9IGF3YWl0IExpKHAsIHRoaXMubG9jYWxGaWxlUmVhZGVyKTtcbiAgICAgICAgICBpZiAoci5zdGF0ZSA9PT0gXCJjbG9zZWRcIikgcmV0dXJuO1xuICAgICAgICAgIEUodGhpcywga3QsICgoZCA9IG5bMF0pID09IG51bGwgPyB2b2lkIDAgOiBkLmR1cmF0aW9uKSA/PyAwKSwga2kociwgbiwge1xuICAgICAgICAgICAgb25EZWNvZGluZ0Vycm9yOiAodikgPT4ge1xuICAgICAgICAgICAgICBpZiAobSh0aGlzLCBkdCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgdjtcbiAgICAgICAgICAgICAgbSh0aGlzLCBydCkgPT09IDAgJiYgKEUodGhpcywgZHQsICEwKSwgei53YXJuKFwiRG93bmdyYWRlIHRvIHNvZnR3YXJlIGRlY29kZVwiKSwgbSh0aGlzLCB1dCkuY2FsbCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIEUodGhpcywgY3QsIG0odGhpcywgY3QpICsgbi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBFKHRoaXMsIFcsIGgpLCBFKHRoaXMsIGF0LCAhMSk7XG4gICAgfSk7XG4gICAgQSh0aGlzLCB1dCwgKHIpID0+IHtcbiAgICAgIHZhciBoLCBhO1xuICAgICAgaWYgKEUodGhpcywgYXQsICExKSwgbSh0aGlzLCBrKS5mb3JFYWNoKChmKSA9PiBmLmNsb3NlKCkpLCBFKHRoaXMsIGssIFtdKSwgciA9PSBudWxsIHx8IHIgPT09IDApXG4gICAgICAgIEUodGhpcywgVywgMCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IGYgPSAwO1xuICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IHRoaXMuc2FtcGxlcy5sZW5ndGg7IGQrKykge1xuICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnNhbXBsZXNbZF07XG4gICAgICAgICAgaWYgKHAuaXNfaWRyICYmIChmID0gZCksICEocC5jdHMgPCByKSkge1xuICAgICAgICAgICAgRSh0aGlzLCBXLCBmKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgRSh0aGlzLCBjdCwgMCksIEUodGhpcywgcnQsIDApLCAoKGggPSBtKHRoaXMsIEwpKSA9PSBudWxsID8gdm9pZCAwIDogaC5zdGF0ZSkgIT09IFwiY2xvc2VkXCIgJiYgKChhID0gbSh0aGlzLCBMKSkgPT0gbnVsbCB8fCBhLmNsb3NlKCkpLCBFKHRoaXMsIEwsIG5ldyBWaWRlb0RlY29kZXIoe1xuICAgICAgICBvdXRwdXQ6IChmKSA9PiB7XG4gICAgICAgICAgaWYgKEUodGhpcywgcnQsIG0odGhpcywgcnQpICsgMSksIGYudGltZXN0YW1wID09PSAtMSkge1xuICAgICAgICAgICAgZi5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZCA9IGY7XG4gICAgICAgICAgZi5kdXJhdGlvbiA9PSBudWxsICYmIChkID0gbmV3IFZpZGVvRnJhbWUoZiwge1xuICAgICAgICAgICAgZHVyYXRpb246IG0odGhpcywga3QpXG4gICAgICAgICAgfSksIGYuY2xvc2UoKSksIG0odGhpcywgaykucHVzaChkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IChmKSA9PiB7XG4gICAgICAgICAgei5lcnJvcihgTVA0Q2xpcCBWaWRlb0RlY29kZXIgZXJyOiAke2YubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSkpLCBtKHRoaXMsIEwpLmNvbmZpZ3VyZSh7XG4gICAgICAgIC4uLnRoaXMuY29uZixcbiAgICAgICAgLi4ubSh0aGlzLCBkdCkgPyB7IGhhcmR3YXJlQWNjZWxlcmF0aW9uOiBcInByZWZlci1zb2Z0d2FyZVwiIH0gOiB7fVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQSh0aGlzLCBKdCwgKCkgPT4ge1xuICAgICAgdmFyIHIsIGg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aW1lOiBtKHRoaXMsIGx0KSxcbiAgICAgICAgZGVjU3RhdGU6IChyID0gbSh0aGlzLCBMKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuc3RhdGUsXG4gICAgICAgIGRlY1FTaXplOiAoaCA9IG0odGhpcywgTCkpID09IG51bGwgPyB2b2lkIDAgOiBoLmRlY29kZVF1ZXVlU2l6ZSxcbiAgICAgICAgZGVjQ3Vzb3JJZHg6IG0odGhpcywgVyksXG4gICAgICAgIHNhbXBsZUxlbjogdGhpcy5zYW1wbGVzLmxlbmd0aCxcbiAgICAgICAgaW5wdXRDbnQ6IG0odGhpcywgY3QpLFxuICAgICAgICBvdXRwdXRDbnQ6IG0odGhpcywgcnQpLFxuICAgICAgICBjYWNoZUZyYW1lTGVuOiBtKHRoaXMsIGspLmxlbmd0aCxcbiAgICAgICAgc29mdERlb2NkZTogbSh0aGlzLCBkdClcbiAgICAgIH07XG4gICAgfSk7XG4gICAgUih0aGlzLCBcImRlc3Ryb3lcIiwgKCkgPT4ge1xuICAgICAgdmFyIHIsIGg7XG4gICAgICAoKHIgPSBtKHRoaXMsIEwpKSA9PSBudWxsID8gdm9pZCAwIDogci5zdGF0ZSkgIT09IFwiY2xvc2VkXCIgJiYgKChoID0gbSh0aGlzLCBMKSkgPT0gbnVsbCB8fCBoLmNsb3NlKCkpLCBFKHRoaXMsIEwsIG51bGwpLCBtKHRoaXMsIGZ0KS5hYm9ydCA9ICEwLCBtKHRoaXMsIGspLmZvckVhY2goKGEpID0+IGEuY2xvc2UoKSksIEUodGhpcywgaywgW10pLCB0aGlzLmxvY2FsRmlsZVJlYWRlci5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHRoaXMubG9jYWxGaWxlUmVhZGVyID0gciwgdGhpcy5zYW1wbGVzID0gaCwgdGhpcy5jb25mID0gYTtcbiAgfVxufVxuTCA9IG5ldyBXZWFrTWFwKCksIGx0ID0gbmV3IFdlYWtNYXAoKSwgZnQgPSBuZXcgV2Vha01hcCgpLCBrdCA9IG5ldyBXZWFrTWFwKCksIGR0ID0gbmV3IFdlYWtNYXAoKSwgVyA9IG5ldyBXZWFrTWFwKCksIGsgPSBuZXcgV2Vha01hcCgpLCBydCA9IG5ldyBXZWFrTWFwKCksIGN0ID0gbmV3IFdlYWtNYXAoKSwgeHQgPSBuZXcgV2Vha01hcCgpLCBhdCA9IG5ldyBXZWFrTWFwKCksIER0ID0gbmV3IFdlYWtNYXAoKSwgdXQgPSBuZXcgV2Vha01hcCgpLCBKdCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUnQsIE10LCBaLCBwdCwgWCwgSiwgaiwgT3QsIE50LCAkdCwgcXQ7XG5jbGFzcyBDaSB7XG4gIGNvbnN0cnVjdG9yKHIsIGgsIGEsIGYpIHtcbiAgICBBKHRoaXMsIFJ0LCAxKTtcbiAgICBBKHRoaXMsIE10KTtcbiAgICBBKHRoaXMsIFosIG51bGwpO1xuICAgIEEodGhpcywgcHQsIHsgYWJvcnQ6ICExLCBzdDogcGVyZm9ybWFuY2Uubm93KCkgfSk7XG4gICAgUih0aGlzLCBcImZpbmRcIiwgYXN5bmMgKHIpID0+IHtcbiAgICAgIGlmIChtKHRoaXMsIFopID09IG51bGwgfHwgciA8PSBtKHRoaXMsIFgpIHx8IHIgLSBtKHRoaXMsIFgpID4gMWU1KSB7XG4gICAgICAgIG0odGhpcywgJHQpLmNhbGwodGhpcyksIEUodGhpcywgWCwgcik7XG4gICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdGhpcy5zYW1wbGVzLmxlbmd0aDsgYSsrKVxuICAgICAgICAgIGlmICghKHRoaXMuc2FtcGxlc1thXS5jdHMgPCByKSkge1xuICAgICAgICAgICAgRSh0aGlzLCBKLCBhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbSh0aGlzLCBwdCkuYWJvcnQgPSAhMDtcbiAgICAgIGNvbnN0IGggPSByIC0gbSh0aGlzLCBYKTtcbiAgICAgIHJldHVybiBFKHRoaXMsIFgsIHIpLCBFKHRoaXMsIHB0LCB7IGFib3J0OiAhMSwgc3Q6IHBlcmZvcm1hbmNlLm5vdygpIH0pLCBhd2FpdCBtKHRoaXMsIE90KS5jYWxsKHRoaXMsIGgsIG0odGhpcywgWiksIG0odGhpcywgcHQpKTtcbiAgICB9KTtcbiAgICBBKHRoaXMsIFgsIDApO1xuICAgIEEodGhpcywgSiwgMCk7XG4gICAgQSh0aGlzLCBqLCB7XG4gICAgICBmcmFtZUNudDogMCxcbiAgICAgIGRhdGE6IFtdXG4gICAgfSk7XG4gICAgQSh0aGlzLCBPdCwgYXN5bmMgKHIsIGggPSBudWxsLCBhKSA9PiB7XG4gICAgICBpZiAoaCA9PSBudWxsIHx8IGEuYWJvcnQgfHwgaC5zdGF0ZSA9PT0gXCJjbG9zZWRcIikgcmV0dXJuIFtdO1xuICAgICAgY29uc3QgZiA9IE1hdGguY2VpbChyICogKG0odGhpcywgTXQpIC8gMWU2KSk7XG4gICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgY29uc3QgZCA9IG0odGhpcywgaikuZnJhbWVDbnQgLSBmO1xuICAgICAgaWYgKGQgPiAwKVxuICAgICAgICByZXR1cm4gZCA8IHEuc2FtcGxlUmF0ZSAvIDEwICYmIG0odGhpcywgTnQpLmNhbGwodGhpcywgaCksIFBpKG0odGhpcywgaiksIGYpO1xuICAgICAgaWYgKGguZGVjb2RlUXVldWVTaXplID4gMTApIHtcbiAgICAgICAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gYS5zdCA+IDNlMylcbiAgICAgICAgICB0aHJvdyBhLmFib3J0ID0gITAsIEVycm9yKFxuICAgICAgICAgICAgYE1QNENsaXAudGljayBhdWRpbyB0aW1lb3V0LCAke0pTT04uc3RyaW5naWZ5KG0odGhpcywgcXQpLmNhbGwodGhpcykpfWBcbiAgICAgICAgICApO1xuICAgICAgICBhd2FpdCBOZSgxNSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobSh0aGlzLCBKKSA+PSB0aGlzLnNhbXBsZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIG0odGhpcywgTnQpLmNhbGwodGhpcywgaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbSh0aGlzLCBPdCkuY2FsbCh0aGlzLCByLCBoLCBhKTtcbiAgICB9KTtcbiAgICBBKHRoaXMsIE50LCAocikgPT4ge1xuICAgICAgaWYgKHIuZGVjb2RlUXVldWVTaXplID4gMTAwKSByZXR1cm47XG4gICAgICBjb25zdCBoID0gW107XG4gICAgICBsZXQgYSA9IG0odGhpcywgSik7XG4gICAgICBmb3IgKDsgYSA8IHRoaXMuc2FtcGxlcy5sZW5ndGg7ICkge1xuICAgICAgICBjb25zdCBmID0gdGhpcy5zYW1wbGVzW2FdO1xuICAgICAgICBpZiAoYSArPSAxLCAhZi5kZWxldGVkICYmIChoLnB1c2goZiksIGgubGVuZ3RoID49IDEwKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIEUodGhpcywgSiwgYSksIHIuZGVjb2RlKFxuICAgICAgICBoLm1hcChcbiAgICAgICAgICAoZikgPT4gbmV3IEVuY29kZWRBdWRpb0NodW5rKHtcbiAgICAgICAgICAgIHR5cGU6IFwia2V5XCIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGYuY3RzLFxuICAgICAgICAgICAgZHVyYXRpb246IGYuZHVyYXRpb24sXG4gICAgICAgICAgICBkYXRhOiBmLmRhdGFcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICAgIEEodGhpcywgJHQsICgpID0+IHtcbiAgICAgIHZhciByO1xuICAgICAgRSh0aGlzLCBYLCAwKSwgRSh0aGlzLCBKLCAwKSwgRSh0aGlzLCBqLCB7XG4gICAgICAgIGZyYW1lQ250OiAwLFxuICAgICAgICBkYXRhOiBbXVxuICAgICAgfSksIChyID0gbSh0aGlzLCBaKSkgPT0gbnVsbCB8fCByLmNsb3NlKCksIEUodGhpcywgWiwgemkoXG4gICAgICAgIHRoaXMuY29uZixcbiAgICAgICAge1xuICAgICAgICAgIHJlc2FtcGxlUmF0ZTogcS5zYW1wbGVSYXRlLFxuICAgICAgICAgIHZvbHVtZTogbSh0aGlzLCBSdClcbiAgICAgICAgfSxcbiAgICAgICAgKGgpID0+IHtcbiAgICAgICAgICBtKHRoaXMsIGopLmRhdGEucHVzaChoKSwgbSh0aGlzLCBqKS5mcmFtZUNudCArPSBoWzBdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgfSk7XG4gICAgQSh0aGlzLCBxdCwgKCkgPT4ge1xuICAgICAgdmFyIHIsIGg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aW1lOiBtKHRoaXMsIFgpLFxuICAgICAgICBkZWNTdGF0ZTogKHIgPSBtKHRoaXMsIFopKSA9PSBudWxsID8gdm9pZCAwIDogci5zdGF0ZSxcbiAgICAgICAgZGVjUVNpemU6IChoID0gbSh0aGlzLCBaKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGguZGVjb2RlUXVldWVTaXplLFxuICAgICAgICBkZWNDdXNvcklkeDogbSh0aGlzLCBKKSxcbiAgICAgICAgc2FtcGxlTGVuOiB0aGlzLnNhbXBsZXMubGVuZ3RoLFxuICAgICAgICBwY21MZW46IG0odGhpcywgaikuZnJhbWVDbnRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgUih0aGlzLCBcImRlc3Ryb3lcIiwgKCkgPT4ge1xuICAgICAgRSh0aGlzLCBaLCBudWxsKSwgbSh0aGlzLCBwdCkuYWJvcnQgPSAhMCwgRSh0aGlzLCBqLCB7XG4gICAgICAgIGZyYW1lQ250OiAwLFxuICAgICAgICBkYXRhOiBbXVxuICAgICAgfSksIHRoaXMubG9jYWxGaWxlUmVhZGVyLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5sb2NhbEZpbGVSZWFkZXIgPSByLCB0aGlzLnNhbXBsZXMgPSBoLCB0aGlzLmNvbmYgPSBhLCBFKHRoaXMsIFJ0LCBmLnZvbHVtZSksIEUodGhpcywgTXQsIGYudGFyZ2V0U2FtcGxlUmF0ZSk7XG4gIH1cbn1cblJ0ID0gbmV3IFdlYWtNYXAoKSwgTXQgPSBuZXcgV2Vha01hcCgpLCBaID0gbmV3IFdlYWtNYXAoKSwgcHQgPSBuZXcgV2Vha01hcCgpLCBYID0gbmV3IFdlYWtNYXAoKSwgSiA9IG5ldyBXZWFrTWFwKCksIGogPSBuZXcgV2Vha01hcCgpLCBPdCA9IG5ldyBXZWFrTWFwKCksIE50ID0gbmV3IFdlYWtNYXAoKSwgJHQgPSBuZXcgV2Vha01hcCgpLCBxdCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB6aShsLCByLCBoKSB7XG4gIGNvbnN0IGEgPSAobikgPT4ge1xuICAgIGlmIChuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaWYgKHIudm9sdW1lICE9PSAxKVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbilcbiAgICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IHYubGVuZ3RoOyBiKyspIHZbYl0gKj0gci52b2x1bWU7XG4gICAgICBuLmxlbmd0aCA9PT0gMSAmJiAobiA9IFtuWzBdLCBuWzBdXSksIGgobik7XG4gICAgfVxuICB9LCBmID0gVGkoYSksIGQgPSByLnJlc2FtcGxlUmF0ZSAhPT0gbC5zYW1wbGVSYXRlLCBwID0gbmV3IEF1ZGlvRGVjb2Rlcih7XG4gICAgb3V0cHV0OiAobikgPT4ge1xuICAgICAgY29uc3QgdiA9IGxlKG4pO1xuICAgICAgZCA/IGYoXG4gICAgICAgICgpID0+IGJpKHYsIG4uc2FtcGxlUmF0ZSwge1xuICAgICAgICAgIHJhdGU6IHIucmVzYW1wbGVSYXRlLFxuICAgICAgICAgIGNoYW5Db3VudDogbi5udW1iZXJPZkNoYW5uZWxzXG4gICAgICAgIH0pXG4gICAgICApIDogYSh2KSwgbi5jbG9zZSgpO1xuICAgIH0sXG4gICAgZXJyb3I6IChuKSA9PiB7XG4gICAgICB6LmVycm9yKGBNUDRDbGlwIEF1ZGlvRGVjb2RlciBlcnI6ICR7bi5tZXNzYWdlfWApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwLmNvbmZpZ3VyZShsKSwge1xuICAgIGRlY29kZShuKSB7XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgbikgcC5kZWNvZGUodik7XG4gICAgfSxcbiAgICBjbG9zZSgpIHtcbiAgICAgIHAuc3RhdGUgIT09IFwiY2xvc2VkXCIgJiYgcC5jbG9zZSgpO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHAuc3RhdGU7XG4gICAgfSxcbiAgICBnZXQgZGVjb2RlUXVldWVTaXplKCkge1xuICAgICAgcmV0dXJuIHAuZGVjb2RlUXVldWVTaXplO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIFRpKGwpIHtcbiAgY29uc3QgciA9IFtdO1xuICBsZXQgaCA9IDA7XG4gIGZ1bmN0aW9uIGEocCwgbikge1xuICAgIHJbbl0gPSBwLCBmKCk7XG4gIH1cbiAgZnVuY3Rpb24gZigpIHtcbiAgICBjb25zdCBwID0gcltoXTtcbiAgICBwICE9IG51bGwgJiYgKGwocCksIGggKz0gMSwgZigpKTtcbiAgfVxuICBsZXQgZCA9IDA7XG4gIHJldHVybiAocCkgPT4ge1xuICAgIGNvbnN0IG4gPSBkO1xuICAgIGQgKz0gMSwgcCgpLnRoZW4oKHYpID0+IGEodiwgbikpLmNhdGNoKCh2KSA9PiBhKHYsIG4pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFBpKGwsIHIpIHtcbiAgY29uc3QgaCA9IFtuZXcgRmxvYXQzMkFycmF5KHIpLCBuZXcgRmxvYXQzMkFycmF5KHIpXTtcbiAgbGV0IGEgPSAwLCBmID0gMDtcbiAgZm9yICg7IGYgPCBsLmRhdGEubGVuZ3RoOyApIHtcbiAgICBjb25zdCBbZCwgcF0gPSBsLmRhdGFbZl07XG4gICAgaWYgKGEgKyBkLmxlbmd0aCA+IHIpIHtcbiAgICAgIGNvbnN0IG4gPSByIC0gYTtcbiAgICAgIGhbMF0uc2V0KGQuc3ViYXJyYXkoMCwgbiksIGEpLCBoWzFdLnNldChwLnN1YmFycmF5KDAsIG4pLCBhKSwgbC5kYXRhW2ZdWzBdID0gZC5zdWJhcnJheShuLCBkLmxlbmd0aCksIGwuZGF0YVtmXVsxXSA9IHAuc3ViYXJyYXkobiwgcC5sZW5ndGgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlXG4gICAgICBoWzBdLnNldChkLCBhKSwgaFsxXS5zZXQocCwgYSksIGEgKz0gZC5sZW5ndGgsIGYrKztcbiAgfVxuICByZXR1cm4gbC5kYXRhID0gbC5kYXRhLnNsaWNlKGYpLCBsLmZyYW1lQ250IC09IHIsIGg7XG59XG5hc3luYyBmdW5jdGlvbiBMaShsLCByKSB7XG4gIGNvbnN0IGggPSBsWzBdLCBhID0gbC5hdCgtMSk7XG4gIGlmIChhID09IG51bGwpIHJldHVybiBbXTtcbiAgY29uc3QgZiA9IGEub2Zmc2V0ICsgYS5zaXplIC0gaC5vZmZzZXQ7XG4gIGlmIChmIDwgM2U3KSB7XG4gICAgY29uc3QgZCA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgYXdhaXQgci5yZWFkKGYsIHsgYXQ6IGgub2Zmc2V0IH0pXG4gICAgKTtcbiAgICByZXR1cm4gbC5tYXAoKHApID0+IHtcbiAgICAgIGNvbnN0IG4gPSBwLm9mZnNldCAtIGgub2Zmc2V0O1xuICAgICAgbGV0IHYgPSBkLnN1YmFycmF5KG4sIG4gKyBwLnNpemUpO1xuICAgICAgcmV0dXJuIHAuaXNfaWRyICYmICh2ID0gRWUodikpLCBuZXcgRW5jb2RlZFZpZGVvQ2h1bmsoe1xuICAgICAgICB0eXBlOiBwLmlzX3N5bmMgPyBcImtleVwiIDogXCJkZWx0YVwiLFxuICAgICAgICB0aW1lc3RhbXA6IHAuY3RzLFxuICAgICAgICBkdXJhdGlvbjogcC5kdXJhdGlvbixcbiAgICAgICAgZGF0YTogdlxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGwubWFwKGFzeW5jIChkKSA9PiB7XG4gICAgICBsZXQgcCA9IGF3YWl0IHIucmVhZChkLnNpemUsIHtcbiAgICAgICAgYXQ6IGQub2Zmc2V0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkLmlzX2lkciAmJiAocCA9IEVlKG5ldyBVaW50OEFycmF5KHApKSksIG5ldyBFbmNvZGVkVmlkZW9DaHVuayh7XG4gICAgICAgIHR5cGU6IGQuaXNfc3luYyA/IFwia2V5XCIgOiBcImRlbHRhXCIsXG4gICAgICAgIHRpbWVzdGFtcDogZC5jdHMsXG4gICAgICAgIGR1cmF0aW9uOiBkLmR1cmF0aW9uLFxuICAgICAgICBkYXRhOiBwXG4gICAgICB9KTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gVWUobCwgciwgaCkge1xuICBjb25zdCBhID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhsLCByKSwgZiA9IGEuZ2V0Q29udGV4dChcIjJkXCIpO1xuICByZXR1cm4gYXN5bmMgKGQpID0+IChmLmRyYXdJbWFnZShkLCAwLCAwLCBsLCByKSwgZC5jbG9zZSgpLCBhd2FpdCBhLmNvbnZlcnRUb0Jsb2IoaCkpO1xufVxuZnVuY3Rpb24ga2kobCwgciwgaCkge1xuICBsZXQgYSA9IDA7XG4gIGlmIChsLnN0YXRlID09PSBcImNvbmZpZ3VyZWRcIikge1xuICAgIGZvciAoOyBhIDwgci5sZW5ndGg7IGErKykgbC5kZWNvZGUoclthXSk7XG4gICAgbC5mbHVzaCgpLmNhdGNoKChmKSA9PiB7XG4gICAgICBpZiAoIShmIGluc3RhbmNlb2YgRXJyb3IpKSB0aHJvdyBmO1xuICAgICAgaWYgKGYubWVzc2FnZS5pbmNsdWRlcyhcIkRlY29kaW5nIGVycm9yXCIpICYmIGgub25EZWNvZGluZ0Vycm9yICE9IG51bGwpIHtcbiAgICAgICAgaC5vbkRlY29kaW5nRXJyb3IoZik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZi5tZXNzYWdlLmluY2x1ZGVzKFwiQWJvcnRlZCBkdWUgdG8gY2xvc2VcIikpXG4gICAgICAgIHRocm93IGY7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEVlKGwpIHtcbiAgY29uc3QgciA9IG5ldyBEYXRhVmlldyhsLmJ1ZmZlciwgbC5ieXRlT2Zmc2V0LCBsLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gKHIuZ2V0VWludDgoNCkgJiAzMSkgPT09IDYgPyBsLnN1YmFycmF5KHIuZ2V0VWludDMyKDApICsgNCkgOiBsO1xufVxuZnVuY3Rpb24gRGkobCwgcikge1xuICBpZiAociAhPT0gXCJhdmMxXCIgJiYgciAhPT0gXCJodmMxXCIpIHJldHVybiAhMTtcbiAgY29uc3QgaCA9IG5ldyBEYXRhVmlldyhsLmJ1ZmZlcik7XG4gIGxldCBhID0gMDtcbiAgZm9yICg7IGEgPCBsLmJ5dGVMZW5ndGggLSA0OyApIHtcbiAgICBpZiAociA9PT0gXCJhdmMxXCIpIHtcbiAgICAgIGlmICgoaC5nZXRVaW50OChhICsgNCkgJiAzMSkgPT09IDUpIHJldHVybiAhMDtcbiAgICB9IGVsc2UgaWYgKHIgPT09IFwiaHZjMVwiICYmIChoLmdldFVpbnQ4KGEgKyA0KSA+PiAxICYgNjMpID09PSAyMClcbiAgICAgIHJldHVybiAhMDtcbiAgICBhICs9IGguZ2V0VWludDMyKGEpICsgNDtcbiAgfVxuICByZXR1cm4gITE7XG59XG52YXIgJDtcbmNsYXNzIFJpIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgQSh0aGlzLCAkLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBSKHRoaXMsIFwib25cIiwgKHIsIGgpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBtKHRoaXMsICQpLmdldChyKSA/PyAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgcmV0dXJuIGEuYWRkKGgpLCBtKHRoaXMsICQpLmhhcyhyKSB8fCBtKHRoaXMsICQpLnNldChyLCBhKSwgKCkgPT4ge1xuICAgICAgICBhLmRlbGV0ZShoKSwgYS5zaXplID09PSAwICYmIG0odGhpcywgJCkuZGVsZXRlKHIpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBSKHRoaXMsIFwib25jZVwiLCAociwgaCkgPT4ge1xuICAgICAgY29uc3QgYSA9IHRoaXMub24ociwgKC4uLmYpID0+IHtcbiAgICAgICAgYSgpLCBoKC4uLmYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYTtcbiAgICB9KTtcbiAgICBSKHRoaXMsIFwiZW1pdFwiLCAociwgLi4uaCkgPT4ge1xuICAgICAgY29uc3QgYSA9IG0odGhpcywgJCkuZ2V0KHIpO1xuICAgICAgYSAhPSBudWxsICYmIGEuZm9yRWFjaCgoZikgPT4gZiguLi5oKSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGZvcndhcmRFdmVudChyLCBoLCBhKSB7XG4gICAgY29uc3QgZiA9IGEubWFwKChkKSA9PiB7XG4gICAgICBjb25zdCBbcCwgbl0gPSBBcnJheS5pc0FycmF5KGQpID8gZCA6IFtkLCBkXTtcbiAgICAgIHJldHVybiByLm9uKHAsICguLi52KSA9PiB7XG4gICAgICAgIGguZW1pdChuLCAuLi52KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmLmZvckVhY2goKGQpID0+IGQoKSk7XG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIG0odGhpcywgJCkuY2xlYXIoKTtcbiAgfVxufVxuJCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB1ZSA9IChsLCByKSA9PiB7XG4gIGNvbnN0IGggPSBuZXcgVWludDhBcnJheSg4KTtcbiAgbmV3IERhdGFWaWV3KGguYnVmZmVyKS5zZXRVaW50MzIoMCwgcik7XG4gIGZvciAobGV0IGYgPSAwOyBmIDwgNDsgZisrKVxuICAgIGhbNCArIGZdID0gbC5jaGFyQ29kZUF0KGYpO1xuICByZXR1cm4gaDtcbn0sIE1pID0gKCkgPT4ge1xuICBjb25zdCBsID0gbmV3IFRleHRFbmNvZGVyKCksIHIgPSBsLmVuY29kZShcIm1kdGFcIiksIGggPSBsLmVuY29kZShcIm1wNCBoYW5kbGVyXCIpLCBhID0gMzIgKyBoLmJ5dGVMZW5ndGggKyAxLCBmID0gbmV3IFVpbnQ4QXJyYXkoYSksIGQgPSBuZXcgRGF0YVZpZXcoZi5idWZmZXIpO1xuICByZXR1cm4gZi5zZXQodWUoXCJoZGxyXCIsIGEpLCAwKSwgZC5zZXRVaW50MzIoOCwgMCksIGYuc2V0KHIsIDE2KSwgZi5zZXQoaCwgMzIpLCBmO1xufSwgT2kgPSAobCkgPT4ge1xuICBjb25zdCByID0gbmV3IFRleHRFbmNvZGVyKCksIGggPSByLmVuY29kZShcIm1kdGFcIiksIGEgPSBsLm1hcCgoYikgPT4ge1xuICAgIGNvbnN0IHkgPSByLmVuY29kZShiKSwgQiA9IDggKyB5LmJ5dGVMZW5ndGgsIHQgPSBuZXcgVWludDhBcnJheShCKTtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KHQuYnVmZmVyKS5zZXRVaW50MzIoMCwgQiksIHQuc2V0KGgsIDQpLCB0LnNldCh5LCA0ICsgaC5ieXRlTGVuZ3RoKSwgdDtcbiAgfSksIGQgPSAxNiArIGEucmVkdWNlKChiLCB5KSA9PiBiICsgeS5ieXRlTGVuZ3RoLCAwKSwgcCA9IG5ldyBVaW50OEFycmF5KGQpLCBuID0gbmV3IERhdGFWaWV3KHAuYnVmZmVyKTtcbiAgcC5zZXQodWUoXCJrZXlzXCIsIGQpLCAwKSwgbi5zZXRVaW50MzIoOCwgMCksIG4uc2V0VWludDMyKDEyLCBsLmxlbmd0aCk7XG4gIGxldCB2ID0gMTY7XG4gIGZvciAoY29uc3QgYiBvZiBhKVxuICAgIHAuc2V0KGIsIHYpLCB2ICs9IGIuYnl0ZUxlbmd0aDtcbiAgcmV0dXJuIHA7XG59LCBOaSA9IChsKSA9PiB7XG4gIGNvbnN0IHIgPSBuZXcgVGV4dEVuY29kZXIoKSwgaCA9IHIuZW5jb2RlKFwiZGF0YVwiKSwgYSA9IE9iamVjdC5lbnRyaWVzKGwpLm1hcCgoW3YsIGJdLCB5KSA9PiB7XG4gICAgY29uc3QgQiA9IHkgKyAxLCB0ID0gci5lbmNvZGUoYiksIGUgPSAyNCArIHQuYnl0ZUxlbmd0aCwgaSA9IG5ldyBVaW50OEFycmF5KGUpLCBzID0gbmV3IERhdGFWaWV3KGkuYnVmZmVyKTtcbiAgICByZXR1cm4gcy5zZXRVaW50MzIoMCwgZSksIHMuc2V0VWludDMyKDQsIEIpLCBzLnNldFVpbnQzMig4LCAxNiArIHQuYnl0ZUxlbmd0aCksIGkuc2V0KGgsIDEyKSwgcy5zZXRVaW50MzIoMTYsIDEpLCBpLnNldCh0LCAyNCksIGk7XG4gIH0pLCBkID0gOCArIGEucmVkdWNlKCh2LCBiKSA9PiB2ICsgYi5ieXRlTGVuZ3RoLCAwKSwgcCA9IG5ldyBVaW50OEFycmF5KGQpO1xuICBwLnNldCh1ZShcImlsc3RcIiwgZCksIDApO1xuICBsZXQgbiA9IDg7XG4gIGZvciAoY29uc3QgdiBvZiBhKVxuICAgIHAuc2V0KHYsIG4pLCBuICs9IHYuYnl0ZUxlbmd0aDtcbiAgcmV0dXJuIHA7XG59LCBHaSA9IChsKSA9PiB7XG4gIGNvbnN0IHIgPSBNaSgpLCBoID0gT2koT2JqZWN0LmtleXMobCkpLCBhID0gTmkobCksIGYgPSByLmxlbmd0aCArIGgubGVuZ3RoICsgYS5sZW5ndGgsIGQgPSBuZXcgVWludDhBcnJheShmKTtcbiAgcmV0dXJuIGQuc2V0KHIsIDApLCBkLnNldChoLCByLmxlbmd0aCksIGQuc2V0KGEsIHIubGVuZ3RoICsgaC5sZW5ndGgpLCBkO1xufTtcbmZ1bmN0aW9uIHJuKGwpIHtcbiAgei5pbmZvKFwicmVjb2RlbXV4IG9wdHM6XCIsIGwpO1xuICBjb25zdCByID0gRC5jcmVhdGVGaWxlKCksIGggPSBuZXcgUmkoKSwgYSA9ICh2LCBiKSA9PiB7XG4gICAgY29uc3QgQiA9IHYuYWRkKFwidWR0YVwiKS5hZGQoXCJtZXRhXCIpO1xuICAgIEIuZGF0YSA9IEdpKGIpLCBCLnNpemUgPSBCLmRhdGEuYnl0ZUxlbmd0aDtcbiAgfTtcbiAgbGV0IGYgPSAhMTtcbiAgY29uc3QgZCA9ICgpID0+IHtcbiAgICByLm1vb3YgPT0gbnVsbCB8fCBmIHx8IChmID0gITAsIGwubWV0YURhdGFUYWdzICE9IG51bGwgJiYgYShyLm1vb3YsIGwubWV0YURhdGFUYWdzKSwgbC5kdXJhdGlvbiAhPSBudWxsICYmIChyLm1vb3YubXZoZC5kdXJhdGlvbiA9IGwuZHVyYXRpb24pKTtcbiAgfTtcbiAgaC5vbmNlKFwiVmlkZW9SZWFkeVwiLCBkKSwgaC5vbmNlKFwiQXVkaW9SZWFkeVwiLCBkKTtcbiAgbGV0IHAgPSBsLnZpZGVvICE9IG51bGwgPyBIaShsLnZpZGVvLCByLCBoKSA6IG51bGwsIG4gPSBsLmF1ZGlvICE9IG51bGwgPyBWaShsLmF1ZGlvLCByLCBoKSA6IG51bGw7XG4gIHJldHVybiBsLnZpZGVvID09IG51bGwgJiYgaC5lbWl0KFwiVmlkZW9SZWFkeVwiKSwgbC5hdWRpbyA9PSBudWxsICYmIGguZW1pdChcIkF1ZGlvUmVhZHlcIiksIHtcbiAgICBlbmNvZGVWaWRlbzogKHYsIGIpID0+IHtcbiAgICAgIHAgPT0gbnVsbCB8fCBwLmVuY29kZSh2LCBiKSwgdi5jbG9zZSgpO1xuICAgIH0sXG4gICAgZW5jb2RlQXVkaW86ICh2KSA9PiB7XG4gICAgICBuICE9IG51bGwgJiYgKG4uZW5jb2RlKHYpLCB2LmNsb3NlKCkpO1xuICAgIH0sXG4gICAgZ2V0RW5jb2RlUXVldWVTaXplOiAoKSA9PiAocCA9PSBudWxsID8gdm9pZCAwIDogcC5lbmNvZGVRdWV1ZVNpemUpID8/IChuID09IG51bGwgPyB2b2lkIDAgOiBuLmVuY29kZVF1ZXVlU2l6ZSkgPz8gMCxcbiAgICBmbHVzaDogYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBwID09IG51bGwgPyB2b2lkIDAgOiBwLmZsdXNoKCksXG4gICAgICAgIChuID09IG51bGwgPyB2b2lkIDAgOiBuLnN0YXRlKSA9PT0gXCJjb25maWd1cmVkXCIgPyBuLmZsdXNoKCkgOiBudWxsXG4gICAgICBdKTtcbiAgICB9LFxuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICBoLmRlc3Ryb3koKSwgcCA9PSBudWxsIHx8IHAuY2xvc2UoKSwgKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uc3RhdGUpID09PSBcImNvbmZpZ3VyZWRcIiAmJiBuLmNsb3NlKCk7XG4gICAgfSxcbiAgICBtcDRmaWxlOiByXG4gIH07XG59XG5mdW5jdGlvbiBIaShsLCByLCBoKSB7XG4gIGNvbnN0IGEgPSB7XG4gICAgdGltZXNjYWxlOiAxZTYsXG4gICAgd2lkdGg6IGwud2lkdGgsXG4gICAgaGVpZ2h0OiBsLmhlaWdodCxcbiAgICBicmFuZHM6IFtcImlzb21cIiwgXCJpc28yXCIsIFwiYXZjMVwiLCBcIm1wNDJcIiwgXCJtcDQxXCJdLFxuICAgIGF2Y0RlY29kZXJDb25maWdSZWNvcmQ6IG51bGwsXG4gICAgbmFtZTogXCJUcmFjayBjcmVhdGVkIHdpdGggV2ViQVZcIlxuICB9O1xuICBsZXQgZiA9IC0xLCBkID0gITE7XG4gIGgub25jZShcIkF1ZGlvUmVhZHlcIiwgKCkgPT4ge1xuICAgIGQgPSAhMDtcbiAgfSk7XG4gIGNvbnN0IHAgPSB7XG4gICAgZW5jb2RlcjA6IFtdLFxuICAgIGVuY29kZXIxOiBbXVxuICB9LCBuID0gKGMsIHUsIF8pID0+IHtcbiAgICB2YXIgZztcbiAgICBpZiAoZiA9PT0gLTEgJiYgXyAhPSBudWxsKSB7XG4gICAgICBjb25zdCB3ID0gKGcgPSBfLmRlY29kZXJDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBnLmRlc2NyaXB0aW9uO1xuICAgICAgWWkodyksIGEuYXZjRGVjb2RlckNvbmZpZ1JlY29yZCA9IHcsIGYgPSByLmFkZFRyYWNrKGEpLCBoLmVtaXQoXCJWaWRlb1JlYWR5XCIpLCB6LmluZm8oXCJWaWRlb0VuY29kZXIsIHZpZGVvIHRyYWNrIHJlYWR5LCB0cmFja0lkOlwiLCBmKTtcbiAgICB9XG4gICAgcFtjXS5wdXNoKFF0KHUpKTtcbiAgfTtcbiAgbGV0IHYgPSBcImVuY29kZXIxXCIsIGIgPSAwO1xuICBjb25zdCB5ID0gTWF0aC5mbG9vcigxZTMgLyBsLmV4cGVjdEZQUyAqIDFlMyk7XG4gIGZ1bmN0aW9uIEIoKSB7XG4gICAgaWYgKCFkKSByZXR1cm47XG4gICAgY29uc3QgYyA9IHYgPT09IFwiZW5jb2RlcjFcIiA/IFwiZW5jb2RlcjBcIiA6IFwiZW5jb2RlcjFcIiwgdSA9IHBbdl0sIF8gPSBwW2NdO1xuICAgIGlmICh1Lmxlbmd0aCA9PT0gMCAmJiBfLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGxldCBnID0gdVswXTtcbiAgICBpZiAoZyAhPSBudWxsICYmICghZy5pc19zeW5jIHx8IGcuY3RzIC0gYiA8IHkpKSB7XG4gICAgICBjb25zdCBTID0gdCh1KTtcbiAgICAgIFMgPiBiICYmIChiID0gUyk7XG4gICAgfVxuICAgIGNvbnN0IHcgPSBfWzBdO1xuICAgIGlmICh3ICE9IG51bGwgJiYgdy5pc19zeW5jICYmIHcuY3RzIC0gYiA8IHkpIHtcbiAgICAgIHYgPSBjLCBCKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChnICE9IG51bGwgJiYgZy5pc19zeW5jICYmICh3ICE9IG51bGwgJiYgdy5pc19zeW5jKSlcbiAgICAgIGlmIChnLmN0cyA8PSB3LmN0cykge1xuICAgICAgICBjb25zdCBTID0gdCh1KTtcbiAgICAgICAgUyA+IGIgJiYgKGIgPSBTKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSBjLCBCKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0KGMpIHtcbiAgICBsZXQgdSA9IC0xLCBfID0gMDtcbiAgICBmb3IgKDsgXyA8IGMubGVuZ3RoOyBfKyspIHtcbiAgICAgIGNvbnN0IGcgPSBjW19dO1xuICAgICAgaWYgKF8gPiAwICYmIGcuaXNfc3luYykgYnJlYWs7XG4gICAgICByLmFkZFNhbXBsZShmLCBnLmRhdGEsIGcpLCB1ID0gZy5jdHMgKyBnLmR1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gYy5zcGxpY2UoMCwgXyksIHU7XG4gIH1cbiAgY29uc3QgZSA9IERlKEIsIDE1KSwgaSA9IEFlKFxuICAgIGwsXG4gICAgKGMsIHUpID0+IG4oXCJlbmNvZGVyMFwiLCBjLCB1KVxuICApLCBzID0gQWUoXG4gICAgbCxcbiAgICAoYywgdSkgPT4gbihcImVuY29kZXIxXCIsIGMsIHUpXG4gICk7XG4gIGxldCBvID0gMDtcbiAgcmV0dXJuIHtcbiAgICBnZXQgZW5jb2RlUXVldWVTaXplKCkge1xuICAgICAgcmV0dXJuIGkuZW5jb2RlUXVldWVTaXplICsgcy5lbmNvZGVRdWV1ZVNpemU7XG4gICAgfSxcbiAgICBlbmNvZGU6IChjLCB1KSA9PiB7XG4gICAgICB1LmtleUZyYW1lICYmIChvICs9IDEpLCAobyAlIDIgPT09IDAgPyBpIDogcykuZW5jb2RlKGMsIHUpO1xuICAgIH0sXG4gICAgZmx1c2g6IGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgaS5zdGF0ZSA9PT0gXCJjb25maWd1cmVkXCIgPyBhd2FpdCBpLmZsdXNoKCkgOiBudWxsLFxuICAgICAgICBzLnN0YXRlID09PSBcImNvbmZpZ3VyZWRcIiA/IGF3YWl0IHMuZmx1c2goKSA6IG51bGxcbiAgICAgIF0pLCBlKCksIEIoKTtcbiAgICB9LFxuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICBpLnN0YXRlID09PSBcImNvbmZpZ3VyZWRcIiAmJiBpLmNsb3NlKCksIHMuc3RhdGUgPT09IFwiY29uZmlndXJlZFwiICYmIHMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBZaShsKSB7XG4gIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShsKTtcbiAgclsyXS50b1N0cmluZygyKS5zbGljZSgtMikuaW5jbHVkZXMoXCIxXCIpICYmIChyWzJdID0gMCk7XG59XG5mdW5jdGlvbiBBZShsLCByKSB7XG4gIGNvbnN0IGggPSBuZXcgVmlkZW9FbmNvZGVyKHtcbiAgICBlcnJvcjogei5lcnJvcixcbiAgICBvdXRwdXQ6IHJcbiAgfSk7XG4gIHJldHVybiBoLmNvbmZpZ3VyZSh7XG4gICAgY29kZWM6IGwuY29kZWMsXG4gICAgZnJhbWVyYXRlOiBsLmV4cGVjdEZQUyxcbiAgICBoYXJkd2FyZUFjY2VsZXJhdGlvbjogbC5fX3Vuc2FmZV9oYXJkd2FyZUFjY2VsZXJhdGlvbl9fLFxuICAgIGJpdHJhdGU6IGwuYml0cmF0ZSxcbiAgICB3aWR0aDogbC53aWR0aCxcbiAgICBoZWlnaHQ6IGwuaGVpZ2h0LFxuICAgIGFscGhhOiBcImRpc2NhcmRcIixcbiAgICBhdmM6IHsgZm9ybWF0OiBcImF2Y1wiIH1cbiAgfSksIGg7XG59XG5mdW5jdGlvbiBWaShsLCByLCBoKSB7XG4gIGNvbnN0IGEgPSB7XG4gICAgdGltZXNjYWxlOiAxZTYsXG4gICAgc2FtcGxlcmF0ZTogbC5zYW1wbGVSYXRlLFxuICAgIGNoYW5uZWxfY291bnQ6IGwuY2hhbm5lbENvdW50LFxuICAgIGhkbHI6IFwic291blwiLFxuICAgIHR5cGU6IGwuY29kZWMgPT09IFwiYWFjXCIgPyBcIm1wNGFcIiA6IFwiT3B1c1wiLFxuICAgIG5hbWU6IFwiVHJhY2sgY3JlYXRlZCB3aXRoIFdlYkFWXCJcbiAgfTtcbiAgbGV0IGYgPSAtMSwgZCA9IFtdLCBwID0gITE7XG4gIGgub25jZShcIlZpZGVvUmVhZHlcIiwgKCkgPT4ge1xuICAgIHAgPSAhMCwgZC5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBjb25zdCBiID0gUXQodik7XG4gICAgICByLmFkZFNhbXBsZShmLCBiLmRhdGEsIGIpO1xuICAgIH0pLCBkID0gW107XG4gIH0pO1xuICBjb25zdCBuID0gbmV3IEF1ZGlvRW5jb2Rlcih7XG4gICAgZXJyb3I6IHouZXJyb3IsXG4gICAgb3V0cHV0OiAodiwgYikgPT4ge1xuICAgICAgdmFyIHk7XG4gICAgICBpZiAoZiA9PT0gLTEpIHtcbiAgICAgICAgY29uc3QgQiA9ICh5ID0gYi5kZWNvZGVyQ29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogeS5kZXNjcmlwdGlvbjtcbiAgICAgICAgZiA9IHIuYWRkVHJhY2soe1xuICAgICAgICAgIC4uLmEsXG4gICAgICAgICAgZGVzY3JpcHRpb246IEIgPT0gbnVsbCA/IHZvaWQgMCA6ICRpKEIpXG4gICAgICAgIH0pLCBoLmVtaXQoXCJBdWRpb1JlYWR5XCIpLCB6LmluZm8oXCJBdWRpb0VuY29kZXIsIGF1ZGlvIHRyYWNrIHJlYWR5LCB0cmFja0lkOlwiLCBmKTtcbiAgICAgIH1cbiAgICAgIGlmIChwKSB7XG4gICAgICAgIGNvbnN0IEIgPSBRdCh2KTtcbiAgICAgICAgci5hZGRTYW1wbGUoZiwgQi5kYXRhLCBCKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBkLnB1c2godik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG4uY29uZmlndXJlKHtcbiAgICBjb2RlYzogbC5jb2RlYyA9PT0gXCJhYWNcIiA/IHEuY29kZWMgOiBcIm9wdXNcIixcbiAgICBzYW1wbGVSYXRlOiBsLnNhbXBsZVJhdGUsXG4gICAgbnVtYmVyT2ZDaGFubmVsczogbC5jaGFubmVsQ291bnQsXG4gICAgYml0cmF0ZTogMTI4ZTNcbiAgfSksIG47XG59XG5mdW5jdGlvbiBXaShsLCByLCBoKSB7XG4gIGxldCBhID0gMCwgZiA9IDA7XG4gIGNvbnN0IGQgPSBsLmJveGVzO1xuICBsZXQgcCA9ICExO1xuICBjb25zdCBuID0gKCkgPT4ge1xuICAgIHZhciBpO1xuICAgIGlmICghcClcbiAgICAgIGlmIChkLmZpbmQoKHMpID0+IHMudHlwZSA9PT0gXCJtb29mXCIpICE9IG51bGwpXG4gICAgICAgIHAgPSAhMDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGYgPj0gZC5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHQgPSBuZXcgRC5EYXRhU3RyZWFtKCk7XG4gICAgdC5lbmRpYW5uZXNzID0gRC5EYXRhU3RyZWFtLkJJR19FTkRJQU47XG4gICAgbGV0IGUgPSBmO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKDsgZSA8IGQubGVuZ3RoOyApXG4gICAgICAgIGRbZV0ud3JpdGUodCksIGRlbGV0ZSBkW2VdLCBlICs9IDE7XG4gICAgfSBjYXRjaCAocykge1xuICAgICAgY29uc3QgbyA9IGRbZV07XG4gICAgICB0aHJvdyBzIGluc3RhbmNlb2YgRXJyb3IgJiYgbyAhPSBudWxsID8gRXJyb3IoXG4gICAgICAgIGAke3MubWVzc2FnZX0gfCBkZWx0YUJ1ZiggYm94VHlwZTogJHtvLnR5cGV9LCBib3hTaXplOiAke28uc2l6ZX0sIGJveERhdGFMZW46ICR7KChpID0gby5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogaS5sZW5ndGgpID8/IC0xfSlgXG4gICAgICApIDogcztcbiAgICB9XG4gICAgcmV0dXJuIEFpKGwpLCBmID0gZC5sZW5ndGgsIG5ldyBVaW50OEFycmF5KHQuYnVmZmVyKTtcbiAgfTtcbiAgbGV0IHYgPSAhMSwgYiA9ICExLCB5ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydCh0KSB7XG4gICAgICAgIGEgPSBzZWxmLnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBlID0gbigpO1xuICAgICAgICAgIGUgIT0gbnVsbCAmJiAhYiAmJiB0LmVucXVldWUoZSk7XG4gICAgICAgIH0sIHIpLCB5ID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoY2xlYXJJbnRlcnZhbChhKSwgbC5mbHVzaCgpLCBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHQuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGkgPSBuKCk7XG4gICAgICAgICAgaSAhPSBudWxsICYmICFiICYmIHQuZW5xdWV1ZShpKSwgYiB8fCB0LmNsb3NlKCk7XG4gICAgICAgIH0sIHYgJiYgeSgpO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgYiA9ICEwLCBjbGVhckludGVydmFsKGEpLCBoID09IG51bGwgfHwgaCgpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIHN0b3A6ICh0KSA9PiB7XG4gICAgICB2IHx8ICh2ID0gITAsIHkgPT0gbnVsbCB8fCB5KHQpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBaaShsKSB7XG4gIGxldCByID0gMDtcbiAgY29uc3QgaCA9IGwuYm94ZXMsIGEgPSBbXTtcbiAgbGV0IGYgPSAwO1xuICBhc3luYyBmdW5jdGlvbiBkKCkge1xuICAgIGNvbnN0IGkgPSBlKGgsIHIpO1xuICAgIHIgPSBoLmxlbmd0aCwgYS5mb3JFYWNoKCh7IHRyYWNrOiBzLCBpZDogbyB9KSA9PiB7XG4gICAgICBjb25zdCBjID0gcy5zYW1wbGVzLmF0KC0xKTtcbiAgICAgIGMgIT0gbnVsbCAmJiAoZiA9IE1hdGgubWF4KGYsIGMuY3RzICsgYy5kdXJhdGlvbikpLCBsLnJlbGVhc2VVc2VkU2FtcGxlcyhvLCBzLnNhbXBsZXMubGVuZ3RoKSwgcy5zYW1wbGVzID0gW107XG4gICAgfSksIGwubWRhdHMgPSBbXSwgbC5tb29mcyA9IFtdLCBpICE9IG51bGwgJiYgYXdhaXQgKHkgPT0gbnVsbCA/IHZvaWQgMCA6IHkud3JpdGUoaSkpO1xuICB9XG4gIGxldCBwID0gW107XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgaWYgKHAubGVuZ3RoID4gMCkgcmV0dXJuICEwO1xuICAgIGNvbnN0IGkgPSBoLmZpbmRJbmRleCgocykgPT4gcy50eXBlID09PSBcIm1vb3ZcIik7XG4gICAgaWYgKGkgPT09IC0xKSByZXR1cm4gITE7XG4gICAgaWYgKHAgPSBoLnNsaWNlKDAsIGkgKyAxKSwgciA9IGkgKyAxLCBhLmxlbmd0aCA9PT0gMClcbiAgICAgIGZvciAobGV0IHMgPSAxOyA7IHMgKz0gMSkge1xuICAgICAgICBjb25zdCBvID0gbC5nZXRUcmFja0J5SWQocyk7XG4gICAgICAgIGlmIChvID09IG51bGwpIGJyZWFrO1xuICAgICAgICBhLnB1c2goeyB0cmFjazogbywgaWQ6IHMgfSk7XG4gICAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGxldCB2ID0gMDtcbiAgY29uc3QgYiA9IEt0KCk7XG4gIGxldCB5ID0gbnVsbDtcbiAgY29uc3QgQiA9IChhc3luYyAoKSA9PiB7XG4gICAgeSA9IGF3YWl0IGIuY3JlYXRlV3JpdGVyKCksIHYgPSBzZWxmLnNldEludGVydmFsKCgpID0+IHtcbiAgICAgIG4oKSAmJiBkKCk7XG4gICAgfSwgMTAwKTtcbiAgfSkoKTtcbiAgbGV0IHQgPSAhMTtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBpZiAodCkgdGhyb3cgRXJyb3IoXCJGaWxlIGV4cG9ydGVkXCIpO1xuICAgIGlmICh0ID0gITAsIGF3YWl0IEIsIGNsZWFySW50ZXJ2YWwodiksICFuKCkgfHwgeSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBsLmZsdXNoKCksIGF3YWl0IGQoKSwgYXdhaXQgKHkgPT0gbnVsbCA/IHZvaWQgMCA6IHkuY2xvc2UoKSk7XG4gICAgY29uc3QgaSA9IHAuZmluZCgoYykgPT4gYy50eXBlID09PSBcIm1vb3ZcIik7XG4gICAgaWYgKGkgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgaS5tdmhkLmR1cmF0aW9uID0gZjtcbiAgICBjb25zdCBzID0gS3QoKSwgbyA9IGUocCwgMCk7XG4gICAgcmV0dXJuIGF3YWl0IEN0KHMsIG8pLCBhd2FpdCBDdChzLCBiLCB7IG92ZXJ3cml0ZTogITEgfSksIGF3YWl0IHMuc3RyZWFtKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGUoaSwgcykge1xuICAgIGlmIChzID49IGkubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBvID0gbmV3IEQuRGF0YVN0cmVhbSgpO1xuICAgIG8uZW5kaWFubmVzcyA9IEQuRGF0YVN0cmVhbS5CSUdfRU5ESUFOO1xuICAgIGZvciAobGV0IGMgPSBzOyBjIDwgaS5sZW5ndGg7IGMrKylcbiAgICAgIGlbY10gIT09IG51bGwgJiYgKGlbY10ud3JpdGUobyksIGRlbGV0ZSBpW2NdKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoby5idWZmZXIpO1xuICB9XG59XG5mdW5jdGlvbiBRdChsKSB7XG4gIGNvbnN0IHIgPSBuZXcgQXJyYXlCdWZmZXIobC5ieXRlTGVuZ3RoKTtcbiAgbC5jb3B5VG8ocik7XG4gIGNvbnN0IGggPSBsLnRpbWVzdGFtcDtcbiAgcmV0dXJuIHtcbiAgICBkdXJhdGlvbjogbC5kdXJhdGlvbiA/PyAwLFxuICAgIGR0czogaCxcbiAgICBjdHM6IGgsXG4gICAgaXNfc3luYzogbC50eXBlID09PSBcImtleVwiLFxuICAgIGRhdGE6IHJcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIFhpKGwpIHtcbiAgY29uc3QgciA9IEQuY3JlYXRlRmlsZSgpLCBoID0gWmkocik7XG4gIGF3YWl0IGppKGwsIHIpO1xuICBjb25zdCBhID0gYXdhaXQgaCgpO1xuICBpZiAoYSA9PSBudWxsKSB0aHJvdyBFcnJvcihcIkNhbiBub3QgZ2VuZXJhdGUgZmlsZSBmcm9tIHN0cmVhbXNcIik7XG4gIHJldHVybiBhO1xufVxuYXN5bmMgZnVuY3Rpb24gamkobCwgcikge1xuICBsZXQgaCA9IDAsIGEgPSAwLCBmID0gMCwgZCA9IDAsIHAgPSAwLCBuID0gMCwgdiA9IG51bGwsIGIgPSBudWxsO1xuICBmb3IgKGNvbnN0IHkgb2YgbClcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShhc3luYyAoQikgPT4ge1xuICAgICAgZmUoeS5waXBlVGhyb3VnaChuZXcgY2UoKSksIHtcbiAgICAgICAgb25Eb25lOiBCLFxuICAgICAgICBvbkNodW5rOiBhc3luYyAoeyBjaHVua1R5cGU6IHQsIGRhdGE6IGUgfSkgPT4ge1xuICAgICAgICAgIGlmICh0ID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmlkZW9UcmFja0NvbmY6IGksIGF1ZGlvVHJhY2tDb25mOiBzIH0gPSBkZShcbiAgICAgICAgICAgICAgZS5maWxlLFxuICAgICAgICAgICAgICBlLmluZm9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoID09PSAwICYmIGkgIT0gbnVsbCAmJiAoaCA9IHIuYWRkVHJhY2soaSkpLCBkID09PSAwICYmIHMgIT0gbnVsbCAmJiAoZCA9IHIuYWRkVHJhY2socykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodCA9PT0gXCJzYW1wbGVzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZTogaSwgc2FtcGxlczogcyB9ID0gZSwgbyA9IGkgPT09IFwidmlkZW9cIiA/IGggOiBkLCBjID0gaSA9PT0gXCJ2aWRlb1wiID8gYSA6IHAsIHUgPSBpID09PSBcInZpZGVvXCIgPyBmIDogbjtcbiAgICAgICAgICAgIHMuZm9yRWFjaCgoZykgPT4ge1xuICAgICAgICAgICAgICByLmFkZFNhbXBsZShvLCBnLmRhdGEsIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogZy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBkdHM6IGcuZHRzICsgYyxcbiAgICAgICAgICAgICAgICBjdHM6IGcuY3RzICsgdSxcbiAgICAgICAgICAgICAgICBpc19zeW5jOiBnLmlzX3N5bmNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IF8gPSBzLmF0KC0xKTtcbiAgICAgICAgICAgIGlmIChfID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIGkgPT09IFwidmlkZW9cIiA/IHYgPSBfIDogaSA9PT0gXCJhdWRpb1wiICYmIChiID0gXyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgdiAhPSBudWxsICYmIChhICs9IHYuZHRzLCBmICs9IHYuY3RzKSwgYiAhPSBudWxsICYmIChwICs9IGIuZHRzLCBuICs9IGIuY3RzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFuKGwpIHtcbiAgcmV0dXJuIGF3YWl0IFhpKFtsXSk7XG59XG5mdW5jdGlvbiBLaShsKSB7XG4gIGxldCByID0gW107XG4gIGNvbnN0IGggPSBuZXcgQXVkaW9EZWNvZGVyKHtcbiAgICBvdXRwdXQ6IChhKSA9PiB7XG4gICAgICByLnB1c2goYSk7XG4gICAgfSxcbiAgICBlcnJvcjogei5lcnJvclxuICB9KTtcbiAgcmV0dXJuIGguY29uZmlndXJlKGwpLCB7XG4gICAgZGVjb2RlOiBhc3luYyAoYSkgPT4ge1xuICAgICAgYS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGguZGVjb2RlKFxuICAgICAgICAgIG5ldyBFbmNvZGVkQXVkaW9DaHVuayh7XG4gICAgICAgICAgICB0eXBlOiBkLmlzX3N5bmMgPyBcImtleVwiIDogXCJkZWx0YVwiLFxuICAgICAgICAgICAgdGltZXN0YW1wOiAxZTYgKiBkLmN0cyAvIGQudGltZXNjYWxlLFxuICAgICAgICAgICAgZHVyYXRpb246IDFlNiAqIGQuZHVyYXRpb24gLyBkLnRpbWVzY2FsZSxcbiAgICAgICAgICAgIGRhdGE6IGQuZGF0YVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KSwgYXdhaXQgaC5mbHVzaCgpO1xuICAgICAgY29uc3QgZiA9IHI7XG4gICAgICByZXR1cm4gciA9IFtdLCBmO1xuICAgIH0sXG4gICAgY2xvc2U6ICgpID0+IHtcbiAgICAgIGguY2xvc2UoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBRaShsLCByKSB7XG4gIGNvbnN0IGggPSBuZXcgQXVkaW9FbmNvZGVyKHtcbiAgICBvdXRwdXQ6IChkKSA9PiB7XG4gICAgICByKFF0KGQpKTtcbiAgICB9LFxuICAgIGVycm9yOiB6LmVycm9yXG4gIH0pO1xuICBoLmNvbmZpZ3VyZSh7XG4gICAgY29kZWM6IGwuY29kZWMsXG4gICAgc2FtcGxlUmF0ZTogbC5zYW1wbGVSYXRlLFxuICAgIG51bWJlck9mQ2hhbm5lbHM6IGwubnVtYmVyT2ZDaGFubmVsc1xuICB9KTtcbiAgbGV0IGEgPSBudWxsO1xuICBmdW5jdGlvbiBmKGQsIHApIHtcbiAgICByZXR1cm4gbmV3IEF1ZGlvRGF0YSh7XG4gICAgICB0aW1lc3RhbXA6IHAsXG4gICAgICBudW1iZXJPZkNoYW5uZWxzOiBsLm51bWJlck9mQ2hhbm5lbHMsXG4gICAgICBudW1iZXJPZkZyYW1lczogZC5sZW5ndGggLyBsLm51bWJlck9mQ2hhbm5lbHMsXG4gICAgICBzYW1wbGVSYXRlOiBsLnNhbXBsZVJhdGUsXG4gICAgICBmb3JtYXQ6IFwiZjMyLXBsYW5hclwiLFxuICAgICAgZGF0YTogZFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBhc3luYyAoZCwgcCkgPT4ge1xuICAgICAgYSAhPSBudWxsICYmIGguZW5jb2RlKGYoYS5kYXRhLCBhLnRzKSksIGEgPSB7IGRhdGE6IGQsIHRzOiBwIH07XG4gICAgfSxcbiAgICBzdG9wOiBhc3luYyAoKSA9PiB7XG4gICAgICBhICE9IG51bGwgJiYgKEppKGEuZGF0YSwgbC5udW1iZXJPZkNoYW5uZWxzLCBsLnNhbXBsZVJhdGUpLCBoLmVuY29kZShmKGEuZGF0YSwgYS50cykpLCBhID0gbnVsbCksIGF3YWl0IGguZmx1c2goKSwgaC5jbG9zZSgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIEppKGwsIHIsIGgpIHtcbiAgY29uc3QgYSA9IGwubGVuZ3RoIC0gMSwgZiA9IE1hdGgubWluKGggLyAyLCBhKTtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBmOyBkKyspXG4gICAgZm9yIChsZXQgcCA9IDE7IHAgPD0gcjsgcCsrKVxuICAgICAgbFtNYXRoLmZsb29yKGEgLyBwKSAtIGRdICo9IGQgLyBmO1xufVxuZnVuY3Rpb24gb24obCwgcikge1xuICB6LmluZm8oXCJtaXhpbk1QNEFuZEF1ZGlvLCBvcHRzOlwiLCB7XG4gICAgdm9sdW1lOiByLnZvbHVtZSxcbiAgICBsb29wOiByLmxvb3BcbiAgfSk7XG4gIGNvbnN0IGggPSBELmNyZWF0ZUZpbGUoKSwgeyBzdHJlYW06IGEsIHN0b3A6IGYgfSA9IFdpKGgsIDUwMCk7XG4gIGxldCBkID0gbnVsbCwgcCA9IG51bGwsIG4gPSBbXSwgdiA9IDAsIGIgPSAwLCB5ID0gMCwgQiA9ICEwLCB0ID0gNDhlMztcbiAgZmUobC5waXBlVGhyb3VnaChuZXcgY2UoKSksIHtcbiAgICBvbkRvbmU6IGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IChwID09IG51bGwgPyB2b2lkIDAgOiBwLnN0b3AoKSksIGQgPT0gbnVsbCB8fCBkLmNsb3NlKCksIGYoKTtcbiAgICB9LFxuICAgIG9uQ2h1bms6IGFzeW5jICh7IGNodW5rVHlwZTogbywgZGF0YTogYyB9KSA9PiB7XG4gICAgICBpZiAobyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgIGNvbnN0IHsgdmlkZW9UcmFja0NvbmY6IHUsIGF1ZGlvVHJhY2tDb25mOiBfLCBhdWRpb0RlY29kZXJDb25mOiBnIH0gPSBkZShjLmZpbGUsIGMuaW5mbyk7XG4gICAgICAgIHYgPT09IDAgJiYgdSAhPSBudWxsICYmICh2ID0gaC5hZGRUcmFjayh1KSk7XG4gICAgICAgIGNvbnN0IHcgPSBfID8/IHtcbiAgICAgICAgICB0aW1lc2NhbGU6IDFlNixcbiAgICAgICAgICBzYW1wbGVyYXRlOiB0LFxuICAgICAgICAgIGNoYW5uZWxfY291bnQ6IHEuY2hhbm5lbENvdW50LFxuICAgICAgICAgIGhkbHI6IFwic291blwiLFxuICAgICAgICAgIG5hbWU6IFwiU291bmRIYW5kbGVyXCIsXG4gICAgICAgICAgdHlwZTogXCJtcDRhXCJcbiAgICAgICAgfTtcbiAgICAgICAgYiA9PT0gMCAmJiAoYiA9IGguYWRkVHJhY2sodyksIHQgPSAoXyA9PSBudWxsID8gdm9pZCAwIDogXy5zYW1wbGVyYXRlKSA/PyB0LCBCID0gXyAhPSBudWxsKTtcbiAgICAgICAgY29uc3QgUyA9IG5ldyBBdWRpb0NvbnRleHQoeyBzYW1wbGVSYXRlOiB0IH0pO1xuICAgICAgICBuID0gT2UoXG4gICAgICAgICAgYXdhaXQgUy5kZWNvZGVBdWRpb0RhdGEoXG4gICAgICAgICAgICBhd2FpdCBuZXcgUmVzcG9uc2Uoci5zdHJlYW0pLmFycmF5QnVmZmVyKClcbiAgICAgICAgICApXG4gICAgICAgICksIGcgIT0gbnVsbCAmJiAoZCA9IEtpKGcpKSwgcCA9IFFpKFxuICAgICAgICAgIGcgPz8ge1xuICAgICAgICAgICAgY29kZWM6IHcudHlwZSA9PT0gXCJtcDRhXCIgPyBxLmNvZGVjIDogdy50eXBlLFxuICAgICAgICAgICAgbnVtYmVyT2ZDaGFubmVsczogdy5jaGFubmVsX2NvdW50LFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogdy5zYW1wbGVyYXRlXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoVSkgPT4gaC5hZGRTYW1wbGUoYiwgVS5kYXRhLCBVKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChvID09PSBcInNhbXBsZXNcIikge1xuICAgICAgICBjb25zdCB7IGlkOiB1LCB0eXBlOiBfLCBzYW1wbGVzOiBnIH0gPSBjO1xuICAgICAgICBpZiAoXyA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgICAgICAgZy5mb3JFYWNoKCh3KSA9PiBoLmFkZFNhbXBsZSh1LCB3LmRhdGEsIHcpKSwgQiB8fCBhd2FpdCBpKGcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfID09PSBcImF1ZGlvXCIgJiYgYXdhaXQgcyhnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBlKG8pIHtcbiAgICBjb25zdCBjID0gbi5tYXAoXG4gICAgICAodSkgPT4gci5sb29wID8gU2kodSwgeSwgeSArIG8pIDogdS5zbGljZSh5LCB5ICsgbylcbiAgICApO1xuICAgIGlmICh5ICs9IG8sIHIudm9sdW1lICE9PSAxKVxuICAgICAgZm9yIChjb25zdCB1IG9mIGMpXG4gICAgICAgIGZvciAobGV0IF8gPSAwOyBfIDwgdS5sZW5ndGg7IF8rKykgdVtfXSAqPSByLnZvbHVtZTtcbiAgICByZXR1cm4gYztcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBpKG8pIHtcbiAgICBjb25zdCBjID0gb1swXSwgdSA9IG9bby5sZW5ndGggLSAxXSwgXyA9IE1hdGguZmxvb3IoXG4gICAgICAodS5jdHMgKyB1LmR1cmF0aW9uIC0gYy5jdHMpIC8gdS50aW1lc2NhbGUgKiB0XG4gICAgKSwgZyA9IGJlKFtlKF8pXSk7XG4gICAgZy5sZW5ndGggIT09IDAgJiYgKHAgPT0gbnVsbCB8fCBwLmVuY29kZShcbiAgICAgIGcsXG4gICAgICBjLmN0cyAvIGMudGltZXNjYWxlICogMWU2XG4gICAgKSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcyhvKSB7XG4gICAgaWYgKGQgPT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IGMgPSAoYXdhaXQgZC5kZWNvZGUobykpLm1hcChcbiAgICAgIGxlXG4gICAgKSwgdSA9IG1pKGMpLCBfID0gZSh1WzBdLmxlbmd0aCksIGcgPSBvWzBdO1xuICAgIHAgPT0gbnVsbCB8fCBwLmVuY29kZShcbiAgICAgIGJlKFt1LCBfXSksXG4gICAgICBnLmN0cyAvIGcudGltZXNjYWxlICogMWU2XG4gICAgKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uICRpKGwpIHtcbiAgY29uc3QgciA9IGwuYnl0ZUxlbmd0aCwgaCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAwLFxuICAgIC8vIHZlcnNpb24gMFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIC8vIGZsYWdzXG4gICAgMyxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAyMyArIHIsXG4gICAgLy8gbGVuZ3RoXG4gICAgMCxcbiAgICAvLyAweDAxLCAvLyBlc19pZFxuICAgIDIsXG4gICAgLy8gZXNfaWRcbiAgICAwLFxuICAgIC8vIHN0cmVhbV9wcmlvcml0eVxuICAgIDQsXG4gICAgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgMTggKyByLFxuICAgIC8vIGxlbmd0aFxuICAgIDY0LFxuICAgIC8vIGNvZGVjIDogbXBlZzRfYXVkaW9cbiAgICAyMSxcbiAgICAvLyBzdHJlYW1fdHlwZVxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIC8vIGJ1ZmZlcl9zaXplXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAvLyBtYXhCaXRyYXRlXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAvLyBhdmdCaXRyYXRlXG4gICAgNSxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICByLFxuICAgIC4uLm5ldyBVaW50OEFycmF5KGwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGwgOiBsLmJ1ZmZlciksXG4gICAgNixcbiAgICAxLFxuICAgIDJcbiAgXSksIGEgPSBuZXcgRC5Cb3hQYXJzZXIuZXNkc0JveChoLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gYS5oZHJfc2l6ZSA9IDAsIGEucGFyc2UobmV3IEQuRGF0YVN0cmVhbShoLCAwLCBELkRhdGFTdHJlYW0uQklHX0VORElBTikpLCBhO1xufVxuZXhwb3J0IHtcbiAgcSBhcyBERUZBVUxUX0FVRElPX0NPTkYsXG4gIFJpIGFzIEV2ZW50VG9vbCxcbiAgeiBhcyBMb2csXG4gIHNuIGFzIE1QNENsaXAsXG4gIGVuIGFzIGFkanVzdEF1ZGlvRGF0YVZvbHVtZSxcbiAgYmkgYXMgYXVkaW9SZXNhbXBsZSxcbiAgZmUgYXMgYXV0b1JlYWRTdHJlYW0sXG4gIE1lIGFzIGNvbmNhdEZsb2F0MzJBcnJheSxcbiAgbWkgYXMgY29uY2F0UENNRnJhZ21lbnRzLFxuICBWZSBhcyBjcmVhdGVFbCxcbiAgbm4gYXMgZGVjb2RlSW1nLFxuICBPZSBhcyBleHRyYWN0UENNNEF1ZGlvQnVmZmVyLFxuICBsZSBhcyBleHRyYWN0UENNNEF1ZGlvRGF0YSxcbiAgWGkgYXMgZmFzdENvbmNhdE1QNCxcbiAgV2kgYXMgZmlsZTJzdHJlYW0sXG4gIGFuIGFzIGZpeEZNUDREdXJhdGlvbixcbiAgb24gYXMgbWl4aW5NUDRBbmRBdWRpbyxcbiAgYmUgYXMgbWl4aW5QQ00sXG4gIHJuIGFzIHJlY29kZW11eCxcbiAgV2UgYXMgcmVuZGVyVHh0MkltZyxcbiAgdG4gYXMgcmVuZGVyVHh0MkltZ0JpdG1hcCxcbiAgU2kgYXMgcmluZ1NsaWNlRmxvYXQzMkFycmF5LFxuICBEZSBhcyB3b3JrZXJUaW1lclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyYW1lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@designcombo/frames/dist/frames.js\n"));

/***/ })

}]);